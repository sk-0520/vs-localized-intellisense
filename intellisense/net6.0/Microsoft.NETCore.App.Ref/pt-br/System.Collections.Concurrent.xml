<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Collections.Concurrent</name>
  </assembly>
  <members>
    <member name="T:System.Collections.Concurrent.BlockingCollection`1">
      <summary>Fornece funcionalidades de bloqueio e delimitação para coleções thread-safe que implementam <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</summary>
      <typeparam name="T">O tipo dos elementos na coleção.</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.#ctor">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> sem um limite superior.</summary>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> sem um limite superior e usando a <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> fornecida como seu armazenamento de dados subjacente.</summary>
      <param name="collection">A coleção a ser usada como armazenamento de dados subjacente.</param>
      <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collection" /> é nulo.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> com o limite superior especificado e usando a <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> fornecida como seu repositório de dados subjacente.</summary>
      <param name="collection">A coleção a ser usada como armazenamento de dados subjacente.</param>
      <param name="boundedCapacity">O tamanho limitado da coleção.</param>
      <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collection" /> é nulo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">O <paramref name="boundedCapacity" /> não é um valor positivo.</exception>
      <exception cref="T:System.ArgumentException">A <paramref name="collection" /> fornecida contém mais valores que o permitido pela <paramref name="boundedCapacity" />.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Int32)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> com o limite superior especificado.</summary>
      <param name="boundedCapacity">O tamanho limitado da coleção.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">O <paramref name="boundedCapacity" /> não é um valor positivo.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
      <summary>Adiciona o item ao <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <param name="item">O item a ser adicionado à coleção. O valor pode ser uma referência nula.</param>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
      <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi marcado como concluído com relação a adições.  
  
- ou - 
A coleção subjacente não aceitou o item.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
      <summary>Adiciona o item ao <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <param name="item">O item a ser adicionado à coleção. O valor pode ser uma referência nula.</param>
      <param name="cancellationToken">Um token de cancelamento a ser observado.</param>
      <exception cref="T:System.OperationCanceledException">Se o padrão <see cref="T:System.Threading.CancellationToken" /> for cancelado.</exception>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado ou o <see cref="T:System.Threading.CancellationTokenSource" /> que possui o <paramref name="cancellationToken" /> foi descartado.</exception>
      <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi marcado como concluído com relação a adições.  
  
- ou - 
A coleção subjacente não aceitou o item.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
      <summary>Adiciona o item especificado a qualquer uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas.</summary>
      <param name="collections">A matriz de coleções.</param>
      <param name="item">O item a ser adicionado a uma das coleções.</param>
      <exception cref="T:System.ObjectDisposedException">Pelo menos uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartada.</exception>
      <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collections" /> é nulo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">A contagem de <paramref name="collections" /> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</exception>
      <exception cref="T:System.ArgumentException">O argumento <paramref name="collections" /> é uma matriz de tamanho 0 ou contém um elemento nulo, ou pelo menos uma das coleções foi marcada como completa para adição.</exception>
      <exception cref="T:System.InvalidOperationException">Pelo menos uma coleção subjacente não aceitou o item.</exception>
      <returns>O índice da coleção na matriz <paramref name="collections" /> na qual o item foi adicionado.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
      <summary>Adiciona o item especificado a qualquer uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas.</summary>
      <param name="collections">A matriz de coleções.</param>
      <param name="item">O item a ser adicionado a uma das coleções.</param>
      <param name="cancellationToken">Um token de cancelamento a ser observado.</param>
      <exception cref="T:System.OperationCanceledException">Se o padrão <see cref="T:System.Threading.CancellationToken" /> for cancelado.</exception>
      <exception cref="T:System.InvalidOperationException">Pelo menos uma coleção subjacente não aceitou o item.</exception>
      <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collections" /> é nulo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">A contagem de <paramref name="collections" /> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</exception>
      <exception cref="T:System.ArgumentException">O argumento <paramref name="collections" /> é uma matriz de tamanho 0 ou contém um elemento nulo, ou pelo menos uma das coleções foi marcada como completa para adição.</exception>
      <exception cref="T:System.ObjectDisposedException">Pelo menos uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartada ou o <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> foi descartado.</exception>
      <returns>O índice da coleção na matriz <paramref name="collections" /> na qual o item foi adicionado.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding">
      <summary>Marca que as instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> não estão mais aceitando nenhuma adição.</summary>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
      <summary>Copia todos os itens da instância <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> para uma matriz unidimensional compatível, iniciando no índice especificado da matriz de destino.</summary>
      <param name="array">A matriz unidimensional que é o destino dos elementos copiados da instância <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />. A matriz deve ter indexação com base em zero.</param>
      <param name="index">O índice com base em zero em <paramref name="array" /> no qual a cópia começa.</param>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
      <exception cref="T:System.ArgumentNullException">O argumento <paramref name="array" /> é nulo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="index" /> é menor que zero.</exception>
      <exception cref="T:System.ArgumentException">O argumento <paramref name="index" /> é igual ou maior que o comprimento da <paramref name="array" />.  
  
A matriz de destino é muito pequena para conter todos os elementos de BlockingCollection.  
  
A classificação da matriz não corresponde.  
  
O tipo de matriz é incompatível com o tipo dos elementos de BlockingCollection.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
      <summary>Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.Dispose(System.Boolean)">
      <summary>Libera os recursos usados pela instância <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <param name="disposing">Se está sendo descartado explicitamente (true) ou devido a um finalizador (false).</param>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable">
      <summary>Fornece um consumindo <see cref="T:System.Collections.Generic.IEnumerator`1" /> para itens na coleção.</summary>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
      <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que remove e retorna os itens da coleção.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
      <summary>Fornece um consumindo <see cref="T:System.Collections.Generic.IEnumerable`1" /> para itens na coleção.</summary>
      <param name="cancellationToken">Um token de cancelamento a ser observado.</param>
      <exception cref="T:System.OperationCanceledException">Se o padrão <see cref="T:System.Threading.CancellationToken" /> for cancelado.</exception>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado ou o <see cref="T:System.Threading.CancellationTokenSource" /> que criou o <paramref name="cancellationToken" /> foi descartado</exception>
      <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que remove e retorna os itens da coleção.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
      <summary>Fornece um <see cref="T:System.Collections.Generic.IEnumerator`1" /> para itens na coleção.</summary>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
      <returns>Um <see cref="T:System.Collections.Generic.IEnumerator`1" /> para os itens na coleção.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <summary>Copia todos os itens da instância <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> para uma matriz unidimensional compatível, iniciando no índice especificado da matriz de destino.</summary>
      <param name="array">A matriz unidimensional que é o destino dos elementos copiados da instância <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />. A matriz deve ter indexação com base em zero.</param>
      <param name="index">O índice com base em zero em <paramref name="array" /> no qual a cópia começa.</param>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
      <exception cref="T:System.ArgumentNullException">O argumento <paramref name="array" /> é nulo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="index" /> é menor que zero.</exception>
      <exception cref="T:System.ArgumentException">O argumento <paramref name="index" /> é igual ou maior que o comprimento da <paramref name="array" />, a matriz é multidimensional ou o parâmetro de tipo para a coleção não pode ser convertido automaticamente no tipo da matriz de destino.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>Fornece um <see cref="T:System.Collections.IEnumerator" /> para itens na coleção.</summary>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
      <returns>Um <see cref="T:System.Collections.IEnumerator" /> para os itens na coleção.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.Take">
      <summary>Remove um item do <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
      <exception cref="T:System.InvalidOperationException">A coleção subjacente foi modificada fora desta instância de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> ou o <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> está vazio e a coleção foi marcada como concluída para adição.</exception>
      <exception cref="T:System.OperationCanceledException">A <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> está vazia e foi marcada como concluída com relação a adições.</exception>
      <returns>O item removido da coleção.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
      <summary>Remove um item do <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <param name="cancellationToken">Objeto que pode ser usado para cancelar a operação take.</param>
      <exception cref="T:System.OperationCanceledException">O <see cref="T:System.Threading.CancellationToken" /> está cancelado.</exception>
      <exception cref="T:System.ObjectDisposedException">A <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartada ou a <see cref="T:System.Threading.CancellationTokenSource" /> que criou o token foi cancelada.</exception>
      <exception cref="T:System.InvalidOperationException">A coleção subjacente foi modificada fora desta instância de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> ou a BlockingCollection está marcada como concluída para adicionar ou a <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> está vazia.</exception>
      <returns>O item removido da coleção.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
      <summary>Toma um item de qualquer uma das instâncias <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas.</summary>
      <param name="collections">A matriz de coleções.</param>
      <param name="item">O item removido de uma das coleções.</param>
      <exception cref="T:System.ObjectDisposedException">Pelo menos uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartada.</exception>
      <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collections" /> é nulo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">A contagem de <paramref name="collections" /> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</exception>
      <exception cref="T:System.ArgumentException">O argumento <paramref name="collections" /> é uma matriz de tamanho 0 ou contém um elemento nulo ou <see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /> foi chamado na coleção.</exception>
      <exception cref="T:System.InvalidOperationException">Pelo menos uma das coleções subjacentes foi alterada fora da instância de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns>O índice da coleção na matriz <paramref name="collections" /> da qual o item foi removido.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
      <summary>Recebe um item de qualquer uma das instâncias <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas, observando ao mesmo tempo o token de cancelamento especificado.</summary>
      <param name="collections">A matriz de coleções.</param>
      <param name="item">O item removido de uma das coleções.</param>
      <param name="cancellationToken">Um token de cancelamento a ser observado.</param>
      <exception cref="T:System.OperationCanceledException">Se o padrão <see cref="T:System.Threading.CancellationToken" /> for cancelado.</exception>
      <exception cref="T:System.InvalidOperationException">Pelo menos uma das coleções subjacentes foi alterada fora da instância de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collections" /> é nulo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">A contagem de <paramref name="collections" /> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</exception>
      <exception cref="T:System.ArgumentException">O argumento <paramref name="collections" /> é uma matriz de comprimento zero ou contém um elemento nulo, ou <see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /> foi chamado na coleção.</exception>
      <exception cref="T:System.ObjectDisposedException">Pelo menos uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartada.</exception>
      <returns>O índice da coleção na matriz <paramref name="collections" /> da qual o item foi removido.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.ToArray">
      <summary>Copia os itens da instância <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> em uma nova matriz.</summary>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
      <returns>Uma matriz que contém cópias dos elementos da coleção.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
      <summary>Tenta adicionar o item especificado ao <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <param name="item">O item a ser adicionado à coleção.</param>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
      <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi marcado como concluído com relação a adições.  
  
- ou - 
A coleção subjacente não aceitou o item.</exception>
      <returns>
        <see langword="true" /> se <paramref name="item" /> pôde ser adicionado; caso contrário, <see langword="false" />. Se o item for duplicado e a coleção subjacente não aceitar itens duplicados, será gerada uma <see cref="T:System.InvalidOperationException" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
      <summary>Tenta adicionar o item especificado à <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> dentro do período de tempo especificado.</summary>
      <param name="item">O item a ser adicionado à coleção.</param>
      <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
      <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi marcado como concluído com relação a adições.  
  
- ou - 
A coleção subjacente não aceitou o item.</exception>
      <returns>
        <see langword="true" /> se o <paramref name="item" /> puder ser adicionado à coleção dentro do tempo especificado, caso contrário, false. Se o item for duplicado e a coleção subjacente não aceitar itens duplicados, será gerada uma <see cref="T:System.InvalidOperationException" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
      <summary>Tenta adicionar o item especificado ao <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> no período especificado, enquanto observa um token de cancelamento.</summary>
      <param name="item">O item a ser adicionado à coleção.</param>
      <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
      <param name="cancellationToken">Um token de cancelamento a ser observado.</param>
      <exception cref="T:System.OperationCanceledException">Se o padrão <see cref="T:System.Threading.CancellationToken" /> for cancelado.</exception>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado ou o <see cref="T:System.Threading.CancellationTokenSource" /> subjacente foi descartado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
      <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi marcado como concluído com relação a adições.  
  
- ou - 
A coleção subjacente não aceitou o item.</exception>
      <returns>
        <see langword="true" /> se o <paramref name="item" /> puder ser adicionado à coleção dentro do tempo especificado, caso contrário, false. Se o item for duplicado e a coleção subjacente não aceitar itens duplicados, será gerada uma <see cref="T:System.InvalidOperationException" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
      <summary>Tenta adicionar o item especificado ao <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <param name="item">O item a ser adicionado à coleção.</param>
      <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> é um número negativo diferente de -1 milissegundos, que representa um tempo limite infinito ou o tempo limite é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi marcado como concluído com relação a adições.  
  
- ou - 
A coleção subjacente não aceitou o item.</exception>
      <returns>
        <see langword="true" /> se o <paramref name="item" /> puder ser adicionado à coleção dentro do tempo especificado, caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
      <summary>Tenta adicionar o item especificado a qualquer uma das instâncias <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas.</summary>
      <param name="collections">A matriz de coleções.</param>
      <param name="item">O item a ser adicionado a uma das coleções.</param>
      <exception cref="T:System.ObjectDisposedException">Pelo menos uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartada.</exception>
      <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collections" /> é nulo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">A contagem de <paramref name="collections" /> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</exception>
      <exception cref="T:System.ArgumentException">O argumento <paramref name="collections" /> é uma matriz de tamanho 0 ou contém um elemento nulo, ou pelo menos uma das coleções foi marcada como completa para adição.</exception>
      <exception cref="T:System.InvalidOperationException">Pelo menos uma coleção subjacente não aceitou o item.</exception>
      <returns>O índice da coleção na matriz <paramref name="collections" /> ao qual o item foi adicionado ou -1 caso o item não possa ser adicionado.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
      <summary>Tenta adicionar o item especificado a qualquer uma das instâncias <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas.</summary>
      <param name="collections">A matriz de coleções.</param>
      <param name="item">O item a ser adicionado a uma das coleções.</param>
      <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
      <exception cref="T:System.ObjectDisposedException">Pelo menos uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartada.</exception>
      <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collections" /> é nulo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito. 
- ou - 
A contagem de <paramref name="collections" /> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</exception>
      <exception cref="T:System.ArgumentException">O argumento <paramref name="collections" /> é uma matriz de tamanho 0 ou contém um elemento nulo, ou pelo menos uma das coleções foi marcada como completa para adição.</exception>
      <exception cref="T:System.InvalidOperationException">Pelo menos uma coleção subjacente não aceitou o item.</exception>
      <returns>O índice da coleção na matriz <paramref name="collections" /> ao qual o item foi adicionado ou -1 caso o item não possa ser adicionado.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
      <summary>Tenta adicionar o item especificado a qualquer uma das instâncias <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas.</summary>
      <param name="collections">A matriz de coleções.</param>
      <param name="item">O item a ser adicionado a uma das coleções.</param>
      <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
      <param name="cancellationToken">Um token de cancelamento a ser observado.</param>
      <exception cref="T:System.OperationCanceledException">Se o padrão <see cref="T:System.Threading.CancellationToken" /> for cancelado.</exception>
      <exception cref="T:System.InvalidOperationException">Pelo menos uma coleção subjacente não aceitou o item.</exception>
      <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collections" /> é nulo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito. 
- ou - 
A contagem de <paramref name="collections" /> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</exception>
      <exception cref="T:System.ArgumentException">O argumento <paramref name="collections" /> é uma matriz de tamanho 0 ou contém um elemento nulo, ou pelo menos uma das coleções foi marcada como completa para adição.</exception>
      <exception cref="T:System.ObjectDisposedException">Pelo menos uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartada.</exception>
      <returns>O índice da coleção na matriz <paramref name="collections" /> ao qual o item foi adicionado ou -1 caso o item não possa ser adicionado.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
      <summary>Tenta adicionar o item especificado a qualquer uma das instâncias <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas, observando ao mesmo tempo o token de cancelamento especificado.</summary>
      <param name="collections">A matriz de coleções.</param>
      <param name="item">O item a ser adicionado a uma das coleções.</param>
      <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
      <exception cref="T:System.ObjectDisposedException">Pelo menos uma das instâncias <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> ou o <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> foi descartado.</exception>
      <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collections" /> é nulo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> é um número negativo diferente de -1 milissegundos, que representa um tempo limite infinito ou o tempo limite é maior que <see cref="F:System.Int32.MaxValue" />.  
  
- ou - 
A contagem de <paramref name="collections" /> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</exception>
      <exception cref="T:System.ArgumentException">O argumento <paramref name="collections" /> é uma matriz de tamanho 0 ou contém um elemento nulo, ou pelo menos uma das coleções foi marcada como completa para adição.</exception>
      <exception cref="T:System.InvalidOperationException">Pelo menos uma coleção subjacente não aceitou o item.</exception>
      <returns>O índice da coleção na matriz <paramref name="collections" /> ao qual o item foi adicionado ou -1 caso o item não possa ser adicionado.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
      <summary>Tenta remover um item no <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <param name="item">O item a ser removido da coleção.</param>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
      <exception cref="T:System.InvalidOperationException">A coleção subjacente foi alterada fora da instância de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns>
        <see langword="true" /> se um item pode ser removido; Caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
      <summary>Tenta remover um item do <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> no período de tempo especificado.</summary>
      <param name="item">O item a ser removido da coleção.</param>
      <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
      <exception cref="T:System.InvalidOperationException">A coleção subjacente foi alterada fora da instância de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns>
        <see langword="true" /> se um item puder ser removido da coleção dentro do tempo especificado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
      <summary>Tenta remover um item do <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> no período especificado, enquanto observa um token de cancelamento.</summary>
      <param name="item">O item a ser removido da coleção.</param>
      <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
      <param name="cancellationToken">Um token de cancelamento a ser observado.</param>
      <exception cref="T:System.OperationCanceledException">O <see cref="T:System.Threading.CancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado ou o <see cref="T:System.Threading.CancellationTokenSource" /> subjacente foi descartado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
      <exception cref="T:System.InvalidOperationException">A coleção subjacente foi alterada fora da dessa instância de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns>
        <see langword="true" /> se um item puder ser removido da coleção dentro do tempo especificado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
      <summary>Tenta remover um item do <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> no período de tempo especificado.</summary>
      <param name="item">O item a ser removido da coleção.</param>
      <param name="timeout">Um objeto que representa o número de milissegundos de espera ou um objeto que representa -1 milissegundos para esperar por tempo indeterminado.</param>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito. 
- ou - 
 <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException">A coleção subjacente foi alterada fora da instância de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns>
        <see langword="true" /> se um item puder ser removido da coleção dentro do tempo especificado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
      <summary>Tenta remover um item de qualquer uma das instâncias <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas.</summary>
      <param name="collections">A matriz de coleções.</param>
      <param name="item">O item removido de uma das coleções.</param>
      <exception cref="T:System.ObjectDisposedException">Pelo menos uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartada.</exception>
      <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collections" /> é nulo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">A contagem de <paramref name="collections" /> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</exception>
      <exception cref="T:System.ArgumentException">O argumento <paramref name="collections" /> é uma matriz de tamanho 0 ou contém um elemento nulo.</exception>
      <exception cref="T:System.InvalidOperationException">Pelo menos uma das coleções subjacentes foi alterada fora da instância de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns>O índice da coleção na matriz <paramref name="collections" /> da qual o item foi removido ou -1 caso um item não possa ser removido.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
      <summary>Tenta remover um item de qualquer uma das instâncias <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas.</summary>
      <param name="collections">A matriz de coleções.</param>
      <param name="item">O item removido de uma das coleções.</param>
      <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
      <exception cref="T:System.ObjectDisposedException">Pelo menos uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartada.</exception>
      <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collections" /> é nulo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito. 
- ou - 
A contagem de <paramref name="collections" /> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</exception>
      <exception cref="T:System.ArgumentException">O argumento <paramref name="collections" /> é uma matriz de tamanho 0 ou contém um elemento nulo.</exception>
      <exception cref="T:System.InvalidOperationException">Pelo menos uma das coleções subjacentes foi alterada fora da instância de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns>O índice da coleção na matriz <paramref name="collections" /> da qual o item foi removido ou -1 caso um item não possa ser removido.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
      <summary>Tenta remover um item de qualquer uma das instâncias <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas.</summary>
      <param name="collections">A matriz de coleções.</param>
      <param name="item">O item removido de uma das coleções.</param>
      <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
      <param name="cancellationToken">Um token de cancelamento a ser observado.</param>
      <exception cref="T:System.OperationCanceledException">Se o padrão <see cref="T:System.Threading.CancellationToken" /> for cancelado.</exception>
      <exception cref="T:System.InvalidOperationException">Pelo menos uma das coleções subjacentes foi alterada fora da instância de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collections" /> é nulo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito. 
- ou - 
A contagem de <paramref name="collections" /> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</exception>
      <exception cref="T:System.ArgumentException">O argumento <paramref name="collections" /> é uma matriz de tamanho 0 ou contém um elemento nulo.</exception>
      <exception cref="T:System.ObjectDisposedException">Pelo menos uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartada.</exception>
      <returns>O índice da coleção na matriz <paramref name="collections" /> da qual o item foi removido ou -1 caso um item não possa ser removido.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
      <summary>Tenta remover um item de qualquer uma das instâncias <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas.</summary>
      <param name="collections">A matriz de coleções.</param>
      <param name="item">O item removido de uma das coleções.</param>
      <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
      <exception cref="T:System.ObjectDisposedException">Pelo menos uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartada.</exception>
      <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collections" /> é nulo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> é um número negativo diferente de -1 milissegundos, que representa um tempo limite infinito ou o tempo limite é maior que <see cref="F:System.Int32.MaxValue" />.  
  
- ou - 
A contagem de <paramref name="collections" /> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</exception>
      <exception cref="T:System.ArgumentException">O argumento <paramref name="collections" /> é uma matriz de tamanho 0 ou contém um elemento nulo.</exception>
      <exception cref="T:System.InvalidOperationException">Pelo menos uma das coleções subjacentes foi alterada fora da instância de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
      <returns>O índice da coleção na matriz <paramref name="collections" /> da qual o item foi removido ou -1 caso um item não possa ser removido.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.BlockingCollection`1.BoundedCapacity">
      <summary>Obtém a capacidade limitada dessa instância <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
      <returns>A capacidade limitada dessa coleção ou int.MaxValue, se nenhum limite tiver sido fornecido.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.BlockingCollection`1.Count">
      <summary>Obtém o número de itens contidos no <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
      <returns>O número de itens contidos no <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.BlockingCollection`1.IsAddingCompleted">
      <summary>Obtém se esta <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi marcada como completa para adição.</summary>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
      <returns>Se esta coleção foi marcada como completa para adição.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.BlockingCollection`1.IsCompleted">
      <summary>Obtém se esta <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi marcada como completa para a adição e está vazia.</summary>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
      <returns>Se esta coleção foi marcada como completa para a adição e está vazia.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#IsSynchronized">
      <summary>Obtém um valor que indica se o acesso à <see cref="T:System.Collections.ICollection" /> é sincronizado (thread-safe).</summary>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
      <returns>Sempre retorna <see langword="false" /> para indicar que o acesso não está sincronizado.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#SyncRoot">
      <summary>Obtém um objeto que pode ser usado para sincronizar o acesso ao <see cref="T:System.Collections.ICollection" />. Não há suporte a esta propriedade.</summary>
      <exception cref="T:System.NotSupportedException">Não há suporte para a propriedade SyncRoot.</exception>
      <returns>Retorna <see langword="null" />.</returns>
    </member>
    <member name="T:System.Collections.Concurrent.ConcurrentBag`1">
      <summary>Representa uma coleção thread-safe não classificada de objetos.</summary>
      <typeparam name="T">O tipo dos elementos a serem armazenados na coleção.</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.#ctor">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> que contém elementos copiados da coleção especificada.</summary>
      <param name="collection">A coleção cujos elementos são copiados para o novo <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> é uma referência nula (Nada no Visual Basic).</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.Add(`0)">
      <summary>Adiciona um objeto ao <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</summary>
      <param name="item">O objeto a ser adicionado ao <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />. O valor pode ser uma referência nula (Nada no Visual Basic) para tipos de referência.</param>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.Clear">
      <summary>Remove todos os valores do <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.CopyTo(`0[],System.Int32)">
      <summary>Copia os elementos <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> em um <see cref="T:System.Array" /> unidimensional existente, começando no índice da matriz especificado.</summary>
      <param name="array">Um <see cref="T:System.Array" /> unidimensional que é o destino dos elementos copiados do <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />. O <see cref="T:System.Array" /> deve ter indexação com base em zero.</param>
      <param name="index">O índice com base em zero em <paramref name="array" /> no qual a cópia começa.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> é uma referência nula (Nada no Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> é menor que zero.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="index" /> é igual ou maior que o tamanho do <paramref name="array" /> -ou- o número de elementos no <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> de origem é maior que o espaço disponível do <paramref name="index" /> até o fim do <paramref name="array" /> de destino.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.GetEnumerator">
      <summary>Retorna um enumerador que itera por meio de <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</summary>
      <returns>Um enumerador para o conteúdo de <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryAdd(`0)">
      <summary>Tenta adicionar um objeto ao <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</summary>
      <param name="item">O objeto a ser adicionado ao <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />. O valor pode ser uma referência nula (Nada no Visual Basic) para tipos de referência.</param>
      <returns>Sempre retorna verdadeiro</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <summary>Copia os elementos do <see cref="T:System.Collections.ICollection" /> para um <see cref="T:System.Array" />, começando em um determinado índice <see cref="T:System.Array" />.</summary>
      <param name="array">Um <see cref="T:System.Array" /> unidimensional que é o destino dos elementos copiados do <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />. O <see cref="T:System.Array" /> deve ter indexação com base em zero.</param>
      <param name="index">O índice com base em zero em <paramref name="array" /> no qual a cópia começa.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> é uma referência nula (Nada no Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> é menor que zero.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" /> é multidimensional. -ou- O <paramref name="array" /> não deve ter indexação baseada em zero. -ou- <paramref name="index" /> é igual ou maior que o tamanho da <paramref name="array" /> -ou- O número de elementos no <see cref="T:System.Collections.ICollection" /> de origem é maior que o espaço disponível do <paramref name="index" /> até o fim da <paramref name="array" /> de destino. -ou- O tipo do <see cref="T:System.Collections.ICollection" /> de origem não pode ser convertido automaticamente no tipo do <paramref name="array" /> de destino.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera por meio de <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</summary>
      <returns>Um enumerador para o conteúdo de <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.ToArray">
      <summary>Copia os elementos do <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> em uma nova matriz.</summary>
      <returns>Uma nova matriz que contém um instantâneo dos elementos copiados de <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.TryPeek(`0@)">
      <summary>Tenta retornar um objeto do <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> sem removê-lo.</summary>
      <param name="result">Quando o método for retornado, <paramref name="result" /> conterá um objeto do <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> ou o valor padrão de <typeparamref name="T" /> se a operação falhar.</param>
      <returns>
        <see langword="true" /> se um objeto foi retornado com sucesso, caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.TryTake(`0@)">
      <summary>Tenta remover e retornar um objeto do <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</summary>
      <param name="result">Quando este método retornar, <paramref name="result" /> conterá o objeto removido do <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> ou o valor padrão de <typeparamref name="T" /> se o multiconjunto estiver vazio.</param>
      <returns>
        <see langword="true" /> se um objeto tiver sido removido com êxito; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentBag`1.Count">
      <summary>Obtém o número de elementos contidos no <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</summary>
      <returns>O número de elementos contidos no <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentBag`1.IsEmpty">
      <summary>Obtém um valor que indica se a <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> está vazia.</summary>
      <returns>
        <see langword="true" /> se o <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> estiver vazio; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentBag`1.System#Collections#ICollection#IsSynchronized">
      <summary>Obtém um valor indicando se o acesso ao <see cref="T:System.Collections.ICollection" /> está sincronizado com o SyncRoot.</summary>
      <returns>Sempre retorna <see langword="false" /> para indicar que o acesso não está sincronizado.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentBag`1.System#Collections#ICollection#SyncRoot">
      <summary>Obtém um objeto que pode ser usado para sincronizar o acesso ao <see cref="T:System.Collections.ICollection" />. Não há suporte a esta propriedade.</summary>
      <exception cref="T:System.NotSupportedException">Não há suporte para a propriedade SyncRoot.</exception>
      <returns>Retorna <see langword="null" />.</returns>
    </member>
    <member name="T:System.Collections.Concurrent.ConcurrentDictionary`2">
      <summary>Representa uma coleção thread-safe de pares chave-valor que podem ser acessados por vários threads ao mesmo tempo.</summary>
      <typeparam name="TKey">O tipo das chaves no dicionário.</typeparam>
      <typeparam name="TValue">O tipo dos valores no dicionário.</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que está vazia, tem o nível de simultaneidade padrão, tem a capacidade inicial padrão e usa o comparador padrão para o tipo de chave.</summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que contém elementos copiados do <see cref="T:System.Collections.Generic.IEnumerable`1" /> especificado, tem o nível de simultaneidade padrão, tem a capacidade inicial padrão e usa o comparador padrão para o tipo de chave.</summary>
      <param name="collection">O <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos são copiados para o novo <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> ou qualquer uma de suas chaves é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="collection" /> contém uma ou mais chaves duplicadas.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que contém elementos copiados do <see cref="T:System.Collections.IEnumerable" /> especificado, tem o nível de simultaneidade padrão, tem a capacidade inicial padrão e usa o <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado.</summary>
      <param name="collection">O <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos são copiados para o novo <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</param>
      <param name="comparer">A implementação de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> a ser usada ao comparar chaves.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> ou <paramref name="comparer" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que está vazia, tem a capacidade e o nível de simultaneidade padrão e usa o <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado.</summary>
      <param name="comparer">A implementação de comparação de igualdade a ser usada ao comparar chaves.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparer" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que contém elementos copiados da <see cref="T:System.Collections.IEnumerable" /> especificada e usa o <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado.</summary>
      <param name="concurrencyLevel">O número estimado de threads que atualizará o <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> simultaneamente.</param>
      <param name="collection">O <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos são copiados para o novo <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</param>
      <param name="comparer">A implementação de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> a ser usada ao comparar chaves.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> ou <paramref name="comparer" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="concurrencyLevel" /> é menor que 1.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="collection" /> contém uma ou mais chaves duplicadas.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que está vazia, tem a capacidade e o nível de simultaneidade especificados e usa o comparador padrão para o tipo de chave.</summary>
      <param name="concurrencyLevel">O número estimado de threads que atualizará o <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> simultaneamente.</param>
      <param name="capacity">O número inicial de elementos que o <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> pode conter.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="concurrencyLevel" /> é menor que 1.  
  
- ou - 
 <paramref name="capacity" /> é menor que 0.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que está vazia, tem o nível se simultaneidade especificado, tem a capacidade inicial especificada e usa o <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado.</summary>
      <param name="concurrencyLevel">O número estimado de threads que atualizará o <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> simultaneamente.</param>
      <param name="capacity">O número inicial de elementos que o <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> pode conter.</param>
      <param name="comparer">A implementação de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> a ser usada ao comparar chaves.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparer" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="concurrencyLevel" /> ou <paramref name="capacity" /> é menor que 1.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,`1,System.Func{`0,`1,`1})">
      <summary>Adiciona um par chave-valor ao <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> se a chave ainda não existir ou atualiza um par chave-valor no <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> usando a função especificada se a chave já existir.</summary>
      <param name="key">A chave a ser adicionada ou cujo valor deve ser atualizado</param>
      <param name="addValue">O valor a ser adicionado para uma chave ausente</param>
      <param name="updateValueFactory">A função usada para gerar um novo valor para uma chave existente com base no valor existente da chave</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> ou <paramref name="updateValueFactory" /> é <see langword="null" />.</exception>
      <exception cref="T:System.OverflowException">O dicionário contém muitos elementos.</exception>
      <returns>O novo valor da chave. Será <paramref name="addValue" /> (se a chave estava ausente) ou o resultado de <paramref name="updateValueFactory" /> (se a chave estava presente).</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})">
      <summary>Usará as funções especificadas para adicionar um par chave-valor ao <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> se a chave ainda não existir ou para atualizar um par chave-valor no <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> se a chave já existir.</summary>
      <param name="key">A chave a ser adicionada ou cujo valor deve ser atualizado</param>
      <param name="addValueFactory">A função usada para gerar um valor para uma chave ausente</param>
      <param name="updateValueFactory">A função usada para gerar um novo valor para uma chave existente com base no valor existente da chave</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" />, <paramref name="addValueFactory" /> ou <paramref name="updateValueFactory" /> é <see langword="null" />.</exception>
      <exception cref="T:System.OverflowException">O dicionário contém muitos elementos.</exception>
      <returns>O novo valor da chave. Esse será o resultado de <paramref name="addValueFactory" /> (se a chave estava ausente) ou o resultado de <paramref name="updateValueFactory" /> (se a chave estava presente).</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate``1(`0,System.Func{`0,``0,`1},System.Func{`0,`1,``0,`1},``0)">
      <summary>Usará o argumento e as funções especificadas para adicionar um par chave-valor ao <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> se a chave ainda não existir ou para atualizar um par chave-valor no <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> se a chave já existir.</summary>
      <param name="key">A chave a ser adicionada ou cujo valor deve ser atualizado.</param>
      <param name="addValueFactory">A função usada para gerar um valor para uma chave ausente.</param>
      <param name="updateValueFactory">A função usada para gerar um novo valor para uma chave existente com base no valor existente da chave.</param>
      <param name="factoryArgument">Um argumento a passar para <paramref name="addValueFactory" /> e <paramref name="updateValueFactory" />.</param>
      <typeparam name="TArg">O tipo de um argumento para passar para <paramref name="addValueFactory" /> e <paramref name="updateValueFactory" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" />, <paramref name="addValueFactory" /> ou <paramref name="updateValueFactory" /> é uma referência nula (Nothing no Visual Basic).</exception>
      <exception cref="T:System.OverflowException">O dicionário contém muitos elementos.</exception>
      <returns>O novo valor da chave. Esse será o resultado de <paramref name="addValueFactory" /> (se a chave estava ausente) ou o resultado de <paramref name="updateValueFactory" /> (se a chave estava presente).</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.Clear">
      <summary>Remove todas as chaves e valores do <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.ContainsKey(`0)">
      <summary>Determina se o <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> atual contém a chave especificada.</summary>
      <param name="key">A chave a ser localizada no <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> é <see langword="null" />.</exception>
      <returns>
        <see langword="true" /> se o <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> contiver um elemento com a chave especificada; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetEnumerator">
      <summary>Retorna um enumerador que itera por meio de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</summary>
      <returns>Um enumerador para o <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,`1)">
      <summary>Adiciona um par chave-valor ao <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> se a chave ainda não existe. Retorna o novo valor ou o valor existente se a chave existir.</summary>
      <param name="key">A chave do elemento a ser adicionada.</param>
      <param name="value">O valor a ser adicionado se a chave ainda não existir.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> é <see langword="null" />.</exception>
      <exception cref="T:System.OverflowException">O dicionário contém muitos elementos.</exception>
      <returns>O valor da chave. Esse será o valor existente da chave se ela já estiver no dicionário ou o novo valor se ela não estiver no dicionário.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
      <summary>Adiciona um par chave/valor para o <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> usando a função especificada, se a chave ainda não existir. Retorna o novo valor ou o valor existente se a chave existir.</summary>
      <param name="key">A chave do elemento a ser adicionada.</param>
      <param name="valueFactory">A função usada para gerar um valor para a chave.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> ou <paramref name="valueFactory" /> é <see langword="null" />.</exception>
      <exception cref="T:System.OverflowException">O dicionário contém muitos elementos.</exception>
      <returns>O valor da chave. Esse será o valor existente da chave se ela já estiver no dicionário ou o novo valor se ela não estiver no dicionário.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd``1(`0,System.Func{`0,``0,`1},``0)">
      <summary>Adiciona um par chave/valor ao <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> usando o argumento e a função especificada se a chave ainda não existir ou retorna o valor existente se a chave já existir.</summary>
      <param name="key">A chave do elemento a ser adicionada.</param>
      <param name="valueFactory">A função usada para gerar um valor para a chave.</param>
      <param name="factoryArgument">Um valor de argumento para passar para <paramref name="valueFactory" />.</param>
      <typeparam name="TArg">O tipo de um argumento a ser passado <paramref name="valueFactory" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> é uma referência <see langword="null" /> (Nothing no Visual Basic).</exception>
      <exception cref="T:System.OverflowException">O dicionário contém muitos elementos.</exception>
      <returns>O valor da chave. Esse será o valor existente da chave se ela já estiver no dicionário ou o novo valor se ela não estiver no dicionário.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>Adiciona um item à coleção.</summary>
      <param name="keyValuePair">O <see cref="T:System.Collections.Generic.KeyValuePair`2" /> a ser adicionado ao dicionário.</param>
      <exception cref="T:System.ArgumentNullException">O <see cref="P:System.Collections.Generic.KeyValuePair`2.Key" /> de <paramref name="keyValuePair" /> é <see langword="null" />.</exception>
      <exception cref="T:System.OverflowException">O <see cref="T:System.Collections.Generic.Dictionary`2" /> contém muitos elementos.</exception>
      <exception cref="T:System.ArgumentException">Já existe um elemento com a mesma chave no <see cref="T:System.Collections.Generic.Dictionary`2" />.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>Determina se o <see cref="T:System.Collections.Generic.ICollection`1" /> contém um elemento com a chave especificada.</summary>
      <param name="keyValuePair">A chave a ser localizada no <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
      <returns>
        <see langword="true" /> se o <see cref="T:System.Collections.Generic.ICollection`1" /> contiver um elemento com a chave especificada; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
      <summary>Copia os elementos do <see cref="T:System.Collections.ICollection" /> para uma matriz, começando no índice da matriz especificada.</summary>
      <param name="array">A matriz unidimensional que é o destino dos elementos copiados do <see cref="T:System.Collections.ICollection" />. A matriz deve ter indexação com base em zero.</param>
      <param name="index">O índice com base em zero em <paramref name="array" /> no qual a cópia começa.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> é menor que 0.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="index" /> é igual ou maior que o comprimento da <paramref name="array" />.

- ou -

O número de elementos na origem <see cref="T:System.Collections.ICollection" /> é maior do que o espaço disponível de <paramref name="index" /> até o final do <paramref name="array" /> de destino.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>Remove o par chave/valor especificado da coleção.</summary>
      <param name="keyValuePair">O <see cref="T:System.Collections.Generic.KeyValuePair`2" /> a ser removido.</param>
      <exception cref="T:System.ArgumentNullException">A propriedade <see cref="P:System.Collections.Generic.KeyValuePair`2.Key" /> de <paramref name="keyValuePair" /> é <see langword="null" />.</exception>
      <returns>
        <see langword="true" /> se o elemento for removido com êxito; caso contrário, <see langword="false" />. Esse método também retornará false se <paramref name="key" /> não tiver sido encontrado no <see cref="T:System.Collections.Generic.ICollection`1" /> original.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IDictionary{TKey@TValue}#Add(`0,`1)">
      <summary>Adiciona a chave e o valor especificados ao <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
      <param name="key">O objeto a ser usado como chave do elemento a ser adicionado.</param>
      <param name="value">O objeto a ser usado como o valor do elemento a ser adicionado.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Já existe um elemento com a mesma chave no <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</exception>
      <exception cref="T:System.OverflowException">O dicionário contém muitos elementos.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IDictionary{TKey@TValue}#Remove(`0)">
      <summary>Remove o elemento com a chave especificada do <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
      <param name="key">A chave do elemento a ser removido.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> é <see langword="null" />.</exception>
      <returns>
        <see langword="true" /> se o elemento for removido com êxito; caso contrário, <see langword="false" />. Esse método também retornará <see langword="false" /> se <paramref name="key" /> não tiver sido encontrado no <see cref="T:System.Collections.Generic.IDictionary`2" /> original.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <summary>Copia os elementos do <see cref="T:System.Collections.ICollection" /> para uma matriz, começando no índice da matriz especificada.</summary>
      <param name="array">A matriz unidimensional que é o destino dos elementos copiados do <see cref="T:System.Collections.ICollection" />. A matriz deve ter indexação com base em zero.</param>
      <param name="index">O índice com base em zero em <paramref name="array" /> no qual a cópia começa.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> é menor que 0.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="index" /> é igual ou maior que o comprimento da <paramref name="array" />.  
  
- ou - 
O número de elementos na origem <see cref="T:System.Collections.ICollection" /> é maior do que o espaço disponível de <paramref name="index" /> até o final do <paramref name="array" /> de destino.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
      <summary>Adiciona a chave e o valor especificados ao dicionário.</summary>
      <param name="key">O objeto a ser usado como a chave.</param>
      <param name="value">O objeto a ser usado como o valor.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">O <paramref name="key" /> é de um tipo que não é atribuível ao tipo de chave do <see cref="T:System.Collections.Generic.Dictionary`2" />.  
  
- ou - 
 O <paramref name="value" /> é de um tipo que não é atribuível ao tipo de valores no <see cref="T:System.Collections.Generic.Dictionary`2" />.  
  
- ou - 
Já existe um valor com a mesma chave no <see cref="T:System.Collections.Generic.Dictionary`2" />.</exception>
      <exception cref="T:System.OverflowException">O dicionário contém muitos elementos.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
      <summary>Obtém um valor que indica que <see cref="T:System.Collections.Generic.IDictionary`2" /> contém um elemento com a chave especificada.</summary>
      <param name="key">A chave a ser localizada no <see cref="T:System.Collections.Generic.IDictionary`2" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> é <see langword="null" />.</exception>
      <returns>
        <see langword="true" /> se o <see cref="T:System.Collections.Generic.IDictionary`2" /> contiver um elemento com a chave especificada; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#GetEnumerator">
      <summary>Fornece um <see cref="T:System.Collections.IDictionaryEnumerator" /> para o <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
      <returns>Um <see cref="T:System.Collections.IDictionaryEnumerator" /> para o <see cref="T:System.Collections.Generic.IDictionary`2" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
      <summary>Remove o elemento com a chave especificada do <see cref="T:System.Collections.IDictionary" />.</summary>
      <param name="key">A chave do elemento a ser removido.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera por meio de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</summary>
      <returns>Um enumerador para o <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.ToArray">
      <summary>Copia os pares de chave e valor armazenados em <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> para uma nova matriz.</summary>
      <returns>Uma nova matriz que contém um instantâneo de pares de chave e valor copiados de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryAdd(`0,`1)">
      <summary>Tenta adicionar a chave e o valor especificados ao <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</summary>
      <param name="key">A chave do elemento a ser adicionada.</param>
      <param name="value">O valor do elemento a ser adicionado. O valor pode ser <see langword="null" /> para tipos de referência.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> é <see langword="null" />.</exception>
      <exception cref="T:System.OverflowException">O dicionário contém muitos elementos.</exception>
      <returns>
        <see langword="true" /> se o par chave/valor foi adicionado ao <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> com êxito; <see langword="false" /> se a chave já existir.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryGetValue(`0,`1@)">
      <summary>Tenta obter o valor associado à chave especificada do <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</summary>
      <param name="key">A chave do valor a ser obtido.</param>
      <param name="value">Quando esse método for retornado, ele conterá o objeto do <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que tem a chave especificada ou o valor padrão do tipo se a operação tiver falhado.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> é <see langword="null" />.</exception>
      <returns>
        <see langword="true" /> se a chave foi encontrada no <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemove(`0,`1@)">
      <summary>Tenta remover e retornar o valor com a chave especificada do <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</summary>
      <param name="key">A chave do elemento a ser removido e retornado.</param>
      <param name="value">Quando for retornado, esse método conterá o objeto removido do <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> ou o valor padrão do tipo <see langword="TValue" /> se <paramref name="key" /> não existir.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> é <see langword="null" />.</exception>
      <returns>
        <see langword="true" /> se um objeto tiver sido removido com êxito; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemove(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>Remove uma chave e o valor do dicionário.</summary>
      <param name="item">O <see cref="T:System.Collections.Generic.KeyValuePair`2" /> que representa a chave e o valor a serem removidos.</param>
      <exception cref="T:System.ArgumentNullException">A propriedade <see cref="P:System.Collections.Generic.KeyValuePair`2.Key" /> de <paramref name="item" /> é <see langword="null" />.</exception>
      <returns>
        <see langword="true" /> se a chave e o valor representados por <paramref name="item" /> forem encontrados e removidos com êxito; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryUpdate(`0,`1,`1)">
      <summary>Atualizará o valor associado a <paramref name="key" /> para <paramref name="newValue" /> se o valor existente com <paramref name="key" /> for igual a <paramref name="comparisonValue" />.</summary>
      <param name="key">A chave do valor que é comparada com <paramref name="comparisonValue" /> e possivelmente substituída.</param>
      <param name="newValue">O valor que substitui o valor do elemento que foi especificado <paramref name="key" /> se a comparação resulta em igualdade.</param>
      <param name="comparisonValue">O valor é comparado com o valor do elemento que tem o valor de <paramref name="key" /> especificado.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> é <see langword="null" />.</exception>
      <returns>
        <see langword="true" /> se o valor com <paramref name="key" /> era igual a <paramref name="comparisonValue" /> e foi substituído pelo <paramref name="newValue" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Count">
      <summary>Obtém o número de pares chave-valor contidos no <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</summary>
      <exception cref="T:System.OverflowException">O dicionário contém muitos elementos.</exception>
      <returns>O número de pares chave-valor contidos no <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.IsEmpty">
      <summary>Obtém um valor que indica se a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> está vazia.</summary>
      <returns>
        <see langword="true" /> se o <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> estiver vazio; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Item(`0)">
      <summary>Obtém ou define o valor associado à chave especificada.</summary>
      <param name="key">A chave do valor a ser obtido ou definido.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Collections.Generic.KeyNotFoundException">A propriedade é recuperada e <paramref name="key" /> não existe na coleção.</exception>
      <returns>O valor do par chave-valor no índice especificado.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Keys">
      <summary>Obtém uma coleção que contém as chaves do <see cref="T:System.Collections.Generic.Dictionary`2" />.</summary>
      <returns>Uma coleção de chaves no <see cref="T:System.Collections.Generic.Dictionary`2" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#IsReadOnly">
      <summary>Obtém um valor que indica se o <see cref="T:System.Collections.ICollection" /> é somente leitura.</summary>
      <returns>
        <see langword="true" /> se o <see cref="T:System.Collections.ICollection" /> for somente leitura; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IReadOnlyDictionary{TKey@TValue}#Keys">
      <summary>Obtém uma coleção que contém as chaves do <see cref="T:System.Collections.Generic.Dictionary`2" />.</summary>
      <returns>Uma coleção que contém as chaves no <see cref="T:System.Collections.Generic.Dictionary`2" /> .</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IReadOnlyDictionary{TKey@TValue}#Values">
      <summary>Obtém uma coleção que contém os valores no <see cref="T:System.Collections.Generic.Dictionary`2" />.</summary>
      <returns>Uma coleção que contém os valores no <see cref="T:System.Collections.Generic.Dictionary`2" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#IsSynchronized">
      <summary>Obtém um valor que indica se o acesso ao <see cref="T:System.Collections.ICollection" /> está sincronizado com o SyncRoot.</summary>
      <returns>
        <see langword="true" /> caso o acesso ao <see cref="T:System.Collections.ICollection" /> seja sincronizado (thread-safe); do contrário, <see langword="false" />. Para <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> essa propriedade sempre retorna <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#SyncRoot">
      <summary>Obtém um objeto que pode ser usado para sincronizar o acesso ao <see cref="T:System.Collections.ICollection" />. Não há suporte a esta propriedade.</summary>
      <exception cref="T:System.NotSupportedException">Não há suporte a esta propriedade.</exception>
      <returns>Sempre retorna um valor nulo.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#IsFixedSize">
      <summary>Obtém um valor que indica se o <see cref="T:System.Collections.Generic.IDictionary`2" /> tem um tamanho fixo.</summary>
      <returns>
        <see langword="true" /> se o <see cref="T:System.Collections.Generic.IDictionary`2" /> tiver um valor fixo; caso contrário, <see langword="false" />. Para <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> , essa propriedade sempre retorna <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#IsReadOnly">
      <summary>Obtém um valor que indica se o <see cref="T:System.Collections.Generic.IDictionary`2" /> é somente leitura.</summary>
      <returns>
        <see langword="true" /> se o <see cref="T:System.Collections.Generic.IDictionary`2" /> for somente leitura; caso contrário, <see langword="false" />. Para <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> , essa propriedade sempre retorna <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Item(System.Object)">
      <summary>Obtém ou define o valor associado à chave especificada.</summary>
      <param name="key">A chave do valor a ser obtido ou definido.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Um valor está sendo atribuído e <paramref name="key" /> é de um tipo que não é atribuível ao tipo de chave ou ao tipo de valor do <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</exception>
      <returns>O valor associado à chave especificada ou <see langword="null" /> se <paramref name="key" /> não estiver no dicionário ou <paramref name="key" /> for de um tipo que não é atribuível ao tipo de chave de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Keys">
      <summary>Obtém um <see cref="T:System.Collections.ICollection" /> que contém as chaves do <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
      <returns>Uma interface que contém as chaves do <see cref="T:System.Collections.Generic.IDictionary`2" /> .</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Values">
      <summary>Obtém um <see cref="T:System.Collections.ICollection" /> que contém os valores no <see cref="T:System.Collections.IDictionary" />.</summary>
      <returns>Uma interface que contém os valores no <see cref="T:System.Collections.IDictionary" /> .</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Values">
      <summary>Obtém uma coleção que contém os valores no <see cref="T:System.Collections.Generic.Dictionary`2" />.</summary>
      <returns>Uma coleção que contém os valores no <see cref="T:System.Collections.Generic.Dictionary`2" />.</returns>
    </member>
    <member name="T:System.Collections.Concurrent.ConcurrentQueue`1">
      <summary>Representa uma coleção thread-safe PEPS (primeiro a entrar, primeiro a sair).</summary>
      <typeparam name="T">O tipo dos elementos contidos na fila.</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.#ctor">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.</summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> que contém elementos copiados da coleção especificada.</summary>
      <param name="collection">A coleção cujos elementos são copiados para o novo <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.</param>
      <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collection" /> é nulo.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.Clear">
      <summary>Remove todos os objetos da <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.</summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.CopyTo(`0[],System.Int32)">
      <summary>Copia os elementos <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> em um <see cref="T:System.Array" /> unidimensional existente, começando no índice da matriz especificado.</summary>
      <param name="array">Um <see cref="T:System.Array" /> unidimensional que é o destino dos elementos copiados do <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />. O <see cref="T:System.Array" /> deve ter indexação com base em zero.</param>
      <param name="index">O índice com base em zero em <paramref name="array" /> no qual a cópia começa.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> é uma referência nula (Nada no Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> é menor que zero.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="index" /> é igual ou maior que o tamanho do <paramref name="array" /> -ou- O número de elementos no <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> de origem é maior que o espaço disponível do <paramref name="index" /> até o fim da <paramref name="array" /> de destino.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.Enqueue(`0)">
      <summary>Adiciona um objeto ao final do <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.</summary>
      <param name="item">O objeto a ser adicionado ao final do <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />. O valor pode ser uma referência nula (Nada no Visual Basic) para tipos de referência.</param>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.GetEnumerator">
      <summary>Retorna um enumerador que itera por meio de <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.</summary>
      <returns>Um enumerador para o conteúdo de <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryAdd(`0)">
      <summary>Tenta adicionar um objeto ao <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</summary>
      <param name="item">O objeto a ser adicionado ao <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />. O valor pode ser uma referência nula (Nada no Visual Basic) para tipos de referência.</param>
      <returns>
        <see langword="true" /> se o objeto tiver sido adicionado com êxito; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryTake(`0@)">
      <summary>Tenta remover e retornar um objeto do <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</summary>
      <param name="item">Quando este método retornar, se a operação tiver sido bem-sucedida, <paramref name="item" /> conterá o objeto removido. Caso nenhum objeto esteja disponível para ser removido, o valor é não especificado.</param>
      <returns>
        <see langword="true" /> se um elemento tiver sido removido e tiver retornado com êxito; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <summary>Copia os elementos do <see cref="T:System.Collections.ICollection" /> para um <see cref="T:System.Array" />, começando em um determinado índice <see cref="T:System.Array" />.</summary>
      <param name="array">Um <see cref="T:System.Array" /> unidimensional que é o destino dos elementos copiados do <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />. O <see cref="T:System.Array" /> deve ter indexação com base em zero.</param>
      <param name="index">O índice com base em zero em <paramref name="array" /> no qual a cópia começa.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> é uma referência nula (Nada no Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> é menor que zero.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" /> é multidimensional. -ou- O <paramref name="array" /> não deve ter indexação baseada em zero. -ou- <paramref name="index" /> é igual ou maior que o tamanho da <paramref name="array" /> -ou- O número de elementos no <see cref="T:System.Collections.ICollection" /> de origem é maior que o espaço disponível do <paramref name="index" /> até o fim da <paramref name="array" /> de destino. -ou- O tipo do <see cref="T:System.Collections.ICollection" /> de origem não pode ser convertido automaticamente no tipo do <paramref name="array" /> de destino.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.ToArray">
      <summary>Copia os elementos armazenados em <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> em uma nova matriz.</summary>
      <returns>Uma nova matriz que contém um instantâneo dos elementos copiados de <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.TryDequeue(`0@)">
      <summary>Tenta remover e retornar o objeto no início da fila simultânea.</summary>
      <param name="result">Quando este método retornar, se a operação tiver sido bem-sucedida, <paramref name="result" /> conterá o objeto removido. Caso nenhum objeto esteja disponível para ser removido, o valor é não especificado.</param>
      <returns>
        <see langword="true" /> se um elemento tiver sido removido e retornado do início do <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> com êxito; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.TryPeek(`0@)">
      <summary>Tenta retornar um objeto do início da <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> sem removê-lo.</summary>
      <param name="result">Quando este método retorna, o <paramref name="result" /> contém um objeto do início da <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> ou um valor não especificado quando a operação falha.</param>
      <returns>
        <see langword="true" /> se um objeto foi retornado com sucesso, caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.Count">
      <summary>Obtém o número de elementos contidos no <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.</summary>
      <returns>O número de elementos contidos no <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.IsEmpty">
      <summary>Obtém um valor que indica se a <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> está vazia.</summary>
      <returns>
        <see langword="true" /> se o <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> estiver vazio; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#ICollection#IsSynchronized">
      <summary>Obtém um valor indicando se o acesso ao <see cref="T:System.Collections.ICollection" /> está sincronizado com o SyncRoot.</summary>
      <returns>Sempre retorna <see langword="false" /> para indicar que o acesso não está sincronizado.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#ICollection#SyncRoot">
      <summary>Obtém um objeto que pode ser usado para sincronizar o acesso ao <see cref="T:System.Collections.ICollection" />. Não há suporte a esta propriedade.</summary>
      <exception cref="T:System.NotSupportedException">Não há suporte para a propriedade SyncRoot.</exception>
      <returns>Retorna <see langword="null" />.</returns>
    </member>
    <member name="T:System.Collections.Concurrent.ConcurrentStack`1">
      <summary>Representa uma coleção thread-safe LIFO (último a entrar, primeiro a sair).</summary>
      <typeparam name="T">O tipo dos elementos contidos na pilha.</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.#ctor">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> que contém elementos copiados da coleção especificada.</summary>
      <param name="collection">A coleção cujos elementos são copiados para o novo <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</param>
      <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collection" /> é nulo.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.Clear">
      <summary>Remove todos os objetos da <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.CopyTo(`0[],System.Int32)">
      <summary>Copia os elementos <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> em um <see cref="T:System.Array" /> unidimensional existente, começando no índice da matriz especificado.</summary>
      <param name="array">Um <see cref="T:System.Array" /> unidimensional que é o destino dos elementos copiados do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />. O <see cref="T:System.Array" /> deve ter indexação com base em zero.</param>
      <param name="index">O índice com base em zero em <paramref name="array" /> no qual a cópia começa.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> é uma referência nula (Nada no Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> é menor que zero.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="index" /> é igual ou maior que o tamanho do <paramref name="array" /> -ou- O número de elementos no <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> de origem é maior que o espaço disponível do <paramref name="index" /> até o fim da <paramref name="array" /> de destino.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.GetEnumerator">
      <summary>Retorna um enumerador que itera por meio de <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</summary>
      <returns>Um enumerador para o <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.Push(`0)">
      <summary>Insere um objeto na parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</summary>
      <param name="item">O objeto a ser enviado por push para o <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />. O valor pode ser uma referência nula (Nada no Visual Basic) para tipos de referência.</param>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.PushRange(`0[])">
      <summary>Insere vários objetos na parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> de maneira atômica.</summary>
      <param name="items">Os objetos a serem enviados por push para o <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="items" /> é uma referência nula (Nada no Visual Basic).</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.PushRange(`0[],System.Int32,System.Int32)">
      <summary>Insere vários objetos na parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> de maneira atômica.</summary>
      <param name="items">Os objetos a serem enviados por push para o <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</param>
      <param name="startIndex">O deslocamento de base zero em <paramref name="items" /> no qual começar a inserir elementos na parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</param>
      <param name="count">O número de elementos a serem inseridos na parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="items" /> é uma referência nula (Nada no Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="startIndex" /> ou <paramref name="count" /> é negativo. Ou <paramref name="startIndex" /> é maior que ou igual ao comprimento da <paramref name="items" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="startIndex" /> + <paramref name="count" /> é maior que o comprimento do <paramref name="items" />.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryAdd(`0)">
      <summary>Tenta adicionar um objeto ao <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</summary>
      <param name="item">O objeto a ser adicionado ao <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />. O valor pode ser uma referência nula (Nada no Visual Basic) para tipos de referência.</param>
      <returns>
        <see langword="true" /> se o objeto tiver sido adicionado com êxito; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryTake(`0@)">
      <summary>Tenta remover e retornar um objeto do <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</summary>
      <param name="item">Quando este método retornar, se a operação tiver sido bem-sucedida, <paramref name="item" /> conterá o objeto removido. Caso nenhum objeto esteja disponível para ser removido, o valor é não especificado.</param>
      <returns>
        <see langword="true" /> se um elemento tiver sido removido e tiver retornado com êxito; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <summary>Copia os elementos do <see cref="T:System.Collections.ICollection" /> para um <see cref="T:System.Array" />, começando em um determinado índice <see cref="T:System.Array" />.</summary>
      <param name="array">Um <see cref="T:System.Array" /> unidimensional que é o destino dos elementos copiados do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />. O <see cref="T:System.Array" /> deve ter indexação com base em zero.</param>
      <param name="index">O índice com base em zero em <paramref name="array" /> no qual a cópia começa.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> é uma referência nula (Nada no Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> é menor que zero.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" /> é multidimensional. -ou- O <paramref name="array" /> não deve ter indexação baseada em zero. -ou- <paramref name="index" /> é igual ou maior que o tamanho da <paramref name="array" /> -ou- O número de elementos no <see cref="T:System.Collections.ICollection" /> de origem é maior que o espaço disponível do <paramref name="index" /> até o fim da <paramref name="array" /> de destino. -ou- O tipo do <see cref="T:System.Collections.ICollection" /> de origem não pode ser convertido automaticamente no tipo do <paramref name="array" /> de destino.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.ToArray">
      <summary>Copia os itens armazenados em <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> em uma nova matriz.</summary>
      <returns>Uma nova matriz que contém um instantâneo dos elementos copiados de <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPeek(`0@)">
      <summary>Tenta retornar um objeto da parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> sem removê-lo.</summary>
      <param name="result">Quando esse método for retornado, <paramref name="result" /> conterá um objeto da parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> ou um valor não especificado se a operação falhar.</param>
      <returns>
        <see langword="true" /> se um objeto foi retornado com sucesso, caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPop(`0@)">
      <summary>Tenta remover e retornar o objeto na parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</summary>
      <param name="result">Quando este método retornar, se a operação tiver sido bem-sucedida, <paramref name="result" /> conterá o objeto removido. Caso nenhum objeto esteja disponível para ser removido, o valor é não especificado.</param>
      <returns>
        <see langword="true" /> se um elemento tiver sido removido e retornado na parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> com êxito; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPopRange(`0[])">
      <summary>Tenta remover e retornar vários objetos da parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> de forma atômica.</summary>
      <param name="items">O <see cref="T:System.Array" /> a que os objetos removidos da parte superior de <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> serão adicionados.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="items" /> é um argumento nulo (Nada no Visual Basic).</exception>
      <returns>O número de objetos removidos com êxito da parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> e inseridos no <paramref name="items" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPopRange(`0[],System.Int32,System.Int32)">
      <summary>Tenta remover e retornar vários objetos da parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> de forma atômica.</summary>
      <param name="items">O <see cref="T:System.Array" /> a que os objetos removidos da parte superior de <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> serão adicionados.</param>
      <param name="startIndex">O deslocamento de base zero em <paramref name="items" /> no qual começar a inserir elementos da parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</param>
      <param name="count">O número de elementos a serem removidos da parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> e inseridos em <paramref name="items" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="items" /> é uma referência nula (Nada no Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="startIndex" /> ou <paramref name="count" /> é negativo. Ou <paramref name="startIndex" /> é maior que ou igual ao comprimento da <paramref name="items" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="startIndex" /> + <paramref name="count" /> é maior que o comprimento do <paramref name="items" />.</exception>
      <returns>O número de objetos removidos com êxito da parte superior da pilha e inseridos no <paramref name="items" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentStack`1.Count">
      <summary>Obtém o número de elementos contidos no <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</summary>
      <returns>O número de elementos contidos no <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentStack`1.IsEmpty">
      <summary>Obtém um valor que indica se a <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> está vazia.</summary>
      <returns>
        <see langword="true" /> se o <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> estiver vazio; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#IsSynchronized">
      <summary>Obtém um valor indicando se o acesso ao <see cref="T:System.Collections.ICollection" /> está sincronizado com o SyncRoot.</summary>
      <returns>Sempre retorna <see langword="false" /> para indicar que o acesso não está sincronizado.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#SyncRoot">
      <summary>Obtém um objeto que pode ser usado para sincronizar o acesso ao <see cref="T:System.Collections.ICollection" />. Não há suporte a esta propriedade.</summary>
      <exception cref="T:System.NotSupportedException">Não há suporte para a propriedade SyncRoot</exception>
      <returns>Retorna <see langword="null" />.</returns>
    </member>
    <member name="T:System.Collections.Concurrent.EnumerablePartitionerOptions">
      <summary>Especifica opções para controlar o comportamento de armazenamento em buffer de um particionador.</summary>
    </member>
    <member name="F:System.Collections.Concurrent.EnumerablePartitionerOptions.NoBuffering">
      <summary>Cria um particionador que recebe itens da fonte enumerável, um de cada vez e não usa o armazenamento intermediário que pode ser acessado de forma mais eficiente por vários threads. Essa opção dá suporte à baixa latência (os itens serão processados assim que estiverem disponíveis da fonte) e dá suporte parcial às dependências entre os itens (um thread não pode ficar em deadlock esperando um item que o próprio thread é responsável por processar).</summary>
    </member>
    <member name="F:System.Collections.Concurrent.EnumerablePartitionerOptions.None">
      <summary>Use o comportamento padrão, que é usar o armazenamento em buffer para obter o desempenho ideal.</summary>
    </member>
    <member name="T:System.Collections.Concurrent.IProducerConsumerCollection`1">
      <summary>Define métodos para manipular coleções thread-safe destinadas a uso pelo produtor/consumidor. Essa interface fornece uma representação unificada de coleções de produtor/consumidor para que abstrações de níveis mais altos, como o <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />, possam usar a coleção como o mecanismo de armazenamento subjacente.</summary>
      <typeparam name="T">Especifica o tipo dos elementos na coleção.</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.CopyTo(`0[],System.Int32)">
      <summary>Copia os elementos do <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> para um <see cref="T:System.Array" />, começando em um índice especificado.</summary>
      <param name="array">Um <see cref="T:System.Array" /> unidimensional que é o destino dos elementos copiados do <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.  
  
A matriz deve ter indexação com base em zero.</param>
      <param name="index">O índice com base em zero em <paramref name="array" /> no qual a cópia começa.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> é uma referência nula (Nada no Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> é menor que zero.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="index" /> é igual ou maior que o tamanho do <paramref name="array" /> -ou- O número de elementos na coleção é maior que o espaço disponível do <paramref name="index" /> até o fim da <paramref name="array" /> de destino.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.ToArray">
      <summary>Copia os elementos contidos na <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> em uma nova matriz.</summary>
      <returns>Uma nova matriz que contém os elementos copiados da <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.TryAdd(`0)">
      <summary>Tenta adicionar um objeto ao <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</summary>
      <param name="item">O objeto a ser adicionado ao <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</param>
      <exception cref="T:System.ArgumentException">O <paramref name="item" /> era inválido para esta coleção.</exception>
      <returns>
        <see langword="true" /> se o objeto tiver sido adicionado com êxito; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.TryTake(`0@)">
      <summary>Tenta remover e retornar um objeto do <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</summary>
      <param name="item">Quando este método retorna, se o objeto foi removido e retornou com êxito, <paramref name="item" /> contém o objeto removido. Caso nenhum objeto esteja disponível para ser removido, o valor é não especificado.</param>
      <returns>
        <see langword="true" /> se um objeto tiver sido removido e tiver retornado com êxito; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Collections.Concurrent.OrderablePartitioner`1">
      <summary>Representa uma maneira particular de dividir uma fonte de dados classificável em várias partições.</summary>
      <typeparam name="TSource">O tipo dos elementos na coleção.</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.#ctor(System.Boolean,System.Boolean,System.Boolean)">
      <summary>Chamado de construtores em classes derivadas para inicializar a classe <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> com as restrições especificadas nas chaves de índice.</summary>
      <param name="keysOrderedInEachPartition">Indica se os elementos em cada partição são gerados na ordem de chaves crescentes.</param>
      <param name="keysOrderedAcrossPartitions">Indica se elementos em uma partição anterior vêm sempre antes de elementos em uma partição posterior. Se true, cada elemento na partição 0 terá uma chave de ordem menor que qualquer elemento na partição 1, cada elemento na partição 1 terá uma chave de ordem menor que qualquer elemento na partição 2 e assim por diante.</param>
      <param name="keysNormalized">Indica se as chaves são normalizadas. Se true, todas as chaves de ordem serão inteiros distintos no intervalo [0 . numberOfElements-1]. Se falso, as chaves de ordem ainda devem ser diferentes, mas somente sua ordem relativa será considerada e não seus valores absolutos.</param>
    </member>
    <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.GetDynamicPartitions">
      <summary>Cria um objeto que pode particionar a coleção subjacente em um número variável de partições.</summary>
      <exception cref="T:System.NotSupportedException">Não há suporte para o particionamento dinâmico pela classe base. Ele deve ser implementado em classes derivadas.</exception>
      <returns>Um objeto que pode criar partições pela fonte de dados subjacente.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderableDynamicPartitions">
      <summary>Cria um objeto que pode particionar a coleção subjacente em um número variável de partições.</summary>
      <exception cref="T:System.NotSupportedException">Este particionador não dá suporte para o particionamento dinâmico.</exception>
      <returns>Um objeto que pode criar partições pela fonte de dados subjacente.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderablePartitions(System.Int32)">
      <summary>Particiona a coleção subjacente no número especificado de partições ordenáveis.</summary>
      <param name="partitionCount">O número de partições a criar.</param>
      <returns>Uma lista contendo enumeradores <paramref name="partitionCount" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.GetPartitions(System.Int32)">
      <summary>Particiona a coleção subjacente no número determinado de partições ordenadas.</summary>
      <param name="partitionCount">O número de partições a criar.</param>
      <returns>Uma lista contendo enumeradores <paramref name="partitionCount" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized">
      <summary>Especifica se as chaves de ordem são normalizadas.</summary>
      <returns>
        <see langword="true" /> Se as chaves forem normalizadas; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedAcrossPartitions">
      <summary>Especifica se os elementos em uma partição anterior vêm sempre antes de elementos em uma partição posterior.</summary>
      <returns>
        <see langword="true" /> Se os elementos em uma partição anterior sempre vierem antes dos elementos em uma partição posterior; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedInEachPartition">
      <summary>Especifica se os elementos em cada partição são gerados na ordem de chaves crescentes.</summary>
      <returns>
        <see langword="true" /> Se os elementos em cada partição forem resultantes na ordem de aumento de chaves; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner">
      <summary>Fornece estratégias de particionamento comuns para enumeráveis, listas e matrizes.</summary>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create(System.Int32,System.Int32)">
      <summary>Cria um particionador que divide em partes o intervalo especificado pelo usuário.</summary>
      <param name="fromInclusive">O limite inferior inclusivo do intervalo.</param>
      <param name="toExclusive">O limite superior exclusivo do intervalo.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="toExclusive" /> é menor ou igual ao argumento <paramref name="fromInclusive" />.</exception>
      <returns>Um particionador.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create(System.Int32,System.Int32,System.Int32)">
      <summary>Cria um particionador que divide em partes o intervalo especificado pelo usuário.</summary>
      <param name="fromInclusive">O limite inferior inclusivo do intervalo.</param>
      <param name="toExclusive">O limite superior exclusivo do intervalo.</param>
      <param name="rangeSize">O tamanho de cada subintervalo.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="toExclusive" /> é menor ou igual ao argumento <paramref name="fromInclusive" />.  
  
- ou - 
O argumento <paramref name="rangeSize" /> é menor ou igual a 0.</exception>
      <returns>Um particionador.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create(System.Int64,System.Int64)">
      <summary>Cria um particionador que divide em partes o intervalo especificado pelo usuário.</summary>
      <param name="fromInclusive">O limite inferior inclusivo do intervalo.</param>
      <param name="toExclusive">O limite superior exclusivo do intervalo.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="toExclusive" /> é menor ou igual ao argumento <paramref name="fromInclusive" />.</exception>
      <returns>Um particionador.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create(System.Int64,System.Int64,System.Int64)">
      <summary>Cria um particionador que divide em partes o intervalo especificado pelo usuário.</summary>
      <param name="fromInclusive">O limite inferior inclusivo do intervalo.</param>
      <param name="toExclusive">O limite superior exclusivo do intervalo.</param>
      <param name="rangeSize">O tamanho de cada subintervalo.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="toExclusive" /> é menor ou igual ao argumento <paramref name="fromInclusive" />.  
  
- ou - 
O argumento <paramref name="rangeSize" /> é menor ou igual a 0.</exception>
      <returns>Um particionador.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create``1(``0[],System.Boolean)">
      <summary>Cria um particionador ordenável de uma instância do <see cref="T:System.Array" />.</summary>
      <param name="array">A matriz a ser particionada.</param>
      <param name="loadBalance">Um valor booliano que indica se o particionador criado deve balancear carga dinamicamente entre as partições em vez de criar uma partição estaticamente.</param>
      <typeparam name="TSource">O tipo dos elementos na matriz de origem.</typeparam>
      <returns>Um particionador ordenável com base na matriz de entrada.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Cria um particionador ordenável de uma instância do <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
      <param name="source">O enumerável a ser particionado.</param>
      <typeparam name="TSource">O tipo dos elementos no enumerável de origem.</typeparam>
      <returns>Um particionador ordenável com base na matriz de entrada.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Concurrent.EnumerablePartitionerOptions)">
      <summary>Cria um particionador ordenável de uma instância do <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
      <param name="source">O enumerável a ser particionado.</param>
      <param name="partitionerOptions">Opções para controlar o comportamento de buffer do particionador.</param>
      <typeparam name="TSource">O tipo dos elementos no enumerável de origem.</typeparam>
      <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="partitionerOptions" /> especifica um valor inválido para <see cref="T:System.Collections.Concurrent.EnumerablePartitionerOptions" />.</exception>
      <returns>Um particionador ordenável com base na matriz de entrada.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create``1(System.Collections.Generic.IList{``0},System.Boolean)">
      <summary>Cria um particionador ordenável com base em uma instância <see cref="T:System.Collections.Generic.IList`1" />.</summary>
      <param name="list">A lista a ser particionada.</param>
      <param name="loadBalance">Um valor booliano que indica se o particionador criado deve balancear carga dinamicamente entre as partições em vez de criar uma partição estaticamente.</param>
      <typeparam name="TSource">Tipo dos elementos na lista de origem.</typeparam>
      <returns>Um particionador ordenável baseado na lista de entrada.</returns>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner`1">
      <summary>Representa uma maneira particular de dividir uma fonte de dados em várias partições.</summary>
      <typeparam name="TSource">O tipo dos elementos na coleção.</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner`1.#ctor">
      <summary>Cria uma nova instância de particionador.</summary>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions">
      <summary>Cria um objeto que pode particionar a coleção subjacente em um número variável de partições.</summary>
      <exception cref="T:System.NotSupportedException">Não há suporte para o particionamento dinâmico pela classe base. Você deve implementá-la em uma classe derivada.</exception>
      <returns>Um objeto que pode criar partições pela fonte de dados subjacente.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)">
      <summary>Particiona a coleção subjacente no número de partições determinado.</summary>
      <param name="partitionCount">O número de partições a criar.</param>
      <returns>Uma lista contendo enumeradores <paramref name="partitionCount" />.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions">
      <summary>Especifica se as partições adicionais podem ser criadas dinamicamente.</summary>
      <returns>
        <see langword="true" /> Se o <see cref="T:System.Collections.Concurrent.Partitioner`1" /> pode criar partições dinamicamente à medida que são solicitadas; <see langword="false" /> se o <see cref="T:System.Collections.Concurrent.Partitioner`1" /> só pode alocar partições estaticamente.</returns>
    </member>
  </members>
</doc>