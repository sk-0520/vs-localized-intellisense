<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Reflection.Metadata</name>
  </assembly>
  <members>
    <member name="T:System.Reflection.AssemblyFlags" />
    <member name="F:System.Reflection.AssemblyFlags.ContentTypeMask">
      <summary>
        <see cref="T:System.Reflection.AssemblyContentType" /> 값에 해당하는 콘텐츠 형식이 마스크된 비트입니다.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.DisableJitCompileOptimizer">
      <summary>어셈블리에 대해 JIT(Just-In-Time) 컴파일러 최적화가 사용되지 않도록 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.EnableJitCompileTracking">
      <summary>어셈블리에 대해 JIT(Just-In-Time) 컴파일러 추적이 사용되도록 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.PublicKey">
      <summary>어셈블리 참조에는 해시되지 않은 전체 공개 키가 포함되어 있습니다. 어셈블리 정의에는 적용되지 않습니다.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.Retargetable">
      <summary>런타임에 사용되는 참조된 어셈블리의 구현은 컴파일 시간에 표시되는 버전과 일치하지 않을 것으로 예상됩니다.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.WindowsRuntime">
      <summary>어셈블리는 Windows 런타임 코드를 포함합니다.</summary>
    </member>
    <member name="T:System.Reflection.AssemblyHashAlgorithm">
      <summary>어셈블리 파일을 해시하고 강력한 이름을 생성하는 데 사용한 해시 알고리즘을 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.MD5">
      <summary>MD5 메시지 다이제스트 알고리즘을 검색합니다.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.None">
      <summary>해시 알고리즘이 없음을 나타내는 마스크입니다.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha1">
      <summary>SHA의 게시되지 않은 결함을 수정하는 수정 버전의 SHA를 검색합니다.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha256">
      <summary>해시 크기가 256비트인 SHA(Secure Hash Algorithm) 버전을 검색합니다.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha384">
      <summary>해시 크기가 384비트인 SHA(Secure Hash Algorithm) 버전을 검색합니다.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha512">
      <summary>해시 크기가 512비트인 SHA(Secure Hash Algorithm) 버전을 검색합니다.</summary>
    </member>
    <member name="T:System.Reflection.DeclarativeSecurityAction">
      <summary>선언적 보안을 사용하여 수행할 수 있는 보안 작업을 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Assert">
      <summary>스택의 상위 호출자에게 리소스에 대한 액세스 권한이 없더라도 호출 코드를 사용하여 현재 권한 개체로 식별되는 리소스에 액세스할 수 있습니다.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Demand">
      <summary>호출 체인의 모든 호출자에게 지정된 사용 권한이 부여되었는지 확인합니다.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Deny">
      <summary>추가 검사가 없으면 지정된 사용 권한에 대한 요구가 거부됩니다.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.InheritanceDemand">
      <summary>클래스를 상속하거나 메서드를 재정의하는 파생 클래스에 지정된 사용 권한이 있어야 합니다.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.LinkDemand">
      <summary>직접 실행 호출자에게 지정된 사용 권한이 부여되었는지 확인합니다.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.None">
      <summary>선언적 보안 동작이 없습니다.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.PermitOnly">
      <summary>추가 검사가 없으면 지정된 권한 이외의 모든 사용 권한에 대한 수요가 거부됩니다.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestMinimum">
      <summary>코드를 실행하는 데 필요한 최소 사용 권한을 요청합니다. 이 작업은 어셈블리 범위 내에서만 사용할 수 있습니다.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestOptional">
      <summary>선택적인 추가 사용 권한을 요청합니다(실행하는 데 필수는 아님). 이 요청은 특별히 요청되지 않은 다른 모든 사용 권한을 암시적으로 거부합니다. 이 작업은 어셈블리 범위 내에서만 사용할 수 있습니다.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestRefuse">
      <summary>잘못 사용될 수 있는 사용 권한을 호출 코드에 부여하지 않도록 하는 요청입니다. 이 작업은 어셈블리 범위 내에서만 사용할 수 있습니다.</summary>
    </member>
    <member name="T:System.Reflection.ManifestResourceAttributes" />
    <member name="F:System.Reflection.ManifestResourceAttributes.Private">
      <summary>어셈블리에서 리소스를 내보내지 않습니다.</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.Public">
      <summary>어셈블리에서 리소스를 내보냅니다.</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.VisibilityMask">
      <summary>표시 유형 관련 특성만 마스크합니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ArrayShape">
      <summary>배열 형식의 도형을 나타냅니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ArrayShape.#ctor(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <summary>
        <see cref="T:System.Reflection.Metadata.ArrayShape" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
      <param name="rank">배열의 차수입니다.</param>
      <param name="sizes">각 차원의 크기입니다.</param>
      <param name="lowerBounds">각 차원의 낮은 경계입니다.</param>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.LowerBounds">
      <summary>모든 차원의 낮은 경계를 가져옵니다. 길이가 순위보다 작을 수 있습니다. 이 경우에 후행 차원이 낮은 경계를 지정합니다.</summary>
      <returns>하위 범위의 배열입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Rank">
      <summary>배열의 차수를 가져옵니다.</summary>
      <returns>차원의 수입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Sizes">
      <summary>모든 차원의 크기를 가져옵니다.</summary>
      <returns>크기의 배열입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetDeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Flags" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.PublicKey" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Equality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Inequality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyFile" />
    <member name="M:System.Reflection.Metadata.AssemblyFile.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyFile.ContainsMetadata">
      <summary>파일에 메타데이터가 있는지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns>
        <see langword="true" /> 파일에 메타 데이터가 포함 되어 있으면이 고, <see langword="false" /> 그렇지 않으면입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFile.HashValue">
      <summary>
        <see cref="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" />을 사용하여 계산된 파일 콘텐츠의 해시 값을 가져옵니다.</summary>
      <returns>
        <see cref="T:System.Reflection.Metadata.BlobHandle" />파일 콘텐츠의 해시 값을 나타내는 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFile.Name">
      <summary>해당 확장명을 포함하는 파일 이름을 가져옵니다.</summary>
      <returns>
        <see cref="T:System.Reflection.Metadata.StringHandle" />확장명을 가진 파일 이름을 나타내는 인스턴스입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Reflection.Metadata.AssemblyFileHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Equality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Inequality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection">
      <summary>
        <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />의 컬렉션을 나타냅니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyFileHandle}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Count">
      <summary>컬렉션의 요소 수를 가져옵니다.</summary>
      <returns>컬렉션에 있는 요소의 수입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyReference" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Flags" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.HashValue" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.PublicKeyOrToken" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Equality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Inequality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection">
      <summary>어셈블리 참조의 컬렉션입니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyReferenceHandle}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Count">
      <summary>컬렉션의 요소 수를 가져옵니다.</summary>
      <returns>컬렉션에 있는 요소의 수입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Blob" />
    <member name="M:System.Reflection.Metadata.Blob.GetBytes" />
    <member name="P:System.Reflection.Metadata.Blob.IsDefault" />
    <member name="P:System.Reflection.Metadata.Blob.Length" />
    <member name="T:System.Reflection.Metadata.BlobBuilder" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.#ctor(System.Int32)">
      <param name="capacity" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Align(System.Int32)">
      <param name="alignment" />
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.AllocateChunk(System.Int32)">
      <param name="minimalSize" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Clear" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.ContentEquals(System.Reflection.Metadata.BlobBuilder)">
      <summary>이 작성기의 현재 내용을 다른 내용과 비교합니다.</summary>
      <param name="other">이 인스턴스와 비교할 <see cref="T:System.Reflection.Metadata.BlobBuilder" /> 인스턴스입니다.</param>
      <exception cref="T:System.InvalidOperationException">콘텐츠를 사용할 수 없습니다. 작성기가 다른 콘텐츠와 연결되어 있습니다.</exception>
      <returns>같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Free" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.FreeChunk" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.GetBlobs">
      <summary>작성기의 콘텐츠를 나타내는 모든 Blob의 시퀀스를 반환합니다.</summary>
      <exception cref="T:System.InvalidOperationException">콘텐츠를 사용할 수 없습니다. 작성기가 다른 콘텐츠와 연결되어 있습니다.</exception>
      <returns>Blob의 시퀀스입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkPrefix(System.Reflection.Metadata.BlobBuilder)">
      <param name="prefix" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="prefix" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkSuffix(System.Reflection.Metadata.BlobBuilder)">
      <param name="suffix" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="suffix" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.PadTo(System.Int32)">
      <param name="position" />
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ReserveBytes(System.Int32)">
      <summary>바이트의 연속 블록을 예약합니다.</summary>
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" />가 음수입니다.</exception>
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray">
      <exception cref="T:System.InvalidOperationException">콘텐츠를 사용할 수 없습니다. 작성기가 다른 콘텐츠와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 및 <paramref name="byteCount" />에 의해 지정된 범위가 버퍼 콘텐츠 경계를 벗어납니다.</exception>
      <exception cref="T:System.InvalidOperationException">콘텐츠를 사용할 수 없습니다. 작성기가 다른 콘텐츠와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray">
      <exception cref="T:System.InvalidOperationException">콘텐츠를 사용할 수 없습니다. 작성기가 다른 콘텐츠와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 및 <paramref name="byteCount" />에 의해 지정된 범위가 버퍼 콘텐츠 경계를 벗어납니다.</exception>
      <exception cref="T:System.InvalidOperationException">콘텐츠를 사용할 수 없습니다. 작성기가 다른 콘텐츠와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.TryWriteBytes(System.IO.Stream,System.Int32)">
      <summary>작성기에 바이트 시퀀스를 작성하려고 합니다. 반환 값은 성공적으로 작성된 바이트 수를 나타냅니다.</summary>
      <param name="source" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" />가 음수입니다.</exception>
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
      <returns>
        <paramref name="source" />에서 성공적으로 기록된 바이트 수입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBoolean(System.Boolean)">
      <summary>작성기에 <see cref="T:System.Boolean" /> 값을 씁니다.</summary>
      <param name="value">작성할 값입니다.</param>
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteByte(System.Byte)">
      <summary>작성기에 <see cref="T:System.Byte" /> 값을 씁니다.</summary>
      <param name="value">작성할 값입니다.</param>
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte*,System.Int32)">
      <summary>버퍼에서 지정된 바이트 수를 작성기에 씁니다.</summary>
      <param name="buffer" />
      <param name="byteCount">쓸 바이트 수입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" />가 음수입니다.</exception>
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte,System.Int32)">
      <summary>지정된 바이트 값의 발생 횟수를 작성기에 씁니다.</summary>
      <param name="value" />
      <param name="byteCount">기록할 <paramref name="value" />의 발생 횟수입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" />가 음수입니다.</exception>
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[])">
      <summary>바이트 배열의 내용을 작성기에 씁니다.</summary>
      <param name="buffer">쓸 바이트 배열입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <summary>바이트 배열의 지정된 인덱스에서 시작하는 지정된 바이트 수를 작성기에 씁니다.</summary>
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount">쓸 바이트 수입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 및 <paramref name="byteCount" />에 의해 지정된 범위가 <paramref name="buffer" />의 경계를 벗어납니다.</exception>
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>변경할 수 없는 바이트 배열의 내용을 작성기에 씁니다.</summary>
      <param name="buffer">쓸 배열입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <summary>변경할 수 없는 배열의 지정된 인덱스에서 시작하는 지정된 바이트 수를 작성기에 씁니다.</summary>
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount">쓸 바이트 수입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 및 <paramref name="byteCount" />에 의해 지정된 범위가 <paramref name="buffer" />의 경계를 벗어납니다.</exception>
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedInteger(System.Int32)">
      <summary>ECMA-335-II 장 23.2: Blob 및 서명에 정의 된 대로 압축 되지 않은 부호 없는 정수 인코딩을 구현 합니다.</summary>
      <param name="value">작성할 값입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" />는 압축된 부호 없는 정수로 표시될 수 없습니다.</exception>
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedSignedInteger(System.Int32)">
      <summary>ECMA-335-II 장 23.2: Blob 및 서명에 정의 된 대로 압축 부호 있는 정수 인코딩을 구현 합니다.</summary>
      <param name="value">작성할 값입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" />는 압축된 부호 있는 정수로 표시될 수 없습니다.</exception>
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteConstant(System.Object)">
      <summary>현재 위치에서 상수 값(ECMA-335 Partition II 섹션 22.9 참조)을 씁니다.</summary>
      <param name="value">작성할 상수 값입니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" />는 상수 유형이 아닙니다.</exception>
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.IO.Stream)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.InvalidOperationException">콘텐츠를 사용할 수 없습니다. 작성기가 다른 콘텐츠와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobBuilder)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.InvalidOperationException">콘텐츠를 사용할 수 없습니다. 작성기가 다른 콘텐츠와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobWriter@)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" />은 기본값(<see cref="T:System.Reflection.Metadata.BlobWriter" />)입니다.</exception>
      <exception cref="T:System.InvalidOperationException">콘텐츠를 사용할 수 없습니다. 작성기가 다른 콘텐츠와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDateTime(System.DateTime)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDecimal(System.Decimal)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDouble(System.Double)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteGuid(System.Guid)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16(System.Int16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16BE(System.Int16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32(System.Int32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32BE(System.Int32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt64(System.Int64)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteReference(System.Int32,System.Boolean)">
      <summary>힙(힙 오프셋) 또는 테이블(행 번호)에 대한 참조를 씁니다.</summary>
      <param name="reference">힙 오프셋 또는 테이블 행 번호.</param>
      <param name="isSmall">
        <see langword="true" />를 사용하여 참조를 16비트 정수로 인코딩하고, <see langword="false" />를 사용하여 32비트 정수로 인코딩합니다.</param>
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSByte(System.SByte)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSerializedString(System.String)">
      <summary>SerString 형식으로 문자열을 씁니다(ECMA-335-II 23.3 사용자 지정 특성 참조).</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSingle(System.Single)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16(System.UInt16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16BE(System.UInt16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32(System.UInt32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32BE(System.UInt32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt64(System.UInt64)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUserString(System.String)">
      <summary>사용자 문자열(#US) 힙 형식으로 문자열을 씁니다(ECMA-335-II 24.2.4 #US 및 #Blob 힙 참조).</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.Char[])">
      <summary>현재 위치에서 UTF16(little endian) 인코딩된 문자 배열을 씁니다.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.String)">
      <summary>현재 위치에서 UTF16(little endian) 인코딩된 문자열을 씁니다.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF8(System.String,System.Boolean)">
      <summary>현재 위치에서 UTF8 인코딩된 문자열을 씁니다.</summary>
      <param name="value">상수 값입니다.</param>
      <param name="allowUnpairedSurrogates">
        <see langword="true" />를 사용하여 지정된 대로 짝이 없는 서로게이트를 인코딩합니다. <see langword="false" />를 사용하여 U+FFFD 문자로 바꿉니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.ChunkCapacity" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.Count" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.FreeBytes" />
    <member name="T:System.Reflection.Metadata.BlobBuilder.Blobs" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#Blob}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.BlobContentId" />
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Byte[])">
      <param name="id" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="id" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Guid,System.UInt32)">
      <param name="guid" />
      <param name="stamp" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Reflection.Metadata.BlobContentId)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Byte[])">
      <param name="hashCode" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="hashCode" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.GetHashCode" />
    <member name="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Equality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Inequality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobContentId.Guid" />
    <member name="P:System.Reflection.Metadata.BlobContentId.IsDefault" />
    <member name="P:System.Reflection.Metadata.BlobContentId.Stamp" />
    <member name="T:System.Reflection.Metadata.BlobHandle" />
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Reflection.Metadata.BlobHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Equality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Implicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Inequality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.BlobReader" />
    <member name="M:System.Reflection.Metadata.BlobReader.#ctor(System.Byte*,System.Int32)">
      <summary>지정된 메모리 블록의 reader를 만듭니다.</summary>
      <param name="buffer">메모리 블록의 시작에 대한 포인터.</param>
      <param name="length">메모리 블록의 길이(바이트)입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" />는 <see langword="null" />이고 <paramref name="length" />가 0보다 큽니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" />가 음수입니다.</exception>
      <exception cref="T:System.PlatformNotSupportedException">현재 플랫폼은 little-endian이 아닙니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Align(System.Byte)">
      <summary>지정된 맞춤을 충족하는 데 필요한 바이트 수 만큼 reader를 앞으로 다시 배치합니다.</summary>
      <param name="alignment" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.IndexOf(System.Byte)">
      <summary>현재 위치에 따라 Blob에서 지정된 바이트를 검색합니다.</summary>
      <param name="value">찾을 바이트 값입니다.</param>
      <returns>현재 위치를 기준으로 한 인덱스 또는 현재 위치 다음의 Blob에서 바이트가 없으면 -1입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBlobHandle">
      <summary>압축된 정수로 인코딩된 Blob 힙 핸들을 읽습니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBoolean" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32)">
      <summary>현재 위치에서 시작하는 바이트를 읽습니다.</summary>
      <param name="byteCount">읽을 바이트 수입니다.</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> 바이트를 사용할 수 없습니다.</exception>
      <returns>바이트 배열입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32,System.Byte[],System.Int32)">
      <summary>현재 위치에서 시작하는 바이트를 읽고 지정된 오프셋에서 시작하는 지정된 버퍼에 씁니다.</summary>
      <param name="byteCount">읽을 바이트 수입니다.</param>
      <param name="buffer">바이트 읽기가 기록될 대상 버퍼입니다.</param>
      <param name="bufferOffset">바이트 읽기가 기록될 대상 버퍼의 오프셋입니다.</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> 바이트를 사용할 수 없습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadChar" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedInteger">
      <summary>부호 없는 압축된 정수 값을 읽습니다. 메타 데이터 사양 섹션 23.2: Blob 및 시그니처를 참조 하세요.</summary>
      <exception cref="T:System.BadImageFormatException">현재 위치의 데이터는 유효한 압축 정수가 아닙니다.</exception>
      <returns>읽은 압축된 정수 값입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedSignedInteger">
      <summary>부호 있는 압축된 정수 값을 읽습니다. 메타 데이터 사양 섹션 23.2: Blob 및 시그니처를 참조 하세요.</summary>
      <exception cref="T:System.BadImageFormatException">현재 위치의 데이터는 유효한 압축 정수가 아닙니다.</exception>
      <returns>읽은 압축된 정수 값입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadConstant(System.Reflection.Metadata.ConstantTypeCode)">
      <summary>현재 위치에서 상수 값(ECMA-335 Partition II 섹션 22.9 참조)을 읽습니다.</summary>
      <param name="typeCode" />
      <exception cref="T:System.BadImageFormatException">Blob에서 읽는 동안 오류가 발생했습니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="typeCode" />은 유효한 <see cref="T:System.Reflection.Metadata.ConstantTypeCode" />이 아닙니다.</exception>
      <returns>boxed 상수 값입니다. 개체 할당을 방지하려면 읽기* 메서드를 직접 사용합니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDateTime" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDecimal">
      <summary>
        <see cref="T:System.Decimal" /> 번호를 읽습니다.</summary>
      <exception cref="T:System.BadImageFormatException">현재 위치의 데이터는 유효한 <see cref="T:System.Decimal" /> 번호가 아닙니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDouble" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadGuid" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializationTypeCode">
      <summary>직렬화된 사용자 지정 특성 값으로 인코딩된 형식 코드를 읽습니다.</summary>
      <returns>인코딩이 유효하지 않은 경우 <see cref="F:System.Reflection.Metadata.SerializationTypeCode.Invalid" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializedString">
      <summary>UTF8의 해당 내용 다음에 길이를 포함하는 압축된 정수로 인코딩된 문자열을 읽습니다. Null 문자열은 단일 0xFF 바이트로 인코딩됩니다.</summary>
      <exception cref="T:System.BadImageFormatException">인코딩이 잘못되었습니다.</exception>
      <returns>문자열 값 또는 <see langword="null" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureHeader" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureTypeCode">
      <summary>서명으로 인코딩된 형식 코드를 읽습니다.</summary>
      <returns>인코딩이 유효한 경우 직렬화된 사용자 지정 특성 값으로 인코딩된 형식 코드이거나 인코딩이 유효하지 않은 경우 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSingle" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadTypeHandle">
      <summary>서명에 TypeDefOrRefOrSpecEncoded로 인코딩된 형식 핸들을 읽습니다(ECMA-335 II.23.2.8 참조).</summary>
      <returns>인코딩이 유효한 경우 핸들입니다. 그렇지 않으면 <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> 속성이 <see langword="true" />인 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF16(System.Int32)">
      <summary>현재 위치에서 시작하는 UTF16(little endian) 인코딩된 문자열을 읽습니다.</summary>
      <param name="byteCount">읽을 바이트 수입니다.</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> 바이트를 사용할 수 없습니다.</exception>
      <returns>문자열입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF8(System.Int32)">
      <summary>현재 위치에서 시작하는 UTF8 인코딩된 문자열을 읽습니다.</summary>
      <param name="byteCount">읽을 바이트 수입니다.</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> 바이트를 사용할 수 없습니다.</exception>
      <returns>문자열입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Reset">
      <summary>reader를 기본 메모리 블록의 시작 부분에 다시 배치합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedInteger(System.Int32@)">
      <summary>부호 없는 압축된 정수 값을 읽습니다. 메타 데이터 사양 섹션 23.2: Blob 및 시그니처를 참조 하세요.</summary>
      <param name="value">읽은 압축된 정수 값입니다.</param>
      <returns>값을 성공적으로 읽은 경우 <see langword="true" />입니다. 현재 위치의 데이터가 유효한 압축 정수가 아닌 경우 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedSignedInteger(System.Int32@)">
      <summary>부호 있는 압축된 정수 값을 읽습니다. 메타 데이터 사양 섹션 23.2: Blob 및 시그니처를 참조 하세요.</summary>
      <param name="value">읽은 압축된 정수 값입니다.</param>
      <returns>값을 성공적으로 읽은 경우 <see langword="true" />입니다. 현재 위치의 데이터가 유효한 압축 정수가 아닌 경우 <see langword="false" />입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.CurrentPointer">
      <summary>reader의 현재 위치에 있는 바이트에 대한 포인터를 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Length">
      <summary>기본 메모리 블록의 총 길이를 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Offset">
      <summary>Blob의 시작에서 현재 위치까지 오프셋을 가져오거나 설정합니다.</summary>
      <exception cref="T:System.BadImageFormatException">오프셋은 기본 reader의 경계 외부에 설정됩니다.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.RemainingBytes">
      <summary>현재 위치에서 기본 메모리 블록의 끝까지 남아 있는 바이트 수를 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.StartPointer">
      <summary>기본 메모리 블록의 시작 부분에 있는 바이트에 대한 포인터를 가져옵니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.BlobWriter" />
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[])">
      <param name="buffer" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="count" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Int32)">
      <param name="size" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Reflection.Metadata.Blob)">
      <param name="blob" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.Align(System.Int32)">
      <param name="alignment" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.Clear" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ContentEquals(System.Reflection.Metadata.BlobWriter)">
      <summary>이 작성기의 현재 내용을 다른 내용과 비교합니다.</summary>
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.PadTo(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 및 <paramref name="byteCount" />에 의해 지정된 범위가 버퍼 콘텐츠 경계를 벗어납니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 및 <paramref name="byteCount" />에 의해 지정된 범위가 버퍼 콘텐츠 경계를 벗어납니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBoolean(System.Boolean)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteByte(System.Byte)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte*,System.Int32)">
      <param name="buffer" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" />가 음수입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte,System.Int32)">
      <param name="value" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" />가 음수입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[])">
      <param name="buffer" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" />이(가) <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 및 <paramref name="byteCount" />에 의해 지정된 범위가 <paramref name="buffer" />의 경계를 벗어납니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="buffer" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" />이(가) <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 및 <paramref name="byteCount" />에 의해 지정된 범위가 <paramref name="buffer" />의 경계를 벗어납니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.IO.Stream,System.Int32)">
      <param name="source" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" />가 음수입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Reflection.Metadata.BlobBuilder)">
      <param name="source" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" />이(가) <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedInteger(System.Int32)">
      <summary>ECMA-335-II 장 23.2: Blob 및 서명에 정의 된 대로 압축 되지 않은 부호 없는 정수 인코딩을 구현 합니다.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" />는 압축된 부호 없는 정수로 표시될 수 없습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedSignedInteger(System.Int32)">
      <summary>ECMA-335-II 장 23.2: Blob 및 서명에 정의 된 대로 압축 부호 있는 정수 인코딩을 구현 합니다.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" />는 압축된 부호 있는 정수로 표시될 수 없습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteConstant(System.Object)">
      <summary>현재 위치에서 상수 값(ECMA-335 Partition II 섹션 22.9 참조)을 씁니다.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentException">
        <paramref name="value" />는 상수 유형이 아닙니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDateTime(System.DateTime)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDecimal(System.Decimal)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDouble(System.Double)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteGuid(System.Guid)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16(System.Int16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16BE(System.Int16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32(System.Int32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32BE(System.Int32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt64(System.Int64)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteReference(System.Int32,System.Boolean)">
      <summary>힙(힙 오프셋) 또는 테이블(행 번호)에 대한 참조를 씁니다.</summary>
      <param name="reference">힙 오프셋 또는 테이블 행 번호.</param>
      <param name="isSmall">
        <see langword="true" />를 사용하여 참조를 16비트 정수로 인코딩하고, <see langword="false" />를 사용하여 32비트 정수로 인코딩합니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSByte(System.SByte)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSerializedString(System.String)">
      <summary>SerString 형식으로 문자열을 씁니다(ECMA-335-II 23.3 사용자 지정 특성 참조).</summary>
      <param name="str" />
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSingle(System.Single)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16(System.UInt16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16BE(System.UInt16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32(System.UInt32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32BE(System.UInt32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt64(System.UInt64)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)">
      <summary>사용자 문자열(#US) 힙 형식으로 문자열을 씁니다(ECMA-335-II 24.2.4 #US 및 #Blob 힙 참조).</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.Char[])">
      <summary>현재 위치에서 UTF16(little endian) 인코딩된 문자열을 씁니다.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" />이(가) <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.String)">
      <summary>현재 위치에서 UTF16(little endian) 인코딩된 문자열을 씁니다.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" />이(가) <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF8(System.String,System.Boolean)">
      <summary>현재 위치에서 UTF8 인코딩된 문자열을 씁니다.</summary>
      <param name="value" />
      <param name="allowUnpairedSurrogates" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" />이(가) <see langword="null" />인 경우</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.Blob" />
    <member name="P:System.Reflection.Metadata.BlobWriter.Length" />
    <member name="P:System.Reflection.Metadata.BlobWriter.Offset" />
    <member name="P:System.Reflection.Metadata.BlobWriter.RemainingBytes" />
    <member name="T:System.Reflection.Metadata.Constant" />
    <member name="P:System.Reflection.Metadata.Constant.Parent">
      <summary>부모 핸들(<see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />)을 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.TypeCode">
      <summary>상수 값의 형식을 식별하는 형식 코드를 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.Value">
      <summary>상수 값을 가져옵니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ConstantHandle" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Reflection.Metadata.ConstantHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Equality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Inequality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ConstantHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ConstantTypeCode">
      <summary>메타데이터 상수의 형식을 나타내는 값을 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Boolean">
      <summary>Boolean 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Byte">
      <summary>부호 없는 1바이트 정수입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Char">
      <summary>문자 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Double">
      <summary>8바이트 부동 소수점 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int16">
      <summary>부호 있는 2바이트 정수 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int32">
      <summary>부호 있는 4바이트 정수 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int64">
      <summary>부호 있는 8바이트 정수 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Invalid">
      <summary>잘못된 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.NullReference">
      <summary>null 참조입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.SByte">
      <summary>부호 있는 1바이트 정수 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Single">
      <summary>4바이트 부동 소수점 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.String">
      <summary>
        <see cref="T:System.String" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt16">
      <summary>부호 없는 2바이트 정수 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt32">
      <summary>부호 없는 4바이트 정수 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt64">
      <summary>부호 없는 8바이트 정수 형식입니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttribute" />
    <member name="M:System.Reflection.Metadata.CustomAttribute.DecodeValue``1(System.Reflection.Metadata.ICustomAttributeTypeProvider{``0})">
      <summary>값 Blob에 인코딩된 인수를 디코딩합니다.</summary>
      <param name="provider" />
      <typeparam name="TType" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Constructor">
      <summary>사용자 지정 특성 유형의 생성자(<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />)를 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Parent">
      <summary>특성이 적용되는 메타데이터 엔터티의 핸들을 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Value">
      <summary>특성 값을 얻습니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandle" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Reflection.Metadata.CustomAttributeHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Equality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Inequality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomAttributeHandle}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Count">
      <summary>컬렉션의 요소 수를 가져옵니다.</summary>
      <returns>컬렉션에 있는 요소의 수입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1">
      <summary>사용자 지정 특성 서명에서 디코딩된 명명된 인수를 나타냅니다.</summary>
      <typeparam name="TType">사용자 지정 특성 시그니처에서 디코딩된 값의 형식을 나타내는 데 사용 되는 형식입니다.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeNamedArgument`1.#ctor(System.String,System.Reflection.Metadata.CustomAttributeNamedArgumentKind,`0,System.Object)">
      <summary>지정된 이름, 종류, 형식 및 값을 사용하여 <see cref="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
      <param name="name">인수의 이름입니다.</param>
      <param name="kind">인수의 종류입니다.</param>
      <param name="type">인수 형식입니다.</param>
      <param name="value">인수 값입니다.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Kind">
      <summary>인수의 종류를 가져옵니다.</summary>
      <returns>인수 종류입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Name">
      <summary>인수의 이름을 가져옵니다.</summary>
      <returns>인수 이름입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Type">
      <summary>인수의 형식을 가져옵니다.</summary>
      <returns>인수 형식입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Value">
      <summary>인수 값을 가져옵니다.</summary>
      <returns>인수 값을 포함 하는 개체입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgumentKind">
      <summary>사용자 지정 특성 서명에서 인수의 종류를 정의하는 상수를 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Field">
      <summary>필드 인수입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Property">
      <summary>속성 인수입니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1">
      <summary>사용자 지정 메타데이터 특성에 대해 형식 인수를 나타냅니다.</summary>
      <typeparam name="TType">인수 형식입니다.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeTypedArgument`1.#ctor(`0,System.Object)">
      <summary>지정된 인수 형식 및 값을 사용하여 <see cref="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
      <param name="type">인수 형식입니다.</param>
      <param name="value">인수 값입니다.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Type">
      <summary>인수의 형식을 가져옵니다.</summary>
      <returns>인수 형식입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Value">
      <summary>인수 값을 가져옵니다.</summary>
      <returns>인수 값입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeValue`1">
      <summary>
        <paramref name="TType" />에서 지정된 형식의 사용자 지정 특성을 나타냅니다.</summary>
      <typeparam name="TType">특성 유형입니다.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeValue`1.#ctor(System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeTypedArgument{`0}},System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeNamedArgument{`0}})">
      <summary>지정된 고정 인수 및 명명된 인수를 사용하여 <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
      <param name="fixedArguments">고정 인수입니다.</param>
      <param name="namedArguments">명명된 인수입니다.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.FixedArguments">
      <summary>사용자 지정 특성에 대한 고정 인수를 가져옵니다.</summary>
      <returns>변경할 수 없는 인수 배열입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.NamedArguments">
      <summary>사용자 지정 특성 값에 대한 명명된 인수를 가져옵니다.</summary>
      <returns>변경할 수 없는 인수 배열입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Kind" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Parent" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Value" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Equality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Inequality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomDebugInformationHandle}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Count">
      <summary>컬렉션의 요소 수를 가져옵니다.</summary>
      <returns>컬렉션에 있는 요소의 수입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DebugMetadataHeader" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.EntryPoint" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.Id" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.IdStartOffset">
      <summary>메타데이터 Blob 시작에서 <see cref="P:System.Reflection.Metadata.DebugMetadataHeader.Id" /> Blob의 시작으로 오프셋(바이트)을 가져옵니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttribute" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Action" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Parent" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.PermissionSet" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Equality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Inequality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DeclarativeSecurityAttributeHandle}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Count">
      <summary>컬렉션의 요소 수를 가져옵니다.</summary>
      <returns>컬렉션에 있는 요소의 수입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Document">
      <summary>디버그 메타데이터의 소스 문서입니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Hash">
      <summary>문서 콘텐츠 해시를 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.HashAlgorithm">
      <summary>
        <see cref="P:System.Reflection.Metadata.Document.Hash" />(SHA1, SHA256 등)를 계산하는 데 사용되는 해시 알고리즘을 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Language">
      <summary>소스 코드 언어(C#, VB, F# 등)를 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Name">
      <summary>문서 이름 Blob을 가져옵니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandle" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Reflection.Metadata.DocumentHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Equality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Inequality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DocumentHandle}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Count">
      <summary>컬렉션의 요소 수를 가져옵니다.</summary>
      <returns>컬렉션에 있는 요소의 수입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentNameBlobHandle">
      <summary>문서 이름으로 구조화된 이식 가능한 PDB에서 #Blob 힙의 blob을 나타내는 <see cref="T:System.Reflection.Metadata.BlobHandle" />입니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Equality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Explicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.DocumentNameBlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Implicit(System.Reflection.Metadata.DocumentNameBlobHandle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Inequality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.DocumentNameBlobHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Shape(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <summary>배열 셰이프를 인코딩합니다.</summary>
      <param name="rank">배열의 차원 수(1개 이상이어야 함).</param>
      <param name="sizes">차원 크기. 배열은 <paramref name="rank" />보다 짧을 수 있지만 더 길면 안 됩니다.</param>
      <param name="lowerBounds">차원 하한을 설정하거나 기본값(<see cref="T:System.Collections.Immutable.ImmutableArray`1" />)을 지정하여 모든 <paramref name="rank" /> 하위 범위를 0으로 설정합니다.
배열은 <paramref name="rank" />보다 짧을 수 있지만 더 길면 안 됩니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="rank" />가 범위 [1, 0xffff]를 벗어나거나 <see langword="sizes.Length" /> 또는 <see langword="lowerBounds.Length" />보다 작은 경우</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="sizes" />이(가) <see langword="null" />인 경우</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.BlobEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Action{System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder},System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder})">
      <summary>사용자 지정 특성 시그니처 Blob을 인코딩합니다.</summary>
      <param name="fixedArguments">고정 인수를 인코딩하기 위해 먼저 호출됩니다.</param>
      <param name="namedArguments">명명된 인수를 인코딩하기 위해 두 번째로 호출됩니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="fixedArguments" /> 또는 <paramref name="namedArguments" />가 <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder@,System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder@)">
      <summary>사용자 지정 특성 시그니처 Blob을 인코딩합니다.
매개 변수 목록에 나타나는 순서대로 사용해야 하는 인코더 쌍을 반환합니다.</summary>
      <param name="fixedArguments">고정 인수를 인코딩하기 위해 first를 사용합니다.</param>
      <param name="namedArguments">명명된 인수를 인코딩하기 위해 second를 사용합니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature">
      <summary>필드 시그니처 Blob을 인코딩합니다.</summary>
      <returns>필드 형식의 인코더.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.LocalVariableSignature(System.Int32)">
      <summary>지역 변수 시그니처를 인코딩합니다.</summary>
      <param name="variableCount">지역 변수의 수.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="variableCount" />가 [0, 0x1fffffff] 범위에 있지 않습니다.</exception>
      <returns>지역 변수 시퀀스의 인코더.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSignature(System.Reflection.Metadata.SignatureCallingConvention,System.Int32,System.Boolean)">
      <summary>메서드 시그니처 Blob을 인코딩합니다.</summary>
      <param name="convention">호출 규칙입니다.</param>
      <param name="genericParameterCount">제네릭 매개 변수의 수.</param>
      <param name="isInstanceMethod">인스턴스 메서드 시그니처를 인코딩하려면 <see langword="true" />, 정적 메서드 시그니처를 인코딩하려면 <see langword="false" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericParameterCount" />가 [0, 0xffff] 범위에 있지 않습니다.</exception>
      <returns>반환 값 및 매개 변수를 포함한 나머지 시그니처의 인코더.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSpecificationSignature(System.Int32)">
      <summary>메서드 사양 시그니처 Blob을 인코딩합니다.</summary>
      <param name="genericArgumentCount">제네릭 인수 수.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericArgumentCount" />가 [0, 0xffff] 범위에 있지 않습니다.</exception>
      <returns>제네릭 인수의 인코더.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetArguments(System.Int32)">
      <summary>권한 집합 인수를 인코딩합니다.</summary>
      <param name="argumentCount">집합의 인수 개수.</param>
      <returns>집합의 인수 인코더.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetBlob(System.Int32)">
      <summary>권한 집합 blob을 인코딩합니다.</summary>
      <param name="attributeCount">집합의 특성 개수.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="attributeCount" />가 [0, 0x1fffffff] 범위에 있지 않습니다.</exception>
      <returns>권한 집합 인코더.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PropertySignature(System.Boolean)">
      <summary>속성 시그니처 Blob을 인코딩합니다.</summary>
      <param name="isInstanceProperty">인스턴스 속성 시그니처를 인코딩하려면 <see langword="true" />, 정적 속성 시그니처를 인코딩하려면 <see langword="false" />.</param>
      <returns>메서드 시그니처와 동일한 구조를 포함하는 반환 값 및 매개 변수를 포함한 나머지 시그니처의 인코더.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.TypeSpecificationSignature">
      <summary>형식 사양 시그니처를 인코딩합니다.</summary>
      <returns>형식 사양으로 표현되는 구조적 형식의 형식 인코더(기본 형식을 인코딩하지 않아야 함).</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.BlobEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CodedIndex" />
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.CustomAttributeType(System.Reflection.Metadata.EntityHandle)">
      <summary>지정된 핸들에 대해 CustomAttributeType으로 코딩된 인덱스를 계산합니다.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">예기치 않은 핸들 형식입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasConstant(System.Reflection.Metadata.EntityHandle)">
      <summary>지정된 핸들에 대해 HasConstant로 코딩된 인덱스를 계산합니다.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />또는 <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">예기치 않은 핸들 형식입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomAttribute(System.Reflection.Metadata.EntityHandle)">
      <summary>지정된 핸들에 대해 HasCustomAttribute로 코딩된 인덱스를 계산합니다.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" /> 또는 <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">예기치 않은 핸들 형식입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <summary>지정된 핸들에 대해 HasCustomDebugInformation으로 코딩된 인덱스를 계산합니다.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />, <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.DocumentHandle" />, <see cref="T:System.Reflection.Metadata.LocalScopeHandle" />, <see cref="T:System.Reflection.Metadata.LocalVariableHandle" />, <see cref="T:System.Reflection.Metadata.LocalConstantHandle" /> 또는 <see cref="T:System.Reflection.Metadata.ImportScopeHandle" />.</param>
      <exception cref="T:System.ArgumentException">예기치 않은 핸들 형식입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasDeclSecurity(System.Reflection.Metadata.EntityHandle)">
      <summary>지정된 핸들에 대해 HasDeclSecurity로 코딩된 인덱스를 계산합니다.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />또는 <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">예기치 않은 핸들 형식입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasFieldMarshal(System.Reflection.Metadata.EntityHandle)">
      <summary>지정된 핸들에 대해 HasFieldMarshal로 코딩된 인덱스를 계산합니다.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.ParameterHandle" /> 또는 <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">예기치 않은 핸들 형식입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasSemantics(System.Reflection.Metadata.EntityHandle)">
      <summary>지정된 핸들에 대해 HasSemantics로 코딩된 인덱스를 계산합니다.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">예기치 않은 핸들 형식입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.Implementation(System.Reflection.Metadata.EntityHandle)">
      <summary>지정된 핸들에 대해 구현이 코딩된 인덱스를 계산합니다.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> 또는 <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">예기치 않은 핸들 형식입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberForwarded(System.Reflection.Metadata.EntityHandle)">
      <summary>지정된 핸들에 대해 MemberForwarded로 코딩된 인덱스를 계산합니다.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.FieldDefinition" />, <see cref="T:System.Reflection.Metadata.MethodDefinition" /></param>
      <exception cref="T:System.ArgumentException">예기치 않은 핸들 형식입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberRefParent(System.Reflection.Metadata.EntityHandle)">
      <summary>지정된 핸들에 대해 MemberRefParent로 코딩된 인덱스를 계산합니다.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">예기치 않은 핸들 형식입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MethodDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <summary>지정된 핸들에 대해 MethodDefOrRef로 코딩된 인덱스를 계산합니다.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">예기치 않은 핸들 형식입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.ResolutionScope(System.Reflection.Metadata.EntityHandle)">
      <summary>지정된 핸들에 대해 ResolutionScope로 코딩된 인덱스를 계산합니다.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> 또는 <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">예기치 않은 핸들 형식입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <summary>지정된 핸들에 대해 TypeDefOrRef로 코딩된 인덱스를 계산합니다.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">예기치 않은 핸들 형식입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRefOrSpec(System.Reflection.Metadata.EntityHandle)">
      <summary>지정된 핸들에 대해 TypeDefOrRefOrSpec으로 코딩된 인덱스를 계산합니다.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 또는 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /></param>
      <exception cref="T:System.ArgumentException">예기치 않은 핸들 형식입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeOrMethodDef(System.Reflection.Metadata.EntityHandle)">
      <summary>지정된 핸들에 대해 TypeOrMethodDef로 코딩된 인덱스를 계산합니다.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">예기치 않은 핸들 형식입니다.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.#ctor" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddCatchRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Catch 영역을 추가합니다.</summary>
      <param name="tryStart">Try 블록의 첫 번째 명령을 표시하는 레이블입니다.</param>
      <param name="tryEnd">Try 블록의 바로 다음 명령을 표시하는 레이블입니다.</param>
      <param name="handlerStart">처리기의 첫 번째 명령을 표시하는 레이블입니다.</param>
      <param name="handlerEnd">처리기의 바로 다음 명령을 표시하는 레이블입니다.</param>
      <param name="catchType">Catch할 예외의 형식: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 또는 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">이 작성기가 연결된 명령 인코더에서 레이블을 정의하지 않았습니다.

또는

<paramref name="catchType" />이 올바른 형식 핸들이 아닙니다.</exception>
      <exception cref="T:System.ArgumentNullException">레이블에 기본값이 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFaultRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>오류 영역을 추가합니다.</summary>
      <param name="tryStart">Try 블록의 첫 번째 명령을 표시하는 레이블입니다.</param>
      <param name="tryEnd">Try 블록의 바로 다음 명령을 표시하는 레이블입니다.</param>
      <param name="handlerStart">처리기의 첫 번째 명령을 표시하는 레이블입니다.</param>
      <param name="handlerEnd">처리기의 바로 다음 명령을 표시하는 레이블입니다.</param>
      <exception cref="T:System.ArgumentException">이 작성기가 연결된 명령 인코더에서 레이블을 정의하지 않았습니다.</exception>
      <exception cref="T:System.ArgumentNullException">레이블에 기본값이 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFilterRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>Catch 영역을 추가합니다.</summary>
      <param name="tryStart">Try 블록의 첫 번째 명령을 표시하는 레이블입니다.</param>
      <param name="tryEnd">Try 블록의 바로 다음 명령을 표시하는 레이블입니다.</param>
      <param name="handlerStart">처리기의 첫 번째 명령을 표시하는 레이블입니다.</param>
      <param name="handlerEnd">처리기의 바로 다음 명령을 표시하는 레이블입니다.</param>
      <param name="filterStart">필터 블록의 첫 번째 명령을 표시하는 레이블입니다.</param>
      <exception cref="T:System.ArgumentException">이 작성기가 연결된 명령 인코더에서 레이블을 정의하지 않았습니다.</exception>
      <exception cref="T:System.ArgumentNullException">레이블에 기본값이 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFinallyRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>Finally 영역을 추가합니다.</summary>
      <param name="tryStart">Try 블록의 첫 번째 명령을 표시하는 레이블입니다.</param>
      <param name="tryEnd">Try 블록의 바로 다음 명령을 표시하는 레이블입니다.</param>
      <param name="handlerStart">처리기의 첫 번째 명령을 표시하는 레이블입니다.</param>
      <param name="handlerEnd">처리기의 바로 다음 명령을 표시하는 레이블입니다.</param>
      <exception cref="T:System.ArgumentException">이 작성기가 연결된 명령 인코더에서 레이블을 정의하지 않았습니다.</exception>
      <exception cref="T:System.ArgumentNullException">레이블에 기본값이 있습니다.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ElementType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ObjectArray" />
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Boolean" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Enum(System.String)">
      <param name="enumTypeName" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveSerializationTypeCode)">
      <param name="type" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SystemType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt64" />
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Count(System.Int32)">
      <param name="count" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.AddModifier(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <summary>사용자 지정 한정자를 인코딩합니다.</summary>
      <param name="type">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 또는 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <param name="isOptional">선택적 한정자입니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" />이 <see langword="null" />이거나 예기치 않은 종류입니다.</exception>
      <returns>후속 한정자의 인코더입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry" />
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.#ctor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="handle" />
      <param name="operation" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Handle" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Operation" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueOperation" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddEvent" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddField" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddParameter" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddProperty" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.Default" />
    <member name="T:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Add(System.Reflection.Metadata.ExceptionRegionKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <summary>예외 절을 추가합니다.</summary>
      <param name="kind">절 종류.</param>
      <param name="tryOffset">Try 블록 시작 오프셋.</param>
      <param name="tryLength">Try 블록 길이.</param>
      <param name="handlerOffset">처리기 시작 오프셋.</param>
      <param name="handlerLength">처리기 길이.</param>
      <param name="catchType">
        <paramref name="kind" />가 <see cref="F:System.Reflection.Metadata.ExceptionRegionKind.Catch" />가 아닌 경우 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 또는 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /></param>
      <param name="filterOffset">필터 블록의 오프셋이거나, <paramref name="kind" />가 <see cref="F:System.Reflection.Metadata.ExceptionRegionKind.Filter" />가 아닌 경우 0입니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="catchType" />이 잘못되었습니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="kind" />의 값이 잘못된 경우
          
또는

<paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> 또는 <paramref name="handlerLength" />가 범위를 벗어났습니다.</exception>
      <exception cref="T:System.InvalidOperationException">메서드 본문이 예외 영역을 포함하도록 선언되지 않았습니다.</exception>
      <returns>다음 절의 인코더.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddCatch(System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle)">
      <summary>오류 절을 추가합니다.</summary>
      <param name="tryOffset">Try 블록 시작 오프셋.</param>
      <param name="tryLength">Try 블록 길이.</param>
      <param name="handlerOffset">처리기 시작 오프셋.</param>
      <param name="handlerLength">처리기 길이.</param>
      <param name="catchType">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 또는 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="catchType" />이 잘못되었습니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> 또는 <paramref name="handlerLength" />가 범위를 벗어났습니다.</exception>
      <exception cref="T:System.InvalidOperationException">메서드 본문이 예외 영역을 포함하도록 선언되지 않았습니다.</exception>
      <returns>다음 절의 인코더.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFault(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>오류 절을 추가합니다.</summary>
      <param name="tryOffset">Try 블록 시작 오프셋.</param>
      <param name="tryLength">Try 블록 길이.</param>
      <param name="handlerOffset">처리기 시작 오프셋.</param>
      <param name="handlerLength">처리기 길이.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> 또는 <paramref name="handlerLength" />가 범위를 벗어났습니다.</exception>
      <exception cref="T:System.InvalidOperationException">메서드 본문이 예외 영역을 포함하도록 선언되지 않았습니다.</exception>
      <returns>다음 절의 인코더.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFilter(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>오류 절을 추가합니다.</summary>
      <param name="tryOffset">Try 블록 시작 오프셋.</param>
      <param name="tryLength">Try 블록 길이.</param>
      <param name="handlerOffset">처리기 시작 오프셋.</param>
      <param name="handlerLength">처리기 길이.</param>
      <param name="filterOffset">필터 블록의 오프셋.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> 또는 <paramref name="handlerLength" />가 범위를 벗어났습니다.</exception>
      <exception cref="T:System.InvalidOperationException">메서드 본문이 예외 영역을 포함하도록 선언되지 않았습니다.</exception>
      <returns>다음 절의 인코더.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFinally(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Finally 절을 추가합니다.</summary>
      <param name="tryOffset">Try 블록 시작 오프셋.</param>
      <param name="tryLength">Try 블록 길이.</param>
      <param name="handlerOffset">처리기 시작 오프셋.</param>
      <param name="handlerLength">처리기 길이.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> 또는 <paramref name="handlerLength" />가 범위를 벗어났습니다.</exception>
      <exception cref="T:System.InvalidOperationException">메서드 본문이 예외 영역을 포함하도록 선언되지 않았습니다.</exception>
      <returns>다음 절의 인코더.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallExceptionRegion(System.Int32,System.Int32)">
      <summary>영역이 작은 형식에 맞는 경우 <see langword="true" />를 반환합니다.</summary>
      <param name="startOffset">영역의 시작 오프셋.</param>
      <param name="length">영역의 길이.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallRegionCount(System.Int32)">
      <summary>예외 영역 수가 처음 작은 형식인 경우 <see langword="true" />를 반환합니다.</summary>
      <param name="exceptionRegionCount">예외 영역의 수.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Builder">
      <summary>기본 작성기.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.HasSmallFormat">
      <summary>인코더가 작은 형식을 사용하는 경우 <see langword="true" />입니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions">
      <summary>ExportedType 테이블의 TypeDefinitionId 열에 액세스하는 확장 메서드를 제공합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions.GetTypeDefinitionId(System.Reflection.Metadata.ExportedType)">
      <summary>모듈의 TypeDef 테이블에서 대상 형식의 가능한 행 번호에 대한 힌트를 가져옵니다.
네임스페이스와 이름이 일치하지 않으면 확인은 대상 TypeDef 테이블의 전체 검색으로 대체됩니다. <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder" />가 <see langword="true" />인 경우 무시되거나 0이 됩니다.</summary>
      <param name="exportedType" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasExplicitThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.None" />
    <member name="T:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.HeapIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Blob" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Guid" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.String" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.UserString" />
    <member name="T:System.Reflection.Metadata.Ecma335.InstructionEncoder">
      <summary>명령을 인코딩합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.Ecma335.ControlFlowBuilder)">
      <summary>코드 및 제어 흐름 작성기가 지원되는 인코더를 생성합니다.</summary>
      <param name="codeBuilder">인코딩된 명령을 쓸 작성기.</param>
      <param name="controlFlowBuilder">작성기 추적 레이블, 분기 및 예외 처리기.
<see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)" />, <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel" />, <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)" /> 등과 같은 <see cref="T:System.Reflection.Metadata.Ecma335.InstructionEncoder" />의 제어 흐름 팩터리 메서드 중 일부를 사용할 수 있도록 지정되어야 합니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>분기 명령을 인코딩합니다.</summary>
      <param name="code">인코딩할 분기 명령.</param>
      <param name="label">명령 스트림에서 대상 위치의 레이블.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="code" />가 분기 명령이 아닌 경우

또는 
<paramref name="label" />이 인코더에서 정의되지 않은 경우</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="label" />에 기본값이 있는 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.EntityHandle)">
      <summary>
        <c>call</c> 명령 및 해당 피연산자를 인코딩합니다.</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MemberReferenceHandle)">
      <summary>
        <c>call</c> 명령 및 해당 피연산자를 인코딩합니다.</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>
        <c>call</c> 명령 및 해당 피연산자를 인코딩합니다.</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodSpecificationHandle)">
      <summary>
        <c>call</c> 명령 및 해당 피연산자를 인코딩합니다.</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.CallIndirect(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <summary>
        <c>call</c> 명령 및 해당 피연산자를 인코딩합니다.</summary>
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel">
      <summary>나중에 명령 스트림에서의 위치를 표시하고 참조하는 데 사용할 수 있는 레이블을 정의합니다.</summary>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" />이(가) <see langword="null" />인 경우</exception>
      <returns>레이블 핸들.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgument(System.Int32)">
      <summary>인수 로드 명령을 인코딩합니다.</summary>
      <param name="argumentIndex">인수의 인덱스.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="argumentIndex" />가 음수입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgumentAddress(System.Int32)">
      <summary>인수 주소 로드 명령을 인코딩합니다.</summary>
      <param name="argumentIndex">인수의 인덱스.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="argumentIndex" />가 음수입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI4(System.Int32)">
      <summary>
        <see cref="T:System.Int32" /> 상수 로드 명령을 인코딩합니다.</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI8(System.Int64)">
      <summary>
        <see cref="T:System.Int64" /> 상수 로드 명령을 인코딩합니다.</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR4(System.Single)">
      <summary>
        <see cref="T:System.Single" /> 상수 로드 명령을 인코딩합니다.</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR8(System.Double)">
      <summary>
        <see cref="T:System.Double" /> 상수 로드 명령을 인코딩합니다.</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocal(System.Int32)">
      <summary>지역 변수 로드 명령을 인코딩합니다.</summary>
      <param name="slotIndex">지역 변수 슬롯의 인덱스.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="slotIndex" />가 음수입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocalAddress(System.Int32)">
      <summary>지역 변수 주소 로드 명령을 인코딩합니다.</summary>
      <param name="slotIndex">지역 변수 슬롯의 인덱스.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="slotIndex" />가 음수입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)">
      <summary>
        <c>ldstr</c> 명령 및 해당 피연산자를 인코딩합니다.</summary>
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>지정된 레이블을 현재 IL 오프셋과 연결합니다.</summary>
      <param name="label">표시할 레이블.</param>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="label" />이 인코더에서 정의되지 않은 경우</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="label" />에 기본값이 있는 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.OpCode(System.Reflection.Metadata.ILOpCode)">
      <summary>지정된 작업 코드를 인코딩합니다.</summary>
      <param name="code" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreArgument(System.Int32)">
      <summary>인수 저장 명령을 인코딩합니다.</summary>
      <param name="argumentIndex">인수의 인덱스.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="argumentIndex" />가 음수입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreLocal(System.Int32)">
      <summary>지역 변수 저장 명령을 인코딩합니다.</summary>
      <param name="slotIndex">지역 변수 슬롯의 인덱스.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="slotIndex" />가 음수입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Int32)">
      <summary>토큰을 인코딩합니다.</summary>
      <param name="token" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Reflection.Metadata.EntityHandle)">
      <summary>토큰을 인코딩합니다.</summary>
      <param name="handle" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.CodeBuilder">
      <summary>인코딩된 명령이 작성되는 기본 작성기.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder">
      <summary>작성기 추적 레이블, 분기 및 예외 처리기.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.Offset">
      <summary>다음 인코딩된 명령의 오프셋.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LabelHandle" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Equality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Inequality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.Id">
      <summary>
        <see cref="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />의 컨텍스트 내에서 레이블을 식별하는, 1부터 시작되는 ID입니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralEncoder">
      <summary>리터럴을 인코딩하기 위한 메서드를 제공합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder">지정된 BLOB 빌더를 사용하여 <see cref="T:System.Reflection.Metadata.Ecma335.LiteralEncoder" /> 클래스의 새 인스턴스를 만듭니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Scalar">
      <summary>리터럴 값을 인코딩하는 데 사용되는 인코더를 반환합니다.</summary>
      <returns>리터럴 값의 인코더입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ScalarEncoder})">
      <summary>지정된 대리자를 사용하여 리터럴의 형식 및 값을 인코딩합니다.</summary>
      <param name="type">리터럴의 형식을 인코딩하는 데 사용되는 대리자입니다. 이 메서드에서 처음 호출됩니다.</param>
      <param name="scalar">리터럴의 값을 인코딩하는 데 사용되는 대리자입니다. 이 메서드에서 두 번째로 호출됩니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> 또는 <paramref name="scalar" />가 <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder@,System.Reflection.Metadata.Ecma335.ScalarEncoder@)">
      <summary>매개 변수 목록에 나타나는 순서대로 리터럴의 형식과 값을 인코딩하는 데 사용해야 하는 인코더 쌍을 반환합니다.</summary>
      <param name="type">이 메서드가 반환될 때 리터럴의 형식을 인코딩하는 데 사용되는 사용자 지정 특성 요소 형식 인코더입니다.</param>
      <param name="scalar">이 메서드가 반환될 때 리터럴의 값을 인코딩하는 데 사용되는 스칼라 인코더입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.VectorEncoder})">
      <summary>지정된 대리자를 사용하여 벡터의 형식 및 항목을 인코딩합니다.</summary>
      <param name="arrayType">벡터의 형식을 인코딩하는 데 사용되는 대리자입니다. 이 메서드에서 처음 호출됩니다.</param>
      <param name="vector">벡터의 항목을 인코딩하는 데 사용되는 대리자입니다. 이 메서드에서 두 번째로 호출됩니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="arrayType" /> 또는 <paramref name="vector" />가 <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder@,System.Reflection.Metadata.Ecma335.VectorEncoder@)">
      <summary>매개 변수 목록에 나타나는 순서대로 벡터 리터럴의 형식과 항목을 인코딩하는 데 사용해야 하는 인코더 쌍을 반환합니다.</summary>
      <param name="arrayType">이 메서드가 반환될 때 벡터의 형식을 인코딩하는 데 사용되는 사용자 지정 특성 배열 형식 인코더입니다.</param>
      <param name="vector">이 메서드가 반환될 때 벡터의 항목을 인코딩하는 데 사용되는 벡터 인코더입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Vector">
      <summary>벡터의 항목을 인코딩하는 데 사용되는 벡터 인코더를 가져옵니다.</summary>
      <returns>벡터의 항목을 인코딩하는 데 사용되는 벡터 인코더입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.AddLiteral" />
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.AddVariable" />
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Type(System.Boolean,System.Boolean)">
      <param name="isByRef" />
      <param name="isPinned" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.TypedReference" />
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataAggregator" />
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseTableRowCounts" />
      <param name="baseHeapSizes" />
      <param name="deltaReaders" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Reflection.Metadata.MetadataReader,System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseReader" />
      <param name="deltaReaders" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.GetGenerationHandle(System.Reflection.Metadata.Handle,System.Int32@)">
      <summary>집계 메타데이터 내의 엔터티 핸들을 토대로, 엔터티가 정의되는 메타데이터 생성 내의 엔터티 핸들을 계산합니다.</summary>
      <param name="handle">집계 메타데이터의 엔터티 핸들입니다.</param>
      <param name="generation">엔터티가 정의되는 생성입니다.</param>
      <returns>메타데이터 <paramref name="generation" />의 엔터티 핸들입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataBuilder">
      <summary>MetadataBuilder 클래스는 고성능 방식으로 어셈블리에 대한 메타데이터를 읽고 씁니다. 컴파일러 및 기타 어셈블리 생성 도구에서 사용하도록 설계되었습니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>메타데이터 테이블 및 힙에 대한 작성기를 만듭니다.</summary>
      <param name="userStringHeapStartOffset">사용자 문자열 힙의 시작 오프셋입니다. 메타데이터가 EnC 델타 메타데이터가 아닌 한, 모든 이전 EnC 생성의 사용자 문자열 힙 누적 크기는 0이어야 합니다.</param>
      <param name="stringHeapStartOffset">문자열 힙의 시작 오프셋입니다. 메타데이터가 EnC 델타 메타데이터가 아닌 한, 모든 이전 EnC 생성의 문자열 힙 누적 크기는 0이어야 합니다.</param>
      <param name="blobHeapStartOffset">Blob 힙의 시작 오프셋입니다. 메타데이터가 EnC 델타 메타데이터가 아닌 한, 모든 이전 EnC 생성의 Blob 힙 누적 크기는 0이어야 합니다.</param>
      <param name="guidHeapStartOffset">GUID 힙의 시작 오프셋입니다. 메타데이터가 EnC 델타 메타데이터가 아닌 한, 모든 이전 EnC 생성의 GUID 힙 누적 크기는 0이어야 합니다.</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">오프셋이 너무 큽니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">오프셋이 음수입니다.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="guidHeapStartOffset" />이 GUID 크기의 배수가 아닙니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssembly(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.AssemblyHashAlgorithm)">
      <param name="name" />
      <param name="version" />
      <param name="culture" />
      <param name="publicKey" />
      <param name="flags" />
      <param name="hashAlgorithm" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyFile(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Boolean)">
      <param name="name" />
      <param name="hashValue" />
      <param name="containsMetadata" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyReference(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.Metadata.BlobHandle)">
      <param name="name" />
      <param name="version" />
      <param name="culture" />
      <param name="publicKeyOrToken" />
      <param name="flags" />
      <param name="hashValue" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddConstant(System.Reflection.Metadata.EntityHandle,System.Object)">
      <summary>매개 변수, 필드 또는 속성의 기본값을 추가합니다.</summary>
      <param name="parent">부모 엔터티 핸들이며 <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" /> 중 하나일 수 있습니다.</param>
      <param name="value">상수 값입니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" />에 필요한 핸들 종류가 없습니다.</exception>
      <returns>추가된 상수에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>사용자 지정 특성을 추가합니다.</summary>
      <param name="parent">사용자 지정 특성을 추가할 엔터티: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" /> 또는 <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />입니다.</param>
      <param name="constructor">사용자 지정 특성 생성자: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />입니다.</param>
      <param name="value">사용자 지정 특성 값 Blob입니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" />에 필요한 핸들 종류가 없습니다.</exception>
      <returns>추가된 사용자 지정 특성에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomDebugInformation(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>사용자 지정 디버그 정보를 추가합니다.</summary>
      <param name="parent">디버그 정보를 연결할 엔터티: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />, <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.DocumentHandle" />, <see cref="T:System.Reflection.Metadata.LocalScopeHandle" />, <see cref="T:System.Reflection.Metadata.LocalVariableHandle" />, <see cref="T:System.Reflection.Metadata.LocalConstantHandle" /> 또는 <see cref="T:System.Reflection.Metadata.ImportScopeHandle" />입니다.</param>
      <param name="kind">정보 종류입니다. <paramref name="value" /> Blob의 구조를 결정합니다.</param>
      <param name="value">사용자 지정 디버그 정보 Blob입니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" />에 필요한 핸들 종류가 없습니다.</exception>
      <returns>추가된 사용자 지정 디버그 정보에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDeclarativeSecurityAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.DeclarativeSecurityAction,System.Reflection.Metadata.BlobHandle)">
      <summary>형식, 메서드 또는 어셈블리에 선언적 보안 특성을 추가합니다.</summary>
      <param name="parent">부모 엔터티 핸들이며 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" /> 중 하나일 수 있습니다.</param>
      <param name="action">선언적 보안 작업입니다.</param>
      <param name="permissionSet">권한 집합 Blob입니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" />에 필요한 핸들 종류가 없습니다.</exception>
      <returns>추가된 선언적 보안 특성에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDocument(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle)">
      <summary>문서 디버그 정보를 추가합니다.</summary>
      <param name="name">문서 이름 Blob입니다.</param>
      <param name="hashAlgorithm">
        <paramref name="hash" /> 값을 계산하는 데 사용되는 해시 알고리즘의 GUID입니다.</param>
      <param name="hash">문서 콘텐츠의 해시입니다.</param>
      <param name="language">언어의 GUID입니다.</param>
      <returns>추가된 문서에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncLogEntry(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="entity" />
      <param name="code" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncMapEntry(System.Reflection.Metadata.EntityHandle)">
      <param name="entity" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEvent(System.Reflection.EventAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>이벤트 정의를 추가합니다.</summary>
      <param name="attributes">이벤트 특성입니다.</param>
      <param name="name">이벤트 이름입니다.</param>
      <param name="type">이벤트 유형: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 또는 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />입니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" />에 필요한 핸들 종류가 없습니다.</exception>
      <returns>추가된 이벤트 정의에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEventMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="declaringType" />
      <param name="eventList" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddExportedType(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <summary>내보낸 형식을 추가합니다.</summary>
      <param name="attributes">형식 특성입니다.</param>
      <param name="namespace">형식 네임스페이스입니다.</param>
      <param name="name">형식 이름입니다.</param>
      <param name="implementation">구현 엔터티 핸들이며 <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> 또는 <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> 중 하나일 수 있습니다.</param>
      <param name="typeDefinitionId">형식 정의 ID입니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="implementation" />에 필요한 핸들 종류가 없습니다.</exception>
      <returns>추가된 내보낸 형식에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldDefinition(System.Reflection.FieldAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>필드 정의를 추가합니다.</summary>
      <param name="attributes">필드 특성입니다.</param>
      <param name="name">필드 이름입니다.</param>
      <param name="signature">필드 시그니처입니다. <see cref="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature" />를 사용하여 Blob을 생성합니다.</param>
      <returns>추가된 필드 정의에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldLayout(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary>필드 정의의 필드 레이아웃을 정의합니다.</summary>
      <param name="field">필드 정의 핸들입니다.</param>
      <param name="offset">선언 형식 인스턴스 내에 있는 필드의 바이트 오프셋입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldRelativeVirtualAddress(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary>PE 이미지에 저장된 초기 값에 필드의 매핑을 추가합니다.</summary>
      <param name="field">필드 정의 핸들입니다.</param>
      <param name="offset">매핑된 필드의 초기 값을 저장하는 PE 이미지의 블록 내 오프셋입니다(일반적으로 .text 섹션에 있음).</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" />가 음수입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameter(System.Reflection.Metadata.EntityHandle,System.Reflection.GenericParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary>제네릭 매개 변수 정의를 추가합니다.</summary>
      <param name="parent">부모 엔터티 핸들이며 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 중 하나일 수 있습니다.</param>
      <param name="attributes">제네릭 매개 변수 특성입니다.</param>
      <param name="name">매개 변수 이름입니다.</param>
      <param name="index">0부터 시작하는 매개 변수 인덱스입니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" />에 필요한 핸들 종류가 없습니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" />가 <see cref="F:System.UInt16.MaxValue" />보다 큰 경우</exception>
      <returns>추가된 제네릭 매개 변수에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameterConstraint(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>제네릭 매개 변수에 형식 제약 조건을 추가합니다.</summary>
      <param name="genericParameter">제한할 제네릭 매개 변수입니다.</param>
      <param name="constraint">형식 제약 조건이며 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 또는 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> 중 하나일 수 있습니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="genericParameter" />에 필요한 핸들 종류가 없습니다.</exception>
      <returns>추가된 제네릭 매개 변수 제약 조건에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddImportScope(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>로컬 범위 디버그 정보를 추가합니다.</summary>
      <param name="parentScope">부모 범위 핸들입니다.</param>
      <param name="imports">가져오기 범위 핸들입니다.</param>
      <returns>추가된 가져오기 범위에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddInterfaceImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>형식에 인터페이스 구현을 추가합니다.</summary>
      <param name="type">인터페이스를 구현하는 형식입니다.</param>
      <param name="implementedInterface">구현되는 인터페이스이며 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 또는 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> 중 하나일 수 있습니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="implementedInterface" />에 필요한 핸들 종류가 없습니다.</exception>
      <returns>추가된 인터페이스 구현에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalConstant(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>지역 상수 디버그 정보를 추가합니다.</summary>
      <param name="name">변수의 이름입니다.</param>
      <param name="signature">LocalConstantSig Blob입니다.</param>
      <returns>추가된 지역 상수에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalScope(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalConstantHandle,System.Int32,System.Int32)">
      <summary>로컬 범위 디버그 정보를 추가합니다.</summary>
      <param name="method">포함하는 메서드입니다.</param>
      <param name="importScope">연결된 가져오기 범위의 핸들입니다.</param>
      <param name="variableList">범위가 변수를 선언하는 경우 이를 첫 번째 변수의 핸들로 설정합니다. 그렇지 않으면 이를 다음 범위 정의에 의해 선언된 첫 번째 변수의 핸들로 설정합니다. 범위가 변수를 정의하지 않으면 <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(1)" />입니다.</param>
      <param name="constantList">범위가 상수를 선언하는 경우 이를 첫 번째 상수의 핸들로 설정합니다. 그렇지 않으면 이를 다음 범위 정의에 의해 선언된 첫 번째 상수의 핸들로 설정합니다. 범위가 상수를 정의하지 않으면 <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(1)" />입니다.</param>
      <param name="startOffset">범위에 포함된 첫 번째 명령의 오프셋입니다.</param>
      <param name="length">범위의 길이(바이트)입니다.</param>
      <returns>추가된 로컬 범위에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalVariable(System.Reflection.Metadata.LocalVariableAttributes,System.Int32,System.Reflection.Metadata.StringHandle)">
      <summary>지역 변수 디버그 정보를 추가합니다.</summary>
      <param name="attributes">지역 변수 특성입니다.</param>
      <param name="index">로컬 시그니처의 지역 변수에 대한 0부터 시작하는 인덱스입니다.</param>
      <param name="name">변수의 이름입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" />가 <see cref="F:System.UInt16.MaxValue" />보다 큰 경우</exception>
      <returns>추가된 지역 변수에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddManifestResource(System.Reflection.ManifestResourceAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.UInt32)">
      <summary>매니페스트 리소스를 추가합니다.</summary>
      <param name="attributes">매니페스트 리소스 특성입니다.</param>
      <param name="name">매니페스트 리소스의 이름입니다.</param>
      <param name="implementation">구현 엔터티 핸들이며 <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> 또는 <see langword="null" /> 중 하나일 수 있습니다.</param>
      <param name="offset">이 리소스 레코드가 시작되는 참조된 파일 내의 바이트 오프셋을 지정합니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="implementation" />에 필요한 핸들 종류가 없습니다.</exception>
      <returns>추가된 매니페스트 리소스에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMarshallingDescriptor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>필드 또는 매개 변수에 마샬링 정보를 추가합니다.</summary>
      <param name="parent">부모 엔터티 핸들이며 <see cref="T:System.Reflection.Metadata.ParameterHandle" /> 또는 <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> 중 하나일 수 있습니다.</param>
      <param name="descriptor">설명자 Blob입니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" />에 필요한 핸들 종류가 없습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMemberReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>MemberRef 테이블 행을 추가합니다.</summary>
      <param name="parent">포함하는 엔터티이며 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> 중 하나일 수 있습니다.</param>
      <param name="name">멤버 이름입니다.</param>
      <param name="signature">멤버 시그니처입니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" />에 필요한 핸들 종류가 없습니다.</exception>
      <returns>추가된 멤버 참조에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDebugInformation(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>메서드 디버그 정보를 추가합니다.</summary>
      <param name="document">메서드의 모든 시퀀스 위치를 포함하는 단일 문서의 핸들이거나, 메서드에 시퀀스 위치가 없거나 메서드가 여러 문서에 걸쳐 있는 경우 <see langword="null" />입니다.</param>
      <param name="sequencePoints">시퀀스 위치 Blob이거나, 메서드에 시퀀스 위치가 없는 경우 <see langword="null" />입니다.</param>
      <returns>추가된 메서드 디버그 정보에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDefinition(System.Reflection.MethodAttributes,System.Reflection.MethodImplAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Int32,System.Reflection.Metadata.ParameterHandle)">
      <summary>메서드 정의를 추가합니다.</summary>
      <param name="attributes">메서드 특성입니다.</param>
      <param name="implAttributes">메서드 구현 특성입니다.</param>
      <param name="name">메서드 이름입니다.</param>
      <param name="signature">메서드 시그니처입니다.</param>
      <param name="bodyOffset">메서드 본문(IL 스트림)을 저장하는 PE 이미지의 블록 내 오프셋이거나, 메서드에 본문이 없는 경우 -1입니다.</param>
      <param name="parameterList">메서드가 Params 테이블에 매개 변수를 선언하는 경우 이를 첫 번째 매개 변수의 핸들로 설정합니다. 그렇지 않으면 이를 다음 메서드 정의에 의해 선언된 첫 번째 매개 변수의 핸들로 설정합니다. 모듈에 선언된 매개 변수가 없으면 <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(1)" />입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="bodyOffset" />이 -1보다 작습니다.</exception>
      <returns>추가된 메서드 정의에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>형식 내의 메서드 선언에 대한 구현을 정의합니다.</summary>
      <param name="type">형식 정의입니다.</param>
      <param name="methodBody">메서드 본문 엔터티 핸들이며 <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /> 중 하나일 수 있습니다.</param>
      <param name="methodDeclaration">메서드 선언 엔터티 핸들이며 <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /> 중 하나일 수 있습니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="methodBody" /> 또는 <paramref name="methodDeclaration" />에 필요한 핸들 종류가 없습니다.</exception>
      <returns>추가된 메서드 구현에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImport(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.MethodImportAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <summary>메서드 정의에 가져오기 정보를 추가합니다.</summary>
      <param name="method">메서드 정의 핸들입니다.</param>
      <param name="attributes">메서드 가져오기 특성입니다.</param>
      <param name="name">관리되지 않는 메서드 이름입니다.</param>
      <param name="module">관리되지 않는 메서드를 포함하는 모듈입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSemantics(System.Reflection.Metadata.EntityHandle,System.Reflection.MethodSemanticsAttributes,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>메서드(getter, setter, adder 등)를 속성 또는 이벤트와 연결합니다.</summary>
      <param name="association">연결 엔터티 핸들이며 <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" /> 중 하나일 수 있습니다.</param>
      <param name="semantics">메서드 의미 체계 특성입니다.</param>
      <param name="methodDefinition">메서드 정의입니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="association" />에 필요한 핸들 종류가 없습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSpecification(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>메서드 사양(인스턴스화)을 추가합니다.</summary>
      <param name="method">제네릭 메서드 엔터티 핸들이며 <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /> 중 하나일 수 있습니다.</param>
      <param name="instantiation">메서드의 제네릭 인수를 인코딩하는 인스턴스화 Blob입니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" />에 필요한 핸들 종류가 없습니다.</exception>
      <returns>추가된 메서드 사양에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModule(System.Int32,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="generation" />
      <param name="moduleName" />
      <param name="mvid" />
      <param name="encId" />
      <param name="encBaseId" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModuleReference(System.Reflection.Metadata.StringHandle)">
      <param name="moduleName" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddNestedType(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <summary>지정된 형식 정의에 대한 중첩 관계를 정의합니다.</summary>
      <param name="type">중첩 형식 정의 핸들입니다.</param>
      <param name="enclosingType">바깥쪽 형식 정의 핸들입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddParameter(System.Reflection.ParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary>매개 변수 정의를 추가합니다.</summary>
      <param name="attributes">매개 변수 특성입니다.</param>
      <param name="name">선택 사항입니다. 매개 변수 이름입니다.</param>
      <param name="sequenceNumber">매개 변수의 시퀀스 번호입니다. 값 0은 소유자 메서드의 반환 형식을 나타냅니다. 해당 매개 변수의 번호는 1부터 시작합니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="sequenceNumber" />가 <see cref="F:System.UInt16.MaxValue" />보다 큰 경우</exception>
      <returns>추가된 매개 변수에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddProperty(System.Reflection.PropertyAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>속성 정의를 추가합니다.</summary>
      <param name="attributes">속성 특성입니다.</param>
      <param name="name">속성 이름입니다.</param>
      <param name="signature">속성의 시그니처입니다.</param>
      <returns>추가된 속성 정의에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddPropertyMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="declaringType" />
      <param name="propertyList" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStandaloneSignature(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStateMachineMethod(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>상태 시스템 메서드 디버그 정보를 추가합니다.</summary>
      <param name="moveNextMethod">상태 시스템 <see langword="MoveNext" /> 메서드(컴파일러 생성 메서드)의 핸들입니다.</param>
      <param name="kickoffMethod">킥오프 메서드(사용자 정의 반복기/비동기 메서드)의 핸들입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeDefinition(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>형식 정의를 추가합니다.</summary>
      <param name="attributes">형식 특성입니다.</param>
      <param name="namespace">형식 네임스페이스입니다.</param>
      <param name="name">형식 이름입니다.</param>
      <param name="baseType">기본 형식 엔터티 핸들이며 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> 또는 <see langword="null" /> 중 하나일 수 있습니다.</param>
      <param name="fieldList">형식이 필드를 선언하는 경우 이를 첫 번째 필드의 핸들로 설정합니다. 그렇지 않으면 이를 다음 형식 정의에 의해 선언된 첫 번째 필드의 핸들로 설정합니다. 모듈에 필드를 정의하는 형식이 없으면 <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(1)" />입니다.</param>
      <param name="methodList">형식이 메서드를 선언하는 경우 첫 번째 메서드의 핸들입니다. 그렇지 않으면 다음 형식 정의에 의해 선언된 첫 번째 메서드의 핸들입니다. 모듈에 메서드를 정의하는 형식이 없으면 <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(1)" />입니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="baseType" />에 필요한 핸들 종류가 없습니다.</exception>
      <returns>추가된 형식 정의에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeLayout(System.Reflection.Metadata.TypeDefinitionHandle,System.UInt16,System.UInt32)">
      <summary>형식 정의의 형식 레이아웃을 정의합니다.</summary>
      <param name="type">형식 정의입니다.</param>
      <param name="packingSize">필드가 형식 인스턴스 내 바이트 주소(<paramref name="packingSize" />의 배수와 해당 필드 형식의 일반 맞춤 중 더 작은 값)에 배치되도록 지정합니다. 값은 0, 1, 2, 4, 8, 16, 32, 64, 128 중 하나여야 합니다. 값이 0이면 사용된 압축 크기가 현재 플랫폼의 기본값과 일치해야 함을 나타냅니다.</param>
      <param name="size">형식 인스턴스의 최소 크기를 나타내며 패딩을 허용하기 위한 것입니다. 할당된 메모리의 양은 레이아웃과 <paramref name="size" />에서 계산된 크기의 최댓값입니다. 이 지시문이 값 형식에 적용되는 경우 크기는 1MB보다 작습니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <summary>형식 참조를 추가합니다.</summary>
      <param name="resolutionScope">대상 형식을 선언하는 엔터티이며 <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 또는 <see langword="null" /> 중 하나일 수 있습니다.</param>
      <param name="namespace">형식 참조 네임스페이스입니다.</param>
      <param name="name">형식 참조 이름입니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="resolutionScope" />에 필요한 핸들 종류가 없습니다.</exception>
      <returns>추가된 형식 참조에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeSpecification(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Byte[])">
      <summary>Blob 힙에 지정된 Blob을 추가합니다(아직 없는 경우).</summary>
      <param name="value">Blob을 포함하는 배열입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" />이(가) <see langword="null" />인 경우</exception>
      <returns>추가된 Blob 또는 기존 Blob에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Blob 힙에 바이트 배열의 지정된 Blob을 추가합니다(아직 없는 경우).</summary>
      <param name="value">Blob을 포함하는 배열입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" />이(가) <see langword="null" />인 경우</exception>
      <returns>추가된 Blob 또는 기존 Blob에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Reflection.Metadata.BlobBuilder)">
      <summary>Blob 힙에 변경이 불가능한 바이트 배열의 지정된 Blob을 추가합니다(아직 없는 경우).</summary>
      <param name="value">Blob을 포함하는 Blob 작성기 인스턴스입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" />이(가) <see langword="null" />인 경우</exception>
      <returns>추가된 Blob 또는 기존 Blob에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF16(System.String)">
      <summary>UTF16 인코딩을 사용하여 문자열을 Blob으로 인코딩하고 Blob 힙에 추가합니다(아직 없는 경우).</summary>
      <param name="value">추가할 문자열입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" />이(가) <see langword="null" />인 경우</exception>
      <returns>추가된 Blob 또는 기존 Blob에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF8(System.String,System.Boolean)">
      <summary>UTF8 인코딩을 사용하여 문자열을 Blob으로 인코딩하고 Blob 힙에 추가합니다(아직 없는 경우).</summary>
      <param name="value">추가할 값입니다.</param>
      <param name="allowUnpairedSurrogates">
        <see langword="true" />이면 쌍을 이루지 않는 서로게이트를 지정된 대로 인코딩하고, <see langword="false" />이면 해당 서로게이트를 U+FFFD 문자로 바꿉니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" />이(가) <see langword="null" />인 경우</exception>
      <returns>추가된 Blob 또는 기존 Blob에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddConstantBlob(System.Object)">
      <summary>상수 값을 Blob으로 인코딩하고 Blob 힙에 추가합니다(아직 없는 경우). UTF16을 사용하여 문자열 상수를 인코딩합니다.</summary>
      <param name="value">추가할 상수 값입니다.</param>
      <returns>추가된 Blob 또는 기존 Blob에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddDocumentName(System.String)">
      <summary>디버그 문서 이름을 인코딩하고 Blob 힙에 추가합니다(아직 없는 경우).</summary>
      <param name="value">추가할 문서 이름입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" />이(가) <see langword="null" />인 경우</exception>
      <returns>추가된 문서 이름 Blob 또는 기존 문서 이름 Blob에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddGuid(System.Guid)">
      <summary>GUID 힙에 지정된 GUID를 추가합니다(아직 없는 경우).</summary>
      <param name="guid">추가할 GUID입니다.</param>
      <returns>추가된 GUID 또는 기존 GUID에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddString(System.String)">
      <summary>문자열 힙에 지정된 문자열을 추가합니다(아직 없는 경우).</summary>
      <param name="value">추가할 문자열입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" />이(가) <see langword="null" />인 경우</exception>
      <returns>추가된 문자열 또는 기존 문자열에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddUserString(System.String)">
      <summary>사용자 문자열 힙에 지정된 문자열을 추가합니다(아직 없는 경우).</summary>
      <param name="value">추가할 문자열입니다.</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">힙의 나머지 공간이 너무 작아서 문자열에 맞지 않습니다.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" />이(가) <see langword="null" />인 경우</exception>
      <returns>추가된 문자열 또는 기존 문자열에 대한 핸들입니다. 이 값은 <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" />에서 사용할 수 있습니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCount(System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>지정된 테이블의 현재 항목 수를 반환합니다.</summary>
      <param name="table">테이블 인덱스입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="table" />이 유효한 테이블 인덱스가 아닙니다.</exception>
      <returns>테이블의 항목 수입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCounts">
      <summary>각 테이블의 현재 항목 수를 반환합니다.</summary>
      <returns>
        <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" /> 크기의 배열이며, 각 항목은 해당 테이블의 현재 행 수로 채워집니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveGuid">
      <summary>GUID 힙에 GUID를 위한 공간을 예약합니다.</summary>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">힙의 나머지 공간이 너무 작아서 문자열에 맞지 않습니다.</exception>
      <returns>예약된 GUID 및 힙에 저장된 GUID Blob을 나타내는 <see cref="T:System.Reflection.Metadata.Blob" />에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveUserString(System.Int32)">
      <summary>사용자 문자열 힙에 지정된 길이의 문자열을 위한 공간을 예약합니다.</summary>
      <param name="length">예약할 문자 수입니다.</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">힙의 나머지 공간이 너무 작아서 문자열에 맞지 않습니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" />가 음수입니다.</exception>
      <returns>예약된 사용자 문자열 및 전체 사용자 문자열 Blob(길이 및 터미널 문자 포함)을 나타내는 <see cref="T:System.Reflection.Metadata.Blob" />에 대한 핸들입니다. 이 핸들은 <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" />에서 사용할 수 있습니다.
<see cref="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)" />을 사용하여 Blob 콘텐츠를 채웁니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.HeapIndex,System.Int32)">
      <summary>지정된 힙의 용량을 설정합니다.</summary>
      <param name="heap">힙 인덱스입니다.</param>
      <param name="byteCount">바이트 수입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="heap" />이 유효한 힙 인덱스가 아닙니다.

또는

<paramref name="byteCount" />가 음수입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>지정된 테이블의 용량을 설정합니다.</summary>
      <param name="table">테이블 인덱스입니다.</param>
      <param name="rowCount">표의 행 수입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="table" />이 유효한 테이블 인덱스가 아닙니다.

또는

<paramref name="rowCount" />가 음수입니다.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions">
      <summary>ECMA-335 메타데이터 테이블 및 힙의 특정 원시 요소로 작업하도록 확장 메서드를 제공합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueLogEntries(System.Reflection.Metadata.MetadataReader)">
      <summary>EnC 로그의 항목을 열거합니다.</summary>
      <param name="reader" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" />이(가) <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueMapEntries(System.Reflection.Metadata.MetadataReader)">
      <summary>EnC 지도의 항목을 열거합니다.</summary>
      <param name="reader" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" />이(가) <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>메타데이터 시작에서 지정된 힙으로 오프셋을 반환합니다.</summary>
      <param name="reader" />
      <param name="heapIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="heapIndex" />가 유효한 힙 인덱스가 아닌 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>지정된 힙의 크기를 반환합니다.</summary>
      <param name="reader" />
      <param name="heapIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="heapIndex" />가 유효한 힙 인덱스가 아닌 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.BlobHandle)">
      <summary>해당 항목이 마지막인 경우 nil 핸들 또는 <see cref="T:System.Reflection.Metadata.Blob" /> 힙의 지정된 항목 뒤에 오는 <see cref="T:System.Reflection.Metadata.Blob" />에 핸들을 반환합니다.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" />이(가) <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.StringHandle)">
      <summary>해당 항목이 마지막인 경우 nil 핸들 또는 문자열 힙의 지정된 항목 뒤에 오는 문자열에 핸들을 반환합니다.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" />이(가) <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.UserStringHandle)">
      <summary>해당 항목이 마지막인 경우 nil 핸들 또는 UserString 힙의 지정된 항목 뒤에 오는 UserString에 핸들을 반환합니다.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" />이(가) <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>메타데이터의 시작부터 지정된 테이블로 오프셋을 반환합니다.</summary>
      <param name="reader" />
      <param name="tableIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tableIndex" />가 유효한 테이블 인덱스가 아닌 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowCount(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>지정된 테이블의 행 수를 반환합니다.</summary>
      <param name="reader" />
      <param name="tableIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tableIndex" />가 유효한 테이블 인덱스가 아닌 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>지정된 테이블의 행 크기를 반환합니다.</summary>
      <param name="reader" />
      <param name="tableIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tableIndex" />가 유효한 테이블 인덱스가 아닌 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithEvents(System.Reflection.Metadata.MetadataReader)">
      <summary>하나 이상의 이벤트를 정의하는 형식을 열거합니다.</summary>
      <param name="reader" />
      <returns>결과 시퀀스는 EventMap 테이블의 항목과 정확하게 일치합니다. 즉, n번째 반환된 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />은(는) EventMap의 n번째 행에 저장됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithProperties(System.Reflection.Metadata.MetadataReader)">
      <summary>하나 이상의 속성을 정의하는 형식을 열거합니다.</summary>
      <param name="reader" />
      <returns>결과 시퀀스는 속성 맵 테이블의 항목과 정확하게 일치합니다. 즉, n번째 반환된 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />은(는) 속성 맵의 n번째 행에 저장됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)">
      <summary>서명 BLOB에 있는 형식 핸들과 원시 형식 종류를 고려하여, 대상 형식이 값 형식 또는 참조 형식인지를 결정합니다.</summary>
      <param name="reader" />
      <param name="typeHandle" />
      <param name="rawTypeKind" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataRootBuilder">
      <summary>이식 가능한 실행 가능 이미지에 포함된 메타데이터 루트의 작성기입니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.String,System.Boolean)">
      <summary>메타데이터 루트의 작성기를 만듭니다.</summary>
      <param name="tablesAndHeaps">테이블에 저장된 메타데이터 엔터티와 힙에 저장된 값이 들어간 작성기입니다. 메타데이터 루트를 직렬화할 때 엔터티와 값이 열거됩니다.</param>
      <param name="metadataVersion">메타데이터 헤더에 쓰인 버전 문자열입니다. 기본 값은 "v4.0.30319"입니다.</param>
      <param name="suppressValidation">직렬화 중에 메타데이터 테이블의 기본 유효성 검사를 표시하지 않으려면 <see langword="true" />, 그렇지 않으면 <paramref name="false" />입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="tablesAndHeaps" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataVersion" />이 너무 긴 경우(UTF8 인코딩 시 바이트 수가 255 미만이어야 함)</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Int32,System.Int32)">
      <summary>메타데이터 루트 콘텐츠를 주어진 <see cref="T:System.Reflection.Metadata.BlobBuilder" />로 직렬화합니다.</summary>
      <param name="builder">쓰기를 할 작성기입니다.</param>
      <param name="methodBodyStreamRva">메서드 본문 스트림 시작 지점의 상대 가상 주소입니다. MethodDef 테이블의 RVA 필드의 최종 값을 계산하는데 사용합니다.</param>
      <param name="mappedFieldDataStreamRva">필드 초기화 데이터 스트림 시작 지점의 상대 가상 주소입니다. FieldRVA 테이블의 RVA 필드의 최종 값을 계산하는데 사용합니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="builder" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="methodBodyStreamRva" /> 또는 <paramref name="mappedFieldDataStreamRva" />가 음수입니다.</exception>
      <exception cref="T:System.InvalidOperationException">메타데이터 테이블은 사양에 필요한 대로 정렬되지 않으며 <see cref="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation" />은 <see langword="false" />입니다.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.MetadataVersion">
      <summary>메타데이터 버전입니다.</summary>
      <returns>메타 데이터 버전을 나타내는 문자열입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Sizes">
      <summary>다양한 메타데이터 구조의 크기를 반환합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation">
      <summary>메타데이터 테이블의 기본 유효성 검사를 표시하지 않을 지 결정합니다. 유효성 검사는 테이블의 항목이 ECMA 사양이 요구하는 순서대로 추가되었는지 확인합니다. 모든 사양 요구 사항이 메타데이터 테이블에 적용되는 것은 아닙니다.</summary>
      <returns>
        <see langword="true" /> 메타 데이터 테이블의 기본 유효성 검사를 표시 하지 않으려면 그렇지 않으면 <see langword="false" /> 입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataSizes">
      <summary>다양한 메타데이터 구조의 크기 정보를 제공합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataSizes.GetAlignedHeapSize(System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>지정된 힙의 맞춤 크기를 반환합니다.</summary>
      <param name="index" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.ExternalRowCounts">
      <summary>외부 테이블 행 개수입니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.HeapSizes">
      <summary>정확한 (맞추지 않은) 힙 사이즈.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.RowCounts">
      <summary>테이블 행 개수</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataTokens" />
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.HeapCount">
      <summary>Ecma335 메타데이터에 있을 수 있는 최대 테이블 수입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount">
      <summary>Ecma335 메타데이터에 있을 수 있는 최대 테이블 수입니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyFileHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.BlobHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ConstantHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomAttributeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomDebugInformationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DeclarativeSecurityAttributeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentNameBlobHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Int32)">
      <summary>토큰 값에서 엔터티 핸들을 만듭니다.</summary>
      <param name="token" />
      <exception cref="T:System.ArgumentException">
        <paramref name="token" />이 유효한 메타데이터 엔터티 토큰이 아닙니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>토큰 값에서 <see cref="T:System.Reflection.Metadata.EntityHandle" />을(를) 만듭니다.</summary>
      <param name="tableIndex" />
      <param name="rowNumber" />
      <exception cref="T:System.ArgumentException">
        <paramref name="tableIndex" />가 유효한 테이블 인덱스가 아닙니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EventDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ExportedTypeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterConstraintHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.BlobHandle)">
      <summary>지정된 <paramref name="handle" />에 해당하는 메타데이터 힙 데이터의 오프셋을 가져옵니다.</summary>
      <param name="handle" />
      <returns>
        <paramref name="handle" />이(가) 특정한 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 또는 <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" />의 컨텍스트에서만 해석될 경우, 0으로 시작하는 오프셋 혹은 -1입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.GuidHandle)">
      <summary>지정된 <paramref name="handle" />에 해당하는 메타데이터 힙 데이터의 오프셋을 가져옵니다.</summary>
      <param name="handle" />
      <returns>#Guid 힙에 대한 1부터 시작하는 인덱스입니다. 기본적으로 바이트 배열인 다른 힙과 달리 #Guid 힙은 16바이트 GUID 배열입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.Handle)">
      <summary>지정된 <paramref name="handle" />에 해당하는 메타데이터 힙 데이터의 오프셋을 가져옵니다.</summary>
      <param name="handle" />
      <returns>
        <paramref name="handle" />이(가) 특정한 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 또는 <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" />의 컨텍스트에서만 해석될 경우, 힙에 해당하는 오프셋 혹은 -1입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary>
        <paramref name="reader" />의 컨텍스트에서 지정된 <paramref name="handle" />에 해당하는 메타데이터 힙 데이터의 오프셋을 가져옵니다.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.NotSupportedException">작업이 지정된 <paramref name="handle" />에서 지원되지 않습니다.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="handle" />가 잘못되었습니다.</exception>
      <returns>
        <paramref name="handle" />이 메타데이터 힙 핸들이 아닐 경우, 0으로 시작하는 오프셋 혹은 -1입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.StringHandle)">
      <summary>지정된 <paramref name="handle" />에 해당하는 메타데이터 힙 데이터의 오프셋을 가져옵니다.</summary>
      <param name="handle" />
      <returns>
        <paramref name="handle" />이(가) 특정한 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 또는 <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" />의 컨텍스트에서만 해석될 경우, 0으로 시작하는 오프셋 혹은 -1입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.UserStringHandle)">
      <summary>지정된 <paramref name="handle" />에 해당하는 메타데이터 힙 데이터의 오프셋을 가져옵니다.</summary>
      <param name="handle" />
      <returns>0으로 시작하는 오프셋입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.EntityHandle)">
      <summary>지정된 <paramref name="handle" />에 해당하는 메타데이터 테이블 항목의 행 번호를 가져옵니다.</summary>
      <param name="handle" />
      <returns>
        <paramref name="handle" />이(가) 특정한 <see cref="T:System.Reflection.Metadata.MetadataReader" />의 컨텍스트에서만 해석될 경우, 1부터 시작하는 행 번호 혹은 -1입니다.
<see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)" />을 참조하세요.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary>
        <paramref name="reader" />의 컨텍스트에서 지정된 <paramref name="handle" />에 해당하는 메타데이터 테이블 항목의 행 번호를 가져옵니다.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentException">
        <paramref name="handle" />이 유효한 메타데이터 테이블 핸들이 아닙니다.</exception>
      <returns>1부터 시작하는 행 번호입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.EntityHandle)">
      <summary>지정된 <paramref name="handle" />의 메타데이터 토큰을 가져옵니다.</summary>
      <param name="handle" />
      <returns>
        <paramref name="handle" />이(가) 특정한 <see cref="T:System.Reflection.Metadata.MetadataReader" />의 컨텍스트에서만 해석될 경우, 메타데이터 토큰 혹은 0입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.Handle)">
      <summary>지정된 <paramref name="handle" />의 메타데이터 토큰을 가져옵니다.</summary>
      <param name="handle" />
      <exception cref="T:System.ArgumentException">핸들은 토큰이 없는 메타데이터 엔터티를 나타냅니다.
토큰은 메타데이터 테이블 핸들이나 <see cref="F:System.Reflection.Metadata.HandleKind.UserString" /> 형식의 힙 핸들에 대해서만 검색할 수 있습니다.</exception>
      <returns>
        <paramref name="handle" />이(가) 특정한 <see cref="T:System.Reflection.Metadata.MetadataReader" />의 컨텍스트에서만 해석될 경우, 메타데이터 토큰 혹은 0입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary>
        <paramref name="reader" />의 컨텍스트에서 지정된 <paramref name="handle" />의 메타데이터 토큰을 가져옵니다.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.NotSupportedException">작업이 지정된 <paramref name="handle" />에서 지원되지 않습니다.</exception>
      <returns>메타데이터 토큰입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary>
        <paramref name="reader" />의 컨텍스트에서 지정된 <paramref name="handle" />의 메타데이터 토큰을 가져옵니다.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentException">핸들은 토큰이 없는 메타데이터 엔터티를 나타냅니다.
토큰은 메타데이터 테이블 핸들이나 <see cref="F:System.Reflection.Metadata.HandleKind.UserString" /> 형식의 힙 핸들에 대해서만 검색할 수 있습니다.</exception>
      <exception cref="T:System.NotSupportedException">작업이 지정된 <paramref name="handle" />에서 지원되지 않습니다.</exception>
      <returns>메타데이터 토큰입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GuidHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Int32)">
      <summary>토큰 값에서 핸들을 만듭니다.</summary>
      <param name="token" />
      <exception cref="T:System.ArgumentException">
        <paramref name="token" />이 유효한 메타데이터 토큰이 아닙니다.
메타데이터 테이블 엔터티 또는 <see cref="F:System.Reflection.Metadata.HandleKind.UserString" /> 힙의 오프셋을 인코딩해야 합니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>토큰 값에서 <see cref="T:System.Reflection.Metadata.EntityHandle" />을(를) 만듭니다.</summary>
      <param name="tableIndex" />
      <param name="rowNumber" />
      <exception cref="T:System.ArgumentException">
        <paramref name="tableIndex" />가 유효한 테이블 인덱스가 아닙니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ImportScopeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.InterfaceImplementationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalScopeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ManifestResourceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MemberReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDebugInformationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodImplementationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodSpecificationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ModuleReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.PropertyDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StandaloneSignatureHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StringHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetHeapIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.HeapIndex@)">
      <summary>지정된 <see cref="T:System.Reflection.Metadata.HandleKind" />에 해당하는 힙의 <see cref="T:System.Reflection.Metadata.Ecma335.HeapIndex" />을(를) 가져옵니다.</summary>
      <param name="type">핸들 형식입니다.</param>
      <param name="index">힙 인덱스입니다.</param>
      <returns>핸들 형식이 Ecma335 힙에 해당하는 경우 <see langword="true" />이며, 그렇지 않은 경우 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetTableIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.TableIndex@)">
      <summary>지정된 <see cref="T:System.Reflection.Metadata.HandleKind" />에 해당하는 테이블의 <see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" />을(를) 가져옵니다.</summary>
      <param name="type">핸들 형식입니다.</param>
      <param name="index">테이블 인덱스입니다.</param>
      <returns>핸들 형식이 Ecma335이나 이식 가능 PDB 테이블에 해당하는 경우 <see langword="true" />이며, 그렇지 않은 경우 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeSpecificationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.UserStringHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyAttributes">
      <summary>메서드 본문 특성을 정의합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.InitLocals">
      <summary>로컬 메모리를 비우고 동적으로 할당하려면 메서드가 정의하는 로컬 항목을 초기화합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.None">
      <summary>로컬 메모리 초기화를 수행하지 않습니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder">
      <summary>메서드 본문 스트림에 인코더를 제공합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary>메서드 본문을 인코딩하고 제공된 코드 크기, 최대 스택 크기, 예외 영역의 수, 지역 변수의 시그니처 핸들, 메서드 본문 특성을 사용하여 메서드 본문 스트림에 추가하고 예외 영역을 작은 형식으로 인코딩할지 여부를 나타낼 수 있습니다.</summary>
      <param name="codeSize">명령에 예약될 바이트 수입니다.</param>
      <param name="maxStack">최대 스택 크기입니다.</param>
      <param name="exceptionRegionCount">예외 영역의 수입니다.</param>
      <param name="hasSmallExceptionRegions">예외 영역을 작은 형식으로 인코딩해야 하는 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
      <param name="localVariablesSignature">지역 변수의 시그니처 핸들입니다.</param>
      <param name="attributes">메서드 본문 특성입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="codeSize" />, <paramref name="exceptionRegionCount" /> 또는 <paramref name="maxStack" />이 허용되는 범위를 벗어났습니다.</exception>
      <returns>메서드 본문 스트림 내에서 인코딩된 본문의 오프셋입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary>메서드 본문을 인코딩하고 제공된 코드 크기, 최대 스택 크기, 예외 영역의 수, 지역 변수의 시그니처 핸들, 메서드 본문 특성을 사용하여 메서드 본문 스트림에 추가하고 예외 영역을 작은 형식으로 인코딩할지 여부를 나타내고, 메서드를 동적 로컬 메모리 풀에서 할당할지 여부를 나타낼 수 있습니다.</summary>
      <param name="codeSize">명령에 예약될 바이트 수입니다.</param>
      <param name="maxStack">최대 스택 크기입니다.</param>
      <param name="exceptionRegionCount">예외 영역의 수입니다.</param>
      <param name="hasSmallExceptionRegions">예외 영역을 작은 형식으로 인코딩해야 하는 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
      <param name="localVariablesSignature">지역 변수의 시그니처 핸들입니다.</param>
      <param name="attributes">메서드 본문 특성입니다.</param>
      <param name="hasDynamicStackAllocation">메서드가 동적 로컬 메모리 풀에서 할당되는 경우(<see langword="localloc" /> 명령) <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="codeSize" />, <paramref name="exceptionRegionCount" /> 또는 <paramref name="maxStack" />이 허용되는 범위를 벗어났습니다.</exception>
      <returns>메서드 본문 스트림 내에서 인코딩된 본문의 오프셋입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary>메서드 본문을 인코딩하여 메서드 본문 스트림에 추가합니다.</summary>
      <param name="instructionEncoder">명령 인코더입니다.</param>
      <param name="maxStack">최대 스택 크기입니다.</param>
      <param name="localVariablesSignature">지역 변수의 시그니처 핸들입니다.</param>
      <param name="attributes">메서드 본문 특성입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instructionEncoder" />에 기본값이 있습니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maxStack" />이 [0, <see cref="F:System.UInt16.MaxValue" />] 범위를 벗어났습니다.</exception>
      <exception cref="T:System.InvalidOperationException">명령 스트림의 분기가 대상으로 하는 레이블이 표시되지 않았거나 분기 명령과 대상 레이블 간의 거리가 명령 피연산자의 크기에 맞지 않습니다.</exception>
      <returns>메서드 본문 스트림 내에서 인코딩된 본문의 오프셋입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary>메서드 본문을 인코딩하고 제공된 명령 인코더, 최대 스택 크기, 지역 변수의 시그니처 핸들, 메서드 본문 특성을 사용하여 메서드 본문 스트림에 추가하고 메서드를 동적 로컬 메모리 풀에서 할당할지 여부를 나타낼 수 있습니다.</summary>
      <param name="instructionEncoder">명령 인코더입니다.</param>
      <param name="maxStack">최대 스택 크기입니다.</param>
      <param name="localVariablesSignature">지역 변수의 시그니처 핸들입니다.</param>
      <param name="attributes">메서드 본문 특성입니다.</param>
      <param name="hasDynamicStackAllocation">메서드가 동적 로컬 메모리 풀에서 할당되는 경우(IL에 <see langword="localloc" /> 명령이 포함된 경우) <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instructionEncoder" />에 기본값이 있습니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maxStack" />이 [0, <see cref="F:System.UInt16.MaxValue" />] 범위를 벗어났습니다.</exception>
      <exception cref="T:System.InvalidOperationException">명령 스트림의 분기가 대상으로 하는 레이블이 표시되지 않았거나 분기 명령과 대상 레이블 간의 거리가 명령 피연산자의 크기에 맞지 않습니다.</exception>
      <returns>메서드 본문 스트림 내에서 인코딩된 본문의 오프셋입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody">
      <summary>메서드 본문을 설명합니다. 이 클래스는 <see cref="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder" /> 클래스와 함께 사용하기 위한 것입니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.ExceptionRegions">
      <summary>예외 영역을 메서드 본문으로 인코딩하는 데 사용할 수 있는 인코더 개체를 가져옵니다.</summary>
      <returns>예외 영역 인코더 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Instructions">
      <summary>명령에 예약된 blob을 가져옵니다.</summary>
      <returns>지침을 위해 예약 된 blob입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Offset">
      <summary>메서드 본문 스트림에 인코딩된 메서드 본문의 오프셋을 가져옵니다.</summary>
      <returns>메서드 본문 스트림에 인코딩된 메서드 본문의 오프셋입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder">
      <summary>메서드 시그니처에 인코더를 제공합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" />
      <param name="hasVarArgs" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Action{System.Reflection.Metadata.Ecma335.ReturnTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ParametersEncoder})">
      <summary>제공된 반환 형식 및 매개 변수를 인코딩합니다.</summary>
      <param name="parameterCount">매개 변수 수입니다.</param>
      <param name="returnType">반환 형식을 인코딩하기 위해 맨 먼저 호출되는 메서드입니다.</param>
      <param name="parameters">매개 변수를 인코딩하기 위해 두 번째 호출되는 메서드입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="returnType" /> 또는 <paramref name="parameters" />가 <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Reflection.Metadata.Ecma335.ReturnTypeEncoder@,System.Reflection.Metadata.Ecma335.ParametersEncoder@)">
      <summary>매개 변수 목록에 나타나는 순서대로 사용해야 하는 제공된 반환 형식 및 매개 변수를 인코딩합니다.</summary>
      <param name="parameterCount">매개 변수 수입니다.</param>
      <param name="returnType">반환 형식을 인코딩하기 위해 맨 먼저 호출되는 메서드입니다.</param>
      <param name="parameters">매개 변수를 인코딩하기 위해 두 번째 호출되는 메서드입니다.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.HasVarArgs" />
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <summary>
        <see cref="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
      <param name="builder">명명된 인수를 인코딩하는 데 사용되는 작성기입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Action{System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.NameEncoder},System.Action{System.Reflection.Metadata.Ecma335.LiteralEncoder})">
      <summary>명명된 인수(필드 또는 속성)를 인코딩합니다.</summary>
      <param name="isField">필드를 인코딩하려면 <see langword="true" />이고, 속성을 인코딩하려면 <see langword="false" />입니다.</param>
      <param name="type">인수 형식을 인코딩하기 위해 가장 먼저 호출할 메서드입니다.</param>
      <param name="name">필드 또는 속성의 이름을 인코딩하기 위해 두 번째 호출할 메서드입니다.</param>
      <param name="literal">인수의 리터럴 값을 인코딩하기 위해 세 번째 호출할 메서드입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" />, <paramref name="name" /> 또는 <paramref name="literal" />이 <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder@,System.Reflection.Metadata.Ecma335.NameEncoder@,System.Reflection.Metadata.Ecma335.LiteralEncoder@)">
      <summary>명명된 인수(필드 또는 속성)를 인코딩하고 매개 변수 목록에 나타나는 순서대로 사용되어야 하는 세 인코더를 반환합니다.</summary>
      <param name="isField">필드를 인코딩하려면 <see langword="true" />이고, 속성을 인코딩하려면 <see langword="false" />입니다.</param>
      <param name="type">인수 형식을 인코딩하기 위해 가장 먼저 호출할 메서드입니다.</param>
      <param name="name">필드 또는 속성의 이름을 인코딩하기 위해 두 번째 호출할 메서드입니다.</param>
      <param name="literal">인수의 리터럴 값을 인코딩하기 위해 세 번째 호출할 메서드입니다.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.ScalarType" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.SZArray" />
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.NameEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.Name(System.String)">
      <param name="name" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NameEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.ParametersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" />
      <param name="hasVarArgs" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.AddParameter" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.StartVarArgs" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.HasVarArgs" />
    <member name="T:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.TypedReference" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.PermissionSetEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="typeName" />
      <param name="encodedArguments" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Reflection.Metadata.BlobBuilder)">
      <param name="typeName" />
      <param name="encodedArguments" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.PortablePdbBuilder">
      <summary>이식 가능한 PDB 이미지의 작성기를 나타냅니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.Collections.Immutable.ImmutableArray{System.Int32},System.Reflection.Metadata.MethodDefinitionHandle,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <summary>이식 가능한 PDB 이미지의 작성기를 만듭니다.</summary>
      <param name="tablesAndHeaps">테이블에 저장된 디버그 메타데이터 엔터티와 힙에 저장된 값으로 채워진 작성기입니다. 이식 가능한 PDB 이미지를 직렬화할 때 엔터티와 값이 열거됩니다.</param>
      <param name="typeSystemRowCounts">연결된 형식 시스템 메타데이터에 포함된 모든 테이블의 행 수입니다. 배열의 각 슬롯은 테이블(<see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" />)에 해당합니다. 배열의 길이는 <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" />와(과) 동일해야 합니다.</param>
      <param name="entryPoint">진입점 메서드 정의 핸들입니다.</param>
      <param name="idProvider">Blob 시퀀스로 표시되는 콘텐츠의 ID를 계산하는 함수입니다. 지정하지 않으면 콘텐츠를 무시하고 현재 시간을 기준으로 콘텐츠 ID를 반환하는 기본 함수가 사용됩니다(<see cref="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />). 결정적 이식 가능 PDB 이미지를 생성하려면 결정 함수를 지정해야 합니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="tablesAndHeaps" /> 또는 <paramref name="typeSystemRowCounts" />가 <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <summary>이식 가능한 PDB 콘텐츠를 지정된 <see cref="T:System.Reflection.Metadata.BlobBuilder" />(으)로 직렬화합니다.</summary>
      <param name="builder">쓸 작성기입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="builder" />이(가) <see langword="null" />인 경우</exception>
      <returns>직렬화된 콘텐츠의 ID입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.FormatVersion" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.IdProvider" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.MetadataVersion" />
    <member name="T:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.TypedReference" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Void" />
    <member name="P:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.ScalarEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.Constant(System.Object)">
      <summary>상수 리터럴을 인코딩합니다.</summary>
      <param name="value">
        <see cref="T:System.Boolean" />, <see cref="T:System.Byte" />, <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.UInt16" />, <see cref="T:System.Int32" />, <see cref="T:System.UInt32" />, <see cref="T:System.Int64" />, <see cref="T:System.UInt64" />, <see cref="T:System.Single" />, <see cref="T:System.Double" />, <see cref="T:System.Char" />(2바이트 유니코드 문자로 인코딩됨), <see cref="T:System.String" />(SerString으로 인코딩됨) 또는 <see cref="T:System.Enum" />(기본 정수 값으로 인코딩됨) 형식의 상수입니다.</param>
      <exception cref="T:System.ArgumentException">예기치 않은 상수 형식입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.NullArray">
      <summary>
        <see cref="T:System.Array" /> 형식의 <see langword="null" /> 리터럴을 인코딩합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.SystemType(System.String)">
      <summary>
        <see cref="T:System.Type" /> 형식 리터럴(<see langword="null" />일 수 있음)을 인코딩합니다.</summary>
      <param name="serializedTypeName">형식의 이름이거나 <see langword="null" />입니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="serializedTypeName" />가 비어 있는 경우</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ScalarEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2">
      <summary>시그니처 blob을 디코딩합니다.</summary>
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.#ctor(System.Reflection.Metadata.ISignatureTypeProvider{`0,`1},System.Reflection.Metadata.MetadataReader,`1)">
      <summary>새 <see cref="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2" />를 만듭니다.</summary>
      <param name="provider">시그니처를 디코딩할 때 형식 기호를 가져오는 데 사용되는 공급자입니다.</param>
      <param name="metadataReader">시그니처를 가져온 메타데이터 판독기입니다. 지정된 공급자가 허용하는 경우 <see langword="null" />일 수 있습니다.</param>
      <param name="genericContext">제네릭 매개 변수를 확인하는 데 필요한 추가 컨텍스트입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeFieldSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>필드 시그니처 blob을 디코딩하고 시그니처를 지나 판독기를 앞으로 이동합니다.</summary>
      <param name="blobReader">필드 시그니처에 배치되는 blob 판독기입니다.</param>
      <returns>디코딩된 필드 형식입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeLocalSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>지역 변수 시그니처 blob을 디코딩하고 시그니처를 지나 판독기를 앞으로 이동합니다.</summary>
      <param name="blobReader">지역 변수 시그니처에 배치되는 blob 판독기입니다.</param>
      <exception cref="T:System.BadImageFormatException">지역 변수 시그니처가 유효하지 않습니다.</exception>
      <returns>지역 변수 형식입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>메서드(정의, 참조 또는 독립 실행형) 또는 속성 시그니처 blob을 디코딩합니다.</summary>
      <param name="blobReader">메서드 시그니처에 배치되는 blob 판독기입니다.</param>
      <exception cref="T:System.BadImageFormatException">메서드 시그니처가 유효하지 않습니다.</exception>
      <returns>디코딩된 메서드 시그니처입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSpecificationSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>메서드 사양 시그니처 blob을 디코딩하고 시그니처를 지나 판독기를 앞으로 이동합니다.</summary>
      <param name="blobReader">유효한 메서드 사양 시그니처에 배치되는 blob 판독기입니다.</param>
      <returns>메서드 사양을 통해 제네릭 메서드를 인스턴스화하는 데 사용되는 형식입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeType(System.Reflection.Metadata.BlobReader@,System.Boolean)">
      <summary>시그니처에 포함된 형식을 디코딩하고 형식을 지나 판독기를 앞으로 이동합니다.</summary>
      <param name="blobReader">선행 <see cref="T:System.Reflection.Metadata.SignatureTypeCode" />에 배치되는 blob 판독기입니다.</param>
      <param name="allowTypeSpecifications">
        <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />이 시그니처에서 (CLASS | VALUETYPE) 뒤에 오도록 허용하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
      <exception cref="T:System.BadImageFormatException">판독기가 유효한 시그니처 형식에 배치되지 않았습니다.</exception>
      <returns>디코딩된 형식입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Action{System.Reflection.Metadata.Ecma335.SignatureTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ArrayShapeEncoder})">
      <summary>배열 형식을 인코딩합니다.</summary>
      <param name="elementType">요소의 형식을 인코딩하기 위해 가장 먼저 호출됩니다.</param>
      <param name="arrayShape">배열의 모양을 인코딩하기 위해 두 번째 호출됩니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="elementType" /> 또는 <paramref name="arrayShape" />가 <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Reflection.Metadata.Ecma335.SignatureTypeEncoder@,System.Reflection.Metadata.Ecma335.ArrayShapeEncoder@)">
      <summary>배열 형식을 인코딩합니다. 매개 변수 목록에 나타나는 순서대로 사용해야 하는 인코더 쌍을 반환합니다.</summary>
      <param name="elementType">요소의 형식을 인코딩하기 위해 가장 먼저 사용합니다.</param>
      <param name="arrayShape">배열의 모양을 인코딩하기 위해 두 번째 사용합니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Boolean" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.CustomModifiers">
      <summary>사용자 지정 한정자를 사용하여 형식의 시그니처를 시작합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.FunctionPointer(System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.Ecma335.FunctionPointerAttributes,System.Int32)">
      <summary>함수 포인터 시그니처를 시작합니다.</summary>
      <param name="convention">호출 규칙입니다.</param>
      <param name="attributes">함수 포인터 특성입니다.</param>
      <param name="genericParameterCount">제네릭 매개 변수 개수입니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributes" />이 잘못되었습니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericParameterCount" />가 [0, 0xffff] 범위에 있지 않습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericInstantiation(System.Reflection.Metadata.EntityHandle,System.Int32,System.Boolean)">
      <summary>제네릭 인스턴스화 시그니처를 시작합니다.</summary>
      <param name="genericType">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /></param>
      <param name="genericArgumentCount">제네릭 인수 개수입니다.</param>
      <param name="isValueType">형식을 값 형식으로 표시하려면 <see langword="true" />이고, 시그니처의 참조 형식으로 표시하려면 <see langword="false" />입니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="genericType" />에 필요한 핸들 종류가 없습니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericArgumentCount" />가 범위 [1, 0xffff]에 있지 않습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericMethodTypeParameter(System.Int32)">
      <summary>포함하는 제네릭 메서드의 형식 매개 변수에 대한 참조를 인코딩합니다.</summary>
      <param name="parameterIndex">매개 변수 인덱스입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="parameterIndex" />가 [0, 0xffff] 범위에 있지 않습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericTypeParameter(System.Int32)">
      <summary>포함하는 제네릭 형식의 형식 매개 변수에 대한 참조를 인코딩합니다.</summary>
      <param name="parameterIndex">매개 변수 인덱스입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="parameterIndex" />가 [0, 0xffff] 범위에 있지 않습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.IntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Pointer">
      <summary>포인터 시그니처를 시작합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary>기본 형식 코드를 작성합니다.</summary>
      <param name="type">
        <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference" /> 및 <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.Void" />를 제외한 모든 기본 형식 코드입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="type" />이 이 컨텍스트에서 유효하지 않습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SZArray">
      <summary>SZ 배열(벡터) 시그니처를 시작합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Type(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <summary>형식에 대한 참조를 인코딩합니다.</summary>
      <param name="type">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /></param>
      <param name="isValueType">형식을 값 형식으로 표시하려면 <see langword="true" />이고, 시그니처의 참조 형식으로 표시하려면 <see langword="false" />입니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" />에 필요한 핸들 종류가 없습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UIntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.VoidPointer">
      <summary>void 포인터를 인코딩합니다(<c>void*</c>).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.TableIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Assembly" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ClassLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Constant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.DeclSecurity" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Document" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncLog" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Event" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ExportedType" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Field" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldMarshal" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldRva" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.File" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParam" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParamConstraint" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImplMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImportScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.InterfaceImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalConstant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalVariable" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ManifestResource" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MemberRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSemantics" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSpec" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Module" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ModuleRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.NestedClass" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Param" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ParamPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Property" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StandAloneSig" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StateMachineMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeSpec" />
    <member name="T:System.Reflection.Metadata.Ecma335.VectorEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.Count(System.Int32)">
      <param name="count" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.VectorEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.EntityHandle">
      <summary>메타데이터 엔터티(예: 형식 참조, 형식 정의, 형식 사양, 메서드 정의, 사용자 지정 특성)을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.EntityHandle.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.EntityHandle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Object)">
      <summary>현재 인스턴스와 지정된 개체가 같은지 여부를 나타내는 값을 반환합니다.</summary>
      <param name="obj">현재 인스턴스와 비교할 개체입니다.</param>
      <returns>
        <paramref name="obj" />가 <see cref="T:System.Reflection.Metadata.EntityHandle" />과 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Reflection.Metadata.EntityHandle)">
      <summary>현재 인스턴스와 지정된 <see cref="T:System.Reflection.Metadata.EntityHandle" />이 같은지 여부를 나타내는 값을 반환합니다.</summary>
      <param name="other">현재 인스턴스와 비교할 값입니다.</param>
      <returns>현재 인스턴스와 <paramref name="other" />가 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.GetHashCode">
      <summary>이 인스턴스의 해시 코드를 반환합니다.</summary>
      <returns>이 인스턴스의 해시 코드입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Equality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Implicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Inequality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.EntityHandle.IsNil" />
    <member name="P:System.Reflection.Metadata.EntityHandle.Kind" />
    <member name="T:System.Reflection.Metadata.EventAccessors" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Adder" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Others" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Raiser" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Remover" />
    <member name="T:System.Reflection.Metadata.EventDefinition" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Name" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Type" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Reflection.Metadata.EventDefinitionHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Equality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Inequality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#EventDefinitionHandle}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Count">
      <summary>컬렉션의 요소 수를 가져옵니다.</summary>
      <returns>컬렉션에 있는 요소의 수입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ExceptionRegion" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.CatchType">
      <summary>지역이 catch 또는 nil 토큰을 나타내는 경우 TypeRef, TypeDef 또는 TypeSpec 핸들을 가져오고 그렇지 않으면 (<see langword="default" />(<see cref="T:System.Reflection.Metadata.EntityHandle" />))를 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.FilterOffset">
      <summary>필터 블록 시작의 IL 오프셋을 가져오거나 지역이 필터가 아닌 경우 -1을 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerLength">
      <summary>예외 처리기의 길이(바이트)를 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerOffset">
      <summary>예외 처리기의 시작 IL 오프셋을 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.Kind" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryLength">
      <summary>try 블록의 길이(바이트 단위)를 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryOffset">
      <summary>try 블록의 시작 IL 오프셋을 가져옵니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExceptionRegionKind" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Catch" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Fault" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Filter" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Finally" />
    <member name="T:System.Reflection.Metadata.ExportedType" />
    <member name="M:System.Reflection.Metadata.ExportedType.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ExportedType.Attributes" />
    <member name="P:System.Reflection.Metadata.ExportedType.Implementation">
      <summary>대상 형식의 구현을 해결하기 위한 핸들을 가져옵니다.</summary>
      <returns>
        <list type="bullet">
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" /> 어셈블리의 다른 모듈을 나타냅니다.</description>
          </item>
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> 가 인 경우 다른 어셈블리 <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder" /> 를 나타내는 <see langword="true" /> 입니다.</description>
          </item>
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> 이가 중첩 된 선언 내보낸 형식을 나타내는입니다.</description>
          </item>
        </list>
      </returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.IsForwarder" />
    <member name="P:System.Reflection.Metadata.ExportedType.Name">
      <summary>대상 형식의 이름을 가져오거나, 형식이 루트 네임스페이스에 중첩되거나 정의된 경우 <see langword="default" />를 가져옵니다.</summary>
      <returns>
        <see cref="T:System.Reflection.Metadata.StringHandle" />구조체 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.Namespace">
      <summary>대상 형식을 포함하는 네임스페이스 전체 이름을 가져오거나, 형식이 루트 네임스페이스에 중첩되거나 정의된 경우 <see langword="default" />를 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.NamespaceDefinition">
      <summary>대상 형식이 정의된 네임스페이스 정의 핸들을 가져오거나, 형식이 루트 네임스페이스에 중첩되거나 정의된 경우 <see langword="default" />를 가져옵니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandle" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Reflection.Metadata.ExportedTypeHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Equality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Inequality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection">
      <summary>
        <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 인스턴스의 컬렉션을 나타냅니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ExportedTypeHandle}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Count">
      <summary>컬렉션의 요소 수를 가져옵니다.</summary>
      <returns>컬렉션에 있는 요소의 수입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.FieldDefinition" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetMarshallingDescriptor" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetOffset">
      <summary>필드 레이아웃 오프셋을 반환하거나, 사용할 수 없는 경우 -1을 반환합니다.</summary>
      <returns>필드 정의 오프셋이거나, 사용할 수 없는 경우 -1입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetRelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Name" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Reflection.Metadata.FieldDefinitionHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Equality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Inequality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#FieldDefinitionHandle}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Count">
      <summary>컬렉션의 요소 수를 가져옵니다.</summary>
      <returns>컬렉션에 있는 요소의 수입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameter" />
    <member name="M:System.Reflection.Metadata.GenericParameter.GetConstraints" />
    <member name="M:System.Reflection.Metadata.GenericParameter.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameter.Attributes">
      <summary>분산 및 제약 조건을 지정하는 특성을 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Index">
      <summary>선언 제네릭 형식 또는 메서드 선언 내에서 매개 변수의 0부터 시작하는 인덱스를 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Name">
      <summary>제네릭 매개 변수의 이름을 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Parent">
      <summary>이 제네릭 매개 변수의 부모를 나타내는 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />을 가져옵니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraint" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraint.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Parameter">
      <summary>제한된 <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />을 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Type">
      <summary>이 제네릭 매개 변수가 파생되도록 제한하는 형식 또는 이 제네릭 매개 변수가 구현하도록 제한되는 형식을 지정하는 핸들(<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 또는 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />)을 가져옵니다.</summary>
      <returns>
        <see cref="T:System.Reflection.Metadata.EntityHandle" /> 인스턴스입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Equality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Inequality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection">
      <summary>제네릭 형식 매개 변수에 대한 제약 조건의 컬렉션을 나타냅니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterConstraintHandle}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Count">
      <summary>컬렉션의 요소 수를 가져옵니다.</summary>
      <returns>컬렉션에 있는 요소의 수입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Item(System.Int32)">
      <summary>읽기 전용 목록에서 지정된 인덱스의 요소를 가져옵니다.</summary>
      <param name="index">가져올 요소의 0부터 시작하는 인덱스입니다.</param>
      <returns>읽기 전용 목록에서 지정된 인덱스의 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Reflection.Metadata.GenericParameterHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Equality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Inequality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection">
      <summary>메서드나 형식의 제네릭 형식 매개 변수 컬렉션을 나타냅니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterHandle}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Count">
      <summary>컬렉션의 요소 수를 가져옵니다.</summary>
      <returns>컬렉션에 있는 요소의 수입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Item(System.Int32)">
      <summary>읽기 전용 목록에서 지정된 인덱스의 요소를 가져옵니다.</summary>
      <param name="index">가져올 요소의 0부터 시작하는 인덱스입니다.</param>
      <returns>읽기 전용 목록에서 지정된 인덱스의 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GuidHandle" />
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Reflection.Metadata.GuidHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Equality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GuidHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Implicit(System.Reflection.Metadata.GuidHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Inequality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.GuidHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Handle">
      <summary>메타데이터 엔터티(형식 참조, 형식 정의, 형식 사양, 메서드 정의, 사용자 지정 특성 등) 또는 값(문자열, Blob, guid, 사용자 문자열 등)을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Handle.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.Handle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Reflection.Metadata.Handle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Handle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.Handle.op_Equality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.op_Inequality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.Handle.IsNil" />
    <member name="P:System.Reflection.Metadata.Handle.Kind" />
    <member name="T:System.Reflection.Metadata.HandleComparer" />
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>두 엔터티 핸들을 비교합니다.</summary>
      <param name="x">비교할 첫 번째 엔터티 핸들입니다.</param>
      <param name="y">비교할 두 번째 엔터티 핸들입니다.</param>
      <returns>두 엔터티 핸들이 같으면 0이고, 같지 않으면 0이 아닌 값입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <summary>두 핸들을 비교합니다.</summary>
      <param name="x">비교할 첫 번째 핸들입니다.</param>
      <param name="y">비교할 두 번째 핸들입니다.</param>
      <returns>두 핸들이 같으면 0이고, 같지 않으면 0이 아닌 값입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>지정한 개체가 같은지 여부를 확인합니다.</summary>
      <param name="x">비교할 <paramref name="T" /> 형식의 첫 번째 개체입니다.</param>
      <param name="y">비교할 <paramref name="T" /> 형식의 두 번째 개체입니다.</param>
      <returns>지정한 개체가 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <summary>지정한 개체가 같은지 여부를 확인합니다.</summary>
      <param name="x">비교할 <paramref name="T" /> 형식의 첫 번째 개체입니다.</param>
      <param name="y">비교할 <paramref name="T" /> 형식의 두 번째 개체입니다.</param>
      <returns>지정한 개체가 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.EntityHandle)">
      <summary>지정한 개체의 해시 코드를 반환합니다.</summary>
      <param name="obj">해시 코드가 반환될 <see cref="T:System.Object" />입니다.</param>
      <returns>지정한 개체의 해시 코드입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.Handle)">
      <summary>지정한 개체의 해시 코드를 반환합니다.</summary>
      <param name="obj">해시 코드가 반환될 <see cref="T:System.Object" />입니다.</param>
      <returns>지정한 개체의 해시 코드입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.HandleComparer.Default" />
    <member name="T:System.Reflection.Metadata.HandleKind" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyFile" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.Blob" />
    <member name="F:System.Reflection.Metadata.HandleKind.Constant" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.DeclarativeSecurityAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.Document" />
    <member name="F:System.Reflection.Metadata.HandleKind.EventDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ExportedType" />
    <member name="F:System.Reflection.Metadata.HandleKind.FieldDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameterConstraint" />
    <member name="F:System.Reflection.Metadata.HandleKind.Guid" />
    <member name="F:System.Reflection.Metadata.HandleKind.ImportScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.InterfaceImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalConstant" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalVariable" />
    <member name="F:System.Reflection.Metadata.HandleKind.ManifestResource" />
    <member name="F:System.Reflection.Metadata.HandleKind.MemberReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.NamespaceDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.Parameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.PropertyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.StandaloneSignature" />
    <member name="F:System.Reflection.Metadata.HandleKind.String" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.UserString" />
    <member name="T:System.Reflection.Metadata.IConstructedTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetArrayType(`0,System.Reflection.Metadata.ArrayShape)">
      <summary>특정 요소 형식 및 셰이프의 일반화된 배열에 대한 형식 기호를 가져옵니다.</summary>
      <param name="elementType">배열에 있는 요소의 형식입니다.</param>
      <param name="shape">배열의 셰이프(순위, 크기 및 하한값)입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetByReferenceType(`0)">
      <summary>특정 요소 형식의 관리형 포인터에 대한 형식 기호를 가져옵니다.</summary>
      <param name="elementType" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetGenericInstantiation(`0,System.Collections.Immutable.ImmutableArray{`0})">
      <summary>특정 형식 인수를 사용하는 특정 제네릭 형식의 제네릭 인스턴스화에 대한 형식 기호를 가져옵니다.</summary>
      <param name="genericType" />
      <param name="typeArguments" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetPointerType(`0)">
      <summary>특정 요소 형식의 비관리형 포인터에 대한 형식 기호를 가져옵니다.</summary>
      <param name="elementType" />
    </member>
    <member name="T:System.Reflection.Metadata.ICustomAttributeTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetSystemType">
      <summary>
        <see cref="T:System.Type" />에 대한 <typeparamref name="TType" /> 표현을 가져옵니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetTypeFromSerializedName(System.String)">
      <summary>지정된 직렬화 형식 이름의 형식 기호를 가져옵니다.</summary>
      <param name="name">소위 말하는 "리플렉션 표기법" 형식의 직렬화된 형식입니다(<see cref="M:System.Type.GetType(System.String)" /> 메서드가 이해한 바에 따르면).</param>
      <exception cref="T:System.BadImageFormatException">이름의 형식이 잘못되었습니다.</exception>
      <returns>
        <typeparamref name="TType" /> 인스턴스입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetUnderlyingEnumType(`0)">
      <summary>지정된 열거형 형식 기호의 기본 형식을 가져옵니다.</summary>
      <param name="type">열거형 형식입니다.</param>
      <exception cref="T:System.BadImageFormatException">지정된 형식 기호가 열거형을 나타내지 않습니다.</exception>
      <returns>열거형의 기본 형식을 나타내는 형식 코드입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.IsSystemType(`0)">
      <summary>지정된 형식이 <see cref="T:System.Type" />을 나타내는지 확인합니다.</summary>
      <param name="type">확인할 형식입니다.</param>
      <returns>지정된 형식이 <see cref="T:System.Type" />이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ILOpCode" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.And" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Arglist" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Box" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Break" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Call" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Calli" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Callvirt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Castclass" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ceq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ckfinite" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Constrained" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Dup" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfilter" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfinally" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Isinst" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Jmp" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_5" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_6" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_7" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_m1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelema" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldlen" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldnull" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldstr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldtoken" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldvirtftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Localloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mkrefany" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Neg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newarr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Nop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Not" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Or" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Pop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Readonly" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanytype" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanyval" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ret" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rethrow" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shl" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sizeof" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Switch" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Tail" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Throw" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unaligned" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox_any" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Volatile" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Xor" />
    <member name="T:System.Reflection.Metadata.ILOpCodeExtensions" />
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetBranchOperandSize(System.Reflection.Metadata.ILOpCode)">
      <summary>지정된 분기 명령 피연산자의 크기를 계산합니다.</summary>
      <param name="opCode">분기 작업 코드입니다.</param>
      <exception cref="T:System.ArgumentException">지정된 <paramref name="opCode" />는 분기 작업 코드가 아닙니다.</exception>
      <returns>
        <paramref name="opCode" />가 짧은 분기이면 1이고, 긴 분기이면 4입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetLongBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>긴 형식의 지정된 분기 작업 코드를 가져옵니다.</summary>
      <param name="opCode">분기 작업 코드입니다.</param>
      <exception cref="T:System.ArgumentException">지정된 <paramref name="opCode" />는 분기 작업 코드가 아닙니다.</exception>
      <returns>긴 형식의 분기 작업 코드입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetShortBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>짧은 형식의 지정된 분기 작업 코드를 가져옵니다.</summary>
      <param name="opCode">분기 작업 코드입니다.</param>
      <exception cref="T:System.ArgumentException">지정된 <paramref name="opCode" />는 분기 작업 코드가 아닙니다.</exception>
      <returns>짧은 형식의 분기 작업 코드입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.IsBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>지정된 작업이 레이블의 분기인지 확인합니다.</summary>
      <param name="opCode" />
      <returns>지정된 작업 코드가 레이블의 분기이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImageFormatLimitationException">
      <summary>메타데이터 쓰기 시도가 형식 사양에 지정된 제한을 초과하는 경우에 throw되는 예외입니다. 예를 들어 힙 크기 제한을 초과하는 경우입니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor">
      <summary>
        <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>serialize된 데이터를 사용하여 <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="info">serialize된 개체 데이터를 보유하는 개체입니다.</param>
      <param name="context">원본 또는 대상에 대한 컨텍스트 정보입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String)">
      <summary>지정된 오류 메시지를 사용하여 <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="message">이 예외의 원인을 설명하는 오류 메시지입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String,System.Exception)">
      <summary>지정된 오류 메시지와 이 예외를 발생시킨 예외를 사용하여 <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="message">이 예외의 원인을 설명하는 오류 메시지입니다.</param>
      <param name="innerException">현재 예외의 원인이 되는 예외이거나, 내부 예외를 지정하지 않았으면 <see langword="null" />입니다.</param>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinition" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Alias" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Kind" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetAssembly" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetNamespace" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetType" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportDefinition}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <exception cref="T:System.BadImageFormatException">잘못된 Blob 형식입니다.</exception>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinitionKind" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyReference" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyReferenceAlias" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportXmlNamespace" />
    <member name="T:System.Reflection.Metadata.ImportScope">
      <summary>가져오기 그룹을 사용할 수 있는 어휘 범위에 대한 정보를 제공합니다. 이 정보는 디버그 메타데이터에 저장됩니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScope.GetImports" />
    <member name="P:System.Reflection.Metadata.ImportScope.ImportsBlob" />
    <member name="P:System.Reflection.Metadata.ImportScope.Parent" />
    <member name="T:System.Reflection.Metadata.ImportScopeCollection" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportScopeHandle}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Count">
      <summary>컬렉션의 요소 수를 가져옵니다.</summary>
      <returns>컬렉션에 있는 요소의 수입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportScopeCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportScopeHandle" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Reflection.Metadata.ImportScopeHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Equality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Inequality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.InterfaceImplementation" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementation.Interface">
      <summary>구현된 인터페이스(<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 또는 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />)를 가져옵니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandle" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Equality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Inequality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#InterfaceImplementationHandle}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Count">
      <summary>컬렉션의 요소 수를 가져옵니다.</summary>
      <returns>컬렉션에 있는 요소의 수입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISignatureTypeProvider`2">
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetFunctionPointerType(System.Reflection.Metadata.MethodSignature{`0})">
      <summary>지정된 메서드 <paramref name="signature" />의 함수 포인터 형식에 대한 형식 기호를 가져옵니다.</summary>
      <param name="signature" />
      <returns>함수 포인터 형식에 대한 형식 기호입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericMethodParameter(`1,System.Int32)">
      <summary>지정된 0 기반 <paramref name="index" />에서 제네릭 메서드 매개 변수에 대한 형식 기호를 가져옵니다.</summary>
      <param name="genericContext" />
      <param name="index" />
      <returns>
        <paramref name="index" />의 제네릭 메서드 매개 변수에 대한 형식 기호입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericTypeParameter(`1,System.Int32)">
      <summary>지정된 0 기반 <paramref name="index" />에서 제네릭 형식 매개 변수에 대한 형식 기호를 가져옵니다.</summary>
      <param name="genericContext" />
      <param name="index" />
      <returns>지정된 0 기반 <paramref name="index" />에서 제네릭 형식 매개 변수에 대한 형식 기호입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetModifiedType(`0,`0,System.Boolean)">
      <summary>사용자 지정 한정자가 적용된 형식의 형식 기호를 가져옵니다.</summary>
      <param name="modifier">적용되는 한정자 형식입니다.</param>
      <param name="unmodifiedType">한정자가 적용되지 않는 기본 형식의 형식 기호입니다.</param>
      <param name="isRequired">수정자가 필요한 경우에는 <see langword="true" />이고, 선택 사항인 경우에는 <see langword="false" />입니다.</param>
      <returns>형식 기호.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetPinnedType(`0)">
      <summary>고정된 것으로 표시된 로컬 변수 형식에 대한 형식 기호를 가져옵니다.</summary>
      <param name="elementType" />
      <returns>로컬 변수 형식에 대한 형식 기호입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetTypeFromSpecification(System.Reflection.Metadata.MetadataReader,`1,System.Reflection.Metadata.TypeSpecificationHandle,System.Byte)">
      <summary>형식 사양에 대한 형식 기호를 가져옵니다.</summary>
      <param name="reader">서명 디코더에 전달된 메타데이터 reader입니다. <see langword="null" />일 수 있습니다.</param>
      <param name="genericContext">서명 디코더에 전달된 컨텍스트.</param>
      <param name="handle">형식 사양 핸들.</param>
      <param name="rawTypeKind">서명에 지정된 형식의 종류입니다. 이 값을 해석하려면 <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />를 사용합니다.</param>
      <returns>형식 사양에 대한 형식 기호입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISimpleTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetPrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary>기본 형식에 대한 형식 기호를 가져옵니다.</summary>
      <param name="typeCode" />
      <returns>다음에 대한 형식 기호 <param name="typeCode" />을 선택합니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromDefinition(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeDefinitionHandle,System.Byte)">
      <summary>형식 정의에 대한 형식 기호를 가져옵니다.</summary>
      <param name="reader">서명 디코더에 전달된 메타데이터 reader입니다. <see langword="null" />일 수 있습니다.</param>
      <param name="handle">형식 정의 핸들.</param>
      <param name="rawTypeKind">서명에 지정된 형식의 종류입니다. 이 값을 해석하려면 <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />를 사용합니다.</param>
      <returns>형식 기호.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromReference(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeReferenceHandle,System.Byte)">
      <summary>형식 참조에 대한 형식 기호를 가져옵니다.</summary>
      <param name="reader">서명 디코더에 전달된 메타데이터 reader입니다. <see langword="null" />일 수 있습니다.</param>
      <param name="handle">형식 정의 핸들.</param>
      <param name="rawTypeKind">서명에 지정된 형식의 종류입니다. 이 값을 해석하려면 <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />를 사용합니다.</param>
      <returns>형식 기호.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISZArrayTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ISZArrayTypeProvider`1.GetSZArrayType(`0)">
      <summary>하한값이 0인 특정 요소 형식의 1차원 배열에 대한 형식 기호를 가져옵니다.</summary>
      <param name="elementType" />
      <returns>
        <typeparamref name="TType" /> 인스턴스입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstant">
      <summary>지역 상수에 대한 정보를 제공합니다. 이 정보는 디버그 메타데이터에 저장됩니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstant.Name" />
    <member name="P:System.Reflection.Metadata.LocalConstant.Signature">
      <summary>상수 시그니처를 가져옵니다.</summary>
      <returns>상수 시그니처입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandle" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Reflection.Metadata.LocalConstantHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Equality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Inequality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalConstantHandle}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Count">
      <summary>컬렉션의 요소 수를 가져옵니다.</summary>
      <returns>컬렉션에 있는 요소의 수입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScope">
      <summary>지역 변수 및 상수의 범위에 대한 정보를 제공합니다. 이 정보는 디버그 메타데이터에 저장됩니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScope.GetChildren" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalConstants" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalVariables" />
    <member name="P:System.Reflection.Metadata.LocalScope.EndOffset" />
    <member name="P:System.Reflection.Metadata.LocalScope.ImportScope" />
    <member name="P:System.Reflection.Metadata.LocalScope.Length" />
    <member name="P:System.Reflection.Metadata.LocalScope.Method" />
    <member name="P:System.Reflection.Metadata.LocalScope.StartOffset" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandle" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Reflection.Metadata.LocalScopeHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Equality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Inequality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalScopeHandle}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Count">
      <summary>컬렉션의 요소 수를 가져옵니다.</summary>
      <returns>컬렉션에 있는 요소의 수입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalVariable">
      <summary>지역 변수에 대한 정보를 제공합니다. 이 정보는 디버그 메타데이터에 저장됩니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariable.Attributes" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Index" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Name" />
    <member name="T:System.Reflection.Metadata.LocalVariableAttributes" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.DebuggerHidden" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.None" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandle" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Reflection.Metadata.LocalVariableHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Equality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Inequality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalVariableHandle}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Count">
      <summary>컬렉션의 요소 수를 가져옵니다.</summary>
      <returns>컬렉션에 있는 요소의 수입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResource" />
    <member name="M:System.Reflection.Metadata.ManifestResource.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ManifestResource.Attributes">
      <summary>매니페스트 리소스 특성을 가져옵니다.</summary>
      <returns>매니페스트 리소스 특성을 지정 하는 열거형 값의 비트 조합입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Implementation">
      <summary>구현 엔터티 핸들을 가져옵니다.</summary>
      <returns>EntityHandle 인스턴스입니다. 속성이 이면 <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> 반환 된 <see langword="true" /> 핸들에 기본값이 포함 됩니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Name">
      <summary>리소스 이름을 가져옵니다.</summary>
      <returns>리소스 이름입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Offset">
      <summary>이 리소스 레코드가 시작되는 참조된 파일 내의 바이트 오프셋을 가져옵니다.</summary>
      <returns>참조 된 파일 내에서이 리소스 레코드가 시작 되는 바이트 오프셋입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandle" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Reflection.Metadata.ManifestResourceHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Equality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Inequality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection">
      <summary>
        <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" /> 인스턴스의 컬렉션을 나타냅니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ManifestResourceHandle}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Count">
      <summary>컬렉션의 요소 수를 가져옵니다.</summary>
      <returns>컬렉션에 있는 요소의 수입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReference" />
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeFieldSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MemberReference.GetKind">
      <summary>멤버 참조가 메서드 또는 필드인지 여부를 확인합니다.</summary>
      <exception cref="T:System.BadImageFormatException">멤버 참조 서명이 올바르지 않습니다.</exception>
      <returns>멤버 참조의 종류를 나타내는 열거형 값 중 하나입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Name" />
    <member name="P:System.Reflection.Metadata.MemberReference.Parent">
      <summary>부모 엔터티 핸들을 가져옵니다.</summary>
      <returns>엔터티 핸들 인스턴스입니다. 속성이 이면 <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> 반환 된 <see langword="true" /> 핸들에 기본값이 포함 됩니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Signature">
      <summary>시그니처 Blob에 대한 핸들을 가져옵니다.</summary>
      <returns>서명 blob에 대 한 핸들입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandle" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Reflection.Metadata.MemberReferenceHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Equality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Inequality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /> 인스턴스의 컬렉션을 나타냅니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MemberReferenceHandle}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Count">
      <summary>컬렉션의 요소 수를 가져옵니다.</summary>
      <returns>컬렉션에 있는 요소의 수입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceKind">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReference" />가 메서드 또는 필드를 참조하는지를 나타내는 상수를 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Field">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReference" />는 필드를 참조합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Method">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReference" />는 메서드를 참조합니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataKind" />
    <member name="F:System.Reflection.Metadata.MetadataKind.Ecma335">
      <summary>CLI 메타데이터입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.ManagedWindowsMetadata">
      <summary>관리 컴파일러에서 생성된 Windows 메타데이터입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.WindowsMetadata">
      <summary>Windows 메타데이터입니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReader">
      <summary>ECMA 335 CLI 사양에 정의된 대로 메타데이터를 읽습니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32)">
      <summary>지정된 메모리 위치에 저장된 메타데이터에서 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="metadata">메타데이터 블록의 첫 번째 바이트에 대한 포인터입니다.</param>
      <param name="length">블록의 바이트 수입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary>지정된 메모리 위치에 저장된 메타데이터에서 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="metadata" />
      <param name="length" />
      <param name="options" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>지정된 메모리 위치에 저장된 메타데이터에서 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="metadata" />
      <param name="length" />
      <param name="options" />
      <param name="utf8Decoder" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" />가 양수가 아닙니다.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="metadata" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="utf8Decoder" />의 인코딩은 <see cref="T:System.Text.UTF8Encoding" />이 아닙니다.</exception>
      <exception cref="T:System.PlatformNotSupportedException">현재 플랫폼은 big-endian입니다.</exception>
      <exception cref="T:System.BadImageFormatException">잘못된 메타데이터 헤더입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyFile(System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyReference(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobBytes(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobContent(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.StringHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetConstant(System.Reflection.Metadata.ConstantHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttribute(System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttributes(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDeclarativeSecurityAttribute(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDocument(System.Reflection.Metadata.DocumentHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetEventDefinition(System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetExportedType(System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetFieldDefinition(System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameter(System.Reflection.Metadata.GenericParameterHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameterConstraint(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGuid(System.Reflection.Metadata.GuidHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetImportScope(System.Reflection.Metadata.ImportScopeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetInterfaceImplementation(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalConstant(System.Reflection.Metadata.LocalConstantHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScope(System.Reflection.Metadata.LocalScopeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalVariable(System.Reflection.Metadata.LocalVariableHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetManifestResource(System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMemberReference(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDefinition(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodImplementation(System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodSpecification(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleReference(System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinition(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinitionRoot" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetParameter(System.Reflection.Metadata.ParameterHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetPropertyDefinition(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetStandaloneSignature(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.StringHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeDefinition(System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeReference(System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeSpecification(System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetUserString(System.Reflection.Metadata.UserStringHandle)">
      <param name="handle" />
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyFiles" />
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.DebugMetadataHeader">
      <summary>#Pdb 스트림에서 디코딩된 정보를 가져오거나 스트림이 없는 경우 <see langword="null" />을 가져옵니다.</summary>
      <returns>#Pdb 스트림에서 디코딩된 정보 이거나, 스트림이 없는 <see langword="null" /> 경우입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.DeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Documents" />
    <member name="P:System.Reflection.Metadata.MetadataReader.EventDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ExportedTypes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.FieldDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ImportScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.IsAssembly">
      <summary>메타데이터가 어셈블리를 나타내는지 여부를 지정하는 값을 가져옵니다.</summary>
      <returns>
        <see langword="true" /> 메타 데이터가 어셈블리를 나타내면이 고, 그렇지 않으면입니다. 그렇지 않으면 <see langword="false" /> 입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalConstants" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalVariables" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ManifestResources" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MemberReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataKind">
      <summary>메타데이터 종류를 가져옵니다.</summary>
      <returns>메타 데이터 종류를 지정 하는 열거형 값 중 하나입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataLength">
      <summary>기본 데이터의 길이를 가져옵니다.</summary>
      <returns>기본 데이터의 길이입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataPointer">
      <summary>기본 데이터에 대한 포인터를 가져옵니다.</summary>
      <returns>기본 데이터에 대 한 포인터입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataVersion">
      <summary>메타데이터 헤더에서 읽은 버전 문자열을 가져옵니다.</summary>
      <returns>메타 데이터 헤더에서 읽은 버전 문자열입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Options">
      <summary>생성자에 전달된 <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" />를 가져옵니다.</summary>
      <returns>열거형 값을 설명 하는 열거형 값의 비트 조합입니다 <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" /> .</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.PropertyDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.StringComparer">
      <summary>메타데이터에 저장된 문자열을 비교하는 데 사용되는 비교자를 가져옵니다.</summary>
      <returns>메타 데이터에 저장 된 문자열을 비교 하는 데 사용 되는 비교자입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.UTF8Decoder">
      <summary>UTF8로 인코딩된 바이트 시퀀스에서 문자열 인스턴스를 생성하기 위해 reader에서 사용하는 디코더를 가져옵니다.</summary>
      <returns>판독기가 UTF8 인코딩된 바이트 시퀀스에서 문자열 인스턴스를 생성 하는 데 사용 하는 디코더입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderOptions" />
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.ApplyWindowsRuntimeProjections">
      <summary>Windows 런타임 프로젝션은 기본적으로 설정되어 있습니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.Default">
      <summary>
        <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" /> 인수를 사용하지 않는 오버로드를 통해 <see cref="T:System.Reflection.Metadata.MetadataReader" />를 가져올 때 사용되는 옵션입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.None">
      <summary>모든 옵션을 사용할 수 없습니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderProvider">
      <summary>바이트 배열, 메모리 블록 또는 스트림으로 저장된 메타데이터에 대한 <see cref="T:System.Reflection.Metadata.MetadataReader" />를 제공합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.Dispose">
      <summary>reader에 의해 할당된 모든 메로리를 삭제합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Byte*,System.Int32)">
      <summary>메모리에 저장된 이미지를 통해 메타데이터 공급자를 만듭니다.</summary>
      <param name="start">메타데이터 Blob의 시작 부분에 대한 포인터.</param>
      <param name="size">메타데이터 Blob의 크기.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="start" />이(가) <see cref="F:System.IntPtr.Zero" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" />가 음수입니다.</exception>
      <returns>새 메타데이터 공급자.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>바이트 배열을 통해 공급자를 만듭니다.</summary>
      <param name="image">메타데이터 이미지.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="image" />이(가) <see langword="null" />인 경우</exception>
      <returns>새 공급자.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary>현재 위치에서 시작하는 지정된 크기의 스트림에 대한 공급자를 만듭니다.</summary>
      <param name="stream">
        <see cref="T:System.IO.Stream" /> 인스턴스입니다.</param>
      <param name="options">스트림에서 이미지의 섹션을 읽는 방법을 지정하는 옵션입니다.</param>
      <param name="size">스트림의 메타데이터 Blob의 크기. 지정되지 않은 경우 메타데이터 Blob은 스트림의 맨 끝까지 확장되는 것으로 간주됩니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="stream" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="stream" />은 읽기 및 검색 작업을 지원하지 않습니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">크기가 음수이거나 스트림의 끝을 넘어 확장됩니다.</exception>
      <exception cref="T:System.IO.IOException">스트림에서 읽는 중 오류가 발생했습니다(<see cref="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata" />가 지정된 경우에만).</exception>
      <returns>새 공급자.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Byte*,System.Int32)">
      <summary>메모리에 저정된 Blob을 통해 이식 가능한 PDB 메타데이터 공급자를 만듭니다.</summary>
      <param name="start">이식 가능한 PDB Blob의 시작 부분에 대한 포인터입니다.</param>
      <param name="size">이식 가능한 PDB Blob의 크기.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="start" />이(가) <see cref="F:System.IntPtr.Zero" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" />가 음수입니다.</exception>
      <returns>새 이식 가능한 PDB 메타데이터 공급자.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>바이트 배열을 통해 이식 가능한 PDB 메타데이터 공급자를 만듭니다.</summary>
      <param name="image">이식 가능한 PDB 이미지.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="image" />이(가) <see langword="null" />인 경우</exception>
      <returns>새 이식 가능한 PDB 메타데이터 공급자.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary>현재 위치에서 시작하는 지정된 크기의 스트림에 대한 공급자를 만듭니다.</summary>
      <param name="stream">스트림입니다.</param>
      <param name="options">스트림에서 이미지의 섹션을 읽는 방법을 지정하는 옵션입니다.</param>
      <param name="size">스트림의 메타데이터 Blob의 크기. 지정되지 않은 경우 메타데이터 Blob은 스트림의 맨 끝까지 확장되는 것으로 간주됩니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="stream" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="stream" />은 읽기 및 검색 작업을 지원하지 않습니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">크기가 음수이거나 스트림의 끝을 넘어 확장됩니다.</exception>
      <returns>
        <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> 인스턴스입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.GetMetadataReader(System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>
        <see cref="T:System.Reflection.Metadata.MetadataReader" />에서 <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />을 가져옵니다.</summary>
      <param name="options">메타데이터를 읽을 때 구성을 나타내는 열거형 값의 비트 조합입니다.</param>
      <param name="utf8Decoder">사용할 인코딩입니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="utf8Decoder" />의 인코딩은 <see cref="T:System.Text.UTF8Encoding" />이 아닙니다.</exception>
      <exception cref="T:System.PlatformNotSupportedException">현재 플랫폼은 big-endian입니다.</exception>
      <exception cref="T:System.IO.IOException">기본 스트림에서 읽는 동안 IO 오류가 발생했습니다.</exception>
      <exception cref="T:System.ObjectDisposedException">공급자가 삭제되었습니다.</exception>
      <returns>
        <see cref="T:System.Reflection.Metadata.MetadataReader" /> 인스턴스.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStreamOptions" />
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.Default">
      <summary>기본적으로 스트림은 <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />가 삭제되고 PE 이미지의 섹션이 느리게 읽혀질 때 삭제됩니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen">
      <summary>
        <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />가 삭제될 때 스트림을 열린 상태로 유지합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata">
      <summary>
        <para>PDB 메타데이터를 즉시 메모리로 읽습니다.</para>
        <para>기본 파일은 닫히며 <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />가 생성된 후에도 삭제될 수 있습니다. <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />는 <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen" />을 지정하지 않을 경우 생성자가 반환될 때 자동으로 스트림을 닫습니다.</para>
      </summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringComparer">
      <summary>가능하면 할당을 방지하면서 메타데이터의 문자열을 쿼리하기 위한 문자열 비교 도우미를 제공합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringDecoder">
      <summary>텍스트를 나타내는 메타데이터의 바이트 시퀀스를 디코딩하는 사용자 지정 메커니즘을 <see cref="T:System.Reflection.Metadata.MetadataReader" />에 제공합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.#ctor(System.Text.Encoding)">
      <summary>지정된 인코딩을 사용하여 <see cref="T:System.Reflection.Metadata.MetadataStringDecoder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="encoding">사용할 인코딩입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.GetString(System.Byte*,System.Int32)">
      <summary>메타데이터의 바이트 시퀀스에 대한 문자열을 가져옵니다. 필요한 경우 이 항목을 캐시 문자열로 재정의합니다. 그렇지 않으면 <see cref="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding" />으로 바로 전달되어 구현되고 모든 호출에 새 문자열이 할당됩니다.</summary>
      <param name="bytes">디코딩할 바이트에 대한 포인터입니다.</param>
      <param name="byteCount">디코딩할 바이트 수입니다.</param>
      <returns>디코딩된 문자열입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.DefaultUTF8">
      <summary>생성자에게 제공된 디코더가 없는 경우 <see cref="T:System.Reflection.Metadata.MetadataReader" />에서 UTF-8을 디코딩하는 데 사용하는 기본 디코더를 가져옵니다.</summary>
      <returns>에서 <see cref="T:System.Reflection.Metadata.MetadataReader" /> u t f-8을 디코딩하는 데 사용 하는 기본 디코더입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding">
      <summary>이 인스턴스에서 사용되는 인코딩을 가져옵니다.</summary>
      <returns>이 인스턴스에서 사용 하는 인코딩입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodBodyBlock" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.Create(System.Reflection.Metadata.BlobReader)">
      <param name="reader" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILBytes" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILContent" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILReader" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.ExceptionRegions" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalSignature" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalVariablesInitialized" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.MaxStack" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.Size">
      <summary>헤더, IL 및 예외 영역을 포함하여 메서드 본문의 크기를 가져옵니다.</summary>
      <returns>메서드 본문의 크기입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformation">
      <summary>메서드 정의와 연결된 디버그 정보를 제공합니다. 이 정보는 디버그 메타데이터에 저장됩니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetSequencePoints">
      <summary>
        <see cref="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob" />에서 디코딩된 시퀀스 위치 컬렉션을 반환합니다.</summary>
      <returns>시퀀스 위치 컬렉션입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetStateMachineKickoffMethod">
      <summary>상태 머신의 킥오프 메서드를 반환합니다.</summary>
      <returns>메서드가 상태 머신의 <c>MoveNext</c> 메서드인 경우 상태 시스템의 킥오프 메서드입니다. 그렇지 않으면 <see cref="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" /> 속성이 <see langword="true" />인 핸들을 반환합니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.Document">
      <summary>메서드의 모든 시퀀스 위치를 포함하는 단일 문서의 핸들을 가져옵니다.</summary>
      <returns>메서드의 모든 시퀀스 위치를 포함 하는 단일 문서에 대 한 핸들 또는 <see cref="P:System.Reflection.Metadata.DocumentHandle.IsNil" /><see langword="true" /> 메서드에 시퀀스 지점이 없거나 여러 문서에 걸쳐 있는 경우 해당 속성이 인 핸들입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.LocalSignature">
      <summary>로컬 서명 핸들을 반환합니다.</summary>
      <returns>로컬 서명 핸들 이거나, <see cref="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" /><see langword="true" /> 메서드에서 지역 변수를 정의 하지 않는 경우 해당 속성이 인 핸들입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob">
      <summary>Blob 인코딩 시퀀스 위치를 반환합니다.</summary>
      <returns>Blob 인코딩 시퀀스 위치 이거나, <see cref="P:System.Reflection.Metadata.BlobHandle.IsNil" /><see langword="true" /> 메서드에 시퀀스 위치가 없는 경우 속성이 인 핸들입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Equality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Inequality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.ToDefinitionHandle">
      <summary>이 핸들에 해당하는 <see cref="T:System.Reflection.Metadata.MethodDefinition" />에 대한 핸들을 반환합니다.</summary>
      <returns>이 핸들에 해당하는 메서드 정의 핸들입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDebugInformationHandle}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Count">
      <summary>컬렉션의 요소 수를 가져옵니다.</summary>
      <returns>컬렉션에 있는 요소의 수입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDefinition" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetImport" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetParameters" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.ImplAttributes" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Name" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.RelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Equality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Inequality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.ToDebugInformationHandle">
      <summary>이 핸들에 해당하는 <see cref="T:System.Reflection.Metadata.MethodDebugInformation" />에 대한 핸들을 반환합니다.</summary>
      <returns>이 핸들에 해당하는 메서드 디버그 정보 핸들입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDefinitionHandle}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Count">
      <summary>컬렉션의 요소 수를 가져옵니다.</summary>
      <returns>컬렉션에 있는 요소의 수입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImplementation" />
    <member name="M:System.Reflection.Metadata.MethodImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodBody" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodDeclaration" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.Type" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandle" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Reflection.Metadata.MethodImplementationHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Equality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Inequality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodImplementationHandle}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Count">
      <summary>컬렉션의 요소 수를 가져옵니다.</summary>
      <returns>컬렉션에 있는 요소의 수입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImport" />
    <member name="P:System.Reflection.Metadata.MethodImport.Attributes" />
    <member name="P:System.Reflection.Metadata.MethodImport.Module" />
    <member name="P:System.Reflection.Metadata.MethodImport.Name" />
    <member name="T:System.Reflection.Metadata.MethodSignature`1">
      <summary>메서드(정의, 참조 또는 독립 실행형) 또는 속성 서명을 나타냅니다. 속성의 경우 서명은 구분된 <see cref="T:System.Reflection.Metadata.SignatureHeader" />을 포함하여 getter의 속성과 일치합니다.</summary>
      <typeparam name="TType">메서드 형식입니다.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.MethodSignature`1.#ctor(System.Reflection.Metadata.SignatureHeader,`0,System.Int32,System.Int32,System.Collections.Immutable.ImmutableArray{`0})">
      <summary>지정된 헤더, 반환 형식 및 매개 변수 정보를 사용하여 <see cref="T:System.Reflection.Metadata.MethodSignature`1" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
      <param name="header">서명의 선행 바이트에 있는 정보입니다(종류, 호출 규칙, 플래그).</param>
      <param name="returnType">메서드의 반환 형식입니다.</param>
      <param name="requiredParameterCount">필수 매개 변수의 수입니다.</param>
      <param name="genericParameterCount">제네릭 형식 매개 변수의 수입니다.</param>
      <param name="parameterTypes">매개 변수 형식입니다.</param>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.GenericParameterCount">
      <summary>메서드에 대한 제네릭 형식 매개 변수의 수를 가져옵니다.</summary>
      <returns>제네릭 형식 매개 변수의 수 이거나 제네릭이 아닌 메서드의 경우 0입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.Header">
      <summary>서명의 선행 바이트에 있는 정보를 가져옵니다(종류, 호출 규칙, 플래그).</summary>
      <returns>헤더 서명입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ParameterTypes">
      <summary>메서드의 매개 변수 형식을 가져옵니다.</summary>
      <returns>매개 변수 형식에 대 한 변경할 수 없는 컬렉션입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.RequiredParameterCount">
      <summary>메서드에 필요한 매개 변수의 수를 가져옵니다.</summary>
      <returns>필수 매개 변수의 수입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ReturnType">
      <summary>메서드의 반환 형식을 가져옵니다.</summary>
      <returns>반환 형식입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecification" />
    <member name="M:System.Reflection.Metadata.MethodSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodSpecification.Method">
      <summary>이 인스턴스가 참조하는 제네릭 메서드(즉, 인스턴스화인 제네릭 메서드)를 지정하는 <see langword="MethodDef" /> 또는 <see langword="MemberRef" /> 핸들을 가져옵니다.</summary>
      <returns>
        <see langword="MethodDef" />
        <see langword="MemberRef" /> 이 인스턴스가 참조 하는 제네릭 메서드를 지정 하는 또는 핸들입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSpecification.Signature">
      <summary>시그니처 Blob에 대한 핸들을 가져옵니다.</summary>
      <returns>서명 blob에 대 한 핸들입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Reflection.Metadata.MethodSpecificationHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Equality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Inequality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.MethodSpecificationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.ModuleDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.BaseGenerationId" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Generation" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.GenerationId" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Mvid" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Name" />
    <member name="T:System.Reflection.Metadata.ModuleDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Reflection.Metadata.ModuleDefinitionHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Equality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Inequality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ModuleDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ModuleReference" />
    <member name="M:System.Reflection.Metadata.ModuleReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleReference.Name" />
    <member name="T:System.Reflection.Metadata.ModuleReferenceHandle" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Reflection.Metadata.ModuleReferenceHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Equality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Inequality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ModuleReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.NamespaceDefinition" />
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.ExportedTypes">
      <summary>네임스페이스에 직접 상주하는 모든 내보낸 형식을 가져옵니다.</summary>
      <returns>내보낸 형식 핸들의 변경할 수 없는 배열입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Name">
      <summary>네임스페이스 정의의 정규화되지 않은 이름을 가져옵니다.</summary>
      <returns>네임 스페이스 정의의 정규화 되지 않은 이름입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.NamespaceDefinitions">
      <summary>현재 네임스페이스 정의의 직접 자식인 네임스페이스 정의를 가져옵니다.</summary>
      <returns>현재 네임 스페이스 정의의 직계 자식인 네임 스페이스 정의의 변경할 수 없는 배열입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Parent">
      <summary>부모 네임스페이스를 가져옵니다.</summary>
      <returns>부모 네임 스페이스입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.TypeDefinitions">
      <summary>네임스페이스에 직접 상주하는 모든 형식 정의를 가져옵니다.</summary>
      <returns>형식 정의 핸들의 변경할 수 없는 배열입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.NamespaceDefinitionHandle">
      <summary>네임스페이스 정의에 대한 핸들을 제공합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Equality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.NamespaceDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Implicit(System.Reflection.Metadata.NamespaceDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Inequality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Parameter" />
    <member name="M:System.Reflection.Metadata.Parameter.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.Parameter.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.Parameter.GetMarshallingDescriptor" />
    <member name="P:System.Reflection.Metadata.Parameter.Attributes" />
    <member name="P:System.Reflection.Metadata.Parameter.Name" />
    <member name="P:System.Reflection.Metadata.Parameter.SequenceNumber" />
    <member name="T:System.Reflection.Metadata.ParameterHandle" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Reflection.Metadata.ParameterHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Equality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Inequality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection">
      <summary>지정된 메서드의 매개 변수 컬렉션을 포함합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ParameterHandle}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Count">
      <summary>컬렉션의 요소 수를 가져옵니다.</summary>
      <returns>컬렉션에 있는 요소의 수입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PEReaderExtensions" />
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader)">
      <summary>
        <see cref="T:System.Reflection.Metadata.MetadataReader" />에서 <see cref="T:System.Reflection.PortableExecutable.PEReader" />을 가져옵니다.</summary>
      <param name="peReader">현재 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 인스턴스입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.PlatformNotSupportedException">현재 플랫폼은 big-endian입니다.</exception>
      <exception cref="T:System.IO.IOException">기본 스트림에서 읽는 동안 IO 오류가 발생했습니다.</exception>
      <returns>메타 데이터 판독기입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary>
        <see cref="T:System.Reflection.PortableExecutable.PEReader" />에서 지정된 메타데이터 읽기 구성을 사용하여 메타데이터 판독기를 가져옵니다.</summary>
      <param name="peReader">현재 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 인스턴스입니다.</param>
      <param name="options">메타데이터 읽기 구성을 나타내는 열거형 값입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.PlatformNotSupportedException">현재 플랫폼은 big-endian입니다.</exception>
      <exception cref="T:System.IO.IOException">기본 스트림에서 읽는 동안 IO 오류가 발생했습니다.</exception>
      <returns>지정된 메타데이터 읽기 구성을 사용하는 메타데이터 판독기입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>
        <see cref="T:System.Reflection.PortableExecutable.PEReader" />에서 지정된 메타데이터 읽기 구성 및 인코딩 구성을 사용하여 메타데이터 판독기를 가져옵니다.</summary>
      <param name="peReader">현재 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 인스턴스입니다.</param>
      <param name="options">메타데이터 읽기 구성을 나타내는 열거형 값입니다.</param>
      <param name="utf8Decoder">인코딩 구성을 사용하는 메타데이터 문자열 디코더입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="utf8Decoder" />의 인코딩은 <see cref="T:System.Text.UTF8Encoding" />이 아닙니다.</exception>
      <exception cref="T:System.PlatformNotSupportedException">현재 플랫폼은 big-endian입니다.</exception>
      <exception cref="T:System.IO.IOException">기본 스트림에서 읽는 동안 IO 오류가 발생했습니다.</exception>
      <returns>&gt;지정된 메타데이터 읽기 구성 및 인코딩 구성을 사용하는 메타데이터 판독기입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMethodBody(System.Reflection.PortableExecutable.PEReader,System.Int32)">
      <summary>RVA(Relevant Virtual Address)가 지정된 메서드의 본문 블록을 반환합니다.</summary>
      <param name="peReader">현재 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 인스턴스입니다.</param>
      <param name="relativeVirtualAddress">RVA(Relevant Virtual Address)입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.BadImageFormatException">메타데이터에 본문이 없거나 본문이 잘못되었습니다.</exception>
      <exception cref="T:System.InvalidOperationException">메서드가 저장되는 섹션을 사용할 수 없습니다.</exception>
      <exception cref="T:System.IO.IOException">기본 스트림에서 읽는 동안 IO 오류가 발생했습니다.</exception>
      <returns>메서드 블록 본문 인스턴스입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveSerializationTypeCode">
      <summary>
        <see cref="T:System.Reflection.Metadata.CustomAttribute" /> 값 Blob에서 기본 값의 형식을 인코딩하는 데 사용되는 형식 코드를 정의하는 상수를 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Boolean">
      <summary>
        <see cref="T:System.Boolean" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Byte">
      <summary>부호 없는 1바이트 정수 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Char">
      <summary>
        <see cref="T:System.Char" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Double">
      <summary>8바이트 부동 소수점 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int16">
      <summary>부호 있는 2바이트 정수 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int32">
      <summary>부호 있는 4바이트 정수 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int64">
      <summary>부호 있는 8바이트 정수 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.SByte">
      <summary>부호 있는 1바이트 정수 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Single">
      <summary>4바이트 부동 소수점 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.String">
      <summary>
        <see cref="T:System.String" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt16">
      <summary>부호 없는 2바이트 정수 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt32">
      <summary>부호 없는 4바이트 정수 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt64">
      <summary>부호 없는 8바이트 정수 형식입니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveTypeCode">
      <summary>메타데이터 서명에 있는 기본 형식을 정의하는 상수를 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Boolean">
      <summary>
        <see cref="T:System.Boolean" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Byte">
      <summary>
        <see cref="T:System.Byte" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Char">
      <summary>
        <see cref="T:System.Char" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Double">
      <summary>
        <see cref="T:System.Double" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int16">
      <summary>
        <see cref="T:System.Int16" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int32">
      <summary>
        <see cref="T:System.Int32" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int64">
      <summary>
        <see cref="T:System.Int64" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.IntPtr">
      <summary>
        <see cref="T:System.IntPtr" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Object">
      <summary>
        <see cref="T:System.Object" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.SByte">
      <summary>
        <see cref="T:System.SByte" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Single">
      <summary>
        <see cref="T:System.Single" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.String">
      <summary>
        <see cref="T:System.String" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference">
      <summary>형식화된 참조입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt16">
      <summary>
        <see cref="T:System.UInt16" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt32">
      <summary>
        <see cref="T:System.UInt32" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt64">
      <summary>
        <see cref="T:System.UInt64" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UIntPtr">
      <summary>
        <see cref="T:System.UIntPtr" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Void">
      <summary>
        <see cref="T:System.Void" /> 형식입니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PropertyAccessors" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Getter" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Others" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Setter" />
    <member name="T:System.Reflection.Metadata.PropertyDefinition" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetDefaultValue" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Equality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Inequality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#PropertyDefinitionHandle}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Count">
      <summary>컬렉션의 요소 수를 가져옵니다.</summary>
      <returns>컬렉션에 있는 요소의 수입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ReservedBlob`1">
      <summary>후속 콘텐츠 업데이트를 위해 예약된 메타데이터 힙의 핸들 및 해당 blob을 나타냅니다.</summary>
      <typeparam name="THandle" />
    </member>
    <member name="M:System.Reflection.Metadata.ReservedBlob`1.CreateWriter">
      <summary>콘텐츠를 업데이트하는 데 사용되는 <see cref="T:System.Reflection.Metadata.BlobWriter" />를 반환합니다.</summary>
      <returns>콘텐츠를 업데이트하는 데 사용되는 Blob 작성기를 반환합니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Content" />
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Handle">
      <summary>예약된 Blob 핸들을 가져옵니다.</summary>
      <returns>예약 된 lsas 핸들입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SequencePoint" />
    <member name="F:System.Reflection.Metadata.SequencePoint.HiddenLine" />
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Reflection.Metadata.SequencePoint)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.GetHashCode" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Document" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndLine" />
    <member name="P:System.Reflection.Metadata.SequencePoint.IsHidden" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Offset" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartLine" />
    <member name="T:System.Reflection.Metadata.SequencePointCollection" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#SequencePoint}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SequencePointCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SerializationTypeCode">
      <summary>
        <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" /> Blob에서 값의 형식을 인코딩하는 데 사용되는 형식 코드를 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Boolean">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Boolean" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Byte">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Byte" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Char">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Char" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Double">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Double" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Enum">
      <summary>특성 인수는 Enum 인스턴스입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int16">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int16" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int32">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int32" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int64">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int64" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Invalid">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SByte">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SByte" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Single">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Single" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.String">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.String" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SZArray">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SZArray" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.TaggedObject">
      <summary>특성 인수는 "boxed"(매개 변수, 필드 또는 형식 개체의 속성에 전달됨)되고 특성 Blob에서 형식 정보를 제공합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Type">
      <summary>특성 인수는 <see cref="T:System.Type" /> 인스턴스입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt16">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt16" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt32">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt32" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt64">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt64" />에 해당하는 값입니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureAttributes">
      <summary>메서드 서명에 적용할 수 있는 추가 플래그를 지정합니다. 이 형식에서 필드의 기본 값은 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 구조체에서 나타내는 선행 서명 바이트의 표현에 해당합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis">
      <summary>인스턴스 포인터를 나타내는 명시적으로 선언된 첫 번째 매개 변수를 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Generic">
      <summary>제네릭 메서드</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Instance">
      <summary>인스턴스 메서드</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.None">
      <summary>플래그가 없습니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureCallingConvention">
      <summary>지정된 서명의 인수를 호출자에서 호출 수신자로 전달하는 방법을 지정합니다. 이 형식에서 필드의 기본 값은 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 구조체에서 나타내는 선행 서명 바이트의 표현에 해당합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.CDecl">
      <summary>호출 스택이 호출자에 의해 정리되는 관리되지 않는 C/C++ 스타일 호출 규칙입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.Default">
      <summary>고정 길이 인수 목록을 포함하는 관리되는 호출 규칙입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.FastCall">
      <summary>가능한 경우 인수를 레지스터로 전달하는 관리되지 않는 호출 규칙입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.StdCall">
      <summary>호출 스택이 호출 수신자에 의해 정리되는 관리되지 않는 호출 규칙입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.ThisCall">
      <summary>고정 인수 목록을 사용하여 인스턴스 멤버 함수를 호출하기 위한 관리되지 않는 C++ 스타일 호출 규칙입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.Unmanaged">
      <summary>관리되지 않는 호출 규칙의 세부 사항이 modopts로 인코딩됨을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.VarArgs">
      <summary>추가 인수를 전달하기 위한 관리되는 호출 규칙입니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureHeader">
      <summary>서명 Blob의 선행 바이트에 의해 지정된 서명 특징을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask">
      <summary>호출 규칙 또는 서명 종류에 대한 마스크 값을 가져옵니다. 기본 <see cref="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask" /> 값은 15 (0x0F)입니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Byte)">
      <summary>지정된 바이트 값을 사용하여 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
      <param name="rawValue">바이트</param>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Reflection.Metadata.SignatureKind,System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.SignatureAttributes)">
      <summary>지정된 서명 종류, 호출 규칙 및 서명 특성을 사용하여 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
      <param name="kind">시그니처 종류</param>
      <param name="convention">호출 규칙.</param>
      <param name="attributes">서명 특성</param>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Object)">
      <summary>지정된 개체와 이 <see cref="T:System.Reflection.Metadata.SignatureHeader" />가 같은지 비교합니다.</summary>
      <param name="obj">비교할 개체입니다.</param>
      <returns>개체가 동일하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Reflection.Metadata.SignatureHeader)">
      <summary>두 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 값이 같은지 여부를 비교합니다.</summary>
      <param name="other">비교할 값입니다.</param>
      <returns>값이 동일하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.GetHashCode">
      <summary>현재 개체의 해시 코드를 가져옵니다.</summary>
      <returns>현재 개체의 해시 코드입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Equality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary>두 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 값이 같은지 여부를 비교합니다.</summary>
      <param name="left">비교할 첫 번째 값입니다.</param>
      <param name="right">비교할 두 번째 값입니다.</param>
      <returns>값이 동일하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Inequality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary>두 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 값이 서로 같지 않은지 확인합니다.</summary>
      <param name="left">비교할 첫 번째 값입니다.</param>
      <param name="right">비교할 두 번째 값입니다.</param>
      <returns>값이 같지 않으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.ToString">
      <summary>현재 개체를 나타내는 문자열을 반환합니다.</summary>
      <returns>현재 개체를 나타내는 문자열입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Attributes">
      <summary>서명 특성을 가져옵니다.</summary>
      <returns>특성입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.CallingConvention">
      <summary>호출 규칙을 가져옵니다.</summary>
      <returns>호출 규칙.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.HasExplicitThis">
      <summary>이 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 구조체에 <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" /> 서명 특성이 있는지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns>
        <see langword="true" /> 특성이 있으면 <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" /> 이 고, 그렇지 않으면 <see langword="false" /> 입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsGeneric">
      <summary>이 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 구조체에 <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" /> 서명 특성이 있는지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns>
        <see langword="true" /> 특성이 있으면 <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" /> 이 고, 그렇지 않으면 <see langword="false" /> 입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsInstance">
      <summary>이 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 구조체에 <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" /> 서명 특성이 있는지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns>
        <see langword="true" /> 특성이 있으면 <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" /> 이 고, 그렇지 않으면 <see langword="false" /> 입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Kind">
      <summary>시그니처 종류를 가져옵니다.</summary>
      <returns>시그니처 종류</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.RawValue">
      <summary>헤더 바이트의 원시 값을 가져옵니다.</summary>
      <returns>헤더 바이트의 원시 값입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureKind">
      <summary>서명 종류를 지정합니다. 이 형식에서 필드의 기본 값은 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 구조체에서 나타내는 선행 서명 바이트의 표현에 해당합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Field">
      <summary>필드 시그니처입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.LocalVariables">
      <summary>지역 변수 서명입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Method">
      <summary>메서드 참조, 메서드 정의 또는 독립 실행형 메서드 서명입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.MethodSpecification">
      <summary>메서드 사양 서명입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Property">
      <summary>속성 서명입니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeCode">
      <summary>서명 인코딩에서 사용되는 형식 코드를 정의하는 상수를 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Array">
      <summary>서명에서 일반화된 <see cref="T:System.Array" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Boolean">
      <summary>서명에서 <see cref="T:System.Boolean" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.ByReference">
      <summary>서명에서 관리되는 포인터를(byref 반환 값 및 매개 변수)를 나타냅니다. 기본 형식을 인코딩하는 서명별로 Blob에서 이어집니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Byte">
      <summary>서명에서 <see cref="T:System.Byte" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Char">
      <summary>서명에서 <see cref="T:System.Char" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Double">
      <summary>서명에서 <see cref="T:System.Double" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.FunctionPointer">
      <summary>서명에서 함수 포인터 형식을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericMethodParameter">
      <summary>서명 내에서 사용되는 제네릭 메서드 매개 변수를 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeInstance">
      <summary>서명에서 제네릭 형식의 인스턴스화를 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeParameter">
      <summary>서명 내에서 사용되는 제네릭 형식 매개 변수를 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int16">
      <summary>서명에서 <see cref="T:System.Int16" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int32">
      <summary>서명에서 <see cref="T:System.Int32" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int64">
      <summary>서명에서 <see cref="T:System.Int64" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.IntPtr">
      <summary>서명에서 <see cref="T:System.IntPtr" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Invalid">
      <summary>잘못되었거나 초기화되지 않은 형식 코드를 나타냅니다. 유효한 서명에서 나타나지 않습니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Object">
      <summary>서명에서 <see cref="T:System.Object" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.OptionalModifier">
      <summary>호출자가 무시할 수 있는 서명 내의 형식에 적용되는 사용자 지정 한정자를 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pinned">
      <summary>가비지 수집기에서 고정한 지역 변수를 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pointer">
      <summary>서명에서 관리되지 않는 포인터를 나타냅니다. 기본 형식을 인코딩하는 서명별로 Blob에서 이어집니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.RequiredModifier">
      <summary>호출자가 이해해야 하는 서명 내의 형식에 적용되는 사용자 지정 한정자를 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SByte">
      <summary>서명에서 <see cref="T:System.SByte" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Sentinel">
      <summary>고정 인수의 끝과 가변 인수의 시작을 나타내는 표식을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Single">
      <summary>서명에서 <see cref="T:System.Single" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.String">
      <summary>서명에서 <see cref="T:System.String" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SZArray">
      <summary>낮은 경계가 0인 단일 차원 <see cref="T:System.Array" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypedReference">
      <summary>서명에서 형식화된 참조를 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypeHandle">
      <summary>서명에서 <see cref="T:System.Reflection.Metadata.EntityHandle" /> 형식의 앞에 옵니다. 원시 메타데이터에서는 참조 형식의 경우 ELEMENT_TYPE_CLASS(0x12)로 인코딩되거나 값 형식의 경우 ELEMENT_TYPE_VALUETYPE(0x11)으로 인코딩됩니다. Windows 런타임 프로젝션이 클래스에서 값 형식 또는 반대로 투사되므로 이 값은 단일 코드로 축소되며, 이 경우에 원시 코드는 잘못 출력됩니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt16">
      <summary>서명에서 <see cref="T:System.UInt16" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt32">
      <summary>서명에서 <see cref="T:System.UInt32" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt64">
      <summary>서명에서 <see cref="T:System.UInt64" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UIntPtr">
      <summary>서명에서 <see cref="T:System.UIntPtr" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Void">
      <summary>서명에서 <see cref="T:System.Void" />을 나타냅니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeKind">
      <summary>서명의 형식 정의를 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Class">
      <summary>형식 정의 또는 참조는 클래스를 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Unknown">
      <summary>형식 참조 또는 정의가 클래스 또는 값 형식이면 현재 컨텍스트에서 알려져 있지 않습니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.ValueType">
      <summary>형식 정의 또는 참조는 값 형식을 나타냅니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignature" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeLocalSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetKind">
      <summary>서명의 종류를 결정합니다. <see cref="F:System.Reflection.Metadata.SignatureKind.Method" /> 또는 <see cref="F:System.Reflection.Metadata.SignatureKind.LocalVariables" />입니다.</summary>
      <exception cref="T:System.BadImageFormatException">서명이 잘못되었습니다.</exception>
      <returns>서명 종류를 나타내는 열거형 값입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.StandaloneSignature.Signature">
      <summary>시그니처 Blob에 대한 핸들을 가져옵니다.</summary>
      <returns>서명 blob에 대 한 핸들입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignatureHandle" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Equality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Inequality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.StandaloneSignatureKind">
      <summary>
        <see cref="T:System.Reflection.Metadata.StandaloneSignature" />가 독립 실행형 메서드 또는 지역 변수 시그니처를 나타내는지를 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.LocalVariables">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReference" />는 지역 변수 서명을 참조합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.Method">
      <summary>
        <see cref="T:System.Reflection.Metadata.StandaloneSignature" />는 독립 실행형 메서드 서명을 나타냅니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StringHandle" />
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Reflection.Metadata.StringHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.StringHandle.op_Equality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StringHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Implicit(System.Reflection.Metadata.StringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Inequality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.StringHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeDefinition" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclaringType">
      <summary>지정된 중첩 형식의 바깥쪽 형식을 반환합니다.</summary>
      <returns>지정된 중첩 형식의 바깥쪽 형식이거나, 형식이 중첩되지 않는 경우 <see cref="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" /> 속성이 <see langword="true" />인 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetEvents" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetFields" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetInterfaceImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetLayout" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethodImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethods" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetNestedTypes">
      <summary>지정된 형식으로 중첩된 형식 배열을 반환합니다.</summary>
      <returns>지정된 형식으로 중첩된 형식을 나타내는 변경할 수 없는 형식 정의 핸들 배열입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetProperties" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.BaseType">
      <summary>형식 정의의 기본 형식을 가져옵니다. <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 또는 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />입니다.</summary>
      <returns>형식 정의의 기본 형식입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.IsNested">
      <summary>중첩된 형식인지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns>
        <see langword="true" /> 중첩 형식이 면이 고, <see langword="false" /> 그렇지 않으면입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Name">
      <summary>형식 이름을 가져옵니다.</summary>
      <returns>형식의 이름입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Namespace">
      <summary>형식이 정의된 네임스페이스의 전체 이름을 가져옵니다.</summary>
      <returns>형식이 정의 된 네임 스페이스의 전체 이름 이거나, <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /><see langword="true" /> 형식이 중첩 되거나 루트 네임 스페이스에서 정의 된 경우 해당 속성이 인 핸들입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.NamespaceDefinition">
      <summary>형식이 정의된 네임스페이스의 정의 핸들을 가져옵니다.</summary>
      <returns>형식이 정의 된 네임 스페이스의 정의 핸들 이거나, <see cref="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" /><see langword="true" />  형식이 중첩 되거나 루트 네임 스페이스에서 정의 된 경우 해당 속성이 인 핸들입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Reflection.Metadata.TypeDefinitionHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Equality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Inequality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection">
      <summary>
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 인스턴스 컬렉션을 포함합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeDefinitionHandle}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Count">
      <summary>컬렉션의 요소 수를 가져옵니다.</summary>
      <returns>컬렉션에 있는 요소의 수입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeLayout" />
    <member name="M:System.Reflection.Metadata.TypeLayout.#ctor(System.Int32,System.Int32)">
      <param name="size" />
      <param name="packingSize" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeLayout.IsDefault" />
    <member name="P:System.Reflection.Metadata.TypeLayout.PackingSize" />
    <member name="P:System.Reflection.Metadata.TypeLayout.Size" />
    <member name="T:System.Reflection.Metadata.TypeReference" />
    <member name="P:System.Reflection.Metadata.TypeReference.Name">
      <summary>대상 형식의 이름을 가져옵니다.</summary>
      <returns>대상 형식의 이름입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.Namespace">
      <summary>대상 형식이 정의된 네임스페이스의 전체 이름을 가져옵니다.</summary>
      <returns>대상 형식이 정의 된 네임 스페이스의 전체 이름 이거나, <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /><see langword="true" /> 형식이 중첩 되거나 루트 네임 스페이스에서 정의 된 경우 속성이 인 핸들입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.ResolutionScope">
      <summary>지정된 <see cref="P:System.Reflection.Metadata.TypeReference.Namespace" /> 및 <see cref="P:System.Reflection.Metadata.TypeReference.Name" />에 의해 대상 형식이 정의되고 고유하게 식별되는 결정 범위를 가져옵니다.</summary>
      <returns>대상 형식이 고유 하 게 정의 되는 해상도 범위입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandle" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Reflection.Metadata.TypeReferenceHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Equality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Inequality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection">
      <summary>
        <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 인스턴스 컬렉션을 포함합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeReferenceHandle}#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
      <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Count">
      <summary>컬렉션의 요소 수를 가져옵니다.</summary>
      <returns>컬렉션에 있는 요소의 수입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.MoveNext">
      <summary>열거자를 컬렉션의 다음 요소로 이동합니다.</summary>
      <returns>열거자가 다음 요소로 이동한 경우 <see langword="true" />이(가) 반환되고, 컬렉션의 끝을 지난 경우 <see langword="false" />이(가) 반환됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>컬렉션의 첫 번째 요소 앞의 초기 위치에 열거자를 설정합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>관리되지 않는 리소스의 확보, 해제 또는 다시 설정과 관련된 애플리케이션 정의 작업을 수행합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>컬렉션에서 열거자의 현재 위치에 있는 요소를 가져옵니다.</summary>
      <returns>컬렉션에서 열거자의 현재 위치에 있는 요소입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeSpecification" />
    <member name="M:System.Reflection.Metadata.TypeSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.TypeSpecification.Signature" />
    <member name="T:System.Reflection.Metadata.TypeSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Reflection.Metadata.TypeSpecificationHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Equality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Inequality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeSpecificationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.UserStringHandle">
      <summary>사용자 문자열 힙에 대한 핸들을 나타냅니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Reflection.Metadata.UserStringHandle)">
      <summary>현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.</summary>
      <param name="other">이 개체와 비교할 개체입니다.</param>
      <returns>현재 개체가 <paramref name="other" /> 매개 변수와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Equality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.UserStringHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Implicit(System.Reflection.Metadata.UserStringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Inequality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.UserStringHandle.IsNil" />
    <member name="T:System.Reflection.MethodImportAttributes" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionCDecl" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionFastCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionStdCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionThisCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionWinApi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAnsi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAuto" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetUnicode" />
    <member name="F:System.Reflection.MethodImportAttributes.ExactSpelling" />
    <member name="F:System.Reflection.MethodImportAttributes.None" />
    <member name="F:System.Reflection.MethodImportAttributes.SetLastError" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharMask" />
    <member name="T:System.Reflection.MethodSemanticsAttributes" />
    <member name="F:System.Reflection.MethodSemanticsAttributes.Adder">
      <summary>
        <para>이벤트에 대한 처리기를 추가하는 데 사용됩니다. Ecma 335 CLI 사양에서 <see langword="AddOn" /> 플래그에 해당합니다.</para>
        <para>
          <see langword="add_" /> 접두사를 사용하여 CLS 규격 adder의 이름을 지정합니다.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Getter">
      <summary>
        <para>속성의 값을 읽습니다.</para>
        <para>get_ 접두사를 사용하여 CLS 규격 getter의 이름을 지정합니다.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Other">
      <summary>속성(getter 또는 setter 아님) 또는 이벤트(adder, remover 또는 raiser 아님)에 대한 기타 메서드입니다.</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Raiser">
      <summary>
        <para>이벤트가 발생했음을 나타내는 데 사용됩니다. Ecma 335 CLI 사양에서 <see langword="Fire" /> 플래그에 해당합니다.</para>
        <para>
          <see langword="raise_" /> 접두사를 사용하여 CLS 규격 raiser의 이름을 지정합니다.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Remover">
      <summary>
        <para>이벤트에 대한 처리기를 제거하는 데 사용됩니다. Ecma 335 CLI 사양에서 <see langword="RemoveOn" /> 플래그에 해당합니다.</para>
        <para>
          <see langword="remove_" /> 접두사를 사용하여 CLS 규격 remover의 이름을 지정합니다.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Setter">
      <summary>
        <para>속성 값을 수정하는 데 사용됩니다.</para>
        <para>
          <see langword="set_" /> 접두사를 사용하여 CLS 규격 setter의 이름을 지정합니다.</para>
      </summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.AggressiveWSTrim" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Bit32Machine" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedHi" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedLo" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.DebugStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Dll" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.ExecutableImage" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LargeAddressAware" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LineNumsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LocalSymsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.NetRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RelocsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RemovableRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.System" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.UpSystemOnly" />
    <member name="T:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData">
      <summary>PDB(프로그램 디버그 데이터베이스) 파일에 대한 정보를 제공합니다.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Age">
      <summary>PDB의 반복입니다. 첫 번째 반복은 1입니다. 반복은 PDB 콘텐츠가 확대될 때마다 증가합니다.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Guid">
      <summary>연결된 PDB의 GUID(Globally Unique Identifier)입니다.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Path">
      <summary>PE/COFF 파일에 대한 디버그 정보를 포함하는 .pdb 파일의 경로입니다.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CoffHeader">
      <summary>COFF 파일의 헤더를 나타냅니다.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Characteristics">
      <summary>파일의 특성을 나타내는 플래그를 가져옵니다.</summary>
      <returns>파일의 특성을 나타내는 플래그입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Machine">
      <summary>대상 머신의 형식을 가져옵니다.</summary>
      <returns>대상 컴퓨터의 유형입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSections">
      <summary>섹션 수를 가져옵니다. 헤더 바로 다음에 오는 섹션 테이블의 크기를 나타냅니다.</summary>
      <returns>섹션 수입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSymbols">
      <summary>기호 테이블의 항목 수를 가져옵니다. 이 데이터를 사용하여 기호 테이블 바로 뒤에 오는 문자열 테이블을 찾을 수 있습니다. PE 이미지의 경우 이 값이 0이어야 합니다.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.PointerToSymbolTable">
      <summary>COFF 기호 테이블에 대한 파일 포인터를 가져옵니다.</summary>
      <returns>COFF 기호 테이블에 대 한 파일 포인터 이거나, COFF 기호 테이블이 없는 경우 0입니다. PE 이미지의 경우 이 값이 0이어야 합니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.SizeOfOptionalHeader">
      <summary>실행 파일에는 필요하지만 개체 파일에는 필요하지 않은 선택적 헤더의 크기를 가져옵니다. 개체 파일의 경우 이 값이 0이어야 합니다.</summary>
      <returns>선택적 헤더의 크기입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.TimeDateStamp">
      <summary>파일이 만들어진 시기를 나타내는 값을 가져옵니다.</summary>
      <returns>32 이후의 시간 (초) (00:00 1970 1 월 1 일)의 하위 비트 (파일 생성 시기를 나타냄)입니다.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CorFlags">
      <summary>COR20Flags</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILLibrary" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILOnly" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.NativeEntryPoint" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Prefers32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Requires32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.StrongNameSigned" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.TrackDebugData" />
    <member name="T:System.Reflection.PortableExecutable.CorHeader" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.CodeManagerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.EntryPointTokenOrRelativeVirtualAddress" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ExportAddressTableJumpsDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.Flags" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MajorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ManagedNativeHeaderDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MetadataDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MinorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ResourcesDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.StrongNameSignatureDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.VtableFixupsDirectory" />
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" />
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.#ctor">
      <summary>
        <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddCodeViewEntry(System.String,System.Reflection.Metadata.BlobContentId,System.UInt16)">
      <summary>CodeView 항목을 추가합니다.</summary>
      <param name="pdbPath">PDB의 경로입니다. 비워 둘 수 없습니다.</param>
      <param name="pdbContentId">PDB 콘텐츠의 고유 ID입니다.</param>
      <param name="portablePdbVersion">이식 가능한 PDB 형식의 버전(예: 1.0의 경우 0x0100) 또는 0(PDB를 이식할 수 없는 경우)입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="pdbPath" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="pdbPath" />는 NUL 문자를 포함합니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="portablePdbVersion" />이 0x0100보다 작습니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEmbeddedPortablePdbEntry(System.Reflection.Metadata.BlobBuilder,System.UInt16)">
      <summary>Embedded Portable PDB 항목을 추가합니다.</summary>
      <param name="debugMetadata">이식 가능한 PDB 메타데이터 작성기입니다.</param>
      <param name="portablePdbVersion">이식 가능한 PDB 형식의 버전입니다(예: 1.0의 경우 0x0100).</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="debugMetadata" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="portablePdbVersion" />이 0x0100보다 작습니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32)">
      <summary>지정된 형식의 항목을 추가합니다.</summary>
      <param name="type">항목 유형입니다.</param>
      <param name="version">항목 버전입니다.</param>
      <param name="stamp">항목 스탬프입니다.</param>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry``1(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32,``0,System.Action{System.Reflection.Metadata.BlobBuilder,``0})">
      <summary>지정된 형식의 항목을 추가하고 해당 데이터를 직렬화합니다.</summary>
      <param name="type">항목 유형입니다.</param>
      <param name="version">항목 버전입니다.</param>
      <param name="stamp">항목 스탬프입니다.</param>
      <param name="data">
        <paramref name="dataSerializer" />로 전달할 데이터입니다.</param>
      <param name="dataSerializer">데이터를 <see cref="T:System.Reflection.Metadata.BlobBuilder" />에 직렬화할 직렬 변환기입니다.</param>
      <typeparam name="TData">에 전달 되는 데이터의 형식 <paramref name="dataSerializer" /> 입니다.</typeparam>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddPdbChecksumEntry(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>PDB 체크섬 항목을 추가합니다.</summary>
      <param name="algorithmName">해시 알고리즘 이름입니다(예: "SHA256").</param>
      <param name="checksum">체크섬입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="algorithmName" /> 또는 <paramref name="checksum" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="algorithmName" /> 또는 <paramref name="checksum" /> 비어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddReproducibleEntry">
      <summary>재현 가능한 항목을 추가합니다.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntry">
      <summary>디버그 정보 블록의 위치, 크기 및 형식을 식별합니다.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryEntry.#ctor(System.UInt32,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.Int32,System.Int32,System.Int32)">
      <summary>
        <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryEntry" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
      <param name="stamp" />
      <param name="majorVersion" />
      <param name="minorVersion" />
      <param name="type" />
      <param name="dataSize" />
      <param name="dataRelativeVirtualAddress" />
      <param name="dataPointer" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataPointer">
      <summary>디버그 데이터에 대한 파일 포인터를 가져옵니다.</summary>
      <returns>디버그 데이터에 대 한 파일 포인터입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataRelativeVirtualAddress">
      <summary>이미지 기준에 따라 로드되는 디버그 데이터의 주소를 가져옵니다.</summary>
      <returns>이미지 베이스를 기준으로 하는 디버그 데이터의 주소입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataSize">
      <summary>디버그 데이터의 크기(디버그 디렉터리 제외)를 가져옵니다.</summary>
      <returns>디버그 디렉터리를 제외 하 고 디버그 데이터의 크기입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.IsPortableCodeView">
      <summary>항목이 이식 가능한 PDB를 가리키는 <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" /> 항목인지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns>
        <see langword="true" /> 항목이 <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" /> 이식 가능한 PDB를 가리키는 항목이 면이 고, 그렇지 않으면 <see langword="false" /> 입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MajorVersion">
      <summary>디버그 데이터 형식의 주 버전 번호를 가져옵니다.</summary>
      <returns>디버그 데이터 형식의 주 버전 번호입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MinorVersion">
      <summary>디버그 데이터 형식의 부 버전 번호를 가져옵니다.</summary>
      <returns>디버그 데이터 형식의 부 버전 번호입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Stamp">
      <summary>PE/COFF 파일이 결정적이지 않으면 디버그 데이터를 만든 날짜 및 시간을 가져오고, 그렇지 않으면 콘텐츠의 해시를 기반으로 값을 가져옵니다.</summary>
      <returns>명확 하지 않은 PE/COFF 파일의 경우 디버그 데이터를 만든 시간 및 날짜입니다. 그렇지 않으면 콘텐츠의 해시를 기반으로 하는 값입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Type">
      <summary>디버깅 정보의 형식을 가져옵니다.</summary>
      <returns>디버깅 정보의 형식입니다.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntryType">
      <summary>
        <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryEntry" /> 디버깅 정보의 형식을 설명하는 열거형입니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView">
      <summary>연결된 PDB 파일 설명입니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Coff">
      <summary>COFF 디버그 정보(줄 번호, 기호 테이블, 문자열 테이블)입니다. 파일 헤더의 필드에서도 이 형식의 디버그 정보를 가리킵니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb">
      <summary>
        <para>항목은 Embedded Portable PDB를 포함하는 blob을 가리킵니다. Embedded Portable PDB blob의 형식은 다음과 같습니다.</para>
        <para>- blob ::= uncompressed-size data</para>
        <para>- 데이터는 blob의 나머지 부분으로 확장되며 Deflate로 압축된 이식 가능한 PDB를 포함합니다.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.PdbChecksum">
      <summary>항목은 PE/COFF 파일을 빌드하는 데 사용된 기호 파일 콘텐츠의 암호화 해시를 저장합니다. 해시를 사용하여 지정된 PDB 파일이 PE/COFF 파일을 사용하여 빌드되고 어떤 식으로도 변경되지 않았는지 확인할 수 있습니다. PE/COFF 파일(예: 프라이빗 및 퍼블릭 기호)을 빌드하는 동안 여러 PDB가 생성된 경우 두 개 이상의 항목이 존재할 수 있습니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Reproducible">
      <summary>이 항목이 있으면 결정적 PE/COFF 파일을 나타냅니다. 자세한 내용은 설명 부분을 참조하세요.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Unknown">
      <summary>모든 도구에서 무시해야 하는 알 수 없는 값입니다.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DirectoryEntry" />
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.RelativeVirtualAddress" />
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.Size" />
    <member name="M:System.Reflection.PortableExecutable.DirectoryEntry.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" />
      <param name="size" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.DllCharacteristics">
      <summary>동적 연결 라이브러리의 특징을 설명합니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.AppContainer">
      <summary>이미지는 AppContainer 내에서 실행되어야 합니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.DynamicBase">
      <summary>DLL을 다시 배치할 수 있습니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.HighEntropyVirtualAddressSpace">
      <summary>이미지는 높은 엔트로피 64비트 가상 주소 공간을 처리할 수 있습니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoBind">
      <summary>이 이미지를 바인딩하지 않습니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoIsolation">
      <summary>이미지는 격리를 이해하지만 원하지 않습니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoSeh">
      <summary>이미지에서는 SEH를 사용하지 않습니다. 이 이미지에는 SE 처리기가 없습니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NxCompatible">
      <summary>이미지가 NX와 호환됩니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessInit">
      <summary>예약되어 있습니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessTerm">
      <summary>예약되어 있습니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.TerminalServerAware">
      <summary>이미지가 터미널 서버를 인식합니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadInit">
      <summary>예약되어 있습니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadTerm">
      <summary>예약되어 있습니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.WdmDriver">
      <summary>드라이버는 WDM 모델을 사용합니다.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Machine">
      <summary>대상 머신의 CPU 아키텍처를 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha">
      <summary>Alpha.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha64">
      <summary>ALPHA64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.AM33">
      <summary>Matsushita AM33.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Amd64">
      <summary>AMD64(K8).</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm">
      <summary>ARM little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm64">
      <summary>ARM64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.ArmThumb2">
      <summary>ARM Thumb-2 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Ebc">
      <summary>EFI 바이트 코드.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.I386">
      <summary>Intel 386.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.IA64">
      <summary>Intel 64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.M32R">
      <summary>M32R little-endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MIPS16">
      <summary>MIPS.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu">
      <summary>FPU를 포함하는 MIPS.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu16">
      <summary>FPU를 포함하는 MIPS16.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPC">
      <summary>IBM PowerPC little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPCFP">
      <summary>PowerPCFP.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3">
      <summary>Hitachi SH3 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3Dsp">
      <summary>Hitachi SH3 DSP.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3E">
      <summary>Hitachi SH3 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH4">
      <summary>Hitachi SH4 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH5">
      <summary>Hitachi SH5.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Thumb">
      <summary>Thumb.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Tricore">
      <summary>Infineon.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Unknown">
      <summary>대상 CPU를 알 수 없거나 지정하지 않았습니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.WceMipsV2">
      <summary>MIPS little-endian WCE v2.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ManagedPEBuilder" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.ManagedResourcesDataAlignment" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.MappedFieldDataAlignment" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Reflection.Metadata.Ecma335.MetadataRootBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.ResourceSectionBuilder,System.Reflection.PortableExecutable.DebugDirectoryBuilder,System.Int32,System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.PortableExecutable.CorFlags,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <param name="header" />
      <param name="metadataRootBuilder" />
      <param name="ilStream" />
      <param name="mappedFieldData" />
      <param name="managedResources" />
      <param name="nativeResources" />
      <param name="debugDirectoryBuilder" />
      <param name="strongNameSignatureSize" />
      <param name="entryPoint" />
      <param name="flags" />
      <param name="deterministicIdProvider" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.GetDirectories" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" />
      <param name="location" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.Sign(System.Reflection.Metadata.BlobBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Byte[]})">
      <param name="peImage" />
      <param name="signatureProvider" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData">
      <summary>PDB 체크섬 디버그 디렉터리 항목을 나타냅니다.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.AlgorithmName">
      <summary>체크섬을 계산하는 데 사용되는 암호화 해시 알고리즘의 이름입니다.</summary>
      <returns>체크섬을 계산 하는 데 사용 되는 암호화 해시 알고리즘의 이름을 나타내는 문자열입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.Checksum">
      <summary>PDB 콘텐츠의 체크섬입니다.</summary>
      <returns>PDB 콘텐츠의 체크섬을 나타내는 변경할 수 없는 바이트 배열입니다.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEBuilder" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <param name="header" />
      <param name="deterministicIdProvider" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetDirectories" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetSections" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" />
      <param name="location" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.Header" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IdProvider" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IsDeterministic" />
    <member name="T:System.Reflection.PortableExecutable.PEBuilder.Section" />
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Name" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Section.#ctor(System.String,System.Reflection.PortableExecutable.SectionCharacteristics)">
      <param name="name" />
      <param name="characteristics" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder">
      <summary>PE 디렉터리를 빌드합니다.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEDirectoriesBuilder.#ctor">
      <summary>
        <see cref="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder" /> 클래스의 인스턴스를 초기화합니다.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.AddressOfEntryPoint">
      <summary>PE 파일이 메모리로 로드될 때 이미지 기준에 따라 진입점의 주소입니다.</summary>
      <returns>프로그램 이미지의 경우 시작 주소입니다. 장치 드라이버의 경우 초기화 함수의 주소입니다. Dll에 대 한 진입점은 선택적 요소입니다. 진입점이 없으면이 필드는 0 이어야 합니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BaseRelocationTable">
      <summary>기본 재배치 테이블 이미지 디렉터리 항목입니다.</summary>
      <returns>디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BoundImportTable">
      <summary>바인딩된 가져오기 이미지 디렉터리 항목입니다.</summary>
      <returns>디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CopyrightTable">
      <summary>저작권/아키텍처 이미지 디렉터리 항목입니다.</summary>
      <returns>디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CorHeaderTable">
      <summary>COM descriptortable 이미지 디렉터리 항목입니다.</summary>
      <returns>디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DebugTable">
      <summary>디버그 테이블 이미지 디렉터리 항목입니다.</summary>
      <returns>디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DelayImportTable">
      <summary>지연 가져오기 테이블 이미지 디렉터리 항목입니다.</summary>
      <returns>디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExceptionTable">
      <summary>예외 테이블 이미지 디렉터리 항목입니다.</summary>
      <returns>디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExportTable">
      <summary>내보내기 테이블 이미지 디렉터리 항목입니다.</summary>
      <returns>디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.GlobalPointerTable">
      <summary>전역 포인터 테이블 이미지 디렉터리 항목입니다.</summary>
      <returns>디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportAddressTable">
      <summary>IAT(가져오기 주소 테이블) 이미지 디렉터리 항목입니다.</summary>
      <returns>디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportTable">
      <summary>가져오기 테이블 이미지 디렉터리 항목입니다.</summary>
      <returns>디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.LoadConfigTable">
      <summary>로드 구성 테이블 이미지 디렉터리 항목입니다.</summary>
      <returns>디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ResourceTable">
      <summary>리소스 테이블 이미지 디렉터리 항목입니다.</summary>
      <returns>디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ThreadLocalStorageTable">
      <summary>TLS(스레드 로컬 스토리지) 테이블 이미지 디렉터리 항목입니다.</summary>
      <returns>디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeader" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.AddressOfEntryPoint">
      <summary>PE 파일이 메모리로 로드될 때 이미지 기준에 따라 진입점의 주소를 가져옵니다.</summary>
      <returns>이미지 밑을 기준으로 하는 진입점의 주소입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfCode">
      <summary>이미지가 메모리에 로드될 때 이미지 기준에 따라 코드 시작 섹션의 주소를 가져옵니다.</summary>
      <returns>이미지 베이스를 기준으로 하는 코드의 시작 부분에 대 한 주소입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfData">
      <summary>이미지가 메모리에 로드될 때 이미지 기준에 따라 데이터 시작 섹션의 주소를 가져옵니다.</summary>
      <returns>이미지 베이스를 기준으로 하는 데이터 시작 부분의 주소입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseRelocationTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BoundImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CertificateTableDirectory">
      <summary>특성 인증서 테이블을 가리키는 인증서 테이블 항목을 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CheckSum">
      <summary>이미지 파일 체크섬을 가져옵니다.</summary>
      <returns>이미지 파일 체크섬입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CopyrightTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CorHeaderTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DebugTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DelayImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DllCharacteristics" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExceptionTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment">
      <summary>이미지 파일의 섹션 원시 데이터를 정렬하는 데 사용되는 맞춤 요소(바이트)를 가져옵니다.</summary>
      <returns>512에서 64K 사이의 2 제곱 (포함)입니다. 기본값은 512입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.GlobalPointerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImageBase">
      <summary>이미지를 메모리로 로드할 때 이미지의 첫 번째 바이트의 기본 주소를 가져옵니다.</summary>
      <returns>64K의 배수가 되는 기본 설정 주소입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportAddressTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.LoadConfigTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Magic">
      <summary>이미지 파일의 형식을 식별하는 값을 가져옵니다.</summary>
      <returns>이미지 파일의 형식입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorImageVersion">
      <summary>이미지의 주 버전 번호를 가져옵니다.</summary>
      <returns>브라우저의 주 버전 번호입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorLinkerVersion">
      <summary>링커 주 버전 번호를 가져옵니다.</summary>
      <returns>링커 주 버전 번호입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorOperatingSystemVersion">
      <summary>필수 운영 체제의 주 버전 번호를 가져옵니다.</summary>
      <returns>필수 운영 체제의 주 버전 번호입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorSubsystemVersion">
      <summary>하위 시스템의 주 버전 번호를 가져옵니다.</summary>
      <returns>하위 시스템의 주 버전 번호입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorImageVersion">
      <summary>이미지의 부 버전 번호를 가져옵니다.</summary>
      <returns>브라우저의 부 버전 번호입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorLinkerVersion">
      <summary>링커 부 버전 번호를 가져옵니다.</summary>
      <returns>링커 부 버전 번호입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorOperatingSystemVersion">
      <summary>필수 운영 체제의 부 버전 번호를 가져옵니다.</summary>
      <returns>필수 운영 체제의 부 버전 번호입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorSubsystemVersion">
      <summary>하위 시스템의 부 버전 번호를 가져옵니다.</summary>
      <returns>하위 시스템의 부 버전 번호입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.NumberOfRvaAndSizes">
      <summary>
        <see cref="T:System.Reflection.PortableExecutable.PEHeader" />의 나머지 부분에 있는 데이터 디렉터리 항목 수를 가져옵니다. 각 항목은 위치와 크기를 설명합니다.</summary>
      <returns>의 나머지 부분에 있는 데이터 디렉터리 항목 수입니다 <see cref="T:System.Reflection.PortableExecutable.PEHeader" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ResourceTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment">
      <summary>메모리에 로드되는 섹션의 맞춤(바이트)을 가져옵니다.</summary>
      <returns>보다 크거나 같은 숫자 <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment" /> 입니다. 기본값은 아키텍처의 페이지 크기입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfCode">
      <summary>코드(텍스트) 섹션의 크기 또는 모든 코드 섹션의 합계(여러 섹션이 있는 경우)를 가져옵니다.</summary>
      <returns>여러 섹션이 있는 경우 코드 (텍스트) 섹션의 크기 또는 모든 코드 섹션의 합계입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeaders">
      <summary>FileAlignment의 배수로 반올림된 MS DOS 스텁, PE 헤더 및 섹션 헤더의 결합된 크기를 가져옵니다.</summary>
      <returns>FileAlignment의 배수로 반올림 된 MS DOS 스텁, PE 헤더 및 섹션 헤더의 결합 된 크기입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit">
      <summary>커밋할 로컬 힙 공간의 크기를 가져옵니다.</summary>
      <returns>커밋할 로컬 힙 공간의 크기입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapReserve">
      <summary>예약할 로컬 힙 공간의 크기를 가져옵니다. <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit" />만 커밋되고, 나머지는 예약 크기에 도달할 때까지 한 번에 한 페이지씩 사용할 수 있습니다.</summary>
      <returns>예약할 로컬 힙 공간의 크기입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfImage">
      <summary>이미지가 메모리에 로드될 때 모든 헤더를 포함한 이미지의 크기(바이트)를 가져옵니다.</summary>
      <returns>이미지의 크기 (바이트)입니다 .이 크기는의 배수입니다 <see cref="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfInitializedData">
      <summary>초기화된 데이터 섹션의 크기 또는 모든 초기화된 데이터 섹션의 합계(여러 데이터 섹션이 있는 경우)를 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit">
      <summary>커밋할 스택의 크기를 가져옵니다.</summary>
      <returns>커밋할 스택의 크기입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackReserve">
      <summary>예약할 스택의 크기를 가져옵니다. <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit" />만 커밋되고, 나머지는 예약 크기에 도달할 때까지 한 번에 한 페이지씩 사용할 수 있습니다.</summary>
      <returns>예약할 스택의 크기입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfUninitializedData">
      <summary>초기화되지 않은 데이터 섹션(BSS)의 크기 또는 모든 초기화된 데이터 섹션의 합계(여러 BSS 섹션이 있는 경우)를 가져옵니다.</summary>
      <returns>초기화 되지 않은 데이터 섹션의 크기 (BSS) 또는 이러한 모든 섹션의 합계입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Subsystem">
      <summary>이 이미지를 실행하는 데 필요한 하위 시스템의 이름을 가져옵니다.</summary>
      <returns>이 이미지를 실행 하는 데 필요한 하위 시스템의 이름입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ThreadLocalStorageTableDirectory" />
    <member name="T:System.Reflection.PortableExecutable.PEHeaderBuilder">
      <summary>PE(이식 가능) 파일에 대한 헤더를 정의합니다.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.#ctor(System.Reflection.PortableExecutable.Machine,System.Int32,System.Int32,System.UInt64,System.Byte,System.Byte,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.Subsystem,System.Reflection.PortableExecutable.DllCharacteristics,System.Reflection.PortableExecutable.Characteristics,System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
      <summary>
        <see cref="T:System.Reflection.PortableExecutable.PEHeader" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="machine">대상 머신의 CPU 아키텍처입니다.</param>
      <param name="sectionAlignment">메모리에 로드되는 섹션의 맞춤(바이트)입니다. <paramref name="fileAlignment" />보다 크거나 같아야 합니다. 기본값은 아키텍처의 페이지 크기입니다.</param>
      <param name="fileAlignment">이미지 파일의 섹션 원시 데이터를 정렬하는 데 사용되는 맞춤 요소(바이트)입니다. 값은 512~64K(포함) 사이의 2의 거듭제곱입니다. 기본값은 512입니다. <paramref name="sectionAlignment" />가 아키텍처의 페이지 크기보다 작은 경우 <paramref name="fileAlignment" />가 <paramref name="sectionAlignment" />와 일치해야 합니다.</param>
      <param name="imageBase">메모리로 로드되는 이미지의 첫 번째 바이트의 기본 주소이며, 64K의 배수입니다.</param>
      <param name="majorLinkerVersion">링커 주 버전 번호입니다.</param>
      <param name="minorLinkerVersion">링커 부 버전 번호입니다.</param>
      <param name="majorOperatingSystemVersion">필수 운영 체제의 주 버전 번호입니다.</param>
      <param name="minorOperatingSystemVersion">필수 운영 체제의 부 버전 번호입니다.</param>
      <param name="majorImageVersion">브라우저의 주 버전 번호입니다.</param>
      <param name="minorImageVersion">브라우저의 부 버전 번호입니다.</param>
      <param name="majorSubsystemVersion">하위 시스템의 주 버전 번호입니다.</param>
      <param name="minorSubsystemVersion">하위 시스템의 부 버전 번호입니다.</param>
      <param name="subsystem">이미지를 실행하는 데 필요한 하위 시스템입니다.</param>
      <param name="dllCharacteristics">동적 연결 라이브러리의 특징을 설명하는 개체입니다.</param>
      <param name="imageCharacteristics">이미지의 특징을 설명하는 개체입니다.</param>
      <param name="sizeOfStackReserve">예약할 스택의 크기입니다. <paramref name="sizeOfStackCommit" />만 커밋되고, 나머지는 예약 크기에 도달할 때까지 한 번에 한 페이지씩 사용할 수 있습니다.</param>
      <param name="sizeOfStackCommit">커밋할 스택의 크기입니다.</param>
      <param name="sizeOfHeapReserve">예약할 로컬 힙 공간의 크기입니다. <paramref name="sizeOfHeapCommit" />만 커밋되고, 나머지는 예약 크기에 도달할 때까지 한 번에 한 페이지씩 사용할 수 있습니다.</param>
      <param name="sizeOfHeapCommit">커밋할 로컬 힙 공간의 크기입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="fileAlignment" />는 512~64K 사이의 2의 거듭제곱이 아닙니다.
또는

<paramref name="sectionAlignment" />는 2의 거듭제곱이 아닙니다.

또는

<paramref name="sectionAlignment" />가 <paramref name="fileAlignment" />보다 작은 경우</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateExecutableHeader">
      <summary>실행 파일 헤더를 만듭니다.</summary>
      <returns>실행 파일 헤더를 나타내는 <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" /> 인스턴스입니다.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateLibraryHeader">
      <summary>라이브러리 헤더를 만듭니다.</summary>
      <returns>라이브러리 헤더를 나타내는 <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" /> 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.DllCharacteristics">
      <summary>동적 링커 라이브러리 특징을 반환합니다.</summary>
      <returns>동적 링커 라이브러리 특징을 설명 하는 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.FileAlignment">
      <summary>이미지 파일의 섹션 원시 데이터를 정렬하는 데 사용되는 맞춤 요소(바이트)입니다. 값은 512~64K(포함) 사이의 2의 거듭제곱입니다. 기본값은 512입니다. 섹션 맞춤이 아키텍처의 페이지 크기보다 작은 경우 파일 맞춤은 섹션 맞춤과 일치해야 합니다.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageBase">
      <summary>메모리로 로드되는 이미지의 첫 번째 바이트의 기본 주소이며, 64K의 배수입니다.</summary>
      <returns>메모리로 로드할 때 이미지 첫 번째 바이트의 기본 설정 주소를 나타내는 숫자입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageCharacteristics">
      <summary>이미지 특징을 반환합니다.</summary>
      <returns>이미지 특징을 나타내는 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Machine">
      <summary>대상 머신의 CPU 아키텍처입니다.</summary>
      <returns>다른 CPU 아키텍처를 나타내는 열거형 값 중 하나입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorImageVersion">
      <summary>브라우저의 주 버전 번호입니다.</summary>
      <returns>이미지의 주 버전 번호를 나타내는의 크기 (숫자)입니다 <see cref="T:System.UInt16" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorLinkerVersion">
      <summary>링커 주 버전 번호입니다.</summary>
      <returns>링커 주 버전 번호를 나타내는의 크기 (숫자)입니다 <see cref="T:System.Byte" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorOperatingSystemVersion">
      <summary>필수 운영 체제의 주 버전 번호입니다.</summary>
      <returns>
        <see cref="T:System.UInt16" />필요한 운영 체제의 주 버전 번호를 나타내는의 크기입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorSubsystemVersion">
      <summary>하위 시스템의 주 버전 번호입니다.</summary>
      <returns>
        <see cref="T:System.UInt16" />하위 시스템의 주 버전 번호를 나타내는의 크기 (숫자)입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorImageVersion">
      <summary>브라우저의 부 버전 번호입니다.</summary>
      <returns>이미지의 부 버전 번호를 나타내는의 크기 (숫자)입니다 <see cref="T:System.UInt16" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorLinkerVersion">
      <summary>링커 부 버전 번호입니다.</summary>
      <returns>링커 부 버전 번호를 나타내는의 크기 (숫자)입니다 <see cref="T:System.Byte" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorOperatingSystemVersion">
      <summary>필수 운영 체제의 부 버전 번호입니다.</summary>
      <returns>
        <see cref="T:System.UInt16" />필요한 운영 체제의 부 버전 번호를 나타내는의 크기입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorSubsystemVersion">
      <summary>하위 시스템의 부 버전 번호입니다.</summary>
      <returns>
        <see cref="T:System.UInt16" />하위 시스템의 부 버전 번호를 나타내는의 크기 (숫자)입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SectionAlignment">
      <summary>메모리에 로드되는 섹션의 맞춤(바이트)입니다.</summary>
      <returns>메모리에 로드 되는 섹션의 맞춤 (바이트)을 나타내는 숫자입니다. 파일 맞춤 보다 크거나 같아야 합니다. 기본값은 아키텍처의 페이지 크기입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit">
      <summary>커밋할 로컬 힙 공간의 크기입니다.</summary>
      <returns>커밋할 로컬 힙 공간의 크기를 나타내는 숫자입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapReserve">
      <summary>예약할 로컬 힙 공간의 크기입니다. <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit" />만 커밋되고, 나머지는 예약 크기에 도달할 때까지 한 번에 한 페이지씩 사용할 수 있습니다.</summary>
      <returns>예약할 로컬 힙 공간의 크기를 나타내는 숫자입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit">
      <summary>커밋할 스택의 크기입니다.</summary>
      <returns>커밋할 스택의 크기를 나타내는 숫자입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackReserve">
      <summary>예약할 스택의 크기입니다. <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit" />만 커밋되고, 나머지는 예약 크기에 도달할 때까지 한 번에 한 페이지씩 사용할 수 있습니다.</summary>
      <returns>예약할 스택의 크기를 나타내는 숫자입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Subsystem">
      <summary>이 이미지를 실행하는 데 필요한 하위 시스템입니다.</summary>
      <returns>
        <see cref="T:System.Reflection.PortableExecutable.Subsystem" /> 인스턴스입니다.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeaders">
      <summary>스트림에서 PE(이식 가능한 실행 파일) 및 COFF(공용 개체 파일 형식) 헤더를 읽는 형식을 정의합니다.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream)">
      <summary>지정된 스트림의 현재 위치에서 PE 헤더를 읽는 <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> 클래스의 새 인스턴스를 인스턴스화합니다.</summary>
      <param name="peStream">스트림의 현재 위치에서 시작하여 스트림의 끝에서 끝나는 PE 이미지를 포함하는 스트림입니다.</param>
      <exception cref="T:System.BadImageFormatException">스트림에서 읽은 데이터의 형식이 잘못되었습니다.</exception>
      <exception cref="T:System.IO.IOException">스트림에서 읽는 중 오류가 발생했습니다.</exception>
      <exception cref="T:System.ArgumentException">스트림이 검색 작업을 지원하지 않습니다.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" />이(가) <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32)">
      <summary>지정된 크기의 PE 이미지를 나타내는 스트림에서 PE 헤더를 읽는 <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> 클래스의 새 인스턴스를 인스턴스화합니다.</summary>
      <param name="peStream">현재 위치에서 시작하여 지정된 크기의 PE 이미지를 포함하는 스트림입니다.</param>
      <param name="size">PE 이미지의 크기입니다.</param>
      <exception cref="T:System.BadImageFormatException">스트림에서 읽은 데이터의 형식이 잘못되었습니다.</exception>
      <exception cref="T:System.IO.IOException">스트림에서 읽는 중 오류가 발생했습니다.</exception>
      <exception cref="T:System.ArgumentException">스트림이 검색 작업을 지원하지 않습니다.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" />가 음수이거나 스트림의 끝을 넘어 확장됩니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
      <summary>지정된 크기의 PE 이미지를 나타내고 PE 이미지를 메모리로 로드했는지 여부를 표시하는 스트림에서 PE 헤더를 읽는 <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> 클래스의 새 인스턴스를 인스턴스화합니다.</summary>
      <param name="peStream">현재 위치에서 시작하여 지정된 크기의 PE 이미지를 포함하는 스트림입니다.</param>
      <param name="size">PE 이미지의 크기입니다.</param>
      <param name="isLoadedImage">OS 로더에서 PE 이미지를 메모리로 로드했으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
      <exception cref="T:System.BadImageFormatException">스트림에서 읽은 데이터의 형식이 잘못되었습니다.</exception>
      <exception cref="T:System.IO.IOException">스트림에서 읽는 중 오류가 발생했습니다.</exception>
      <exception cref="T:System.ArgumentException">스트림이 검색 작업을 지원하지 않습니다.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" />가 음수이거나 스트림의 끝을 넘어 확장됩니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.GetContainingSectionIndex(System.Int32)">
      <summary>PE 이미지 섹션에서 지정된 상대 가상 주소를 포함하는 섹션을 검색합니다.</summary>
      <param name="relativeVirtualAddress">검색할 상대 가상 주소입니다.</param>
      <returns>
        <paramref name="relativeVirtualAddress" />를 포함하는 섹션의 인덱스이거나 -1(검색에 실패한 경우)입니다.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.TryGetDirectoryOffset(System.Reflection.PortableExecutable.DirectoryEntry,System.Int32@)">
      <summary>이미지 시작 부분에서 지정된 디렉터리 데이터까지 오프셋(바이트)을 가져옵니다.</summary>
      <param name="directory">PE 디렉터리 항목입니다.</param>
      <param name="offset">메서드가 반환될 때 이미지 시작 부분에서 지정된 디렉터리 데이터까지 오프셋을 포함합니다.</param>
      <returns>디렉터리 데이터가 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeader">
      <summary>이미지의 COFF 헤더를 가져옵니다.</summary>
      <returns>이미지의 COFF 헤더입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeaderStartOffset">
      <summary>PE 이미지 시작 부분에서 COFF 헤더 시작 부분까지 바이트 오프셋을 가져옵니다.</summary>
      <returns>PE 이미지의 시작부터 COFF 헤더 시작 까지의 바이트 오프셋입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeader">
      <summary>COR 헤더를 가져옵니다.</summary>
      <returns>COR 헤더 이거나, <see langword="null" /> 이미지에가 없는 경우입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeaderStartOffset">
      <summary>이미지 시작 위치부터 COR 헤더까지 바이트 오프셋을 가져옵니다.</summary>
      <returns>이미지 시작부터 COR 헤더 까지의 바이트 오프셋 이거나, 이미지에 COR 헤더가 없는 경우-1입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsCoffOnly">
      <summary>이미지가 COFF 전용인지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns>
        <see langword="true" /> 이미지가 Coff 전용 이면이 고, 그렇지 않으면입니다. 그렇지 않으면 <see langword="false" /> 입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsConsoleApplication">
      <summary>이미지가 Windows 콘솔 애플리케이션을 나타내는지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns>
        <see langword="true" /> 이미지가 Windows 콘솔 응용 프로그램 이면이 고, 그렇지 않으면 <see langword="false" /> 입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsDll">
      <summary>이미지가 동적 링크 라이브러리를 나타내는지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns>
        <see langword="true" /> 이미지가 DLL 이면이 고, 그렇지 않으면입니다. 그렇지 않으면 <see langword="false" /> 입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsExe">
      <summary>이미지가 실행 파일을 나타내는지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns>
        <see langword="true" /> 이미지가 실행 파일 이면이 고, 그렇지 않으면입니다. 그렇지 않으면 <see langword="false" /> 입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataSize">
      <summary>CLI 메타데이터의 크기를 가져옵니다.</summary>
      <returns>CLI 메타 데이터의 크기 이거나, 이미지가 메타 데이터를 포함 하지 않는 경우 0입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataStartOffset">
      <summary>PE 이미지 시작 부분에서 CLI 메타데이터 시작 부분까지 오프셋(바이트)을 가져옵니다.</summary>
      <returns>PE 이미지의 시작부터 CLI 메타 데이터 시작 까지의 오프셋 (바이트)입니다. 이미지에 메타 데이터가 포함 되어 있지 않은 경우에는-1입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeader">
      <summary>이미지의 PE 헤더를 가져옵니다.</summary>
      <returns>이미지의 PE 헤더 이거나, <see langword="null" /> 이미지가 COFF 전용 이면입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeaderStartOffset">
      <summary>이미지의 시작 부분에서 헤더의 바이트 오프셋을 가져옵니다.</summary>
      <returns>이미지의 시작 부분에 있는 헤더의 바이트 오프셋입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.SectionHeaders">
      <summary>PE 섹션 헤더를 가져옵니다.</summary>
      <returns>PE 섹션 헤더를 포함 하는 배열입니다.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEMagic" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32Plus" />
    <member name="T:System.Reflection.PortableExecutable.PEMemoryBlock" />
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent">
      <summary>전체 블록의 내용을 배열로 읽어 들입니다.</summary>
      <returns>변경할 수 없는 바이트 배열입니다.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent(System.Int32,System.Int32)">
      <summary>일부 블록의 내용을 배열로 읽어 들입니다.</summary>
      <param name="start">블록 내의 시작 위치입니다.</param>
      <param name="length">읽을 바이트 수입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">지정된 범위는 블록 내에 포함되지 않습니다.</exception>
      <returns>변경할 수 없는 바이트 배열입니다.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader">
      <summary>전체 블록에 걸친 blob에 대한 <see cref="T:System.Reflection.Metadata.BlobReader" />를 만듭니다.</summary>
      <returns>전체 블록에 걸친 blob에 대한 판독기입니다.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader(System.Int32,System.Int32)">
      <summary>블록의 일부에 걸친 blob에 대한 <see cref="T:System.Reflection.Metadata.BlobReader" />를 만듭니다.</summary>
      <param name="start">블록 내의 시작 위치입니다.</param>
      <param name="length">블록 부분에 있는 바이트 수입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">지정된 범위는 블록 내에 포함되지 않습니다.</exception>
      <returns>블록의 일부에 걸친 blob에 대한 판독기입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Length">
      <summary>블록의 길이를 가져옵니다.</summary>
      <returns>블록의 길이입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Pointer">
      <summary>블록의 첫 번째 바이트에 대한 포인터를 가져옵니다.</summary>
      <returns>블록의 첫 번째 바이트에 대 한 포인터입니다.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEReader">
      <summary>PE(이식 가능) 파일 형식에 대한 판독기를 제공합니다.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32)">
      <summary>메모리에 저장된 PE 이미지를 통해 이식 가능한 실행 파일 판독기를 만듭니다.</summary>
      <param name="peImage">PE 이미지의 시작에 대한 포인터입니다.</param>
      <param name="size">PE 이미지의 크기입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" />이(가) <see cref="F:System.IntPtr.Zero" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" />가 음수입니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32,System.Boolean)">
      <summary>메모리에 저장된 PE 이미지를 통해 이식 가능한 실행 파일 판독기를 만듭니다. 플래그는 이미지가 메모리에 이미 로드되었는지 여부를 나타냅니다.</summary>
      <param name="peImage">PE 이미지의 시작에 대한 포인터입니다.</param>
      <param name="size">PE 이미지의 크기입니다.</param>
      <param name="isLoadedImage">OS 로더에서 PE 이미지를 메모리로 로드했으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" />이(가) <see cref="F:System.IntPtr.Zero" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" />가 음수입니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>바이트 배열에 저장된 PE 이미지를 통해 이식 가능한 실행 파일 판독기를 만듭니다.</summary>
      <param name="peImage">PE 이미지를 나타내는 변경할 수 없는 바이트 배열입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" />이(가) <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream)">
      <summary>스트림에 저장된 PE 이미지를 통해 이식 가능한 실행 파일 판독기를 만듭니다.</summary>
      <param name="peStream">PE 이미지 스트림입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" />이(가) <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)">
      <summary>스트림에 저장된 PE 이미지를 통해 스트림의 현재 위치에서 시작하여 끝에서 끝나는 이식 가능한 실행 파일 판독기를 만듭니다.</summary>
      <param name="peStream">PE 이미지 스트림입니다.</param>
      <param name="options">스트림에서 PE 이미지의 섹션을 읽는 방법을 지정하는 옵션입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="options" />의 값이 잘못된 경우</exception>
      <exception cref="T:System.IO.IOException">스트림에서 읽는 중 오류가 발생했습니다(데이터를 프리페치하는 경우에만).</exception>
      <exception cref="T:System.BadImageFormatException">
        <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" />가 지정되고 이미지의 PE 헤더가 잘못되었습니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions,System.Int32)">
      <summary>스트림의 현재 위치에서 시작하여 지정된 크기의 PE 이미지를 통해 이식 가능한 실행 파일 판독기를 만듭니다.</summary>
      <param name="peStream">PE 이미지 스트림입니다.</param>
      <param name="options">스트림에서 PE 이미지의 섹션을 읽는 방법을 지정하는 옵션입니다.</param>
      <param name="size">PE 이미지 크기입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" />가 음수이거나 스트림의 끝을 넘어 확장됩니다.</exception>
      <exception cref="T:System.IO.IOException">스트림에서 읽는 중 오류가 발생했습니다(데이터를 프리페치하는 경우에만).</exception>
      <exception cref="T:System.BadImageFormatException">
        <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" />가 지정되고 이미지의 PE 헤더가 잘못되었습니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.Dispose">
      <summary>reader에 의해 할당된 모든 메로리를 삭제합니다.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetEntireImage">
      <summary>전체 PE 이미지를 포함하는 <see cref="T:System.Reflection.PortableExecutable.PEMemoryBlock" /> 개체를 가져옵니다.</summary>
      <exception cref="T:System.InvalidOperationException">전체 PE 이미지를 사용할 수 없습니다.</exception>
      <returns>전체 PE 이미지를 포함하는 메모리 블록입니다.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetMetadata">
      <summary>CLI 메타데이터를 포함하는 PE 섹션을 로드합니다.</summary>
      <exception cref="T:System.InvalidOperationException">PE 이미지에 메타데이터가 포함되어 있지 않습니다(<see cref="P:System.Reflection.PortableExecutable.PEReader.HasMetadata" />가 <see langword="false" /> 반환).</exception>
      <exception cref="T:System.BadImageFormatException">PE 헤더에 잘못된 데이터가 포함되어 있습니다.</exception>
      <exception cref="T:System.IO.IOException">기본 스트림에서 읽는 동안 IO 오류가 발생했습니다.</exception>
      <returns>CLI 메타데이터를 포함하는 메모리 블록입니다.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.Int32)">
      <summary>지정된 상대 가상 주소를 포함하는 PE 섹션을 메모리로 로드하고 해당 주소에서 시작하여 포함된 섹션의 끝에서 끝나는 메모리 블록을 반환합니다.</summary>
      <param name="relativeVirtualAddress">읽을 데이터의 상대 가상 주소입니다.</param>
      <exception cref="T:System.BadImageFormatException">PE 헤더에 잘못된 데이터가 포함되어 있습니다.</exception>
      <exception cref="T:System.IO.IOException">기본 스트림에서 읽는 동안 IO 오류가 발생했습니다.</exception>
      <exception cref="T:System.InvalidOperationException">PE 이미지를 사용할 수 없습니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="relativeVirtualAddress" />가 음수입니다.</exception>
      <returns>
        <paramref name="relativeVirtualAddress" />에서 시작하여 포함된 섹션의 끝에서 끝나는 메모리 블록이거나, <paramref name="relativeVirtualAddress" />가 이 PE 이미지의 PE 섹션에 포함된 위치를 나타내지 않는 경우 빈 블록입니다.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.String)">
      <summary>지정된 이름의 PE 섹션을 메모리로 로드하고 섹션을 포괄하는 메모리 블록을 반환합니다.</summary>
      <param name="sectionName">섹션의 이름입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="sectionName" />이(가) <see langword="null" />인 경우</exception>
      <exception cref="T:System.InvalidOperationException">PE 이미지를 사용할 수 없습니다.</exception>
      <returns>섹션을 포괄하는 메모리 블록이거나, 지정된 <paramref name="sectionName" />의 섹션이 이 PE 이미지에 없으면 빈 블록입니다.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadCodeViewDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>지정된 디버그 디렉터리 항목에서 가리키는 데이터를 읽고 CodeView로 해석합니다.</summary>
      <param name="entry">디버그 디렉터리 항목 인스턴스입니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" />는 CodeView 항목이 아닙니다.</exception>
      <exception cref="T:System.BadImageFormatException">데이터 형식이 잘못되었습니다.</exception>
      <exception cref="T:System.IO.IOException">기본 스트림에서 읽는 동안 IO 오류가 발생했습니다.</exception>
      <exception cref="T:System.InvalidOperationException">PE 이미지를 사용할 수 없습니다.</exception>
      <returns>코드 보기 디버그 디렉터리 데이터 인스턴스입니다.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadDebugDirectory">
      <summary>모든 디버그 디렉터리 테이블 항목을 읽습니다.</summary>
      <exception cref="T:System.BadImageFormatException">항목의 형식이 잘못되었습니다.</exception>
      <exception cref="T:System.IO.IOException">기본 스트림에서 읽는 동안 IO 오류가 발생했습니다.</exception>
      <exception cref="T:System.InvalidOperationException">PE 이미지를 사용할 수 없습니다.</exception>
      <returns>디버그 디렉터리 테이블 항목의 배열입니다.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadEmbeddedPortablePdbDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>지정된 디버그 디렉터리 항목에서 가리키는 데이터를 읽고 Embedded Portable PDB blob으로 해석합니다.</summary>
      <param name="entry">데이터를 읽을 디버그 디렉터리 항목입니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" />가 <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb" /> 항목이 아닌 경우</exception>
      <exception cref="T:System.BadImageFormatException">데이터 형식이 잘못되었습니다.</exception>
      <exception cref="T:System.InvalidOperationException">PE 이미지를 사용할 수 없습니다.</exception>
      <returns>이식 가능한 PDB 이미지를 읽는 메타데이터 판독기의 공급자입니다.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadPdbChecksumDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>지정된 디버그 디렉터리 항목에서 가리키는 데이터를 읽고 PDB 체크섬 항목으로 해석합니다.</summary>
      <param name="entry">데이터를 읽을 디버그 디렉터리 항목입니다.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" />가 PDB 체크섬 항목이 아닙니다.</exception>
      <exception cref="T:System.BadImageFormatException">데이터 형식이 잘못되었습니다.</exception>
      <exception cref="T:System.IO.IOException">기본 스트림에서 읽는 동안 IO 오류가 발생했습니다.</exception>
      <exception cref="T:System.InvalidOperationException">PE 이미지를 사용할 수 없습니다.</exception>
      <returns>PDB 체크섬 항목입니다.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.TryOpenAssociatedPortablePdb(System.String,System.Func{System.String,System.IO.Stream},System.Reflection.Metadata.MetadataReaderProvider@,System.String@)">
      <summary>PE 이미지와 연결된 이식 가능한 PDB를 엽니다.</summary>
      <param name="peImagePath">PE 이미지의 경로입니다. 경로는 PE 파일을 포함하는 디렉터리에 있는 PDB 파일을 찾는 데 사용됩니다.</param>
      <param name="pdbFileStreamProvider">지정된 경우 지정된 파일 경로에 대한 <see cref="T:System.IO.Stream" />을 열기 위해 호출됩니다. 공급자는 읽을 수 있고 검색 가능한 <see cref="T:System.IO.Stream" /> 또는 <see langword="null" />(대상 파일이 없거나 어떤 이유로 무시되어야 하는 경우)을 반환해야 합니다. 예기치 않은 IO 오류로 인해 파일이 열리지 않는 경우 공급자는 <see cref="T:System.IO.IOException" />을 throw해야 합니다.</param>
      <param name="pdbReaderProvider">성공하면 이식 가능한 PDB를 읽는 데 사용할 <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />의 새 인스턴스입니다.</param>
      <param name="pdbPath">성공하고 PDB가 파일에 있으면 파일의 경로이고 PDB가 PE 이미지 자체에 포함되어 있으면 <see langword="null" />입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImagePath" /> 또는 <paramref name="pdbFileStreamProvider" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="pdbFileStreamProvider" />에서 반환되는 스트림은 읽기 및 검색 작업을 지원하지 않습니다.</exception>
      <exception cref="T:System.BadImageFormatException">오류 때문에 일치 하는 PDB 파일을 찾을 수 없습니다. PE 이미지 또는 PDB가 잘못 되었습니다.</exception>
      <exception cref="T:System.IO.IOException">오류 때문에 일치 하는 PDB 파일을 찾을 수 없습니다. PE 이미지 또는 PDB를 읽는 동안 IO 오류가 발생 했습니다.</exception>
      <returns>PE 이미지에 PDB가 연결되어 있고 PDB가 성공적으로 열린 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.HasMetadata">
      <summary>PE 이미지에 CLI 메타데이터가 포함되어 있는지 여부를 나타내는 값을 가져옵니다.</summary>
      <exception cref="T:System.BadImageFormatException">PE 헤더에 잘못된 데이터가 포함되어 있습니다.</exception>
      <exception cref="T:System.IO.IOException">기본 스트림에서 읽는 동안 오류가 발생했습니다.</exception>
      <returns>
        <see langword="true" /> PE 이미지에 CLI 메타 데이터가 포함 되어 있으면이 고, 그렇지 않으면 <see langword="false" /> 입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsEntireImageAvailable">
      <summary>판독기에서 전체 PE 이미지에 액세스할 수 있는지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns>
        <see langword="true" /> 판독기가 전체 PE 이미지에 액세스할 수 있으면이 고, 그렇지 않으면입니다. 그렇지 않으면 <see langword="false" /> 입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsLoadedImage">
      <summary>OS 로더에서 PE 이미지를 메모리로 로드했는지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns>OS 로더에서 PE 이미지를 메모리로 로드했으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.PEHeaders">
      <summary>PE 헤더를 가져옵니다.</summary>
      <exception cref="T:System.BadImageFormatException">헤더에 잘못된 데이터가 포함되어 있습니다.</exception>
      <exception cref="T:System.IO.IOException">스트림에서 읽는 중 오류가 발생했습니다.</exception>
      <returns>이 PE 이미지의 PE 헤더입니다.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEStreamOptions">
      <summary>스트림에서 PE 이미지 섹션을 읽는 방법을 지정하는 옵션을 제공합니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.Default">
      <summary>기본적으로 스트림은 <see cref="T:System.Reflection.PortableExecutable.PEReader" />가 삭제되고 PE 이미지의 섹션이 느리게 읽혀질 때 삭제됩니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.IsLoadedImage">
      <summary>OS 로더에서 기본 PE 이미지를 메모리로 로드했는지 여부를 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen">
      <summary>
        <see cref="T:System.Reflection.PortableExecutable.PEReader" />가 삭제될 때 스트림을 열린 상태로 유지합니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage">
      <summary>전체 이미지를 즉시 메모리로 읽습니다. <see cref="T:System.Reflection.PortableExecutable.PEReader" />는 <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" />을 지정하지 않을 경우 생성자가 반환될 때 자동으로 스트림을 닫습니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata">
      <summary>
        <para>메타데이터 섹션을 즉시 메모리로 읽습니다.</para>
        <para>파일의 다른 섹션에서 읽기는 허용되지 않습니다(<see cref="T:System.Reflection.PortableExecutable.PEReader" />에서 <see cref="T:System.InvalidOperationException" />을 throw함).</para>
        <para>
          <see cref="T:System.Reflection.PortableExecutable.PEReader" />는 <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" />을 지정하지 않을 경우 생성자가 반환될 때 자동으로 스트림을 닫습니다. 기본 파일은 닫히며 <see cref="T:System.Reflection.PortableExecutable.PEReader" />가 생성된 후에도 삭제될 수 있습니다.</para>
      </summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ResourceSectionBuilder">
      <summary>PE 리소스 섹션 작성기의 기본 클래스를 정의합니다. <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" />에서 파생하여 네이티브 리소스에 대한 serialization 논리를 제공합니다.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.#ctor">
      <summary>
        <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.SectionLocation)">
      <summary>지정된 리소스를 직렬화합니다.</summary>
      <param name="builder">직렬화할 데이터가 들어 있는 Blob입니다.</param>
      <param name="location">
        <paramref name="builder" />를 직렬화할 위치입니다.</param>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionCharacteristics" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1024Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align128Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align16Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2048Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align256Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align32Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4096Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align512Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align64Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8192Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.AlignMask" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsCode" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsInitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsUninitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.GPRel" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerComdat" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerInfo" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerNRelocOvfl" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerOther" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerRemove" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Mem16Bit" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemDiscardable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemExecute" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemFardata" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemLocked" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotCached" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotPaged" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPreload" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemProtected" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPurgeable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemRead" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemShared" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemSysheap" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemWrite" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.NoDeferSpecExc" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeCopy" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeDSect" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeGroup" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoLoad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoPad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeOver" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeReg" />
    <member name="T:System.Reflection.PortableExecutable.SectionHeader">
      <summary>PE/COFF 파일의 섹션 헤더에 대한 정보를 제공합니다.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.Name">
      <summary>섹션의 이름을 가져옵니다.</summary>
      <returns>섹션의 이름입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfLineNumbers">
      <summary>섹션에 대한 줄 번호 항목 수를 가져옵니다.</summary>
      <returns>섹션에 대 한 줄 번호 항목 수입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfRelocations">
      <summary>섹션에 대한 재배치 항목 수를 가져옵니다.</summary>
      <returns>섹션에 대 한 재배치 항목 수입니다. PE 이미지의 값은 0입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToLineNumbers">
      <summary>섹션에 대한 줄 번호 항목의 시작 부분을 가리키는 파일 포인터를 가져옵니다.</summary>
      <returns>섹션에 대 한 줄 번호 항목의 시작 부분에 대 한 파일 포인터 이거나, COFF 줄 번호가 없는 경우 0입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRawData">
      <summary>COFF 파일 내에 있는 섹션의 첫 페이지를 가리키는 파일 포인터를 가져옵니다.</summary>
      <returns>COFF 파일 내에 있는 섹션의 첫 번째 페이지에 대 한 파일 포인터입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRelocations">
      <summary>섹션에 대한 재배치 항목의 시작 부분을 가리키는 파일 포인터를 가져옵니다.</summary>
      <returns>섹션에 대 한 재배치 항목의 시작 부분에 대 한 파일 포인터입니다. PE 이미지의 경우 0으로 설정 되 고, 재배치가 없으면로 설정 됩니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SectionCharacteristics">
      <summary>섹션의 특징을 설명하는 플래그를 가져옵니다.</summary>
      <returns>섹션의 특성을 설명 하는 플래그입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SizeOfRawData">
      <summary>섹션 크기(개체 파일의 경우) 또는 디스크에 있는 초기화된 데이터의 크기(이미지 파일의 경우)를 가져옵니다.</summary>
      <returns>디스크에 있는 섹션의 크기 (개체 파일의 경우) 또는 초기화 된 데이터 크기 (이미지 파일의 경우)입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualAddress">
      <summary>섹션의 가상 주소를 가져옵니다.</summary>
      <returns>섹션의 가상 주소입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualSize">
      <summary>메모리에 로드된 섹션의 전체 크기를 가져옵니다.</summary>
      <returns>메모리에 로드 된 경우 섹션의 총 크기입니다.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionLocation" />
    <member name="M:System.Reflection.PortableExecutable.SectionLocation.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" />
      <param name="pointerToRawData" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.PointerToRawData" />
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.RelativeVirtualAddress" />
    <member name="T:System.Reflection.PortableExecutable.Subsystem">
      <summary>이미지의 하위 시스템 요구 사항을 설명합니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiApplication">
      <summary>EFI(Extensible Firmware Interface) 애플리케이션.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiBootServiceDriver">
      <summary>부팅 서비스가 포함된 EFI 드라이버.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRom">
      <summary>EFI ROM 이미지.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRuntimeDriver">
      <summary>런타임 서비스가 포함된 EFI 드라이버.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Native">
      <summary>이미지에 하위 시스템이 필요하지 않습니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.NativeWindows">
      <summary>이미지가 네이티브 Win9x 드라이버입니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.OS2Cui">
      <summary>이미지가 OS/2 문자 하위 시스템에서 실행됩니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.PosixCui">
      <summary>이미지가 Posix 문자 하위 시스템에서 실행됩니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Unknown">
      <summary>알 수 없는 하위 시스템.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsBootApplication">
      <summary>부팅 애플리케이션.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCEGui">
      <summary>이미지가 Windows CE 하위 시스템에서 실행됩니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCui">
      <summary>이미지가 Windows 문자 하위 시스템에서 실행됩니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsGui">
      <summary>이미지가 Windows GUI 하위 시스템에서 실행됩니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Xbox">
      <summary>Xbox 시스템.</summary>
    </member>
  </members>
</doc>