<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Security.Cryptography.Algorithms</name>
  </assembly>
  <members>
    <member name="T:System.Security.Cryptography.Aes">
      <summary>Représente la classe de base abstraite dont toutes les implémentations d’AES (Advanced Encryption Standard) doivent hériter.</summary>
    </member>
    <member name="M:System.Security.Cryptography.Aes.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.Aes" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.Aes.Create">
      <summary>Crée un objet de chiffrement qui permet d’exécuter l’algorithme symétrique.</summary>
      <returns>Objet de chiffrement qui permet d’exécuter l’algorithme symétrique.</returns>
    </member>
    <member name="M:System.Security.Cryptography.Aes.Create(System.String)">
      <summary>Crée un objet de chiffrement qui spécifie l’implémentation d’AES à utiliser pour exécuter l’algorithme symétrique.</summary>
      <param name="algorithmName">Nom de l’implémentation spécifique d’AES à utiliser.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="algorithmName" /> a la valeur <see langword="null" />.</exception>
      <returns>Objet de chiffrement qui permet d’exécuter l’algorithme symétrique.</returns>
    </member>
    <member name="T:System.Security.Cryptography.AesCcm">
      <summary>Représente une clé AES (Advanced Encryption Standard) à utiliser avec le mode de fonctionnement CCM (Counter with CBC-MAC).</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.#ctor(System.Byte[])">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.AesCcm" /> avec une clé fournie.</summary>
      <param name="key">Clé secrète à utiliser pour cette instance.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="key" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La longueur du paramètre <paramref name="key" /> est autre que 16, 24 ou 32 octets (128, 192 ou 256 bits).</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.#ctor(System.ReadOnlySpan{System.Byte})">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.AesCcm" /> avec une clé fournie.</summary>
      <param name="key">Clé secrète à utiliser pour cette instance.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La longueur du paramètre <paramref name="key" /> est autre que 16, 24 ou 32 octets (128, 192 ou 256 bits).</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.Decrypt(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
      <summary>Déchiffre le texte chiffré dans la mémoire tampon de destination fournie si la balise d’authentification peut être validée.</summary>
      <param name="nonce">Nonce associé à ce message, qui doit correspondre à la valeur fournie lors du chiffrement.</param>
      <param name="ciphertext">Contenu chiffré à déchiffrer.</param>
      <param name="tag">Balise d’authentification générée pour ce message lors du chiffrement.</param>
      <param name="plaintext">Tableau d’octets devant recevoir le contenu déchiffré.</param>
      <param name="associatedData">Données supplémentaires associées à ce message, qui doivent correspondre à la valeur fournie lors du chiffrement.</param>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="plaintext" /> et le <paramref name="ciphertext" /> n’ont pas la même longueur.

- ou -

La longueur du paramètre <paramref name="nonce" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesCcm.NonceByteSizes" />.

- ou -

La longueur du paramètre <paramref name="tag" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesCcm.TagByteSizes" />.</exception>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="nonce" />, <paramref name="ciphertext" />, <paramref name="tag" /> ou <paramref name="plaintext" /> est <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La valeur de balise n’a pas pu être vérifiée, ou l’opération de déchiffrement a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.Decrypt(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Déchiffre le texte chiffré dans la mémoire tampon de destination fournie si la balise d’authentification peut être validée.</summary>
      <param name="nonce">Nonce associé à ce message, qui doit correspondre à la valeur fournie lors du chiffrement.</param>
      <param name="ciphertext">Contenu chiffré à déchiffrer.</param>
      <param name="tag">Balise d’authentification générée pour ce message lors du chiffrement.</param>
      <param name="plaintext">Plage d’octets devant recevoir le contenu déchiffré.</param>
      <param name="associatedData">Données supplémentaires associées à ce message, qui doivent correspondre à la valeur fournie lors du chiffrement.</param>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="plaintext" /> et le <paramref name="ciphertext" /> n’ont pas la même longueur.

- ou -

La longueur du paramètre <paramref name="nonce" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesCcm.NonceByteSizes" />.

- ou -

La longueur du paramètre <paramref name="tag" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesCcm.TagByteSizes" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La valeur de balise n’a pas pu être vérifiée, ou l’opération de déchiffrement a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.Dispose">
      <summary>Libère les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Security.Cryptography.AesCcm" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.Encrypt(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
      <summary>Chiffre le texte en clair dans la mémoire tampon de destination du texte chiffré et génère la balise d’authentification dans une mémoire tampon distincte.</summary>
      <param name="nonce">Nonce associé à ce message, qui doit être une valeur unique pour chaque opération avec la même clé.</param>
      <param name="plaintext">Contenu à chiffrer.</param>
      <param name="ciphertext">Tableau d’octets devant recevoir le contenu chiffré.</param>
      <param name="tag">Tableau d’octets devant recevoir la balise d’authentification générée.</param>
      <param name="associatedData">Données supplémentaires associées à ce message, qui doivent également être fournies au cours du déchiffrement.</param>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="plaintext" /> et le <paramref name="ciphertext" /> n’ont pas la même longueur.

- ou -

La longueur du paramètre <paramref name="nonce" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesCcm.NonceByteSizes" />.

- ou -

La longueur du paramètre <paramref name="tag" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesCcm.TagByteSizes" />.</exception>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="nonce" />, <paramref name="ciphertext" />, <paramref name="tag" /> ou <paramref name="plaintext" /> est <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">L’opération de chiffrement a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.Encrypt(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Chiffre le texte en clair dans la mémoire tampon de destination du texte chiffré et génère la balise d’authentification dans une mémoire tampon distincte.</summary>
      <param name="nonce">Nonce associé à ce message, qui doit être une valeur unique pour chaque opération avec la même clé.</param>
      <param name="plaintext">Contenu à chiffrer.</param>
      <param name="ciphertext">Plage d’octets devant recevoir le contenu chiffré.</param>
      <param name="tag">Plage d’octets devant recevoir la balise d’authentification générée.</param>
      <param name="associatedData">Données supplémentaires associées à ce message, qui doivent également être fournies au cours du déchiffrement.</param>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="plaintext" /> et le <paramref name="ciphertext" /> n’ont pas la même longueur.

- ou -

La longueur du paramètre <paramref name="nonce" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesCcm.NonceByteSizes" />.

- ou -

La longueur du paramètre <paramref name="tag" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesCcm.TagByteSizes" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">L’opération de chiffrement a échoué.</exception>
    </member>
    <member name="P:System.Security.Cryptography.AesCcm.NonceByteSizes">
      <summary>Obtient les tailles des nonces, en octets, prises en charge par cette instance.</summary>
      <returns>Tailles de nonce prises en charge par cette instance : 7, 8, 9, 10, 11, 12 ou 13 octets (56, 64, 72, 80, 88, 96 ou 104 bits).</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesCcm.TagByteSizes">
      <summary>Obtient les tailles des balises, en octets, prises en charge par cette instance.</summary>
      <returns>Tailles des balises prises en charge par cette instance : 4, 6, 8, 10, 12, 14 ou 16 octets (32, 48, 64, 80, 96, 112 ou 128 bits).</returns>
    </member>
    <member name="T:System.Security.Cryptography.AesGcm">
      <summary>Représente une clé AES (Advanced Encryption Standard) à utiliser avec le mode de fonctionnement GCM (Galois/Counter Mode).</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.#ctor(System.Byte[])">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.AesGcm" /> avec une clé fournie.</summary>
      <param name="key">Clé secrète à utiliser pour cette instance.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="key" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La longueur du paramètre <paramref name="key" /> est autre que 16, 24 ou 32 octets (128, 192 ou 256 bits).</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.#ctor(System.ReadOnlySpan{System.Byte})">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.AesGcm" /> avec une clé fournie.</summary>
      <param name="key">Clé secrète à utiliser pour cette instance.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La longueur du paramètre <paramref name="key" /> est autre que 16, 24 ou 32 octets (128, 192 ou 256 bits).</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.Decrypt(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
      <summary>Déchiffre le texte chiffré dans la mémoire tampon de destination fournie si la balise d’authentification peut être validée.</summary>
      <param name="nonce">Nonce associé à ce message, qui doit correspondre à la valeur fournie lors du chiffrement.</param>
      <param name="ciphertext">Contenu chiffré à déchiffrer.</param>
      <param name="tag">Balise d’authentification générée pour ce message lors du chiffrement.</param>
      <param name="plaintext">Tableau d’octets devant recevoir le contenu déchiffré.</param>
      <param name="associatedData">Données supplémentaires associées à ce message, qui doivent correspondre à la valeur fournie lors du chiffrement.</param>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="plaintext" /> et le <paramref name="ciphertext" /> n’ont pas la même longueur.

- ou -

La longueur du paramètre <paramref name="nonce" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesGcm.NonceByteSizes" />.

- ou -

La longueur du paramètre <paramref name="tag" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesGcm.TagByteSizes" />.</exception>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="nonce" />, <paramref name="ciphertext" />, <paramref name="tag" /> ou <paramref name="plaintext" /> est <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La valeur de balise n’a pas pu être vérifiée, ou l’opération de déchiffrement a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.Decrypt(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Déchiffre le texte chiffré dans la mémoire tampon de destination fournie si la balise d’authentification peut être validée.</summary>
      <param name="nonce">Nonce associé à ce message, qui doit correspondre à la valeur fournie lors du chiffrement.</param>
      <param name="ciphertext">Contenu chiffré à déchiffrer.</param>
      <param name="tag">Balise d’authentification générée pour ce message lors du chiffrement.</param>
      <param name="plaintext">Plage d’octets devant recevoir le contenu déchiffré.</param>
      <param name="associatedData">Données supplémentaires associées à ce message, qui doivent correspondre à la valeur fournie lors du chiffrement.</param>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="plaintext" /> et le <paramref name="ciphertext" /> n’ont pas la même longueur.

- ou -

La longueur du paramètre <paramref name="nonce" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesGcm.NonceByteSizes" />.

- ou -

La longueur du paramètre <paramref name="tag" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesGcm.TagByteSizes" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La valeur de balise n’a pas pu être vérifiée, ou l’opération de déchiffrement a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.Dispose">
      <summary>Libère les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Security.Cryptography.AesGcm" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.Encrypt(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
      <summary>Chiffre le texte en clair dans la mémoire tampon de destination du texte chiffré et génère la balise d’authentification dans une mémoire tampon distincte.</summary>
      <param name="nonce">Nonce associé à ce message, qui doit être une valeur unique pour chaque opération avec la même clé.</param>
      <param name="plaintext">Contenu à chiffrer.</param>
      <param name="ciphertext">Tableau d’octets devant recevoir le contenu chiffré.</param>
      <param name="tag">Tableau d’octets devant recevoir la balise d’authentification générée.</param>
      <param name="associatedData">Données supplémentaires associées à ce message, qui doivent également être fournies au cours du déchiffrement.</param>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="plaintext" /> et le <paramref name="ciphertext" /> n’ont pas la même longueur.

- ou -

La longueur du paramètre <paramref name="nonce" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesGcm.NonceByteSizes" />.

- ou -

La longueur du paramètre <paramref name="tag" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesGcm.TagByteSizes" />.</exception>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="nonce" />, <paramref name="ciphertext" />, <paramref name="tag" /> ou <paramref name="plaintext" /> est <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">L’opération de chiffrement a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.Encrypt(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Chiffre le texte en clair dans la mémoire tampon de destination du texte chiffré et génère la balise d’authentification dans une mémoire tampon distincte.</summary>
      <param name="nonce">Nonce associé à ce message, qui doit être une valeur unique pour chaque opération avec la même clé.</param>
      <param name="plaintext">Contenu à chiffrer.</param>
      <param name="ciphertext">Tableau d’octets devant recevoir le contenu chiffré.</param>
      <param name="tag">Tableau d’octets devant recevoir la balise d’authentification générée.</param>
      <param name="associatedData">Données supplémentaires associées à ce message, qui doivent également être fournies au cours du déchiffrement.</param>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="plaintext" /> et le <paramref name="ciphertext" /> n’ont pas la même longueur.

- ou -

La longueur du paramètre <paramref name="nonce" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesGcm.NonceByteSizes" />.

- ou -

La longueur du paramètre <paramref name="tag" /> n’est pas autorisée par <see cref="P:System.Security.Cryptography.AesGcm.TagByteSizes" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">L’opération de chiffrement a échoué.</exception>
    </member>
    <member name="P:System.Security.Cryptography.AesGcm.NonceByteSizes">
      <summary>Obtient les tailles des nonces, en octets, prises en charge par cette instance.</summary>
      <returns>Tailles de nonce prises en charge par cette instance : 12 octets (96 bits).</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesGcm.TagByteSizes">
      <summary>Obtient les tailles des balises, en octets, prises en charge par cette instance.</summary>
      <returns>Tailles des balises prises en charge par cette instance : 12, 13, 14, 15 ou 16 octets (96, 104, 112, 120 ou 128 bits).</returns>
    </member>
    <member name="T:System.Security.Cryptography.AesManaged">
      <summary>Fournit une implémentation managée de l'algorithme symétrique AES (Advanced Encryption Standard).</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.AesManaged" />.</summary>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le paramètre de stratégie de sécurité Windows pour FIPS est activé.</exception>
      <exception cref="T:System.InvalidOperationException">Cette implémentation ne fait pas partie des algorithmes de chiffrement validés FIPS pour les plateformes Windows.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.CreateDecryptor">
      <summary>Crée un objet déchiffreur symétrique avec la clé et le vecteur d'initialisation actuels.</summary>
      <returns>Objet déchiffreur symétrique.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.CreateDecryptor(System.Byte[],System.Byte[])">
      <summary>Crée un objet déchiffreur symétrique avec la clé et le vecteur d'initialisation spécifiés.</summary>
      <param name="rgbKey">Clé secrète à utiliser pour l'algorithme symétrique.</param>
      <param name="rgbIV">Vecteur d'initialisation à utiliser pour l'algorithme symétrique.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> ou <paramref name="iv" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="key" /> n'est pas valide.</exception>
      <returns>Objet déchiffreur symétrique.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.CreateEncryptor">
      <summary>Crée un objet chiffreur symétrique avec la clé et le vecteur d'initialisation actuels.</summary>
      <returns>Objet chiffreur symétrique.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.CreateEncryptor(System.Byte[],System.Byte[])">
      <summary>Crée un objet chiffreur symétrique avec la clé et le vecteur d'initialisation spécifiés.</summary>
      <param name="rgbKey">Clé secrète à utiliser pour l'algorithme symétrique.</param>
      <param name="rgbIV">Vecteur d'initialisation à utiliser pour l'algorithme symétrique.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> ou <paramref name="iv" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="key" /> n'est pas valide.</exception>
      <returns>Objet chiffreur symétrique.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.GenerateIV">
      <summary>Génère un vecteur d'initialisation aléatoire à utiliser pour l'algorithme symétrique.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.GenerateKey">
      <summary>Génère une clé aléatoire à utiliser pour l'algorithme symétrique.</summary>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.BlockSize">
      <summary>Obtient ou définit la taille de bloc, en bits, de l'opération de chiffrement.</summary>
      <returns>Taille de bloc, en bits, de l’opération de chiffrement. La valeur par défaut est 128 bits.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.FeedbackSize">
      <summary>Obtient ou définit le nombre de bits à utiliser en commentaires.</summary>
      <returns>Taille des commentaires, en bits.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.IV">
      <summary>Obtient ou définit le vecteur d'initialisation à utiliser pour l'algorithme symétrique.</summary>
      <returns>Le vecteur d'initialisation à utiliser pour l'algorithme symétrique.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.Key">
      <summary>Obtient ou définit la clé secrète utilisée pour l'algorithme symétrique.</summary>
      <returns>La clé à utiliser pour l'algorithme symétrique.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.KeySize">
      <summary>Obtient ou définit la taille, en bits, de la clé secrète utilisée pour l'algorithme symétrique.</summary>
      <returns>Taille, en bits, de la clé utilisée par l'algorithme symétrique.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.LegalBlockSizes">
      <summary>Obtient les tailles de bloc, en octets, prises en charge par l'algorithme symétrique.</summary>
      <returns>Tailles de bloc, en bits, prises en charge par l’algorithme symétrique.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.LegalKeySizes">
      <summary>Obtient les tailles de clé, en octets, prises en charge par l'algorithme symétrique.</summary>
      <returns>Tailles de clé, en bits, prises en charge par l’algorithme symétrique.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.Mode">
      <summary>Obtient ou définit le mode de fonctionnement pour l'algorithme symétrique.</summary>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <see cref="P:System.Security.Cryptography.AesManaged.Mode" /> a la valeur <see cref="F:System.Security.Cryptography.CipherMode.CFB" /> ou <see cref="F:System.Security.Cryptography.CipherMode.OFB" />.</exception>
      <returns>Une des valeurs d'énumération qui spécifie le mode de chiffrement par blocs à utiliser pour le chiffrement. La valeur par défaut est <see cref="F:System.Security.Cryptography.CipherMode.CBC" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.Padding">
      <summary>Obtient ou définit le mode de remplissage utilisé dans l'algorithme symétrique.</summary>
      <returns>Une des valeurs d'énumération qui spécifie le type de remplissage à appliquer. La valeur par défaut est <see cref="F:System.Security.Cryptography.PaddingMode.PKCS7" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter">
      <summary>Représente la classe de base dont dérivent tous les déformateurs d’échange de clés asymétriques.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter.DecryptKeyExchange(System.Byte[])">
      <summary>En cas de substitution dans une classe dérivée, extrait des informations confidentielles à partir des données d’échange de clés chiffrées.</summary>
      <param name="rgb">Données d’échange de clés dans lesquelles les informations confidentielles sont cachées.</param>
      <returns>Informations confidentielles dérivées des données d’échange de clés.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>En cas de substitution dans une classe dérivée, définit la clé privée à utiliser pour déchiffrer les informations confidentielles.</summary>
      <param name="key">Instance de l’implémentation de <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> qui contient la clé privée.</param>
    </member>
    <member name="P:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter.Parameters">
      <summary>En cas de substitution dans une classe dérivée, obtient ou définit les paramètres pour l’échange de clés asymétriques.</summary>
      <returns>Chaîne au format XML contenant les paramètres de l’opération d’échange de clés asymétriques.</returns>
    </member>
    <member name="T:System.Security.Cryptography.AsymmetricKeyExchangeFormatter">
      <summary>Représente la classe de base dont dérivent tous les formateurs d’échange de clés asymétriques.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeFormatter.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Security.Cryptography.AsymmetricKeyExchangeFormatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeFormatter.CreateKeyExchange(System.Byte[])">
      <summary>En cas de substitution dans une classe dérivée, crée les données d’échange de clés chiffrées à partir des données d’entrée spécifiées.</summary>
      <param name="data">Informations confidentielles à passer dans l’échange de clés.</param>
      <returns>Données d’échange de clés chiffrées à envoyer au destinataire prévu.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeFormatter.CreateKeyExchange(System.Byte[],System.Type)">
      <summary>En cas de substitution dans une classe dérivée, crée les données d’échange de clés chiffrées à partir des données d’entrée spécifiées.</summary>
      <param name="data">Informations confidentielles à passer dans l’échange de clés.</param>
      <param name="symAlgType">Ce paramètre n’est pas utilisé dans la version actuelle.</param>
      <returns>Données d’échange de clés chiffrées à envoyer au destinataire prévu.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>En cas de substitution dans une classe dérivée, définit la clé publique à utiliser pour chiffrer les informations confidentielles.</summary>
      <param name="key">Instance de l’implémentation de <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> qui contient la clé publique.</param>
    </member>
    <member name="P:System.Security.Cryptography.AsymmetricKeyExchangeFormatter.Parameters">
      <summary>En cas de substitution dans une classe dérivée, obtient les paramètres pour l’échange de clés asymétriques.</summary>
      <returns>Chaîne au format XML contenant les paramètres de l’opération d’échange de clés asymétriques.</returns>
    </member>
    <member name="T:System.Security.Cryptography.AsymmetricSignatureDeformatter">
      <summary>Représente la classe de base abstraite dont toutes les implémentations des modules de déformatage de signature asymétriques dérivent.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureDeformatter.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Security.Cryptography.AsymmetricSignatureDeformatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureDeformatter.SetHashAlgorithm(System.String)">
      <summary>En cas de remplacement dans une classe dérivée, définit l’algorithme de hachage à utiliser pour vérifier la signature.</summary>
      <param name="strName">Nom de l’algorithme de hachage à utiliser pour vérifier la signature.</param>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>En cas de substitution dans une classe dérivée, définit la clé publique à utiliser pour vérifier la signature.</summary>
      <param name="key">Instance d’une implémentation de <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> qui contient la clé publique.</param>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureDeformatter.VerifySignature(System.Byte[],System.Byte[])">
      <summary>En cas de substitution dans une classe dérivée, vérifie la signature des données spécifiées.</summary>
      <param name="rgbHash">Données signées avec <paramref name="rgbSignature" />.</param>
      <param name="rgbSignature">Signature à vérifier pour <paramref name="rgbHash" />.</param>
      <returns>
        <see langword="true" /> si <paramref name="rgbSignature" /> correspond à la signature traitée à l’aide de l’algorithme de hachage et de la clé spécifiés sur <paramref name="rgbHash" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureDeformatter.VerifySignature(System.Security.Cryptography.HashAlgorithm,System.Byte[])">
      <summary>Vérifie la signature de la valeur de hachage spécifiée.</summary>
      <param name="hash">Algorithme de hachage à utiliser pour vérifier la signature.</param>
      <param name="rgbSignature">Signature à vérifier.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="hash" /> a la valeur <see langword="null" />.</exception>
      <returns>
        <see langword="true" /> si la signature est valide pour le hachage ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.AsymmetricSignatureFormatter">
      <summary>Représente la classe de base dont toutes les implémentations des formateurs de signatures asymétriques dérivent.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureFormatter.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Security.Cryptography.AsymmetricSignatureFormatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureFormatter.CreateSignature(System.Byte[])">
      <summary>En cas de substitution dans une classe dérivée, crée la signature pour les données spécifiées.</summary>
      <param name="rgbHash">Données à signer.</param>
      <returns>Signature numérique pour le paramètre <paramref name="rgbHash" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureFormatter.CreateSignature(System.Security.Cryptography.HashAlgorithm)">
      <summary>Crée la signature à partir de la valeur de hachage spécifiée.</summary>
      <param name="hash">Algorithme de hachage à utiliser pour créer la signature.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="hash" /> a la valeur <see langword="null" />.</exception>
      <returns>Signature pour la valeur de hachage spécifiée.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureFormatter.SetHashAlgorithm(System.String)">
      <summary>En cas de substitution dans une classe dérivée, définit l’algorithme de hachage à utiliser pour créer la signature.</summary>
      <param name="strName">Nom de l’algorithme de hachage à utiliser pour créer la signature.</param>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>En cas de substitution dans une classe dérivée, définit l’algorithme asymétrique à utiliser pour créer la signature.</summary>
      <param name="key">Instance de l’implémentation de <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> à utiliser pour créer la signature.</param>
    </member>
    <member name="T:System.Security.Cryptography.CryptoConfig">
      <summary>Accède aux informations de configuration du chiffrement.</summary>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.CryptoConfig" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.AddAlgorithm(System.Type,System.String[])">
      <summary>Ajoute un ensemble de noms aux mappages d'algorithmes à utiliser pour le domaine d'application actuel.</summary>
      <param name="algorithm">Algorithme auquel mapper.</param>
      <param name="names">Tableau de noms à mapper à l'algorithme.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="algorithm" /> ou <paramref name="names" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="algorithm" /> n'est pas accessible en dehors de l'assembly.  
  
- ou - 
L'une des entrées dans le paramètre <paramref name="names" /> est vide ou <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.AddOID(System.String,System.String[])">
      <summary>Ajoute un ensemble de noms aux mappages d'identificateurs d'objets (OID) à utiliser pour le domaine d'application actuel.</summary>
      <param name="oid">Identificateur d'objet (OID) auquel mapper.</param>
      <param name="names">Tableau de noms à mapper à l'OID.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="oid" /> ou <paramref name="names" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">L'une des entrées dans le paramètre <paramref name="names" /> est vide ou <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.CreateFromName(System.String)">
      <summary>Crée une nouvelle instance de l'objet de chiffrement spécifié.</summary>
      <param name="name">Nom simple de l'objet de chiffrement dont une instance doit être créée.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">L'algorithme décrit par le paramètre <paramref name="name" /> a été utilisé avec mode FIPS activé, mais n'est pas compatible FIPS.</exception>
      <returns>Nouvelle instance de l'objet de chiffrement spécifié.</returns>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.CreateFromName(System.String,System.Object[])">
      <summary>Crée une nouvelle instance de l'objet de chiffrement spécifié avec les arguments spécifiés.</summary>
      <param name="name">Nom simple de l'objet de chiffrement dont une instance doit être créée.</param>
      <param name="args">Arguments utilisés pour créer l'objet de chiffrement spécifié.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">L'algorithme décrit par le paramètre <paramref name="name" /> a été utilisé avec mode FIPS activé, mais n'est pas compatible FIPS.</exception>
      <returns>Nouvelle instance de l'objet de chiffrement spécifié.</returns>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.EncodeOID(System.String)">
      <summary>Encode l'identificateur de l'objet spécifié (OID, Object Identifier).</summary>
      <param name="str">OID à encoder.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="str" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">Une erreur s'est produite lors de l'encodage de l'OID.</exception>
      <returns>Tableau d'octets contenant l'OID encodé.</returns>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.MapNameToOID(System.String)">
      <summary>Obtient l'identificateur de l'objet (OID) de l'algorithme correspondant au nom simple spécifié.</summary>
      <param name="name">Nom simple de l'algorithme pour lequel l'OID doit être obtenu.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</exception>
      <returns>OID de l'algorithme spécifié.</returns>
    </member>
    <member name="P:System.Security.Cryptography.CryptoConfig.AllowOnlyFipsAlgorithms">
      <summary>Indique si le runtime doit appliquer la stratégie pour créer uniquement des algorithmes certifiés FIPS (Federal Information Processing Standard).</summary>
      <returns>
        <see langword="true" /> pour appliquer la stratégie; sinon, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.DeriveBytes">
      <summary>Représente la classe de base abstraite dont héritent toutes les classes qui dérivent des séquences d'octets d'une longueur spécifiée.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DeriveBytes.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.DeriveBytes" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DeriveBytes.Dispose">
      <summary>En cas de substitution dans une classe dérivée, libère toutes les ressources utilisées par l’instance actuelle de la classe <see cref="T:System.Security.Cryptography.DeriveBytes" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DeriveBytes.Dispose(System.Boolean)">
      <summary>En cas de substitution dans une classe dérivée, libère les ressources non managées utilisées par la classe <see cref="T:System.Security.Cryptography.DeriveBytes" /> et libère éventuellement les ressources managées.</summary>
      <param name="disposing">
        <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="M:System.Security.Cryptography.DeriveBytes.GetBytes(System.Int32)">
      <summary>En cas de substitution dans une classe dérivée, retourne des octets de clé pseudo-aléatoires.</summary>
      <param name="cb">Nombre d'octets de clé pseudo-aléatoires à générer.</param>
      <returns>Tableau d'octets rempli avec des octets de clé pseudo-aléatoires.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DeriveBytes.Reset">
      <summary>En cas de substitution dans une classe dérivée, rétablit l'état de l'opération.</summary>
    </member>
    <member name="T:System.Security.Cryptography.DES">
      <summary>Représente la classe de base de l’algorithme DES (Data Encryption Standard) dont toutes les implémentations de <see cref="T:System.Security.Cryptography.DES" /> doivent dériver.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DES.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.DES" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DES.Create">
      <summary>Crée une instance d’un objet de chiffrement pour exécuter l’algorithme Data Encryption Standard (<see cref="T:System.Security.Cryptography.DES" />).</summary>
      <returns>Objet de chiffrement.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DES.Create(System.String)">
      <summary>Crée une instance d'un objet de chiffrement pour exécuter l'implémentation spécifiée de l'algorithme Data Encryption Standard (<see cref="T:System.Security.Cryptography.DES" />).</summary>
      <param name="algName">Nom de l'implémentation spécifique de <see cref="T:System.Security.Cryptography.DES" /> à utiliser.</param>
      <returns>Objet de chiffrement.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DES.IsSemiWeakKey(System.Byte[])">
      <summary>Détermine si la clé spécifiée est semi-faible.</summary>
      <param name="rgbKey">Clé secrète dont la semi-faiblesse doit être testée.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La taille du paramètre <paramref name="rgbKey" /> n’est pas valide.</exception>
      <returns>
        <see langword="true" /> si la clé est semi-faible ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DES.IsWeakKey(System.Byte[])">
      <summary>Détermine si la clé spécifiée est faible.</summary>
      <param name="rgbKey">Clé secrète dont la faiblesse doit être testée.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La taille du paramètre <paramref name="rgbKey" /> n’est pas valide.</exception>
      <returns>
        <see langword="true" /> si la clé est faible ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.DES.Key">
      <summary>Obtient ou définit la clé secrète pour l’algorithme Data Encryption Standard (<see cref="T:System.Security.Cryptography.DES" />).</summary>
      <exception cref="T:System.ArgumentNullException">Une tentative d’affectation de la valeur <see langword="null" /> à la clé a été effectuée.</exception>
      <exception cref="T:System.ArgumentException">Une tentative a été effectuée pour définir une clé dont la longueur n’est pas égale à <see cref="F:System.Security.Cryptography.SymmetricAlgorithm.BlockSizeValue" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une tentative de définition d’une clé faible (voir <see cref="M:System.Security.Cryptography.DES.IsWeakKey(System.Byte[])" />) ou d’une clé semi-faible (voir <see cref="M:System.Security.Cryptography.DES.IsSemiWeakKey(System.Byte[])" />) a été effectuée.</exception>
      <returns>Clé secrète pour l’algorithme <see cref="T:System.Security.Cryptography.DES" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.DSA">
      <summary>Représente la classe de base abstraite dont toutes les implémentations de Digital Signature Algorithm (<see cref="T:System.Security.Cryptography.DSA" />) doivent hériter.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DSA.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DSA.Create">
      <summary>Crée l'objet de chiffrement par défaut utilisé pour exécuter l'algorithme asymétrique.</summary>
      <returns>Objet de chiffrement utilisé pour exécuter l'algorithme asymétrique.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.Create(System.Int32)">
      <summary>Crée une clé DSA éphémère avec la taille de clé spécifiée.</summary>
      <param name="keySizeInBits">Taille de la clé, en bits.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="keySizeInBits" /> n’est pas autorisé par <see cref="P:System.Security.Cryptography.AsymmetricAlgorithm.LegalKeySizes" />.</exception>
      <returns>Nouvelle clé DSA éphémère avec la taille de clé spécifiée.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.Create(System.Security.Cryptography.DSAParameters)">
      <summary>Crée une clé DSA éphémère avec les paramètres de clé DSA spécifiés.</summary>
      <param name="parameters">Paramètres pour l’algorithme <see cref="T:System.Security.Cryptography.DSA" />.</param>
      <returns>Nouvelle clé DSA éphémère.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.Create(System.String)">
      <summary>Crée l'objet de chiffrement spécifié utilisé pour exécuter l'algorithme asymétrique.</summary>
      <param name="algName">Nom de l'implémentation spécifique de <see cref="T:System.Security.Cryptography.DSA" /> à utiliser.</param>
      <returns>Objet de chiffrement utilisé pour exécuter l'algorithme asymétrique.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.CreateSignature(System.Byte[])">
      <summary>En cas de substitution dans une classe dérivée, crée la signature <see cref="T:System.Security.Cryptography.DSA" /> pour la valeur de hachage spécifiée.</summary>
      <param name="rgbHash">Valeur de hachage à signer.</param>
      <returns>Signature numérique pour la valeur de hachage spécifiée.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.CreateSignature(System.Byte[],System.Security.Cryptography.DSASignatureFormat)">
      <summary>Crée la signature DSA pour la valeur de hachage spécifiée dans le format indiqué.</summary>
      <param name="rgbHash">Valeur de hachage à signer.</param>
      <param name="signatureFormat">Format d’encodage à utiliser pour la signature.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="rgbHash" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> n’est pas un format connu.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de signature.</exception>
      <returns>Signature DSA pour les données spécifiées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.CreateSignatureCore(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.DSASignatureFormat)">
      <summary>Crée la signature DSA pour la valeur de hachage spécifiée dans le format indiqué.</summary>
      <param name="hash">Valeur de hachage à signer.</param>
      <param name="signatureFormat">Format d’encodage à utiliser pour la signature.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de signature.</exception>
      <returns>Signature DSA pour les données spécifiées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ExportParameters(System.Boolean)">
      <summary>En cas de remplacement dans une classe dérivée, exporte les éléments <see cref="T:System.Security.Cryptography.DSAParameters" />.</summary>
      <param name="includePrivateParameters">
        <see langword="true" /> pour inclure les paramètres privés ; sinon <see langword="false" />.</param>
      <returns>Paramètres pour <see cref="T:System.Security.Cryptography.DSA" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.FromXmlString(System.String)">
      <summary>Reconstruit un objet <see cref="T:System.Security.Cryptography.DSA" /> à partir d'une chaîne XML.</summary>
      <param name="xmlString">Chaîne XML à utiliser pour reconstruire l'objet <see cref="T:System.Security.Cryptography.DSA" />.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="xmlString" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le format du paramètre <paramref name="xmlString" /> n’est pas valide.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.GetMaxSignatureSize(System.Security.Cryptography.DSASignatureFormat)">
      <summary>Obtient la plus grande taille, en octets, pour une signature produite par cette clé dans le format indiqué.</summary>
      <param name="signatureFormat">Format d’encodage d’une signature.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> n’est pas un format connu.</exception>
      <returns>Taille maximale, en octets, d’une signature produite par cette clé dans le format indiqué.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.HashData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>En cas de remplacement dans une classe dérivée, calcule la valeur de hachage de la partie spécifiée d’un tableau d’octets à l’aide d’un algorithme de hachage spécifié.</summary>
      <param name="data">Données à hacher.</param>
      <param name="offset">Index du premier octet dans les <paramref name="data" /> à hacher.</param>
      <param name="count">Nombre d’octets à hacher.</param>
      <param name="hashAlgorithm">Algorithme à utiliser pour hacher les données.</param>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
      <returns>Données hachées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.HashData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)">
      <summary>En cas de remplacement dans une classe dérivée, calcule la valeur de hachage du flux binaire spécifié en utilisant un algorithme de hachage spécifié.</summary>
      <param name="data">Flux binaire à hacher.</param>
      <param name="hashAlgorithm">Algorithme à utiliser pour hacher les données.</param>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
      <returns>Données hachées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure PKCS#8 EncryptedPrivateKeyInfo après le déchiffrement avec un mot de passe basé sur l’octet, en remplaçant les clés de cet objet.</summary>
      <param name="passwordBytes">Octets à utiliser comme mot de passe lors du déchiffrement du matériel de clé.</param>
      <param name="source">Octets d’une structure PKCS#8 EncryptedPrivateKeyInfo dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le mot de passe est incorrect.

- ou -

Le contenu de <paramref name="source" /> indique que la fonction de dérivation de clés (KDF) à appliquer est la fonction KDF PKCS#12 existante, qui nécessite des mots de passe basés sur <see cref="T:System.Char" />.

- ou -

Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 EncryptedPrivateKeyInfo encodée en ASN.1-BER.

- ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

- ou -

Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

- ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure PKCS#8 EncryptedPrivateKeyInfo après le déchiffrement avec un mot de passe basé sur char, en remplaçant les clés de cet objet.</summary>
      <param name="password">Mot de passe à utiliser pour déchiffrer le matériel de clé.</param>
      <param name="source">Octets d’une structure PKCS#8 EncryptedPrivateKeyInfo dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le mot de passe est incorrect.

- ou -

Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 EncryptedPrivateKeyInfo encodée en ASN.1-BER.

- ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

- ou -

Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

- ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ImportFromEncryptedPem(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte})">
      <summary>Importe une clé privée encodée au format PEM RFC 7468 chiffrée, en remplaçant les clés de cet objet.</summary>
      <param name="input">Texte PEM de la clé chiffrée à importer.</param>
      <param name="passwordBytes">Octets à utiliser comme mot de passe lors du déchiffrement du matériel de clé.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="input" /> ne contient pas de clé encodée au format PEM avec une étiquette reconnue.

- ou -

            <paramref name="input" /> contient plusieurs clés encodées au format PEM avec une étiquette reconnue.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le mot de passe est incorrect.

- ou -

Le contenu décodé en base 64 du texte PEM à partir de <paramref name="input" /> ne représente pas une structure de PKCS#8 EncryptedPrivateKeyInfo encodée en ASN.1-BER.

- ou -

Le contenu décodé en base 64 du texte PEM à partir de <paramref name="input" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

- ou -

Le contenu décodé en base 64 du texte PEM à partir de <paramref name="input" /> représente la clé dans un format qui n’est pas pris en charge.

- ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ImportFromEncryptedPem(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>Importe une clé privée encodée au format PEM RFC 7468 chiffrée, en remplaçant les clés de cet objet.</summary>
      <param name="input">Texte PEM de la clé chiffrée à importer.</param>
      <param name="password">Mot de passe à utiliser pour déchiffrer le matériel de clé.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="input" /> ne contient pas de clé encodée au format PEM avec une étiquette reconnue.

- ou -

            <paramref name="input" /> contient plusieurs clés encodées au format PEM avec une étiquette reconnue.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le mot de passe est incorrect.

- ou -

Le contenu décodé en base 64 du texte PEM à partir de <paramref name="input" /> ne représente pas une structure de PKCS#8 EncryptedPrivateKeyInfo encodée en ASN.1-BER.

- ou -

Le contenu décodé en base 64 du texte PEM à partir de <paramref name="input" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

- ou -

Le contenu décodé en base 64 du texte PEM à partir de <paramref name="input" /> représente la clé dans un format qui n’est pas pris en charge.

- ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ImportFromPem(System.ReadOnlySpan{System.Char})">
      <summary>Importe une clé encodée au format PEM RFC 7468, en remplaçant les clés de cet objet.</summary>
      <param name="input">Texte PEM de la clé à importer.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="input" /> ne contient pas de clé encodée au format PEM avec une étiquette reconnue.

- ou -

            <paramref name="input" /> contient plusieurs clés encodées au format PEM avec une étiquette reconnue.

- ou -

            <paramref name="input" /> contient une clé encodée au format PEM chiffrée.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ImportParameters(System.Security.Cryptography.DSAParameters)">
      <summary>En cas de remplacement dans une classe dérivée, importe les éléments <see cref="T:System.Security.Cryptography.DSAParameters" /> spécifiés.</summary>
      <param name="parameters">Paramètres pour <see cref="T:System.Security.Cryptography.DSA" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parameters" /> ne contient pas les champs obligatoires.

- ou -

<paramref name="parameters" /> contient des champs avec des longueurs incohérentes pour une clé valide.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="parameters" /> ne représente pas un jeu de paramètres de clé DSA valide.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ImportPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure PKCS#8 PrivateKeyInfo après le déchiffrement, en remplaçant les clés de cet objet.</summary>
      <param name="source">Octets d’une structure PKCS#8 PrivateKeyInfo dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 PrivateKeyInfo encodée en ASN.1-BER.

- ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

- ou -

Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

- ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ImportSubjectPublicKeyInfo(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la clé publique à partir d’une structure X.509 SubjectPublicKeyInfo après le déchiffrement, en remplaçant les clés de cet objet.</summary>
      <param name="source">Octets d’une structure X.509 SubjectPublicKeyInfo dans l’encodage ASN.1-DER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le contenu de <paramref name="source" /> ne représente pas une structure X.509 SubjectPublicKeyInfo encodée en ASN.1-DER.

- ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

- ou -

Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

- ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.SignData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Calcule la valeur de hachage d'une partie du tableau d'octets indiqué à l'aide de l'algorithme de hachage spécifié et signe la valeur de hachage obtenue.</summary>
      <param name="data">Données d'entrée pour lesquelles calculer le hachage.</param>
      <param name="offset">Décalage dans le tableau à partir duquel l’utilisation de données commence.</param>
      <param name="count">Nombre d'octets dans le tableau à utiliser comme données.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="count" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="offset" /> + <paramref name="count" /> - 1 génère un index qui dépasse la limite supérieure de <paramref name="data" />.</exception>
      <returns>Signature DSA pour les données spécifiées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.SignData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Calcule la valeur de hachage des données spécifiées et la signe à l’aide du format de signature spécifié.</summary>
      <param name="data">Données à signer.</param>
      <param name="offset">Offset dans <paramref name="data" /> partir duquel commencer le hachage.</param>
      <param name="count">Nombre d’octets à lire à partir de <paramref name="data" />.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <param name="signatureFormat">Format d’encodage à utiliser pour la signature.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> n’est pas un format connu.
 
-ou- <paramref name="offset" /> est inférieur à zéro.
 
-ou- <paramref name="count" /> est inférieur à zéro.
 
-ou- <paramref name="offset" /> + <paramref name="count" /> - 1 génère un index qui est au-delà de la limite supérieure de <paramref name="data" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> a une <see langword="null" /> ou <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> vide.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de hachage ou de signature.</exception>
      <returns>Signature DSA pour les données spécifiées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.SignData(System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Calcule la valeur de hachage du tableau d'octets indiqué à l'aide de l'algorithme de hachage spécifié et signe la valeur de hachage obtenue.</summary>
      <param name="data">Données d'entrée pour lesquelles calculer le hachage.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <returns>Signature DSA pour les données spécifiées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.SignData(System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Calcule la valeur de hachage des données spécifiées et la signe à l’aide du format de signature spécifié.</summary>
      <param name="data">Données à signer.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <param name="signatureFormat">Format d’encodage à utiliser pour la signature.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> n’est pas un format connu.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> a une <see langword="null" /> ou <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> vide.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de hachage ou de signature.</exception>
      <returns>Signature DSA pour les données spécifiées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.SignData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Calcule la valeur de hachage du flux indiqué à l'aide de l'algorithme de hachage spécifié et signe la valeur de hachage obtenue.</summary>
      <param name="data">Flux d'entrée pour lequel calculer le hachage.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <returns>Signature DSA pour les données spécifiées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.SignData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Calcule la valeur de hachage des données spécifiées et la signe à l’aide du format de signature spécifié.</summary>
      <param name="data">Données à signer.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <param name="signatureFormat">Format d’encodage à utiliser pour la signature.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> n’est pas un format connu.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> a une <see langword="null" /> ou <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> vide.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de hachage ou de signature.</exception>
      <returns>Signature DSA pour les données spécifiées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.SignDataCore(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Calcule la valeur de hachage des données spécifiées et la signe à l’aide du format de signature spécifié.</summary>
      <param name="data">Données à signer.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <param name="signatureFormat">Format d’encodage à utiliser pour la signature.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de hachage ou de signature.</exception>
      <returns>Signature DSA pour les données spécifiées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.SignDataCore(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Calcule la valeur de hachage des données spécifiées et la signe à l’aide du format de signature spécifié.</summary>
      <param name="data">Données à signer.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <param name="signatureFormat">Format d’encodage à utiliser pour la signature.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de hachage ou de signature.</exception>
      <returns>Signature DSA pour les données spécifiées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ToXmlString(System.Boolean)">
      <summary>Crée et retourne une représentation de la chaîne XML de l'objet <see cref="T:System.Security.Cryptography.DSA" /> en cours.</summary>
      <param name="includePrivateParameters">
        <see langword="true" /> pour inclure les paramètres privés ; sinon <see langword="false" />.</param>
      <returns>Encodage de la chaîne XML de l'objet <see cref="T:System.Security.Cryptography.DSA" /> actuel.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryCreateSignature(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@)">
      <summary>Tente de créer la signature DSA pour le hachage spécifié dans la mémoire tampon fournie.</summary>
      <param name="hash">Hachage à signer.</param>
      <param name="destination">Plage d’octets pour la réception de la signature.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Cette instance représente uniquement une clé publique.

- ou -

Le type d’implémentation prend en charge uniquement le DSA hérité (FIPS 186-2), et <paramref name="hash" /> n’est pas une valeur de 20 octets.

- ou -

La création de la signature a échoué.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir le résultat ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryCreateSignature(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.DSASignatureFormat,System.Int32@)">
      <summary>Tente de créer la signature DSA pour la valeur de hachage spécifiée au format indiqué et de la placer dans la mémoire tampon fournie.</summary>
      <param name="hash">Valeur de hachage à signer.</param>
      <param name="destination">Mémoire tampon utilisée pour recevoir la signature.</param>
      <param name="signatureFormat">Format d’encodage à utiliser pour la signature.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> n’est pas un format connu.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de signature.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la signature ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryCreateSignatureCore(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.DSASignatureFormat,System.Int32@)">
      <summary>Tente de créer la signature DSA pour la valeur de hachage spécifiée au format indiqué et de la placer dans la mémoire tampon fournie.</summary>
      <param name="hash">Valeur de hachage à signer.</param>
      <param name="destination">Mémoire tampon utilisée pour recevoir la signature.</param>
      <param name="signatureFormat">Format d’encodage à utiliser pour la signature.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de signature.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la signature ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#8 EncryptedPrivateKeyInfo dans une mémoire tampon fournie, à l’aide d’un mot de passe basé sur l’octet.</summary>
      <param name="passwordBytes">Octets à utiliser comme mot de passe lors du chiffrement du matériel de clé.</param>
      <param name="pbeParameters">Paramètres de chiffrement par mot de passe à utiliser lors du chiffrement du matériel de clé.</param>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#8 EncryptedPrivateKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.

- ou -

<paramref name="pbeParameters" /> indique que <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" /> doit être utilisé, ce qui nécessite des mots de passe basés sur <see cref="T:System.Char" />.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#8 EncryptedPrivateKeyInfo dans une mémoire tampon fournie, à l’aide d’un mot de passe basé sur char.</summary>
      <param name="password">Mot de passe à utiliser lors du chiffrement du matériel de clé.</param>
      <param name="pbeParameters">Paramètres de chiffrement par mot de passe à utiliser lors du chiffrement du matériel de clé.</param>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#8 EncryptedPrivateKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryExportPkcs8PrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#8 PrivateKeyInfo dans une mémoire tampon fournie.</summary>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#8 PrivateKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryExportSubjectPublicKeyInfo(System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format X.509 SubjectPublicKeyInfo dans une mémoire tampon fournie.</summary>
      <param name="destination">Intervalle d’octets pour recevoir les données X.509 SubjectPublicKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryHashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Int32@)">
      <summary>Tente de calculer la valeur de hachage des données fournies dans une mémoire tampon fournie.</summary>
      <param name="data">Données à hacher.</param>
      <param name="destination">Plage d’octets pour la réception de la valeur de hachage.</param>
      <param name="hashAlgorithm">Nom de l'algorithme de hachage à utiliser.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir le résultat ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TrySignData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Int32@)">
      <summary>Tente de créer la signature DSA pour les données spécifiées dans la mémoire tampon fournie.</summary>
      <param name="data">Données à hacher et à signer.</param>
      <param name="destination">Plage d’octets pour la réception de la signature.</param>
      <param name="hashAlgorithm">Nom de l'algorithme de hachage à utiliser.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir le résultat ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TrySignData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat,System.Int32@)">
      <summary>Tente de créer la signature DSA pour les données spécifiées dans le format indiqué et de les placer dans la mémoire tampon fournie.</summary>
      <param name="data">Données à hacher et à signer.</param>
      <param name="destination">Mémoire tampon utilisée pour recevoir la signature.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <param name="signatureFormat">Format d’encodage à utiliser pour la signature.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> n’est pas un format connu.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> a une <see langword="null" /> ou <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> vide.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de signature.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la signature ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TrySignDataCore(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat,System.Int32@)">
      <summary>Tente de créer la signature DSA pour les données spécifiées dans le format indiqué et de les placer dans la mémoire tampon fournie.</summary>
      <param name="data">Données à hacher et à signer.</param>
      <param name="destination">Mémoire tampon utilisée pour recevoir la signature.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <param name="signatureFormat">Format d’encodage à utiliser pour la signature.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de signature.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la signature ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyData(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Vérifie qu'une signature numérique est valide en calculant la valeur de hachage des données indiquées à l'aide de l'algorithme de hachage spécifié et en la comparant à la signature fournie.</summary>
      <param name="data">Données signées.</param>
      <param name="signature">Données de la signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage des données.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="signature" /> est <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le type d’implémentation prend en charge uniquement le DSA hérité (FIPS 186-2), et l’algorithme de hachage n’est pas SHA-1.

- ou -

La vérification de la signature a échoué.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <returns>
        <see langword="true" /> si la signature numérique est valide ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyData(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Vérifie qu’une signature numérique est valide pour les données fournies.</summary>
      <param name="data">Données signées.</param>
      <param name="signature">Signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour hacher les données pour le processus de vérification.</param>
      <param name="signatureFormat">Format d’encodage de <paramref name="signature" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ou <paramref name="signature" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> n’est pas un format connu.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> a une <see langword="null" /> ou <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> vide.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de hachage ou de vérification.</exception>
      <returns>
        <see langword="true" /> si la signature numérique est valide pour les données fournies ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyData(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Vérifie qu'une signature numérique est valide en calculant la valeur de hachage des données dans une partie d'un tableau d'octets à l'aide de l'algorithme de hachage spécifié et en la comparant à la signature fournie.</summary>
      <param name="data">Données signées.</param>
      <param name="offset">Index de départ à partir duquel calculer le hachage.</param>
      <param name="count">Nombre d’octets à hacher.</param>
      <param name="signature">Données de la signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage des données.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="signature" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="count" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="offset" /> + <paramref name="count" /> - 1 génère un index qui dépasse la limite supérieure de <paramref name="data" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le type d’implémentation prend en charge uniquement le DSA hérité (FIPS 186-2), et l’algorithme de hachage n’est pas SHA-1.

- ou -

La vérification de la signature a échoué.</exception>
      <returns>
        <see langword="true" /> si la signature numérique est valide ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyData(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Vérifie qu’une signature numérique est valide pour les données fournies.</summary>
      <param name="data">Tableau qui contient les données signées.</param>
      <param name="offset">Index de départ de la partie signée de <paramref name="data" />.</param>
      <param name="count">Nombre d’octets dans <paramref name="data" /> qui ont été signés.</param>
      <param name="signature">Signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour hacher les données pour le processus de vérification.</param>
      <param name="signatureFormat">Format d’encodage de <paramref name="signature" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ou <paramref name="signature" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> n’est pas un format connu.
 
-ou- <paramref name="offset" /> est inférieur à zéro.
 
-ou- <paramref name="count" /> est inférieur à zéro.
 
-ou- <paramref name="offset" /> + <paramref name="count" /> - 1 génère un index qui est au-delà de la limite supérieure de <paramref name="data" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> a une <see langword="null" /> ou <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> vide.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de hachage ou de vérification.</exception>
      <returns>
        <see langword="true" /> si la signature numérique est valide pour les données fournies ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyData(System.IO.Stream,System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Vérifie qu'une signature numérique est valide en calculant la valeur de hachage du flux indiqué à l'aide de l'algorithme de hachage spécifié et en la comparant à la signature fournie.</summary>
      <param name="data">Données signées.</param>
      <param name="signature">Données de la signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage des données.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="signature" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le type d’implémentation prend en charge uniquement le DSA hérité (FIPS 186-2), et l’algorithme de hachage n’est pas SHA-1.

- ou -

La vérification de la signature a échoué.</exception>
      <returns>
        <see langword="true" /> si la signature numérique est valide ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyData(System.IO.Stream,System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Vérifie qu’une signature numérique est valide pour les données fournies.</summary>
      <param name="data">Données signées.</param>
      <param name="signature">Signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour hacher les données pour le processus de vérification.</param>
      <param name="signatureFormat">Format d’encodage de <paramref name="signature" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ou <paramref name="signature" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> n’est pas un format connu.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> a une <see langword="null" /> ou <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> vide.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de hachage ou de vérification.</exception>
      <returns>
        <see langword="true" /> si la signature numérique est valide pour les données fournies ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyData(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName)">
      <summary>Vérifie qu’une signature numérique est valide en calculant la valeur de hachage des données dans une plage d’octets à l’aide de l’algorithme de hachage spécifié et en la comparant à la signature fournie.</summary>
      <param name="data">Données signées.</param>
      <param name="signature">Signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage des données.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le type d’implémentation prend en charge uniquement le DSA hérité (FIPS 186-2), et l’algorithme de hachage n’est pas SHA-1.

- ou -

La vérification de la signature a échoué.</exception>
      <returns>
        <see langword="true" /> si la signature numérique est valide ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyData(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Vérifie qu’une signature numérique est valide pour les données fournies.</summary>
      <param name="data">Données signées.</param>
      <param name="signature">Signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour hacher les données pour le processus de vérification.</param>
      <param name="signatureFormat">Format d’encodage de <paramref name="signature" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> n’est pas un format connu.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de hachage ou de vérification.</exception>
      <returns>
        <see langword="true" /> si la signature numérique est valide pour les données fournies ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyDataCore(System.IO.Stream,System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Vérifie qu’une signature numérique est valide pour les données fournies.</summary>
      <param name="data">Données signées.</param>
      <param name="signature">Signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour hacher les données pour le processus de vérification.</param>
      <param name="signatureFormat">Format d’encodage de <paramref name="signature" />.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de hachage ou de vérification.</exception>
      <returns>
        <see langword="true" /> si la signature numérique est valide pour les données fournies ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyDataCore(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Vérifie qu’une signature numérique est valide pour les données fournies.</summary>
      <param name="data">Données signées.</param>
      <param name="signature">Signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour hacher les données pour le processus de vérification.</param>
      <param name="signatureFormat">Format d’encodage de <paramref name="signature" />.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de hachage ou de vérification.</exception>
      <returns>
        <see langword="true" /> si la signature numérique est valide pour les données fournies ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifySignature(System.Byte[],System.Byte[])">
      <summary>Substitué dans une classe dérivée, vérifie la signature <see cref="T:System.Security.Cryptography.DSA" /> pour les données spécifiées.</summary>
      <param name="rgbHash">Hachage des données signées avec <paramref name="rgbSignature" />.</param>
      <param name="rgbSignature">Signature à vérifier pour <c>rgbData</c>.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le type d’implémentation prend en charge uniquement le DSA hérité (FIPS 186-2), et la valeur de hachage n’est pas égale à 20 octets.

- ou -

La vérification de la signature a échoué.</exception>
      <returns>
        <see langword="true" /> si <paramref name="rgbSignature" /> correspond à la signature traitée à l’aide de l’algorithme de hachage et de la clé spécifiés sur <paramref name="rgbHash" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifySignature(System.Byte[],System.Byte[],System.Security.Cryptography.DSASignatureFormat)">
      <summary>Vérifie qu’une signature numérique est valide pour le hachage fourni.</summary>
      <param name="rgbHash">Code de hachage signé.</param>
      <param name="rgbSignature">Signature à vérifier.</param>
      <param name="signatureFormat">Format d’encodage de <paramref name="rgbSignature" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="rgbHash" /> ou <paramref name="rgbSignature" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> n’est pas un format connu.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de vérification.</exception>
      <returns>
        <see langword="true" /> si la signature numérique est valide pour les données fournies ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifySignature(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Vérifie qu’une signature numérique est valide pour un hachage de données fourni.</summary>
      <param name="hash">Hachage des données à vérifier.</param>
      <param name="signature">Signature à vérifier.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le type d’implémentation prend en charge uniquement le DSA hérité (FIPS 186-2), et la valeur de hachage n’est pas égale à 20 octets.

- ou -

La vérification de la signature a échoué.</exception>
      <returns>
        <see langword="true" /> si la signature numérique est valide pour le hachage ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifySignature(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.DSASignatureFormat)">
      <summary>Vérifie qu’une signature numérique est valide pour le hachage fourni.</summary>
      <param name="hash">Code de hachage signé.</param>
      <param name="signature">Signature à vérifier.</param>
      <param name="signatureFormat">Format d’encodage de <paramref name="signature" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> n’est pas un format connu.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de vérification.</exception>
      <returns>
        <see langword="true" /> si la signature numérique est valide pour les données fournies ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifySignatureCore(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.DSASignatureFormat)">
      <summary>Vérifie qu’une signature numérique est valide pour le hachage fourni.</summary>
      <param name="hash">Code de hachage signé.</param>
      <param name="signature">Signature à vérifier.</param>
      <param name="signatureFormat">Format d’encodage de <paramref name="signature" />.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de vérification.</exception>
      <returns>
        <see langword="true" /> si la signature numérique est valide pour les données fournies ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.DSAParameters">
      <summary>Contient les paramètres standard de l'algorithme <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.Counter">
      <summary>Spécifie le compteur de l'algorithme <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.G">
      <summary>Spécifie le paramètre <see langword="G" /> pour l'algorithme <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.J">
      <summary>Spécifie le paramètre <see langword="J" /> pour l'algorithme <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.P">
      <summary>Spécifie le paramètre <see langword="P" /> pour l'algorithme <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.Q">
      <summary>Spécifie le paramètre <see langword="Q" /> pour l'algorithme <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.Seed">
      <summary>Spécifie la valeur initiale pour l'algorithme <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.X">
      <summary>Spécifie le paramètre <see langword="X" /> pour l'algorithme <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.Y">
      <summary>Spécifie le paramètre <see langword="Y" /> pour l'algorithme <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="T:System.Security.Cryptography.DSASignatureDeformatter">
      <summary>Vérifie une signature Digital Signature Algorithm (<see cref="T:System.Security.Cryptography.DSA" />) PKCS#1 v1.5.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureDeformatter.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.DSASignatureDeformatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureDeformatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.DSASignatureDeformatter" /> avec la clé spécifiée.</summary>
      <param name="key">Instance de Digital Signature Algorithm (<see cref="T:System.Security.Cryptography.DSA" />) qui contient la clé.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureDeformatter.SetHashAlgorithm(System.String)">
      <summary>Spécifie l'algorithme de hachage pour le déformateur de signatures Digital Signature Algorithm (<see cref="T:System.Security.Cryptography.DSA" />).</summary>
      <param name="strName">Nom de l'algorithme de hachage à utiliser pour le déformateur de signatures.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">Le paramètre <paramref name="strName" /> ne correspond pas à l'algorithme de hachage <see cref="T:System.Security.Cryptography.SHA1" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Spécifie la clé à utiliser pour le déformateur de signatures Digital Signature Algorithm (<see cref="T:System.Security.Cryptography.DSA" />).</summary>
      <param name="key">Instance de <see cref="T:System.Security.Cryptography.DSA" /> qui contient la clé.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureDeformatter.VerifySignature(System.Byte[],System.Byte[])">
      <summary>Vérifie la signature Digital Signature Algorithm (<see cref="T:System.Security.Cryptography.DSA" />) sur les données.</summary>
      <param name="rgbHash">Données signées avec <paramref name="rgbSignature" />.</param>
      <param name="rgbSignature">Signature à vérifier pour <paramref name="rgbHash" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="rgbHash" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="rgbSignature" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">La clé DSA est manquante.</exception>
      <returns>
        <see langword="true" /> si la signature est valide pour les données ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.DSASignatureFormat">
      <summary>Spécifie le format de données des signatures avec la famille d’algorithmes DSA.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSASignatureFormat.IeeeP1363FixedFieldConcatenation">
      <summary>Format de signature de la norme IEEE P1363, qui produit une signature de taille fixe pour une clé donnée.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSASignatureFormat.Rfc3279DerSequence">
      <summary>Format de signature de la norme IETF RFC 3279 qui produit une signature de taille variable.</summary>
    </member>
    <member name="T:System.Security.Cryptography.DSASignatureFormatter">
      <summary>Crée une signature Digital Signature Algorithm (<see cref="T:System.Security.Cryptography.DSA" />).</summary>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureFormatter.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.DSASignatureFormatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureFormatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.DSASignatureFormatter" /> avec la clé spécifiée.</summary>
      <param name="key">Instance de Digital Signature Algorithm (<see cref="T:System.Security.Cryptography.DSA" />) qui contient la clé.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureFormatter.CreateSignature(System.Byte[])">
      <summary>Crée la signature Digital Signature Algorithm (<see cref="T:System.Security.Cryptography.DSA" />) PKCS #1 pour les données spécifiées.</summary>
      <param name="rgbHash">Données à signer.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="rgbHash" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">L'identificateur d'objet (OID, Object Identifier) est <see langword="null" />.  
  
- ou - 
La clé DSA est <see langword="null" />.</exception>
      <returns>Signature numérique pour les données spécifiées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureFormatter.SetHashAlgorithm(System.String)">
      <summary>Spécifie l'algorithme de hachage pour le formateur de signatures Digital Signature Algorithm (<see cref="T:System.Security.Cryptography.DSA" />).</summary>
      <param name="strName">Nom de l'algorithme de hachage à utiliser pour le formateur de signatures.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">Le paramètre <paramref name="strName" /> ne correspond pas à l'algorithme de hachage <see cref="T:System.Security.Cryptography.SHA1" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Spécifie la clé à utiliser pour le formateur de signatures Digital Signature Algorithm (<see cref="T:System.Security.Cryptography.DSA" />).</summary>
      <param name="key">Instance de <see cref="T:System.Security.Cryptography.DSA" /> qui contient la clé.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="T:System.Security.Cryptography.ECCurve">
      <summary>Représente une courbe elliptique.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.A">
      <summary>Le premier coefficient pour une courbe explicite. <c>A</c> pour les courbes Weierstrass, Montgomery et Edwards courtes.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.B">
      <summary>Le deuxième coefficient pour une courbe explicite. <c>B</c> pour les courbes Weierstrass et <c>d</c> pour les courbes d’Edwards courtes.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.Cofactor">
      <summary>Cofacteur de la courbe.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.CurveType">
      <summary>Identifie la composition de l’objet <see cref="T:System.Security.Cryptography.ECCurve" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.G">
      <summary>Le générateur, ou point de base, pour les opérations sur la courbe.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.Hash">
      <summary>Le nom de l’algorithme de hachage utilisé pour générer les coefficients de courbe (<see cref="F:System.Security.Cryptography.ECCurve.A" /> et <see cref="F:System.Security.Cryptography.ECCurve.B" />) à partir de la <see cref="F:System.Security.Cryptography.ECCurve.Seed" /> sous l’algorithme de génération ANSI X9.62. S’applique uniquement aux courbes explicites.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.Order">
      <summary>L’ordre de la courbe. S’applique uniquement aux courbes explicites.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.Polynomial">
      <summary>La courbe polynomiale. S’applique uniquement aux courbes de caractéristique 2.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.Prime">
      <summary>Prime spécifiant le champ de base. S’applique uniquement aux courbes prime.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.Seed">
      <summary>La valeur initiale pour la génération de coefficient sous l’algorithme de génération ANSI X9.62. S’applique uniquement aux courbes explicites.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECCurve.CreateFromFriendlyName(System.String)">
      <summary>Crée une courbe nommée à l’aide du nom convivial spécifié de l’identificateur.</summary>
      <param name="oidFriendlyName">Nom convivial de l’identificateur.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="oidFriendlyName" /> a la valeur <see langword="null" />.</exception>
      <returns>Un objet représentant la courbe nommée.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECCurve.CreateFromOid(System.Security.Cryptography.Oid)">
      <summary>Crée une courbe nommée à l'aide de l'objet <see cref="T:System.Security.Cryptography.Oid" /> spécifié.</summary>
      <param name="curveOid">L’identificateur d’objet à utiliser.</param>
      <returns>Un objet représentant la courbe nommée.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECCurve.CreateFromValue(System.String)">
      <summary>Crée une courbe nommée à l’aide de la représentation décimale spécifiée de l’identificateur.</summary>
      <param name="oidValue">Le nombre en pointillés de l’identificateur.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="oidValue" /> a la valeur <see langword="null" />.</exception>
      <returns>Un objet représentant la courbe nommée.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECCurve.Validate">
      <summary>Valide l’intégrité de la courbe actuelle. Lève une exception <see cref="T:System.Security.Cryptography.CryptographicException" /> si la structure n’est pas valide.</summary>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Les paramètres de la courbe ne sont pas valides pour le type de courbe actuel.</exception>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.IsCharacteristic2">
      <summary>Obtient une valeur qui indique si le type de courbe fait référence à une courbe explicite caractéristique 2.</summary>
      <returns>
        <see langword="true" /> si la courbe est une courbe explicite caractéristique 2 ; <see langword="false" /> si la courbe est une courbe implicite, prime ou caractéristique 2.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.IsExplicit">
      <summary>Obtient une valeur qui indique si le type de courbe fait référence à une courbe explicite (prime ou caractéristique 2).</summary>
      <returns>
        <see langword="true" /> si la courbe est une courbe explicite (prime ou caractéristique 2) ; <see langword="false" /> si la courbe est une courbe nommée ou implicite.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.IsNamed">
      <summary>Obtient une valeur qui indique si le type de courbe fait référence à une courbe nommée.</summary>
      <returns>
        <see langword="true" /> Si la courbe est une courbe nommée ; <see langword="false" /> si la courbe est une courbe implicite ou explicite (prime ou caractéristique 2).</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.IsPrime">
      <summary>Obtient une valeur qui indique si le type de courbe fait référence à une courbe explicite prime 2.</summary>
      <returns>
        <see langword="true" /> si la courbe est une courbe explicite prime ; <see langword="false" /> si la courbe est une courbe prime nommée, implicite ou caractéristique 2.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.Oid">
      <summary>Obtient l’identificateur d’une courbe nommée.</summary>
      <returns>L’identificateur d’une courbe nommée.</returns>
    </member>
    <member name="T:System.Security.Cryptography.ECCurve.ECCurveType">
      <summary>Indique comment interpréter les données contenues dans un objet <see cref="T:System.Security.Cryptography.ECCurve" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.ECCurveType.Characteristic2">
      <summary>Les paramètres de la courbe représentent une courbe caractéristique 2.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.ECCurveType.Implicit">
      <summary>Aucune donnée de courbe n’est interprétée. L’appelant est censé savoir quelle est la courbe.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.ECCurveType.Named">
      <summary>Les paramètres de la courbe représentent une courbe nommée.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.ECCurveType.PrimeMontgomery">
      <summary>Les paramètres de la courbe représentent une courbe avec la formule B*y^2 = x^3 + A*x^2 + x.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.ECCurveType.PrimeShortWeierstrass">
      <summary>Les paramètres de la courbe représentent une courbe avec la formule y^2 = x^3 + A*x + B dans le champ prime P.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.ECCurveType.PrimeTwistedEdwards">
      <summary>Les paramètres de la courbe représentent une courbe avec la formule A*x^2 + y^2 = 1 + B*x^2*y^2 dans le champ prime P.</summary>
    </member>
    <member name="T:System.Security.Cryptography.ECCurve.NamedCurves">
      <summary>Représente une classe de fabrique pour la création de courbes nommées.</summary>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP160r1">
      <summary>Obtient une courbe nommée brainpoolP160r1.</summary>
      <returns>Une courbe nommée brainpoolP160r1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP160t1">
      <summary>Obtient une courbe nommée brainpoolP160t1.</summary>
      <returns>Une courbe nommée brainpoolP160t1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP192r1">
      <summary>Obtient une courbe nommée brainpoolP192r1.</summary>
      <returns>Une courbe nommée brainpoolP192r1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP192t1">
      <summary>Obtient une courbe nommée brainpoolP192t1.</summary>
      <returns>Une courbe nommée brainpoolP192t1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP224r1">
      <summary>Obtient une courbe nommée brainpoolP224r1.</summary>
      <returns>Une courbe nommée brainpoolP224r1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP224t1">
      <summary>Obtient une courbe nommée brainpoolP224t1.</summary>
      <returns>Une courbe nommée brainpoolP224t1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP256r1">
      <summary>Obtient une courbe nommée brainpoolP256r1.</summary>
      <returns>Une courbe nommée brainpoolP256r1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP256t1">
      <summary>Obtient une courbe nommée brainpoolP256t1.</summary>
      <returns>Une courbe nommée brainpoolP256t1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP320r1">
      <summary>Obtient une courbe nommée brainpoolP320r1.</summary>
      <returns>Une courbe nommée brainpoolP320r1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP320t1">
      <summary>Obtient une courbe nommée brainpoolP320t1.</summary>
      <returns>Une courbe nommée brainpoolP320t1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP384r1">
      <summary>Obtient une courbe nommée brainpoolP384r1.</summary>
      <returns>Une courbe nommée brainpoolP384r1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP384t1">
      <summary>Obtient une courbe nommée brainpoolP384t1.</summary>
      <returns>Une courbe nommée brainpoolP384t1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP512r1">
      <summary>Obtient une courbe nommée brainpoolP512r1.</summary>
      <returns>Une courbe nommée brainpoolP512r1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP512t1">
      <summary>Obtient une courbe nommée brainpoolP512t1.</summary>
      <returns>Une courbe nommée brainpoolP512t1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.nistP256">
      <summary>Obtient une courbe nommée nistP256.</summary>
      <returns>Une courbe nommée nistP256.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.nistP384">
      <summary>Obtient une courbe nommée nistP384.</summary>
      <returns>Une courbe nommée nistP384.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.nistP521">
      <summary>Obtient une courbe nommée nistP521.</summary>
      <returns>Une courbe nommée nistP521.</returns>
    </member>
    <member name="T:System.Security.Cryptography.ECDiffieHellman">
      <summary>Fournit une classe de base abstraite de laquelle les implémentations de l'algorithme ECDH (Elliptic Curve Diffie-Hellman) peuvent dériver. Cette classe fournit le jeu d'opérations de base que toutes les implémentations ECDH doivent prendre en charge.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.ECDiffieHellman" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.Create">
      <summary>Crée une nouvelle instance de l'implémentation par défaut de l'algorithme ECDH (Elliptic Curve Diffie-Hellman).</summary>
      <returns>Une nouvelle instance de l'implémentation par défaut de cette classe.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECCurve)">
      <summary>Crée une nouvelle instance de l’implémentation par défaut de l’algorithme Elliptic Curve Diffie-Hellman (ECDH) avec une nouvelle paire de clés publique/privée générée sur la courbe spécifiée.</summary>
      <param name="curve">La courbe à utiliser pour générer une nouvelle paire de clés publique/privée.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="curve" /> ne valide pas.</exception>
      <returns>Une nouvelle instance de l’implémentation par défaut de l’algorithme Elliptic Curve Diffie-Hellman (ECDH).</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECParameters)">
      <summary>Crée une nouvelle instance de l’implémentation par défaut de l’algorithme ECDH (Elliptic Curve Diffie-Hellman) avec la clé décrite par l’objet <see cref="T:System.Security.Cryptography.ECParameters" /> spécifié.</summary>
      <param name="parameters">Paramètres de l’algorithme ECC (Elliptic Curve Cryptography).</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="parameters" /> ne valide pas.</exception>
      <returns>Une nouvelle instance de l’implémentation par défaut de l’algorithme Elliptic Curve Diffie-Hellman (ECDH).</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.Create(System.String)">
      <summary>Crée une nouvelle instance de l’implémentation spécifiée de l’algorithme ECHD (Elliptic Curve Diffie-Hellman).</summary>
      <param name="algorithm">Nom d’une implémentation de l’algorithme ECDH.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="algorithm" /> a la valeur <see langword="null" />.</exception>
      <returns>Nouvelle instance de l'implémentation spécifiée de cette classe. Si le nom de l’algorithme spécifié ne correspond pas à une implémentation ECDH, cette méthode retourne <see langword="null" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Effectue une dérivation de clés à l’aide d’un algorithme de hachage spécifié.</summary>
      <param name="otherPartyPublicKey">La clé publique de l’autre partie.</param>
      <param name="hashAlgorithm">L’algorithme de hachage à utiliser pour dériver la clé.</param>
      <exception cref="T:System.ArgumentException">La courbe utilisée par <paramref name="otherPartyPublicKey" /> a une taille différente de celle de cette clé.

- ou -

Le paramètre <paramref name="hashAlgorithm" /> ne spécifie pas de hachage.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherPartyPublicKey" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La courbe utilisée par <paramref name="otherPartyPublicKey" /> est différente de celle de cette clé.

- ou -

Cette instance représente uniquement une clé publique.</exception>
      <returns>Hachage du secret partagé.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])">
      <summary>En cas d’implémentation dans une classe dérivée, effectue une dérivation de clés à l’aide d’un algorithme de hachage spécifié avec des données facultatives ajoutées au début ou à la fin.</summary>
      <param name="otherPartyPublicKey">La clé publique de l’autre partie.</param>
      <param name="hashAlgorithm">L’algorithme de hachage à utiliser pour dériver la clé.</param>
      <param name="secretPrepend">Valeur à ajouter avant la clé secrète dérivée avant le hachage.</param>
      <param name="secretAppend">Valeur à ajouter après la clé secrète dérivée avant le hachage.</param>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
      <exception cref="T:System.ArgumentException">La courbe utilisée par <paramref name="otherPartyPublicKey" /> a une taille différente de celle de cette clé.

- ou -

Le paramètre <paramref name="hashAlgorithm" /> ne spécifie pas de hachage.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherPartyPublicKey" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La courbe utilisée par <paramref name="otherPartyPublicKey" /> est différente de celle de cette clé.

- ou -

Cette instance représente uniquement une clé publique.</exception>
      <returns>Hachage du secret partagé après l’ajout au début ou à la fin de données comme demandé.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
      <summary>Effectue une dérivation de clés à l’aide d’un algorithme HMAC (Hash-based Message Authentication Code) spécifié.</summary>
      <param name="otherPartyPublicKey">La clé publique de l’autre partie.</param>
      <param name="hashAlgorithm">L’algorithme de hachage à utiliser pour dériver la clé.</param>
      <param name="hmacKey">La clé du HMAC.</param>
      <exception cref="T:System.ArgumentException">La courbe utilisée par <paramref name="otherPartyPublicKey" /> a une taille différente de celle de cette clé.

- ou -

Le paramètre <paramref name="hashAlgorithm" /> ne spécifie pas de hachage.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherPartyPublicKey" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La courbe utilisée par <paramref name="otherPartyPublicKey" /> est différente de celle de cette clé.

- ou -

Cette instance représente uniquement une clé publique.</exception>
      <returns>HMAC du secret partagé.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[],System.Byte[])">
      <summary>En cas d’implémentation dans une classe dérivée, effectue une dérivation de clés à l’aide d’un algorithme HMAC (Hash-based Message Authentication Code) spécifié avec des données facultatives ajoutées au début ou à la fin.</summary>
      <param name="otherPartyPublicKey">La clé publique de l’autre partie.</param>
      <param name="hashAlgorithm">L’algorithme de hachage à utiliser pour dériver la clé.</param>
      <param name="hmacKey">La clé du HMAC.</param>
      <param name="secretPrepend">Valeur à ajouter avant la clé secrète dérivée avant le hachage.</param>
      <param name="secretAppend">Valeur à ajouter après la clé secrète dérivée avant le hachage.</param>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
      <exception cref="T:System.ArgumentException">La courbe utilisée par <paramref name="otherPartyPublicKey" /> a une taille différente de celle de cette clé.

- ou -

Le paramètre <paramref name="hashAlgorithm" /> ne spécifie pas de hachage.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherPartyPublicKey" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La courbe utilisée par <paramref name="otherPartyPublicKey" /> est différente de celle de cette clé.

- ou -

Cette instance représente uniquement une clé publique.</exception>
      <returns>HMAC du secret partagé après l’ajout au début ou à la fin de données comme demandé.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyMaterial(System.Security.Cryptography.ECDiffieHellmanPublicKey)">
      <summary>En cas d’implémentation dans une classe dérivée, effectue une dérivation de clés sur le secret partagé.</summary>
      <param name="otherPartyPublicKey">La clé publique de l’autre partie.</param>
      <exception cref="T:System.ArgumentException">La courbe utilisée par <paramref name="otherPartyPublicKey" /> a une taille différente de celle de cette clé.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherPartyPublicKey" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La courbe utilisée par <paramref name="otherPartyPublicKey" /> est différente de celle de cette clé.

- ou -

Cette instance représente uniquement une clé publique.</exception>
      <returns>Résultat de la fonction de dérivation de clés, utilisant le secret partagé comme entrée.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyTls(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Byte[],System.Byte[])">
      <summary>En cas d’implémentation dans une classe dérivée, effectue une dérivation de clés à l’aide de la fonction pseudo-aléatoire (PRF) du protocole TLS (Transport Layer Security) 1.1.</summary>
      <param name="otherPartyPublicKey">La clé publique de l’autre partie.</param>
      <param name="prfLabel">L’étiquette PRF encodée en ASCII.</param>
      <param name="prfSeed">La valeur de départ PRF à 64 octets.</param>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
      <exception cref="T:System.ArgumentException">La courbe utilisée par <paramref name="otherPartyPublicKey" /> a une taille différente de celle de cette clé.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherPartyPublicKey" />, <paramref name="prfLabel" /> ou <paramref name="prfSeed" /> est <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="prfSeed" /> ne compte pas exactement 64 octets.

- ou -

La courbe utilisée par <paramref name="otherPartyPublicKey" /> est différente de celle de cette clé.

- ou -

Cette instance représente uniquement une clé publique.</exception>
      <returns>48 premiers octets de la fonction pseudo-aléatoire (PRF) du protocole TLS 1.1, utilisant le secret partagé comme clé.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ExportECPrivateKey">
      <summary>Exporte la clé actuelle au format ECPrivateKey.</summary>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
      <returns>Tableau d’octets contenant la représentation ECPrivateKey de cette clé.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ExportExplicitParameters(System.Boolean)">
      <summary>En cas de substitution dans une classe dérivée, exporte les informations de clé publique ou des clés publique et privée d’une clé <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> valide à l’aide du formulaire de courbe explicite vers une structure <see cref="T:System.Security.Cryptography.ECParameters" /> pour qu’elle puisse être passée à la méthode <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />.</summary>
      <param name="includePrivateParameters">
        <see langword="true" /> pour inclure les paramètres privés ; sinon <see langword="false" />.</param>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
      <returns>Objet représentant le point sur la courbe pour cette clé, en utilisant le format de la courbe explicite.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ExportParameters(System.Boolean)">
      <summary>En cas de substitution dans une classe dérivée, exporte les informations de clé publique ou des clés publique et privée d’une clé <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> valide vers une structure <see cref="T:System.Security.Cryptography.ECParameters" /> pour qu’elle puisse être passée à la méthode <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />.</summary>
      <param name="includePrivateParameters">
        <see langword="true" /> pour inclure les paramètres privés. Sinon, <see langword="false" /> pour inclure les paramètres publics uniquement.</param>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
      <returns>Objet représentant le point sur la courbe pour cette clé. Il peut être passé à la méthode <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.FromXmlString(System.String)">
      <summary>Cette méthode lève une exception dans tous les cas.</summary>
      <param name="xmlString">Chaîne XML à utiliser pour reconstruire l'objet <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" />.</param>
      <exception cref="T:System.NotImplementedException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.GenerateKey(System.Security.Cryptography.ECCurve)">
      <summary>En cas de substitution dans une classe dérivée, génère une nouvelle paire de clés publique/privée éphémère pour la courbe spécifiée.</summary>
      <param name="curve">La courbe utilisée pour générer une paire de clés publique/privée éphémère.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="curve" /> ne valide pas.</exception>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportECPrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure ECPrivateKey, en remplaçant les clés de cet objet.</summary>
      <param name="source">Octets d’une structure ECPrivateKey dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 ECPrivateKey encodée en ASN.1-BER.

- ou -

L’importation de clés a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure PKCS#8 EncryptedPrivateKeyInfo après le déchiffrement avec un mot de passe basé sur l’octet, en remplaçant les clés de cet objet.</summary>
      <param name="passwordBytes">Octets à utiliser comme mot de passe lors du déchiffrement du matériel de clé.</param>
      <param name="source">Octets d’une structure PKCS#8 EncryptedPrivateKeyInfo dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le mot de passe est incorrect.

- ou -

Le contenu de <paramref name="source" /> indique que la fonction de dérivation de clés (KDF) à appliquer est la fonction KDF PKCS#12 existante, qui nécessite des mots de passe basés sur <see cref="T:System.Char" />.

- ou -

Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 EncryptedPrivateKeyInfo encodée en ASN.1-BER.

- ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

- ou -

Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

- ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure PKCS#8 EncryptedPrivateKeyInfo après le déchiffrement avec un mot de passe basé sur char, en remplaçant les clés de cet objet.</summary>
      <param name="password">Mot de passe à utiliser pour déchiffrer le matériel de clé.</param>
      <param name="source">Octets d’une structure PKCS#8 EncryptedPrivateKeyInfo dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le mot de passe est incorrect.

- ou -

Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 EncryptedPrivateKeyInfo encodée en ASN.1-BER.

- ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

- ou -

Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

- ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportFromEncryptedPem(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte})">
      <summary>Importe une clé privée encodée au format PEM RFC 7468 chiffrée, en remplaçant les clés de cet objet.</summary>
      <param name="input">Texte PEM de la clé chiffrée à importer.</param>
      <param name="passwordBytes">Octets à utiliser comme mot de passe lors du déchiffrement du matériel de clé.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="input" /> ne contient pas de clé encodée au format PEM avec une étiquette reconnue.

- ou -

<paramref name="input" /> contient plusieurs clés encodées au format PEM avec une étiquette reconnue.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le mot de passe est incorrect.

- ou -

Le contenu décodé en base 64 du texte PEM à partir de <paramref name="input" /> ne représente pas une structure de PKCS#8 EncryptedPrivateKeyInfo encodée en ASN.1-BER.

- ou -

Le contenu décodé en base 64 du texte PEM à partir de <paramref name="input" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

- ou -

Le contenu décodé en base 64 du texte PEM à partir de <paramref name="input" /> représente la clé dans un format qui n’est pas pris en charge.

- ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportFromEncryptedPem(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>Importe une clé privée encodée au format PEM RFC 7468 chiffrée, en remplaçant les clés de cet objet.</summary>
      <param name="input">Texte PEM de la clé chiffrée à importer.</param>
      <param name="password">Mot de passe à utiliser pour déchiffrer le matériel de clé.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="input" /> ne contient pas de clé encodée au format PEM avec une étiquette reconnue.

- ou -

<paramref name="input" /> contient plusieurs clés encodées au format PEM avec une étiquette reconnue.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le mot de passe est incorrect.

- ou -

Le contenu décodé en base 64 du texte PEM à partir de <paramref name="input" /> ne représente pas une structure de PKCS#8 EncryptedPrivateKeyInfo encodée en ASN.1-BER.

- ou -

Le contenu décodé en base 64 du texte PEM à partir de <paramref name="input" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

- ou -

Le contenu décodé en base 64 du texte PEM à partir de <paramref name="input" /> représente la clé dans un format qui n’est pas pris en charge.

- ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportFromPem(System.ReadOnlySpan{System.Char})">
      <summary>Importe une clé encodée au format PEM RFC 7468, en remplaçant les clés de cet objet.</summary>
      <param name="input">Texte PEM de la clé à importer.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="input" /> ne contient pas de clé encodée au format PEM avec une étiquette reconnue.

- ou -

<paramref name="input" /> contient plusieurs clés encodées au format PEM avec une étiquette reconnue.

- ou -

<paramref name="input" /> contient une clé encodée en PEM chiffrée.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)">
      <summary>En cas de substitution dans une classe dérivée, importe les paramètres spécifiés pour une <see cref="T:System.Security.Cryptography.ECCurve" /> en tant que clé éphémère dans l’objet <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> actuel.</summary>
      <param name="parameters">Paramètres de la courbe à importer.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="parameters" /> ne valide pas.</exception>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure PKCS#8 PrivateKeyInfo après le déchiffrement, en remplaçant les clés de cet objet.</summary>
      <param name="source">Octets d’une structure PKCS#8 PrivateKeyInfo dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 PrivateKeyInfo encodée en ASN.1-BER.

- ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

- ou -

Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

- ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportSubjectPublicKeyInfo(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la clé publique à partir d’une structure X.509 SubjectPublicKeyInfo après le déchiffrement, en remplaçant les clés de cet objet.</summary>
      <param name="source">Octets d’une structure X.509 SubjectPublicKeyInfo dans l’encodage ASN.1-DER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le contenu de <paramref name="source" /> ne représente pas une structure X.509 SubjectPublicKeyInfo encodée en ASN.1-DER.

- ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

- ou -

Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

- ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ToXmlString(System.Boolean)">
      <summary>Cette méthode lève une exception dans tous les cas.</summary>
      <param name="includePrivateParameters">
        <see langword="true" /> pour inclure les paramètres privés ; sinon <see langword="false" />.</param>
      <exception cref="T:System.NotImplementedException">Dans tous les cas.</exception>
      <returns>Cette méthode ne retourne pas de valeur.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.TryExportECPrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle dans le format <see langword="ECPrivateKey" /> dans une mémoire tampon fournie.</summary>
      <param name="destination">Étendue d’octets pour recevoir les données <see langword="ECPrivateKey" />.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#8 EncryptedPrivateKeyInfo dans une mémoire tampon fournie, à l’aide d’un mot de passe basé sur l’octet.</summary>
      <param name="passwordBytes">Octets à utiliser comme mot de passe lors du chiffrement du matériel de clé.</param>
      <param name="pbeParameters">Paramètres de chiffrement par mot de passe à utiliser lors du chiffrement du matériel de clé.</param>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#8 EncryptedPrivateKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.

- ou -

<paramref name="pbeParameters" /> indique que <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" /> doit être utilisé, ce qui nécessite des mots de passe basés sur <see cref="T:System.Char" />.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#8 EncryptedPrivateKeyInfo dans une mémoire tampon fournie, à l’aide d’un mot de passe basé sur char.</summary>
      <param name="password">Mot de passe à utiliser lors du chiffrement du matériel de clé.</param>
      <param name="pbeParameters">Paramètres de chiffrement par mot de passe à utiliser lors du chiffrement du matériel de clé.</param>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#8 EncryptedPrivateKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.TryExportPkcs8PrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#8 PrivateKeyInfo dans une mémoire tampon fournie.</summary>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#8 PrivateKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.TryExportSubjectPublicKeyInfo(System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format X.509 SubjectPublicKeyInfo dans une mémoire tampon fournie.</summary>
      <param name="destination">Intervalle d’octets pour recevoir les données X.509 SubjectPublicKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECDiffieHellman.KeyExchangeAlgorithm">
      <summary>Obtient le nom de l'algorithme d'échange de clés.</summary>
      <returns>Nom de l'algorithme d'échange de clés.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECDiffieHellman.PublicKey">
      <summary>Obtient la clé publique utilisée par l'instance ECDH (Elliptic Curve Diffie-Hellman) actuelle.</summary>
      <returns>Partie publique de la paire de clés ECDH utilisée par cette instance <see cref="T:System.Security.Cryptography.ECDiffieHellman" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECDiffieHellman.SignatureAlgorithm">
      <summary>Obtient le nom de l'algorithme de signature.</summary>
      <returns>Toujours <see langword="null" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.ECDiffieHellmanPublicKey">
      <summary>Fournit une classe de base abstraite dont toutes les implémentations <see cref="T:System.Security.Cryptography.ECDiffieHellmanCngPublicKey" /> doivent hériter.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.#ctor(System.Byte[])">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" />.</summary>
      <param name="keyBlob">Tableau d'octets qui représente un objet <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="keyBlob" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.Dispose">
      <summary>Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Security.Cryptography.ECDiffieHellman" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.Dispose(System.Boolean)">
      <summary>Libère les ressources non managées utilisées par la classe <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> et libère éventuellement les ressources managées.</summary>
      <param name="disposing">
        <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.ExportExplicitParameters">
      <summary>En cas de substitution dans une classe dérivée, exporte les <see cref="T:System.Security.Cryptography.ECParameters" /> explicites pour un objet <see cref="T:System.Security.Cryptography.ECCurve" />.</summary>
      <exception cref="T:System.NotSupportedException">Une classe dérivée doit remplacer cette méthode.</exception>
      <returns>Objet représentant le point sur la courbe pour cette clé, en utilisant le format de la courbe explicite.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.ExportParameters">
      <summary>En cas de substitution dans une classe dérivée, exporte les <see cref="T:System.Security.Cryptography.ECParameters" /> nommés ou explicites pour un objet <see cref="T:System.Security.Cryptography.ECCurve" />.</summary>
      <exception cref="T:System.NotSupportedException">Une classe dérivée doit remplacer cette méthode.</exception>
      <returns>Objet représentant le point sur la courbe pour cette clé.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.ToByteArray">
      <summary>Sérialise le BLOB de clé <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" /> en un tableau d'octets.</summary>
      <returns>Un tableau d'octets qui contient la clé publique ECDH (Elliptic Curve Diffie-Hellman) sérialisée.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.ToXmlString">
      <summary>Sérialise la clé publique <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" /> en une chaîne XML.</summary>
      <returns>Une chaîne XML qui contient la clé publique ECDH (Elliptic Curve Diffie-Hellman) sérialisée.</returns>
    </member>
    <member name="T:System.Security.Cryptography.ECDsa">
      <summary>Fournit une classe de base abstraite qui encapsule l’algorithme ECDSA (Elliptic Curve Digital Signature Algorithm).</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.ECDsa" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.Create">
      <summary>Crée une nouvelle instance de l'implémentation par défaut de l'algorithme ECDSA (Elliptic Curve Digital Signature Algorithm).</summary>
      <returns>Nouvelle instance de l'implémentation par défaut (<see cref="T:System.Security.Cryptography.ECDsaCng" />) de cette classe.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.Create(System.Security.Cryptography.ECCurve)">
      <summary>Crée une nouvelle instance de l’implémentation par défaut de l’algorithme Elliptic Curve Digital Signature Algorithm (ECDSA) avec une nouvelle clé générée sur la courbe spécifiée.</summary>
      <param name="curve">La courbe à utiliser pour la génération de clé.</param>
      <returns>Nouvelle instance de l'implémentation par défaut (<see cref="T:System.Security.Cryptography.ECDsaCng" />) de cette classe.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.Create(System.Security.Cryptography.ECParameters)">
      <summary>Crée une nouvelle instance de l’implémentation par défaut de l’algorithme Elliptic Curve Digital Signature Algorithm (ECDSA) en utilisant les paramètres spécifiés en tant que clé.</summary>
      <param name="parameters">Les paramètres représentant la clé à utiliser.</param>
      <returns>Nouvelle instance de l'implémentation par défaut (<see cref="T:System.Security.Cryptography.ECDsaCng" />) de cette classe.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.Create(System.String)">
      <summary>Crée une nouvelle instance de l'implémentation spécifiée de l'algorithme ECDSA (Elliptic Curve Digital Signature Algorithm).</summary>
      <param name="algorithm">Le nom d'une implémentation ECDSA. Les chaînes suivantes font toutes référence à la même implémentation, qui est la seule implémentation actuellement prise en charge dans le .NET Framework : 
- "ECDsa" 
- "ECDsaCng" 
- "System.Security.Cryptography.ECDsaCng" 
Vous pouvez également fournir le nom d'une implémentation ECDSA personnalisée.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="algorithm" /> a la valeur <see langword="null" />.</exception>
      <returns>Nouvelle instance de l'implémentation spécifiée de cette classe. Si le nom de l'algorithme spécifié n'est pas mappé avec une implémentation ECDSA, cette méthode retourne <see langword="null" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ExportECPrivateKey">
      <summary>Exporte la clé actuelle au format ECPrivateKey.</summary>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
      <returns>Tableau d’octets contenant la représentation ECPrivateKey de cette clé.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ExportExplicitParameters(System.Boolean)">
      <summary>En cas de substitution dans une classe dérivée, exporte les paramètres explicites pour une courbe elliptique.</summary>
      <param name="includePrivateParameters">
        <see langword="true" /> pour inclure les paramètres privés ; sinon <see langword="false" />.</param>
      <exception cref="T:System.NotSupportedException">Une classe dérivée doit remplacer cette méthode.</exception>
      <returns>Les paramètres représentant le point sur la courbe pour cette clé, en utilisant le format de la courbe explicite.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ExportParameters(System.Boolean)">
      <summary>En cas de substitution dans une classe dérivée, exporte les paramètres nommés ou explicites pour une courbe elliptique. Si la courbe a un nom, le champ <see cref="F:System.Security.Cryptography.ECParameters.Curve" /> contient les paramètres de la courbe nommée, sinon il contient des paramètres explicites.</summary>
      <param name="includePrivateParameters">
        <see langword="true" /> pour inclure les paramètres privés ; sinon <see langword="false" />.</param>
      <exception cref="T:System.NotSupportedException">Une classe dérivée doit remplacer cette méthode.</exception>
      <returns>Les paramètres représentant le point sur la courbe pour cette clé.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.FromXmlString(System.String)">
      <summary>Cette méthode lève une exception dans tous les cas.</summary>
      <param name="xmlString">Chaîne XML à utiliser pour reconstruire l'objet <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" />.</param>
      <exception cref="T:System.NotImplementedException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.GenerateKey(System.Security.Cryptography.ECCurve)">
      <summary>En cas de substitution dans une classe dérivée, génère une nouvelle paire de clés publique/privée éphémère pour la courbe spécifiée, remplaçant la clé actuelle.</summary>
      <param name="curve">La courbe à utiliser pour générer la clé.</param>
      <exception cref="T:System.NotSupportedException">Une classe dérivée doit remplacer cette méthode.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.GetMaxSignatureSize(System.Security.Cryptography.DSASignatureFormat)">
      <summary>Obtient la plus grande taille, en octets, pour une signature produite par cette clé dans le format indiqué.</summary>
      <param name="signatureFormat">Format d’encodage d’une signature.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> n’est pas un format connu.</exception>
      <returns>Taille maximale, en octets, d’une signature produite par cette clé dans le format indiqué.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.HashData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>En cas de substitution dans une classe dérivée, calcule la valeur de hachage de la partie indiquée d'un tableau d'octets à l'aide de l'algorithme de hachage spécifié.</summary>
      <param name="data">Données à hacher.</param>
      <param name="offset">Index du premier octet dans <paramref name="data" /> à hacher.</param>
      <param name="count">Nombre d'octets à hacher.</param>
      <param name="hashAlgorithm">Algorithme à utiliser pour hacher les données.</param>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
      <returns>Données hachées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.HashData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)">
      <summary>En cas de substitution dans une classe dérivée, calcule la valeur de hachage du flux binaire indiqué à l'aide de l'algorithme de hachage spécifié.</summary>
      <param name="data">Flux binaire à hacher.</param>
      <param name="hashAlgorithm">Algorithme à utiliser pour hacher les données.</param>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
      <returns>Données hachées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportECPrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure ECPrivateKey, en remplaçant les clés de cet objet.</summary>
      <param name="source">Octets d’une structure ECPrivateKey dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 ECPrivateKey encodée en ASN.1-BER.

- ou -

L’importation de clés a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure PKCS#8 EncryptedPrivateKeyInfo après le déchiffrement avec un mot de passe basé sur l’octet, en remplaçant les clés de cet objet.</summary>
      <param name="passwordBytes">Octets à utiliser comme mot de passe lors du déchiffrement du matériel de clé.</param>
      <param name="source">Octets d’une structure PKCS#8 EncryptedPrivateKeyInfo dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le mot de passe est incorrect.

- ou -

Le contenu de <paramref name="source" /> indique que la fonction de dérivation de clés (KDF) à appliquer est la fonction KDF PKCS#12 existante, qui nécessite des mots de passe basés sur <see cref="T:System.Char" />.

- ou -

Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 EncryptedPrivateKeyInfo encodée en ASN.1-BER.

- ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

- ou -

Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

- ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure PKCS#8 EncryptedPrivateKeyInfo après le déchiffrement avec un mot de passe basé sur char, en remplaçant les clés de cet objet.</summary>
      <param name="password">Mot de passe à utiliser pour déchiffrer le matériel de clé.</param>
      <param name="source">Octets d’une structure PKCS#8 EncryptedPrivateKeyInfo dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le mot de passe est incorrect.

- ou -

Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 EncryptedPrivateKeyInfo encodée en ASN.1-BER.

- ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

- ou -

Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

- ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportFromEncryptedPem(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte})">
      <summary>Importe une clé privée encodée au format PEM RFC 7468 chiffrée, en remplaçant les clés de cet objet.</summary>
      <param name="input">Texte PEM de la clé chiffrée à importer.</param>
      <param name="passwordBytes">Octets à utiliser comme mot de passe lors du déchiffrement du matériel de clé.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="input" /> ne contient pas de clé encodée au format PEM avec une étiquette reconnue.

- ou -

<paramref name="input" /> contient plusieurs clés encodées au format PEM avec une étiquette reconnue.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le mot de passe est incorrect.

- ou - 
Le contenu décodé en base 64 du texte PEM à partir de <paramref name="input" /> ne représente pas une structure de PKCS#8 EncryptedPrivateKeyInfo encodée en ASN.1-BER.

- ou -

Le contenu décodé en base 64 du texte PEM à partir de <paramref name="input" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

- ou -

Le contenu décodé en base 64 du texte PEM à partir de <paramref name="input" /> représente la clé dans un format qui n’est pas pris en charge.

- ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportFromEncryptedPem(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>Importe une clé privée encodée au format PEM RFC 7468 chiffrée, en remplaçant les clés de cet objet.</summary>
      <param name="input">Texte PEM de la clé chiffrée à importer.</param>
      <param name="password">Mot de passe à utiliser pour déchiffrer le matériel de clé.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="input" /> ne contient pas de clé encodée au format PEM avec une étiquette reconnue.

- ou -

<paramref name="input" /> contient plusieurs clés encodées au format PEM avec une étiquette reconnue.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le mot de passe est incorrect.

- ou -

Le contenu décodé en base 64 du texte PEM à partir de <paramref name="input" /> ne représente pas une structure de PKCS#8 EncryptedPrivateKeyInfo encodée en ASN.1-BER.

- ou -

Le contenu décodé en base 64 du texte PEM à partir de <paramref name="input" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

- ou -

Le contenu décodé en base 64 du texte PEM à partir de <paramref name="input" /> représente la clé dans un format qui n’est pas pris en charge.

- ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportFromPem(System.ReadOnlySpan{System.Char})">
      <summary>Importe une clé encodée au format PEM RFC 7468, en remplaçant les clés de cet objet.</summary>
      <param name="input">Texte PEM de la clé à importer.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="input" /> ne contient pas de clé encodée au format PEM avec une étiquette reconnue.

- ou -

<paramref name="input" /> contient plusieurs clés encodées au format PEM avec une étiquette reconnue.

- ou -

<paramref name="input" /> contient une clé encodée au format PEM chiffrée.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportParameters(System.Security.Cryptography.ECParameters)">
      <summary>En cas de remplacement dans une classe dérivée, importe les paramètres spécifiés.</summary>
      <param name="parameters">Les paramètres de la courbe.</param>
      <exception cref="T:System.NotSupportedException">Une classe dérivée doit remplacer cette méthode.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure PKCS#8 PrivateKeyInfo après le déchiffrement, en remplaçant les clés de cet objet.</summary>
      <param name="source">Octets d’une structure PKCS#8 PrivateKeyInfo dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 PrivateKeyInfo encodée en ASN.1-BER.

- ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

- ou -

Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

- ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportSubjectPublicKeyInfo(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la clé publique à partir d’une structure X.509 SubjectPublicKeyInfo après le déchiffrement, en remplaçant les clés de cet objet.</summary>
      <param name="source">Octets d’une structure X.509 SubjectPublicKeyInfo dans l’encodage ASN.1-DER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le contenu de <paramref name="source" /> ne représente pas une structure X.509 SubjectPublicKeyInfo encodée en ASN.1-DER.

- ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

- ou -

Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

- ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Calcule la valeur de hachage d'une partie du tableau d'octets indiqué à l'aide de l'algorithme de hachage spécifié et signe la valeur de hachage obtenue.</summary>
      <param name="data">Données d'entrée pour lesquelles calculer le hachage.</param>
      <param name="offset">Décalage dans le tableau à partir duquel l’utilisation de données commence.</param>
      <param name="count">Nombre d'octets dans le tableau à utiliser comme données.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="count" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="offset" /> + <paramref name="count" /> - 1 génère un index qui dépasse la limite supérieure de <paramref name="data" />.</exception>
      <returns>Signature ECDSA pour les données spécifiées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Calcule la valeur de hachage des données spécifiées et la signe à l’aide du format de signature spécifié.</summary>
      <param name="data">Données à signer.</param>
      <param name="offset">Offset dans <paramref name="data" /> partir duquel commencer le hachage.</param>
      <param name="count">Nombre d’octets à lire à partir de <paramref name="data" />.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <param name="signatureFormat">Format d’encodage à utiliser pour la signature.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> n’est pas un format connu.
 
- ou - 
 <paramref name="offset" /> est inférieur à zéro.
 
- ou - 
 <paramref name="count" /> est inférieur à zéro.
 
- ou - 
 <paramref name="offset" /> + <paramref name="count" /> - 1 génère un index qui dépasse la limite supérieure de <paramref name="data" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> a un <see langword="null" /> ou <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> vide.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de hachage ou de signature.</exception>
      <returns>Signature ECDSA pour les données spécifiées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignData(System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Calcule la valeur de hachage du tableau d'octets indiqué à l'aide de l'algorithme de hachage spécifié et signe la valeur de hachage obtenue.</summary>
      <param name="data">Données d'entrée pour lesquelles calculer le hachage.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <returns>Signature ECDSA pour les données spécifiées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignData(System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Calcule la valeur de hachage des données spécifiées et la signe à l’aide du format de signature spécifié.</summary>
      <param name="data">Données à signer.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <param name="signatureFormat">Format d’encodage à utiliser pour la signature.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> n’est pas un format connu.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> a une <see langword="null" /> ou <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> vide.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de hachage ou de signature.</exception>
      <returns>Signature ECDSA pour les données spécifiées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Calcule la valeur de hachage du flux indiqué à l'aide de l'algorithme de hachage spécifié et signe la valeur de hachage obtenue.</summary>
      <param name="data">Flux d'entrée pour lequel calculer le hachage.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <returns>Signature ECDSA pour les données spécifiées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Calcule la valeur de hachage des données spécifiées et la signe à l’aide du format de signature spécifié.</summary>
      <param name="data">Données à signer.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <param name="signatureFormat">Format d’encodage à utiliser pour la signature.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> n’est pas un format connu.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> a une <see langword="null" /> ou <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> vide.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de hachage ou de signature.</exception>
      <returns>Signature ECDSA pour les données spécifiées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignDataCore(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Calcule la valeur de hachage des données spécifiées et la signe à l’aide du format de signature spécifié.</summary>
      <param name="data">Données à signer.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <param name="signatureFormat">Format d’encodage à utiliser pour la signature.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de hachage ou de signature.</exception>
      <returns>Signature ECDSA pour les données spécifiées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignDataCore(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Calcule la valeur de hachage des données spécifiées et la signe à l’aide du format de signature spécifié.</summary>
      <param name="data">Données à signer.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <param name="signatureFormat">Format d’encodage à utiliser pour la signature.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de hachage ou de signature.</exception>
      <returns>Signature ECDSA pour les données spécifiées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignHash(System.Byte[])">
      <summary>Génère une signature numérique pour la valeur de hachage spécifiée.</summary>
      <param name="hash">Valeur de hachage des données signées.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="hash" /> a la valeur <see langword="null" />.</exception>
      <returns>Signature numérique pour la valeur de hachage spécifiée.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignHash(System.Byte[],System.Security.Cryptography.DSASignatureFormat)">
      <summary>Calcule la signature ECDSA pour la valeur de hachage spécifiée dans le format indiqué.</summary>
      <param name="hash">Valeur de hachage à signer.</param>
      <param name="signatureFormat">Format d’encodage à utiliser pour la signature.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="hash" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> n’est pas un format connu.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de signature.</exception>
      <returns>Signature ECDSA pour les données spécifiées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignHashCore(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.DSASignatureFormat)">
      <summary>Calcule la signature ECDSA pour la valeur de hachage spécifiée dans le format indiqué.</summary>
      <param name="hash">Valeur de hachage à signer.</param>
      <param name="signatureFormat">Format d’encodage à utiliser pour la signature.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de signature.</exception>
      <returns>Signature ECDSA pour les données spécifiées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ToXmlString(System.Boolean)">
      <summary>Cette méthode lève une exception dans tous les cas.</summary>
      <param name="includePrivateParameters">
        <see langword="true" /> pour inclure les paramètres privés ; sinon <see langword="false" />.</param>
      <exception cref="T:System.NotImplementedException">Dans tous les cas.</exception>
      <returns>Cette méthode ne retourne pas de valeur.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TryExportECPrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format ECPrivateKey dans une mémoire tampon fournie.</summary>
      <param name="destination">Étendue d’octets devant recevoir les données ECPrivateKey.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#8 EncryptedPrivateKeyInfo dans une mémoire tampon fournie, à l’aide d’un mot de passe basé sur l’octet.</summary>
      <param name="passwordBytes">Octets à utiliser comme mot de passe lors du chiffrement du matériel de clé.</param>
      <param name="pbeParameters">Paramètres de chiffrement par mot de passe à utiliser lors du chiffrement du matériel de clé.</param>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#8 EncryptedPrivateKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.

- ou -

<paramref name="pbeParameters" /> indique que <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" /> doit être utilisé, ce qui nécessite des mots de passe basés sur <see cref="T:System.Char" />.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#8 EncryptedPrivateKeyInfo dans une mémoire tampon fournie, à l’aide d’un mot de passe basé sur char.</summary>
      <param name="password">Mot de passe à utiliser lors du chiffrement du matériel de clé.</param>
      <param name="pbeParameters">Paramètres de chiffrement par mot de passe à utiliser lors du chiffrement du matériel de clé.</param>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#8 EncryptedPrivateKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TryExportPkcs8PrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#8 PrivateKeyInfo dans une mémoire tampon fournie.</summary>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#8 PrivateKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TryExportSubjectPublicKeyInfo(System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format X.509 SubjectPublicKeyInfo dans une mémoire tampon fournie.</summary>
      <param name="destination">Intervalle d’octets pour recevoir les données X.509 SubjectPublicKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TryHashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Int32@)">
      <summary>Tente de calculer la valeur de hachage de la plage d’octets en lecture seule spécifiée dans la destination fournie en utilisant l’algorithme de hachage spécifié.</summary>
      <param name="data">Données à hacher.</param>
      <param name="destination">Mémoire tampon utilisée pour recevoir la valeur de hachage.</param>
      <param name="hashAlgorithm">Algorithme à utiliser pour hacher les données.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, nombre total d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="false" /> si la destination <paramref name="destination" /> n'est pas assez longue pour recevoir la valeur de hachage.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TrySignData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Int32@)">
      <summary>Tente de calculer la signature numérique ECDSA de la plage d'octets en lecture seule spécifiée dans la destination fournie en utilisant l'algorithme de hachage spécifié et la clé actuelle.</summary>
      <param name="data">Données à signer.</param>
      <param name="destination">Mémoire tampon utilisée pour recevoir la signature.</param>
      <param name="hashAlgorithm">Algorithme à utiliser pour hacher les données en vue de la signature.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, nombre total d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="false" /> si la destination <paramref name="destination" /> n’est pas assez longue pour recevoir la signature.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TrySignData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat,System.Int32@)">
      <summary>Tente de créer la signature ECDSA pour les données spécifiées dans le format indiqué dans la mémoire tampon fournie.</summary>
      <param name="data">Données à hacher et à signer.</param>
      <param name="destination">Mémoire tampon utilisée pour recevoir la signature.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <param name="signatureFormat">Format d’encodage à utiliser pour la signature.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> n’est pas un format connu.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> a une <see langword="null" /> ou <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> vide.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de signature.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la signature ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TrySignDataCore(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat,System.Int32@)">
      <summary>Tente de créer la signature ECDSA pour les données spécifiées dans le format indiqué dans la mémoire tampon fournie.</summary>
      <param name="data">Données à hacher et à signer.</param>
      <param name="destination">Mémoire tampon utilisée pour recevoir la signature.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <param name="signatureFormat">Format d’encodage à utiliser pour la signature.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de signature.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la signature ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TrySignHash(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@)">
      <summary>Tente de calculer la signature numérique ECDSA de la plage d’octets en lecture seule spécifiée représentant un hachage de données dans la destination fournie en utilisant la clé actuelle.</summary>
      <param name="hash">Valeur de hachage des données signées.</param>
      <param name="destination">Mémoire tampon utilisée pour recevoir la signature.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, nombre total d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="false" /> si la destination <paramref name="destination" /> n’est pas assez longue pour recevoir la signature.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TrySignHash(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.DSASignatureFormat,System.Int32@)">
      <summary>Tente de créer la signature ECDSA pour la valeur de hachage spécifiée dans le format indiqué dans la mémoire tampon fournie.</summary>
      <param name="hash">Valeur de hachage à signer.</param>
      <param name="destination">Mémoire tampon utilisée pour recevoir la signature.</param>
      <param name="signatureFormat">Format d’encodage à utiliser pour la signature.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> n’est pas un format connu.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de signature.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la signature ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TrySignHashCore(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.DSASignatureFormat,System.Int32@)">
      <summary>Tente de créer la signature ECDSA pour la valeur de hachage spécifiée dans le format indiqué dans la mémoire tampon fournie.</summary>
      <param name="hash">Valeur de hachage à signer.</param>
      <param name="destination">Mémoire tampon utilisée pour recevoir la signature.</param>
      <param name="signatureFormat">Format d’encodage à utiliser pour la signature.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de signature.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la signature ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyData(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Vérifie qu'une signature numérique est adaptée à la clé actuelle et aux données fournies à l’aide d’un algorithme de hachage spécifié.</summary>
      <param name="data">Données signées.</param>
      <param name="signature">Données de la signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage des données.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="signature" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <returns>
        <see langword="true" /> si la signature est valide ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyData(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Vérifie qu’une signature numérique est valide pour les données fournies.</summary>
      <param name="data">Données signées.</param>
      <param name="signature">Signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour hacher les données pour le processus de vérification.</param>
      <param name="signatureFormat">Format d’encodage de <paramref name="signature" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ou <paramref name="signature" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> n’est pas un format connu.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> a une <see langword="null" /> ou <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> vide.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de hachage ou de vérification.</exception>
      <returns>
        <see langword="true" /> si la signature numérique est valide pour les données fournies ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyData(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Vérifie qu’une signature numérique est adaptée à la clé actuelle et la partie de données fournie à l’aide d’un algorithme de hachage spécifié.</summary>
      <param name="data">Données signées.</param>
      <param name="offset">Index de départ à partir duquel calculer le hachage.</param>
      <param name="count">Nombre d’octets à hacher.</param>
      <param name="signature">Données de la signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage des données.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="signature" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="count" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="offset" /> + <paramref name="count" /> - 1 génère un index qui dépasse la limite supérieure de <paramref name="data" />.</exception>
      <returns>
        <see langword="true" /> si la signature est valide ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyData(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Vérifie qu’une signature numérique est valide pour les données fournies.</summary>
      <param name="data">Tableau qui contient les données signées.</param>
      <param name="offset">Index de départ de la partie signée de <paramref name="data" />.</param>
      <param name="count">Nombre d’octets dans <paramref name="data" /> qui ont été signés.</param>
      <param name="signature">Signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour hacher les données pour le processus de vérification.</param>
      <param name="signatureFormat">Format d’encodage de <paramref name="signature" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ou <paramref name="signature" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> n’est pas un format connu.
 
- ou - 
 <paramref name="offset" /> est inférieur à zéro.
 
- ou - 
 <paramref name="count" /> est inférieur à zéro.
 
- ou - 
 <paramref name="offset" /> + <paramref name="count" /> - 1 génère un index qui dépasse la limite supérieure de <paramref name="data" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> a un <see langword="null" /> ou <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> vide.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de hachage ou de vérification.</exception>
      <returns>
        <see langword="true" /> si la signature numérique est valide pour les données fournies ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyData(System.IO.Stream,System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Vérifie qu'une signature numérique est adaptée à la clé actuelle et aux données fournies à l’aide d’un algorithme de hachage spécifié.</summary>
      <param name="data">Données signées.</param>
      <param name="signature">Données de la signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage des données.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="signature" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <returns>
        <see langword="true" /> si la signature est valide ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyData(System.IO.Stream,System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Vérifie qu’une signature numérique est valide pour les données fournies.</summary>
      <param name="data">Données signées.</param>
      <param name="signature">Signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour hacher les données pour le processus de vérification.</param>
      <param name="signatureFormat">Format d’encodage de <paramref name="signature" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ou <paramref name="signature" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> n’est pas un format connu.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> a une <see langword="null" /> ou <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> vide.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de hachage ou de vérification.</exception>
      <returns>
        <see langword="true" /> si la signature numérique est valide pour les données fournies ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyData(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName)">
      <summary>Vérifie qu'une signature numérique est adaptée à la clé actuelle et aux données fournies à l’aide d’un algorithme de hachage spécifié.</summary>
      <param name="data">Données signées.</param>
      <param name="signature">Signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage des données.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <returns>
        <see langword="true" /> si la signature est valide ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyData(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Vérifie qu’une signature numérique est valide pour les données fournies.</summary>
      <param name="data">Données signées.</param>
      <param name="signature">Signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour hacher les données pour le processus de vérification.</param>
      <param name="signatureFormat">Format d’encodage de <paramref name="signature" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> n’est pas un format connu.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de hachage ou de vérification.</exception>
      <returns>
        <see langword="true" /> si la signature numérique est valide pour les données fournies ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyDataCore(System.IO.Stream,System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Vérifie qu’une signature numérique est valide pour les données fournies.</summary>
      <param name="data">Données signées.</param>
      <param name="signature">Signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour hacher les données pour le processus de vérification.</param>
      <param name="signatureFormat">Format d’encodage de <paramref name="signature" />.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de hachage ou de vérification.</exception>
      <returns>
        <see langword="true" /> si la signature numérique est valide pour les données fournies ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyDataCore(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Vérifie qu’une signature numérique est valide pour les données fournies.</summary>
      <param name="data">Données signées.</param>
      <param name="signature">Signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour hacher les données pour le processus de vérification.</param>
      <param name="signatureFormat">Format d’encodage de <paramref name="signature" />.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de hachage ou de vérification.</exception>
      <returns>
        <see langword="true" /> si la signature numérique est valide pour les données fournies ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyHash(System.Byte[],System.Byte[])">
      <summary>Vérifie qu’une signature numérique est adaptée à la clé actuelle et au hachage de données fourni.</summary>
      <param name="hash">Valeur de hachage des données à vérifier.</param>
      <param name="signature">Signature numérique des données à vérifier par rapport à la valeur de hachage.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="hash" /> ou <paramref name="signature" /> est <see langword="null" />.</exception>
      <returns>
        <see langword="true" /> si la signature est valide ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyHash(System.Byte[],System.Byte[],System.Security.Cryptography.DSASignatureFormat)">
      <summary>Vérifie qu’une signature numérique est valide pour le hachage fourni.</summary>
      <param name="hash">Code de hachage signé.</param>
      <param name="signature">Signature à vérifier.</param>
      <param name="signatureFormat">Format d’encodage de <paramref name="signature" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="hash" /> ou <paramref name="signature" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> n’est pas un format connu.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de vérification.</exception>
      <returns>
        <see langword="true" /> si la signature numérique est valide pour les données fournies ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyHash(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Vérifie qu’une signature numérique est adaptée à la clé actuelle et au hachage de données fourni.</summary>
      <param name="hash">Valeur de hachage des données à vérifier.</param>
      <param name="signature">Signature numérique des données à vérifier par rapport à la valeur de hachage.</param>
      <returns>
        <see langword="true" /> si la signature est valide ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyHash(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.DSASignatureFormat)">
      <summary>Vérifie qu’une signature numérique est valide pour le hachage fourni.</summary>
      <param name="hash">Code de hachage signé.</param>
      <param name="signature">Signature à vérifier.</param>
      <param name="signatureFormat">Format d’encodage de <paramref name="signature" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> n’est pas un format connu.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de vérification.</exception>
      <returns>
        <see langword="true" /> si la signature numérique est valide pour les données fournies ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyHashCore(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.DSASignatureFormat)">
      <summary>Vérifie qu’une signature numérique est valide pour le hachage fourni.</summary>
      <param name="hash">Code de hachage signé.</param>
      <param name="signature">Signature à vérifier.</param>
      <param name="signatureFormat">Format d’encodage de <paramref name="signature" />.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de l’opération de vérification.</exception>
      <returns>
        <see langword="true" /> si la signature numérique est valide pour les données fournies ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECDsa.KeyExchangeAlgorithm">
      <summary>Obtient le nom de l'algorithme d'échange de clés.</summary>
      <returns>Toujours <see langword="null" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECDsa.SignatureAlgorithm">
      <summary>Obtient le nom de l'algorithme de signature.</summary>
      <returns>La chaîne "ECDsa".</returns>
    </member>
    <member name="T:System.Security.Cryptography.ECParameters">
      <summary>Représente les paramètres standard pour l’algorithme de chiffrement ECC.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECParameters.Curve">
      <summary>Représente la courbe associée à la clé publique (<see cref="F:System.Security.Cryptography.ECParameters.Q" />) et la clé privée facultative (<see cref="F:System.Security.Cryptography.ECParameters.D" />).</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECParameters.D">
      <summary>Représente la clé privée <see langword="D" /> pour l’algorithme de chiffrement ECC, stockée au format big-endian.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECParameters.Q">
      <summary>Représente la clé publique <see langword="Q" /> pour l’algorithme de chiffrement ECC.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECParameters.Validate">
      <summary>Valide l’objet actuel.</summary>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Les paramètres de clé ou de courbe ne sont pas valides pour le type de courbe actuel.</exception>
    </member>
    <member name="T:System.Security.Cryptography.ECPoint">
      <summary>Représente une paire de coordonnées (X,Y) pour les structures de chiffrement à courbe elliptique.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECPoint.X">
      <summary>Représente la coordonnée X.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECPoint.Y">
      <summary>Représente la coordonnée Y.</summary>
    </member>
    <member name="T:System.Security.Cryptography.HKDF">
      <summary>Dérivation de clé d’extraction et de développement RFC5869 basée sur HMAC (HKDF)</summary>
    </member>
    <member name="M:System.Security.Cryptography.HKDF.DeriveKey(System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Int32,System.Byte[],System.Byte[])">
      <summary>Effectue les fonctions HKDF de développement et d’extraction de la dérivation de clé.</summary>
      <param name="hashAlgorithmName">Algorithme de hachage utilisé pour les opérations HMAC.</param>
      <param name="ikm">Matériel de génération de clé d’entrée.</param>
      <param name="outputLength">Longueur de l’élément de génération de clé de sortie.</param>
      <param name="salt">Valeur Salt facultative (valeur aléatoire non secrète). Si elle n’est pas fournie, la valeur par défaut est un tableau d’octets de la même longueur que la sortie de l’algorithme de hachage spécifié.</param>
      <param name="info">Informations facultatives spécifiques au contexte et à l’application.</param>
      <returns>Support de clé de sortie.</returns>
    </member>
    <member name="M:System.Security.Cryptography.HKDF.DeriveKey(System.Security.Cryptography.HashAlgorithmName,System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Effectue les fonctions HKDF de développement et d’extraction de la dérivation de clé.</summary>
      <param name="hashAlgorithmName">Algorithme de hachage utilisé pour les opérations HMAC.</param>
      <param name="ikm">Matériel de génération de clé d’entrée.</param>
      <param name="output">Mémoire tampon de sortie qui représente le matériel de génération de clé de sortie.</param>
      <param name="salt">Valeur Salt (valeur aléatoire non secrète).</param>
      <param name="info">Informations spécifiques au contexte et à l’application (il peut s’agir d’une étendue vide).</param>
    </member>
    <member name="M:System.Security.Cryptography.HKDF.Expand(System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Int32,System.Byte[])">
      <summary>Exécute la fonction de développement HKDF Consultez la section 2.3 de RFC5869.</summary>
      <param name="hashAlgorithmName">Algorithme de hachage utilisé pour les opérations HMAC.</param>
      <param name="prk">Clé pseudo-aléatoire qui est au moins aussi longue que le tableau d’octets de sortie de l’algorithme de hachage spécifié (généralement la sortie de l’étape de développement).</param>
      <param name="outputLength">Longueur de l’élément de génération de clé de sortie.</param>
      <param name="info">Informations facultatives spécifiques au contexte et à l’application.</param>
      <returns>Support de clé de sortie.</returns>
    </member>
    <member name="M:System.Security.Cryptography.HKDF.Expand(System.Security.Cryptography.HashAlgorithmName,System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Exécute la fonction de développement HKDF. Consultez la section 2.3 de RFC5869.</summary>
      <param name="hashAlgorithmName">Algorithme de hachage utilisé pour les opérations HMAC.</param>
      <param name="prk">Clé pseudo-aléatoire qui est au moins aussi longue que le tableau d’octets de sortie de l’algorithme de hachage spécifié (généralement la sortie de l’étape de développement).</param>
      <param name="output">Mémoire tampon de destination utilisée pour recevoir le support de clé de sortie.</param>
      <param name="info">Informations spécifiques au contexte et à l’application (il peut s’agir d’une étendue vide).</param>
    </member>
    <member name="M:System.Security.Cryptography.HKDF.Extract(System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])">
      <summary>Exécute la fonction d’extraction HKDF.
Consultez la section 2.2 de RFC5869.</summary>
      <param name="hashAlgorithmName">Algorithme de hachage utilisé pour les opérations HMAC.</param>
      <param name="ikm">Matériel de génération de clé d’entrée.</param>
      <param name="salt">Valeur Salt facultative (valeur aléatoire non secrète). Si elle n’est pas fournie, la valeur par défaut est un tableau d’octets de la même longueur que la sortie de l’algorithme de hachage spécifié.</param>
      <returns>Clé pseudo-aléatoire (PRK).</returns>
    </member>
    <member name="M:System.Security.Cryptography.HKDF.Extract(System.Security.Cryptography.HashAlgorithmName,System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
      <summary>Exécute la fonction d’extraction HKDF.
Consultez la section 2.2 de RFC5869.</summary>
      <param name="hashAlgorithmName">Algorithme de hachage utilisé pour les opérations HMAC.</param>
      <param name="ikm">Matériel de génération de clé d’entrée.</param>
      <param name="salt">Valeur Salt (valeur aléatoire non secrète).</param>
      <param name="prk">Mémoire tampon de destination utilisée pour recevoir la clé pseudo-aléatoire (PRK).</param>
      <returns>Nombre d'octets écrits dans la mémoire tampon <paramref name="prk" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.HMACMD5">
      <summary>Calcule un code HMAC (Hash-based Message Authentication Code) à l'aide de la fonction de hachage <see cref="T:System.Security.Cryptography.MD5" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.HMACMD5" /> en utilisant une clé générée de manière aléatoire.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.#ctor(System.Byte[])">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.HMACMD5" /> à l'aide de la clé spécifiée.</summary>
      <param name="key">Clé secrète pour le chiffrement <see cref="T:System.Security.Cryptography.HMACMD5" />. La clé peut avoir n'importe quelle longueur, mais si elle dépasse 64 octets, elle sera hachée (à l'aide de SHA-1) pour dériver une clé de 64 octets. Par conséquent, la taille recommandée pour la clé secrète est égale à 64 octets.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.Dispose(System.Boolean)">
      <summary>Libère les ressources non managées utilisées par <see cref="T:System.Security.Cryptography.HMACMD5" /> et libère éventuellement les ressources managées.</summary>
      <param name="disposing">
        <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.HashCore(System.Byte[],System.Int32,System.Int32)">
      <summary>Route les données écrites dans l’objet vers l’algorithme HMAC pour le calcul de HMAC.</summary>
      <param name="rgb">Entrée pour laquelle HMAC doit être calculé.</param>
      <param name="ib">Offset dans le tableau d'octets à partir duquel l'utilisation de données commence.</param>
      <param name="cb">Nombre d'octets dans le tableau d'octets à utiliser comme données.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.HashCore(System.ReadOnlySpan{System.Byte})">
      <summary>Route les données écrites dans l’objet vers l’algorithme HMAC pour le calcul de HMAC.</summary>
      <param name="source">Entrée pour laquelle HMAC doit être calculé.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.HashFinal">
      <summary>Finalise le calcul de HMAC après que les dernières données ont été traitées par l’algorithme.</summary>
      <returns>Valeur de HMAC calculée dans un tableau d’octets.</returns>
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.Initialize">
      <summary>Rétablit l’état initial de l’algorithme de hachage.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <summary>Tente de finaliser le calcul de HMAC après que les dernières données ont été traitées par l’algorithme HMAC.</summary>
      <param name="destination">Mémoire tampon utilisée pour recevoir la valeur de HMAC.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, nombre total d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment long pour recevoir la valeur de HMAC ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.HMACMD5.Key">
      <summary>Obtient ou définit la clé à utiliser dans le calcul de HMAC.</summary>
      <returns>Clé à utiliser dans le calcul HMAC.</returns>
    </member>
    <member name="T:System.Security.Cryptography.HMACSHA1">
      <summary>Calcule un code HMAC (Hash-based Message Authentication Code) à l'aide de la fonction de hachage <see cref="T:System.Security.Cryptography.SHA1" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.HMACSHA1" /> avec une clé générée de manière aléatoire.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.#ctor(System.Byte[])">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.HMACSHA1" /> avec les données de clé spécifiées.</summary>
      <param name="key">Clé secrète pour le chiffrement <see cref="T:System.Security.Cryptography.HMACSHA1" />. La clé peut avoir n'importe quelle longueur, mais si elle dépasse 64 octets, elle est hachée (à l'aide de SHA-1) pour dériver une clé de 64 octets. Par conséquent, la taille recommandée pour la clé secrète est égale à 64 octets.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.#ctor(System.Byte[],System.Boolean)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.HMACSHA1" /> avec les données de clés spécifiées et une valeur qui spécifie s'il faut utiliser la version managée de l'algorithme SHA1.</summary>
      <param name="key">Clé secrète pour le chiffrement <see cref="T:System.Security.Cryptography.HMACSHA1" />. La clé peut avoir n'importe quelle longueur, mais si elle dépasse 64 octets, elle est hachée (à l'aide de SHA-1) pour dériver une clé de 64 octets. Par conséquent, la taille recommandée pour la clé secrète est égale à 64 octets.</param>
      <param name="useManagedSha1">
        <see langword="true" /> pour utiliser l'implémentation managée de l'algorithme SHA1 (la classe <see cref="T:System.Security.Cryptography.SHA1Managed" />) ; <see langword="false" /> pour utiliser l'implémentation non managée (la classe <see cref="T:System.Security.Cryptography.SHA1CryptoServiceProvider" />).</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.Dispose(System.Boolean)">
      <summary>Ce membre substitue <see cref="M:System.Security.Cryptography.KeyedHashAlgorithm.Dispose(System.Boolean)" />. Une documentation plus complète est peut-être disponible dans cette rubrique.

Libère les ressources non managées utilisées par <see cref="T:System.Security.Cryptography.KeyedHashAlgorithm" /> et libère éventuellement les ressources managées.</summary>
      <param name="disposing">
        <see langword="true" /> pour libérer les ressources managées et non managées ; false pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.HashCore(System.Byte[],System.Int32,System.Int32)">
      <summary>Route les données écrites dans l’objet vers l’algorithme de hachage SHA1 pour calculer le HMAC (code d’authentification de message basé sur un code de hachage).</summary>
      <param name="rgb">Données d'entrée.</param>
      <param name="ib">Offset dans le tableau d'octets à partir duquel l'utilisation de données commence.</param>
      <param name="cb">Nombre d'octets dans le tableau à utiliser comme données.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.HashCore(System.ReadOnlySpan{System.Byte})">
      <summary>Route les données écrites dans l’objet vers l’algorithme HMAC pour le calcul de HMAC.</summary>
      <param name="source">Entrée pour laquelle HMAC doit être calculé.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.HashFinal">
      <summary>Finalise le calcul de HMAC après que les dernières données ont été traitées par l’algorithme.</summary>
      <returns>Valeur de HMAC calculée dans un tableau d’octets.</returns>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.Initialize">
      <summary>Rétablit l’état initial de l’algorithme de hachage.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <summary>Tente de finaliser le calcul de HMAC après que les dernières données ont été traitées par l’algorithme HMAC.</summary>
      <param name="destination">Mémoire tampon utilisée pour recevoir la valeur de HMAC.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, nombre total d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment long pour recevoir la valeur de HMAC ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.HMACSHA1.Key">
      <summary>Obtient ou définit la clé à utiliser dans l'algorithme de hachage.</summary>
      <returns>Clé à utiliser dans l'algorithme de hachage.</returns>
    </member>
    <member name="T:System.Security.Cryptography.HMACSHA256">
      <summary>Calcule un code HMAC (Hash-based Message Authentication Code) à l'aide de la fonction de hachage <see cref="T:System.Security.Cryptography.SHA256" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.HMACSHA256" /> avec une clé générée de manière aléatoire.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.#ctor(System.Byte[])">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.HMACSHA256" /> avec les données de clé spécifiées.</summary>
      <param name="key">Clé secrète pour le chiffrement <see cref="T:System.Security.Cryptography.HMACSHA256" />. La clé peut avoir n'importe quelle longueur. Toutefois, la taille recommandée est de 64 octets. Si la clé dépasse 64 octets, elle est hachée (à l'aide de SHA-256) pour dériver une clé de 64 octets. Si la valeur est inférieure à 64 octets, elle est complétée jusqu'à 64 octets.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.Dispose(System.Boolean)">
      <summary>Libère les ressources non managées utilisées par <see cref="T:System.Security.Cryptography.HMACSHA256" /> et libère éventuellement les ressources managées.</summary>
      <param name="disposing">
        <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.HashCore(System.Byte[],System.Int32,System.Int32)">
      <summary>Route les données écrites dans l’objet vers l’algorithme HMAC pour le calcul de HMAC.</summary>
      <param name="rgb">Entrée pour laquelle HMAC doit être calculé.</param>
      <param name="ib">Offset dans le tableau d'octets à partir duquel l'utilisation de données commence.</param>
      <param name="cb">Nombre d'octets dans le tableau d'octets à utiliser comme données.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.HashCore(System.ReadOnlySpan{System.Byte})">
      <summary>Route les données écrites dans l’objet vers l’algorithme HMAC pour le calcul de HMAC.</summary>
      <param name="source">Entrée pour laquelle HMAC doit être calculé.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.HashFinal">
      <summary>Finalise le calcul de HMAC après que les dernières données ont été traitées par l’algorithme.</summary>
      <returns>Valeur de HMAC calculée dans un tableau d’octets.</returns>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.Initialize">
      <summary>Rétablit l’état initial de l’algorithme de hachage.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <summary>Tente de finaliser le calcul de HMAC après que les dernières données ont été traitées par l’algorithme HMAC.</summary>
      <param name="destination">Mémoire tampon utilisée pour recevoir la valeur de HMAC.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, nombre total d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment long pour recevoir la valeur de HMAC ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.HMACSHA256.Key">
      <summary>Obtient ou définit la clé à utiliser dans le calcul de HMAC.</summary>
      <returns>Clé à utiliser dans le calcul HMAC.</returns>
    </member>
    <member name="T:System.Security.Cryptography.HMACSHA384">
      <summary>Calcule un code HMAC (Hash-based Message Authentication Code) à l'aide de la fonction de hachage <see cref="T:System.Security.Cryptography.SHA384" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.HMACSHA384" /> en utilisant une clé générée de manière aléatoire.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.#ctor(System.Byte[])">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.HMACSHA384" /> à l'aide des données de clé spécifiées.</summary>
      <param name="key">Clé secrète pour le chiffrement <see cref="T:System.Security.Cryptography.HMACSHA384" />. La clé peut avoir n'importe quelle longueur. Toutefois, la taille recommandée est de 128 octets. Si la clé dépasse 128 octets, elle est hachée (à l’aide de SHA-384) pour dériver une clé de 128 octets. Si la valeur est inférieure à 128 octets, elle est complétée jusqu’à 128 octets.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.Dispose(System.Boolean)">
      <summary>Libère les ressources non managées utilisées par <see cref="T:System.Security.Cryptography.HMACSHA384" /> et libère éventuellement les ressources managées.</summary>
      <param name="disposing">
        <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.HashCore(System.Byte[],System.Int32,System.Int32)">
      <summary>Route les données écrites dans l’objet vers l’algorithme HMAC pour le calcul de HMAC.</summary>
      <param name="rgb">Entrée pour laquelle HMAC doit être calculé.</param>
      <param name="ib">Offset dans le tableau d'octets à partir duquel l'utilisation de données commence.</param>
      <param name="cb">Nombre d'octets dans le tableau d'octets à utiliser comme données.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.HashCore(System.ReadOnlySpan{System.Byte})">
      <summary>Route les données écrites dans l’objet vers l’algorithme HMAC pour le calcul de HMAC.</summary>
      <param name="source">Entrée pour laquelle HMAC doit être calculé.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.HashFinal">
      <summary>Finalise le calcul de HMAC après que les dernières données ont été traitées par l’algorithme.</summary>
      <returns>Valeur de HMAC calculée dans un tableau d’octets.</returns>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.Initialize">
      <summary>Rétablit l’état initial de l’algorithme de hachage.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <summary>Tente de finaliser le calcul de HMAC après que les dernières données ont été traitées par l’algorithme HMAC.</summary>
      <param name="destination">Mémoire tampon utilisée pour recevoir la valeur de HMAC.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, nombre total d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment long pour recevoir la valeur de HMAC ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.HMACSHA384.Key">
      <summary>Obtient ou définit la clé à utiliser dans le calcul de HMAC.</summary>
      <returns>Clé à utiliser dans le calcul HMAC.</returns>
    </member>
    <member name="P:System.Security.Cryptography.HMACSHA384.ProduceLegacyHmacValues">
      <summary>Fournit une solution de contournement pour l’implémentation .NET Framework 2.0 de l’algorithme <see cref="T:System.Security.Cryptography.HMACSHA384" />, qui est incohérent avec l’implémentation .NET Framework 2.0 Service Pack 1 de l’algorithme.</summary>
      <returns>
        <see langword="true" /> pour permettre aux applications .NET Framework 2.0 Service Pack 1 d'interagir avec les applications .NET Framework 2.0 ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.HMACSHA512">
      <summary>Calcule un code HMAC (Hash-based Message Authentication Code) à l'aide de la fonction de hachage <see cref="T:System.Security.Cryptography.SHA512" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.HMACSHA512" /> avec une clé générée de manière aléatoire.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.#ctor(System.Byte[])">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.HMACSHA512" /> avec les données de clé spécifiées.</summary>
      <param name="key">Clé secrète pour le chiffrement <see cref="T:System.Security.Cryptography.HMACSHA512" />. La clé peut avoir n'importe quelle longueur. Toutefois, la taille recommandée est de 128 octets. Si la clé dépasse 128 octets, elle est hachée (à l’aide de SHA-512) pour dériver une clé de 128 octets. Si la valeur est inférieure à 128 octets, elle est complétée jusqu’à 128 octets.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.Dispose(System.Boolean)">
      <summary>Libère les ressources non managées utilisées par <see cref="T:System.Security.Cryptography.HMACSHA512" /> et libère éventuellement les ressources managées.</summary>
      <param name="disposing">
        <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.HashCore(System.Byte[],System.Int32,System.Int32)">
      <summary>Route les données écrites dans l’objet vers l’algorithme HMAC pour le calcul de HMAC.</summary>
      <param name="rgb">Entrée pour laquelle HMAC doit être calculé.</param>
      <param name="ib">Offset dans le tableau d'octets à partir duquel l'utilisation de données commence.</param>
      <param name="cb">Nombre d'octets dans le tableau d'octets à utiliser comme données.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.HashCore(System.ReadOnlySpan{System.Byte})">
      <summary>Route les données écrites dans l’objet vers l’algorithme HMAC pour le calcul de HMAC.</summary>
      <param name="source">Entrée pour laquelle HMAC doit être calculé.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.HashFinal">
      <summary>Finalise le calcul de HMAC après que les dernières données ont été traitées par l’algorithme.</summary>
      <returns>Valeur de HMAC calculée dans un tableau d’octets.</returns>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.Initialize">
      <summary>Rétablit l’état initial de l’algorithme de hachage.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <summary>Tente de finaliser le calcul de HMAC après que les dernières données ont été traitées par l’algorithme HMAC.</summary>
      <param name="destination">Mémoire tampon utilisée pour recevoir la valeur de HMAC.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, nombre total d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment long pour recevoir la valeur de HMAC ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.HMACSHA512.Key">
      <summary>Obtient ou définit la clé à utiliser dans le calcul de HMAC.</summary>
      <returns>Clé à utiliser dans le calcul HMAC.</returns>
    </member>
    <member name="P:System.Security.Cryptography.HMACSHA512.ProduceLegacyHmacValues">
      <summary>Fournit une solution de contournement pour l'implémentation .NET Framework 2.0 de l'algorithme <see cref="T:System.Security.Cryptography.HMACSHA512" />, qui est incohérent avec l'implémentation .NET Framework 2.0 Service Pack 1.</summary>
      <returns>
        <see langword="true" /> pour permettre aux applications .NET Framework 2.0 Service Pack 1 d'interagir avec les applications .NET Framework 2.0 ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.IncrementalHash">
      <summary>Fournit la prise en charge du calcul d’un hachage ou d’une valeur HMAC (Hash-based Message Authentication Code) incrémentielle sur plusieurs segments.</summary>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[])">
      <summary>Ajoute les données spécifiées aux données déjà traitées dans le hachage ou le code HMAC.</summary>
      <param name="data">Données à traiter.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ObjectDisposedException">L’objet <see cref="T:System.Security.Cryptography.IncrementalHash" /> a déjà été supprimé.</exception>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[],System.Int32,System.Int32)">
      <summary>Ajoute le nombre spécifié d’octets à partir des données spécifiées, en commençant à l’offset spécifié, aux données déjà traitées dans le hachage ou le code HMAC (Hash-based Message Authentication Code).</summary>
      <param name="data">Données à traiter.</param>
      <param name="offset">Offset dans le tableau d'octets à partir duquel l'utilisation de données commence.</param>
      <param name="count">Nombre d’octets à utiliser à partir de <paramref name="data" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> ou <paramref name="offset" /> est un nombre négatif.  
  
- ou - 
 <paramref name="count" /> est supérieur à la longueur de <paramref name="data" />.</exception>
      <exception cref="T:System.ArgumentException">La somme de <paramref name="offset" /> et <paramref name="count" /> est supérieure à la longueur des données.</exception>
      <exception cref="T:System.ObjectDisposedException">L’objet <see cref="T:System.Security.Cryptography.IncrementalHash" /> a déjà été supprimé.</exception>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.AppendData(System.ReadOnlySpan{System.Byte})">
      <summary>Ajoute les données spécifiées aux données déjà traitées dans le hachage ou dans le code HMAC (Hash-based Message Authentication Code).</summary>
      <param name="data">Données à traiter.</param>
      <exception cref="T:System.ObjectDisposedException">L’objet <see cref="T:System.Security.Cryptography.IncrementalHash" /> a déjà été supprimé.</exception>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.CreateHash(System.Security.Cryptography.HashAlgorithmName)">
      <summary>Crée un <see cref="T:System.Security.Cryptography.IncrementalHash" /> pour l’algorithme spécifié.</summary>
      <param name="hashAlgorithm">Nom de l’algorithme de hachage à exécuter.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est soit <see langword="null" /> soit une chaîne vide.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="hashAlgorithm" /> n’est pas un algorithme de hachage connu.</exception>
      <returns>Instance de <see cref="T:System.Security.Cryptography.IncrementalHash" /> prête pour le calcul de l’algorithme de hachage spécifié par <paramref name="hashAlgorithm" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
      <summary>Crée un <see cref="T:System.Security.Cryptography.IncrementalHash" /> pour l’algorithme HMAC (Hash-based Message Authentication Code) à l’aide de la clé et de l’algorithme de hachage spécifiés.</summary>
      <param name="hashAlgorithm">Nom de l’algorithme de hachage à exécuter dans le HMAC.</param>
      <param name="key">Clé secrète pour le HMAC. La clé peut être de n’importe quelle longueur, mais une clé dont la taille est supérieure à celle de la sortie de l’algorithme de hachage spécifié sera hachée pour dériver une clé de dimension correcte. Par conséquent, la taille recommandée de la clé secrète est la taille de la sortie de l’algorithme de hachage spécifié.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est soit <see langword="null" /> soit une chaîne vide.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="hashAlgorithm" /> n’est pas un algorithme de hachage connu.</exception>
      <returns>Instance de la classe <see cref="T:System.Security.Cryptography.IncrementalHash" /> prête pour le calcul de l’algorithme de hachage spécifié.</returns>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.ReadOnlySpan{System.Byte})">
      <summary>Créer un <see cref="T:System.Security.Cryptography.IncrementalHash" /> pour l’algorithme HMAC (Hash-based Message Authentication Code) à l’aide de l’algorithme de hachage spécifié par <paramref name="hashAlgorithm" /> et une clé spécifiée par <paramref name="key" />.</summary>
      <param name="hashAlgorithm">Nom de l’algorithme de hachage à exécuter dans le HMAC.</param>
      <param name="key">Clé secrète pour le HMAC. La clé peut avoir n’importe quelle longueur, mais une clé plus longue que la taille de sortie de l’algorithme de hachage spécifié par <paramref name="hashAlgorithm" /> sera hachée (à l’aide de l’algorithme spécifié par <paramref name="hashAlgorithm" />) pour dériver une clé de dimension correcte. Par conséquent, la taille recommandée de la clé secrète est la taille de la sortie du hachage spécifié par <paramref name="hashAlgorithm" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou une chaîne vide.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="hashAlgorithm" /> n’est pas un algorithme de hachage connu.</exception>
      <returns>Une instance de hachage pour calculer l’algorithme de hachage spécifié par <paramref name="hashAlgorithm" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.Dispose">
      <summary>Libère les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Security.Cryptography.IncrementalHash" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.GetCurrentHash">
      <summary>Récupère le hachage ou le code HMAC (Hash-based Message Authentication Code) pour les données accumulées lors des appels précédents aux méthodes <see cref="M:System.Security.Cryptography.IncrementalHash.AppendData(System.ReadOnlySpan{System.Byte})" /> sans rétablir l’état initial de l’objet.</summary>
      <exception cref="T:System.ObjectDisposedException">L'objet a déjà été supprimé.</exception>
      <returns>Hachage ou code HMAC calculé.</returns>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.GetCurrentHash(System.Span{System.Byte})">
      <summary>Récupère le hachage ou le code HMAC (Hash-based Message Authentication Code) pour les données accumulées lors des appels précédents aux méthodes <see cref="M:System.Security.Cryptography.IncrementalHash.AppendData(System.ReadOnlySpan{System.Byte})" /> sans rétablir l’état initial de l’objet.</summary>
      <param name="destination">Mémoire tampon utilisée pour recevoir le hachage ou la valeur de HMAC.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="destination" /> a une valeur <see cref="P:System.Span`1.Length" /> inférieure à <see cref="P:System.Security.Cryptography.IncrementalHash.HashLengthInBytes" />.</exception>
      <exception cref="T:System.ObjectDisposedException">L'objet a déjà été supprimé.</exception>
      <returns>Nombre d’octets écrits dans <paramref name="destination" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.GetHashAndReset">
      <summary>Récupère le hachage ou le code HMAC (Hash-based Message Authentication Code) pour les données accumulées lors des appels précédents aux méthodes <see cref="Overload:System.Security.Cryptography.IncrementalHash.AppendData" />, puis rétablit l’état initial de l’objet.</summary>
      <exception cref="T:System.ObjectDisposedException">L’objet <see cref="T:System.Security.Cryptography.IncrementalHash" /> a déjà été supprimé.</exception>
      <returns>Hachage ou code HMAC calculé.</returns>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.GetHashAndReset(System.Span{System.Byte})">
      <summary>Récupère le hachage ou le code HMAC (Hash-based Message Authentication Code) pour les données accumulées lors des appels précédents aux méthodes <see cref="M:System.Security.Cryptography.IncrementalHash.AppendData(System.ReadOnlySpan{System.Byte})" /> et rétablit l’état initial de l’objet.</summary>
      <param name="destination">Mémoire tampon utilisée pour recevoir le hachage ou la valeur de HMAC.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="destination" /> a une valeur <see cref="P:System.Span`1.Length" /> inférieure à <see cref="P:System.Security.Cryptography.IncrementalHash.HashLengthInBytes" />.</exception>
      <exception cref="T:System.ObjectDisposedException">L'objet a déjà été supprimé.</exception>
      <returns>Nombre d’octets écrits dans <paramref name="destination" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.TryGetCurrentHash(System.Span{System.Byte},System.Int32@)">
      <summary>Tentatives de récupération du hachage ou du code HMAC (Hash-based Message Authentication Code) pour les données accumulées lors des appels précédents aux méthodes <see cref="M:System.Security.Cryptography.IncrementalHash.AppendData(System.ReadOnlySpan{System.Byte})" /> sans rétablir l’état initial de l’objet.</summary>
      <param name="destination">Mémoire tampon utilisée pour recevoir le hachage ou la valeur de HMAC.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, nombre total d’octets écrits dans <paramref name="destination" />.
Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.ObjectDisposedException">L'objet a déjà été supprimé.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment long pour recevoir la valeur du hachage ou de HMAC ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.TryGetHashAndReset(System.Span{System.Byte},System.Int32@)">
      <summary>Tente de finaliser le calcul du hachage après que les dernières données ont été traitées par l’algorithme de hachage.</summary>
      <param name="destination">Mémoire tampon destinée à recevoir la valeur du hachage ou du code HMAC (Hash-Based Message Authentication Code).</param>
      <param name="bytesWritten">Quand cette méthode est retournée, nombre total d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.ObjectDisposedException">L’objet <see cref="T:System.Security.Cryptography.IncrementalHash" /> a déjà été supprimé.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment long pour recevoir la valeur du hachage ou de HMAC ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.IncrementalHash.AlgorithmName">
      <summary>Obtient le nom de l’algorithme exécuté. Les algorithmes HMAC sont précédés de « HMAC » pour les distinguer d’un code de hachage sans clé.</summary>
      <returns>Nom de l’algorithme exécuté.</returns>
    </member>
    <member name="P:System.Security.Cryptography.IncrementalHash.HashLengthInBytes">
      <summary>Obtient la taille de sortie de cet algorithme de hachage ou HMAC, en octets.</summary>
      <returns>Taille de sortie de cet algorithme de hachage ou HMAC, en octets.</returns>
    </member>
    <member name="T:System.Security.Cryptography.MaskGenerationMethod">
      <summary>Représente la classe abstraite dont doivent dériver tous les algorithmes du générateur de masque.</summary>
    </member>
    <member name="M:System.Security.Cryptography.MaskGenerationMethod.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.MaskGenerationMethod" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.MaskGenerationMethod.GenerateMask(System.Byte[],System.Int32)">
      <summary>En cas de substitution dans une classe dérivée, génère un masque de la longueur spécifiée à l’aide de la valeur initiale aléatoire spécifiée.</summary>
      <param name="rgbSeed">Valeur initiale aléatoire à utiliser pour calculer le masque.</param>
      <param name="cbReturn">Longueur du masque généré, en octets.</param>
      <returns>Masque généré de manière aléatoire dont la longueur est égale au paramètre <paramref name="cbReturn" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.MD5">
      <summary>Représente la classe abstraite dont toutes les implémentations de l'algorithme de hachage <see cref="T:System.Security.Cryptography.MD5" /> héritent.</summary>
    </member>
    <member name="M:System.Security.Cryptography.MD5.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Security.Cryptography.MD5" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.MD5.Create">
      <summary>Crée une instance de l'implémentation par défaut de l'algorithme de hachage <see cref="T:System.Security.Cryptography.MD5" />.</summary>
      <exception cref="T:System.Reflection.TargetInvocationException">L’algorithme a été utilisé en mode FIPS (Federal Information Processing Standards), mais il n’est pas compatible avec la norme FIPS.</exception>
      <returns>Nouvelle instance de l'algorithme de hachage <see cref="T:System.Security.Cryptography.MD5" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.MD5.Create(System.String)">
      <summary>Crée une instance de l'implémentation spécifiée de l'algorithme de hachage <see cref="T:System.Security.Cryptography.MD5" />.</summary>
      <param name="algName">Nom de l'implémentation spécifique de <see cref="T:System.Security.Cryptography.MD5" /> à utiliser.</param>
      <exception cref="T:System.Reflection.TargetInvocationException">L'algorithme décrit par le paramètre <paramref name="algName" /> a été utilisé avec mode FIPS activé, mais n'est pas compatible FIPS.</exception>
      <returns>Nouvelle instance de l'implémentation spécifiée de <see cref="T:System.Security.Cryptography.MD5" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.MD5.HashData(System.Byte[])">
      <summary>Calcule le hachage des données à l’aide de l’algorithme MD5.</summary>
      <param name="source">Données à hacher.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> est <see langword="null" />.</exception>
      <returns>Hachage des données.</returns>
    </member>
    <member name="M:System.Security.Cryptography.MD5.HashData(System.ReadOnlySpan{System.Byte})">
      <summary>Calcule le hachage des données à l’aide de l’algorithme MD5.</summary>
      <param name="source">Données à hacher.</param>
      <returns>Hachage des données.</returns>
    </member>
    <member name="M:System.Security.Cryptography.MD5.HashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
      <summary>Calcule le hachage des données à l’aide de l’algorithme MD5.</summary>
      <param name="source">Données à hacher.</param>
      <param name="destination">Mémoire tampon utilisée pour recevoir la valeur de hachage.</param>
      <exception cref="T:System.ArgumentException">La mémoire tampon de <paramref name="destination" /> est trop petite pour contenir la taille de hachage calculée. L’algorithme MD5 produit toujours un hachage 128 bits, soit 16 octets.</exception>
      <returns>Nombre total d’octets écrits dans <paramref name="destination" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.MD5.TryHashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@)">
      <summary>Tente de calculer le hachage des données à l’aide de l’algorithme MD5.</summary>
      <param name="source">Données à hacher.</param>
      <param name="destination">Mémoire tampon utilisée pour recevoir la valeur de hachage.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, nombre total d’octets écrits dans <paramref name="destination" />.</param>
      <returns>
        <see langword="false" /> si <paramref name="destination" /> est trop petit pour contenir le hachage calculé, <see langword="true" /> dans le cas contraire.</returns>
    </member>
    <member name="T:System.Security.Cryptography.PKCS1MaskGenerationMethod">
      <summary>Calcule les masques en fonction de PKCS #1 pour une utilisation par les algorithmes d’échange de clés.</summary>
    </member>
    <member name="M:System.Security.Cryptography.PKCS1MaskGenerationMethod.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.PKCS1MaskGenerationMethod" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.PKCS1MaskGenerationMethod.GenerateMask(System.Byte[],System.Int32)">
      <summary>Génère et retourne un masque à partir de la valeur initiale aléatoire spécifiée de la longueur spécifiée.</summary>
      <param name="rgbSeed">Valeur initiale aléatoire à utiliser pour calculer le masque.</param>
      <param name="cbReturn">Longueur du masque généré, en octets.</param>
      <returns>Masque généré de manière aléatoire dont la longueur est égale au paramètre <paramref name="cbReturn" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.PKCS1MaskGenerationMethod.HashName">
      <summary>Obtient ou définit le nom de l’algorithme de hachage à utiliser pour générer le masque.</summary>
      <returns>Nom du type qui implémente l’algorithme de hachage à utiliser pour calculer le masque.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RandomNumberGenerator">
      <summary>Représente la classe abstraite dont toutes les implémentations des générateurs de nombres aléatoires de chiffrement doivent hériter.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Security.Cryptography.RandomNumberGenerator" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.Create">
      <summary>Crée une instance de l’implémentation par défaut d’un générateur de nombres aléatoires de chiffrement permettant de générer des données aléatoires.</summary>
      <returns>Nouvelle instance d'un générateur de nombres aléatoires de chiffrement.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.Create(System.String)">
      <summary>Crée une instance de l’implémentation spécifiée d’un générateur de nombres aléatoires de chiffrement.</summary>
      <param name="rngName">Nom de l'implémentation du générateur de nombres aléatoires à utiliser.</param>
      <returns>Nouvelle instance d'un générateur de nombres aléatoires de chiffrement.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.Dispose">
      <summary>En cas de substitution dans une classe dérivée, libère toutes les ressources utilisées par l’instance actuelle de la classe <see cref="T:System.Security.Cryptography.RandomNumberGenerator" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.Dispose(System.Boolean)">
      <summary>En cas de substitution dans une classe dérivée, libère les ressources non managées utilisées par <see cref="T:System.Security.Cryptography.RandomNumberGenerator" /> et libère éventuellement les ressources managées.</summary>
      <param name="disposing">
        <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.Fill(System.Span{System.Byte})">
      <summary>Remplit une étendue avec les octets aléatoires forts du point de vue du chiffrement.</summary>
      <param name="data">Étendue à remplir avec les octets aléatoires forts du point de vue du chiffrement.</param>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetBytes(System.Byte[])">
      <summary>En cas de substitution dans une classe dérivée, remplit un tableau d'octets avec une séquence de valeurs aléatoire et forte du point de vue du chiffrement.</summary>
      <param name="data">Tableau à remplir avec les octets aléatoires forts du point de vue du chiffrement.</param>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetBytes(System.Byte[],System.Int32,System.Int32)">
      <summary>Remplit le tableau d'octets spécifié avec une séquence de valeurs aléatoire et forte du point de vue du chiffrement.</summary>
      <param name="data">Tableau à remplir avec les octets aléatoires forts du point de vue du chiffrement.</param>
      <param name="offset">Index du tableau auquel commencer l'opération de remplissage.</param>
      <param name="count">Nombre d'octets à remplir.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> ou <paramref name="count" /> est inférieur à 0.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="offset" /> plus <paramref name="count" /> excède la longueur de <paramref name="data" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetBytes(System.Span{System.Byte})">
      <summary>Remplit une étendue avec les octets aléatoires forts du point de vue du chiffrement.</summary>
      <param name="data">Étendue à remplir avec les octets aléatoires forts du point de vue du chiffrement.</param>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetInt32(System.Int32)">
      <summary>Génère un entier aléatoire compris entre 0 (inclus) et une limite supérieure exclue spécifiée à l’aide d’un générateur de nombres aléatoires forts du point de vue du chiffrement.</summary>
      <param name="toExclusive">Limite supérieure exclue de la plage aléatoire.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="toExclusive" /> est inférieur ou égal à 0.</exception>
      <returns>Entier aléatoire compris entre 0 (inclus) et <paramref name="toExclusive" /> (exclu).</returns>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetInt32(System.Int32,System.Int32)">
      <summary>Génère un entier aléatoire compris entre une limite inférieure incluse spécifiée et une limite supérieure exclue spécifiée à l’aide d’un générateur de nombres aléatoires forts du point de vue du chiffrement.</summary>
      <param name="fromInclusive">Limite inférieure incluse de la plage aléatoire.</param>
      <param name="toExclusive">Limite supérieure exclue de la plage aléatoire.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="toExclusive" /> est inférieur ou égal au paramètre <paramref name="fromInclusive" />.</exception>
      <returns>Entier aléatoire compris entre <paramref name="fromInclusive" /> (inclus) et <paramref name="toExclusive" /> (exclu).</returns>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetNonZeroBytes(System.Byte[])">
      <summary>En cas de substitution dans une classe dérivée, remplit un tableau d'octets avec une séquence de valeurs différentes de zéro, aléatoire et forte du point de vue du chiffrement.</summary>
      <param name="data">Tableau à remplir avec les octets aléatoires forts du point de vue du chiffrement, différents de zéro.</param>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetNonZeroBytes(System.Span{System.Byte})">
      <summary>Remplit une étendue d’octets avec une séquence aléatoire forte du point de vue du chiffrement de valeurs différentes de zéro.</summary>
      <param name="data">Étendue à remplir avec les octets aléatoires forts du point de vue du chiffrement, différents de zéro.</param>
    </member>
    <member name="T:System.Security.Cryptography.RC2">
      <summary>Représente la classe de base dont toutes les implémentations de l’algorithme <see cref="T:System.Security.Cryptography.RC2" /> doivent dériver.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RC2.EffectiveKeySizeValue">
      <summary>Représente la taille effective de la clé secrète utilisée par l'algorithme <see cref="T:System.Security.Cryptography.RC2" />, en bits.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RC2.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Security.Cryptography.RC2" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RC2.Create">
      <summary>Crée une instance d’un objet de chiffrement pour exécuter l’algorithme <see cref="T:System.Security.Cryptography.RC2" />.</summary>
      <exception cref="T:System.Reflection.TargetInvocationException">L’algorithme a été utilisé en mode FIPS (Federal Information Processing Standards), mais il n’est pas compatible avec la norme FIPS.</exception>
      <returns>Instance d’un objet de chiffrement.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RC2.Create(System.String)">
      <summary>Crée une instance d'un objet de chiffrement pour exécuter l'implémentation spécifiée de l'algorithme <see cref="T:System.Security.Cryptography.RC2" />.</summary>
      <param name="AlgName">Nom de l'implémentation spécifique de <see cref="T:System.Security.Cryptography.RC2" /> à utiliser.</param>
      <exception cref="T:System.Reflection.TargetInvocationException">L'algorithme décrit par le paramètre <paramref name="algName" /> a été utilisé avec mode FIPS activé, mais n'est pas compatible FIPS.</exception>
      <returns>Instance d’un objet de chiffrement.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RC2.EffectiveKeySize">
      <summary>Obtient ou définit la taille effective de la clé secrète utilisée par l’algorithme <see cref="T:System.Security.Cryptography.RC2" />, en bits.</summary>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La taille effective de la clé n’est pas valide.</exception>
      <returns>Taille effective de clé utilisée par l’algorithme <see cref="T:System.Security.Cryptography.RC2" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RC2.KeySize">
      <summary>Obtient ou définit la taille de la clé secrète utilisée par l’algorithme <see cref="T:System.Security.Cryptography.RC2" /> en bits.</summary>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La valeur de taille de clé RC2 est inférieure à la valeur de taille de clé effective.</exception>
      <returns>Taille de la clé secrète utilisée par l’algorithme <see cref="T:System.Security.Cryptography.RC2" /> en bits.</returns>
    </member>
    <member name="T:System.Security.Cryptography.Rfc2898DeriveBytes">
      <summary>Implémente une fonctionnalité de dérivation de clé basée sur mot de passe, PBKDF2, en utilisant un générateur de nombres pseudo-aléatoires basé sur <see cref="T:System.Security.Cryptography.HMACSHA1" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> à l'aide d'un mot de passe, d'un salt et d'un nombre d'itérations pour dériver la clé.</summary>
      <param name="password">Mot de passe utilisé pour dériver la clé.</param>
      <param name="salt">Salt de clé utilisé pour dériver la clé.</param>
      <param name="iterations">Nombre d'itérations pour l'opération.</param>
      <exception cref="T:System.ArgumentException">La taille de salt spécifiée est inférieure à 8 octets ou le nombre d'itérations est inférieur à 1.</exception>
      <exception cref="T:System.ArgumentNullException">Le mot de passe ou le salt est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> en utilisant le mot de passe, le salt, le nombre d’itérations et le nom de l’algorithme de hachage spécifiés pour dériver la clé.</summary>
      <param name="password">Mot de passe à utiliser pour dériver la clé.</param>
      <param name="salt">Salt de clé à utiliser pour dériver la clé.</param>
      <param name="iterations">Nombre d'itérations pour l'opération.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour dériver la clé.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="saltSize" /> est inférieur à zéro.</exception>
      <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> de <paramref name="hashAlgorithm" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le nom de l’algorithme de hachage n’est pas valide.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> à l'aide d'un mot de passe et d'un salt pour dériver la clé.</summary>
      <param name="password">Mot de passe utilisé pour dériver la clé.</param>
      <param name="salt">Salt de clé utilisé pour dériver la clé.</param>
      <exception cref="T:System.ArgumentException">La taille de salt spécifiée est inférieure à 8 octets ou le nombre d'itérations est inférieur à 1.</exception>
      <exception cref="T:System.ArgumentNullException">Le mot de passe ou le salt est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> à l'aide d'un mot de passe, d'un salt et d'un nombre d'itérations pour dériver la clé.</summary>
      <param name="password">Mot de passe utilisé pour dériver la clé.</param>
      <param name="salt">Salt de clé utilisé pour dériver la clé.</param>
      <param name="iterations">Nombre d'itérations pour l'opération.</param>
      <exception cref="T:System.ArgumentException">La taille de salt spécifiée est inférieure à 8 octets ou le nombre d'itérations est inférieur à 1.</exception>
      <exception cref="T:System.ArgumentNullException">Le mot de passe ou le salt est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> en utilisant le mot de passe, le salt, le nombre d’itérations et le nom de l’algorithme de hachage spécifiés pour dériver la clé.</summary>
      <param name="password">Mot de passe à utiliser pour dériver la clé.</param>
      <param name="salt">Salt de clé à utiliser pour dériver la clé.</param>
      <param name="iterations">Nombre d'itérations pour l'opération.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour dériver la clé.</param>
      <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> de <paramref name="hashAlgorithm" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le nom de l’algorithme de hachage n’est pas valide.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> à l'aide du mot de passe et de la taille de salt pour dériver la clé.</summary>
      <param name="password">Mot de passe utilisé pour dériver la clé.</param>
      <param name="saltSize">Taille du salt aléatoire que vous souhaitez que la classe génère.</param>
      <exception cref="T:System.ArgumentException">La taille de salt spécifiée est inférieure à 8 octets.</exception>
      <exception cref="T:System.ArgumentNullException">Le mot de passe ou le salt est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> à l'aide d'un mot de passe, d'une taille de salt et d'un nombre d'itérations pour dériver la clé.</summary>
      <param name="password">Mot de passe utilisé pour dériver la clé.</param>
      <param name="saltSize">Taille du salt aléatoire que vous souhaitez que la classe génère.</param>
      <param name="iterations">Nombre d'itérations pour l'opération.</param>
      <exception cref="T:System.ArgumentException">La taille de salt spécifiée est inférieure à 8 octets ou le nombre d'itérations est inférieur à 1.</exception>
      <exception cref="T:System.ArgumentNullException">Le mot de passe ou le salt est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="iterations" /> est hors limites. Ce paramètre requiert un nombre non négatif.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> en utilisant le mot de passe, la taille de salt, le nombre d’itérations et le nom de l’algorithme de hachage spécifiés pour dériver la clé.</summary>
      <param name="password">Mot de passe à utiliser pour dériver la clé.</param>
      <param name="saltSize">Taille du salt aléatoire que vous souhaitez que la classe génère.</param>
      <param name="iterations">Nombre d'itérations pour l'opération.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour dériver la clé.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="saltSize" /> est inférieur à zéro.</exception>
      <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> de <paramref name="hashAlgorithm" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le nom de l’algorithme de hachage n’est pas valide.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
      <summary>Dérive une clé de chiffrement de l'objet <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />.</summary>
      <param name="algname">Nom de l'algorithme pour lequel la clé doit être dérivée.</param>
      <param name="alghashname">Nom de l'algorithme de hachage à utiliser pour dériver la clé.</param>
      <param name="keySize">Taille de la clé à dériver, en bits.</param>
      <param name="rgbIV">Vecteur d'initialisation (IV) à utiliser pour dériver la clé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le paramètre <paramref name="keySize" /> est incorrect.  
  
- ou - 
Le fournisseur de services de chiffrement ne peut pas être acquis.  
  
- ou - 
Le paramètre <paramref name="algname" /> n'est pas un nom d'algorithme valide.  
  
- ou - 
Le paramètre <paramref name="alghashname" /> n'est pas un nom d'algorithme de hachage valide.</exception>
      <returns>Clé dérivée.</returns>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)">
      <summary>Libère les ressources non managées utilisées par la classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> et libère éventuellement les ressources managées.</summary>
      <param name="disposing">
        <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)">
      <summary>Retourne la clé pseudo-aléatoire de cet objet.</summary>
      <param name="cb">Nombre d'octets de clé pseudo-aléatoires à générer.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="cb" /> est hors limites. Ce paramètre requiert un nombre non négatif.</exception>
      <returns>Tableau d'octets rempli avec des octets de clé pseudo-aléatoires.</returns>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.Reset">
      <summary>Rétablit l'état de l'opération.</summary>
    </member>
    <member name="P:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm" />
    <member name="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount">
      <summary>Obtient ou définit le nombre d'itérations pour l'opération.</summary>
      <exception cref="T:System.ArgumentOutOfRangeException">Le nombre d'itérations est inférieur à 1.</exception>
      <returns>Nombre d'itérations pour l'opération.</returns>
    </member>
    <member name="P:System.Security.Cryptography.Rfc2898DeriveBytes.Salt">
      <summary>Obtient ou définit la valeur salt de clé pour l'opération.</summary>
      <exception cref="T:System.ArgumentException">La taille de salt spécifiée est inférieure à 8 octets.</exception>
      <exception cref="T:System.ArgumentNullException">Le salt est <see langword="null" />.</exception>
      <returns>Valeur salt de clé pour l'opération.</returns>
    </member>
    <member name="T:System.Security.Cryptography.Rijndael">
      <summary>Représente la classe de base dont toutes les implémentations de l'algorithme de chiffrement symétrique <see cref="T:System.Security.Cryptography.Rijndael" /> doivent hériter.</summary>
    </member>
    <member name="M:System.Security.Cryptography.Rijndael.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Security.Cryptography.Rijndael" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.Rijndael.Create">
      <summary>Crée un objet de chiffrement pour exécuter l'algorithme <see cref="T:System.Security.Cryptography.Rijndael" />.</summary>
      <exception cref="T:System.Reflection.TargetInvocationException">L’algorithme a été utilisé en mode FIPS (Federal Information Processing Standards), mais il n’est pas compatible avec la norme FIPS.</exception>
      <returns>Objet de chiffrement.</returns>
    </member>
    <member name="M:System.Security.Cryptography.Rijndael.Create(System.String)">
      <summary>Crée un objet de chiffrement pour effectuer l'implémentation spécifiée de l'algorithme <see cref="T:System.Security.Cryptography.Rijndael" />.</summary>
      <param name="algName">Nom de l'implémentation spécifique de <see cref="T:System.Security.Cryptography.Rijndael" /> à créer.</param>
      <exception cref="T:System.Reflection.TargetInvocationException">L'algorithme décrit par le paramètre <paramref name="algName" /> a été utilisé avec mode FIPS activé, mais n'est pas compatible FIPS.</exception>
      <returns>Objet de chiffrement.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RijndaelManaged">
      <summary>Accède à la version managée de l'algorithme <see cref="T:System.Security.Cryptography.Rijndael" />. Cette classe ne peut pas être héritée.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RijndaelManaged.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RijndaelManaged" />.</summary>
      <exception cref="T:System.InvalidOperationException">Cette classe n'est pas compatible avec l'algorithme FIPS.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RijndaelManaged.CreateDecryptor">
      <summary>Crée un objet déchiffreur symétrique avec la propriété <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key" /> et le vecteur d'initialisation (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />) actuels.</summary>
      <returns>Objet déchiffreur symétrique.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RijndaelManaged.CreateDecryptor(System.Byte[],System.Byte[])">
      <summary>Crée un objet déchiffreur <see cref="T:System.Security.Cryptography.Rijndael" /> symétrique avec le <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key" /> spécifié et le vecteur d'initialisation (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />).</summary>
      <param name="rgbKey">Clé secrète à utiliser pour l'algorithme symétrique. La taille de la clé doit être de 128, 192 ou 256 bits.</param>
      <param name="rgbIV">Vecteur d'initialisation (IV) à utiliser pour l'algorithme symétrique.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="rgbKey" /> a la valeur <see langword="null" />.  
  
- ou - 
Le paramètre <paramref name="rgbIV" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La valeur de la propriété <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Mode" /> n'est ni <see cref="F:System.Security.Cryptography.CipherMode.ECB" />, <see cref="F:System.Security.Cryptography.CipherMode.CBC" /> ni <see cref="F:System.Security.Cryptography.CipherMode.CFB" />.</exception>
      <returns>Objet déchiffreur <see cref="T:System.Security.Cryptography.Rijndael" /> symétrique.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RijndaelManaged.CreateEncryptor">
      <summary>Crée un objet chiffreur symétrique avec la propriété <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key" /> et le vecteur d'initialisation (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />) actuels.</summary>
      <returns>Objet chiffreur symétrique.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RijndaelManaged.CreateEncryptor(System.Byte[],System.Byte[])">
      <summary>Crée un objet chiffreur <see cref="T:System.Security.Cryptography.Rijndael" /> symétrique avec le <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key" /> spécifié et le vecteur d'initialisation (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />).</summary>
      <param name="rgbKey">Clé secrète à utiliser pour l'algorithme symétrique. La taille de la clé doit être de 128, 192 ou 256 bits.</param>
      <param name="rgbIV">Vecteur d'initialisation (IV) à utiliser pour l'algorithme symétrique.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="rgbKey" /> a la valeur <see langword="null" />.  
  
- ou - 
Le paramètre <paramref name="rgbIV" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La valeur de la propriété <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Mode" /> n'est ni <see cref="F:System.Security.Cryptography.CipherMode.ECB" />, <see cref="F:System.Security.Cryptography.CipherMode.CBC" /> ni <see cref="F:System.Security.Cryptography.CipherMode.CFB" />.</exception>
      <returns>Objet chiffreur <see cref="T:System.Security.Cryptography.Rijndael" /> symétrique.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RijndaelManaged.GenerateIV">
      <summary>Génère un vecteur d'initialisation aléatoire (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />) à utiliser pour l'algorithme.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RijndaelManaged.GenerateKey">
      <summary>Génère un <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key" /> aléatoire à utiliser pour l'algorithme.</summary>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.BlockSize">
      <summary>Obtient ou définit la taille de bloc, en bits, de l'opération de chiffrement.</summary>
      <returns>Taille de bloc, en bits, de l’opération de chiffrement. La valeur par défaut est 128 bits.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.IV">
      <summary>Obtient ou définit le vecteur d'initialisation à utiliser pour l'algorithme symétrique.</summary>
      <returns>Vecteur d’initialisation à utiliser pour l’algorithme symétrique.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.Key">
      <summary>Obtient ou définit la clé secrète utilisée pour l'algorithme symétrique.</summary>
      <returns>Clé secrète utilisée pour l’algorithme symétrique.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.KeySize">
      <summary>Obtient ou définit la taille, en bits, de la clé secrète utilisée pour l'algorithme symétrique.</summary>
      <returns>Taille, en bits, de la clé secrète utilisée pour l’algorithme symétrique. La valeur par défaut est 256 bits.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.LegalKeySizes">
      <summary>Obtient les tailles de clé, en octets, prises en charge par l'algorithme symétrique.</summary>
      <returns>Tailles de clé, en bits, prises en charge par l’algorithme symétrique.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.Mode">
      <summary>Obtient ou définit le mode de fonctionnement pour l'algorithme symétrique.</summary>
      <returns>Mode de fonctionnement de l'algorithme symétrique. La valeur par défaut est <see cref="F:System.Security.Cryptography.CipherMode.CBC" /></returns>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.Padding">
      <summary>Obtient ou définit le mode de remplissage utilisé dans l'algorithme symétrique.</summary>
      <returns>Mode de remplissage utilisé dans l'algorithme symétrique. La valeur par défaut est <see cref="F:System.Security.Cryptography.PaddingMode.PKCS7" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RSA">
      <summary>Représente la classe de base dont toutes les implémentations de l'algorithme <see cref="T:System.Security.Cryptography.RSA" /> héritent.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSA.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSA.Create">
      <summary>Crée une instance de l'implémentation par défaut de l'algorithme <see cref="T:System.Security.Cryptography.RSA" />.</summary>
      <returns>Nouvelle instance de l'implémentation par défaut de <see cref="T:System.Security.Cryptography.RSA" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.Create(System.Int32)">
      <summary>Crée une clé RSA éphémère avec la taille de clé spécifiée.</summary>
      <param name="keySizeInBits">Taille de la clé, en bits.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="keySizeInBits" /> n’est pas pris en charge par l’implémentation par défaut.</exception>
      <returns>Nouvelle clé RSA éphémère avec la taille de clé spécifiée.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.Create(System.Security.Cryptography.RSAParameters)">
      <summary>Crée une clé RSA éphémère avec les paramètres de clé RSA spécifiés.</summary>
      <param name="parameters">Paramètres pour l’algorithme <see cref="T:System.Security.Cryptography.RSA" />.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="parameters" /> ne représente pas une clé RSA valide.</exception>
      <returns>Nouvelle clé RSA éphémère.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.Create(System.String)">
      <summary>Crée une instance de l'implémentation spécifiée de <see cref="T:System.Security.Cryptography.RSA" />.</summary>
      <param name="algName">Nom de l'implémentation de <see cref="T:System.Security.Cryptography.RSA" /> à utiliser.</param>
      <returns>Nouvelle instance de l'implémentation spécifiée de <see cref="T:System.Security.Cryptography.RSA" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.Decrypt(System.Byte[],System.Security.Cryptography.RSAEncryptionPadding)">
      <summary>En cas de remplacement dans une classe dérivée, déchiffre les données d’entrée en utilisant le mode de remplissage spécifié.</summary>
      <param name="data">Données à déchiffrer.</param>
      <param name="padding">Mode de remplissage.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ou <paramref name="padding" /> est <see langword="null" />.</exception>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> est inconnu ou n’est pas pris en charge par cette implémentation.

- ou -

La longueur de <paramref name="data" /> n’est pas égale au nombre d’octets pour <see cref="P:System.Security.Cryptography.AsymmetricAlgorithm.KeySize" />.

- ou -

Cette instance représente uniquement une clé publique. 

- ou -

L’opération de déchiffrement a échoué.</exception>
      <returns>Données déchiffrées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.DecryptValue(System.Byte[])">
      <summary>En cas de remplacement dans une classe dérivée, déchiffre les données d'entrée en utilisant la clé privée.</summary>
      <param name="rgb">Texte de chiffrement à déchiffrer.</param>
      <exception cref="T:System.NotSupportedException">Cet appel de méthode n’est pas pris en charge. Cette exception est levée à partir du .NET Framework 4.6.</exception>
      <returns>Déchiffrement résultant du paramètre <paramref name="rgb" /> en texte brut.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.Encrypt(System.Byte[],System.Security.Cryptography.RSAEncryptionPadding)">
      <summary>En cas de remplacement dans une classe dérivée, chiffre les données d’entrée en utilisant le mode de remplissage spécifié.</summary>
      <param name="data">Données à chiffrer.</param>
      <param name="padding">Mode de remplissage.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ou <paramref name="padding" /> est <see langword="null" />.</exception>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> est inconnu ou n’est pas pris en charge par cette implémentation.

- ou -

La longueur de <paramref name="data" /> est trop longue pour la combinaison de <see cref="P:System.Security.Cryptography.AsymmetricAlgorithm.KeySize" /> et du remplissage sélectionné.

- ou -

L’opération de chiffrement a échoué.</exception>
      <returns>Données chiffrées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.EncryptValue(System.Byte[])">
      <summary>En cas de remplacement dans une classe dérivée, chiffre les données d'entrée en utilisant la clé publique.</summary>
      <param name="rgb">Texte brut à chiffrer.</param>
      <exception cref="T:System.NotSupportedException">Cet appel de méthode n’est pas pris en charge. Cette exception est levée à partir du .NET Framework 4.6.</exception>
      <returns>Chiffrement résultant du paramètre <paramref name="rgb" /> en texte chiffré.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ExportParameters(System.Boolean)">
      <summary>En cas de remplacement dans une classe dérivée, exporte les éléments <see cref="T:System.Security.Cryptography.RSAParameters" />.</summary>
      <param name="includePrivateParameters">
        <see langword="true" /> pour inclure les paramètres privés ; sinon <see langword="false" />.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Les paramètres n’ont pas pu être exportés.</exception>
      <returns>Paramètres pour <see cref="T:System.Security.Cryptography.RSA" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ExportRSAPrivateKey">
      <summary>Exporte la clé actuelle au format PKCS#1 RSAPrivateKey.</summary>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
      <returns>Tableau d’octets contenant la représentation PKCS#1 RSAPrivateKey de cette clé.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ExportRSAPublicKey">
      <summary>Exporte la partie clé publique de la clé actuelle au format PKCS#1 RSAPublicKey.</summary>
      <returns>Tableau d’octets contenant la représentation PKCS#1 RSAPublicKey de cette clé.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.FromXmlString(System.String)">
      <summary>Initialise un objet <see cref="T:System.Security.Cryptography.RSA" /> à partir des informations de clé d'une chaîne XML.</summary>
      <param name="xmlString">Chaîne XML qui contient les informations de clé de <see cref="T:System.Security.Cryptography.RSA" />.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="xmlString" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le format du paramètre <paramref name="xmlString" /> n’est pas valide.</exception>
      <exception cref="T:System.PlatformNotSupportedException">.NET Core uniquement : ce membre n’est pas pris en charge.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.HashData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>En cas de remplacement dans une classe dérivée, calcule la valeur de hachage de la partie spécifiée d’un tableau d’octets à l’aide d’un algorithme de hachage spécifié.</summary>
      <param name="data">Données à hacher.</param>
      <param name="offset">Index du premier octet dans les <paramref name="data" /> à hacher.</param>
      <param name="count">Nombre d’octets à hacher.</param>
      <param name="hashAlgorithm">Algorithme à utiliser pour hacher les données.</param>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
      <returns>Données hachées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.HashData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)">
      <summary>En cas de remplacement dans une classe dérivée, calcule la valeur de hachage du flux binaire spécifié en utilisant un algorithme de hachage spécifié.</summary>
      <param name="data">Flux binaire à hacher.</param>
      <param name="hashAlgorithm">L'algorithme de hachage.</param>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
      <returns>Données hachées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure PKCS#8 EncryptedPrivateKeyInfo après le déchiffrement avec un mot de passe basé sur l’octet, en remplaçant les clés de cet objet.</summary>
      <param name="passwordBytes">Octets à utiliser comme mot de passe lors du déchiffrement du matériel de clé.</param>
      <param name="source">Octets d’une structure PKCS#8 EncryptedPrivateKeyInfo dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le mot de passe est incorrect.

- ou -

Le contenu de <paramref name="source" /> indique que la fonction de dérivation de clés (KDF) à appliquer est la fonction KDF PKCS#12 existante, qui nécessite des mots de passe basés sur <see cref="T:System.Char" />.

- ou -

Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 EncryptedPrivateKeyInfo encodée en ASN.1-BER.

- ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

- ou -

Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

- ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure PKCS#8 EncryptedPrivateKeyInfo après le déchiffrement avec un mot de passe basé sur char, en remplaçant les clés de cet objet.</summary>
      <param name="password">Mot de passe à utiliser pour déchiffrer le matériel de clé.</param>
      <param name="source">Octets d’une structure PKCS#8 EncryptedPrivateKeyInfo dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le mot de passe est incorrect.

- ou -

Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 EncryptedPrivateKeyInfo encodée en ASN.1-BER.

- ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

- ou -

Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

- ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportFromEncryptedPem(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte})">
      <summary>Importe une clé privée encodée au format PEM RFC 7468 chiffrée, en remplaçant les clés de cet objet.</summary>
      <param name="input">Texte PEM de la clé chiffrée à importer.</param>
      <param name="passwordBytes">Octets à utiliser comme mot de passe lors du déchiffrement du matériel de clé.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="input" /> ne contient pas de clé encodée au format PEM avec une étiquette reconnue.

- ou -

<paramref name="input" /> contient plusieurs clés encodées au format PEM avec une étiquette reconnue.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le mot de passe est incorrect.

- ou -

Le contenu décodé en base 64 du texte PEM à partir de <paramref name="input" /> ne représente pas une structure de PKCS#8 EncryptedPrivateKeyInfo encodée en ASN.1-BER.

- ou -

Le contenu décodé en base 64 du texte PEM à partir de <paramref name="input" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

- ou -

Le contenu décodé en base 64 du texte PEM à partir de <paramref name="input" /> représente la clé dans un format qui n’est pas pris en charge.

- ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportFromEncryptedPem(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>Importe une clé privée encodée au format PEM RFC 7468 chiffrée, en remplaçant les clés de cet objet.</summary>
      <param name="input">Texte PEM de la clé chiffrée à importer.</param>
      <param name="password">Mot de passe à utiliser pour déchiffrer le matériel de clé.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="input" /> ne contient pas de clé encodée au format PEM avec une étiquette reconnue.

- ou -

<paramref name="input" /> contient plusieurs clés encodées au format PEM avec une étiquette reconnue.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le mot de passe est incorrect.

- ou -

Le contenu décodé en base 64 du texte PEM à partir de <paramref name="input" /> ne représente pas une structure de PKCS#8 EncryptedPrivateKeyInfo encodée en ASN.1-BER.

- ou -

Le contenu décodé en base 64 du texte PEM à partir de <paramref name="input" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

- ou -

Le contenu décodé en base 64 du texte PEM à partir de <paramref name="input" /> représente la clé dans un format qui n’est pas pris en charge.

- ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportFromPem(System.ReadOnlySpan{System.Char})">
      <summary>Importe une clé encodée au format PEM RFC 7468, en remplaçant les clés de cet objet.</summary>
      <param name="input">Texte PEM de la clé à importer.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="input" /> ne contient pas de clé encodée au format PEM avec une étiquette reconnue.

- ou -

<paramref name="input" /> contient plusieurs clés encodées au format PEM avec une étiquette reconnue.

- ou -

<paramref name="input" /> contient une clé encodée au format PEM chiffrée.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportParameters(System.Security.Cryptography.RSAParameters)">
      <summary>En cas de remplacement dans une classe dérivée, importe les éléments <see cref="T:System.Security.Cryptography.RSAParameters" /> spécifiés.</summary>
      <param name="parameters">Paramètres pour <see cref="T:System.Security.Cryptography.RSA" />.</param>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure PKCS#8 PrivateKeyInfo après le déchiffrement, en remplaçant les clés de cet objet.</summary>
      <param name="source">Octets d’une structure PKCS#8 PrivateKeyInfo dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#8 PrivateKeyInfo encodée en ASN.1-BER.

- ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

- ou -

Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

- ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportRSAPrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la paire de clés publique/privée à partir d’une structure PKCS#1 RSAPrivateKey après le déchiffrement, en remplaçant les clés de cet objet.</summary>
      <param name="source">Octets d’une structure PKCS#1 RSAPrivateKey dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#1 RSAPrivateKey encodée en ASN.1-BER.

- ou -

L’importation de clés a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportRSAPublicKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la clé publique à partir d’une structure PKCS#1 RSAPublicKey après le déchiffrement, en remplaçant les clés de cet objet.</summary>
      <param name="source">Octets d’une structure PKCS#1 RSAPublicKey dans l’encodage ASN.1-BER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le contenu de <paramref name="source" /> ne représente pas une structure PKCS#1 RSAPublicKey encodée en ASN.1-BER.

- ou -

L’importation de clés a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportSubjectPublicKeyInfo(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importe la clé publique à partir d’une structure X.509 SubjectPublicKeyInfo après le déchiffrement, en remplaçant les clés de cet objet.</summary>
      <param name="source">Octets d’une structure X.509 SubjectPublicKeyInfo dans l’encodage ASN.1-DER.</param>
      <param name="bytesRead">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets lus à partir de <paramref name="source" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Le contenu de <paramref name="source" /> ne représente pas une structure X.509 SubjectPublicKeyInfo encodée en ASN.1-DER.

- ou -

Le contenu de <paramref name="source" /> indique que la clé est destinée à un algorithme autre que l’algorithme représenté par cette instance.

- ou -

Le contenu de <paramref name="source" /> représente la clé dans un format qui n’est pas pris en charge.

- ou -

L’importation de clé propre à l’algorithme a échoué.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.SignData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Calcule la valeur de hachage d’une partie du tableau d’octets indiqué à l’aide de l’algorithme de hachage et du mode de remplissage spécifiés, et signe la valeur de hachage obtenue.</summary>
      <param name="data">Données d’entrée à hacher et à signer.</param>
      <param name="offset">Décalage dans le tableau à partir duquel l’utilisation de données commence.</param>
      <param name="count">Nombre d'octets dans le tableau à utiliser comme données.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <param name="padding">Mode de remplissage.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="padding" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="count" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="offset" /> + <paramref name="count" /> - 1 génère un index qui dépasse la limite supérieure de <paramref name="data" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> est inconnu ou n’est pas pris en charge par cette implémentation.

- ou -

Cette instance représente uniquement une clé publique.

- ou -

Une erreur s’est produite lors de la création de la signature.</exception>
      <returns>Signature RSA pour les données spécifiées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.SignData(System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Calcule la valeur de hachage du tableau d’octets spécifié en utilisant l’algorithme de hachage et le mode de remplissage spécifiés, et signe la valeur de hachage obtenue.</summary>
      <param name="data">Données d’entrée à hacher et à signer.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <param name="padding">Mode de remplissage.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="padding" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> est inconnu ou n’est pas pris en charge par cette implémentation.

- ou -

Cette instance représente uniquement une clé publique.

- ou -

Une erreur s’est produite lors de la création de la signature.</exception>
      <returns>Signature RSA pour les données spécifiées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.SignData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Calcule la valeur de hachage du flux spécifié en utilisant l’algorithme de hachage et le mode de remplissage spécifiés, et signe la valeur de hachage obtenue.</summary>
      <param name="data">Flux d’entrée à hacher et à signer.</param>
      <param name="hashAlgorithm">Algorithme de hachage à utiliser pour créer la valeur de hachage.</param>
      <param name="padding">Mode de remplissage.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="padding" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> est inconnu ou n’est pas pris en charge par cette implémentation.

- ou -

Cette instance représente uniquement une clé publique.

- ou -

Une erreur s’est produite lors de la création de la signature.</exception>
      <returns>Signature RSA pour les données spécifiées.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.SignHash(System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>En cas de substitution dans une classe dérivée, calcule la signature pour la valeur de hachage spécifiée à l’aide du remplissage spécifié.</summary>
      <param name="hash">Valeur de hachage des données à signer.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage des données.</param>
      <param name="padding">Remplissage.</param>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ou <paramref name="padding" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> est inconnu ou n’est pas pris en charge par cette implémentation.

- ou -

Cette instance représente uniquement une clé publique.

- ou -

Une erreur s’est produite lors de la création de la signature.</exception>
      <returns>Signature RSA pour la valeur de hachage spécifiée.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ToXmlString(System.Boolean)">
      <summary>Crée et retourne une chaîne XML contenant la clé de l'objet <see cref="T:System.Security.Cryptography.RSA" /> actif.</summary>
      <param name="includePrivateParameters">
        <see langword="true" /> pour inclure une clé RSA publique et privée; <see langword="false" /> pour inclure uniquement la clé publique.</param>
      <exception cref="T:System.PlatformNotSupportedException">.NET Core uniquement : ce membre n’est pas pris en charge.</exception>
      <returns>Chaîne XML contenant la clé de l'objet <see cref="T:System.Security.Cryptography.RSA" /> actif.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryDecrypt(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.RSAEncryptionPadding,System.Int32@)">
      <summary>Tente de déchiffrer les données d’entrée à l’aide du mode de remplissage spécifié, en écrivant le résultat dans une mémoire tampon fournie.</summary>
      <param name="data">Données à déchiffrer.</param>
      <param name="destination">Mémoire tampon utilisée pour recevoir les données déchiffrées.</param>
      <param name="padding">Mode de remplissage.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, nombre total d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="padding" /> est <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> est inconnu ou n’est pas pris en charge par cette implémentation.

- ou -

La longueur de <paramref name="data" /> n’est pas égale au nombre d’octets pour <see cref="P:System.Security.Cryptography.AsymmetricAlgorithm.KeySize" />.

- ou -

Cette instance représente uniquement une clé publique. 

- ou -

L’opération de déchiffrement a échoué.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> n’est pas assez long pour recevoir les données déchiffrées ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryEncrypt(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.RSAEncryptionPadding,System.Int32@)">
      <summary>Tente de chiffrer les données d’entrée avec un mode de remplissage spécifié dans une mémoire tampon fournie.</summary>
      <param name="data">Données à chiffrer.</param>
      <param name="destination">Mémoire tampon utilisée pour recevoir les données chiffrées.</param>
      <param name="padding">Mode de remplissage.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, nombre total d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="padding" /> est <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> est inconnu ou n’est pas pris en charge par cette implémentation.

- ou -

La longueur de <paramref name="data" /> est trop longue pour la combinaison de <see cref="P:System.Security.Cryptography.AsymmetricAlgorithm.KeySize" /> et du remplissage sélectionné.

- ou -

L’opération de chiffrement a échoué.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> n’est pas assez long pour recevoir les données chiffrées ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#8 EncryptedPrivateKeyInfo dans une mémoire tampon fournie, à l’aide d’un mot de passe basé sur l’octet.</summary>
      <param name="passwordBytes">Octets à utiliser comme mot de passe lors du chiffrement du matériel de clé.</param>
      <param name="pbeParameters">Paramètres de chiffrement par mot de passe à utiliser lors du chiffrement du matériel de clé.</param>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#8 EncryptedPrivateKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.

- ou -

<paramref name="pbeParameters" /> indique que <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" /> doit être utilisé, ce qui nécessite des mots de passe basés sur <see cref="T:System.Char" />.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#8 EncryptedPrivateKeyInfo dans une mémoire tampon fournie, à l’aide d’un mot de passe basé sur char.</summary>
      <param name="password">Mot de passe à utiliser lors du chiffrement du matériel de clé.</param>
      <param name="pbeParameters">Paramètres de chiffrement par mot de passe à utiliser lors du chiffrement du matériel de clé.</param>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#8 EncryptedPrivateKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryExportPkcs8PrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#8 PrivateKeyInfo dans une mémoire tampon fournie.</summary>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#8 PrivateKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryExportRSAPrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#1 RSAPrivateKey dans une mémoire tampon fournie.</summary>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#1 RSAPrivateKey.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryExportRSAPublicKey(System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format PKCS#1 RSAPublicKey dans une mémoire tampon fournie.</summary>
      <param name="destination">Intervalle d’octets pour recevoir les données PKCS#1 RSAPublicKey.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryExportSubjectPublicKeyInfo(System.Span{System.Byte},System.Int32@)">
      <summary>Tente d’exporter la clé actuelle au format X.509 SubjectPublicKeyInfo dans une mémoire tampon fournie.</summary>
      <param name="destination">Intervalle d’octets pour recevoir les données X.509 SubjectPublicKeyInfo.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, contient une valeur qui indique le nombre d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clé n’a pas pu être exportée.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> est suffisamment grand pour recevoir la sortie ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryHashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Int32@)">
      <summary>Tente de calculer le hachage des données fournies à l’aide de l’algorithme spécifié, en écrivant les résultats dans une mémoire tampon fournie.</summary>
      <param name="data">Données à hacher.</param>
      <param name="destination">Mémoire tampon utilisée pour recevoir la valeur de hachage.</param>
      <param name="hashAlgorithm">Algorithme à utiliser pour hacher les données.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, nombre total d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> n’est pas assez long pour recevoir la valeur de hachage ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TrySignData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding,System.Int32@)">
      <summary>Tente de hacher les données fournies avec l’algorithme spécifié et de signer le hachage avec la clé actuelle, en écrivant la signature dans une mémoire tampon fournie.</summary>
      <param name="data">Données d’entrée à hacher et à signer.</param>
      <param name="destination">Mémoire tampon utilisée pour recevoir la signature RSA.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage des données.</param>
      <param name="padding">Mode de remplissage.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, nombre total d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="padding" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Cette instance représente uniquement une clé publique.

- ou -

Une erreur s’est produite lors de la création de la signature.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> n’est pas assez long pour recevoir la signature RSA ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TrySignHash(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding,System.Int32@)">
      <summary>Tente de signer le hachage avec la clé actuelle, en écrivant la signature dans une mémoire tampon fournie.</summary>
      <param name="hash">Valeur de hachage des données à signer.</param>
      <param name="destination" />
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage des données.</param>
      <param name="padding">Remplissage.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, nombre total d’octets écrits dans <paramref name="destination" />. Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="padding" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> est inconnu ou n’est pas pris en charge par cette implémentation.

- ou -

Cette instance représente uniquement une clé publique.

- ou -

Une erreur s’est produite lors de la création de la signature.</exception>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> n’est pas assez long pour recevoir la signature RSA ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.VerifyData(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Vérifie qu’une signature numérique est valide en calculant la valeur de hachage des données indiquées à l’aide de l’algorithme de hachage et du remplissage spécifiés, et en la comparant à la signature fournie.</summary>
      <param name="data">Données signées.</param>
      <param name="signature">Données de la signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage des données.</param>
      <param name="padding">Mode de remplissage.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="signature" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="padding" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> est inconnu ou n’est pas pris en charge par cette implémentation.</exception>
      <returns>
        <see langword="true" /> si la signature est valide ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.VerifyData(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Vérifie qu’une signature numérique est valide en calculant la valeur de hachage des données dans une partie d’un tableau d’octets à l’aide de l’algorithme de hachage et du remplissage spécifiés, et en la comparant à la signature fournie.</summary>
      <param name="data">Données signées.</param>
      <param name="offset">Index de départ à partir duquel calculer le hachage.</param>
      <param name="count">Nombre d’octets à hacher.</param>
      <param name="signature">Données de la signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage des données.</param>
      <param name="padding">Mode de remplissage.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="signature" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="padding" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="count" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="offset" /> + <paramref name="count" /> - 1 génère un index qui dépasse la limite supérieure de <paramref name="data" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> est inconnu ou n’est pas pris en charge par cette implémentation.</exception>
      <returns>
        <see langword="true" /> si la signature est valide ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.VerifyData(System.IO.Stream,System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Vérifie qu’une signature numérique est valide en calculant la valeur de hachage du flux spécifié en utilisant l’algorithme de hachage et le remplissage spécifiés, et en la comparant à la signature fournie.</summary>
      <param name="data">Données signées.</param>
      <param name="signature">Données de la signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage des données.</param>
      <param name="padding">Mode de remplissage.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="signature" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="padding" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> est inconnu ou n’est pas pris en charge par cette implémentation.</exception>
      <returns>
        <see langword="true" /> si la signature est valide ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.VerifyData(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Vérifie qu’une signature numérique est valide en calculant la valeur de hachage des données indiquées à l’aide de l’algorithme de hachage et du remplissage spécifiés, et en la comparant à la signature fournie.</summary>
      <param name="data">Données signées.</param>
      <param name="signature">Données de la signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage des données.</param>
      <param name="padding">Mode de remplissage.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> est inconnu ou n’est pas pris en charge par cette implémentation.</exception>
      <returns>
        <see langword="true" /> si la signature est valide ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.VerifyHash(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Vérifie qu’une signature numérique est valide en déterminant la valeur de hachage dans la signature en utilisant l’algorithme de hachage et le remplissage spécifiés, et en la comparant à la valeur de hachage fournie.</summary>
      <param name="hash">Valeur de hachage des données signées.</param>
      <param name="signature">Données de la signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage.</param>
      <param name="padding">Mode de remplissage.</param>
      <exception cref="T:System.NotImplementedException">Une classe dérivée doit remplacer cette méthode.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="hash" /> ou <paramref name="padding" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> est inconnu ou n’est pas pris en charge par cette implémentation.</exception>
      <returns>
        <see langword="true" /> si la signature est valide ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.VerifyHash(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Vérifie qu’une signature numérique est valide en déterminant la valeur de hachage dans la signature en utilisant l’algorithme de hachage et le remplissage spécifiés, et en la comparant à la valeur de hachage fournie.</summary>
      <param name="hash">Valeur de hachage des données signées.</param>
      <param name="signature">Données de la signature à vérifier.</param>
      <param name="hashAlgorithm">Algorithme de hachage utilisé pour créer la valeur de hachage.</param>
      <param name="padding">Mode de remplissage.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="hash" /> ou <paramref name="padding" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> est inconnu ou n’est pas pris en charge par cette implémentation.</exception>
      <returns>
        <see langword="true" /> si la signature est valide ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSA.KeyExchangeAlgorithm">
      <summary>Obtient le nom de l’algorithme d’échange de clés disponible avec cette implémentation de <see cref="T:System.Security.Cryptography.RSA" />.</summary>
      <returns>Retourne « RSA ».</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSA.SignatureAlgorithm">
      <summary>Obtient le nom de l’algorithme de signature disponible avec cette implémentation de <see cref="T:System.Security.Cryptography.RSA" />.</summary>
      <returns>Retourne « RSA ».</returns>
    </member>
    <member name="T:System.Security.Cryptography.RSAEncryptionPadding">
      <summary>Spécifie le mode de remplissage et les paramètres à utiliser avec les opérations de chiffrement ou de déchiffrement RSA.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.CreateOaep(System.Security.Cryptography.HashAlgorithmName)">
      <summary>Crée une instance de <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" /> dont le <see cref="P:System.Security.Cryptography.RSAEncryptionPadding.Mode" /> est <see cref="F:System.Security.Cryptography.RSAEncryptionPaddingMode.Oaep" /> avec l’algorithme de hachage donné.</summary>
      <param name="hashAlgorithm">L'algorithme de hachage.</param>
      <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> de <paramref name="hashAlgorithm" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
      <returns>Un objet dont le mode est <see cref="P:System.Security.Cryptography.RSAEncryptionPadding.Mode" /> est <see cref="F:System.Security.Cryptography.RSAEncryptionPaddingMode.Oaep" /> avec l’algorithme de hachage spécifié par <paramref name="hashAlgorithm" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.Equals(System.Object)">
      <summary>Détermine si l’instance actuelle est égale à l’objet spécifié.</summary>
      <param name="obj">Objet à comparer.</param>
      <returns>
        <see langword="true" /> si l’objet <paramref name="obj" /> est égal à l’instance actuelle ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.Equals(System.Security.Cryptography.RSAEncryptionPadding)">
      <summary>Détermine si l’instance actuelle est égale à l’objet <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" /> spécifié.</summary>
      <param name="other">Objet à comparer.</param>
      <returns>
        <see langword="true" /> si l’objet <paramref name="other" /> est égal à l’instance actuelle ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.GetHashCode">
      <summary>Retourne le code de hachage de cet objet <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" />.</summary>
      <returns>Code de hachage de cette instance.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.op_Equality(System.Security.Cryptography.RSAEncryptionPadding,System.Security.Cryptography.RSAEncryptionPadding)">
      <summary>Indique si deux objets <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" /> spécifiés sont égaux.</summary>
      <param name="left">Premier objet à comparer.</param>
      <param name="right">Deuxième objet à comparer.</param>
      <returns>
        <see langword="true" /> si <see langword="left" /> et <see langword="right" /> sont égales ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.op_Inequality(System.Security.Cryptography.RSAEncryptionPadding,System.Security.Cryptography.RSAEncryptionPadding)">
      <summary>Indique si deux objets <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" /> spécifiés sont inégaux.</summary>
      <param name="left">Premier objet à comparer.</param>
      <param name="right">Deuxième objet à comparer.</param>
      <returns>
        <see langword="true" /> si <see langword="left" /> et <see langword="right" /> ne sont pas égales ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.ToString">
      <summary>Retourne la représentation sous forme de chaîne de l'instance <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" /> actuelle.</summary>
      <returns>Représentation sous forme de chaîne de l’objet actuel.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.Mode">
      <summary>Obtient le mode de remplissage représenté par cette instance <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" />.</summary>
      <returns>Mode de remplissage.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.OaepHashAlgorithm">
      <summary>Obtient l’algorithme de hachage utilisé conjointement avec le mode de remplissage <see cref="F:System.Security.Cryptography.RSAEncryptionPaddingMode.Oaep" />.</summary>
      <returns>L'algorithme de hachage.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.OaepSHA1">
      <summary>Obtient un objet qui représente la norme de chiffrement OAEP (Optimal Asymmetric Encryption Padding) avec un algorithme de hachage SHA1.</summary>
      <returns>Objet qui représente la norme de chiffrement OAEP avec un algorithme de hachage SHA1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.OaepSHA256">
      <summary>Obtient un objet qui représente la norme de chiffrement OAEP (Optimal Asymmetric Encryption Padding) avec un algorithme de hachage SHA256.</summary>
      <returns>Objet qui représente la norme de chiffrement OAEP avec un algorithme de hachage SHA256.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.OaepSHA384">
      <summary>Obtient un objet qui représente la norme de chiffrement OAEP (Optimal Asymmetric Encryption Padding) avec un algorithme de hachage SHA-384.</summary>
      <returns>Objet qui représente la norme de chiffrement OAEP avec un algorithme de hachage SHA384.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.OaepSHA512">
      <summary>Obtient un objet qui représente la norme de chiffrement OAEP (Optimal Asymmetric Encryption Padding) avec un algorithme de hachage SHA512.</summary>
      <returns>Objet qui représente la norme de chiffrement OAEP avec un algorithme de hachage SHA512.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.Pkcs1">
      <summary>Obtient un objet qui représente la norme de chiffrement PKCS #1.</summary>
      <returns>Objet qui représente la norme de chiffrement PKCS #1.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RSAEncryptionPaddingMode">
      <summary>Spécifie le mode de remplissage à utiliser avec les opérations de chiffrement ou de déchiffrement RSA.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAEncryptionPaddingMode.Oaep">
      <summary>OAEP (Optimal Asymmetric Encryption Padding). Il est recommandé pour les nouvelles applications.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAEncryptionPaddingMode.Pkcs1">
      <summary>PKCS #1 v1.5. Il est pris en charge pour la compatibilité avec des applications existantes.</summary>
    </member>
    <member name="T:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter">
      <summary>Déchiffre les données d’échange de clés OAEP (Optimal Asymmetric Encryption Padding).</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter" /> avec la clé spécifiée.</summary>
      <param name="key">Instance de l’algorithme <see cref="T:System.Security.Cryptography.RSA" /> qui contient la clé privée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter.DecryptKeyExchange(System.Byte[])">
      <summary>Extrait des informations confidentielles à partir des données d’échange de clés chiffrées.</summary>
      <param name="rgbData">Données d’échange de clés dans lesquelles les informations confidentielles sont cachées.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La vérification des données d’échange de clés a échoué.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">La clé est manquante.</exception>
      <returns>Informations confidentielles dérivées des données d’échange de clés.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Définit la clé privée à utiliser pour déchiffrer les informations confidentielles.</summary>
      <param name="key">Instance de l’algorithme <see cref="T:System.Security.Cryptography.RSA" /> qui contient la clé privée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="P:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter.Parameters">
      <summary>Obtient les paramètres pour l’échange de clés OAEP (Optimal Asymmetric Encryption Padding).</summary>
      <returns>Chaîne XML contenant les paramètres de l’opération d’échange de clés OAEP.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter">
      <summary>Crée des données d’échange de clés OAEP (Optimal Asymmetric Encryption Padding) à l’aide de <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter" /> avec la clé spécifiée.</summary>
      <param name="key">Instance de l’algorithme <see cref="T:System.Security.Cryptography.RSA" /> qui contient la clé publique.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.CreateKeyExchange(System.Byte[])">
      <summary>Crée les données d’échange de clés chiffrées à partir des données d’entrée spécifiées.</summary>
      <param name="rgbData">Informations confidentielles à passer dans l’échange de clés.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">La clé est manquante.</exception>
      <returns>Données d’échange de clés chiffrées à envoyer au destinataire prévu.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.CreateKeyExchange(System.Byte[],System.Type)">
      <summary>Crée les données d’échange de clés chiffrées à partir des données d’entrée spécifiées.</summary>
      <param name="rgbData">Informations confidentielles à passer dans l’échange de clés.</param>
      <param name="symAlgType">Ce paramètre n’est pas utilisé dans la version actuelle.</param>
      <returns>Données d’échange de clés chiffrées à envoyer au destinataire prévu.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Définit la clé publique à utiliser pour chiffrer les données d’échange de clés.</summary>
      <param name="key">Instance de l’algorithme <see cref="T:System.Security.Cryptography.RSA" /> qui contient la clé publique.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="P:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.Parameter">
      <summary>Obtient ou définit le paramètre utilisé pour créer le remplissage dans le processus de création d’un échange de clé.</summary>
      <returns>Valeur du paramètre.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.Parameters">
      <summary>Obtient les paramètres pour l’échange de clés OAEP (Optimal Asymmetric Encryption Padding).</summary>
      <returns>Chaîne XML contenant les paramètres de l’opération d’échange de clés OAEP.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.Rng">
      <summary>Obtient ou définit l’algorithme du générateur de nombres aléatoires à utiliser dans la création de l’échange de clés.</summary>
      <returns>Instance d’un algorithme du générateur de nombres aléatoires à utiliser.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RSAParameters">
      <summary>Représente les paramètres standard pour l’algorithme <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.D">
      <summary>Représente le paramètre <see langword="D" /> pour l’algorithme <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.DP">
      <summary>Représente le paramètre <see langword="DP" /> pour l’algorithme <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.DQ">
      <summary>Représente le paramètre <see langword="DQ" /> pour l’algorithme <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.Exponent">
      <summary>Représente le paramètre <see langword="Exponent" /> pour l’algorithme <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.InverseQ">
      <summary>Représente le paramètre <see langword="InverseQ" /> pour l’algorithme <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.Modulus">
      <summary>Représente le paramètre <see langword="Modulus" /> pour l’algorithme <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.P">
      <summary>Représente le paramètre <see langword="P" /> pour l’algorithme <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.Q">
      <summary>Représente le paramètre <see langword="Q" /> pour l’algorithme <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="T:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter">
      <summary>Déchiffre les données d’échange de clés PKCS #1.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter" /> avec la clé spécifiée.</summary>
      <param name="key">Instance de l’algorithme <see cref="T:System.Security.Cryptography.RSA" /> qui contient la clé privée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.DecryptKeyExchange(System.Byte[])">
      <summary>Extrait des informations confidentielles à partir des données d’échange de clés chiffrées.</summary>
      <param name="rgbIn">Données d’échange de clés dans lesquelles les informations confidentielles sont cachées.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">La clé est manquante.</exception>
      <returns>Informations confidentielles dérivées des données d’échange de clés.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Définit la clé privée à utiliser pour déchiffrer les informations confidentielles.</summary>
      <param name="key">Instance de l’algorithme <see cref="T:System.Security.Cryptography.RSA" /> qui contient la clé privée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="P:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.Parameters">
      <summary>Obtient les paramètres de l’échange de clés PKCS #1.</summary>
      <returns>Chaîne XML contenant les paramètres de l’opération d’échange de clés PKCS #1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.RNG">
      <summary>Obtient ou définit l’algorithme du générateur de nombres aléatoires à utiliser dans la création de l’échange de clés.</summary>
      <returns>Instance d’un algorithme du générateur de nombres aléatoires à utiliser.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter">
      <summary>Crée les données d’échange de clés PKCS#1 à l’aide de <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter" /> avec la clé spécifiée.</summary>
      <param name="key">Instance de l’algorithme <see cref="T:System.Security.Cryptography.RSA" /> qui contient la clé publique.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.CreateKeyExchange(System.Byte[])">
      <summary>Crée les données d’échange de clés chiffrées à partir des données d’entrée spécifiées.</summary>
      <param name="rgbData">Informations confidentielles à passer dans l’échange de clés.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="rgbData" /> est trop volumineux.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">La clé est <see langword="null" />.</exception>
      <returns>Données d’échange de clés chiffrées à envoyer au destinataire prévu.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.CreateKeyExchange(System.Byte[],System.Type)">
      <summary>Crée les données d’échange de clés chiffrées à partir des données d’entrée spécifiées.</summary>
      <param name="rgbData">Informations confidentielles à passer dans l’échange de clés.</param>
      <param name="symAlgType">Ce paramètre n’est pas utilisé dans la version actuelle.</param>
      <returns>Données d’échange de clés chiffrées à envoyer au destinataire prévu.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Définit la clé publique à utiliser pour chiffrer les données d’échange de clés.</summary>
      <param name="key">Instance de l’algorithme <see cref="T:System.Security.Cryptography.RSA" /> qui contient la clé publique.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="P:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.Parameters">
      <summary>Obtient les paramètres de l’échange de clés PKCS #1.</summary>
      <returns>Chaîne XML contenant les paramètres de l’opération d’échange de clés PKCS #1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.Rng">
      <summary>Obtient ou définit l’algorithme du générateur de nombres aléatoires à utiliser dans la création de l’échange de clés.</summary>
      <returns>Instance d’un algorithme du générateur de nombres aléatoires à utiliser.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RSAPKCS1SignatureDeformatter">
      <summary>Vérifie une signature PKCS #1 version 1.5 <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureDeformatter.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RSAPKCS1SignatureDeformatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureDeformatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RSAPKCS1SignatureDeformatter" /> avec la clé spécifiée.</summary>
      <param name="key">Instance de <see cref="T:System.Security.Cryptography.RSA" /> qui contient la clé publique.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureDeformatter.SetHashAlgorithm(System.String)">
      <summary>Définit l’algorithme de hachage à utiliser pour vérifier la signature.</summary>
      <param name="strName">Nom de l’algorithme de hachage à utiliser pour vérifier la signature.</param>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Définit la clé publique à utiliser pour vérifier la signature.</summary>
      <param name="key">Instance de <see cref="T:System.Security.Cryptography.RSA" /> qui contient la clé publique.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureDeformatter.VerifySignature(System.Byte[],System.Byte[])">
      <summary>Vérifie la signature PKCS #1 <see cref="T:System.Security.Cryptography.RSA" /> pour les données spécifiées.</summary>
      <param name="rgbHash">Données signées avec <paramref name="rgbSignature" />.</param>
      <param name="rgbSignature">Signature à vérifier pour <paramref name="rgbHash" />.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">La clé est <see langword="null" />.  
  
- ou - 
L’algorithme de hachage a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="rgbHash" /> a la valeur <see langword="null" />.  
  
- ou - 
Le paramètre <paramref name="rgbSignature" /> a la valeur <see langword="null" />.</exception>
      <returns>
        <see langword="true" /> si <paramref name="rgbSignature" /> correspond à la signature traitée à l’aide de l’algorithme de hachage et de la clé spécifiés sur <paramref name="rgbHash" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RSAPKCS1SignatureFormatter">
      <summary>Crée une signature PKCS #1 version 1.5 <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureFormatter.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RSAPKCS1SignatureFormatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureFormatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.RSAPKCS1SignatureFormatter" /> avec la clé spécifiée.</summary>
      <param name="key">Instance de l’algorithme <see cref="T:System.Security.Cryptography.RSA" /> qui contient la clé privée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureFormatter.CreateSignature(System.Byte[])">
      <summary>Crée la signature PKCS #1 <see cref="T:System.Security.Cryptography.RSA" /> pour les données spécifiées.</summary>
      <param name="rgbHash">Données à signer.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">La clé est <see langword="null" />.  
  
- ou - 
L’algorithme de hachage a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="rgbHash" /> a la valeur <see langword="null" />.</exception>
      <returns>Signature numérique pour <paramref name="rgbHash" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureFormatter.SetHashAlgorithm(System.String)">
      <summary>Définit l’algorithme de hachage à utiliser pour créer la signature.</summary>
      <param name="strName">Nom de l’algorithme de hachage à utiliser pour créer la signature.</param>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Définit la clé privée à utiliser pour créer la signature.</summary>
      <param name="key">Instance de l’algorithme <see cref="T:System.Security.Cryptography.RSA" /> qui contient la clé privée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="T:System.Security.Cryptography.RSASignaturePadding">
      <summary>Spécifie le mode de remplissage et les paramètres à utiliser avec les opérations de création ou de vérification de signature RSA.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSASignaturePadding.Equals(System.Object)">
      <summary>Retourne une valeur qui indique si cette instance est égale à un objet spécifié.</summary>
      <param name="obj">Objet à comparer à l’instance actuelle.</param>
      <returns>
        <see langword="true" /> si l’objet spécifié est égal à l’objet actuel ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSASignaturePadding.Equals(System.Security.Cryptography.RSASignaturePadding)">
      <summary>Retourne une valeur indiquant si cette instance équivaut à un objet <see cref="T:System.Security.Cryptography.RSASignaturePadding" /> spécifié.</summary>
      <param name="other">Objet à comparer à l’instance actuelle.</param>
      <returns>
        <see langword="true" /> si l’objet spécifié est égal à l’objet actuel ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSASignaturePadding.GetHashCode">
      <summary>Retourne le code de hachage de cette instance <see cref="T:System.Security.Cryptography.RSASignaturePadding" />.</summary>
      <returns>Code de hachage pour cette instance de <see cref="T:System.Security.Cryptography.RSASignaturePadding" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSASignaturePadding.op_Equality(System.Security.Cryptography.RSASignaturePadding,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Indique si deux objets <see cref="T:System.Security.Cryptography.RSASignaturePadding" /> spécifiés sont égaux.</summary>
      <param name="left">Premier objet à comparer.</param>
      <param name="right">Deuxième objet à comparer.</param>
      <returns>
        <see langword="true" /> si <see langword="left" /> et <see langword="right" /> sont égales ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSASignaturePadding.op_Inequality(System.Security.Cryptography.RSASignaturePadding,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Indique si deux objets <see cref="T:System.Security.Cryptography.RSASignaturePadding" /> spécifiés sont inégaux.</summary>
      <param name="left">Premier objet à comparer.</param>
      <param name="right">Deuxième objet à comparer.</param>
      <returns>
        <see langword="true" /> si <see langword="left" /> et <see langword="right" /> sont inégaux ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSASignaturePadding.ToString">
      <summary>Retourne la représentation sous forme de chaîne de l'instance <see cref="T:System.Security.Cryptography.RSASignaturePadding" /> actuelle.</summary>
      <returns>Représentation sous forme de chaîne de l’objet actuel.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSASignaturePadding.Mode">
      <summary>Obtient le mode de remplissage de cette instance de <see cref="T:System.Security.Cryptography.RSASignaturePadding" />.</summary>
      <returns>Mode de remplissage (<see cref="F:System.Security.Cryptography.RSASignaturePaddingMode.Pkcs1" /> ou <see cref="F:System.Security.Cryptography.RSASignaturePaddingMode.Pss" />) de cette instance.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSASignaturePadding.Pkcs1">
      <summary>Obtient un objet qui utilise le mode de remplissage PKCS #1 v1.5.</summary>
      <returns>Objet qui utilise le mode de remplissage <see cref="F:System.Security.Cryptography.RSASignaturePaddingMode.Pkcs1" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSASignaturePadding.Pss">
      <summary>Obtient un objet qui utilise le mode de remplissage PSS.</summary>
      <returns>Objet qui utilise le mode de remplissage <see cref="F:System.Security.Cryptography.RSASignaturePaddingMode.Pss" /> avec le nombre d’octets de salt égal à la taille du hachage.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RSASignaturePaddingMode">
      <summary>Spécifie le mode de remplissage à utiliser avec les opérations de création ou de vérification de signature RSA.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSASignaturePaddingMode.Pkcs1">
      <summary>PKCS #1 v1.5.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSASignaturePaddingMode.Pss">
      <summary>Schéma de signature probabiliste.</summary>
    </member>
    <member name="T:System.Security.Cryptography.SHA1">
      <summary>Calcule le hachage <see cref="T:System.Security.Cryptography.SHA1" /> pour les données d'entrée.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA1.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Security.Cryptography.SHA1" />.</summary>
      <exception cref="T:System.InvalidOperationException">La stratégie de cet objet n'est pas compatible avec l'algorithme FIPS.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SHA1.Create">
      <summary>Crée une instance de l'implémentation par défaut de <see cref="T:System.Security.Cryptography.SHA1" />.</summary>
      <returns>Nouvelle instance de <see cref="T:System.Security.Cryptography.SHA1" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA1.Create(System.String)">
      <summary>Crée une instance de l'implémentation spécifiée de <see cref="T:System.Security.Cryptography.SHA1" />.</summary>
      <param name="hashName">Nom de l'implémentation spécifique de <see cref="T:System.Security.Cryptography.SHA1" /> à utiliser.</param>
      <returns>Nouvelle instance de <see cref="T:System.Security.Cryptography.SHA1" /> à l'aide de l'implémentation spécifiée.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA1.HashData(System.Byte[])">
      <summary>Calcule le hachage des données à l’aide de l’algorithme SHA1.</summary>
      <param name="source">Données à hacher.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> est <see langword="null" />.</exception>
      <returns>Hachage des données.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA1.HashData(System.ReadOnlySpan{System.Byte})">
      <summary>Calcule le hachage des données à l’aide de l’algorithme SHA1.</summary>
      <param name="source">Données à hacher.</param>
      <returns>Hachage des données.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA1.HashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
      <summary>Calcule le hachage des données à l’aide de l’algorithme SHA1.</summary>
      <param name="source">Données à hacher.</param>
      <param name="destination">Mémoire tampon utilisée pour recevoir la valeur de hachage.</param>
      <exception cref="T:System.ArgumentException">La mémoire tampon de <paramref name="destination" /> est trop petite pour contenir la taille de hachage calculée. L’algorithme SHA1 produit toujours un hachage 160 bits, soit 20 octets.</exception>
      <returns>Nombre total d’octets écrits dans <paramref name="destination" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA1.TryHashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@)">
      <summary>Tente de calculer le hachage des données à l’aide de l’algorithme SHA1.</summary>
      <param name="source">Données à hacher.</param>
      <param name="destination">Mémoire tampon utilisée pour recevoir la valeur de hachage.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, nombre total d’octets écrits dans <paramref name="destination" />.</param>
      <returns>
        <see langword="false" /> si <paramref name="destination" /> est trop petit pour contenir le hachage calculé, <see langword="true" /> dans le cas contraire.</returns>
    </member>
    <member name="T:System.Security.Cryptography.SHA1Managed">
      <summary>Calcule le hachage <see cref="T:System.Security.Cryptography.SHA1" /> pour les données d'entrée à l'aide de la bibliothèque managée.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA1Managed.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.SHA1Managed" />.</summary>
      <exception cref="T:System.InvalidOperationException">Cette classe n'est pas compatible avec l'algorithme FIPS.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SHA1Managed.Initialize">
      <summary>Initialise une instance de <see cref="T:System.Security.Cryptography.SHA1Managed" />.</summary>
    </member>
    <member name="T:System.Security.Cryptography.SHA256">
      <summary>Calcule le hachage <see cref="T:System.Security.Cryptography.SHA256" /> pour les données d'entrée.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA256.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Security.Cryptography.SHA256" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA256.Create">
      <summary>Crée une instance de l'implémentation par défaut de <see cref="T:System.Security.Cryptography.SHA256" />.</summary>
      <exception cref="T:System.Reflection.TargetInvocationException">Sur le .NET Framework 4.6.1 et versions antérieures : l’algorithme a été utilisé en mode FIPS (Federal Information Processing Standards), mais il n’est pas compatible avec la norme FIPS.</exception>
      <returns>Nouvelle instance de <see cref="T:System.Security.Cryptography.SHA256" />. Sur le .NET Framework, cette méthode crée une instance de la classe <see cref="T:System.Security.Cryptography.SHA256Managed" /> si le mode FIPS n’est pas actif ; si le mode FIPS est actif, elle crée une instance de la classe <see cref="T:System.Security.Cryptography.SHA256Cng" />. Sur .NET Core, elle retourne une instance d’une classe privée dérivée de <see cref="T:System.Security.Cryptography.SHA256" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA256.Create(System.String)">
      <summary>Crée une instance de l'implémentation spécifiée de <see cref="T:System.Security.Cryptography.SHA256" />.</summary>
      <param name="hashName">Nom de l'implémentation spécifique de <see cref="T:System.Security.Cryptography.SHA256" /> à utiliser.</param>
      <exception cref="T:System.Reflection.TargetInvocationException">Sur le .NET Framework uniquement : le mode FIPS est activé, mais <paramref name="hashName" /> demande <see cref="T:System.Security.Cryptography.SHA256Managed" />, qui n’est pas compatible avec la norme FIPS.</exception>
      <returns>Nouvelle instance de <see cref="T:System.Security.Cryptography.SHA256" /> à l'aide de l'implémentation spécifiée.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA256.HashData(System.Byte[])">
      <summary>Calcule le hachage des données à l’aide de l’algorithme SHA256.</summary>
      <param name="source">Données à hacher.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> est <see langword="null" />.</exception>
      <returns>Hachage des données.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA256.HashData(System.ReadOnlySpan{System.Byte})">
      <summary>Calcule le hachage des données à l’aide de l’algorithme SHA256.</summary>
      <param name="source">Données à hacher.</param>
      <returns>Hachage des données.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA256.HashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
      <summary>Calcule le hachage des données à l’aide de l’algorithme SHA256.</summary>
      <param name="source">Données à hacher.</param>
      <param name="destination">Mémoire tampon utilisée pour recevoir la valeur de hachage.</param>
      <exception cref="T:System.ArgumentException">La mémoire tampon de <paramref name="destination" /> est trop petite pour contenir la taille de hachage calculée. L’algorithme SHA256 produit toujours un hachage 256 bits, soit 32 octets.</exception>
      <returns>Nombre total d’octets écrits dans <paramref name="destination" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA256.TryHashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@)">
      <summary>Tente de calculer le hachage des données à l’aide de l’algorithme SHA256.</summary>
      <param name="source">Données à hacher.</param>
      <param name="destination">Mémoire tampon utilisée pour recevoir la valeur de hachage.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, nombre total d’octets écrits dans <paramref name="destination" />.</param>
      <returns>
        <see langword="false" /> si <paramref name="destination" /> est trop petit pour contenir le hachage calculé, <see langword="true" /> dans le cas contraire.</returns>
    </member>
    <member name="T:System.Security.Cryptography.SHA256Managed">
      <summary>Calcule le hachage <see cref="T:System.Security.Cryptography.SHA256" /> pour les données d'entrée à l'aide de la bibliothèque managée.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA256Managed.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.SHA256Managed" /> à l'aide de la bibliothèque managée.</summary>
      <exception cref="T:System.InvalidOperationException">Le paramètre de sécurité FIPS (Federal Information Processing Standards) est activé. Cette implémentation ne fait pas partie des algorithmes de chiffrement validés FIPS pour les plateformes Windows.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SHA256Managed.Initialize">
      <summary>Initialise une instance de <see cref="T:System.Security.Cryptography.SHA256Managed" />.</summary>
    </member>
    <member name="T:System.Security.Cryptography.SHA384">
      <summary>Calcule le hachage <see cref="T:System.Security.Cryptography.SHA384" /> pour les données d'entrée.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA384.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Security.Cryptography.SHA384" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA384.Create">
      <summary>Crée une instance de l'implémentation par défaut de <see cref="T:System.Security.Cryptography.SHA384" />.</summary>
      <exception cref="T:System.Reflection.TargetInvocationException">L’algorithme a été utilisé en mode FIPS (Federal Information Processing Standards), mais il n’est pas compatible avec la norme FIPS.</exception>
      <returns>Nouvelle instance de <see cref="T:System.Security.Cryptography.SHA384" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA384.Create(System.String)">
      <summary>Crée une instance de l'implémentation spécifiée de <see cref="T:System.Security.Cryptography.SHA384" />.</summary>
      <param name="hashName">Nom de l'implémentation spécifique de <see cref="T:System.Security.Cryptography.SHA384" /> à utiliser.</param>
      <exception cref="T:System.Reflection.TargetInvocationException">L'algorithme décrit par le paramètre <paramref name="hashName" /> a été utilisé avec mode FIPS activé, mais n'est pas compatible FIPS.</exception>
      <returns>Nouvelle instance de <see cref="T:System.Security.Cryptography.SHA384" /> à l'aide de l'implémentation spécifiée.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA384.HashData(System.Byte[])">
      <summary>Calcule le hachage des données à l’aide de l’algorithme SHA384.</summary>
      <param name="source">Données à hacher.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> est <see langword="null" />.</exception>
      <returns>Hachage des données.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA384.HashData(System.ReadOnlySpan{System.Byte})">
      <summary>Calcule le hachage des données à l’aide de l’algorithme SHA384.</summary>
      <param name="source">Données à hacher.</param>
      <returns>Hachage des données.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA384.HashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
      <summary>Calcule le hachage des données à l’aide de l’algorithme SHA384.</summary>
      <param name="source">Données à hacher.</param>
      <param name="destination">Mémoire tampon utilisée pour recevoir la valeur de hachage.</param>
      <exception cref="T:System.ArgumentException">La mémoire tampon de <paramref name="destination" /> est trop petite pour contenir la taille de hachage calculée. L’algorithme SHA384 produit toujours un hachage 384 bits, soit 48 octets.</exception>
      <returns>Nombre total d’octets écrits dans <paramref name="destination" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA384.TryHashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@)">
      <summary>Tente de calculer le hachage des données à l’aide de l’algorithme SHA384.</summary>
      <param name="source">Données à hacher.</param>
      <param name="destination">Mémoire tampon utilisée pour recevoir la valeur de hachage.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, nombre total d’octets écrits dans <paramref name="destination" />.</param>
      <returns>
        <see langword="false" /> si <paramref name="destination" /> est trop petit pour contenir le hachage calculé, <see langword="true" /> dans le cas contraire.</returns>
    </member>
    <member name="T:System.Security.Cryptography.SHA384Managed">
      <summary>Calcule le hachage <see cref="T:System.Security.Cryptography.SHA384" /> pour les données d'entrée à l'aide de la bibliothèque managée.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA384Managed.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.SHA384Managed" />.</summary>
      <exception cref="T:System.InvalidOperationException">Le paramètre de sécurité FIPS (Federal Information Processing Standards) est activé. Cette implémentation ne fait pas partie des algorithmes de chiffrement validés FIPS pour les plateformes Windows.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SHA384Managed.Initialize">
      <summary>Initialise une instance de <see cref="T:System.Security.Cryptography.SHA384Managed" />.</summary>
    </member>
    <member name="T:System.Security.Cryptography.SHA512">
      <summary>Calcule le hachage <see cref="T:System.Security.Cryptography.SHA512" /> pour les données d'entrée.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA512.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Security.Cryptography.SHA512" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA512.Create">
      <summary>Crée une instance de l'implémentation par défaut de <see cref="T:System.Security.Cryptography.SHA512" />.</summary>
      <exception cref="T:System.Reflection.TargetInvocationException">L’algorithme a été utilisé en mode FIPS (Federal Information Processing Standards), mais il n’est pas compatible avec la norme FIPS.</exception>
      <returns>Nouvelle instance de <see cref="T:System.Security.Cryptography.SHA512" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA512.Create(System.String)">
      <summary>Crée une instance de l'implémentation spécifiée de <see cref="T:System.Security.Cryptography.SHA512" />.</summary>
      <param name="hashName">Nom de l'implémentation spécifique de <see cref="T:System.Security.Cryptography.SHA512" /> à utiliser.</param>
      <exception cref="T:System.Reflection.TargetInvocationException">L'algorithme décrit par le paramètre <paramref name="hashName" /> a été utilisé avec mode FIPS activé, mais n'est pas compatible FIPS.</exception>
      <returns>Nouvelle instance de <see cref="T:System.Security.Cryptography.SHA512" /> à l'aide de l'implémentation spécifiée.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA512.HashData(System.Byte[])">
      <summary>Calcule le hachage des données à l’aide de l’algorithme SHA512.</summary>
      <param name="source">Données à hacher.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> est <see langword="null" />.</exception>
      <returns>Hachage des données.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA512.HashData(System.ReadOnlySpan{System.Byte})">
      <summary>Calcule le hachage des données à l’aide de l’algorithme SHA512.</summary>
      <param name="source">Données à hacher.</param>
      <returns>Hachage des données.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA512.HashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
      <summary>Calcule le hachage des données à l’aide de l’algorithme SHA512.</summary>
      <param name="source">Données à hacher.</param>
      <param name="destination">Mémoire tampon utilisée pour recevoir la valeur de hachage.</param>
      <exception cref="T:System.ArgumentException">La mémoire tampon de <paramref name="destination" /> est trop petite pour contenir la taille de hachage calculée. L’algorithme SHA1 produit toujours un hachage 512 bits, soit 64 octets.</exception>
      <returns>Nombre total d’octets écrits dans <paramref name="destination" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA512.TryHashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@)">
      <summary>Tente de calculer le hachage des données à l’aide de l’algorithme SHA512.</summary>
      <param name="source">Données à hacher.</param>
      <param name="destination">Mémoire tampon utilisée pour recevoir la valeur de hachage.</param>
      <param name="bytesWritten">Quand cette méthode est retournée, nombre total d’octets écrits dans <paramref name="destination" />.</param>
      <returns>
        <see langword="false" /> si <paramref name="destination" /> est trop petit pour contenir le hachage calculé, <see langword="true" /> dans le cas contraire.</returns>
    </member>
    <member name="T:System.Security.Cryptography.SHA512Managed">
      <summary>Calcule l'algorithme de hachage <see cref="T:System.Security.Cryptography.SHA512" /> pour les données d'entrée à l'aide de la bibliothèque managée.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA512Managed.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.SHA512Managed" />.</summary>
      <exception cref="T:System.InvalidOperationException">Le paramètre de sécurité FIPS (Federal Information Processing Standards) est activé. Cette implémentation ne fait pas partie des algorithmes de chiffrement validés FIPS pour les plateformes Windows.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SHA512Managed.Initialize">
      <summary>Initialise une instance de la classe <see cref="T:System.Security.Cryptography.SHA512Managed" /> à l'aide de la bibliothèque managée.</summary>
    </member>
    <member name="T:System.Security.Cryptography.SignatureDescription">
      <summary>Contient des informations relatives aux propriétés d'une signature numérique.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SignatureDescription.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.SignatureDescription" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SignatureDescription.#ctor(System.Security.SecurityElement)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.SignatureDescription" /> à partir du <see cref="T:System.Security.SecurityElement" /> spécifié.</summary>
      <param name="el">
        <see cref="T:System.Security.SecurityElement" /> à partir duquel obtenir les algorithmes pour la description de signature.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="el" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SignatureDescription.CreateDeformatter(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Crée une instance de <see cref="T:System.Security.Cryptography.AsymmetricSignatureDeformatter" /> avec la clé spécifiée en utilisant la propriété <see cref="P:System.Security.Cryptography.SignatureDescription.DeformatterAlgorithm" />.</summary>
      <param name="key">Clé à utiliser dans <see cref="T:System.Security.Cryptography.AsymmetricSignatureDeformatter" />.</param>
      <returns>Instance nouvellement créée de <see cref="T:System.Security.Cryptography.AsymmetricSignatureDeformatter" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SignatureDescription.CreateDigest">
      <summary>Crée une instance de <see cref="T:System.Security.Cryptography.HashAlgorithm" /> en utilisant la propriété <see cref="P:System.Security.Cryptography.SignatureDescription.DigestAlgorithm" />.</summary>
      <returns>Instance nouvellement créée de <see cref="T:System.Security.Cryptography.HashAlgorithm" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SignatureDescription.CreateFormatter(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Crée une instance de <see cref="T:System.Security.Cryptography.AsymmetricSignatureFormatter" /> avec la clé spécifiée en utilisant la propriété <see cref="P:System.Security.Cryptography.SignatureDescription.FormatterAlgorithm" />.</summary>
      <param name="key">Clé à utiliser dans <see cref="T:System.Security.Cryptography.AsymmetricSignatureFormatter" />.</param>
      <returns>Instance nouvellement créée de <see cref="T:System.Security.Cryptography.AsymmetricSignatureFormatter" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.SignatureDescription.DeformatterAlgorithm">
      <summary>Obtient ou définit l'algorithme du déformateur pour la description de signature.</summary>
      <returns>Algorithme du déformateur pour la description de signature.</returns>
    </member>
    <member name="P:System.Security.Cryptography.SignatureDescription.DigestAlgorithm">
      <summary>Obtient ou définit l'algorithme Digest pour la description de signature.</summary>
      <returns>Algorithme Digest pour la description de signature.</returns>
    </member>
    <member name="P:System.Security.Cryptography.SignatureDescription.FormatterAlgorithm">
      <summary>Obtient ou définit l'algorithme du formateur pour la description de signature.</summary>
      <returns>Algorithme du formateur pour la description de signature.</returns>
    </member>
    <member name="P:System.Security.Cryptography.SignatureDescription.KeyAlgorithm">
      <summary>Obtient ou définit l'algorithme à clé pour la description de signature.</summary>
      <returns>Algorithme à clé pour la description de signature.</returns>
    </member>
    <member name="T:System.Security.Cryptography.TripleDES">
      <summary>Représente la classe de base des algorithmes 3DES (Triple Data Encryption Standard) dont toutes les implémentations de <see cref="T:System.Security.Cryptography.TripleDES" /> doivent dériver.</summary>
    </member>
    <member name="M:System.Security.Cryptography.TripleDES.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.TripleDES" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.TripleDES.Create">
      <summary>Crée une instance d’un objet de chiffrement pour exécuter l’algorithme <see cref="T:System.Security.Cryptography.TripleDES" />.</summary>
      <returns>Instance d’un objet de chiffrement.</returns>
    </member>
    <member name="M:System.Security.Cryptography.TripleDES.Create(System.String)">
      <summary>Crée une instance d'un objet de chiffrement pour exécuter l'implémentation spécifiée de l'algorithme <see cref="T:System.Security.Cryptography.TripleDES" />.</summary>
      <param name="str">Nom de l'implémentation spécifique de <see cref="T:System.Security.Cryptography.TripleDES" /> à utiliser.</param>
      <returns>Instance d’un objet de chiffrement.</returns>
    </member>
    <member name="M:System.Security.Cryptography.TripleDES.IsWeakKey(System.Byte[])">
      <summary>Détermine si la clé spécifiée est faible.</summary>
      <param name="rgbKey">Clé secrète dont la faiblesse doit être testée.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La taille du paramètre <paramref name="rgbKey" /> n’est pas valide.</exception>
      <returns>
        <see langword="true" /> si la clé est faible ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.TripleDES.Key">
      <summary>Obtient ou définit la clé secrète pour l’algorithme <see cref="T:System.Security.Cryptography.TripleDES" />.</summary>
      <exception cref="T:System.ArgumentNullException">Une tentative d’affectation de la valeur <see langword="null" /> à la clé a été effectuée.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Une tentative a été effectuée pour définir une clé dont la longueur n’est pas valide.  
  
- ou - 
Une tentative de définition d’une clé faible (voir <see cref="M:System.Security.Cryptography.TripleDES.IsWeakKey(System.Byte[])" /> a été effectuée.</exception>
      <returns>Clé secrète pour l’algorithme <see cref="T:System.Security.Cryptography.TripleDES" />.</returns>
    </member>
  </members>
</doc>