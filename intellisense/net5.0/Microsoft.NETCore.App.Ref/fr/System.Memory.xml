<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Memory</name>
  </assembly>
  <members>
    <member name="T:System.Buffers.ArrayBufferWriter`1">
      <summary>Représente un récepteur de sortie avec tableau et basé sur le tas, dans lequel <typeparam name="T" /> des données peuvent être écrites.</summary>
      <typeparam name="T">Type des éléments de cette <see cref="T:System.Buffers.ArrayBufferWriter`1" /> instance.</typeparam>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.#ctor">
      <summary>Crée une instance d’un <see cref="T:System.Buffers.ArrayBufferWriter`1" /> dans lequel des données peuvent être écrites, avec la capacité initiale par défaut.</summary>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.#ctor(System.Int32)">
      <summary>Crée une instance d’un <see cref="T:System.Buffers.ArrayBufferWriter`1" /> dans lequel des données peuvent être écrites, avec une capacité initiale spécifiée.</summary>
      <param name="initialCapacity">La capacité minimale avec laquelle initialiser la mémoire tampon sous-jacente.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="initialCapacity" /> est inférieur ou égal à 0.</exception>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.Advance(System.Int32)">
      <summary>Indique au <see cref="T:System.Buffers.IBufferWriter`1" /> que des éléments <paramref name="count" /> ont été écrits dans la <see cref="T:System.Span`1" />/<see cref="T:System.Memory`1" /> de sortie.</summary>
      <param name="count">Nombre d’éléments écrits.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="count" /> est un nombre négatif.</exception>
      <exception cref="T:System.InvalidOperationException">L’appel de méthode tente d’avancer jusqu’après la fin de la mémoire tampon sous-jacente.</exception>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.Clear">
      <summary>Efface les données écrites dans la mémoire tampon sous-jacente.</summary>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.GetMemory(System.Int32)">
      <summary>Retourne une <see cref="T:System.Memory`1" /> où écrire, qui a au moins la longueur spécifiée par <paramref name="sizeHint" />.</summary>
      <param name="sizeHint">Longueur minimale demandée de la <see cref="T:System.Memory`1" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="sizeHint" /> est un nombre négatif.</exception>
      <returns>
        <see cref="T:System.Memory`1" /> dont la longueur est d’au moins <paramref name="sizeHint" />.  Si <paramref name="sizeHint" /> n’est pas fourni ou est égal à 0, une mémoire tampon non vide est retournée.</returns>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.GetSpan(System.Int32)">
      <summary>Retourne une <see cref="T:System.Span`1" /> où écrire, qui a au moins une longueur spécifiée.</summary>
      <param name="sizeHint">Longueur minimale demandée de la <see cref="T:System.Span`1" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="sizeHint" /> est un nombre négatif.</exception>
      <returns>Une plage dont la longueur est d’au moins <paramref name="sizeHint" />. Si <paramref name="sizeHint" /> n’est pas fourni ou est égal à 0, une mémoire tampon non vide est retournée.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.Capacity">
      <summary>Obtient la quantité totale d’espace dans la mémoire tampon sous-jacente.</summary>
      <returns>Capacité totale de la mémoire tampon sous-jacente.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.FreeCapacity">
      <summary>Obtient la quantité d’espace disponible où il est possible d’écrire sans forcer l’accroissement de la mémoire tampon sous-jacente.</summary>
      <returns>Espace disponible pour l’écriture sans forcer la croissance de la mémoire tampon sous-jacente.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenCount">
      <summary>Obtient la quantité de données écrites dans la mémoire tampon sous-jacente.</summary>
      <returns>Quantité de données écrites dans la mémoire tampon sous-jacente.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenMemory">
      <summary>Obtient une <see cref="T:System.ReadOnlyMemory`1" /> qui contient les données écrites jusqu’à présent dans la mémoire tampon sous-jacente.</summary>
      <returns>Données écrites dans la mémoire tampon sous-jacente.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenSpan">
      <summary>Obtient une <see cref="T:System.ReadOnlySpan`1" /> qui contient les données écrites jusqu’à présent dans la mémoire tampon sous-jacente.</summary>
      <returns>Données écrites dans la mémoire tampon sous-jacente.</returns>
    </member>
    <member name="T:System.Buffers.Binary.BinaryPrimitives">
      <summary>Lit les octets en tant que primitives avec un endianness spécifique.</summary>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadDoubleBigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lit un <see cref="T:System.Double" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source">Étendue en lecture seule à lire.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.Double" />.</exception>
      <returns>Valeur avec primauté des octets de poids fort (big-endian).</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadDoubleLittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lit un <see cref="T:System.Double" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source">Étendue en lecture seule à lire.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.Double" />.</exception>
      <returns>Valeur en mode Little Endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lit un <see cref="T:System.Int16" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source">Étendue en lecture seule à lire.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.Int16" />.</exception>
      <returns>Valeur avec primauté des octets de poids fort (big-endian).</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lit un <see cref="T:System.Int16" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source">Étendue en lecture seule à lire.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.Int16" />.</exception>
      <returns>Valeur en mode Little Endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lit un <see cref="T:System.Int32" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source">Étendue en lecture seule à lire.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.Int32" />.</exception>
      <returns>Valeur avec primauté des octets de poids fort (big-endian).</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lit un <see cref="T:System.Int32" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source">Étendue en lecture seule à lire.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.Int32" />.</exception>
      <returns>Valeur en mode Little Endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lit un <see cref="T:System.Int64" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source">Étendue en lecture seule à lire.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.Int64" />.</exception>
      <returns>Valeur avec primauté des octets de poids fort (big-endian).</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lit un <see cref="T:System.Int64" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source">Étendue en lecture seule à lire.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.Int64" />.</exception>
      <returns>Valeur en mode Little Endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadSingleBigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lit un <see cref="T:System.Single" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source">Étendue en lecture seule à lire.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.Single" />.</exception>
      <returns>Valeur avec primauté des octets de poids fort (big-endian).</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadSingleLittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lit un <see cref="T:System.Single" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source">Étendue en lecture seule à lire.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.Single" />.</exception>
      <returns>Valeur en mode Little Endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lit un <see cref="T:System.UInt16" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source">Étendue en lecture seule à lire.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.UInt16" />.</exception>
      <returns>Valeur avec primauté des octets de poids fort (big-endian).</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lit un <see cref="T:System.UInt16" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source">Étendue en lecture seule à lire.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.UInt16" />.</exception>
      <returns>Valeur en mode Little Endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lit un <see cref="T:System.UInt32" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source">Étendue en lecture seule à lire.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.UInt32" />.</exception>
      <returns>Valeur avec primauté des octets de poids fort (big-endian).</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lit un <see cref="T:System.UInt32" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source">Étendue en lecture seule d’octets à lire.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.UInt32" />.</exception>
      <returns>Valeur en mode Little Endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lit un <see cref="T:System.UInt64" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source">Étendue en lecture seule d’octets à lire.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.UInt64" />.</exception>
      <returns>Valeur avec primauté des octets de poids fort (big-endian).</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lit un <see cref="T:System.UInt64" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source">Étendue en lecture seule d’octets à lire.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> est trop petit pour contenir un <see cref="T:System.UInt64" />.</exception>
      <returns>Valeur en mode Little Endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Byte)">
      <summary>Inverse une valeur primitive en effectuant une permutation endianness de la valeur <see cref="T:System.Byte" /> spécifiée, ce qui n’a aucun effet pour un <see cref="T:System.Byte" />.</summary>
      <param name="value">Valeur à inverser.</param>
      <returns>Valeur passée, non modifiée.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int16)">
      <summary>Inverse une valeur primitive en effectuant une permutation endianness de la valeur <see cref="T:System.Int16" /> spécifiée.</summary>
      <param name="value">Valeur à inverser.</param>
      <returns>Valeur inversée.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int32)">
      <summary>Inverse une valeur primitive en effectuant une permutation endianness de la valeur <see cref="T:System.Int32" /> spécifiée.</summary>
      <param name="value">Valeur à inverser.</param>
      <returns>Valeur inversée.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int64)">
      <summary>Inverse une valeur primitive en effectuant une permutation endianness de la valeur <see cref="T:System.Int64" /> spécifiée.</summary>
      <param name="value">Valeur à inverser.</param>
      <returns>Valeur inversée.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.SByte)">
      <summary>Inverse une valeur primitive en effectuant une permutation endianness de la valeur <see cref="T:System.SByte" /> spécifiée, ce qui n’a aucun effet pour un <see cref="T:System.SByte" />.</summary>
      <param name="value">Valeur à inverser.</param>
      <returns>Valeur passée, non modifiée.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt16)">
      <summary>Inverse une valeur primitive en effectuant une permutation endianness de la valeur <see cref="T:System.UInt16" /> spécifiée.</summary>
      <param name="value">Valeur à inverser.</param>
      <returns>Valeur inversée.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt32)">
      <summary>Inverse une valeur primitive en effectuant une permutation endianness de la valeur <see cref="T:System.UInt32" /> spécifiée.</summary>
      <param name="value">Valeur à inverser.</param>
      <returns>Valeur inversée.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt64)">
      <summary>Inverse une valeur primitive en effectuant une permutation endianness de la valeur <see cref="T:System.UInt64" /> spécifiée.</summary>
      <param name="value">Valeur à inverser.</param>
      <returns>Valeur inversée.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadDoubleBigEndian(System.ReadOnlySpan{System.Byte},System.Double@)">
      <summary>Lit un <see cref="T:System.Double" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source">Étendue en lecture seule d’octets à lire.</param>
      <param name="value">Lorsque cette méthode est retournée, contient la valeur lue à partir de l’étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Double" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadDoubleLittleEndian(System.ReadOnlySpan{System.Byte},System.Double@)">
      <summary>Lit un <see cref="T:System.Double" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source">Étendue en lecture seule d’octets à lire.</param>
      <param name="value">Lorsque cette méthode est retournée, contient la valeur lue à partir de l’étendue en lecture seule d’octets, avec primauté des octets de poids faible (little-endian).</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Double" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16BigEndian(System.ReadOnlySpan{System.Byte},System.Int16@)">
      <summary>Lit un <see cref="T:System.Int16" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source">Étendue en lecture seule d’octets à lire.</param>
      <param name="value">Lorsque cette méthode est retournée, valeur lue à partir de l’étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Int16" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.Int16@)">
      <summary>Lit un <see cref="T:System.Int16" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source">Étendue en lecture seule d’octets à lire.</param>
      <param name="value">Lorsque cette méthode est retournée, valeur lue à partir de l’étendue en lecture seule d’octets, en mode Little Endian.</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Int16" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32BigEndian(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Lit un <see cref="T:System.Int32" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source">Étendue en lecture seule d’octets à lire.</param>
      <param name="value">Lorsque cette méthode est retournée, valeur lue à partir de l’étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Int32" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Lit un <see cref="T:System.Int32" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source">Étendue en lecture seule d’octets à lire.</param>
      <param name="value">Lorsque cette méthode est retournée, valeur lue à partir de l’étendue en lecture seule d’octets, en mode Little Endian.</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Int32" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64BigEndian(System.ReadOnlySpan{System.Byte},System.Int64@)">
      <summary>Lit un <see cref="T:System.Int64" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source">Étendue en lecture seule d’octets à lire.</param>
      <param name="value">Lorsque cette méthode est retournée, valeur lue à partir de l’étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Int64" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.Int64@)">
      <summary>Lit un <see cref="T:System.Int64" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source">Étendue en lecture seule d’octets à lire.</param>
      <param name="value">Lorsque cette méthode est retournée, valeur lue à partir de l’étendue en lecture seule d’octets, en mode Little Endian.</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Int64" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadSingleBigEndian(System.ReadOnlySpan{System.Byte},System.Single@)">
      <summary>Lit un <see cref="T:System.Single" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source">Étendue en lecture seule d’octets à lire.</param>
      <param name="value">Lorsque cette méthode est retournée, contient la valeur lue à partir de l’étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Single" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadSingleLittleEndian(System.ReadOnlySpan{System.Byte},System.Single@)">
      <summary>Lit un <see cref="T:System.Single" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source">Étendue en lecture seule d’octets à lire.</param>
      <param name="value">Lorsque cette méthode est retournée, contient la valeur lue à partir de l’étendue en lecture seule d’octets, avec primauté des octets de poids faible (little-endian).</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Single" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16BigEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)">
      <summary>Lit un <see cref="T:System.UInt16" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source">Étendue en lecture seule d’octets à lire.</param>
      <param name="value">Lorsque cette méthode est retournée, valeur lue à partir de l’étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.UInt16" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)">
      <summary>Lit un <see cref="T:System.UInt16" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source">Étendue en lecture seule d’octets à lire.</param>
      <param name="value">Lorsque cette méthode est retournée, valeur lue à partir de l’étendue en lecture seule d’octets, en mode Little Endian.</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.UInt16" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32BigEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)">
      <summary>Lit un <see cref="T:System.UInt32" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source">Étendue en lecture seule d’octets à lire.</param>
      <param name="value">Lorsque cette méthode est retournée, valeur lue à partir de l’étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.UInt32" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)">
      <summary>Lit un <see cref="T:System.UInt32" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source">Étendue en lecture seule d’octets à lire.</param>
      <param name="value">Lorsque cette méthode est retournée, valeur lue à partir de l’étendue en lecture seule d’octets, en mode Little Endian.</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.UInt32" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64BigEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)">
      <summary>Lit un <see cref="T:System.UInt64" /> à partir du début d’une étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="source">Étendue en lecture seule d’octets à lire.</param>
      <param name="value">Lorsque cette méthode est retournée, valeur lue à partir de l’étendue en lecture seule d’octets, avec primauté des octets de poids fort (big-endian).</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.UInt64" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)">
      <summary>Lit un <see cref="T:System.UInt64" /> à partir du début d’une étendue en lecture seule d’octets, en mode Little Endian.</summary>
      <param name="source">Étendue en lecture seule d’octets à lire.</param>
      <param name="value">Lorsque cette méthode est retournée, valeur lue à partir de l’étendue en lecture seule d’octets, en mode Little Endian.</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.UInt64" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleBigEndian(System.Span{System.Byte},System.Double)">
      <summary>Écrit un <see cref="T:System.Double" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Double" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleLittleEndian(System.Span{System.Byte},System.Double)">
      <summary>Écrit un <see cref="T:System.Double" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Double" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16BigEndian(System.Span{System.Byte},System.Int16)">
      <summary>Écrit un <see cref="T:System.Int16" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Int16" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16LittleEndian(System.Span{System.Byte},System.Int16)">
      <summary>Écrit un <see cref="T:System.Int16" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Int16" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32BigEndian(System.Span{System.Byte},System.Int32)">
      <summary>Écrit un <see cref="T:System.Int32" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Int32" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32LittleEndian(System.Span{System.Byte},System.Int32)">
      <summary>Écrit un <see cref="T:System.Int32" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Int32" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64BigEndian(System.Span{System.Byte},System.Int64)">
      <summary>Écrit un <see cref="T:System.Int64" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Int64" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64LittleEndian(System.Span{System.Byte},System.Int64)">
      <summary>Écrit un <see cref="T:System.Int64" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Int64" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteSingleBigEndian(System.Span{System.Byte},System.Single)">
      <summary>Écrit un <see cref="T:System.Single" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Single" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteSingleLittleEndian(System.Span{System.Byte},System.Single)">
      <summary>Écrit un <see cref="T:System.Single" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.Single" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)">
      <summary>Écrit un <see cref="T:System.UInt16" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.UInt16" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)">
      <summary>Écrit un <see cref="T:System.UInt16" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.UInt16" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)">
      <summary>Écrit un <see cref="T:System.UInt32" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.UInt32" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)">
      <summary>Écrit un <see cref="T:System.UInt32" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.UInt32" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)">
      <summary>Écrit un <see cref="T:System.UInt64" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.UInt64" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)">
      <summary>Écrit un <see cref="T:System.UInt64" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <returns>
        <see langword="true" /> si l’étendue est suffisamment grande pour contenir un <see cref="T:System.UInt64" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteDoubleBigEndian(System.Span{System.Byte},System.Double)">
      <summary>Écrit un <see cref="T:System.Double" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteDoubleLittleEndian(System.Span{System.Byte},System.Double)">
      <summary>Écrit un <see cref="T:System.Double" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16BigEndian(System.Span{System.Byte},System.Int16)">
      <summary>Écrit un <see cref="T:System.Int16" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.Int16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16LittleEndian(System.Span{System.Byte},System.Int16)">
      <summary>Écrit un <see cref="T:System.Int16" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.Int16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32BigEndian(System.Span{System.Byte},System.Int32)">
      <summary>Écrit un <see cref="T:System.Int32" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32LittleEndian(System.Span{System.Byte},System.Int32)">
      <summary>Écrit un <see cref="T:System.Int32" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64BigEndian(System.Span{System.Byte},System.Int64)">
      <summary>Écrit un <see cref="T:System.Int64" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.Int64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64LittleEndian(System.Span{System.Byte},System.Int64)">
      <summary>Écrit un <see cref="T:System.Int64" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.Int64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteSingleBigEndian(System.Span{System.Byte},System.Single)">
      <summary>Écrit un <see cref="T:System.Single" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.Single" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteSingleLittleEndian(System.Span{System.Byte},System.Single)">
      <summary>Écrit un <see cref="T:System.Single" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.Single" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)">
      <summary>Écrit un <see cref="T:System.UInt16" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.UInt16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)">
      <summary>Écrit un <see cref="T:System.UInt16" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.UInt16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)">
      <summary>Écrit un <see cref="T:System.UInt32" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.UInt32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)">
      <summary>Écrit un <see cref="T:System.UInt32" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.UInt32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)">
      <summary>Écrit un <see cref="T:System.UInt64" /> dans une étendue d’octets, avec primauté des octets de poids fort (big-endian).</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, avec primauté des octets de poids fort (big-endian).</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.UInt64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)">
      <summary>Écrit un <see cref="T:System.UInt64" /> dans une étendue d’octets, en mode Little Endian.</summary>
      <param name="destination">Étendue d’octets dans laquelle la valeur doit être écrite, en mode Little Endian.</param>
      <param name="value">Valeur à écrire dans l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> est trop petit pour contenir un <see cref="T:System.UInt64" />.</exception>
    </member>
    <member name="T:System.Buffers.BuffersExtensions">
      <summary>Fournit des méthodes d'extension pour <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.CopyTo``1(System.Buffers.ReadOnlySequence{``0},System.Span{``0})">
      <summary>Copie le <see cref="T:System.Buffers.ReadOnlySequence`1" /> dans le <see cref="T:System.Span`1" /> spécifié.</summary>
      <param name="source">
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> source.</param>
      <param name="destination">
        <see cref="T:System.Span`1" /> de destination.</param>
      <typeparam name="T">Type des éléments de <see cref="T:System.Buffers.ReadOnlySequence`1" /> .</typeparam>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.PositionOf``1(System.Buffers.ReadOnlySequence{``0},``0)">
      <summary>Retourne la position de la première occurrence de <paramref name="item" /> dans <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <param name="source">
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> source.</param>
      <param name="value">L’élément à rechercher dans <see cref="T:System.Buffers.ReadOnlySequence`1" />.</param>
      <typeparam name="T">Type des éléments de <see cref="T:System.Buffers.ReadOnlySequence`1" /> .</typeparam>
      <returns>Un objet dont la méthode <see cref="M:System.SequencePosition.GetInteger" /> retourne la position de la première occurrence de <paramref name="item" />, ou un objet dont la propriété <see langword="Nullable&lt;SequencePosition&gt;.HasValue" /> est <see langword="false" /> .</returns>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.ToArray``1(System.Buffers.ReadOnlySequence{``0})">
      <summary>Convertit <see cref="T:System.Buffers.ReadOnlySequence`1" /> en tableau.</summary>
      <param name="sequence">La séquence en lecture seule à convertir en tableau.</param>
      <typeparam name="T">Type des éléments de <see cref="T:System.Buffers.ReadOnlySequence`1" /> .</typeparam>
      <returns>Tableau contenant les données dans la séquence en lecture seule actuelle.</returns>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.Write``1(System.Buffers.IBufferWriter{``0},System.ReadOnlySpan{``0})">
      <summary>Écrit le contenu de <paramref name="value" /> dans <paramref name="writer" />.</summary>
      <param name="writer">L’enregistreur de la mémoire tampon dans lequel écrire <paramref name="value" />.</param>
      <param name="value">L’étendue en lecture seule à écrire dans <paramref name="writer" />.</param>
      <typeparam name="T">Type des éléments de <see cref="T:System.ReadOnlySpan`1" /> .</typeparam>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="writer" /> est plus court que <paramref name="value" />.</exception>
    </member>
    <member name="T:System.Buffers.IBufferWriter`1">
      <summary>Représente un récepteur de sortie dans lequel des données <typeparamref name="T" /> peuvent être écrites.</summary>
      <typeparam name="T">Type des éléments de <see cref="T:System.Buffers.IBufferWriter`1" /> .</typeparam>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.Advance(System.Int32)">
      <summary>Indique à <see cref="T:System.Buffers.IBufferWriter`1" /> que des éléments de données <paramref name="count" /> ont été écrits dans les sorties <see cref="T:System.Span`1" /> ou <see cref="T:System.Memory`1" />.</summary>
      <param name="count">Nombre d'éléments de données écrits dans <see cref="T:System.Span`1" /> ou <see cref="T:System.Memory`1" />.</param>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.GetMemory(System.Int32)">
      <summary>Renvoie un élément <see cref="T:System.Memory`1" /> à écrire d’au moins la taille requise (spécifiée par <paramref name="sizeHint" />).</summary>
      <param name="sizeHint">La longueur minimale de l’élément <see cref="T:System.Memory`1" /> retourné. Si 0, une mémoire tampon est renvoyé.</param>
      <exception cref="T:System.OutOfMemoryException">La mémoire tampon demandée n'est pas disponible.</exception>
      <returns>Un élément <see cref="T:System.Memory`1" /> d’au moins <paramref name="sizeHint" />. Si <paramref name="sizeHint" /> est 0, renvoie une mémoire tampon non vide.</returns>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)">
      <summary>Renvoie un élément <see cref="T:System.Span`1" /> à écrire d’au moins la taille requise (spécifiée par <paramref name="sizeHint" />).</summary>
      <param name="sizeHint">La longueur minimale de l’élément <see cref="T:System.Span`1" /> retourné. Si 0, une mémoire tampon est renvoyé.</param>
      <returns>Un élément <see cref="T:System.Span`1" /> d’au moins <paramref name="sizeHint" />. Si <paramref name="sizeHint" /> est 0, renvoie une mémoire tampon non vide.</returns>
    </member>
    <member name="T:System.Buffers.MemoryPool`1">
      <summary>Représente un pool de blocs de mémoire.</summary>
      <typeparam name="T">Type des éléments dans le pool de mémoire.</typeparam>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.#ctor">
      <summary>Construit une nouvelle instance de pool de mémoire.</summary>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Dispose">
      <summary>Libère toutes les ressources utilisées par le pool de mémoire.</summary>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Dispose(System.Boolean)">
      <summary>Libère les ressources non managées utilisées par le pool de mémoire, et de façon facultative les ressources managées.</summary>
      <param name="disposing">
        <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Rent(System.Int32)">
      <summary>Retourne un bloc de mémoire capable de contenir au moins <paramref name="minBufferSize" /> éléments de T.</summary>
      <param name="minBufferSize">Le nombre minimal d’éléments de <typeparamref name="T" /> que peut contenir le pool de mémoire. La valeur -1 retourne un pool de mémoire défini sur la taille par défaut du pool.</param>
      <returns>Un bloc de mémoire capable de contenir au moins <paramref name="minBufferSize" /> éléments de T.</returns>
    </member>
    <member name="P:System.Buffers.MemoryPool`1.MaxBufferSize">
      <summary>Récupère la taille maximale de la mémoire tampon prise en charge par ce pool.</summary>
      <returns>Taille maximale de la mémoire tampon prise en charge par ce pool.</returns>
    </member>
    <member name="P:System.Buffers.MemoryPool`1.Shared">
      <summary>Récupère une instance singleton d’un pool de mémoire basé sur des tableaux.</summary>
      <returns>Instance singleton d’un pool de mémoire.</returns>
    </member>
    <member name="T:System.Buffers.ReadOnlySequence`1">
      <summary>Représente une séquence capable de lire une série séquentielle de <typeparamref name="T" />.</summary>
      <typeparam name="T">Type des éléments de la séquence en lecture seule.</typeparam>
    </member>
    <member name="F:System.Buffers.ReadOnlySequence`1.Empty">
      <summary>Retourne un <see cref="T:System.Buffers.ReadOnlySequence`1" /> vide.</summary>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[])">
      <summary>Crée une instance de <see cref="T:System.Buffers.ReadOnlySequence`1" /> à partir de <paramref name="array" />.</summary>
      <param name="array">Le tableau à partir duquel créer une séquence en lecture seule.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[],System.Int32,System.Int32)">
      <summary>Crée une instance d’un <see cref="T:System.Buffers.ReadOnlySequence`1" /> à partir d’une section d’un tableau.</summary>
      <param name="array">Le tableau à partir duquel créer la séquence en lecture seule.</param>
      <param name="start">L’index basé sur zéro du premier élément du tableau à inclure dans la séquence en lecture seule.</param>
      <param name="length">Le nombre d’éléments à inclure dans la séquence en lecture seule.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.Buffers.ReadOnlySequenceSegment{`0},System.Int32,System.Buffers.ReadOnlySequenceSegment{`0},System.Int32)">
      <summary>Crée une instance d’un <see cref="T:System.Buffers.ReadOnlySequence`1" /> à partir d’une liste de mémoire liée représentée par les segments de début et de fin et les index correspondants.</summary>
      <param name="startSegment">Nœud initial de la liste de mémoires liée.</param>
      <param name="startIndex">Position au début de la séquence dans <paramref name="startSegment" />.</param>
      <param name="endSegment">Nœud final de la liste de mémoires liée.</param>
      <param name="endIndex">Position à la fin de la séquence dans <paramref name="endSegment" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="startSegment" /> ou <paramref name="endSegment" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">L’index exécuté de <paramref name="startSegment" /> est supérieur à l’index exécuté de <paramref name="endSegment" />, même si <paramref name="startSegment" /> est différent de <paramref name="endSegment" />.

- ou -

<paramref name="startSegment" /> est égal à <paramref name="endSegment" />, mais <paramref name="endIndex" /> est plus petit que <paramref name="startIndex" />.

- ou -

<paramref name="startIndex" /> est supérieur à la longueur du bloc de mémoire sous-jacent de <paramref name="startSegment" />.</exception>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.ReadOnlyMemory{`0})">
      <summary>Crée une instance de <see cref="T:System.Buffers.ReadOnlySequence`1" /> à partir de <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <param name="memory">Bloc de mémoire en lecture seule d’éléments de type <typeparamref name="T" />.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetEnumerator">
      <summary>Retourne un énumérateur sur <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <returns>Retourne un énumérateur sur <see cref="T:System.Buffers.ReadOnlySequence`1" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetOffset(System.SequencePosition)">
      <summary>Retourne le décalage d’un élément <paramref name="position" /> dans cette séquence à partir du début.</summary>
      <param name="position">Élément <see cref="T:System.SequencePosition" /> qui fournit le décalage.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">La position est hors limites.</exception>
      <returns>Décalage à partir du début de la séquence.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64)">
      <summary>Retourne un nouvel <see cref="T:System.SequencePosition" /> à un <paramref name="offset" /> à partir du début de la séquence.</summary>
      <param name="offset">Décalage à partir du début de la séquence.</param>
      <returns>Objet représentant la position de la séquence qui commence au <paramref name="offset" /> spécifié à partir du début de la séquence.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64,System.SequencePosition)">
      <summary>Retourne une nouvelle <see cref="T:System.SequencePosition" /> commençant au décalage spécifié à partir de la position de <paramref name="origin" />.</summary>
      <param name="offset">Décalage à partir de la position de séquence de <paramref name="origin" /> spécifiée.</param>
      <param name="origin">Position de séquence représentant le point à partir duquel initier le décalage.</param>
      <returns>Objet représentant la position de la séquence qui commence à la position <paramref name="offset" /> de l’objet de position <paramref name="origin" /> spécifié.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.Int32)">
      <summary>Constitue une section du <see cref="T:System.Buffers.ReadOnlySequence`1" /> actuel, qui commence à l’index <paramref name="start" /> et contient <paramref name="length" /> éléments.</summary>
      <param name="start">Index auquel commence cette section.</param>
      <param name="length">La longueur de la section.</param>
      <returns>Une section constituée de <paramref name="length" /> éléments à partir de l’instance actuelle commençant à l’index <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.SequencePosition)">
      <summary>Constitue une section du <see cref="T:System.Buffers.ReadOnlySequence`1" /> actuel, qui commence à l’index <paramref name="start" /> et se termine à la position <paramref name="end" /> (exclue).</summary>
      <param name="start">Index auquel commence cette section.</param>
      <param name="end">Position <see cref="T:System.SequencePosition" /> de fin (exclue) de la section.</param>
      <returns>Section constituée des éléments entre l’index <paramref name="start" /> et la position de séquence <paramref name="end" /> (exclue) dans la séquence en lecture seule actuelle.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64)">
      <summary>Constitue une section du <see cref="T:System.Buffers.ReadOnlySequence`1" /> actuel, entre l’index spécifié et la fin de la séquence en lecture seule.</summary>
      <param name="start">Index de début auquel commence cette section.</param>
      <returns>Section entre l’index <paramref name="start" /> et la fin de la séquence en lecture seule actuelle.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.Int64)">
      <summary>Constitue une section de <see cref="T:System.Buffers.ReadOnlySequence`1" /> donné, en commençant par <paramref name="start" />, avec <paramref name="length" /> éléments.</summary>
      <param name="start">Index auquel commence cette section.</param>
      <param name="length">La longueur de la section.</param>
      <returns>Une section constituée de <paramref name="length" /> éléments à partir de l’instance actuelle commençant à l’index <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.SequencePosition)">
      <summary>Constitue une section du <see cref="T:System.Buffers.ReadOnlySequence`1" /> actuel, qui commence à l’index <paramref name="start" /> et se termine à la position <paramref name="end" /> (exclue).</summary>
      <param name="start">Index auquel commence cette section.</param>
      <param name="end">Position de fin (exclue) de la section.</param>
      <returns>Section constituée des éléments entre l’index <paramref name="start" /> et la position de séquence <paramref name="end" /> (exclue) dans la séquence en lecture seule actuelle.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition)">
      <summary>Constitue une section du <see cref="T:System.Buffers.ReadOnlySequence`1" /> actuel, entre la position de séquence spécifiée et la fin de la séquence en lecture seule.</summary>
      <param name="start">Le <see cref="T:System.SequencePosition" /> de début (inclus) où démarrer cette section.</param>
      <returns>Section entre la position de séquence <paramref name="start" /> et la fin de la séquence en lecture seule actuelle.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int32)">
      <summary>Constitue une section du <see cref="T:System.Buffers.ReadOnlySequence`1" /> actuel, qui commence à l’index <paramref name="start" /> et contient <paramref name="length" /> éléments.</summary>
      <param name="start">Le <see cref="T:System.SequencePosition" /> de début (inclus) où démarrer cette section.</param>
      <param name="length">La longueur de la section.</param>
      <returns>Section constituée de <paramref name="length" /> éléments de l’instance actuelle commençant à la position de séquence <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int64)">
      <summary>Constitue une section du <see cref="T:System.Buffers.ReadOnlySequence`1" /> actuel, qui commence à l’index <paramref name="start" /> et contient <paramref name="length" /> éléments.</summary>
      <param name="start">Le <see cref="T:System.SequencePosition" /> de début (inclus) où démarrer cette section.</param>
      <param name="length">La longueur de la section.</param>
      <returns>Section constituée de <paramref name="length" /> éléments de l’instance actuelle commençant à la position de séquence <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.SequencePosition)">
      <summary>Constitue une section du <see cref="T:System.Buffers.ReadOnlySequence`1" /> actuel, qui commence à l’index <paramref name="start" /> et se termine à la position <paramref name="end" /> (exclue).</summary>
      <param name="start">Le <see cref="T:System.SequencePosition" /> de début (inclus) où démarrer cette section.</param>
      <param name="end">Position <see cref="T:System.SequencePosition" /> de fin (exclue) de la section.</param>
      <returns>Section constituée des éléments entre la position de séquence <paramref name="start" /> et la position de séquence <paramref name="end" /> (exclue) dans la séquence en lecture seule actuelle.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.ToString">
      <summary>Retourne une chaîne qui représente la séquence actuelle.</summary>
      <returns>Chaîne qui représente la séquence actuelle.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.TryGet(System.SequencePosition@,System.ReadOnlyMemory{`0}@,System.Boolean)">
      <summary>Tente de récupérer le segment suivant après <paramref name="position" /> et retourne une valeur qui indique si l’opération a réussi.</summary>
      <param name="position">La position de séquence actuelle.</param>
      <param name="memory">Une étendue de mémoire en lecture seule qui contient le segment suivant après <paramref name="position" />.</param>
      <param name="advance">
        <see langword="true" /> si <paramref name="position" /> doit être au début du segment suivant ; sinon, <see langword="false" />.</param>
      <returns>Retourne <see langword="true" /> si la méthode a retourné le segment suivant, ou <see langword="false" /> si la fin de la séquence en lecture seule a été atteinte.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.End">
      <summary>Obtient la position à la fin de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.First">
      <summary>Obtient <see cref="T:System.ReadOnlyMemory`1" /> à partir du premier segment.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.FirstSpan">
      <summary>Obtient <see cref="T:System.ReadOnlySpan`1" /> à partir du premier segment.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.IsEmpty">
      <summary>Obtient une valeur qui indique si <see cref="T:System.Buffers.ReadOnlySequence`1" /> est vide.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.IsSingleSegment">
      <summary>Obtient une valeur qui indique si <see cref="T:System.Buffers.ReadOnlySequence`1" /> contient un segment <see cref="T:System.ReadOnlyMemory`1" /> unique.</summary>
      <returns>
        <see langword="true" /> Si la séquence en lecture seule est vide ; Sinon, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Length">
      <summary>Obtient la longueur de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <returns>Longueur de la séquence en lecture seule.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Start">
      <summary>Obtient la position au début de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="T:System.Buffers.ReadOnlySequence`1.Enumerator">
      <summary>Représente un énumérateur sur une <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <typeparam name="T" />
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.#ctor(System.Buffers.ReadOnlySequence{`0}@)">
      <summary>Initialise l'énumérateur.</summary>
      <param name="sequence">
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> à énumérer.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.MoveNext">
      <summary>Accède au <see cref="T:System.ReadOnlyMemory`1" /> suivant dans le <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <returns>
        <see langword="true" /> si l’énumérateur a avancé jusqu’à l’élément suivant ; <see langword="false" /> si la fin de la séquence a été atteinte.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Enumerator.Current">
      <summary>Obtient le <see cref="T:System.ReadOnlyMemory`1" /> actuel.</summary>
      <returns>
        <see cref="T:System.ReadOnlyMemory`1" /> actuel.</returns>
    </member>
    <member name="T:System.Buffers.ReadOnlySequenceSegment`1">
      <summary>Représente une liste liée de nœuds <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <typeparam name="T">Type des éléments dans le segment de séquence en lecture seule.</typeparam>
    </member>
    <member name="M:System.Buffers.ReadOnlySequenceSegment`1.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Buffers.ReadOnlySequenceSegment`1" />.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Memory">
      <summary>Récupère ou définit une valeur <see cref="T:System.ReadOnlyMemory`1" /> pour le nœud actuel.</summary>
      <returns>
        <see cref="T:System.ReadOnlyMemory`1" />Valeur pour le nœud actuel.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Next">
      <summary>Récupère ou définit le nœud suivant.</summary>
      <returns>Nœud suivant.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.RunningIndex">
      <summary>Récupère ou définit la somme des longueurs de nœud avant le nœud actuel.</summary>
      <returns>Somme des longueurs de nœuds avant le nœud actuel.</returns>
    </member>
    <member name="T:System.Buffers.SequenceReader`1">
      <summary>Fournit des méthodes de lecture de données binaires et texte à partir d’un <see cref="T:System.Buffers.ReadOnlySequence`1" /> en ciblant les performances et les allocations de tas minimales ou égales à zéro.</summary>
      <typeparam name="T">Type de la séquence en lecture seule.</typeparam>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.#ctor(System.Buffers.ReadOnlySequence{`0})">
      <summary>Crée un <see cref="T:System.Buffers.SequenceReader`1" /> sur une <see cref="T:System.Buffers.ReadOnlySequence`1" /> donnée.</summary>
      <param name="sequence">Séquence en lecture seule sur laquelle créer <see cref="T:System.Buffers.SequenceReader`1" />.</param>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.Advance(System.Int64)">
      <summary>Déplace le lecteur vers l’avant, d’un nombre d’éléments spécifié.</summary>
      <param name="count">Nombre d’éléments à avancer.</param>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePast(`0)">
      <summary>Avance jusqu’après des instances consécutives de <paramref name="value" />.</summary>
      <param name="value">Valeur après laquelle le lecteur doit avancer.</param>
      <returns>Nombre de positions dont le lecteur a avancé.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0)">
      <summary>Avance jusqu’après des instances consécutives de l’une ou l’autre de deux valeurs spécifiées.</summary>
      <param name="value0">Première valeur à ignorer.</param>
      <param name="value1">Deuxième valeur à ignorer.</param>
      <returns>Nombre de positions dont le lecteur a avancé.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0)">
      <summary>Avance jusqu’après des instances consécutives de l’une des trois valeurs spécifiées.</summary>
      <param name="value0">Première valeur à ignorer.</param>
      <param name="value1">Deuxième valeur à ignorer.</param>
      <param name="value2">Troisième valeur à ignorer.</param>
      <returns>Nombre de positions dont le lecteur a avancé.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0,`0)">
      <summary>Avance jusqu’après des instances consécutives de l’une des quatre valeurs spécifiées.</summary>
      <param name="value0">Première valeur à ignorer.</param>
      <param name="value1">Deuxième valeur à ignorer.</param>
      <param name="value2">Troisième valeur à ignorer.</param>
      <param name="value3">Quatrième valeur à ignorer.</param>
      <returns>Nombre de positions dont le lecteur a avancé.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(System.ReadOnlySpan{`0})">
      <summary>Ignore les instances consécutives des <paramref name="values" /> spécifiés.</summary>
      <param name="values">Valeurs à ignorer.</param>
      <returns>Nombre de positions dont le lecteur a avancé.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvanceToEnd">
      <summary>Déplace le lecteur à la fin de la séquence.</summary>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.IsNext(`0,System.Boolean)">
      <summary>Vérifie si une valeur spécifiée suit dans la séquence.</summary>
      <param name="next">Valeur à laquelle comparer les éléments suivants.</param>
      <param name="advancePast">
        <see langword="true" /> pour se déplacer après les valeurs <paramref name="next" /> si elles sont trouvées ; sinon, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> si les valeurs sont les prochaines dans la séquence ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.IsNext(System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Vérifie si les valeurs spécifiées dans une plage en lecture seule suivent dans la séquence.</summary>
      <param name="next">Plage à laquelle comparer les éléments suivants.</param>
      <param name="advancePast">
        <see langword="true" /> pour se déplacer après les valeurs <paramref name="next" /> si elles sont trouvées ; sinon, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> si les valeurs sont les prochaines dans la séquence ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.Rewind(System.Int64)">
      <summary>Déplace le lecteur vers l’arrière, du nombre d’éléments spécifié.</summary>
      <param name="count">Nombre d'éléments.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> est négatif ou supérieur à <see cref="P:System.Buffers.SequenceReader`1.Consumed" />.</exception>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryAdvanceTo(`0,System.Boolean)">
      <summary>Recherche un délimiteur spécifié et avance (facultatif) jusqu’après celui-ci s’il est trouvé.</summary>
      <param name="delimiter">Délimiteur à rechercher.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> pour se déplacer après le <paramref name="delimiter" /> s’il est trouvé ; sinon, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> si le <paramref name="delimiter" /> donné est trouvé ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryAdvanceToAny(System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Recherche un des délimiteurs spécifiés et avance (facultatif) jusqu’après le premier de ces délimiteurs trouvé.</summary>
      <param name="delimiters">Les délimiteurs à rechercher.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> pour se déplacer après la première instance d’un des <paramref name="delimiters" /> donnés ; <see langword="false" /> pour ne pas se déplacer après le délimiteur.</param>
      <returns>
        <see langword="true" /> si un des <paramref name="delimiters" /> donnés a été trouvé ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryCopyTo(System.Span{`0})">
      <summary>Copie des données à partir de la position actuelle vers la plage de destination donnée s’il y a suffisamment de données pour la remplir.</summary>
      <param name="destination">Plage de destination dans laquelle copier.</param>
      <returns>
        <see langword="true" /> s’il y a suffisamment de données pour remplir complètement la plage <paramref name="destination" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryPeek(`0@)">
      <summary>Donne un aperçu de la valeur suivante sans avancer le lecteur.</summary>
      <param name="value">La valeur suivante, ou la valeur par défaut si la position correspond à la fin du lecteur.</param>
      <returns>
        <see langword="true" /> si le lecteur n’est pas à la fin et que l’opération d’aperçu a réussi ; <see langword="false" /> si la position correspond à la fin du lecteur.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryPeek(System.Int64,`0@)">
      <summary>Donne un aperçu de la valeur suivante au niveau de l’offset spécifié sans avancer le lecteur.</summary>
      <param name="offset">Offset à partir de la position actuelle.</param>
      <param name="value">La valeur suivante, ou la valeur par défaut si la position correspond à la fin du lecteur.</param>
      <returns>
        <see langword="true" /> si le lecteur n’est pas à la fin et que l’opération d’aperçu a réussi ; <see langword="false" /> si la position correspond à la fin du lecteur.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryRead(`0@)">
      <summary>Lit la valeur suivante et avance le lecteur.</summary>
      <param name="value">La valeur suivante, ou la valeur par défaut si la position correspond à la fin du lecteur.</param>
      <returns>
        <see langword="true" /> si le lecteur n’est pas à la fin et que l’opération de lecture a réussi ; <see langword="false" /> si la position correspond à la fin du lecteur.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,`0,System.Boolean)">
      <summary>Tente de tout lire jusqu’au <paramref name="delimiter" />, en ignorant les délimiteurs précédés de <paramref name="delimiterEscape" />.</summary>
      <param name="sequence">Quand la méthode retourne, contient les données lues, le cas échéant.</param>
      <param name="delimiter">Délimiteur à rechercher.</param>
      <param name="delimiterEscape">Valeur indiquant qu’un <paramref name="delimiter" /> qui suit immédiatement doit être ignoré.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> pour se déplacer après le <paramref name="delimiter" /> s’il est trouvé ; sinon, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> si le <paramref name="delimiter" /> a été trouvé ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,System.Boolean)">
      <summary>Tente de tout lire jusqu’au <paramref name="delimiter" />.</summary>
      <param name="sequence">Quand la méthode retourne, contient les données lues, le cas échéant.</param>
      <param name="delimiter">Délimiteur à rechercher.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> pour se déplacer après le <paramref name="delimiter" /> s’il est trouvé ; sinon, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> si le <paramref name="delimiter" /> a été trouvé ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Tente de lire les données jusqu’à ce que le délimiteur entier spécifié comme plage en lecture seule soit rencontré.</summary>
      <param name="sequence">Quand la méthode retourne, contient les données lues, le cas échéant.</param>
      <param name="delimiter">Plage en lecture seule qui contient un ou plusieurs délimiteurs.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> pour se déplacer après le <paramref name="delimiter" /> s’il est trouvé ; sinon, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> si le <paramref name="delimiter" /> a été trouvé ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,`0,System.Boolean)">
      <summary>Tente de tout lire jusqu’au <paramref name="delimiter" />, en ignorant les délimiteurs précédés de <paramref name="delimiterEscape" />.</summary>
      <param name="span">Quand la méthode retourne, contient les données lues, le cas échéant.</param>
      <param name="delimiter">Délimiteur à rechercher.</param>
      <param name="delimiterEscape">Valeur indiquant qu’un <paramref name="delimiter" /> qui suit immédiatement doit être ignoré.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> pour se déplacer après le <paramref name="delimiter" /> s’il est trouvé ; sinon, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> si le <paramref name="delimiter" /> a été trouvé ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,System.Boolean)">
      <summary>Tente de tout lire jusqu’au <paramref name="delimiter" />.</summary>
      <param name="span">Quand la méthode retourne, contient les données lues, le cas échéant.</param>
      <param name="delimiter">Délimiteur à rechercher.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> pour se déplacer après le <paramref name="delimiter" /> s’il est trouvé ; sinon, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> si le <paramref name="delimiter" /> a été trouvé ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Tente de tout lire jusqu’au <paramref name="delimiter" />.</summary>
      <param name="sequence">Données lues, le cas échéant.</param>
      <param name="delimiter">Délimiteur à rechercher.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> pour se déplacer jusqu’après le <paramref name="delimiter" /> s’il est trouvé.</param>
      <param name="span">Données lues, le cas échéant.</param>
      <returns>
        <see langword="true" /> si le <paramref name="delimiter" /> a été trouvé ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadToAny(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Tente de tout lire jusqu’à un des <paramref name="delimiters" /> spécifiés.</summary>
      <param name="sequence">Quand la méthode retourne, contient les données lues, le cas échéant.</param>
      <param name="delimiters">Délimiteurs à rechercher.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> pour se déplacer après la première instance trouvée d’un des <paramref name="delimiters" /> donnés ; sinon, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> si un des <paramref name="delimiters" /> a été trouvé ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadToAny(System.ReadOnlySpan{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Tente de tout lire jusqu’à un des <paramref name="delimiters" /> spécifiés.</summary>
      <param name="span">Quand la méthode retourne, contient les données lues, le cas échéant.</param>
      <param name="delimiters">Délimiteurs à rechercher.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> pour se déplacer après la première instance trouvée d’un des <paramref name="delimiters" /> donnés ; sinon, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> si un des <paramref name="delimiters" /> a été trouvé ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Consumed">
      <summary>Obtient le nombre total de valeurs <typeparamref name="T" /> traitées par le lecteur.</summary>
      <returns>Nombre total de valeurs traitées par le lecteur.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.CurrentSpan">
      <summary>Obtient un <see cref="T:System.Span`1" /> qui contient le segment actuel dans <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns>Étendue qui contient le segment actuel dans la séquence.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.CurrentSpanIndex">
      <summary>Obtient l’index dans <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />.</summary>
      <returns>Index dans le <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.End">
      <summary>Obtient une valeur qui indique s’il n’y a plus de données dans <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns>
        <see langword="true" /> lorsqu’il n’y a plus de données dans <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> ; sinon, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Length">
      <summary>Obtient le nombre d’éléments dans la <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> du lecteur.</summary>
      <returns>Nombre d’éléments dans le du lecteur <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Position">
      <summary>Obtient la position actuelle dans <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns>Position actuelle dans le <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Remaining">
      <summary>Obtient les éléments restants dans la <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> du lecteur.</summary>
      <returns>Les éléments restants dans le lecteur <see cref="P:System.Buffers.SequenceReader`1.Sequence" /></returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Sequence">
      <summary>Obtient la <see cref="T:System.Buffers.ReadOnlySequence`1" /> sous-jacente pour le lecteur.</summary>
      <returns>Séquence en lecture seule sous-jacente pour le lecteur.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.UnreadSequence">
      <summary>Obtient la partie non lue de <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns>Partie non lue de <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.UnreadSpan">
      <summary>Obtient la partie non lue de <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />.</summary>
      <returns>Partie non lue de <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> .</returns>
    </member>
    <member name="T:System.Buffers.SequenceReaderExtensions">
      <summary>Fournit des fonctionnalités étendues pour la classe <see cref="T:System.Buffers.SequenceReader`1" /> qui permet de lire des valeurs numériques spécifiques à endian à partir de données binaires.</summary>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int16@)">
      <summary>Tente de lire un <see cref="T:System.Int16" /> avec primauté des octets de poids fort (big-endian).</summary>
      <param name="reader">Instance de lecteur de séquence d’octets à partir de laquelle la valeur doit être lue.</param>
      <param name="value">Lorsque la méthode est retournée, valeur lue dans le lecteur de séquence d’octets, avec primauté des octets de poids fort (big-endian).</param>
      <returns>
        <see langword="true" /> si l’opération de lecture réussit ; <see langword="false" /> s’il n’y pas suffisamment de données pour un <see cref="T:System.Int16" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int32@)">
      <summary>Tente de lire un <see cref="T:System.Int32" /> avec primauté des octets de poids fort (big-endian).</summary>
      <param name="reader">Lecteur de séquence d’octets à partir duquel la valeur doit être lue.</param>
      <param name="value">Lorsque la méthode est retournée, valeur lue dans le lecteur de séquence d’octets, avec primauté des octets de poids fort (big-endian).</param>
      <returns>
        <see langword="true" /> si l’opération de lecture réussit ; <see langword="false" /> s’il n’y pas suffisamment de données pour un <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int64@)">
      <summary>Tente de lire un <see cref="T:System.Int64" /> avec primauté des octets de poids fort (big-endian).</summary>
      <param name="reader">Instance de lecteur de séquence d’octets à partir de laquelle la valeur doit être lue.</param>
      <param name="value">Lorsque la méthode est retournée, valeur lue dans le lecteur de séquence d’octets, avec primauté des octets de poids fort (big-endian).</param>
      <returns>
        <see langword="true" /> si l’opération de lecture réussit ; <see langword="false" /> s’il n’y pas suffisamment de données pour un <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int16@)">
      <summary>Tente de lire un <see cref="T:System.Int16" /> en mode Little Endian.</summary>
      <param name="reader">Instance de lecteur de séquence d’octets à partir de laquelle la valeur doit être lue.</param>
      <param name="value">Lorsque la méthode est retournée, valeur lue dans le lecteur de séquence d’octets, en mode Little Endian.</param>
      <returns>
        <see langword="true" /> si l’opération de lecture réussit ; <see langword="false" /> s’il n’y pas suffisamment de données pour un <see cref="T:System.Int16" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int32@)">
      <summary>Tente de lire un <see cref="T:System.Int32" /> en mode Little Endian.</summary>
      <param name="reader">Instance de lecteur de séquence d’octets à partir de laquelle la valeur doit être lue.</param>
      <param name="value">Lorsque la méthode est retournée, valeur lue dans le lecteur de séquence d’octets, en mode Little Endian.</param>
      <returns>
        <see langword="true" /> si l’opération de lecture réussit ; <see langword="false" /> s’il n’y pas suffisamment de données pour un <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int64@)">
      <summary>Tente de lire un <see cref="T:System.Int64" /> en mode Little Endian.</summary>
      <param name="reader">Instance de lecteur de séquence d’octets à partir de laquelle la valeur doit être lue.</param>
      <param name="value">Lorsque la méthode est retournée, valeur lue dans le lecteur de séquence d’octets, en mode Little Endian.</param>
      <returns>
        <see langword="true" /> si l’opération de lecture réussit ; <see langword="false" /> s’il n’y pas suffisamment de données pour un <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="T:System.Buffers.StandardFormat">
      <summary>Représente une chaîne de format standard sans utiliser une chaîne réelle.</summary>
    </member>
    <member name="F:System.Buffers.StandardFormat.MaxPrecision">
      <summary>Définit la valeur maximale de précision valide.</summary>
    </member>
    <member name="F:System.Buffers.StandardFormat.NoPrecision">
      <summary>Indique qu’un format n’utilise pas de précision ou que la précision n’est pas spécifiée.</summary>
    </member>
    <member name="M:System.Buffers.StandardFormat.#ctor(System.Char,System.Byte)">
      <summary>Initialise une nouvelle instance de la structure <see cref="T:System.Buffers.StandardFormat" />.</summary>
      <param name="symbol">Un spécificateur de format de type spécifique, comme « G », « D » ou « X ».</param>
      <param name="precision">Précision facultative comprise entre 0 et 99, ou la valeur spéciale <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> (valeur par défaut).</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="symbol" /> n’est pas <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> et sa valeur est supérieure à <see cref="F:System.Buffers.StandardFormat.MaxPrecision" />.

- ou -

<paramref name="symbol" /> ne peut pas être converti en objet <see cref="T:System.Byte" />.</exception>
    </member>
    <member name="M:System.Buffers.StandardFormat.Equals(System.Buffers.StandardFormat)">
      <summary>Retourne une valeur qui indique si le <see cref="T:System.Buffers.StandardFormat" /> spécifié est égal à l’instance actuelle.</summary>
      <param name="other">Format à comparer à l’instance actuelle.</param>
      <returns>
        <see langword="true" /> si les deux instances sont égales ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Equals(System.Object)">
      <summary>Retourne une valeur qui indique si l’objet spécifié est un objet <see cref="T:System.Buffers.StandardFormat" /> égal à l’instance actuelle.</summary>
      <param name="obj">Objet à comparer à l’instance actuelle.</param>
      <returns>
        <see langword="true" /> si les deux instances sont égales ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.GetHashCode">
      <summary>Retourne le code de hachage de cette instance.</summary>
      <returns>Code de hachage de cette instance.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Equality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
      <summary>Retourne une valeur qui indique si deux instances de <see cref="T:System.Buffers.StandardFormat" /> sont égales.</summary>
      <param name="left">Premier format à comparer.</param>
      <param name="right">Second format à comparer.</param>
      <returns>
        <see langword="true" /> si les deux instances sont égales ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Implicit(System.Char)~System.Buffers.StandardFormat">
      <summary>Convertit un caractère en une instance <see cref="T:System.Buffers.StandardFormat" /> à l’aide de la précision <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</summary>
      <param name="symbol">Caractère à convertir en valeur <see cref="T:System.Buffers.StandardFormat" />.</param>
      <returns>Format avec une propriété <see cref="P:System.Buffers.StandardFormat.Symbol" /> égale à <paramref name="symbol" /> et une propriété <see cref="P:System.Buffers.StandardFormat.Precision" /> égale à <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Inequality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
      <summary>Détermine si deux instances de <see cref="T:System.Buffers.StandardFormat" /> sont inégales.</summary>
      <param name="left">Premier format à comparer.</param>
      <param name="right">Second format à comparer.</param>
      <returns>
        <see langword="true" /> si les deux formats sont inégaux ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Parse(System.ReadOnlySpan{System.Char})">
      <summary>Convertit un <see langword="ReadOnlySpan&lt;System.Char&gt;" /> en une instance <see cref="T:System.Buffers.StandardFormat" /> à l’aide de la précision <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</summary>
      <param name="format">Étendue en lecture seule qui contient le caractère à analyser.</param>
      <returns>Valeur dont la valeur de propriété <see cref="P:System.Buffers.StandardFormat.Symbol" /> est le caractère dans <paramref name="format" /> et dont la valeur de propriété <see cref="P:System.Buffers.StandardFormat.Precision" /> est <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Parse(System.String)">
      <summary>Convertit une chaîne de format standard .NET classique en une instance <see cref="T:System.Buffers.StandardFormat" />.</summary>
      <param name="format">Chaîne de format standard .NET classique.</param>
      <exception cref="T:System.FormatException">
        <paramref name="format" /> n’est pas une chaîne de format standard valide.</exception>
      <returns>Un format.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.ToString">
      <summary>Retourne la représentation sous forme de chaîne de ce format.</summary>
      <returns>Représentation sous forme de chaîne de ce format.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.TryParse(System.ReadOnlySpan{System.Char},System.Buffers.StandardFormat@)">
      <summary>Tente de convertir un <see langword="ReadOnlySpan&lt;Char&gt;" /> en une instance <see cref="T:System.Buffers.StandardFormat" /> et retourne une valeur qui indique si l’opération d’analyse a réussi.</summary>
      <param name="format">Étendue en lecture seule qui contient le caractère à convertir.</param>
      <param name="result">Lorsque cette méthode retourne une valeur, contient l’instance <see cref="T:System.Buffers.StandardFormat" /> analysée si l’opération a réussi.</param>
      <returns>
        <see langword="true" /> si l'opération d'analyse a réussi ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.HasPrecision">
      <summary>Obtient une valeur qui indique si un format a une précision définie.</summary>
      <returns>
        <see langword="true" /> Si le format a une précision autre que <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> ; sinon, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.IsDefault">
      <summary>Obtient une valeur qui indique si l'instance actuelle est un format par défaut.</summary>
      <returns>
        <see langword="true" /> Si l’instance actuelle est un format par défaut ; Sinon, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.Precision">
      <summary>Obtient le composant de la précision du format.</summary>
      <returns>Le composant de précision, qui peut être <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> , ou peut être compris entre 0 et 9.</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.Symbol">
      <summary>Obtient le composant de caractère du format.</summary>
      <returns>Composant de caractère du format.</returns>
    </member>
    <member name="T:System.Buffers.Text.Base64">
      <summary>Conversions entre les données binaires et le texte codé UTF-8 qui est représenté en base 64.</summary>
    </member>
    <member name="M:System.Buffers.Text.Base64.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean)">
      <summary>Décode l’étendue du texte codé en UTF-8 représenté en tant que base 64 dans les données binaires. Si l’entrée n’est pas un multiple de 4, il décodera autant que possible, au multiple de 4 le plus proche.</summary>
      <param name="utf8">L’étendue d’entrée qui contient du texte codé UTF-8 en base 64 qui doit être décodé.</param>
      <param name="bytes">L’étendue de sortie qui contient le résultat de l’opération, autrement dit, les données binaires décodées.</param>
      <param name="bytesConsumed">Le nombre d’octets d’entrée consommés pendant l’opération. Cela peut servir à découper l’entrée pour les appels suivants, si nécessaire.</param>
      <param name="bytesWritten">Le nombre d’octets écrits dans l’étendue de sortie. Cela peut servir à découper la sortie pour les appels suivants, si nécessaire.</param>
      <param name="isFinalBlock">
        <see langword="true" /> (valeur par défaut) si l’étendue d’entrée contient la totalité des données à décoder. <see langword="false" /> si l’étendue d’entrée contient des données partielles avec plus de données à suivre.</param>
      <returns>L'une des valeurs d’énumération qui indique l’état de l’opération de décodage.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.DecodeFromUtf8InPlace(System.Span{System.Byte},System.Int32@)">
      <summary>Décode l’étendue du texte codé en UTF-8 en base 64 (sur place) dans les données binaires. La sortie binaire décodée est plus petite que les données de texte contenues dans l’entrée (l’opération dégonfle des données). Si l’entrée n’est pas un multiple de 4, la méthode ne décodera aucune donnée.</summary>
      <param name="buffer">L’étendue d’entrée qui contient les données de texte en base 64 qui doit être décodé.</param>
      <param name="bytesWritten">Le nombre d’octets écrits dans la mémoire tampon.</param>
      <returns>L'une des valeurs d’énumération qui indique l’état de l’opération de décodage.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.EncodeToUtf8(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean)">
      <summary>Code l’étendue des données binaires en texte codé UTF-8 représenté en tant que base 64.</summary>
      <param name="bytes">L’étendue d’entrée qui contient les données binaires qui doivent être codées.</param>
      <param name="utf8">L’étendue de sortie qui contient le résultat de l’opération, autrement dit, le texte codé UTF-8 en base 64.</param>
      <param name="bytesConsumed">Le nombre d’octets d’entrée consommés pendant l’opération. Cela peut servir à découper l’entrée pour les appels suivants, si nécessaire.</param>
      <param name="bytesWritten">Le nombre d’octets écrits dans l’étendue de sortie. Cela peut servir à découper la sortie pour les appels suivants, si nécessaire.</param>
      <param name="isFinalBlock">
        <see langword="true" /> (valeur par défaut) si l’étendue d’entrée contient la totalité des données à coder. <see langword="false" /> si l’étendue d’entrée contient des données partielles avec plus de données à suivre.</param>
      <returns>L'une des valeurs d’énumération qui indique l’état de l’opération de codage.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.EncodeToUtf8InPlace(System.Span{System.Byte},System.Int32,System.Int32@)">
      <summary>Code l’étendue des données binaires (sur place) en texte codé UTF-8 représenté en tant que base 64. La sortie du texte codé est plus grande que les données binaires contenues dans l’entrée (l’opération gonfle les données).</summary>
      <param name="buffer">L’étendue d’entrée qui contient les données binaires qui doivent être codées. Étant donné que la méthode effectue une conversion sur place, elle doit être suffisamment grande pour stocker le résultat de l’opération.</param>
      <param name="dataLength">Le nombre d’octets de données binaires contenues dans la mémoire tampon qui doit être codé. Cette valeur doit être inférieure à la longueur de la mémoire tampon.</param>
      <param name="bytesWritten">Le nombre d’octets écrits dans la mémoire tampon.</param>
      <returns>L'une des valeurs d’énumération qui indique l’état de l’opération de codage.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.GetMaxDecodedFromUtf8Length(System.Int32)">
      <summary>Retourne la longueur maximale (en octets) du résultat, si vous deviez décoder le texte codé en base 64 dans une étendue d’octets avec la longueur spécifiée.</summary>
      <param name="length">Taille de l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> est inférieur à 0.</exception>
      <returns>Longueur maximale (en octets) du résultat.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.GetMaxEncodedToUtf8Length(System.Int32)">
      <summary>Retourne la longueur maximale (en octets) du résultat, si vous deviez coder les données binaires dans une étendue d’octets avec la longueur spécifiée.</summary>
      <param name="length">Taille de l’étendue d’octets.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> est inférieur à 0 ou supérieur à 1610612733 (étant donné que le codage gonfle les données de 4/3).</exception>
      <returns>Longueur maximale (en octets) du résultat.</returns>
    </member>
    <member name="T:System.Buffers.Text.Utf8Formatter">
      <summary>Fournit des méthodes statiques pour mettre en forme des types de données courants en tant que chaînes UTF8.</summary>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Boolean,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Met en forme un <see cref="T:System.Boolean" /> en chaîne UTF-8.</summary>
      <param name="value">Valeur à mettre en forme.</param>
      <param name="destination">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format">Format standard à utiliser.</param>
      <returns>
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Byte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Met en forme un <see cref="T:System.Byte" /> en chaîne UTF-8.</summary>
      <param name="value">Valeur à mettre en forme.</param>
      <param name="destination">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format">Format standard à utiliser.</param>
      <returns>
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTime,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Met en forme un <see cref="T:System.DateTime" /> en chaîne UTF-8.</summary>
      <param name="value">Valeur à mettre en forme.</param>
      <param name="destination">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format">Format standard à utiliser.</param>
      <returns>
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTimeOffset,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Met en forme un <see cref="T:System.DateTimeOffset" /> en chaîne UTF-8.</summary>
      <param name="value">Valeur à mettre en forme.</param>
      <param name="destination">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format">Format standard à utiliser.</param>
      <returns>
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Decimal,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Met en forme un <see cref="T:System.Decimal" /> en chaîne UTF-8.</summary>
      <param name="value">Valeur à mettre en forme.</param>
      <param name="destination">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format">Format standard à utiliser.</param>
      <returns>
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Double,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Met en forme un <see cref="T:System.Double" /> en chaîne UTF-8.</summary>
      <param name="value">Valeur à mettre en forme.</param>
      <param name="destination">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format">Format standard à utiliser.</param>
      <returns>
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Guid,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Met en forme un <see cref="T:System.Guid" /> en chaîne UTF-8.</summary>
      <param name="value">Valeur à mettre en forme.</param>
      <param name="destination">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format">Format standard à utiliser.</param>
      <returns>
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Met en forme un <see cref="T:System.Int16" /> en chaîne UTF-8.</summary>
      <param name="value">Valeur à mettre en forme.</param>
      <param name="destination">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format">Format standard à utiliser.</param>
      <returns>
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Met en forme un <see cref="T:System.Int32" /> en chaîne UTF-8.</summary>
      <param name="value">Valeur à mettre en forme.</param>
      <param name="destination">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format">Format standard à utiliser.</param>
      <returns>
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Met en forme un <see cref="T:System.Int64" /> en chaîne UTF-8.</summary>
      <param name="value">Valeur à mettre en forme.</param>
      <param name="destination">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format">Format standard à utiliser.</param>
      <returns>
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.SByte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Met en forme un <see cref="T:System.SByte" /> en chaîne UTF-8.</summary>
      <param name="value">Valeur à mettre en forme.</param>
      <param name="destination">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format">Format standard à utiliser.</param>
      <returns>
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Single,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Met en forme un <see cref="T:System.Single" /> en chaîne UTF-8.</summary>
      <param name="value">Valeur à mettre en forme.</param>
      <param name="destination">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format">Format standard à utiliser.</param>
      <returns>
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.TimeSpan,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Met en forme un <see cref="T:System.TimeSpan" /> en chaîne UTF-8.</summary>
      <param name="value">Valeur à mettre en forme.</param>
      <param name="destination">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format">Format standard à utiliser.</param>
      <returns>
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Met en forme un <see cref="T:System.UInt16" /> en chaîne UTF-8.</summary>
      <param name="value">Valeur à mettre en forme.</param>
      <param name="destination">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format">Format standard à utiliser.</param>
      <returns>
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Met en forme un <see cref="T:System.UInt32" /> en chaîne UTF-8.</summary>
      <param name="value">Valeur à mettre en forme.</param>
      <param name="destination">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format">Format standard à utiliser.</param>
      <returns>
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Met en forme un <see cref="T:System.UInt64" /> en chaîne UTF-8.</summary>
      <param name="value">Valeur à mettre en forme.</param>
      <param name="destination">Mémoire tampon où écrire la valeur au format UTF-8.</param>
      <param name="bytesWritten">Quand la méthode retourne, contient la longueur en octets du texte mis en forme.</param>
      <param name="format">Format standard à utiliser.</param>
      <returns>
        <see langword="true" /> si l’opération de mise en forme réussit ; <see langword="false" /> si <paramref name="buffer" /> est trop petit.</returns>
    </member>
    <member name="T:System.Buffers.Text.Utf8Parser">
      <summary>Fournit des méthodes statiques pour analyser les types de données courants dans les chaînes UTF-8.</summary>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Boolean@,System.Int32@,System.Char)">
      <summary>Analyse un <see cref="T:System.Boolean" /> au début d’une chaîne UTF-8.</summary>
      <param name="source">Chaîne UTF-8 à analyser.</param>
      <param name="value">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat">Format attendu de la chaîne UTF-8.</param>
      <returns>
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Byte@,System.Int32@,System.Char)">
      <summary>Analyse un <see cref="T:System.Byte" /> au début d’une chaîne UTF-8.</summary>
      <param name="source">Chaîne UTF-8 à analyser.</param>
      <param name="value">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat">Format attendu de la chaîne UTF-8.</param>
      <returns>
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.DateTime@,System.Int32@,System.Char)">
      <summary>Analyse un <see cref="T:System.DateTime" /> au début d’une chaîne UTF-8.</summary>
      <param name="source">Chaîne UTF-8 à analyser.</param>
      <param name="value">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat">Format attendu de la chaîne UTF-8.</param>
      <returns>
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.DateTimeOffset@,System.Int32@,System.Char)">
      <summary>Analyse un <see cref="T:System.DateTimeOffset" /> au début d’une chaîne UTF-8.</summary>
      <param name="source">Chaîne UTF-8 à analyser.</param>
      <param name="value">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat">Format attendu de la chaîne UTF-8.</param>
      <returns>
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Decimal@,System.Int32@,System.Char)">
      <summary>Analyse un <see cref="T:System.Decimal" /> au début d’une chaîne UTF-8.</summary>
      <param name="source">Chaîne UTF-8 à analyser.</param>
      <param name="value">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat">Format attendu de la chaîne UTF-8.</param>
      <returns>
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Double@,System.Int32@,System.Char)">
      <summary>Analyse un <see cref="T:System.Double" /> au début d’une chaîne UTF-8.</summary>
      <param name="source">Chaîne UTF-8 à analyser.</param>
      <param name="value">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat">Format attendu de la chaîne UTF-8.</param>
      <returns>
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Guid@,System.Int32@,System.Char)">
      <summary>Analyse un <see cref="T:System.Guid" /> au début d’une chaîne UTF-8.</summary>
      <param name="source">Chaîne UTF-8 à analyser.</param>
      <param name="value">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat">Format attendu de la chaîne UTF-8.</param>
      <returns>
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int16@,System.Int32@,System.Char)">
      <summary>Analyse un <see cref="T:System.Int16" /> au début d’une chaîne UTF-8.</summary>
      <param name="source">Chaîne UTF-8 à analyser.</param>
      <param name="value">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat">Format attendu de la chaîne UTF-8.</param>
      <returns>
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int32@,System.Int32@,System.Char)">
      <summary>Analyse un <see cref="T:System.Int32" /> au début d’une chaîne UTF-8.</summary>
      <param name="source">Chaîne UTF-8 à analyser.</param>
      <param name="value">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat">Format attendu de la chaîne UTF-8.</param>
      <returns>
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int64@,System.Int32@,System.Char)">
      <summary>Analyse un <see cref="T:System.Int64" /> au début d’une chaîne UTF-8.</summary>
      <param name="source">Chaîne UTF-8 à analyser.</param>
      <param name="value">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat">Format attendu de la chaîne UTF-8.</param>
      <returns>
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.SByte@,System.Int32@,System.Char)">
      <summary>Analyse un <see cref="T:System.SByte" /> au début d’une chaîne UTF-8.</summary>
      <param name="source">Chaîne UTF-8 à analyser.</param>
      <param name="value">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat">Format attendu de la chaîne UTF-8.</param>
      <returns>
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Single@,System.Int32@,System.Char)">
      <summary>Analyse un <see cref="T:System.Single" /> au début d’une chaîne UTF-8.</summary>
      <param name="source">Chaîne UTF-8 à analyser.</param>
      <param name="value">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat">Format attendu de la chaîne UTF-8.</param>
      <returns>
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.TimeSpan@,System.Int32@,System.Char)">
      <summary>Analyse un <see cref="T:System.TimeSpan" /> au début d’une chaîne UTF-8.</summary>
      <param name="source">Chaîne UTF-8 à analyser.</param>
      <param name="value">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat">Format attendu de la chaîne UTF-8.</param>
      <returns>
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt16@,System.Int32@,System.Char)">
      <summary>Analyse un <see cref="T:System.UInt16" /> au début d’une chaîne UTF-8.</summary>
      <param name="source">Chaîne UTF-8 à analyser.</param>
      <param name="value">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat">Format attendu de la chaîne UTF-8.</param>
      <returns>
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt32@,System.Int32@,System.Char)">
      <summary>Analyse un <see cref="T:System.UInt32" /> au début d’une chaîne UTF-8.</summary>
      <param name="source">Chaîne UTF-8 à analyser.</param>
      <param name="value">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat">Format attendu de la chaîne UTF-8.</param>
      <returns>
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt64@,System.Int32@,System.Char)">
      <summary>Analyse un <see cref="T:System.UInt64" /> au début d’une chaîne UTF-8.</summary>
      <param name="source">Chaîne UTF-8 à analyser.</param>
      <param name="value">Quand la méthode retourne, contient la valeur analysée à partir de <paramref name="source" /> si l’opération d’analyse a réussi.</param>
      <param name="bytesConsumed">Si l’opération d’analyse a réussi, contient la longueur en octets de la sous-chaîne analysée quand la méthode retourne. Si la méthode échoue, <paramref name="bytesConsumed" /> est défini sur 0.</param>
      <param name="standardFormat">Format attendu de la chaîne UTF-8.</param>
      <returns>
        <see langword="true" /> pour la réussite ; <see langword="false" /> si la syntaxe de la chaîne n’était pas valide, ou si un dépassement de capacité positif ou négatif s’est produit.</returns>
    </member>
    <member name="T:System.MemoryExtensions">
      <summary>Fournit des méthodes d’extension pour les types liés à la mémoire et à l’étendue, comme <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />, <see cref="T:System.Span`1" /> et <see cref="T:System.ReadOnlySpan`1" />.</summary>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String)">
      <summary>Crée un <see langword="ReadOnlyMemory&lt;Char&gt;" /> sur la partie de la chaîne cible.</summary>
      <param name="text">Chaîne cible.</param>
      <returns>Représentation sous forme de mémoire de caractères en lecture seule de la chaîne, ou <see langword="default" /> si <paramref name="text" /> est <see langword="null" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Index)">
      <summary>Crée un <see langword="ReadOnlyMemory&lt;Char&gt;" /> sur une partie de la chaîne cible en commençant à un index spécifié.</summary>
      <param name="text">Chaîne cible.</param>
      <param name="startIndex">Index auquel commence cette section.</param>
      <returns>Représentation sous forme de mémoire de caractères en lecture seule de la chaîne.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32)">
      <summary>Crée un <see langword="ReadOnlyMemory&lt;Char&gt;" /> sur une partie de la chaîne cible en commençant à une position de caractère spécifiée.</summary>
      <param name="text">Chaîne cible.</param>
      <param name="start">Index auquel commence cette section.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> n’est pas dans la plage de <paramref name="text" /> (<paramref name="start" /> est &lt; 0 ou &gt; <c>text.Length</c>).</exception>
      <returns>Représentation sous forme de mémoire de caractères en lecture seule de la chaîne, ou <see langword="default" /> si <paramref name="text" /> est <see langword="null" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32,System.Int32)">
      <summary>Crée un <see langword="ReadOnlyMemory&lt;Char&gt;" /> sur une partie de la chaîne cible en commençant à une position spécifiée avec une longueur.</summary>
      <param name="text">Chaîne cible.</param>
      <param name="start">Index auquel commence cette section.</param>
      <param name="length">Longueur souhaitée de la section.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> ou <paramref name="start" /> + <paramref name="length" /> n’est pas dans la plage de <paramref name="text" />.</exception>
      <returns>Représentation sous forme de mémoire de caractères en lecture seule de la chaîne, ou <see langword="default" /> si <paramref name="text" /> est <see langword="null" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Range)">
      <summary>Crée un <see langword="ReadOnlyMemory&lt;Char&gt;" /> sur une plage spécifiée de la chaîne cible.</summary>
      <param name="text">Chaîne cible.</param>
      <param name="range">Plage qui indique le début et la longueur de la chaîne sectionnée.</param>
      <returns>Représentation sous forme de mémoire de caractères en lecture seule de la chaîne.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[])">
      <summary>Crée une région de mémoire sur le tableau cible.</summary>
      <param name="array">Tableau à convertir.</param>
      <typeparam name="T">Type de tableau.</typeparam>
      <returns>Représentation sous forme de mémoire de tout ou partie du tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Index)">
      <summary>Crée une région de mémoire sur la partie du tableau cible en commençant à un index spécifié jusqu’à la fin du tableau.</summary>
      <param name="array">Tableau à convertir.</param>
      <param name="startIndex">Première position du tableau.</param>
      <typeparam name="T">Type de tableau.</typeparam>
      <returns>Représentation sous forme de mémoire de tout ou partie du tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32)">
      <summary>Crée une région de mémoire sur la partie du tableau cible en commençant à une position spécifiée jusqu’à la fin du tableau.</summary>
      <param name="array">Tableau cible.</param>
      <param name="start">Index à partir duquel commencer la mémoire.</param>
      <typeparam name="T">Type de tableau.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">La valeur <paramref name="array" /> est covariante et le type du tableau n’est pas exactement <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Index <paramref name="start" /> inférieur à 0 ou supérieur à <see langword="array.Length" />.</exception>
      <returns>Représentation sous forme de mémoire de tout ou partie du tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32,System.Int32)">
      <summary>Crée une région de mémoire sur la partie du tableau cible en commençant à une position spécifiée avec une longueur spécifiée.</summary>
      <param name="array">Tableau cible.</param>
      <param name="start">Index où commencer la région de mémoire.</param>
      <param name="length">Nombre d’éléments dans la région de mémoire.</param>
      <typeparam name="T">Type de tableau.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">La valeur <paramref name="array" /> est covariante et le type du tableau n’est pas exactement <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> ou <paramref name="start" /> + <paramref name="length" /> n’est pas dans la plage de <paramref name="array" />.</exception>
      <returns>Représentation sous forme de mémoire de tout ou partie du tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Range)">
      <summary>Crée une région de mémoire sur la partie du tableau cible en commençant à l’index de début inclus de la plage et en se terminant à l’index de fin exclu de la plage.</summary>
      <param name="array">Tableau à convertir.</param>
      <param name="range">Plage à convertir à partir du tableau.</param>
      <typeparam name="T">Type de tableau.</typeparam>
      <returns>Représentation sous forme de mémoire de tout ou partie du tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0})">
      <summary>Crée une région de mémoire sur la partie du segment de tableau cible.</summary>
      <param name="segment">Segment à convertir.</param>
      <typeparam name="T">Type de segment.</typeparam>
      <returns>Représentation sous forme de mémoire du segment.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32)">
      <summary>Crée une région de mémoire sur la partie du segment de tableau cible en commençant à une position spécifiée jusqu’à la fin du segment.</summary>
      <param name="segment">Segment de tableau cible.</param>
      <param name="start">Index à partir duquel commencer la mémoire.</param>
      <typeparam name="T">Type de tableau.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">La valeur <paramref name="segment" /> est covariante et le type de <paramref name="segment" /> n’est pas exactement <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> est inférieur à 0 ou supérieur à <see langword="segment.Count" />.</exception>
      <returns>Représentation sous forme de mémoire de tout ou partie du tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32,System.Int32)">
      <summary>Crée une région de mémoire sur la partie du segment de tableau cible en commençant à une position spécifiée avec une longueur spécifiée.</summary>
      <param name="segment">Segment de tableau cible.</param>
      <param name="start">Index à partir duquel commencer la mémoire.</param>
      <param name="length">Nombre d’éléments dans la mémoire.</param>
      <typeparam name="T">Type de tableau.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">La valeur <paramref name="segment" /> est covariante et le type du tableau n’est pas exactement <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> ou <paramref name="start" /> + <paramref name="length" /> n’est pas dans la plage de <paramref name="segment" />.</exception>
      <returns>Représentation sous forme de mémoire de tout ou partie du tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String)">
      <summary>Crée une étendue en lecture seule sur une partie de la chaîne cible à une position spécifiée pour un nombre spécifié de caractères.</summary>
      <param name="text">Chaîne cible.</param>
      <returns>Représentation sous forme d’étendue en lecture seule de la chaîne.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32)">
      <summary>Crée une étendue en lecture seule sur une partie de la chaîne cible à une position spécifiée jusqu’à la fin de la chaîne.</summary>
      <param name="text">Chaîne cible.</param>
      <param name="start">Index auquel commence cette section.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="text" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> est inférieur à 0 ou supérieur à <see langword="text.Length" />.</exception>
      <returns>Représentation sous forme d’étendue en lecture seule de la chaîne.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32,System.Int32)">
      <summary>Crée une étendue en lecture seule sur une chaîne.</summary>
      <param name="text">Chaîne cible.</param>
      <param name="start">Index auquel commence cette section.</param>
      <param name="length">Longueur souhaitée de la section.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> ou <paramref name="start" /> + <paramref name="length" /> n’est pas dans la plage de <paramref name="text" />.</exception>
      <returns>Représentation sous forme d’étendue en lecture seule de la chaîne.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[])">
      <summary>Crée une étendue sur un tableau cible.</summary>
      <param name="array">Tableau à convertir.</param>
      <typeparam name="T">Type de tableau.</typeparam>
      <returns>Représentation sous forme d’étendue du tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Index)">
      <summary>Crée une étendue sur la partie du tableau cible défini par une valeur <see cref="T:System.Index" />.</summary>
      <param name="array">Tableau à convertir.</param>
      <param name="startIndex">Index de départ.</param>
      <typeparam name="T">Type de tableau.</typeparam>
      <returns>Représentation sous forme d’étendue du tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32)">
      <summary>Crée une étendue sur une partie du tableau cible en commençant à une position spécifiée jusqu’à la fin du tableau.</summary>
      <param name="array">Tableau à convertir.</param>
      <param name="start">Index initial à partir duquel le tableau sera converti.</param>
      <typeparam name="T">Type de tableau.</typeparam>
      <returns>Représentation sous forme d’étendue du tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32,System.Int32)">
      <summary>Crée une étendue sur la partie du tableau cible en commençant à une position spécifiée pour une longueur spécifiée.</summary>
      <param name="array">Tableau cible.</param>
      <param name="start">Index à partir duquel commencer l’étendue.</param>
      <param name="length">Nombre d’éléments dans l’étendue.</param>
      <typeparam name="T">Type de tableau.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">La valeur <paramref name="array" /> est covariante et le type du tableau n’est pas exactement <see langword="T[]" />".</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> ou <paramref name="start" /> + <paramref name="length" /> n’est pas dans la plage de <paramref name="text" />.</exception>
      <returns>Représentation sous forme d’étendue du tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Range)">
      <summary>Crée une étendue sur une partie d’un tableau cible défini par une valeur <see cref="T:System.Range" />.</summary>
      <param name="array">Tableau à convertir.</param>
      <param name="range">Plage du tableau à convertir.</param>
      <typeparam name="T">Type de tableau.</typeparam>
      <returns>Représentation sous forme d’étendue du tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0})">
      <summary>Crée une étendue sur un segment de tableau cible.</summary>
      <param name="segment">Segment de tableau à convertir.</param>
      <typeparam name="T">Type du segment de tableau.</typeparam>
      <returns>Représentation sous forme d’étendue du segment de tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Index)">
      <summary>Crée une étendue sur une partie du segment de tableau cible en commençant à un index spécifié et en se terminant à la fin du segment.</summary>
      <param name="segment">Segment de tableau cible.</param>
      <param name="startIndex">Index à partir duquel commencer l’étendue.</param>
      <typeparam name="T">Type du segment de tableau.</typeparam>
      <returns>Représentation sous forme d’étendue du segment de tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32)">
      <summary>Crée une étendue sur une partie d’un segment de tableau cible à une position spécifiée jusqu’à la fin du segment.</summary>
      <param name="segment">Segment de tableau cible.</param>
      <param name="start">Index à partir duquel commencer l’étendue.</param>
      <typeparam name="T">Type du segment de tableau.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">La valeur <paramref name="segment" /> est covariante et le type du tableau n’est pas exactement <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> est inférieur à 0 ou supérieur à <see langword="segment.Count" />.</exception>
      <returns>Représentation sous forme d’étendue du segment de tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32,System.Int32)">
      <summary>Crée une étendue sur une partie d’un segment de tableau cible à une position spécifiée pour une longueur spécifiée.</summary>
      <param name="segment">Segment de tableau cible.</param>
      <param name="start">Index à partir duquel commencer l’étendue.</param>
      <param name="length">Nombre d’éléments dans l’étendue.</param>
      <typeparam name="T">Type du segment de tableau.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">La valeur <paramref name="segment" /> est covariante et le type du tableau n’est pas exactement <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> ou <paramref name="start" /> + <paramref name="length" /> n’est pas dans la plage de <paramref name="segment" />.</exception>
      <returns>Représentation sous forme d’étendue du tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Range)">
      <summary>Crée une étendue sur une partie d’un segment de tableau cible à l’aide des index de début et de fin de plage.</summary>
      <param name="segment">Segment de tableau cible.</param>
      <param name="range">Plage qui contient les index de début et de fin à utiliser pour découper le tableau.</param>
      <typeparam name="T">Type du segment de tableau.</typeparam>
      <returns>Représentation sous forme d’étendue du segment de tableau.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``1(System.ReadOnlySpan{``0},System.IComparable{``0})">
      <summary>Recherche une valeur dans une <see cref="T:System.ReadOnlySpan`1" /> entière triée en utilisant l’interface générique <see cref="T:System.IComparable`1" /> spécifiée.</summary>
      <param name="span">
        <see cref="T:System.ReadOnlySpan`1" /> triée dans laquelle rechercher.</param>
      <param name="comparable">
        <see cref="T:System.IComparable`1" /> à utiliser pendant la comparaison.</param>
      <typeparam name="T">Type d’élément de l’étendue.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> a la valeur <see langword="null" />.</exception>
      <returns>Index de base zéro de <paramref name="comparable" /> dans le <paramref name="span" /> trié, si <paramref name="comparable" /> existe ; sinon, un nombre négatif qui est le complément de bits de l'index de l'élément suivant supérieur à <paramref name="comparable" /> ou, s'il n'existe aucun élément supérieur, le complément de bits de <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``1(System.Span{``0},System.IComparable{``0})">
      <summary>Recherche une valeur dans une <see cref="T:System.Span`1" /> entière triée en utilisant l’interface générique <see cref="T:System.IComparable`1" /> spécifiée.</summary>
      <param name="span">
        <see cref="T:System.Span`1" /> triée dans laquelle rechercher.</param>
      <param name="comparable">
        <see cref="T:System.IComparable`1" /> à utiliser pendant la comparaison.</param>
      <typeparam name="T">Type d’élément de l’étendue.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> a la valeur <see langword="null" />.</exception>
      <returns>Index de base zéro de <paramref name="comparable" /> dans le <paramref name="span" /> trié, si <paramref name="comparable" /> existe ; sinon, un nombre négatif qui est le complément de bits de l'index de l'élément suivant supérieur à <paramref name="comparable" /> ou, s'il n'existe aucun élément supérieur, le complément de bits de <see cref="P:System.Span`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``0,``1)">
      <summary>Recherche une valeur spécifiée dans une <see cref="T:System.ReadOnlySpan`1" /> entière triée en utilisant le type générique <typeparamref name="TComparer" /> spécifié.</summary>
      <param name="span">
        <see cref="T:System.ReadOnlySpan`1" /> triée dans laquelle rechercher.</param>
      <param name="value">Objet à trouver. La valeur peut être <see langword="null" /> pour les types référence.</param>
      <param name="comparer">
        <typeparamref name="TComparer" /> à utiliser pendant la comparaison.</param>
      <typeparam name="T">Type d’élément de l’étendue.</typeparam>
      <typeparam name="TComparer">Type spécifique de <see cref="T:System.Collections.Generic.IComparer`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparer" /> a la valeur <see langword="null" />.</exception>
      <returns>Index de base zéro de <paramref name="value" /> dans le <paramref name="span" /> trié, si <paramref name="value" /> existe ; sinon, un nombre négatif qui est le complément de bits de l'index de l'élément suivant supérieur à <paramref name="value" /> ou, s'il n'existe aucun élément supérieur, le complément de bits de <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``1)">
      <summary>Recherche une valeur dans une <see cref="T:System.ReadOnlySpan`1" /> entière triée en utilisant le type générique <typeparamref name="TComparable" /> spécifié.</summary>
      <param name="span">
        <see cref="T:System.ReadOnlySpan`1" /> triée dans laquelle rechercher.</param>
      <param name="comparable">
        <typeparamref name="TComparable" /> à utiliser pendant la comparaison.</param>
      <typeparam name="T">Type d’élément de l’étendue.</typeparam>
      <typeparam name="TComparable">Type spécifique de <see cref="T:System.IComparable`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> a la valeur <see langword="null" />.</exception>
      <returns>Index de base zéro de <paramref name="comparable" /> dans le <paramref name="span" /> trié, si <paramref name="comparable" /> existe ; sinon, un nombre négatif qui est le complément de bits de l'index de l'élément suivant supérieur à <paramref name="comparable" /> ou, s'il n'existe aucun élément supérieur, le complément de bits de <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``0,``1)">
      <summary>Recherche une valeur spécifiée dans une <see cref="T:System.Span`1" /> entière triée en utilisant le type générique <typeparamref name="TComparer" /> spécifié.</summary>
      <param name="span">
        <see cref="T:System.Span`1" /> triée dans laquelle rechercher.</param>
      <param name="value">Objet à trouver. La valeur peut être <see langword="null" /> pour les types référence.</param>
      <param name="comparer">
        <typeparamref name="TComparer" /> à utiliser pendant la comparaison.</param>
      <typeparam name="T">Type d’élément de l’étendue.</typeparam>
      <typeparam name="TComparer">Type spécifique de <see cref="T:System.Collections.Generic.IComparer`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparer" /> a la valeur <see langword="null" />.</exception>
      <returns>Index de base zéro de <paramref name="value" /> dans le <paramref name="span" /> trié, si <paramref name="value" /> existe ; sinon, un nombre négatif qui est le complément de bits de l'index de l'élément suivant supérieur à <paramref name="value" /> ou, s'il n'existe aucun élément supérieur, le complément de bits de <see cref="P:System.Span`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``1)">
      <summary>Recherche une valeur dans une <see cref="T:System.Span`1" /> entière triée en utilisant le type générique <typeparamref name="TComparable" /> spécifié.</summary>
      <param name="span">
        <see cref="T:System.Span`1" /> triée dans laquelle rechercher.</param>
      <param name="comparable">
        <typeparamref name="TComparable" /> à utiliser pendant la comparaison.</param>
      <typeparam name="T">Type d’élément de l’étendue.</typeparam>
      <typeparam name="TComparable">Type spécifique de <see cref="T:System.IComparable`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> a la valeur <see langword="null" />.</exception>
      <returns>Index de base zéro de <paramref name="comparable" /> dans le <paramref name="span" /> trié, si <paramref name="comparable" /> existe ; sinon, un nombre négatif qui est le complément de bits de l'index de l'élément suivant supérieur à <paramref name="comparable" /> ou, s'il n'existe aucun élément supérieur, le complément de bits de <see cref="P:System.Span`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.CompareTo(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Compare une étendue de caractères à une autre à l’aide d’une comparaison de chaînes spécifiée et retourne un entier qui indique leur position relative dans l’ordre de tri.</summary>
      <param name="span">Étendue source.</param>
      <param name="other">Valeur à comparer avec l’étendue source.</param>
      <param name="comparisonType">Valeur d’énumération qui détermine comment <paramref name="span" /> et <paramref name="other" /> sont comparés.</param>
      <returns>Entier signé qui indique l’ordre relatif de <paramref name="span" /> et <paramref name="other" /> :   - S’il est inférieur à 0, <paramref name="span" /> précède à <paramref name="other" />.   - S’il est égal à 0, <paramref name="span" /> est égal à <paramref name="other" />.   - S’il est supérieur à 0, <paramref name="span" /> suit <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Indique si une valeur spécifiée se produit dans une étendue de caractères en lecture seule.</summary>
      <param name="span">Étendue source.</param>
      <param name="value">Valeur à rechercher dans l’étendue source.</param>
      <param name="comparisonType">Valeur d’énumération qui détermine comment les caractères dans <paramref name="span" /> et <paramref name="value" /> sont comparés.</param>
      <returns>
        <see langword="true" /> si <paramref name="value" /> se produit dans l’étendue ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains``1(System.ReadOnlySpan{``0},``0)">
      <summary>Indique si une valeur spécifiée est trouvée dans une étendue en lecture seule. Les valeurs sont comparées en utilisant IEquatable{T}.Equals(T).</summary>
      <param name="span">Étendue sur laquelle porte la recherche.</param>
      <param name="value">La valeur à rechercher.</param>
      <typeparam name="T">Type de l’étendue.</typeparam>
      <returns>
        <see langword="true" /> si trouvée ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains``1(System.Span{``0},``0)">
      <summary>Indique si une valeur spécifiée est trouvée dans une étendue. Les valeurs sont comparées en utilisant IEquatable{T}.Equals(T).</summary>
      <param name="span">Étendue sur laquelle porte la recherche.</param>
      <param name="value">La valeur à rechercher.</param>
      <typeparam name="T">Type des éléments de l’étendue.</typeparam>
      <returns>
        <see langword="true" /> si trouvée ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Memory{``0})">
      <summary>Copie le contenu du tableau dans une région de mémoire.</summary>
      <param name="source">Tableau à partir duquel copier les éléments.</param>
      <param name="destination">Mémoire dans laquelle copier les éléments.</param>
      <typeparam name="T">Type de tableau.</typeparam>
      <exception cref="T:System.ArgumentException">La destination est plus petite que le tableau source.</exception>
    </member>
    <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Span{``0})">
      <summary>Copie le contenu du tableau dans l’étendue.</summary>
      <param name="source">Tableau à partir duquel copier les éléments.</param>
      <param name="destination">Étendue dans laquelle copier les éléments.</param>
      <typeparam name="T">Type de tableau.</typeparam>
      <exception cref="T:System.ArgumentException">L’étendue de destination est plus petite que le tableau source.</exception>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Détermine si la fin de <paramref name="span" /> correspond à la <paramref name="value" /> spécifiée quand elle est comparée à l’aide de l’option <paramref name="comparisonType" /> spécifiée.</summary>
      <param name="span">Étendue source.</param>
      <param name="value">Séquence à comparer à la fin de l’étendue source.</param>
      <param name="comparisonType">Valeur d’énumération qui détermine comment <paramref name="span" /> et <paramref name="value" /> sont comparés.</param>
      <returns>
        <see langword="true" /> si <paramref name="value" /> correspond à la fin de <paramref name="span" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Détermine si la séquence spécifiée apparaît à la fin d’une étendue en lecture seule.</summary>
      <param name="span">Étendue source.</param>
      <param name="value">Séquence à comparer à la fin de l’étendue source.</param>
      <typeparam name="T">Type de l’étendue.</typeparam>
      <returns>
        <see langword="true" /> si <paramref name="value" /> correspond à la fin de <paramref name="span" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Détermine si la séquence spécifiée apparaît à la fin d’une étendue.</summary>
      <param name="span">Étendue source.</param>
      <param name="value">Séquence à comparer à la fin de l’étendue source.</param>
      <typeparam name="T">Type de l’étendue.</typeparam>
      <returns>
        <see langword="true" /> si <paramref name="value" /> correspond à la fin de <paramref name="span" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EnumerateRunes(System.ReadOnlySpan{System.Char})">
      <summary>Retourne une énumération de <see cref="T:System.Text.Rune" /> à partir de l’étendue en lecture seule fournie.</summary>
      <param name="span">Étendue source.</param>
      <returns>Énumérateur Rune.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EnumerateRunes(System.Span{System.Char})">
      <summary>Retourne une énumération de <see cref="T:System.Text.Rune" /> à partir de l’étendue fournie.</summary>
      <param name="span">Étendue source.</param>
      <returns>Énumérateur Rune.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Equals(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Détermine si cette <paramref name="span" /> et l’étendue <paramref name="other" /> spécifiée ont les mêmes caractères lorsqu’elles sont comparées à l’aide de l’option <paramref name="comparisonType" /> spécifiée.</summary>
      <param name="span">Étendue source.</param>
      <param name="other">Valeur à comparer avec l’étendue source.</param>
      <param name="comparisonType">Valeur d’énumération qui détermine comment <paramref name="span" /> et <paramref name="other" /> sont comparés.</param>
      <returns>
        <see langword="true" /> si elles sont égales ; sinon <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Signale l’index de base zéro de la première occurrence de la <paramref name="value" /> spécifiée dans la <paramref name="span" /> actuelle.</summary>
      <param name="span">Étendue source.</param>
      <param name="value">Valeur à rechercher dans l’étendue source.</param>
      <param name="comparisonType">Valeur d’énumération qui détermine comment <paramref name="span" /> et <paramref name="value" /> sont comparés.</param>
      <returns>Index de l’occurrence de la valeur dans l’étendue.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},``0)">
      <summary>Recherche la valeur spécifiée et retourne l’index de sa première occurrence. Les valeurs sont comparées en utilisant IEquatable{T}.Equals(T).</summary>
      <param name="span">Étendue sur laquelle porte la recherche.</param>
      <param name="value">La valeur à rechercher.</param>
      <typeparam name="T">Type de l’étendue et de la valeur.</typeparam>
      <returns>Index de l’occurrence de la valeur dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Recherche la séquence spécifiée et retourne l’index de sa première occurrence. Les valeurs sont comparées en utilisant IEquatable{T}.Equals(T).</summary>
      <param name="span">Étendue sur laquelle porte la recherche.</param>
      <param name="value">Séquence à rechercher.</param>
      <typeparam name="T">Type de l’étendue et de la valeur.</typeparam>
      <returns>Index de l’occurrence de la valeur dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},``0)">
      <summary>Recherche la valeur spécifiée et retourne l’index de sa première occurrence. Les valeurs sont comparées en utilisant IEquatable{T}.Equals(T).</summary>
      <param name="span">Étendue sur laquelle porte la recherche.</param>
      <param name="value">La valeur à rechercher.</param>
      <typeparam name="T">Type de l’étendue et de la valeur.</typeparam>
      <returns>Index de l’occurrence de la valeur dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Recherche la séquence spécifiée et retourne l’index de sa première occurrence. Les valeurs sont comparées en utilisant IEquatable{T}.Equals(T).</summary>
      <param name="span">Étendue sur laquelle porte la recherche.</param>
      <param name="value">Séquence à rechercher.</param>
      <typeparam name="T">Type de l’étendue et de la valeur.</typeparam>
      <returns>Index de l’occurrence de la valeur dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
      <summary>Recherche le premier index de l’une des valeurs spécifiées similaires à l’appel d’IndexOf plusieurs fois avec l’opérateur OR logique.</summary>
      <param name="span">Étendue sur laquelle porte la recherche.</param>
      <param name="value0">Une des valeurs à rechercher.</param>
      <param name="value1">Une des valeurs à rechercher.</param>
      <typeparam name="T">Type de l’étendue et des valeurs.</typeparam>
      <returns>Premier index de l’occurrence de l’une des valeurs dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
      <summary>Recherche le premier index de l’une des valeurs spécifiées similaires à l’appel d’IndexOf plusieurs fois avec l’opérateur OR logique.</summary>
      <param name="span">Étendue sur laquelle porte la recherche.</param>
      <param name="value0">Une des valeurs à rechercher.</param>
      <param name="value1">Une des valeurs à rechercher.</param>
      <param name="value2">Une des valeurs à rechercher.</param>
      <typeparam name="T">Type de l’étendue et des valeurs.</typeparam>
      <returns>Premier index de l’occurrence de l’une des valeurs dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Recherche le premier index de l’une des valeurs spécifiées similaires à l’appel d’IndexOf plusieurs fois avec l’opérateur OR logique.</summary>
      <param name="span">Étendue sur laquelle porte la recherche.</param>
      <param name="values">Ensemble des valeurs à rechercher.</param>
      <typeparam name="T">Type de l’étendue et des valeurs.</typeparam>
      <returns>Premier index de l’occurrence de l’une des valeurs dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0)">
      <summary>Recherche le premier index de l’une des valeurs spécifiées similaires à l’appel d’IndexOf plusieurs fois avec l’opérateur OR logique.</summary>
      <param name="span">Étendue sur laquelle porte la recherche.</param>
      <param name="value0">Une des valeurs à rechercher.</param>
      <param name="value1">Une des valeurs à rechercher.</param>
      <typeparam name="T">Type de l’étendue et des valeurs.</typeparam>
      <returns>Premier index de l’occurrence de l’une des valeurs dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0,``0)">
      <summary>Recherche le premier index de l’une des valeurs spécifiées similaires à l’appel d’IndexOf plusieurs fois avec l’opérateur OR logique.</summary>
      <param name="span">Étendue sur laquelle porte la recherche.</param>
      <param name="value0">Une des valeurs à rechercher.</param>
      <param name="value1">Une des valeurs à rechercher.</param>
      <param name="value2">Une des valeurs à rechercher.</param>
      <typeparam name="T">Type de l’étendue et des valeurs.</typeparam>
      <returns>Premier index de l’occurrence de l’une des valeurs dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Recherche le premier index de l’une des valeurs spécifiées similaires à l’appel d’IndexOf plusieurs fois avec l’opérateur OR logique.</summary>
      <param name="span">Étendue sur laquelle porte la recherche.</param>
      <param name="values">Ensemble des valeurs à rechercher.</param>
      <typeparam name="T">Type de l’étendue et des valeurs.</typeparam>
      <returns>Premier index de l’occurrence de l’une des valeurs dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IsWhiteSpace(System.ReadOnlySpan{System.Char})">
      <summary>Indique si l’étendue spécifiée contient uniquement des espaces blancs.</summary>
      <param name="span">Étendue source.</param>
      <returns>
        <see langword="true" /> si l’étendue contient uniquement des espaces blancs ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Signale l’index de base zéro de la dernière occurrence de la <paramref name="value" /> spécifiée dans la <paramref name="span" /> actuelle.</summary>
      <param name="span">Étendue source.</param>
      <param name="value">Valeur à rechercher dans l’étendue source.</param>
      <param name="comparisonType">Valeur d’énumération qui détermine comment <paramref name="span" /> et <paramref name="value" /> sont comparés.</param>
      <returns>Index de la dernière occurrence de la valeur dans l’étendue.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},``0)">
      <summary>Recherche la valeur spécifiée et retourne l’index de sa dernière occurrence. Les valeurs sont comparées en utilisant IEquatable{T}.Equals(T).</summary>
      <param name="span">Étendue sur laquelle porte la recherche.</param>
      <param name="value">La valeur à rechercher.</param>
      <typeparam name="T">Type de l’étendue et de la valeur.</typeparam>
      <returns>Index de la dernière occurrence de la valeur dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Recherche la séquence spécifiée et retourne l’index de sa dernière occurrence. Les valeurs sont comparées en utilisant IEquatable{T}.Equals(T).</summary>
      <param name="span">Étendue sur laquelle porte la recherche.</param>
      <param name="value">Séquence à rechercher.</param>
      <typeparam name="T">Type de l’étendue et de la valeur.</typeparam>
      <returns>Index de la dernière occurrence de la valeur dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},``0)">
      <summary>Recherche la valeur spécifiée et retourne l’index de sa dernière occurrence. Les valeurs sont comparées en utilisant IEquatable{T}.Equals(T).</summary>
      <param name="span">Étendue sur laquelle porte la recherche.</param>
      <param name="value">La valeur à rechercher.</param>
      <typeparam name="T">Type de l’étendue et de la valeur.</typeparam>
      <returns>Index de la dernière occurrence de la valeur dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Recherche la séquence spécifiée et retourne l’index de sa dernière occurrence. Les valeurs sont comparées en utilisant IEquatable{T}.Equals(T).</summary>
      <param name="span">Étendue sur laquelle porte la recherche.</param>
      <param name="value">Séquence à rechercher.</param>
      <typeparam name="T">Type de l’étendue et de la valeur.</typeparam>
      <returns>Index de la dernière occurrence de la valeur dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
      <summary>Recherche le dernier index de l’une des valeurs spécifiées similaires à l’appel de LastIndexOf plusieurs fois avec l’opérateur OR logique.</summary>
      <param name="span">Étendue sur laquelle porte la recherche.</param>
      <param name="value0">Une des valeurs à rechercher.</param>
      <param name="value1">Une des valeurs à rechercher.</param>
      <typeparam name="T">Type de l’étendue et des valeurs.</typeparam>
      <returns>Index de la dernière occurrence de l’une des valeurs dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
      <summary>Recherche le dernier index de l’une des valeurs spécifiées similaires à l’appel de LastIndexOf plusieurs fois avec l’opérateur OR logique.</summary>
      <param name="span">Étendue sur laquelle porte la recherche.</param>
      <param name="value0">Une des valeurs à rechercher.</param>
      <param name="value1">Une des valeurs à rechercher.</param>
      <param name="value2">Une des valeurs à rechercher.</param>
      <typeparam name="T">Type de l’étendue et des valeurs.</typeparam>
      <returns>Index de la dernière occurrence de l’une des valeurs dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Recherche le dernier index de l’une des valeurs spécifiées similaires à l’appel de LastIndexOf plusieurs fois avec l’opérateur OR logique.</summary>
      <param name="span">Étendue sur laquelle porte la recherche.</param>
      <param name="values">Ensemble des valeurs à rechercher.</param>
      <typeparam name="T">Type de l’étendue et des valeurs.</typeparam>
      <returns>Index de la dernière occurrence de l’une des valeurs dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0)">
      <summary>Recherche le dernier index de l’une des valeurs spécifiées similaires à l’appel de LastIndexOf plusieurs fois avec l’opérateur OR logique.</summary>
      <param name="span">Étendue sur laquelle porte la recherche.</param>
      <param name="value0">Une des valeurs à rechercher.</param>
      <param name="value1">Une des valeurs à rechercher.</param>
      <typeparam name="T">Type de l’étendue et des valeurs.</typeparam>
      <returns>Index de la dernière occurrence de l’une des valeurs dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0,``0)">
      <summary>Recherche le dernier index de l’une des valeurs spécifiées similaires à l’appel de LastIndexOf plusieurs fois avec l’opérateur OR logique.</summary>
      <param name="span">Étendue sur laquelle porte la recherche.</param>
      <param name="value0">Une des valeurs à rechercher.</param>
      <param name="value1">Une des valeurs à rechercher.</param>
      <param name="value2">Une des valeurs à rechercher.</param>
      <typeparam name="T">Type de l’étendue et des valeurs.</typeparam>
      <returns>Index de la dernière occurrence de l’une des valeurs dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Recherche le dernier index de l’une des valeurs spécifiées similaires à l’appel de LastIndexOf plusieurs fois avec l’opérateur OR logique.</summary>
      <param name="span">Étendue sur laquelle porte la recherche.</param>
      <param name="values">Ensemble des valeurs à rechercher.</param>
      <typeparam name="T">Type de l’étendue et des valeurs.</typeparam>
      <returns>Index de la dernière occurrence de l’une des valeurs dans l’étendue. Si non trouvé(e), retourne -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Détermine si deux séquences en lecture seule se chevauchent dans la mémoire.</summary>
      <param name="span">Première séquence.</param>
      <param name="other">Deuxième séquence.</param>
      <typeparam name="T">Type des éléments de la séquence en lecture seule.</typeparam>
      <returns>
        <see langword="true" /> si les deux séquences se chevauchent ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Int32@)">
      <summary>Détermine si deux séquences en lecture seule se chevauchent dans la mémoire et génère le décalage des éléments.</summary>
      <param name="span">Première séquence.</param>
      <param name="other">Deuxième séquence.</param>
      <param name="elementOffset">Quand la méthode retourne, contient le décalage entre <paramref name="span" /> et <paramref name="other" />.</param>
      <typeparam name="T">Type des éléments de l’étendue.</typeparam>
      <returns>
        <see langword="true" /> si les deux séquences se chevauchent ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Détermine si une étendue et une étendue en lecture seule se chevauchent dans la mémoire.</summary>
      <param name="span">Étendue à comparer.</param>
      <param name="other">Étendue en lecture seule à comparer.</param>
      <typeparam name="T">Type des éléments de l’étendue.</typeparam>
      <returns>
        <see langword="true" /> si les deux séquences se chevauchent ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0},System.Int32@)">
      <summary>Détermine si une étendue et une étendue en lecture seule se chevauchent dans la mémoire et génère le décalage des éléments.</summary>
      <param name="span">Première séquence à comparer.</param>
      <param name="other">Seconde séquence à comparer.</param>
      <param name="elementOffset">Quand la méthode retourne, contient le décalage entre <paramref name="span" /> et <paramref name="other" />.</param>
      <typeparam name="T">Type des éléments de l’étendue.</typeparam>
      <returns>
        <see langword="true" /> si les deux séquences se chevauchent ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Reverse``1(System.Span{``0})">
      <summary>Inverse la séquence des éléments dans l’intégralité de l’étendue.</summary>
      <param name="span">Étendue à inverser.</param>
      <typeparam name="T">Type des éléments de l’étendue.</typeparam>
    </member>
    <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Détermine l’ordre relatif de deux séquences en lecture seule en comparant leurs éléments avec IComparable{T}.CompareTo(T).</summary>
      <param name="span">Première séquence à comparer.</param>
      <param name="other">Seconde séquence à comparer.</param>
      <typeparam name="T">Type des éléments de la séquence.</typeparam>
      <returns>Entier signé qui indique l’ordre relatif de <paramref name="span" /> et <paramref name="other" /> :   - S’il est inférieur à 0, <paramref name="span" /> précède à <paramref name="other" />.   - S’il est égal à 0, <paramref name="span" /> est égal à <paramref name="other" />.   - S’il est supérieur à 0, <paramref name="span" /> suit <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Détermine l’ordre relatif d’une étendue et d’une étendue en lecture seule en comparant les éléments avec IComparable{T}.CompareTo(T).</summary>
      <param name="span">Étendue à comparer.</param>
      <param name="other">Étendue en lecture seule à comparer.</param>
      <typeparam name="T">Type des éléments de l’étendue.</typeparam>
      <returns>Entier signé qui indique l’ordre relatif de <paramref name="span" /> et <paramref name="other" /> :   - S’il est inférieur à 0, <paramref name="span" /> précède à <paramref name="other" />.   - S’il est égal à 0, <paramref name="span" /> est égal à <paramref name="other" />.   - S’il est supérieur à 0, <paramref name="span" /> suit <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceEqual``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Détermine si deux séquences en lecture seule sont égales en comparant les éléments avec IEquatable{T}.Equals(T).</summary>
      <param name="span">Première séquence à comparer.</param>
      <param name="other">Seconde séquence à comparer.</param>
      <typeparam name="T">Type des éléments de la séquence.</typeparam>
      <returns>
        <see langword="true" /> si les deux séquences sont égales ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceEqual``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Détermine si une étendue et une étendue en lecture seule sont égales en comparant les éléments avec IEquatable{T}.Equals(T).</summary>
      <param name="span">Étendue à comparer.</param>
      <param name="other">Étendue en lecture seule à comparer.</param>
      <typeparam name="T">Type des éléments de la séquence.</typeparam>
      <returns>
        <see langword="true" /> si les deux séquences sont égales ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Sort``1(System.Span{``0})">
      <summary>Trie les éléments dans l’ensemble de <see cref="T:System.Span`1" /> à l’aide <see cref="T:System.IComparable`1" /> de l’implémentation de chaque élément de <see cref="T:System.Span`1" /></summary>
      <param name="span">Étendue de la mémoire à trier.</param>
      <typeparam name="T">Type des éléments de l’étendue.</typeparam>
      <exception cref="T:System.InvalidOperationException">Un ou plusieurs éléments de <paramref name="span" /> n’implémentent pas l’interface <see cref="T:System.IComparable`1" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``1(System.Span{``0},System.Comparison{``0})">
      <summary>Trie les éléments dans l'ensemble de <see cref="T:System.Span`1" /> à l'aide du <see cref="T:System.Comparison`1" /> spécifié.</summary>
      <param name="span">Étendue de la mémoire à trier.</param>
      <param name="comparison">Méthode à utiliser lors de la comparaison d’éléments.</param>
      <typeparam name="T">Type des éléments de l’étendue.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparison" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``2(System.Span{``0},``1)">
      <summary>Trie les éléments dans l’ensemble de <see cref="T:System.Span`1" /> à l’aide de <typeparamref name="TComparer" />.</summary>
      <param name="span">Étendue de la mémoire à trier.</param>
      <param name="comparer">Méthode à utiliser lors de la comparaison d’éléments, ou <see langword="null" /> pour utiliser l’implémentation de l’interface de chaque élément <see cref="T:System.IComparable`1" />.</param>
      <typeparam name="T">Type des éléments de l’étendue.</typeparam>
      <typeparam name="TComparer">Type du comparateur à utiliser pour comparer des éléments.</typeparam>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="comparer" /> a la valeur <see langword="null" />, et un ou plusieurs éléments de <paramref name="span" /> n’implémentent pas l’interface <see cref="T:System.IComparable`1" /></exception>
      <exception cref="T:System.ArgumentException">L’implémentation de <paramref name="comparer" /> a provoqué une erreur pendant le tri.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``2(System.Span{``0},System.Span{``1})">
      <summary>Trie une paire d’étendues (l’une contenant les clés et l’autre contenant les éléments correspondants) en fonction des clés du premier <see cref="T:System.Span`1" /> à l’aide de l’implémentation  <see cref="T:System.IComparable`1" />de chaque clé.</summary>
      <param name="keys">Étendue qui contient les clés à trier.</param>
      <param name="items">Étendue qui contient les éléments qui correspondent aux clés dans <paramref name="keys" />.</param>
      <typeparam name="TKey">Type des éléments de l’étendue de clé.</typeparam>
      <typeparam name="TValue">Type des éléments de l’étendue d’éléments.</typeparam>
      <exception cref="T:System.ArgumentException">La longueur de <paramref name="keys" /> n’est pas égale à la longueur de <paramref name="items" />.</exception>
      <exception cref="T:System.InvalidOperationException">Un ou plusieurs éléments de <paramref name="keys" /> n’implémentent pas l’interface <see cref="T:System.IComparable`1" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``2(System.Span{``0},System.Span{``1},System.Comparison{``0})">
      <summary>Trie une paire d’étendues (l’une contenant les clés et l’autre contenant les éléments correspondants) en fonction des clés du premier <see cref="T:System.Span`1" /> à l’aide de la comparaison spécifiée.</summary>
      <param name="keys">Étendue qui contient les clés à trier.</param>
      <param name="items">Étendue qui contient les éléments qui correspondent aux clés dans <paramref name="keys" />.</param>
      <param name="comparison">
        <see cref="T:System.Comparison`1" /> à utiliser pendant la comparaison d’éléments.</param>
      <typeparam name="TKey">Type des éléments de l’étendue de clé.</typeparam>
      <typeparam name="TValue">Type des éléments de l’étendue d’éléments.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparison" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La longueur de <paramref name="keys" /> n’est pas égale à la longueur de <paramref name="items" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``3(System.Span{``0},System.Span{``1},``2)">
      <summary>Trie une paire d’étendues (l’une contenant les clés et l’autre contenant les éléments correspondants) en fonction des clés du premier <see cref="T:System.Span`1" /> à l’aide du comparateur spécifié.</summary>
      <param name="keys">Étendue qui contient les clés à trier.</param>
      <param name="items">Étendue qui contient les éléments qui correspondent aux clés dans <paramref name="keys" />.</param>
      <param name="comparer">Implémentation <see cref="T:System.Collections.Generic.IComparer`1" /> à utiliser lors de la comparaison d’éléments, ou <see langword="null" /> pour utiliser l'implémentation de l’interface <see cref="T:System.IComparable`1" /> de chaque élément.</param>
      <typeparam name="TKey">Type des éléments de l’étendue de clé.</typeparam>
      <typeparam name="TValue">Type des éléments de l’étendue d’éléments.</typeparam>
      <typeparam name="TComparer">Type du comparateur à utiliser pour comparer des éléments.</typeparam>
      <exception cref="T:System.ArgumentException">La longueur de <paramref name="keys" /> n’est pas égale à la longueur de <paramref name="items" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="comparer" /> a la valeur <see langword="null" />, et un ou plusieurs éléments de <paramref name="keys" /> n’implémentent pas l’interface <see cref="T:System.IComparable`1" /></exception>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Détermine si une étendue de caractères en lecture seule commence par une valeur spécifiée lors d’une comparaison avec une valeur <see cref="T:System.StringComparison" /> spécifiée.</summary>
      <param name="span">Étendue source.</param>
      <param name="value">Séquence à comparer au début de l’étendue source.</param>
      <param name="comparisonType">Valeur d’énumération qui détermine comment <paramref name="span" /> et <paramref name="value" /> sont comparés.</param>
      <returns>
        <see langword="true" /> si <paramref name="value" /> correspond au début de <paramref name="span" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Détermine si une séquence spécifiée apparaît au début d’une étendue en lecture seule.</summary>
      <param name="span">Étendue de caractères en lecture seule dans laquelle rechercher.</param>
      <param name="value">Séquence à rechercher au début de <paramref name="span" />.</param>
      <typeparam name="T">Type des éléments de l’étendue.</typeparam>
      <returns>
        <see langword="true" /> si <paramref name="value" /> correspond au début de <paramref name="span" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Détermine si une séquence spécifiée apparaît au début d’une étendue.</summary>
      <param name="span">Étendue sur laquelle porte la recherche.</param>
      <param name="value">Séquence à rechercher au début de <paramref name="span" />.</param>
      <typeparam name="T">Type des éléments de l’étendue.</typeparam>
      <returns>
        <see langword="true" /> si <paramref name="value" /> correspond au début de <paramref name="span" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToLower(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
      <summary>Copie les caractères de l’étendue source dans la destination en convertissant chaque caractère en minuscules, à l’aide des règles de casse de la culture spécifiée.</summary>
      <param name="source">Étendue source.</param>
      <param name="destination">Étendue de destination qui contient les caractères transformés.</param>
      <param name="culture">Objet qui fournit les règles de casse propres à la culture.</param>
      <exception cref="T:System.InvalidOperationException">Les mémoires tampon source et de destination se chevauchent.</exception>
      <returns>Nombre de caractères écrits dans l’étendue de destination. Si la destination est trop petite, retourne-1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToLowerInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
      <summary>Copie les caractères de l’étendue source dans la destination en convertissant chaque caractère en minuscules, à l’aide des règles de casse de la culture invariante.</summary>
      <param name="source">Étendue source.</param>
      <param name="destination">Étendue de destination qui contient les caractères transformés.</param>
      <exception cref="T:System.InvalidOperationException">Les mémoires tampon source et de destination se chevauchent.</exception>
      <returns>Nombre de caractères écrits dans l’étendue de destination. Si la destination est trop petite, retourne-1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToUpper(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
      <summary>Copie les caractères de l’étendue source dans la destination en convertissant chaque caractère en majuscules, à l’aide des règles de casse de la culture spécifiée.</summary>
      <param name="source">Étendue source.</param>
      <param name="destination">Étendue de destination qui contient les caractères transformés.</param>
      <param name="culture">Objet qui fournit les règles de casse propres à la culture.</param>
      <exception cref="T:System.InvalidOperationException">Les mémoires tampon source et de destination se chevauchent.</exception>
      <returns>Nombre de caractères écrits dans l’étendue de destination. Si la destination est trop petite, retourne-1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToUpperInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
      <summary>Copie les caractères de l’étendue source dans la destination en convertissant chaque caractère en majuscules, à l’aide des règles de casse de la culture invariante.</summary>
      <param name="source">Étendue source.</param>
      <param name="destination">Étendue de destination qui contient les caractères transformés.</param>
      <exception cref="T:System.InvalidOperationException">Les mémoires tampon source et de destination se chevauchent.</exception>
      <returns>Nombre de caractères écrits dans l’étendue de destination. Si la destination est trop petite, retourne-1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.Memory{System.Char})">
      <summary>Supprime tous les espaces blancs de début et de fin d’une région de mémoire de caractères.</summary>
      <param name="memory">Mémoire source de laquelle les caractères sont supprimés.</param>
      <returns>Région de mémoire de caractères tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlyMemory{System.Char})">
      <summary>Supprime tous les espaces blancs de début et de fin d’une région de mémoire de caractères en lecture seule.</summary>
      <param name="memory">Mémoire source de laquelle les caractères sont supprimés.</param>
      <returns>Région de mémoire de caractères tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char})">
      <summary>Supprime tous les espaces blancs de début et de fin d’une étendue de caractères en lecture seule.</summary>
      <param name="span">Étendue source de laquelle les caractères sont supprimés.</param>
      <returns>Étendue de caractères en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.Char)">
      <summary>Supprime d’une étendue de caractères en lecture seule toutes les occurrences de début et de fin d’un caractère spécifié.</summary>
      <param name="span">Étendue source de laquelle le caractère est supprimé.</param>
      <param name="trimChar">Caractère spécifié à rechercher et à supprimer.</param>
      <returns>Étendue de caractères en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>Supprime d’une étendue de caractères en lecture seule toutes les occurrences de début et de fin d’un jeu de caractères spécifié dans une étendue en lecture seule.</summary>
      <param name="span">Étendue source de laquelle les caractères sont supprimés.</param>
      <param name="trimChars">Étendue qui contient le jeu de caractères à supprimer.</param>
      <returns>Étendue de caractères en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.Span{System.Char})">
      <summary>Supprime tous les espaces blancs de début et de fin d’une étendue de caractères.</summary>
      <param name="span">Étendue source de laquelle les caractères sont supprimés.</param>
      <returns>Étendue de caractères tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Memory{``0},``0)">
      <summary>Supprime d’une région de mémoire toutes les occurrences de début et de fin d’un élément spécifié.</summary>
      <param name="memory">Mémoire source de laquelle l’élément est supprimé.</param>
      <param name="trimElement">Élément spécifié à rechercher et à supprimer.</param>
      <typeparam name="T">Type des éléments dans la région de la mémoire.</typeparam>
      <returns>Région de mémoire tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary>Supprime d’une région de mémoire toutes les occurrences de début et de fin d’un jeu d’éléments spécifié dans une étendue en lecture seule.</summary>
      <param name="memory">Mémoire source de laquelle les éléments sont supprimés.</param>
      <param name="trimElements">Étendue qui contient le jeu d’éléments à supprimer.</param>
      <typeparam name="T">Type des éléments dans la région de la mémoire.</typeparam>
      <returns>Région de mémoire tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},``0)">
      <summary>Supprime d’une région de mémoire en lecture seule toutes les occurrences de début et de fin d’un élément spécifié.</summary>
      <param name="memory">Mémoire source de laquelle l’élément est supprimé.</param>
      <param name="trimElement">Élément spécifié à rechercher et à supprimer.</param>
      <typeparam name="T">Type des éléments dans la zone de mémoire en lecture seule.</typeparam>
      <returns>Région de mémoire en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary>Supprime d’une région de mémoire en lecture seule toutes les occurrences de début et de fin d’un jeu d’éléments spécifié dans une étendue en lecture seule.</summary>
      <param name="memory">Mémoire source de laquelle les éléments sont supprimés.</param>
      <param name="trimElements">Étendue qui contient le jeu d’éléments à supprimer.</param>
      <typeparam name="T">Type des éléments dans la zone de mémoire en lecture seule.</typeparam>
      <returns>Région de mémoire en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},``0)">
      <summary>Supprime toutes les occurrences de début et de fin d’un élément spécifié d’une étendue en lecture seule.</summary>
      <param name="span">Étendue source de laquelle l’élément est supprimé.</param>
      <param name="trimElement">Élément spécifié à rechercher et à supprimer.</param>
      <typeparam name="T">Type des éléments de l’étendue en lecture seule.</typeparam>
      <returns>Étendue en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Supprime d’une étendue en lecture seule toutes les occurrences de début et de fin d’un jeu d’éléments spécifié dans une étendue en lecture seule.</summary>
      <param name="span">Étendue source de laquelle les éléments sont supprimés.</param>
      <param name="trimElements">Étendue qui contient le jeu d’éléments à supprimer.</param>
      <typeparam name="T">Type des éléments de l’étendue en lecture seule.</typeparam>
      <returns>Étendue en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Span{``0},``0)">
      <summary>Supprime d’une étendue toutes les occurrences de début et de fin d’un élément spécifié.</summary>
      <param name="span">Étendue source de laquelle l’élément est supprimé.</param>
      <param name="trimElement">Élément spécifié à rechercher et à supprimer.</param>
      <typeparam name="T">Type des éléments de l’étendue.</typeparam>
      <returns>Étendue tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Supprime d’une étendue toutes les occurrences de début et de fin d’un jeu d’éléments spécifié dans une étendue en lecture seule.</summary>
      <param name="span">Étendue source de laquelle les éléments sont supprimés.</param>
      <param name="trimElements">Étendue qui contient le jeu d’éléments à supprimer.</param>
      <typeparam name="T">Type des éléments de l’étendue.</typeparam>
      <returns>Étendue tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.Memory{System.Char})">
      <summary>Supprime tous les espaces blancs de fin d’une région de mémoire de caractères.</summary>
      <param name="memory">Mémoire source de laquelle les caractères sont supprimés.</param>
      <returns>Région de mémoire de caractères tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlyMemory{System.Char})">
      <summary>Supprime tous les espaces blancs de fin d’une région de mémoire de caractères en lecture seule.</summary>
      <param name="memory">Mémoire source de laquelle les caractères sont supprimés.</param>
      <returns>Étendue de caractères en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char})">
      <summary>Supprime tous les espaces blancs de fin d’une étendue de caractères en lecture seule.</summary>
      <param name="span">Étendue source de laquelle les caractères sont supprimés.</param>
      <returns>Étendue de caractères en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.Char)">
      <summary>Supprime toutes les occurrences de fin d’un caractère spécifié d’une étendue en lecture seule.</summary>
      <param name="span">Étendue source de laquelle le caractère est supprimé.</param>
      <param name="trimChar">Caractère spécifié à rechercher et à supprimer.</param>
      <returns>Étendue de caractères en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>Supprime d’une étendue de caractères en lecture seule toutes les occurrences de fin d’un jeu de caractères spécifié dans une étendue en lecture seule.</summary>
      <param name="span">Étendue source de laquelle les caractères sont supprimés.</param>
      <param name="trimChars">Étendue qui contient le jeu de caractères à supprimer.</param>
      <returns>Étendue de caractères en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.Span{System.Char})">
      <summary>Supprime tous les espaces blancs de fin d’une étendue de caractères.</summary>
      <param name="span">Étendue source de laquelle les caractères sont supprimés.</param>
      <returns>Étendue de caractères tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},``0)">
      <summary>Supprime d’une région de mémoire de caractères toutes les occurrences de fin d’un élément spécifié.</summary>
      <param name="memory">Mémoire source de laquelle l’élément est supprimé.</param>
      <param name="trimElement">Élément spécifié à rechercher et à supprimer.</param>
      <typeparam name="T">Type des éléments dans la région de la mémoire.</typeparam>
      <returns>Région de mémoire tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary>Supprime d’une région de mémoire toutes les occurrences de fin d’un jeu d’éléments spécifié dans une étendue en lecture seule.</summary>
      <param name="memory">Mémoire source de laquelle les éléments sont supprimés.</param>
      <param name="trimElements">Étendue qui contient le jeu d’éléments à supprimer.</param>
      <typeparam name="T">Type des éléments dans la région de la mémoire.</typeparam>
      <returns>Région de mémoire tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},``0)">
      <summary>Supprime d’une région de mémoire en lecture seule toutes les occurrences de fin d’un élément spécifié.</summary>
      <param name="memory">Mémoire source de laquelle l’élément est supprimé.</param>
      <param name="trimElement">Élément spécifié à rechercher et à supprimer.</param>
      <typeparam name="T">Type des éléments dans la zone de mémoire en lecture seule.</typeparam>
      <returns>Région de mémoire en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary>Supprime d’une région de mémoire en lecture seule toutes les occurrences de fin d’un jeu d’éléments spécifié dans une étendue en lecture seule.</summary>
      <param name="memory">Mémoire source de laquelle les éléments sont supprimés.</param>
      <param name="trimElements">Étendue qui contient le jeu d’éléments à supprimer.</param>
      <typeparam name="T">Type des éléments dans la zone de mémoire en lecture seule.</typeparam>
      <returns>Région de mémoire en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},``0)">
      <summary>Supprime d’une étendue en lecture seule toutes les occurrences de fin d’un élément spécifié.</summary>
      <param name="span">Étendue source de laquelle l’élément est supprimé.</param>
      <param name="trimElement">Élément spécifié à rechercher et à supprimer.</param>
      <typeparam name="T">Type des éléments de l’étendue en lecture seule.</typeparam>
      <returns>Étendue en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Supprime d’une étendue en lecture seule toutes les occurrences de fin d’un jeu d’éléments spécifié dans une étendue en lecture seule.</summary>
      <param name="span">Étendue source de laquelle les éléments sont supprimés.</param>
      <param name="trimElements">Étendue qui contient le jeu d’éléments à supprimer.</param>
      <typeparam name="T">Type des éléments de l’étendue en lecture seule.</typeparam>
      <returns>Étendue en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},``0)">
      <summary>Supprime d’une étendue toutes les occurrences de fin d’un élément spécifié.</summary>
      <param name="span">Étendue source de laquelle l’élément est supprimé.</param>
      <param name="trimElement">Élément spécifié à rechercher et à supprimer.</param>
      <typeparam name="T">Type des éléments de l’étendue.</typeparam>
      <returns>Étendue tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Supprime d’une étendue toutes les occurrences de fin d’un jeu d’éléments spécifié dans une étendue en lecture seule.</summary>
      <param name="span">Étendue source de laquelle les éléments sont supprimés.</param>
      <param name="trimElements">Étendue qui contient le jeu d’éléments à supprimer.</param>
      <typeparam name="T">Type des éléments de l’étendue.</typeparam>
      <returns>Étendue tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.Memory{System.Char})">
      <summary>Supprime tous les espaces blancs de début d’une région de mémoire.</summary>
      <param name="memory">Mémoire source de laquelle les caractères sont supprimés.</param>
      <returns>Région de mémoire de caractères tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlyMemory{System.Char})">
      <summary>Supprime tous les espaces blancs de début d’une région de mémoire en lecture seule.</summary>
      <param name="memory">Mémoire source de laquelle les caractères sont supprimés.</param>
      <returns>Région de mémoire de caractères en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char})">
      <summary>Supprime tous les espaces blancs de début d’une étendue en lecture seule.</summary>
      <param name="span">Étendue source de laquelle les caractères sont supprimés.</param>
      <returns>Étendue de caractères en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.Char)">
      <summary>Supprime de l’étendue toutes les occurrences de début d’un caractère spécifié.</summary>
      <param name="span">Étendue source de laquelle le caractère est supprimé.</param>
      <param name="trimChar">Caractère spécifié à rechercher et à supprimer.</param>
      <returns>Étendue de caractères en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>Supprime de l’étendue toutes les occurrences de début d’un jeu de caractères spécifiés dans une étendue en lecture seule.</summary>
      <param name="span">Étendue source de laquelle les caractères sont supprimés.</param>
      <param name="trimChars">Étendue qui contient le jeu de caractères à supprimer.</param>
      <returns>Étendue de caractères en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.Span{System.Char})">
      <summary>Supprime tous les espaces blancs de début d’une étendue.</summary>
      <param name="span">Étendue source de laquelle les caractères sont supprimés.</param>
      <returns>Étendue de caractères tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},``0)">
      <summary>Supprime d’une région de mémoire toutes les occurrences de début d’un élément spécifié.</summary>
      <param name="memory">Région de mémoire source de laquelle l’élément est supprimé.</param>
      <param name="trimElement">Élément spécifié à rechercher et à supprimer.</param>
      <typeparam name="T">Type des éléments dans la région de la mémoire.</typeparam>
      <returns>Région de mémoire tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary>Supprime d’une région de mémoire toutes les occurrences de début d’un jeu d’éléments spécifié dans une étendue en lecture seule.</summary>
      <param name="memory">Mémoire source de laquelle les éléments sont supprimés.</param>
      <param name="trimElements">Étendue qui contient le jeu d’éléments à supprimer.</param>
      <typeparam name="T">Type des éléments dans la région de la mémoire.</typeparam>
      <returns>Région de mémoire tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},``0)">
      <summary>Supprime d’une région de mémoire toutes les occurrences de début d’un élément spécifié.</summary>
      <param name="memory">Mémoire source de laquelle l’élément est supprimé.</param>
      <param name="trimElement">Élément spécifié à rechercher et à supprimer.</param>
      <typeparam name="T">Type des éléments dans la zone de mémoire en lecture seule.</typeparam>
      <returns>Région de mémoire en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary>Supprime d’une région de mémoire toutes les occurrences de début d’un jeu d’éléments spécifié dans une étendue en lecture seule.</summary>
      <param name="memory">Mémoire source de laquelle les éléments sont supprimés.</param>
      <param name="trimElements">Étendue qui contient le jeu d’éléments à supprimer.</param>
      <typeparam name="T">Type des éléments dans la zone de mémoire en lecture seule.</typeparam>
      <returns>Région de mémoire en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},``0)">
      <summary>Supprime de l’étendue toutes les occurrences de début d’un élément spécifié.</summary>
      <param name="span">Étendue source de laquelle l’élément est supprimé.</param>
      <param name="trimElement">Élément spécifié à rechercher et à supprimer.</param>
      <typeparam name="T">Type des éléments de l’étendue en lecture seule.</typeparam>
      <returns>Étendue en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Supprime d’une étendue toutes les occurrences de début d’un jeu d’éléments spécifié dans une étendue en lecture seule.</summary>
      <param name="span">Étendue source de laquelle les éléments sont supprimés.</param>
      <param name="trimElements">Étendue qui contient le jeu d’éléments à supprimer.</param>
      <typeparam name="T">Type des éléments de l’étendue en lecture seule.</typeparam>
      <returns>Étendue en lecture seule tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},``0)">
      <summary>Supprime de l’étendue toutes les occurrences de début d’un élément spécifié.</summary>
      <param name="span">Étendue source de laquelle l’élément est supprimé.</param>
      <param name="trimElement">Élément spécifié à rechercher et à supprimer.</param>
      <typeparam name="T">Type des éléments de l’étendue.</typeparam>
      <returns>Étendue tronquée.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Supprime d’une étendue toutes les occurrences de début d’un jeu d’éléments spécifié dans une étendue en lecture seule.</summary>
      <param name="span">Étendue source de laquelle les éléments sont supprimés.</param>
      <param name="trimElements">Étendue qui contient le jeu d’éléments à supprimer.</param>
      <typeparam name="T">Type des éléments de l’étendue.</typeparam>
      <returns>Étendue tronquée.</returns>
    </member>
    <member name="T:System.Runtime.InteropServices.MemoryMarshal">
      <summary>Fournit des méthodes pour interagir avec <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />, <see cref="T:System.Span`1" /> et <see cref="T:System.ReadOnlySpan`1" />.</summary>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.ReadOnlySpan{``0})">
      <summary>Convertit un élément <see cref="T:System.ReadOnlySpan`1" /> d’un type primitif, <paramref name="T" />, en un élément <see langword="ReadOnlySpan&lt;Byte&gt;" />.</summary>
      <param name="span">Section source à convertir.</param>
      <typeparam name="T">Type des éléments de l’étendue en lecture seule.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> contient des références ou des pointeurs.</exception>
      <exception cref="T:System.OverflowException">La propriété <see cref="P:System.ReadOnlySpan`1.Length" /> du nouveau <see cref="T:System.ReadOnlySpan`1" /> dépasserait <see cref="F:System.Int32.MaxValue" /></exception>
      <returns>Étendue en lecture seule de type <see cref="T:System.Byte" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.Span{``0})">
      <summary>Convertit un élément <see cref="T:System.Span`1" /> d’un type primitif, <paramref name="T" />, en un élément <see langword="Span&lt;Byte&gt;" />.</summary>
      <param name="span">Section source à convertir.</param>
      <typeparam name="T">Type des éléments de l’étendue.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> contient des références ou des pointeurs.</exception>
      <exception cref="T:System.OverflowException">La propriété <see cref="P:System.Span`1.Length" /> du nouveau <see cref="T:System.Span`1" /> dépasserait <see cref="F:System.Int32.MaxValue" /></exception>
      <returns>Une étendue de type <see cref="T:System.Byte" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsMemory``1(System.ReadOnlyMemory{``0})">
      <summary>Crée une instance <see cref="T:System.Memory`1" /> à partir d'un élément <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <param name="memory">Mémoire tampon en lecture seule.</param>
      <typeparam name="T">Type des éléments dans la mémoire tampon en lecture seule.</typeparam>
      <returns>Bloc de mémoire représentant la même mémoire que <see cref="T:System.ReadOnlyMemory`1" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.ReadOnlySpan{System.Byte})">
      <summary>Réinterprète une étendue d’octets en lecture seule comme une référence en lecture seule à la structure de type <paramref name="T" />.</summary>
      <param name="span">L’étendue en lecture seule à réinterpréter.</param>
      <typeparam name="T">Type de la référence retournée.</typeparam>
      <returns>La référence en lecture seule à la structure de type <paramref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.Span{System.Byte})">
      <summary>Réinterprète une étendue d’octets comme une référence à la structure de type <paramref name="T" />.</summary>
      <param name="span">L’étendue à réinterpréter.</param>
      <typeparam name="T">Type de la référence retournée.</typeparam>
      <returns>La référence à la structure de type <paramref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.ReadOnlySpan{``0})">
      <summary>Convertit une étendue en lecture seule d’un type primitif en une étendue en lecture seule d’un autre type primitif.</summary>
      <param name="span">Section source à convertir.</param>
      <typeparam name="TFrom">Type de l’étendue source.</typeparam>
      <typeparam name="TTo">Type de l’étendue cible.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="TFrom" /> ou <paramref name="TTo" /> contient des références ou des pointeurs.</exception>
      <returns>Étendue convertie en lecture seule.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.Span{``0})">
      <summary>Convertit une étendue d’un type primitif en une étendue d’un autre type primitif.</summary>
      <param name="span">Section source à convertir.</param>
      <typeparam name="TFrom">Type de l’étendue source.</typeparam>
      <typeparam name="TTo">Type de l’étendue cible.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="TFrom" /> ou <paramref name="TTo" /> contient des références ou des pointeurs.</exception>
      <returns>Étendue convertie.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateFromPinnedArray``1(``0[],System.Int32,System.Int32)">
      <summary>Crée une nouvelle mémoire tampon sur la partie du tableau cible déjà épinglé commençant à l’index <paramref name="start" /> et comprenant des éléments <paramref name="length" />.</summary>
      <param name="array">Tableau source préalablement épinglé.</param>
      <param name="start">Index de <paramref name="array" /> où commencer le bloc de mémoire.</param>
      <param name="length">Nombre d’éléments à inclure dans le bloc de mémoire.</param>
      <typeparam name="T">Type de tableau.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">La valeur <paramref name="array" /> est covariante et le type de <paramref name="array" /> n’est pas exactement <paramref name="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">La valeur <paramref name="start" /> ou l’index de fin n’est pas dans la plage de 0 à <see cref="P:System.Array.Length" />.</exception>
      <returns>Bloc de mémoire sur les éléments spécifiés de <paramref name="array" />. Si <paramref name="array" /> est <see langword="null" />, ou si <paramref name="start" /> et <paramref name="length" /> sont 0, la méthode retourne une instance <see cref="T:System.Memory`1" /> de <see cref="P:System.Memory`1.Length" /> égale à zéro.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan``1(``0@,System.Int32)">
      <summary>Crée une nouvelle étendue en lecture seule sur une partie d’un objet managé normal.</summary>
      <param name="reference">Référence à des données.</param>
      <param name="length">Nombre d'éléments <paramref name="T" /> que contient <paramref name="reference" />.</param>
      <typeparam name="T">Type des éléments de données.</typeparam>
      <returns>Étendue en lecture seule.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateSpan``1(``0@,System.Int32)">
      <summary>Crée une nouvelle étendue sur une partie d’un objet managé normal.</summary>
      <param name="reference">Référence à des données.</param>
      <param name="length">Nombre d'éléments <paramref name="T" /> que contient <paramref name="reference" />.</param>
      <typeparam name="T">Type des éléments de données.</typeparam>
      <returns>Étendue.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetArrayDataReference``1(``0[])">
      <summary>Retourne une référence de l’élément 0 de <paramref name="array" />. Si le tableau est vide, retourne une référence de l’emplacement où l’élément 0 aurait été stocké. Une telle référence peut être utilisée pour l’épinglage, mais elle ne doit jamais être déréférencée.</summary>
      <param name="array">Tableau à analyser.</param>
      <typeparam name="T">Type des éléments du tableau.</typeparam>
      <exception cref="T:System.NullReferenceException">
        <paramref name="array" /> a la valeur <see langword="null" />.</exception>
      <returns>Référence à l’élément 0 dans <paramref name="array" /></returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.ReadOnlySpan{``0})">
      <summary>Retourne une référence à l’élément de l’étendue en lecture seule à l’index 0.</summary>
      <param name="span">Étendue en lecture seule à partir de laquelle la référence est extraite.</param>
      <typeparam name="T">Type des éléments de l’étendue.</typeparam>
      <returns>Référence à l'élément à l’index 0.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.Span{``0})">
      <summary>Retourne une référence à l’élément de l’étendue à l’index 0.</summary>
      <param name="span">Étendue en lecture seule à partir de laquelle la référence est récupérée.</param>
      <typeparam name="T">Type des éléments de l’étendue.</typeparam>
      <returns>Référence à l'élément à l’index 0.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Read``1(System.ReadOnlySpan{System.Byte})">
      <summary>Lit une structure de type <param name="T" /> en dehors d’une étendue d’octets en lecture seule.</summary>
      <param name="source">Étendue en lecture seule.</param>
      <typeparam name="T">Type de l’élément à récupérer à partir de l’étendue en lecture seule.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> contient des références ou des pointeurs.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> est plus petit que <paramref name="T" />.</exception>
      <returns>Structure récupérée à partir de l’étendue en lecture seule.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.ToEnumerable``1(System.ReadOnlyMemory{``0})">
      <summary>Crée une vue <see cref="T:System.Collections.Generic.IEnumerable`1" /> de la mémoire tampon en lecture seule donnée.</summary>
      <param name="memory">Mémoire tampon en lecture seule.</param>
      <typeparam name="T">Type des éléments dans la mémoire tampon en lecture seule.</typeparam>
      <returns>Vue énumérable de <paramref name="memory" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetArray``1(System.ReadOnlyMemory{``0},System.ArraySegment{``0}@)">
      <summary>Tente d’obtenir un segment de tableau à partir de la mémoire tampon sous-jacente. La valeur de retour indique si l'opération a réussi.</summary>
      <param name="memory">Mémoire tampon en lecture seule.</param>
      <param name="segment">Lorsque cette méthode est retournée, contient le segment de tableau récupéré à partir de la mémoire tampon en lecture seule sous-jacente. Si la méthode échoue, la méthode retourne un segment de tableau par défaut.</param>
      <typeparam name="T">Type des éléments dans la mémoire tampon en lecture seule.</typeparam>
      <returns>
        <see langword="true" /> si l'appel de méthode a réussi ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@)">
      <summary>Tente de récupérer un élément <see cref="T:System.Buffers.MemoryManager`1" /> à partir de la mémoire tampon en lecture seule sous-jacente.</summary>
      <param name="memory">Mémoire tampon en lecture seule pour laquelle obtenir le Gestionnaire de mémoire.</param>
      <param name="manager">Quand la méthode est retournée, gestionnaire de <paramref name="memory" />.</param>
      <typeparam name="T">Type des éléments dans la mémoire tampon en lecture seule.</typeparam>
      <typeparam name="TManager">Type du <see cref="T:System.Buffers.MemoryManager`1" /> à récupérer.</typeparam>
      <returns>
        <see langword="true" /> si la méthode a extrait le Gestionnaire de mémoire ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@,System.Int32@,System.Int32@)">
      <summary>Tente de récupérer un élément <see cref="T:System.Buffers.MemoryManager`1" />, un index de début et une longueur à partir de la mémoire tampon en lecture seule sous-jacente.</summary>
      <param name="memory">Mémoire tampon en lecture seule pour laquelle obtenir le Gestionnaire de mémoire.</param>
      <param name="manager">Quand la méthode est retournée, gestionnaire de <paramref name="memory" />.</param>
      <param name="start">Quand la méthode est retournée, offset à partir du début du <paramref name="manager" /> représenté par <paramref name="memory" />.</param>
      <param name="length">Quand la méthode est retournée, longueur du <paramref name="manager" /> représenté par <paramref name="memory" />.</param>
      <typeparam name="T">Type des éléments dans la mémoire tampon en lecture seule.</typeparam>
      <typeparam name="TManager">Type du <see cref="T:System.Buffers.MemoryManager`1" /> à récupérer.</typeparam>
      <returns>
        <see langword="true" /> si la méthode a réussi ; sinon <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetString(System.ReadOnlyMemory{System.Char},System.String@,System.Int32@,System.Int32@)">
      <summary>Tente d’obtenir la chaîne sous-jacente à partir d’un élément <see langword="System.ReadOnlyMemory&lt;Char&gt;" />.</summary>
      <param name="memory">Mémoire en lecture seule contenant un bloc de caractères.</param>
      <param name="text">Lorsque la méthode est retournée, la chaîne contenue dans la mémoire tampon.</param>
      <param name="start">Emplacement de départ dans <paramref name="text" />.</param>
      <param name="length">Nombre de caractères dans <paramref name="text" />.</param>
      <returns>
        <see langword="true" /> si la méthode a réussi à récupérer la chaîne sous-jacente ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryRead``1(System.ReadOnlySpan{System.Byte},``0@)">
      <summary>Tente de lire une structure de type <paramref name="T" /> à partir d’une étendue d’octets en lecture seule.</summary>
      <param name="source">Étendue d’octets en lecture seule.</param>
      <param name="value">Quand la méthode est retournée, instance de <paramref name="T" />.</param>
      <typeparam name="T">Type de la structure à récupérer.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> contient des références ou des pointeurs.</exception>
      <returns>
        <see langword="true" /> si la méthode réussit lors de l’extraction d’une instance de la structure ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryWrite``1(System.Span{System.Byte},``0@)">
      <summary>Tente d’écrire une structure de type <paramref name="T" /> dans une étendue d’octets.</summary>
      <param name="destination">Étendue d’octets contenant la structure.</param>
      <param name="value">Structure à écrire dans l’étendue.</param>
      <typeparam name="T">Type de la structure.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> contient des références ou des pointeurs.</exception>
      <returns>
        <see langword="true" /> si l'opération d’écriture a abouti ; sinon <see langword="false" />. La méthode retourne <see langword="false" /> si l’étendue est trop petite pour contenir <paramref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Write``1(System.Span{System.Byte},``0@)">
      <summary>Écrit une structure de type <paramref name="T" /> dans une étendue d’octets.</summary>
      <param name="destination">Étendue d’octets contenant la structure.</param>
      <param name="value">Structure à écrire dans l’étendue.</param>
      <typeparam name="T">Type de la structure.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> contient des références ou des pointeurs.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> est trop petite pour contenir <paramref name="value" />.</exception>
    </member>
    <member name="T:System.Runtime.InteropServices.SequenceMarshal">
      <summary>Fournit une collection de méthodes pour l’interopérabilité avec <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetArray``1(System.Buffers.ReadOnlySequence{``0},System.ArraySegment{``0}@)">
      <summary>Obtient un segment de tableau à partir de la séquence en lecture seule sous-jacente.</summary>
      <param name="sequence">Séquence en lecture seule à partir de laquelle le segment de tableau sera récupéré.</param>
      <param name="segment">Segment de tableau retourné.</param>
      <typeparam name="T">Type de la séquence en lecture seule.</typeparam>
      <returns>
        <see langword="true" /> s’il est possible de récupérer le segment de tableau ; sinon, <see langword="false" /> et un segment de tableau par défaut est retourné.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlyMemory``1(System.Buffers.ReadOnlySequence{``0},System.ReadOnlyMemory{``0}@)">
      <summary>Tente de récupérer une mémoire en lecture seule à partir de la séquence en lecture seule spécifiée.</summary>
      <param name="sequence">Séquence en lecture seule à partir de laquelle la mémoire sera récupérée.</param>
      <param name="memory">Mémoire en lecture seule retournée de type T.</param>
      <typeparam name="T">Type de la séquence en lecture seule.</typeparam>
      <returns>
        <see langword="true" /> si la mémoire en lecture seule peut être récupérée ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlySequenceSegment``1(System.Buffers.ReadOnlySequence{``0},System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@,System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@)">
      <summary>Tente de récupérer un segment de séquence en lecture seule à partir de la séquence en lecture seule spécifiée.</summary>
      <param name="sequence">Séquence en lecture seule à partir de laquelle le segment de séquence en lecture seule sera récupéré.</param>
      <param name="startSegment">Segment de séquence en lecture seule de début.</param>
      <param name="startIndex">Position initiale.</param>
      <param name="endSegment">Segment de séquence en lecture seule de fin.</param>
      <param name="endIndex">Position finale.</param>
      <typeparam name="T">Type de la séquence en lecture seule.</typeparam>
      <returns>
        <see langword="true" /> si le segment de séquence en lecture seule peut être récupéré ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryRead``1(System.Buffers.SequenceReader{System.Byte}@,``0@)">
      <summary>Tente de lire le type spécifié à partir de la mémoire tampon. Il est dangereux d’utiliser cette méthode avec des structs arbitraires. Pour plus d’informations, consultez la section Notes.</summary>
      <param name="reader">Référence au lecteur de séquence.</param>
      <param name="value">Valeur retournée si la lecture a réussi. <paramref name="value" /> est <see langword="default" /> en cas d’échec (en raison d’un manque d’espace).</param>
      <typeparam name="T">Type de la valeur.</typeparam>
      <returns>
        <see langword="true" /> si la tentative de lecture a réussi ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="T:System.SequencePosition">
      <summary>Représente une position dans un jeu de mémoire non contigu. Les propriétés de ce type doivent uniquement être interprétées par le type qui les a créées.</summary>
    </member>
    <member name="M:System.SequencePosition.#ctor(System.Object,System.Int32)">
      <summary>Initialise une nouvelle instance du struct <see cref="T:System.SequencePosition" />.</summary>
      <param name="object">Ensemble de mémoire non contigu.</param>
      <param name="integer">Position dans <paramref name="object" />.</param>
    </member>
    <member name="M:System.SequencePosition.Equals(System.Object)">
      <summary>Retourne une valeur qui indique si l’instance actuelle est égale à un autre objet.</summary>
      <param name="obj">Objet à comparer à l’instance actuelle.</param>
      <returns>
        <see langword="true" /> si <paramref name="obj" /> est de type <see cref="T:System.SequencePosition" /> et s’il est égal à l’instance actuelle ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.SequencePosition.Equals(System.SequencePosition)">
      <summary>Indique si l’instance actuelle est égale à un autre <see cref="T:System.SequencePosition" />.</summary>
      <param name="other">Position de séquence à comparer à l’instance actuelle.</param>
      <returns>
        <see langword="true" /> si les deux instances sont égales ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.SequencePosition.GetHashCode">
      <summary>Retourne le code de hachage de cette instance.</summary>
      <returns>Code de hachage de cette instance.</returns>
    </member>
    <member name="M:System.SequencePosition.GetInteger">
      <summary>Retourne la partie entière de cette <see cref="T:System.SequencePosition" />.</summary>
      <returns>Partie entière de la position de séquence.</returns>
    </member>
    <member name="M:System.SequencePosition.GetObject">
      <summary>Retourne la partie objet de cette <see cref="T:System.SequencePosition" />.</summary>
      <returns>Partie objet de la position de séquence.</returns>
    </member>
    <member name="T:System.Text.EncodingExtensions">
      <summary>Fournit des méthodes d’extension pour les types d’encodage, tels que <see cref="T:System.Text.Encoding" />, <see cref="T:System.Text.Encoder" />et <see cref="T:System.Text.Decoder" />.</summary>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Decoder,System.Buffers.ReadOnlySequence{System.Byte}@,System.Buffers.IBufferWriter{System.Char},System.Boolean,System.Int64@,System.Boolean@)">
      <summary>Convertit un <see cref="T:System.Buffers.ReadOnlySequence`1" /> en caractères encodés UTF-16 et écrit le résultat dans <paramref name="writer" />.</summary>
      <param name="decoder">Instance du décodeur qui peut convertir des octets en valeurs <see langword="char" />.</param>
      <param name="bytes">Séquence d’octets à décoder.</param>
      <param name="writer">Mémoire tampon dans laquelle les caractères décodés seront écrits.</param>
      <param name="flush">
        <see langword="true" /> pour indiquer qu’aucune autre donnée ne doit être convertie ; sinon, <see langword="false" />.</param>
      <param name="charsUsed">Lorsque cette méthode est retournée, contient le nombre de caractères qui ont été écrits dans <paramref name="writer" />.</param>
      <param name="completed">Lorsque cette méthode est retournée, contient <see langword="true" /> si <paramref name="decoder" /> ne contient pas d’état interne partiel ; sinon, <see langword="false" />.
Si <paramref name="flush" /> est <see langword="true" />, aura toujours la valeur <see langword="true" /> lorsque la méthode est retournée.</param>
      <exception cref="T:System.Text.DecoderFallbackException">
        <paramref name="bytes" /> contient des données qui ne peuvent pas être décodées, et <paramref name="decoder" /> est configuré pour être déclenché lorsque ce genre de données est rencontré.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Decoder,System.ReadOnlySpan{System.Byte},System.Buffers.IBufferWriter{System.Char},System.Boolean,System.Int64@,System.Boolean@)">
      <summary>Convertit un <see cref="T:System.ReadOnlySpan`1" /> en caractères à l’aide de <paramref name="decoder" /> et écrit le résultat dans <paramref name="writer" />.</summary>
      <param name="decoder">Instance du décodeur qui peut convertir des octets en valeurs <see langword="char" />.</param>
      <param name="bytes">Séquence d’octets à décoder.</param>
      <param name="writer">Mémoire tampon dans laquelle les caractères décodés seront écrits.</param>
      <param name="flush">
        <see langword="true" /> pour indiquer qu’aucune autre donnée ne doit être convertie ; sinon, <see langword="false" />.</param>
      <param name="charsUsed">Lorsque cette méthode est retournée, contient le nombre de <see langword="char" /> qui ont été écrits dans <paramref name="writer" />.</param>
      <param name="completed">Lorsque cette méthode est retournée, contient <see langword="true" /> si <paramref name="decoder" /> ne contient pas d’état interne partiel ; sinon, <see langword="false" />.
Si <paramref name="flush" /> est <see langword="true" />, aura toujours la valeur <see langword="true" /> lorsque la méthode est retournée.</param>
      <exception cref="T:System.Text.DecoderFallbackException">
        <paramref name="bytes" /> contient des données qui ne peuvent pas être encodées, et <paramref name="decoder" /> est configuré pour être déclenché lorsque ce genre de données est rencontré.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Encoder,System.Buffers.ReadOnlySequence{System.Char}@,System.Buffers.IBufferWriter{System.Byte},System.Boolean,System.Int64@,System.Boolean@)">
      <summary>Convertit <see cref="T:System.Buffers.ReadOnlySequence`1" /> en octets encodés et écrit le résultat dans <paramref name="writer" />.</summary>
      <param name="encoder">Instance de l’encodeur qui peut convertir des valeurs <see langword="char" /> en octets.</param>
      <param name="chars">Séquence de caractères à encoder.</param>
      <param name="writer">Mémoire tampon dans laquelle les octets encodés seront écrits.</param>
      <param name="flush">
        <see langword="true" /> pour indiquer qu’aucune autre donnée ne doit être convertie ; sinon, <see langword="false" />.</param>
      <param name="bytesUsed">Lorsque cette méthode est retournée, contient le nombre de <see langword="byte" /> qui ont été écrits dans <paramref name="writer" />.</param>
      <param name="completed">Lorsque cette méthode est retournée, contient <see langword="true" /> si toute l’entrée jusqu’à <paramref name="bytesUsed" /> a été convertie ; sinon, <see langword="false" />. Si <paramref name="flush" /> est <see langword="true" />, aura toujours la valeur <see langword="true" /> lorsque la méthode est retournée.</param>
      <exception cref="T:System.Text.EncoderFallbackException">
        <paramref name="chars" /> contient des données qui ne peuvent pas être encodées, et <paramref name="encoder" /> est configuré pour être déclenché lorsque ce genre de données est rencontré.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Encoder,System.ReadOnlySpan{System.Char},System.Buffers.IBufferWriter{System.Byte},System.Boolean,System.Int64@,System.Boolean@)">
      <summary>Convertit un <see cref="T:System.ReadOnlySpan`1" /> en octets à l’aide de <paramref name="encoder" /> et écrit le résultat dans <paramref name="writer" />.</summary>
      <param name="encoder">Instance de l’encodeur qui peut convertir des valeurs <see langword="char" /> en octets.</param>
      <param name="chars">Séquence de caractères à encoder.</param>
      <param name="writer">Mémoire tampon dans laquelle les octets encodés seront écrits.</param>
      <param name="flush">
        <see langword="true" /> pour indiquer qu’aucune autre donnée ne doit être convertie ; sinon, <see langword="false" />.</param>
      <param name="bytesUsed">Lorsque cette méthode est retournée, contient le nombre de <see langword="byte" /> qui ont été écrits dans <paramref name="writer" />.</param>
      <param name="completed">Lorsque cette méthode est retournée, contient <see langword="true" /> si <paramref name="encoder" /> ne contient pas d’état interne partiel ; sinon, <see langword="false" />.
Si <paramref name="flush" /> est <see langword="true" />, aura toujours la valeur <see langword="true" /> lorsque la méthode est retournée.</param>
      <exception cref="T:System.Text.EncoderFallbackException">
        <paramref name="chars" /> contient des données qui ne peuvent pas être encodées, et <paramref name="encoder" /> est configuré pour être déclenché lorsque ce genre de données est rencontré.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Char}@)">
      <summary>Encode le <see cref="T:System.Buffers.ReadOnlySequence`1" /> spécifié dans un tableau <see cref="T:System.Byte" /> à l’aide du <see cref="T:System.Text.Encoding" /> spécifié.</summary>
      <param name="encoding">Encodage qui représente la façon dont les données dans <paramref name="chars" /> doivent être encodées.</param>
      <param name="chars">Séquence à encoder en octets.</param>
      <exception cref="T:System.Text.EncoderFallbackException">
        <paramref name="chars" /> contient des données qui ne peuvent pas être encodées, et <paramref name="encoding" /> est configuré pour être déclenché lorsque ce genre de données est rencontré.</exception>
      <returns>Tableau <see cref="T:System.Byte" /> qui représente le contenu encodé de <paramref name="chars" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Char}@,System.Buffers.IBufferWriter{System.Byte})">
      <summary>Décode le <see cref="T:System.Buffers.ReadOnlySequence`1" /> spécifié en <see langword="byte" />s à l’aide du <see cref="T:System.Text.Encoding" /> spécifié et écrit le résultat dans <paramref name="writer" />.</summary>
      <param name="encoding">Encodage qui représente la façon dont les données dans <paramref name="chars" /> doivent être encodées.</param>
      <param name="chars">
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> dont le contenu doit être encodé.</param>
      <param name="writer">Mémoire tampon dans laquelle les octets encodés seront écrits.</param>
      <exception cref="T:System.Text.EncoderFallbackException">
        <paramref name="chars" /> contient des données qui ne peuvent pas être encodées, et <paramref name="encoding" /> est configuré pour être déclenché lorsque ce genre de données est rencontré.</exception>
      <returns>Nombre d’octets écrits dans <paramref name="writer" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Char}@,System.Span{System.Byte})">
      <summary>Encode le <see cref="T:System.Buffers.ReadOnlySequence`1" /> spécifié en <see langword="byte" />s à l’aide du <see cref="T:System.Text.Encoding" /> spécifié et génère le résultat dans <paramref name="bytes" />.</summary>
      <param name="encoding">Encodage qui représente la façon dont les données dans <paramref name="chars" /> doivent être encodées.</param>
      <param name="chars">Séquence à encoder en octets.</param>
      <param name="bytes">Mémoire tampon de destination dans laquelle les octets encodés seront écrits.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="bytes" /> n’est pas assez grand pour contenir la forme encodée de <paramref name="chars" />.</exception>
      <exception cref="T:System.Text.EncoderFallbackException">
        <paramref name="chars" /> contient des données qui ne peuvent pas être encodées, et <paramref name="encoding" /> est configuré pour être déclenché lorsque ce genre de données est rencontré.</exception>
      <returns>Nombre d’octets écrits dans <paramref name="bytes" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.ReadOnlySpan{System.Char},System.Buffers.IBufferWriter{System.Byte})">
      <summary>Encode le <see cref="T:System.ReadOnlySpan`1" /> spécifié en <see langword="byte" />s à l’aide du <see cref="T:System.Text.Encoding" /> spécifié et écrit le résultat dans <paramref name="writer" />.</summary>
      <param name="encoding">Encodage qui représente la façon dont les données dans <paramref name="chars" /> doivent être encodées.</param>
      <param name="chars">Séquence à encoder en octets.</param>
      <param name="writer">Mémoire tampon dans laquelle les octets encodés seront écrits.</param>
      <exception cref="T:System.Text.EncoderFallbackException">
        <paramref name="chars" /> contient des données qui ne peuvent pas être encodées, et <paramref name="encoding" /> est configuré pour être déclenché lorsque ce genre de données est rencontré.</exception>
      <returns>Nombre d’octets écrits dans <paramref name="writer" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetChars(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Byte}@,System.Buffers.IBufferWriter{System.Char})">
      <summary>Décode le <see cref="T:System.Buffers.ReadOnlySequence`1" /> spécifié en <see langword="char" />s à l’aide du <see cref="T:System.Text.Encoding" /> spécifié et écrit le résultat dans <paramref name="writer" />.</summary>
      <param name="encoding">Encodage qui représente la façon dont les données dans <paramref name="bytes" /> doivent être décodées.</param>
      <param name="bytes">Séquence dont les octets doivent être décodés.</param>
      <param name="writer">Mémoire tampon dans laquelle les caractères décodés seront écrits.</param>
      <exception cref="T:System.Text.DecoderFallbackException">
        <paramref name="bytes" /> contient des données qui ne peuvent pas être décodées, et <paramref name="encoding" /> est configuré pour être déclenché lorsque ce genre de données est rencontré.</exception>
      <returns>Nombre de caractères écrits dans <paramref name="writer" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetChars(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Byte}@,System.Span{System.Char})">
      <summary>Décode le <see cref="T:System.Buffers.ReadOnlySequence`1" /> spécifié en <see langword="char" />s à l’aide du <see cref="T:System.Text.Encoding" /> spécifié et génère le résultat dans <paramref name="chars" />.</summary>
      <param name="encoding">Encodage qui représente la façon dont les données dans <paramref name="bytes" /> sont encodées.</param>
      <param name="bytes">Séquence à décoder en caractères.</param>
      <param name="chars">Mémoire tampon de destination dans laquelle les caractères décodés seront écrits.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="chars" /> n’est pas assez grand pour contenir la forme encodée de <paramref name="bytes" />.</exception>
      <exception cref="T:System.Text.DecoderFallbackException">
        <paramref name="bytes" /> contient des données qui ne peuvent pas être décodées, et <paramref name="encoding" /> est configuré pour être déclenché lorsque ce genre de données est rencontré.</exception>
      <returns>Nombre de caractères écrits dans <paramref name="chars" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetChars(System.Text.Encoding,System.ReadOnlySpan{System.Byte},System.Buffers.IBufferWriter{System.Char})">
      <summary>Décode le <see cref="T:System.ReadOnlySpan`1" /> spécifié en <see langword="char" />s à l’aide du <see cref="T:System.Text.Encoding" /> spécifié et écrit le résultat dans <paramref name="writer" />.</summary>
      <param name="encoding">Encodage qui représente la façon dont les données dans <paramref name="bytes" /> doivent être décodées.</param>
      <param name="bytes">Plage d’octets à décoder.</param>
      <param name="writer">Mémoire tampon dans laquelle les caractères décodés seront écrits.</param>
      <exception cref="T:System.Text.DecoderFallbackException">
        <paramref name="bytes" /> contient des données qui ne peuvent pas être décodées, et <paramref name="encoding" /> est configuré pour être déclenché lorsque ce genre de données est rencontré.</exception>
      <returns>Nombre de caractères écrits dans <paramref name="writer" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetString(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Byte}@)">
      <summary>Décode le <see cref="T:System.Buffers.ReadOnlySequence`1" /> spécifié en un <see cref="T:System.String" /> à l’aide du <see cref="T:System.Text.Encoding" /> spécifié.</summary>
      <param name="encoding">Encodage qui représente la façon dont les données dans <paramref name="bytes" /> sont encodées.</param>
      <param name="bytes">Séquence à décoder en caractères.</param>
      <exception cref="T:System.Text.DecoderFallbackException">
        <paramref name="bytes" /> contient des données qui ne peuvent pas être décodées, et <paramref name="encoding" /> est configuré pour être déclenché lorsque ce genre de données est rencontré.</exception>
      <returns>
        <see cref="T:System.String" /> qui représente le contenu décodé de <paramref name="bytes" />.</returns>
    </member>
    <member name="T:System.Text.SpanRuneEnumerator">
      <summary>Fournit un énumérateur pour les valeurs <see cref="T:System.Text.Rune" /> représentées par une étendue contenant du texte UTF-16.</summary>
    </member>
    <member name="M:System.Text.SpanRuneEnumerator.GetEnumerator">
      <summary>Retourne l’instance de l’énumérateur actuelle.</summary>
      <returns>Instance de l’énumérateur actuelle.</returns>
    </member>
    <member name="M:System.Text.SpanRuneEnumerator.MoveNext">
      <summary>Avance l’énumérateur au <see cref="T:System.Text.Rune" /> suivant de l’étendue.</summary>
      <returns>
        <see langword="true" /> si l’énumérateur a avancé jusqu’à l’élément suivant ; <see langword="false" /> si la fin de l’étendue a été atteinte.</returns>
    </member>
    <member name="P:System.Text.SpanRuneEnumerator.Current">
      <summary>Obtient le <see cref="T:System.Text.Rune" /> à la position actuelle de l'énumérateur.</summary>
      <returns>
        <see cref="T:System.Text.Rune" /> à la position actuelle de l'énumérateur.</returns>
    </member>
  </members>
</doc>