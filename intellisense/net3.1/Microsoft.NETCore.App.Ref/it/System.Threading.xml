<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Threading</name>
  </assembly>
  <members>
    <member name="T:System.Threading.AbandonedMutexException">
      <summary>Eccezione generata quando un thread acquisisce un oggetto <see cref="T:System.Threading.Mutex" /> che un altro thread ha abbandonato uscendo senza rilasciarlo.</summary>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.AbandonedMutexException" /> con i valori predefiniti.</summary>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.Int32,System.Threading.WaitHandle)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.AbandonedMutexException" /> con un indice specificato per il mutex abbandonato, se applicabile, e un oggetto <see cref="T:System.Threading.Mutex" /> che rappresenta il mutex.</summary>
      <param name="location">Indice del mutex abbandonato nella matrice degli handle di attesa se l'eccezione viene generata per il metodo <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> o-1 se l'eccezione viene generata per il metodo <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> oppure <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle">Oggetto <see cref="T:System.Threading.Mutex" /> che rappresenta il mutex abbandonato.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.AbandonedMutexException" /> con dati serializzati.</summary>
      <param name="info">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> che contiene i dati di oggetto serializzati relativi all'eccezione generata.</param>
      <param name="context">Oggetto <see cref="T:System.Runtime.Serialization.StreamingContext" /> contenente le informazioni contestuali sull'origine o sulla destinazione.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.AbandonedMutexException" /> con un messaggio di errore specificato.</summary>
      <param name="message">Messaggio di errore che spiega il motivo dell'eccezione.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.AbandonedMutexException" /> con il messaggio di errore e l'eccezione interna specificati.</summary>
      <param name="message">Messaggio di errore che spiega il motivo dell'eccezione.</param>
      <param name="inner">Eccezione che ha determinato l'eccezione corrente. Se il parametro <paramref name="inner" /> non è <see langword="null" />, l'eccezione corrente viene generata in un blocco <see langword="catch" /> in cui viene gestita l'eccezione interna.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception,System.Int32,System.Threading.WaitHandle)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.AbandonedMutexException" /> con il messaggio di errore, l'eccezione interna, l'indice per il mutex abbandonato, se applicabile, specificati e un oggetto <see cref="T:System.Threading.Mutex" /> che rappresenta il mutex.</summary>
      <param name="message">Messaggio di errore che spiega il motivo dell'eccezione.</param>
      <param name="inner">Eccezione che ha determinato l'eccezione corrente. Se il parametro <paramref name="inner" /> non è <see langword="null" />, l'eccezione corrente viene generata in un blocco <see langword="catch" /> in cui viene gestita l'eccezione interna.</param>
      <param name="location">Indice del mutex abbandonato nella matrice degli handle di attesa se l'eccezione viene generata per il metodo <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> o-1 se l'eccezione viene generata per il metodo <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> oppure <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle">Oggetto <see cref="T:System.Threading.Mutex" /> che rappresenta il mutex abbandonato.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Int32,System.Threading.WaitHandle)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.AbandonedMutexException" /> con il messaggio di errore, l'indice del mutex abbandonato, se applicabile, e il mutex abbandonato specificati.</summary>
      <param name="message">Messaggio di errore che spiega il motivo dell'eccezione.</param>
      <param name="location">Indice del mutex abbandonato nella matrice degli handle di attesa se l'eccezione viene generata per il metodo <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> o-1 se l'eccezione viene generata per il metodo <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> oppure <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle">Oggetto <see cref="T:System.Threading.Mutex" /> che rappresenta il mutex abbandonato.</param>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.Mutex">
      <summary>Ottiene il mutex abbandonato che ha causato l'eccezione, se noto.</summary>
      <returns>Oggetto <see cref="T:System.Threading.Mutex" /> che rappresenta il mutex abbandonato oppure <see langword="null" /> se il mutex abbandonato non è stato identificato.</returns>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.MutexIndex">
      <summary>Ottiene l'indice del mutex abbandonato che ha causato l'eccezione, se noto.</summary>
      <returns>Indice, nella matrice di handle di attesa passati al <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> metodo, <see cref="T:System.Threading.Mutex" /> dell'oggetto che rappresenta il mutex abbandonato oppure-1 se non è stato possibile determinare l'indice del mutex abbandonato.</returns>
    </member>
    <member name="T:System.Threading.AsyncFlowControl">
      <summary>Fornisce la funzionalità per ripristinare la migrazione, o flusso, del contesto di esecuzione fra thread.</summary>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Dispose">
      <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.AsyncFlowControl" />.</summary>
      <exception cref="T:System.InvalidOperationException">La struttura <see cref="T:System.Threading.AsyncFlowControl" /> non viene utilizzata sul thread in cui è stata creata.
In alternativa
La struttura <see cref="T:System.Threading.AsyncFlowControl" /> è già stata utilizzata per chiamare il metodo <see cref="M:System.Threading.AsyncFlowControl.Dispose" /> o <see cref="M:System.Threading.AsyncFlowControl.Undo" />.</exception>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Equals(System.Object)">
      <summary>Determina se l'oggetto specificato è uguale alla struttura <see cref="T:System.Threading.AsyncFlowControl" /> corrente.</summary>
      <param name="obj">Oggetto da confrontare con la struttura corrente.</param>
      <returns>
        <see langword="true" /> se <paramref name="obj" /> è una struttura <see cref="T:System.Threading.AsyncFlowControl" /> ed è uguale alla struttura <see cref="T:System.Threading.AsyncFlowControl" /> corrente; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Equals(System.Threading.AsyncFlowControl)">
      <summary>Determina se la struttura <see cref="T:System.Threading.AsyncFlowControl" /> specificata è uguale alla struttura <see cref="T:System.Threading.AsyncFlowControl" /> corrente.</summary>
      <param name="obj">Struttura <see cref="T:System.Threading.AsyncFlowControl" /> da confrontare con la struttura corrente.</param>
      <returns>
        <see langword="true" /> se <paramref name="obj" /> è uguale alla struttura <see cref="T:System.Threading.AsyncFlowControl" /> corrente; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.GetHashCode">
      <summary>Ottiene un codice hash per la struttura <see cref="T:System.Threading.AsyncFlowControl" /> corrente.</summary>
      <returns>Codice hash per la struttura <see cref="T:System.Threading.AsyncFlowControl" /> corrente.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.op_Equality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)">
      <summary>Confronta due strutture <see cref="T:System.Threading.AsyncFlowControl" /> per stabilire se sono uguali.</summary>
      <param name="a">Struttura <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <param name="b">Struttura <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <returns>
        <see langword="true" /> se le due strutture sono uguali; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.op_Inequality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)">
      <summary>Confronta due strutture <see cref="T:System.Threading.AsyncFlowControl" /> per stabilire se sono diverse.</summary>
      <param name="a">Struttura <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <param name="b">Struttura <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <returns>
        <see langword="true" /> se le strutture non sono uguali; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Undo">
      <summary>Ripristina il flusso del contesto di esecuzione fra i thread.</summary>
      <exception cref="T:System.InvalidOperationException">La struttura <see cref="T:System.Threading.AsyncFlowControl" /> non viene utilizzata sul thread in cui è stata creata.
-oppure-
La struttura <see cref="T:System.Threading.AsyncFlowControl" /> è già stata utilizzata per chiamare il metodo <see cref="M:System.Threading.AsyncFlowControl.Dispose" /> o <see cref="M:System.Threading.AsyncFlowControl.Undo" />.</exception>
    </member>
    <member name="T:System.Threading.AsyncLocal`1">
      <summary>Rappresenta dati di ambiente locali rispetto a un flusso di controllo asincrono specificato, ad esempio un metodo asincrono.</summary>
      <typeparam name="T">Tipo dei dati di ambiente.</typeparam>
    </member>
    <member name="M:System.Threading.AsyncLocal`1.#ctor">
      <summary>Crea un'istanza dell'istanza di <see cref="T:System.Threading.AsyncLocal`1" /> che non riceve notifiche di modifica.</summary>
    </member>
    <member name="M:System.Threading.AsyncLocal`1.#ctor(System.Action{System.Threading.AsyncLocalValueChangedArgs{`0}})">
      <summary>Crea un'istanza dell'istanza di <see cref="T:System.Threading.AsyncLocal`1" /> locale che riceve notifiche di modifica.</summary>
      <param name="valueChangedHandler">Delegato chiamato ogni volta che il valore corrente cambia in qualsiasi thread.</param>
    </member>
    <member name="P:System.Threading.AsyncLocal`1.Value">
      <summary>Ottiene o imposta il valore dei dati di ambiente.</summary>
      <returns>Valore dei dati di ambiente. Se non è stato impostato alcun valore, il valore restituito è <c>default (T)</c>.</returns>
    </member>
    <member name="T:System.Threading.AsyncLocalValueChangedArgs`1">
      <summary>Classe che fornisce le informazioni di modifica dei dati alle istanze di <see cref="T:System.Threading.AsyncLocal`1" /> registrate per le notifiche di modifica.</summary>
      <typeparam name="T">Tipo di dati.</typeparam>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.CurrentValue">
      <summary>Ottiene il valore corrente dei dati.</summary>
      <returns>Valore corrente dei dati.</returns>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.PreviousValue">
      <summary>Ottiene il valore precedente dei dati.</summary>
      <returns>Valore precedente dei dati.</returns>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.ThreadContextChanged">
      <summary>Restituisce un valore che indica se il valore cambia a seguito di una modifica del contesto di esecuzione.</summary>
      <returns>
        <see langword="true" />Se il valore è stato modificato a causa di una modifica del contesto di esecuzione. in caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="T:System.Threading.AutoResetEvent">
      <summary>Rappresenta un evento di sincronizzazione thread che viene reimpostato automaticamente quando viene segnalato, dopo avere rilasciato un singolo thread in attesa. Questa classe non può essere ereditata.</summary>
    </member>
    <member name="M:System.Threading.AutoResetEvent.#ctor(System.Boolean)">
      <summary>Consente l'inizializzazione di una nuova istanza della classe <see cref="T:System.Threading.AutoResetEvent" /> con un valore Booleano che indica se lo stato iniziale deve essere impostato su segnalato.</summary>
      <param name="initialState">
        <see langword="true" /> per impostare lo stato iniziale su segnalato; <see langword="false" /> per impostare lo stato iniziale su non segnalato.</param>
    </member>
    <member name="T:System.Threading.Barrier">
      <summary>Consente a più attività di funzionare in modo cooperativo in un algoritmo in parallelo tramite più fasi.</summary>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Barrier" />.</summary>
      <param name="participantCount">Numero di thread che partecipano.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="participantCount" /> è minore di 0 o maggiore di 32.767.</exception>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32,System.Action{System.Threading.Barrier})">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Barrier" />.</summary>
      <param name="participantCount">Numero di thread che partecipano.</param>
      <param name="postPhaseAction">Oggetto <see cref="T:System.Action`1" /> da eseguire dopo ogni fase. null (Nothing in Visual Basic) può essere passato per non indicare che non viene intrapresa alcuna azione.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="participantCount" /> è minore di 0 o maggiore di 32.767.</exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipant">
      <summary>Notifica all'oggetto <see cref="T:System.Threading.Barrier" /> che sarà presente un partecipante aggiuntivo.</summary>
      <returns>Numero di fase della barriera in corrispondenza di cui parteciperanno inizialmente i nuovi partecipanti.</returns>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.InvalidOperationException">L'aggiunta di un partecipante provocherebbe il superamento del conteggio del partecipante della barriera di 32.767.
-oppure-
Il metodo è stato richiamato dall'interno di un'azione post-fase.</exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipants(System.Int32)">
      <summary>Notifica all'oggetto <see cref="T:System.Threading.Barrier" /> che saranno presenti partecipanti aggiuntivi.</summary>
      <param name="participantCount">Numero di partecipanti aggiuntivi da aggiungere alla barriera.</param>
      <returns>Numero di fase della barriera in corrispondenza di cui parteciperanno inizialmente i nuovi partecipanti.</returns>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="participantCount" /> è minore di 0.
-oppure-
L'aggiunta di partecipanti <paramref name="participantCount" /> provocherebbe il superamento del conteggio del partecipante della barriera di 32.767.</exception>
      <exception cref="T:System.InvalidOperationException">Il metodo è stato richiamato dall'interno di un'azione post-fase.</exception>
    </member>
    <member name="P:System.Threading.Barrier.CurrentPhaseNumber">
      <summary>Ottiene il numero di fase corrente della barriera.</summary>
      <returns>Restituisce il numero di fase corrente della barriera.</returns>
    </member>
    <member name="M:System.Threading.Barrier.Dispose">
      <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.Barrier" />.</summary>
      <exception cref="T:System.InvalidOperationException">Il metodo è stato richiamato dall'interno di un'azione post-fase.</exception>
    </member>
    <member name="M:System.Threading.Barrier.Dispose(System.Boolean)">
      <summary>Rilascia le risorse non gestite usate dall'oggetto <see cref="T:System.Threading.Barrier" /> e, facoltativamente, le risorse gestite.</summary>
      <param name="disposing">True per rilasciare sia le risorse gestite sia quelle non gestite; false per rilasciare solo le risorse non gestite.</param>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantCount">
      <summary>Ottiene il numero totale di partecipanti nella barriera.</summary>
      <returns>Restituisce il numero totale di partecipanti nella barriera.</returns>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantsRemaining">
      <summary>Ottiene il numero di partecipanti nella barriera che non hanno ancora eseguito la segnalazione nella fase corrente.</summary>
      <returns>Restituisce il numero di partecipanti nella barriera che non hanno ancora segnalato nella fase corrente.</returns>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipant">
      <summary>Notifica all'oggetto <see cref="T:System.Threading.Barrier" /> che sarà presente un partecipante in meno.</summary>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.InvalidOperationException">La barriera dispone già di 0 partecipanti.
-oppure-
Il metodo è stato richiamato dall'interno di un'azione post-fase.</exception>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipants(System.Int32)">
      <summary>Notifica all'oggetto <see cref="T:System.Threading.Barrier" /> che saranno presenti meno partecipanti.</summary>
      <param name="participantCount">Numero di partecipanti aggiuntivi da rimuovere dalla barriera.</param>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Il conteggio totale dei partecipanti è minore del <paramref name="participantCount" /> specificato</exception>
      <exception cref="T:System.InvalidOperationException">La barriera dispone già di 0 partecipanti.
-oppure-
Il metodo è stato richiamato dall'interno di un'azione post-fase.
-oppure-
il conteggio del partecipante corrente è minore del conteggio del partecipante specificato</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait">
      <summary>Segnala che un partecipante ha raggiunto la barriera e attende che venga raggiunta anche da tutti gli altri partecipanti.</summary>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.InvalidOperationException">Il metodo viene richiamato dall'interno di un'azione post-fase, la barriera dispone attualmente di 0 partecipanti o la barriera viene segnalata da più thread registrati come partecipanti.</exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException">Se un'eccezione viene generata da un'azione post-fase di una Barriera dopo che tutti thread che partecipano hanno chiamato SignalAndWait, l'eccezione verrà sottoposta a wrapping in un BarrierPostPhaseException e sarà generata su tutti i thread che partecipano.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32)">
      <summary>Segnala che un partecipante ha raggiunto la barriera e attende che venga raggiunta anche da tutti gli altri partecipanti, utilizzando un Signed Integer a 32 bit per misurare il timeout.</summary>
      <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
      <returns>
        <see langword="true" /> se tutti i partecipanti raggiungono la barriera entro il tempo specificato; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
      <exception cref="T:System.InvalidOperationException">Il metodo viene richiamato dall'interno di un'azione post-fase, la barriera dispone attualmente di 0 partecipanti o la barriera viene segnalata da più thread registrati come partecipanti.</exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException">Se un'eccezione viene generata da un'azione post-fase di una Barriera dopo che tutti thread che partecipano hanno chiamato SignalAndWait, l'eccezione verrà sottoposta a wrapping in un BarrierPostPhaseException e sarà generata su tutti i thread che partecipano.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32,System.Threading.CancellationToken)">
      <summary>Segnala che un partecipante ha raggiunto la barriera e attende che venga raggiunta anche da tutti gli altri partecipanti, utilizzando un Signed Integer a 32 bit per misurare il timeout, al contempo osservando un token di annullamento.</summary>
      <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
      <param name="cancellationToken">Oggetto <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <returns>true se tutti i partecipanti raggiungono la barriera entro il tempo specificato; in caso contrario, false.</returns>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
      <exception cref="T:System.InvalidOperationException">Il metodo viene richiamato dall'interno di un'azione post-fase, la barriera dispone attualmente di 0 partecipanti o la barriera viene segnalata da più thread registrati come partecipanti.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Threading.CancellationToken)">
      <summary>Segnala che un partecipante ha raggiunto la barriera e attende che venga raggiunta anche da tutti gli altri partecipanti, al contempo osservando un token di annullamento.</summary>
      <param name="cancellationToken">Oggetto <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.InvalidOperationException">Il metodo viene richiamato dall'interno di un'azione post-fase, la barriera dispone attualmente di 0 partecipanti o la barriera viene segnalata da più thread registrati come partecipanti.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan)">
      <summary>Segnala che un partecipante ha raggiunto la barriera e attende che venga raggiunta anche da tutti gli altri partecipanti, utilizzando un oggetto <see cref="T:System.TimeSpan" /> per misurare l'intervallo di tempo.</summary>
      <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
      <returns>
        <see langword="true" /> se tutti gli altri partecipanti hanno raggiunto la barriera; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito, oppure è più grande di 32.767.</exception>
      <exception cref="T:System.InvalidOperationException">Il metodo viene richiamato dall'interno di un'azione post-fase, la barriera dispone attualmente di 0 partecipanti o la barriera viene segnalata da più thread registrati come partecipanti.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>Segnala che un partecipante ha raggiunto la barriera e attende che venga raggiunta anche da tutti gli altri partecipanti, utilizzando un oggetto <see cref="T:System.TimeSpan" /> per misurare l'intervallo di tempo, al contempo osservando un token di annullamento.</summary>
      <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
      <param name="cancellationToken">Oggetto <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <returns>
        <see langword="true" /> se tutti gli altri partecipanti hanno raggiunto la barriera; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito.</exception>
      <exception cref="T:System.InvalidOperationException">Il metodo viene richiamato dall'interno di un'azione post-fase, la barriera dispone attualmente di 0 partecipanti o la barriera viene segnalata da più thread registrati come partecipanti.</exception>
    </member>
    <member name="T:System.Threading.BarrierPostPhaseException">
      <summary>Eccezione generata quando l'azione post-fase di un oggetto <see cref="T:System.Threading.Barrier" /> non viene eseguita correttamente.</summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.BarrierPostPhaseException" /> con un messaggio fornito dal sistema in cui viene descritto l'errore.</summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Exception)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.BarrierPostPhaseException" /> con l'eccezione interna specificata.</summary>
      <param name="innerException">Eccezione che ha determinato l'eccezione corrente.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.BarrierPostPhaseException" /> con dati serializzati.</summary>
      <param name="info">Oggetto che contiene i dati oggetto serializzati.</param>
      <param name="context">Informazioni contestuali sull'origine o sulla destinazione.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.BarrierPostPhaseException" /> con un messaggio specificato in cui viene descritto l'errore.</summary>
      <param name="message">Messaggio in cui viene descritta l'eccezione. Il chiamante del costruttore deve garantire che la stringa sia stata localizzata in base alle impostazioni cultura correnti del sistema.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String,System.Exception)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.BarrierPostPhaseException" /> con un messaggio di errore specificato e un riferimento all'eccezione interna che è la causa dell'eccezione corrente.</summary>
      <param name="message">Messaggio in cui viene descritta l'eccezione. Il chiamante del costruttore deve garantire che la stringa sia stata localizzata in base alle impostazioni cultura correnti del sistema.</param>
      <param name="innerException">Eccezione che ha determinato l'eccezione corrente. Se il parametro <paramref name="innerException" /> non è <see langword="null" />, l'eccezione corrente viene generata in un blocco <see langword="catch" /> in cui viene gestita l'eccezione interna.</param>
    </member>
    <member name="T:System.Threading.ContextCallback">
      <summary>Rappresenta un metodo da chiamare all'interno di un nuovo contesto.</summary>
      <param name="state">Oggetto contenente informazioni che devono essere utilizzate dal metodo di callback ogni volta che viene eseguito.</param>
    </member>
    <member name="T:System.Threading.CountdownEvent">
      <summary>Rappresenta una primitiva di sincronizzazione segnalata quando il relativo conteggio raggiunge lo zero.</summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.#ctor(System.Int32)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.CountdownEvent" /> con il conteggio specificato.</summary>
      <param name="initialCount">Numero di segnali inizialmente richiesti per impostare l'oggetto <see cref="T:System.Threading.CountdownEvent" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="initialCount" /> è minore di 0.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount">
      <summary>Incrementa di uno il conteggio corrente di <see cref="T:System.Threading.CountdownEvent" />.</summary>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.InvalidOperationException">L'istanza corrente è già impostata.
-oppure-
<see cref="P:System.Threading.CountdownEvent.CurrentCount" /> è uguale a o maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount(System.Int32)">
      <summary>Incrementa di un valore specificato il conteggio corrente di <see cref="T:System.Threading.CountdownEvent" />.</summary>
      <param name="signalCount">Valore che indica l'incremento di <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</param>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signalCount" /> è minore o uguale a 0.</exception>
      <exception cref="T:System.InvalidOperationException">L'istanza corrente è già impostata.
-oppure-
<see cref="P:System.Threading.CountdownEvent.CurrentCount" /> è uguale o maggiore a <see cref="F:System.Int32.MaxValue" /> dopo che il conteggio è incrementato da <paramref name="signalCount." /></exception>
    </member>
    <member name="P:System.Threading.CountdownEvent.CurrentCount">
      <summary>Ottiene il numero di segnali restanti necessari per impostare l'evento.</summary>
      <returns>Numero di segnali restanti necessari per impostare l'evento.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose">
      <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.CountdownEvent" />.</summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose(System.Boolean)">
      <summary>Rilascia le risorse non gestite usate dall'oggetto <see cref="T:System.Threading.CountdownEvent" /> e, facoltativamente, le risorse gestite.</summary>
      <param name="disposing">True per rilasciare sia le risorse gestite sia quelle non gestite; false per rilasciare solo le risorse non gestite.</param>
    </member>
    <member name="P:System.Threading.CountdownEvent.InitialCount">
      <summary>Ottiene il numero di segnali necessari inizialmente per impostare l'evento.</summary>
      <returns>Numero di segnali necessari inizialmente per impostare l'evento.</returns>
    </member>
    <member name="P:System.Threading.CountdownEvent.IsSet">
      <summary>Indica se il conteggio corrente dell'oggetto <see cref="T:System.Threading.CountdownEvent" /> ha raggiunto lo zero.</summary>
      <returns>
        <see langword="true" /> se il conteggio corrente è zero. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset">
      <summary>Reimposta <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> sul valore di <see cref="P:System.Threading.CountdownEvent.InitialCount" />.</summary>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset(System.Int32)">
      <summary>Reimposta la proprietà <see cref="P:System.Threading.CountdownEvent.InitialCount" /> al valore specificato.</summary>
      <param name="count">Numero di segnali necessari per impostare l'oggetto <see cref="T:System.Threading.CountdownEvent" />.</param>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> è minore di 0.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal">
      <summary>Registra un segnale con l'oggetto <see cref="T:System.Threading.CountdownEvent" />, decrementando il valore di <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</summary>
      <returns>
        <see langword="true" /> se il conteggio ha raggiunto lo zero a causa del segnale e l'evento è stato impostato; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.InvalidOperationException">L'istanza corrente è già impostata.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal(System.Int32)">
      <summary>Registra più segnali con l'oggetto <see cref="T:System.Threading.CountdownEvent" />, decrementandone il valore di <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> della quantità specificata.</summary>
      <param name="signalCount">Numero di segnali da registrare.</param>
      <returns>
        <see langword="true" /> se il conteggio ha raggiunto lo zero a causa dei segnali e l'evento è stato impostato; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signalCount" /> è minore di 1.</exception>
      <exception cref="T:System.InvalidOperationException">L'istanza corrente è già impostata. oppure <paramref name="signalCount" /> è maggiore di <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount">
      <summary>Tenta di incrementare <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> di uno.</summary>
      <returns>
        <see langword="true" /> se l'incremento ha avuto esito positivo; in caso contrario, false. Se <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> è già zero, questo metodo restituirà <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> è uguale a <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount(System.Int32)">
      <summary>Tenta di incrementare <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> in base a un valore specificato.</summary>
      <param name="signalCount">Valore che indica l'incremento di <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</param>
      <returns>
        <see langword="true" /> se l'incremento ha avuto esito positivo; in caso contrario, false. Se <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> è già zero, verrà restituito <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signalCount" /> è minore o uguale a 0.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> + <paramref name="signalCount" /> è uguale a o maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait">
      <summary>Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.CountdownEvent" /> non viene impostato.</summary>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32)">
      <summary>Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.CountdownEvent" /> non viene impostato, utilizzando un intero con segno a 32 bit per misurare il timeout.</summary>
      <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
      <returns>
        <see langword="true" /> se l'oggetto <see cref="T:System.Threading.CountdownEvent" /> è stato impostato. In caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary>Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.CountdownEvent" /> non viene impostato, utilizzando un intero con segno a 32 bit per misurare il timeout e al contempo osservando un oggetto <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
      <param name="cancellationToken">Oggetto <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <returns>
        <see langword="true" /> se l'oggetto <see cref="T:System.Threading.CountdownEvent" /> è stato impostato. In caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata. oppure l'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> aveva creato <paramref name="cancellationToken" /> è già stato eliminato.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Threading.CancellationToken)">
      <summary>Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.CountdownEvent" /> non viene impostato, al contempo osservando un oggetto <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken">Oggetto <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata. oppure l'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> aveva creato <paramref name="cancellationToken" /> è già stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan)">
      <summary>Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.CountdownEvent" /> non viene impostato, utilizzando un oggetto <see cref="T:System.TimeSpan" /> per misurare il timeout.</summary>
      <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
      <returns>
        <see langword="true" /> se l'oggetto <see cref="T:System.Threading.CountdownEvent" /> è stato impostato. In caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi che rappresenta un timeout infinito - o - il timeout è più grande di <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.CountdownEvent" /> non viene impostato, utilizzando un oggetto <see cref="T:System.TimeSpan" /> per misurare il timeout e al contempo osservando un oggetto <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
      <param name="cancellationToken">Oggetto <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <returns>
        <see langword="true" /> se l'oggetto <see cref="T:System.Threading.CountdownEvent" /> è stato impostato. In caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata. oppure l'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> aveva creato <paramref name="cancellationToken" /> è già stato eliminato.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi che rappresenta un timeout infinito - o - il timeout è più grande di <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="P:System.Threading.CountdownEvent.WaitHandle">
      <summary>Ottiene un oggetto <see cref="T:System.Threading.WaitHandle" /> utilizzato per attendere l'impostazione dell'evento.</summary>
      <returns>Oggetto <see cref="T:System.Threading.WaitHandle" /> utilizzato per attendere l'impostazione dell'evento.</returns>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
    </member>
    <member name="T:System.Threading.EventResetMode">
      <summary>Indica se <see cref="T:System.Threading.EventWaitHandle" /> verrà reimpostato automaticamente o manualmente dopo la ricezione di un segnale.</summary>
    </member>
    <member name="F:System.Threading.EventResetMode.AutoReset">
      <summary>Con la segnalazione, <see cref="T:System.Threading.EventWaitHandle" /> viene reimpostato automaticamente dopo il rilascio di un singolo thread. Se non sono presenti thread in attesa, <see cref="T:System.Threading.EventWaitHandle" /> resta segnalato fino al blocco di un thread e viene reimpostato dopo il rilascio del thread.</summary>
    </member>
    <member name="F:System.Threading.EventResetMode.ManualReset">
      <summary>Con la segnalazione, <see cref="T:System.Threading.EventWaitHandle" /> rilascia tutti i thread in attesa e resta segnalato finché non viene reimpostato manualmente.</summary>
    </member>
    <member name="T:System.Threading.EventWaitHandle">
      <summary>Rappresenta un evento di sincronizzazione dei thread.</summary>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.EventWaitHandle" />, specificando se l'handle di attesa è inizialmente segnalato e se la reimpostazione viene eseguita automaticamente o manualmente.</summary>
      <param name="initialState">
        <see langword="true" /> per impostare lo stato iniziale su segnalato; <see langword="false" /> per impostarlo su non segnalato.</param>
      <param name="mode">Ottiene uno dei valori di <see cref="T:System.Threading.EventResetMode" /> che determina se l'evento viene reimpostato manualmente o automaticamente.</param>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.EventWaitHandle" />, specificando se l'handle di attesa è inizialmente segnalato se creato a seguito di questa chiamata e se la reimpostazione viene eseguita automaticamente o manualmente e indicando il nome di un evento di sincronizzazione di sistema.</summary>
      <param name="initialState">
        <see langword="true" /> per impostare lo stato iniziale su segnalato se l'evento denominato viene creato come risultato della chiamata; <see langword="false" /> per impostarlo su non segnalato.</param>
      <param name="mode">Ottiene uno dei valori di <see cref="T:System.Threading.EventResetMode" /> che determina se l'evento viene reimpostato manualmente o automaticamente.</param>
      <param name="name">Nome di un evento di sincronizzazione a livello di sistema.</param>
      <exception cref="T:System.IO.IOException">Errore Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">L'evento denominato esiste e include sicurezza del controllo di accesso, ma l'utente non ha <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">L'evento denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</exception>
      <exception cref="T:System.ArgumentException">La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.EventWaitHandle" />, che specifica se l'handle di attesa viene inizialmente segnalato se creato in seguito alla chiamata, se viene reimpostato automaticamente o manualmente, nonché il nome di un evento di sincronizzazione di sistema e una variabile Boolean il cui valore dopo la chiamata indica se è stato creato l'evento di sistema denominato.</summary>
      <param name="initialState">
        <see langword="true" /> per impostare lo stato iniziale su segnalato se l'evento denominato viene creato come risultato della chiamata; <see langword="false" /> per impostarlo su non segnalato.</param>
      <param name="mode">Ottiene uno dei valori di <see cref="T:System.Threading.EventResetMode" /> che determina se l'evento viene reimpostato manualmente o automaticamente.</param>
      <param name="name">Nome di un evento di sincronizzazione a livello di sistema.</param>
      <param name="createdNew">Quando questo metodo viene restituito, contiene <see langword="true" /> se è stato creato un evento locale (ovvero, se il valore di <paramref name="name" /> è <see langword="null" /> o una stringa vuota) oppure se è stato creato l'evento di sistema denominato specificato; <see langword="false" /> se l'evento di sistema denominato specificato è già esistente. Questo parametro viene passato non inizializzato.</param>
      <exception cref="T:System.IO.IOException">Errore Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">L'evento denominato esiste e include sicurezza del controllo di accesso, ma l'utente non ha <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">L'evento denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</exception>
      <exception cref="T:System.ArgumentException">La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
      <summary>Apre l'evento di sincronizzazione denominato specificato, se esistente.</summary>
      <param name="name">Nome dell'evento di sincronizzazione del sistema da aprire.</param>
      <returns>Oggetto che rappresenta l'evento di sistema denominato.</returns>
      <exception cref="T:System.ArgumentException">Il parametro <paramref name="name" /> è una stringa vuota.
-oppure-
La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> è <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">L'evento di sistema denominato non esiste.</exception>
      <exception cref="T:System.IO.IOException">Errore Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">L'evento denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per utilizzarlo.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Reset">
      <summary>Imposta lo stato dell'evento su non segnalato, provocando il blocco dei thread.</summary>
      <returns>
        <see langword="true" /> se l'operazione ha esito positivo; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">Il metodo <see cref="M:System.Threading.WaitHandle.Close" /> è già stato chiamato in precedenza su questo <see cref="T:System.Threading.EventWaitHandle" />.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Set">
      <summary>Imposta lo stato dell'evento su segnalato, per consentire a uno o più thread in attesa di procedere.</summary>
      <returns>
        <see langword="true" /> se l'operazione ha esito positivo; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">Il metodo <see cref="M:System.Threading.WaitHandle.Close" /> è già stato chiamato in precedenza su questo <see cref="T:System.Threading.EventWaitHandle" />.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
      <summary>Apre l'evento di sincronizzazione denominato specificato, se esistente, e restituisce un valore che indica se l'operazione è riuscita.</summary>
      <param name="name">Nome dell'evento di sincronizzazione del sistema da aprire.</param>
      <param name="result">Quando restituisce il controllo, questo metodo contiene un oggetto <see cref="T:System.Threading.EventWaitHandle" /> che rappresenta l'evento di sincronizzazione denominato se la chiamata è riuscita o <see langword="null" /> se la chiamata non è riuscita. Questo parametro viene trattato come non inizializzato.</param>
      <returns>
        <see langword="true" /> se l'evento di sincronizzazione denominato è stato aperto correttamente; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException">Il parametro <paramref name="name" /> è una stringa vuota.
-oppure-
La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> è <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException">Errore Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">L'evento denominato esiste, ma l'utente non dispone dell'accesso di sicurezza desiderato.</exception>
    </member>
    <member name="T:System.Threading.ExecutionContext">
      <summary>Gestisce il contesto di esecuzione per il thread corrente. Questa classe non può essere ereditata.</summary>
    </member>
    <member name="M:System.Threading.ExecutionContext.Capture">
      <summary>Acquisisce il contesto di esecuzione dal thread corrente.</summary>
      <returns>Oggetto <see cref="T:System.Threading.ExecutionContext" /> che rappresenta il contesto di esecuzione per il thread corrente.</returns>
    </member>
    <member name="M:System.Threading.ExecutionContext.CreateCopy">
      <summary>Crea una copia del contesto di esecuzione corrente.</summary>
      <returns>Oggetto <see cref="T:System.Threading.ExecutionContext" /> che rappresenta il contesto di esecuzione corrente.</returns>
      <exception cref="T:System.InvalidOperationException">Non è possibile copiare questo contesto perché è in uso. È possibile copiare solo i contesti acquisiti di recente.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.Dispose">
      <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.ExecutionContext" />.</summary>
    </member>
    <member name="M:System.Threading.ExecutionContext.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Imposta l'oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> specificato con le informazioni logiche sul contesto necessarie per ricreare un'istanza del contesto di esecuzione corrente.</summary>
      <param name="info">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> da completare con le informazioni di serializzazione.</param>
      <param name="context">Struttura <see cref="T:System.Runtime.Serialization.StreamingContext" /> che rappresenta il contesto di destinazione della serializzazione.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="info" /> costruito in modo predefinito è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.IsFlowSuppressed">
      <summary>Indica se il flusso del contesto di esecuzione attualmente è soppresso.</summary>
      <returns>
        <see langword="true" /> se il flusso è soppresso; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ExecutionContext.RestoreFlow">
      <summary>Ripristina il flusso del contesto di esecuzione fra thread asincroni.</summary>
      <exception cref="T:System.InvalidOperationException">Non è possibile ripristinare il flusso del contesto perché non verrà soppresso.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)">
      <summary>Esegue un metodo in un contesto di esecuzione specifico sul thread corrente.</summary>
      <param name="executionContext">Oggetto <see cref="T:System.Threading.ExecutionContext" /> da impostare.</param>
      <param name="callback">Delegato <see cref="T:System.Threading.ContextCallback" /> che rappresenta il metodo da eseguire nel contesto di esecuzione fornito.</param>
      <param name="state">Oggetto da passare al metodo di callback.</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="executionContext" /> costruito in modo predefinito è <see langword="null" />.
In alternativa
<paramref name="executionContext" /> non è stato acquisito tramite un'operazione di acquisizione.
-oppure-
<paramref name="executionContext" /> è stato già utilizzato come argomento per una chiamata <see cref="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)" />.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.SuppressFlow">
      <summary>Sopprime il flusso del contesto di esecuzione fra thread asincroni.</summary>
      <returns>Struttura <see cref="T:System.Threading.AsyncFlowControl" /> per il ripristino del flusso.</returns>
      <exception cref="T:System.InvalidOperationException">Il flusso del contesto è già soppresso.</exception>
    </member>
    <member name="T:System.Threading.HostExecutionContext">
      <summary>Incapsula e propaga il contesto di esecuzione host fra i thread.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.#ctor">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.HostExecutionContext" />.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.#ctor(System.Object)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.HostExecutionContext" /> con lo stato specificato.</summary>
      <param name="state">Oggetto che rappresenta lo stato del contesto di esecuzione dell'host.</param>
    </member>
    <member name="M:System.Threading.HostExecutionContext.CreateCopy">
      <summary>Crea una copia del contesto di esecuzione dell'host corrente.</summary>
      <returns>Oggetto <see cref="T:System.Threading.HostExecutionContext" /> che rappresenta il contesto dell'host per il thread corrente.</returns>
    </member>
    <member name="M:System.Threading.HostExecutionContext.Dispose">
      <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.HostExecutionContext" />.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.Dispose(System.Boolean)">
      <summary>Quando ne viene eseguito l'override in una classe derivata, libera le risorse non gestite usate da <see cref="T:System.Threading.WaitHandle" /> ed eventualmente di liberare le risorse gestite.</summary>
      <param name="disposing">
        <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite, <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
    </member>
    <member name="P:System.Threading.HostExecutionContext.State">
      <summary>Ottiene o imposta lo stato del contesto di esecuzione dell'host.</summary>
      <returns>Oggetto che rappresenta lo stato del contesto di esecuzione dell'host.</returns>
    </member>
    <member name="T:System.Threading.HostExecutionContextManager">
      <summary>Fornisce la funzionalità che consente a un host Common Language Runtime di partecipare al flusso, o migrazione, del contesto di esecuzione.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.#ctor">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.HostExecutionContextManager" />.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.Capture">
      <summary>Acquisisce il contesto di esecuzione dell'host dal thread corrente.</summary>
      <returns>Oggetto <see cref="T:System.Threading.HostExecutionContext" /> che rappresenta il contesto di esecuzione dell'host del thread corrente.</returns>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.Revert(System.Object)">
      <summary>Ripristina lo stato precedente del contesto di esecuzione dell'host.</summary>
      <param name="previousState">Stato precedente del contesto da ripristinare.</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="previousState" /> è <see langword="null" />.
In alternativa
<paramref name="previousState" /> non è stato creato sul thread corrente.
In alternativa
<paramref name="previousState" /> non è l'ultimo stato di <see cref="T:System.Threading.HostExecutionContext" />.</exception>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)">
      <summary>Imposta il contesto di esecuzione dell'host corrente sul contesto di esecuzione dell'host specificato.</summary>
      <param name="hostExecutionContext">Oggetto <see cref="T:System.Threading.HostExecutionContext" /> da impostare.</param>
      <returns>Oggetto per il ripristino dello stato precedente di <see cref="T:System.Threading.HostExecutionContext" />.</returns>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="hostExecutionContext" /> non è stato acquisito tramite un'operazione di acquisizione.
-oppure-
<paramref name="hostExecutionContext" /> è stato l'argomento di una chiamata al metodo <see cref="M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)" /> precedente.</exception>
    </member>
    <member name="T:System.Threading.Interlocked">
      <summary>Consente di eseguire operazioni atomiche per variabili condivise da più thread.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
      <summary>Aggiunge due Integer a 32 bit e sostituisce il primo con la somma, come operazione atomica.</summary>
      <param name="location1">Variabile contenente il primo valore da sommare. La somma dei due valori viene memorizzata in <paramref name="location1" />.</param>
      <param name="value">Valore da aggiungere all'integer in corrispondenza di <paramref name="location1" />.</param>
      <returns>Nuovo valore memorizzato in <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
      <summary>Aggiunge due Integer a 64 bit e sostituisce il primo con la somma, come operazione atomica.</summary>
      <param name="location1">Variabile contenente il primo valore da aggiungere. La somma dei due valori viene memorizzata in <paramref name="location1" />.</param>
      <param name="value">Valore da aggiungere all'integer in corrispondenza di <paramref name="location1" />.</param>
      <returns>Nuovo valore memorizzato in <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
      <summary>Confronta due numeri a virgola mobile e precisione doppia per verificarne l'uguaglianza; se sono uguali, sostituisce il primo valore.</summary>
      <param name="location1">Destinazione il cui valore viene confrontato con <paramref name="comparand" /> ed eventualmente sostituito.</param>
      <param name="value">Valore che sostituisce il valore di destinazione se il confronto rileva l'uguaglianza.</param>
      <param name="comparand">Valore confrontato con il valore in corrispondenza di <paramref name="location1" />.</param>
      <returns>Valore originale in <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
      <summary>Confronta due interi con segno a 32 bit per verificarne l'uguaglianza; se sono uguali, sostituisce il primo valore.</summary>
      <param name="location1">Destinazione il cui valore viene confrontato con <paramref name="comparand" /> ed eventualmente sostituito.</param>
      <param name="value">Valore che sostituisce il valore di destinazione se il confronto rileva l'uguaglianza.</param>
      <param name="comparand">Valore confrontato con il valore in corrispondenza di <paramref name="location1" />.</param>
      <returns>Valore originale in <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
      <summary>Confronta due interi con segno a 64 bit per verificarne l'uguaglianza; se sono uguali, sostituisce il primo valore.</summary>
      <param name="location1">Destinazione il cui valore viene confrontato con <paramref name="comparand" /> ed eventualmente sostituito.</param>
      <param name="value">Valore che sostituisce il valore di destinazione se il confronto rileva l'uguaglianza.</param>
      <param name="comparand">Valore confrontato con il valore in corrispondenza di <paramref name="location1" />.</param>
      <returns>Valore originale in <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
      <summary>Confronta due puntatori o handle specifici della piattaforma per verificarne l'uguaglianza. Se sono uguali, sostituisce il primo elemento.</summary>
      <param name="location1">
        <see cref="T:System.IntPtr" /> di destinazione, il cui valore viene confrontato con il valore di <paramref name="comparand" /> e, se possibile, sostituito da <paramref name="value" />.</param>
      <param name="value">
        <see cref="T:System.IntPtr" /> che sostituisce il valore di destinazione se il confronto rileva l'uguaglianza.</param>
      <param name="comparand">
        <see cref="T:System.IntPtr" /> da confrontare al valore in corrispondenza di <paramref name="location1" />.</param>
      <returns>Valore originale in <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
      <summary>Confronta due oggetti per verificarne l'uguaglianza dei riferimenti. Se sono uguali, sostituisce il primo oggetto.</summary>
      <param name="location1">Oggetto di destinazione confrontato per riferimento con <paramref name="comparand" /> ed eventualmente sostituito.</param>
      <param name="value">Oggetto che sostituisce l'oggetto di destinazione se il confronto dei riferimenti rileva l'uguaglianza.</param>
      <param name="comparand">Oggetto confrontato per riferimento con l'oggetto in <paramref name="location1" />.</param>
      <returns>Valore originale in <paramref name="location1" />.</returns>
      <exception cref="T:System.ArgumentNullException">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
      <summary>Confronta due numeri a virgola mobile e precisione singola per verificarne l'uguaglianza; se sono uguali, sostituisce il primo valore.</summary>
      <param name="location1">Destinazione il cui valore viene confrontato con <paramref name="comparand" /> ed eventualmente sostituito.</param>
      <param name="value">Valore che sostituisce il valore di destinazione se il confronto rileva l'uguaglianza.</param>
      <param name="comparand">Valore confrontato con il valore in corrispondenza di <paramref name="location1" />.</param>
      <returns>Valore originale in <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
      <summary>Confronta due istanze del tipo di riferimento <paramref name="T" /> specificato per verificarne l'uguaglianza dei riferimenti. Se sono uguali, sostituisce la prima istanza.</summary>
      <param name="location1">Destinazione il cui valore viene confrontato per riferimento con <paramref name="comparand" /> ed eventualmente sostituito. Questo rappresenta un parametro di riferimento (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</param>
      <param name="value">Valore che sostituisce il valore di destinazione se il confronto dei riferimenti rileva l'uguaglianza.</param>
      <param name="comparand">Valore confrontato per riferimento con il valore in <paramref name="location1" />.</param>
      <typeparam name="T">Tipo da utilizzare per <paramref name="location1" />, <paramref name="value" /> e <paramref name="comparand" />. Questo tipo deve essere un tipo di riferimento.</typeparam>
      <returns>Valore originale in <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int32@)">
      <summary>Consente di diminuire una variabile specificata e di memorizzarne il risultato, come operazione atomica.</summary>
      <param name="location">Variabile il cui valore deve essere diminuito.</param>
      <returns>Valore diminuito.</returns>
      <exception cref="T:System.ArgumentNullException">L'indirizzo di <paramref name="location" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int64@)">
      <summary>Consente di diminuire la variabile specificata e di memorizzare il risultato, come operazione atomica.</summary>
      <param name="location">Variabile il cui valore deve essere diminuito.</param>
      <returns>Valore diminuito.</returns>
      <exception cref="T:System.ArgumentNullException">L'indirizzo di <paramref name="location" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
      <summary>Imposta un numero in virgola mobile a precisione doppia su un valore specificato e restituisce il valore originale, come operazione atomica.</summary>
      <param name="location1">Variabile da impostare sul valore specificato.</param>
      <param name="value">Valore su cui è impostato il parametro <paramref name="location1" />.</param>
      <returns>Valore originale di <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
      <summary>Imposta un intero con segno a 32 bit su un valore specificato e restituisce il valore originale, come operazione atomica.</summary>
      <param name="location1">Variabile da impostare sul valore specificato.</param>
      <param name="value">Valore su cui è impostato il parametro <paramref name="location1" />.</param>
      <returns>Valore originale di <paramref name="location1" />.</returns>
      <exception cref="T:System.ArgumentNullException">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
      <summary>Imposta un intero con segno a 64 bit su un valore specificato e restituisce il valore originale, come operazione atomica.</summary>
      <param name="location1">Variabile da impostare sul valore specificato.</param>
      <param name="value">Valore su cui è impostato il parametro <paramref name="location1" />.</param>
      <returns>Valore originale di <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
      <summary>Imposta un puntatore o un handle specifico della piattaforma su un valore specificato e restituisce il valore originale, come operazione atomica.</summary>
      <param name="location1">Variabile da impostare sul valore specificato.</param>
      <param name="value">Valore su cui è impostato il parametro <paramref name="location1" />.</param>
      <returns>Valore originale di <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
      <summary>Imposta un oggetto su un valore specificato e restituisce un riferimento all'oggetto originale, come operazione atomica.</summary>
      <param name="location1">Variabile da impostare sul valore specificato.</param>
      <param name="value">Valore su cui è impostato il parametro <paramref name="location1" />.</param>
      <returns>Valore originale di <paramref name="location1" />.</returns>
      <exception cref="T:System.ArgumentNullException">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
      <summary>Imposta un numero in virgola mobile a precisione singola su un valore specificato e restituisce il valore originale, come operazione atomica.</summary>
      <param name="location1">Variabile da impostare sul valore specificato.</param>
      <param name="value">Valore su cui è impostato il parametro <paramref name="location1" />.</param>
      <returns>Valore originale di <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
      <summary>Imposta una variabile del tipo <paramref name="T" /> indicato sul valore specificato e restituisce il valore originale, come operazione atomica.</summary>
      <param name="location1">Variabile su cui impostare il valore specificato. Rappresenta un parametro di riferimento (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</param>
      <param name="value">Valore su cui è impostato il parametro <paramref name="location1" />.</param>
      <typeparam name="T">Tipo da utilizzare per <paramref name="location1" /> e <paramref name="value" />. Questo tipo deve essere un tipo di riferimento.</typeparam>
      <returns>Valore originale di <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.Int32@)">
      <summary>Aumenta una variabile specificata e archivia il risultato, come operazione atomica.</summary>
      <param name="location">Variabile il cui valore deve essere aumentato.</param>
      <returns>Valore aumentato.</returns>
      <exception cref="T:System.NullReferenceException">L'indirizzo di <paramref name="location" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.Int64@)">
      <summary>Aumenta una variabile specificata e archivia il risultato, come operazione atomica.</summary>
      <param name="location">Variabile il cui valore deve essere aumentato.</param>
      <returns>Valore aumentato.</returns>
      <exception cref="T:System.NullReferenceException">L'indirizzo di <paramref name="location" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.MemoryBarrier">
      <summary>Sincronizza l'accesso alla memoria nel modo seguente: il processore che esegue il thread corrente non può riordinare le istruzioni in modo tale che gli accessi alla memoria prima della chiamata a <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> vengano eseguiti dopo quelli successivi alla chiamata a <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.MemoryBarrierProcessWide">
      <summary>Offre una barriera di memoria estesa ai processi che assicura che le letture e le scritture da qualsiasi CPU non possano superare la barriera.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.Read(System.Int64@)">
      <summary>Restituisce un valore a 64 bit, caricato come operazione atomica.</summary>
      <param name="location">Valore a 64 bit da caricare.</param>
      <returns>Valore caricato.</returns>
    </member>
    <member name="T:System.Threading.LazyInitializer">
      <summary>Fornisce routine di inizializzazione differita.</summary>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
      <summary>Inizializza un tipo di riferimento di destinazione con il relativo costruttore senza parametri se non è già stato inizializzato.</summary>
      <param name="target">Riferimento da inizializzare se non è già stato inizializzato.</param>
      <typeparam name="T">Tipo del riferimento da inizializzare.</typeparam>
      <returns>Oggetto inizializzato.</returns>
      <exception cref="T:System.MemberAccessException">Le autorizzazioni per accedere al costruttore di tipo <paramref name="T" /> erano mancanti.</exception>
      <exception cref="T:System.MissingMemberException">Il tipo <paramref name="T" /> non dispone di un costruttore senza parametri.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
      <summary>Inizializza un tipo riferimento o valore di destinazione con il relativo costruttore senza parametri se non è già stato inizializzato.</summary>
      <param name="target">Riferimento o valore di tipo <c>T</c> da inizializzare se non è già stato inizializzato.</param>
      <param name="initialized">Riferimento a un valore booleano che determina se la destinazione è già stata inizializzata.</param>
      <param name="syncLock">Riferimento a un oggetto utilizzato come blocco a esclusione reciproca per l'inizializzazione di <paramref name="target" />. Se <paramref name="syncLock" /> è <see langword="null" />, verrà creata un'istanza di un nuovo oggetto.</param>
      <typeparam name="T">Tipo del riferimento da inizializzare.</typeparam>
      <returns>Oggetto inizializzato.</returns>
      <exception cref="T:System.MemberAccessException">Le autorizzazioni per accedere al costruttore di tipo <paramref name="T" /> erano mancanti.</exception>
      <exception cref="T:System.MissingMemberException">Il tipo <paramref name="T" /> non dispone di un costruttore senza parametri.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
      <summary>Inizializza un tipo di riferimento o di valore di destinazione utilizzando una funzione specificata se non è già stato inizializzato.</summary>
      <param name="target">Riferimento o valore di tipo <c>T</c> da inizializzare se non è già stato inizializzato.</param>
      <param name="initialized">Riferimento a un valore booleano che determina se la destinazione è già stata inizializzata.</param>
      <param name="syncLock">Riferimento a un oggetto utilizzato come blocco a esclusione reciproca per l'inizializzazione di <paramref name="target" />. Se <paramref name="syncLock" /> è <see langword="null" />, verrà creata un'istanza di un nuovo oggetto.</param>
      <param name="valueFactory">Funzione chiamata per inizializzare il riferimento o il valore.</param>
      <typeparam name="T">Tipo del riferimento da inizializzare.</typeparam>
      <returns>Oggetto inizializzato.</returns>
      <exception cref="T:System.MemberAccessException">Le autorizzazioni per accedere al costruttore di tipo <paramref name="T" /> erano mancanti.</exception>
      <exception cref="T:System.MissingMemberException">Il tipo <paramref name="T" /> non dispone di un costruttore senza parametri.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
      <summary>Inizializza un tipo di riferimento di destinazione utilizzando una funzione specificata se non è già stato inizializzato.</summary>
      <param name="target">Riferimento da inizializzare se non è già stato inizializzato.</param>
      <param name="valueFactory">Funzione chiamata per inizializzare il riferimento.</param>
      <typeparam name="T">Tipo del riferimento da inizializzare.</typeparam>
      <returns>Oggetto inizializzato.</returns>
      <exception cref="T:System.MissingMemberException">Il tipo <paramref name="T" /> non dispone di un costruttore senza parametri.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="valueFactory" /> restituisce null (Nothing in Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Object@,System.Func{``0})">
      <summary>Inizializza un tipo di riferimento di destinazione con una funzione specificata se non è già stato inizializzato.</summary>
      <param name="target">Riferimento da inizializzare se non è già stato inizializzato.</param>
      <param name="syncLock">Riferimento a un oggetto utilizzato come blocco a esclusione reciproca per l'inizializzazione di <paramref name="target" />. Se <paramref name="syncLock" /> è <see langword="null" />, verrà creata un'istanza di un nuovo oggetto.</param>
      <param name="valueFactory">Metodo da richiamare per inizializzare <paramref name="target" />.</param>
      <typeparam name="T">Tipo del riferimento da inizializzare.</typeparam>
      <returns>Oggetto inizializzato.</returns>
    </member>
    <member name="T:System.Threading.LockCookie">
      <summary>Definisce il blocco che implementa la semantica writer singolo/visualizzatori multipli. Si tratta di un tipo di valore.</summary>
    </member>
    <member name="M:System.Threading.LockCookie.Equals(System.Object)">
      <summary>Indica se un oggetto specificato è una struttura <see cref="T:System.Threading.LockCookie" /> ed è uguale all'istanza corrente.</summary>
      <param name="obj">Oggetto da confrontare con l'istanza corrente della classe.</param>
      <returns>
        <see langword="true" /> se il valore di <paramref name="obj" /> è uguale al valore dell'istanza corrente; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.Equals(System.Threading.LockCookie)">
      <summary>Indica se l'istanza corrente è uguale all'oggetto <see cref="T:System.Threading.LockCookie" /> specificato.</summary>
      <param name="obj">
        <see cref="T:System.Threading.LockCookie" /> da confrontare con l'istanza corrente.</param>
      <returns>
        <see langword="true" /> se <paramref name="obj" /> è uguale al valore dell'istanza corrente. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.GetHashCode">
      <summary>Restituisce il codice hash per l'istanza.</summary>
      <returns>Codice hash di un intero con segno a 32 bit.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.op_Equality(System.Threading.LockCookie,System.Threading.LockCookie)">
      <summary>Indica se due strutture <see cref="T:System.Threading.LockCookie" /> sono uguali.</summary>
      <param name="a">Oggetto <see cref="T:System.Threading.LockCookie" /> da confrontare con <paramref name="b" />.</param>
      <param name="b">Oggetto <see cref="T:System.Threading.LockCookie" /> da confrontare con <paramref name="a" />.</param>
      <returns>
        <see langword="true" /> se <paramref name="a" /> è uguale a <paramref name="b" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.op_Inequality(System.Threading.LockCookie,System.Threading.LockCookie)">
      <summary>Indica se due strutture <see cref="T:System.Threading.LockCookie" /> non sono uguali.</summary>
      <param name="a">Oggetto <see cref="T:System.Threading.LockCookie" /> da confrontare con <paramref name="b" />.</param>
      <param name="b">Oggetto <see cref="T:System.Threading.LockCookie" /> da confrontare con <paramref name="a" />.</param>
      <returns>
        <see langword="true" /> se <paramref name="a" /> non è uguale a <paramref name="b" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.LockRecursionException">
      <summary>Eccezione generata quando una voce ricorsiva in un blocco non è compatibile con i criteri di ricorsione per tale blocco.</summary>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.LockRecursionException" /> con un messaggio fornito dal sistema in cui viene descritto l'errore.</summary>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.LockRecursionException" /> con dati serializzati.</summary>
      <param name="info">Oggetto che contiene i dati oggetto serializzati.</param>
      <param name="context">Informazioni contestuali sull'origine o sulla destinazione.</param>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.String)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.LockRecursionException" /> con un messaggio specificato in cui viene descritto l'errore.</summary>
      <param name="message">Messaggio in cui viene descritta l'eccezione. Il chiamante di questo costruttore deve assicurare che la stringa sia stata localizzata in base alle impostazioni cultura correnti del sistema.</param>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.String,System.Exception)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.LockRecursionException" /> con un messaggio di errore specificato e un riferimento all'eccezione interna che è la causa dell'eccezione corrente.</summary>
      <param name="message">Messaggio in cui viene descritta l'eccezione. Il chiamante di questo costruttore deve assicurare che la stringa sia stata localizzata in base alle impostazioni cultura correnti del sistema.</param>
      <param name="innerException">Eccezione che ha causato l'eccezione corrente. Se il parametro <paramref name="innerException" /> non è <see langword="null" />, l'eccezione corrente viene generata in un blocco <see langword="catch" /> in cui viene gestita l'eccezione interna.</param>
    </member>
    <member name="T:System.Threading.LockRecursionPolicy">
      <summary>Specifica se lo stesso thread può accedere a un blocco più volte.</summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.NoRecursion">
      <summary>Se un thread tenta di accedere a un blocco in modo ricorsivo, viene generata un'eccezione. È possibile che alcune classi consentano particolari ricorsioni quando questa impostazione è attivata.</summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.SupportsRecursion">
      <summary>Un thread può accedere a un blocco in modo ricorsivo. Alcune classi possono limitare questa funzionalità.</summary>
    </member>
    <member name="T:System.Threading.ManualResetEvent">
      <summary>Rappresenta un evento di sincronizzazione dei thread che, quando viene segnalato, deve essere reimpostato manualmente. Questa classe non può essere ereditata.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEvent.#ctor(System.Boolean)">
      <summary>Consente l'inizializzazione di una nuova istanza della classe <see cref="T:System.Threading.ManualResetEvent" /> con un valore Booleano che indica se lo stato iniziale deve essere impostato su segnalato.</summary>
      <param name="initialState">Viene restituito <see langword="true" /> per impostare lo stato iniziale su segnalato; <see langword="false" /> per impostare lo stato iniziale su non segnalato.</param>
    </member>
    <member name="T:System.Threading.ManualResetEventSlim">
      <summary>Rappresenta un evento di sincronizzazione dei thread che, quando viene segnalato, deve essere reimpostato manualmente. La classe è un'alternativa leggera a <see cref="T:System.Threading.ManualResetEvent" />.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.ManualResetEventSlim" /> con uno stato iniziale di non segnalato.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean)">
      <summary>Consente l'inizializzazione di una nuova istanza della classe <see cref="T:System.Threading.ManualResetEventSlim" /> con un valore Booleano che indica se lo stato iniziale deve essere impostato su segnalato.</summary>
      <param name="initialState">true per impostare lo stato iniziale su segnalato; false per impostarlo su non segnalato.</param>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean,System.Int32)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.ManualResetEventSlim" /> con un valore booleano che indica se impostare lo stato iniziale su segnalato e un conteggio delle rotazioni specificato.</summary>
      <param name="initialState">true per impostare lo stato iniziale su segnalato; false per impostarlo su non segnalato.</param>
      <param name="spinCount">Numero di attese di rotazione che devono verificarsi prima di eseguire il fallback su un'operazione di attesa basata sul kernel.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="spinCount" /> è minore di 0 o maggiore del valore massimo consentito.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose">
      <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.ManualResetEventSlim" />.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose(System.Boolean)">
      <summary>Rilascia le risorse non gestite usate dall'oggetto <see cref="T:System.Threading.ManualResetEventSlim" /> e, facoltativamente, le risorse gestite.</summary>
      <param name="disposing">True per rilasciare sia le risorse gestite sia quelle non gestite; false per rilasciare solo le risorse non gestite.</param>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.IsSet">
      <summary>Ottiene un valore che indica se l'evento è impostato.</summary>
      <returns>true se l'evento è impostato, altrimenti false.</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Reset">
      <summary>Imposta lo stato dell'evento su non segnalato, provocando il blocco dei thread.</summary>
      <exception cref="T:System.ObjectDisposedException">L'oggetto è già stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Set">
      <summary>Imposta lo stato dell'evento su segnalato, per consentire a uno o più thread in attesa dell'evento di procedere.</summary>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.SpinCount">
      <summary>Ottiene il numero di attese di rotazione che devono verificarsi prima di eseguire il fallback su un'operazione di attesa basata sul kernel.</summary>
      <returns>Restituisce il numero di attese di rotazione che devono verificarsi prima di eseguire il fallback su un'operazione di attesa basata sul kernel.</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait">
      <summary>Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.ManualResetEventSlim" /> corrente non viene impostato.</summary>
      <exception cref="T:System.InvalidOperationException">Superato il numero massimo di oggetti waiter consentiti.</exception>
      <exception cref="T:System.ObjectDisposedException">L'oggetto è già stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32)">
      <summary>Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.ManualResetEventSlim" /> corrente non viene impostato, utilizzando un intero con segno a 32 bit per misurare l'intervallo di tempo.</summary>
      <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
      <returns>
        <see langword="true" /> se l'oggetto <see cref="T:System.Threading.ManualResetEventSlim" /> è stato impostato. In caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
      <exception cref="T:System.InvalidOperationException">Superato il numero massimo di oggetti waiter consentiti.</exception>
      <exception cref="T:System.ObjectDisposedException">L'oggetto è già stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary>Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.ManualResetEventSlim" /> corrente non viene impostato, utilizzando un intero con segno a 32 bit per misurare l'intervallo di tempo e al contempo osservando un oggetto <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
      <param name="cancellationToken">Oggetto <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <returns>
        <see langword="true" /> se l'oggetto <see cref="T:System.Threading.ManualResetEventSlim" /> è stato impostato. In caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
      <exception cref="T:System.InvalidOperationException">Superato il numero massimo di oggetti waiter consentiti.</exception>
      <exception cref="T:System.ObjectDisposedException">L'oggetto è già stato eliminato o <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" /> è stata eliminata.</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Threading.CancellationToken)">
      <summary>Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.ManualResetEventSlim" /> corrente non riceve un segnale, osservando un oggetto <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken">Oggetto <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <exception cref="T:System.InvalidOperationException">Superato il numero massimo di oggetti waiter consentiti.</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
      <exception cref="T:System.ObjectDisposedException">L'oggetto è già stato eliminato o <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" /> è stata eliminata.</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan)">
      <summary>Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.ManualResetEventSlim" /> corrente non viene impostato, utilizzando un oggetto <see cref="T:System.TimeSpan" /> per misurare l'intervallo di tempo.</summary>
      <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
      <returns>
        <see langword="true" /> se l'oggetto <see cref="T:System.Threading.ManualResetEventSlim" /> è stato impostato. In caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito.
-oppure-
Il numero di millisecondi in <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException">Superato il numero massimo di oggetti waiter consentiti.</exception>
      <exception cref="T:System.ObjectDisposedException">L'oggetto è già stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.ManualResetEventSlim" /> corrente non viene impostato, utilizzando un oggetto <see cref="T:System.TimeSpan" /> per misurare l'intervallo di tempo e al contempo osservando un oggetto <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
      <param name="cancellationToken">Oggetto <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <returns>
        <see langword="true" /> se l'oggetto <see cref="T:System.Threading.ManualResetEventSlim" /> è stato impostato. In caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito.
-oppure-
Il numero di millisecondi in <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException">Superato il numero massimo di oggetti waiter consentiti.</exception>
      <exception cref="T:System.ObjectDisposedException">L'oggetto è già stato eliminato o <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" /> è stata eliminata.</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.WaitHandle">
      <summary>Ottiene l'oggetto <see cref="T:System.Threading.WaitHandle" /> sottostante per questo oggetto <see cref="T:System.Threading.ManualResetEventSlim" />.</summary>
      <returns>Oggetto evento <see cref="T:System.Threading.WaitHandle" /> sottostante per questo oggetto <see cref="T:System.Threading.ManualResetEventSlim" />.</returns>
    </member>
    <member name="T:System.Threading.Monitor">
      <summary>Fornisce un meccanismo che sincronizza l'accesso agli oggetti.</summary>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object)">
      <summary>Acquisisce un blocco esclusivo sull'oggetto specificato.</summary>
      <param name="obj">Oggetto sui cui acquisire il blocco del monitoraggio.</param>
      <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
      <summary>Acquisisce un blocco esclusivo sull'oggetto specificato e imposta atomicamente un valore che indica se il blocco è stato ottenuto.</summary>
      <param name="obj">Oggetto per il quale attendere.</param>
      <param name="lockTaken">Risultato del tentativo di acquisizione del blocco passato dal riferimento. L'input deve essere <see langword="false" />. L'output è <see langword="true" /> se il blocco viene acquisito; in caso contrario, l'output è <see langword="false" />. L'output viene impostato anche se si verifica un'eccezione durante il tentativo di acquisire il blocco.
Nota   Se non si verifica alcuna eccezione, l'output di questo metodo è sempre <see langword="true" />.</param>
      <exception cref="T:System.ArgumentException">L'input per <paramref name="lockTaken" /> è <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Exit(System.Object)">
      <summary>Viene rilasciato un blocco esclusivo sull'oggetto specificato.</summary>
      <param name="obj">Oggetto sul quale rilasciare il blocco.</param>
      <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">Il blocco per l'oggetto specificato non è di proprietà del thread corrente.</exception>
    </member>
    <member name="M:System.Threading.Monitor.IsEntered(System.Object)">
      <summary>Determina se il thread corrente specificato contiene il blocco sull'oggetto specificato.</summary>
      <param name="obj">Oggetto da testare.</param>
      <returns>
        <see langword="true" /> se il thread corrente è responsabile del blocco su <paramref name="obj" />; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> è <see langword="null" />.</exception>
    </member>
    <member name="P:System.Threading.Monitor.LockContentionCount">
      <summary>Ottiene il numero di volte in cui si è verificata una contesa durante il tentativo di acquisire il blocco del monitoraggio.</summary>
      <returns>Il numero di volte in cui si è verificato un conflitto durante il tentativo di eseguire il blocco del monitoraggio.</returns>
    </member>
    <member name="M:System.Threading.Monitor.Pulse(System.Object)">
      <summary>Consente di notificare a un thread della coda di attesa che lo stato dell'oggetto bloccato è stato modificato.</summary>
      <param name="obj">Oggetto atteso da un thread.</param>
      <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">Il thread chiamante non è il proprietario del blocco per l'oggetto specificato.</exception>
    </member>
    <member name="M:System.Threading.Monitor.PulseAll(System.Object)">
      <summary>Notifica a tutti i thread in attesa che lo stato dell'oggetto è stato modificato.</summary>
      <param name="obj">Oggetto che invia l'impulso.</param>
      <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">Il thread chiamante non è il proprietario del blocco per l'oggetto specificato.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object)">
      <summary>Prova ad acquisire un blocco esclusivo sull'oggetto specificato.</summary>
      <param name="obj">Oggetto sul quale acquisire il blocco.</param>
      <returns>
        <see langword="true" /> se il thread corrente acquisisce il blocco; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
      <summary>Prova ad acquisire un blocco esclusivo sull'oggetto specificato e imposta atomicamente un valore che indica se il blocco è stato ottenuto.</summary>
      <param name="obj">Oggetto sul quale acquisire il blocco.</param>
      <param name="lockTaken">Risultato del tentativo di acquisizione del blocco passato dal riferimento. L'input deve essere <see langword="false" />. L'output è <see langword="true" /> se il blocco viene acquisito; in caso contrario, l'output è <see langword="false" />. L'output viene impostato anche se si verifica un'eccezione durante il tentativo di acquisire il blocco.</param>
      <exception cref="T:System.ArgumentException">L'input per <paramref name="lockTaken" /> è <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
      <summary>Viene eseguito, per un numero specificato di millisecondi, il tentativo di acquisire un blocco esclusivo sull'oggetto specificato.</summary>
      <param name="obj">Oggetto sul quale acquisire il blocco.</param>
      <param name="millisecondsTimeout">Tempo di attesa espresso in millisecondi prima che si verifichi il blocco.</param>
      <returns>
        <see langword="true" /> se il thread corrente acquisisce il blocco; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> è negativo e diverso da <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
      <summary>Prova ad acquisire, per il numero di millisecondi specificato, un blocco esclusivo sull'oggetto specificato e imposta atomicamente un valore che indica se il blocco è stato ottenuto.</summary>
      <param name="obj">Oggetto sul quale acquisire il blocco.</param>
      <param name="millisecondsTimeout">Tempo di attesa espresso in millisecondi prima che si verifichi il blocco.</param>
      <param name="lockTaken">Risultato del tentativo di acquisizione del blocco passato dal riferimento. L'input deve essere <see langword="false" />. L'output è <see langword="true" /> se il blocco viene acquisito; in caso contrario, l'output è <see langword="false" />. L'output viene impostato anche se si verifica un'eccezione durante il tentativo di acquisire il blocco.</param>
      <exception cref="T:System.ArgumentException">L'input per <paramref name="lockTaken" /> è <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> è negativo e diverso da <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
      <summary>Viene eseguito, per una quantità di tempo specificata, il tentativo di acquisire un blocco esclusivo sull'oggetto specificato.</summary>
      <param name="obj">Oggetto sul quale acquisire il blocco.</param>
      <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta la durata di attesa del blocco. Un valore di -1 millisecondo specifica un'attesa infinita.</param>
      <returns>
        <see langword="true" /> se il thread corrente acquisisce il blocco; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="timeout" /> in millisecondi è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecondo) oppure è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
      <summary>Prova ad acquisire, per la quantità di tempo specificata, un blocco esclusivo sull'oggetto specificato e imposta atomicamente un valore che indica se il blocco è stato ottenuto.</summary>
      <param name="obj">Oggetto sul quale acquisire il blocco.</param>
      <param name="timeout">Quantità di tempo che rappresenta la durata di attesa del blocco. Un valore di -1 millisecondo specifica un'attesa infinita.</param>
      <param name="lockTaken">Risultato del tentativo di acquisizione del blocco passato dal riferimento. L'input deve essere <see langword="false" />. L'output è <see langword="true" /> se il blocco viene acquisito; in caso contrario, l'output è <see langword="false" />. L'output viene impostato anche se si verifica un'eccezione durante il tentativo di acquisire il blocco.</param>
      <exception cref="T:System.ArgumentException">L'input per <paramref name="lockTaken" /> è <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="timeout" /> in millisecondi è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecondo) oppure è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object)">
      <summary>Rilascia il blocco su un oggetto e interrompe il thread corrente finché riacquisisce il blocco.</summary>
      <param name="obj">Oggetto per il quale attendere.</param>
      <returns>Viene restituito <see langword="true" /> se la chiamata è stata restituita perché il chiamante ha riacquisito il blocco per l'oggetto specificato. Non viene restituito alcun valore se il blocco non viene riacquisito.</returns>
      <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">Il thread chiamante non è il proprietario del blocco per l'oggetto specificato.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">Il thread da cui è stato richiamato <see langword="Wait" /> viene interrotto in seguito dallo stato di attesa. L'interruzione si verifica quando il metodo <see cref="M:System.Threading.Thread.Interrupt" /> di questo thread viene chiamato da un altro thread.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
      <summary>Rilascia il blocco su un oggetto e interrompe il thread corrente finché riacquisisce il blocco. Allo scadere dell'intervallo di timeout specificato, il thread viene inserito nella coda di thread pronti.</summary>
      <param name="obj">Oggetto per il quale attendere.</param>
      <param name="millisecondsTimeout">Numero di millisecondi da attendere prima che il thread venga inserito nella coda di thread pronti.</param>
      <returns>
        <see langword="true" /> se il blocco è stato riacquisito prima che sia trascorso il tempo specificato; <see langword="false" /> se il blocco è stato riacquisito dopo che è trascorso il tempo specificato. Il metodo non restituisce alcun valore finché il blocco non viene riacquisito.</returns>
      <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">Il thread chiamante non è il proprietario del blocco per l'oggetto specificato.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">Il thread da cui è stato richiamato <see langword="Wait" /> viene interrotto in seguito dallo stato di attesa. L'interruzione si verifica quando il metodo <see cref="M:System.Threading.Thread.Interrupt" /> di questo thread viene chiamato da un altro thread.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Il valore del parametro <paramref name="millisecondsTimeout" /> è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
      <summary>Rilascia il blocco su un oggetto e interrompe il thread corrente finché riacquisisce il blocco. Allo scadere dell'intervallo di timeout specificato, il thread viene inserito nella coda di thread pronti. Questo metodo consente anche di specificare se il dominio di sincronizzazione per il contesto, qualora si trovi in un contesto di sincronizzazione, viene terminato prima dell'attesa e riacquisito in un secondo momento.</summary>
      <param name="obj">Oggetto per il quale attendere.</param>
      <param name="millisecondsTimeout">Numero di millisecondi da attendere prima che il thread venga inserito nella coda di thread pronti.</param>
      <param name="exitContext">
        <see langword="true" /> per uscire e riacquisire il dominio di sincronizzazione per il contesto, se si trova in un contesto sincronizzato, prima dell'attesa; in caso contrario, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> se il blocco è stato riacquisito prima che sia trascorso il tempo specificato; <see langword="false" /> se il blocco è stato riacquisito dopo che è trascorso il tempo specificato. Il metodo non restituisce alcun valore finché il blocco non viene riacquisito.</returns>
      <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">
        <see langword="Wait" /> non viene richiamato dall'interno di un blocco di codice sincronizzato.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">Il thread da cui è stato richiamato <see langword="Wait" /> viene interrotto in seguito dallo stato di attesa. L'interruzione si verifica quando il metodo <see cref="M:System.Threading.Thread.Interrupt" /> di questo thread viene chiamato da un altro thread.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Il valore del parametro <paramref name="millisecondsTimeout" /> è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
      <summary>Rilascia il blocco su un oggetto e interrompe il thread corrente finché riacquisisce il blocco. Allo scadere dell'intervallo di timeout specificato, il thread viene inserito nella coda di thread pronti.</summary>
      <param name="obj">Oggetto per il quale attendere.</param>
      <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il tempo di attesa prima che il thread venga inserito nella coda di thread pronti.</param>
      <returns>
        <see langword="true" /> se il blocco è stato riacquisito prima che sia trascorso il tempo specificato; <see langword="false" /> se il blocco è stato riacquisito dopo che è trascorso il tempo specificato. Il metodo non restituisce alcun valore finché il blocco non viene riacquisito.</returns>
      <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">Il thread chiamante non è il proprietario del blocco per l'oggetto specificato.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">Il thread da cui è stato richiamato <see langword="Wait" /> viene interrotto in seguito dallo stato di attesa. L'interruzione si verifica quando il metodo <see cref="M:System.Threading.Thread.Interrupt" /> di questo thread viene chiamato da un altro thread.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Il valore del parametro <paramref name="timeout" /> in millisecondi è negativo e non rappresenta <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecondo) oppure è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
      <summary>Rilascia il blocco su un oggetto e interrompe il thread corrente finché riacquisisce il blocco. Allo scadere dell'intervallo di timeout specificato, il thread viene inserito nella coda di thread pronti. Esce eventualmente dal dominio di sincronizzazione per il contesto di sincronizzazione prima dell'attesa e riacquisisce il dominio in un secondo momento.</summary>
      <param name="obj">Oggetto per il quale attendere.</param>
      <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il tempo di attesa prima che il thread venga inserito nella coda di thread pronti.</param>
      <param name="exitContext">
        <see langword="true" /> per uscire e riacquisire il dominio di sincronizzazione per il contesto, se si trova in un contesto sincronizzato, prima dell'attesa; in caso contrario, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> se il blocco è stato riacquisito prima che sia trascorso il tempo specificato; <see langword="false" /> se il blocco è stato riacquisito dopo che è trascorso il tempo specificato. Il metodo non restituisce alcun valore finché il blocco non viene riacquisito.</returns>
      <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">
        <see langword="Wait" /> non viene richiamato dall'interno di un blocco di codice sincronizzato.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">Il thread da cui è stato richiamato Wait viene interrotto più tardi dallo stato di attesa. L'interruzione si verifica quando il metodo <see cref="M:System.Threading.Thread.Interrupt" /> di questo thread viene chiamato da un altro thread.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="timeout" /> è negativo e non rappresenta <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecondo) oppure è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="T:System.Threading.Mutex">
      <summary>Primitiva di sincronizzazione che può essere usata anche per la sincronizzazione interprocesso.</summary>
    </member>
    <member name="M:System.Threading.Mutex.#ctor">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Mutex" /> con le proprietà predefinite.</summary>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Mutex" /> con un valore booleano che indica se il thread chiamante deve avere la proprietà iniziale del mutex.</summary>
      <param name="initiallyOwned">Viene restituito <see langword="true" /> per concedere al thread chiamante la proprietà iniziale del mutex; in caso contrario, <see langword="false" />.</param>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Mutex" /> con un valore booleano che indica se il thread chiamante deve avere la proprietà iniziale del mutex e con una stringa che rappresenta il nome del mutex.</summary>
      <param name="initiallyOwned">
        <see langword="true" /> per concedere al thread chiamante la proprietà iniziale del mutex di sistema denominato, se questo è stato creato come risultato della chiamata; in caso contrario, <see langword="false" />.</param>
      <param name="name">Nome di <see cref="T:System.Threading.Mutex" />. Se il valore è <see langword="null" />, l'oggetto <see cref="T:System.Threading.Mutex" /> è senza nome.</param>
      <exception cref="T:System.UnauthorizedAccessException">Il mutex denominato esiste e ha accesso alla sicurezza controllo, ma l'utente non dispone di <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
      <exception cref="T:System.IO.IOException">Errore Win32.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Il mutex denominato non può essere creato, forse perché un handle di attesa di un tipo diverso ha lo stesso nome.</exception>
      <exception cref="T:System.ArgumentException">La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Mutex" /> con un valore booleano che indica se il thread chiamante deve avere la proprietà iniziale del mutex, con una stringa che rappresenta il nome del mutex e con un valore booleano che, quando il metodo viene restituito, indichi se al thread chiamante era stata concessa la proprietà iniziale del mutex.</summary>
      <param name="initiallyOwned">
        <see langword="true" /> per concedere al thread chiamante la proprietà iniziale del mutex di sistema denominato, se questo è stato creato come risultato della chiamata; in caso contrario, <see langword="false" />.</param>
      <param name="name">Nome di <see cref="T:System.Threading.Mutex" />. Se il valore è <see langword="null" />, l'oggetto <see cref="T:System.Threading.Mutex" /> è senza nome.</param>
      <param name="createdNew">Quando questo metodo viene restituito, contiene un valore booleano che è <see langword="true" /> se è stato creato un mutex locale (ovvero, se il valore di <paramref name="name" /> è <see langword="null" /> o una stringa vuota) oppure se è stato creato il mutex di sistema denominato specificato; <see langword="false" /> se il mutex di sistema denominato specificato è già esistente. Questo parametro viene passato non inizializzato.</param>
      <exception cref="T:System.UnauthorizedAccessException">Il mutex denominato esiste e ha accesso alla sicurezza controllo, ma l'utente non dispone di <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
      <exception cref="T:System.IO.IOException">Errore Win32.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Il mutex denominato non può essere creato, forse perché un handle di attesa di un tipo diverso ha lo stesso nome.</exception>
      <exception cref="T:System.ArgumentException">La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
    </member>
    <member name="M:System.Threading.Mutex.OpenExisting(System.String)">
      <summary>Apre il mutex denominato specificato, se esistente.</summary>
      <param name="name">Nome del mutex di sistema da aprire.</param>
      <returns>Oggetto che rappresenta il mutex di sistema denominato.</returns>
      <exception cref="T:System.ArgumentException">Il parametro <paramref name="name" /> è una stringa vuota.
-oppure-
La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> è <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Il mutex denominato non esiste.</exception>
      <exception cref="T:System.IO.IOException">Errore Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Il mutex denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per usarlo.</exception>
    </member>
    <member name="M:System.Threading.Mutex.ReleaseMutex">
      <summary>Rilascia l'oggetto <see cref="T:System.Threading.Mutex" /> una volta.</summary>
      <exception cref="T:System.ApplicationException">Il thread di chiamata non è il proprietario del mutex.</exception>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
    </member>
    <member name="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
      <summary>Apre il mutex denominato specificato, se esistente, e restituisce un valore che indica se l'operazione è stata completata.</summary>
      <param name="name">Nome del mutex di sistema da aprire.</param>
      <param name="result">Quando questo metodo viene restituito, contiene un oggetto di <see cref="T:System.Threading.Mutex" /> che rappresenta il mutex denominato se la chiamata ha esito positivo o <see langword="null" /> se la chiamata ha esito negativo. Questo parametro viene trattato come non inizializzato.</param>
      <returns>
        <see langword="true" /> se il mutex denominato è stato aperto correttamente; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException">Il parametro <paramref name="name" /> è una stringa vuota.
-oppure-
La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> è <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException">Errore Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Il mutex denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per usarlo.</exception>
    </member>
    <member name="T:System.Threading.ReaderWriterLock">
      <summary>Definisce un blocco che supporta writer singoli e lettori multipli.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.#ctor">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.ReaderWriterLock" />.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
      <summary>Acquisisce un blocco del lettore, usando un valore <see cref="T:System.Int32" /> per il timeout.</summary>
      <param name="millisecondsTimeout">Timeout in millisecondi.</param>
      <exception cref="T:System.ApplicationException">L'intervallo <paramref name="millisecondsTimeout" /> scade prima che la richiesta di blocco sia stata soddisfatta.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
      <summary>Acquisisce un blocco del lettore, usando un valore <see cref="T:System.TimeSpan" /> per il timeout.</summary>
      <param name="timeout">Parametro <see langword="TimeSpan" /> che specifica il periodo di timeout.</param>
      <exception cref="T:System.ApplicationException">L'intervallo <paramref name="timeout" /> scade prima che la richiesta di blocco sia stata soddisfatta.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="timeout" /> specifica un valore negativo diverso da -1 millisecondi.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
      <summary>Acquisisce un blocco del writer, usando un valore <see cref="T:System.Int32" /> per il timeout.</summary>
      <param name="millisecondsTimeout">Timeout in millisecondi.</param>
      <exception cref="T:System.ApplicationException">L'intervallo <paramref name="timeout" /> scade prima che la richiesta di blocco sia stata soddisfatta.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
      <summary>Acquisisce un blocco del writer, usando un valore <see cref="T:System.TimeSpan" /> per il timeout.</summary>
      <param name="timeout">Parametro <see langword="TimeSpan" /> che specifica il periodo di timeout.</param>
      <exception cref="T:System.ApplicationException">L'intervallo <paramref name="timeout" /> scade prima che la richiesta di blocco sia stata soddisfatta.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="timeout" /> specifica un valore negativo diverso da -1 millisecondi.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)">
      <summary>Indica se sono stati concessi blocchi del writer a uno o più thread da quando è stato ottenuto il numero di sequenza.</summary>
      <param name="seqNum">Numero di sequenza.</param>
      <returns>
        <see langword="true" /> se sono stati concessi blocchi del writer a uno o più thread da quando è stato ottenuto il numero di sequenza; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)">
      <summary>Ripristina lo stato del blocco del thread in vigore prima della chiamata al metodo <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</summary>
      <param name="lockCookie">Oggetto <see cref="T:System.Threading.LockCookie" /> restituito dal metodo <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</param>
      <exception cref="T:System.ApplicationException">Il thread non è responsabile del blocco del writer.</exception>
      <exception cref="T:System.NullReferenceException">L'indirizzo di <paramref name="lockCookie" /> è un puntatore Null.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.IsReaderLockHeld">
      <summary>Ottiene un valore che indica se il thread corrente è responsabile di un blocco del lettore.</summary>
      <returns>
        <see langword="true" /> se il thread corrente è responsabile del blocco del lettore; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.IsWriterLockHeld">
      <summary>Viene fornito un valore che indica se il thread corrente è responsabile del blocco del writer.</summary>
      <returns>
        <see langword="true" /> se il thread corrente è responsabile del blocco del writer; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseLock">
      <summary>Consente il rilascio del blocco indipendentemente dal numero di acquisizioni del blocco da parte del thread.</summary>
      <returns>Valore <see cref="T:System.Threading.LockCookie" /> che rappresenta il blocco rilasciato.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseReaderLock">
      <summary>Consente di diminuire il conteggio dei blocchi.</summary>
      <exception cref="T:System.ApplicationException">Il thread non è responsabile di blocchi di lettura o del writer.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseWriterLock">
      <summary>Consente di diminuire il conteggio dei blocchi nel blocco del writer.</summary>
      <exception cref="T:System.ApplicationException">Il thread non è responsabile del blocco del writer.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)">
      <summary>Ripristina lo stato del blocco del thread in vigore prima della chiamata a <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</summary>
      <param name="lockCookie">Oggetto <see cref="T:System.Threading.LockCookie" /> restituito dal metodo <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</param>
      <exception cref="T:System.NullReferenceException">L'indirizzo di <paramref name="lockCookie" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
      <summary>Consente l'aggiornamento da un blocco di lettura al blocco del writer, utilizzando un valore <see langword="Int32" /> per il timeout.</summary>
      <param name="millisecondsTimeout">Timeout in millisecondi.</param>
      <returns>Valore <see cref="T:System.Threading.LockCookie" />.</returns>
      <exception cref="T:System.ApplicationException">L'intervallo <paramref name="millisecondsTimeout" /> scade prima che la richiesta di blocco sia stata soddisfatta.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
      <summary>Consente l'aggiornamento da un blocco di lettura al blocco del writer, utilizzando un valore <see langword="TimeSpan" /> per il timeout.</summary>
      <param name="timeout">Parametro <see langword="TimeSpan" /> che specifica il periodo di timeout.</param>
      <returns>Valore <see cref="T:System.Threading.LockCookie" />.</returns>
      <exception cref="T:System.ApplicationException">L'intervallo <paramref name="timeout" /> scade prima che la richiesta di blocco sia stata soddisfatta.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="timeout" /> specifica un valore negativo diverso da -1 millisecondi.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.WriterSeqNum">
      <summary>Viene fornito il numero di sequenza corrente.</summary>
      <returns>Numero di sequenza corrente.</returns>
    </member>
    <member name="T:System.Threading.ReaderWriterLockSlim">
      <summary>Rappresenta un blocco utilizzato per gestire l'accesso a una risorsa, consentendo a più thread l'accesso in lettura o l'accesso esclusivo in scrittura.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.ReaderWriterLockSlim" /> con i valori predefiniti delle proprietà.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.ReaderWriterLockSlim" />, specificando i criteri di ricorsione del blocco.</summary>
      <param name="recursionPolicy">Uno dei valori di enumerazione che specifica i criteri di ricorsione del blocco.</param>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
      <summary>Ottiene il numero complessivo di thread univoci per i quali è stato attivato il blocco in modalità lettura.</summary>
      <returns>Numero di thread univoci per i quali è stato attivato il blocco in modalità lettura.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.Dispose">
      <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.ReaderWriterLockSlim" />.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">
        <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> è maggiore di zero.
In alternativa
<see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> è maggiore di zero.
In alternativa
<see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> è maggiore di zero.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
      <summary>Tenta di accedere al blocco in modalità di lettura.</summary>
      <exception cref="T:System.Threading.LockRecursionException">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha tentato di acquisire il blocco di lettura quando contiene già il blocco di lettura.
-oppure-
La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha tentato di acquisire il blocco di lettura quando contiene già il blocco di scrittura.
-oppure-
Il numero di ricorsione supererebbe la capacità del contatore. Il limite è talmente elevato che questa eccezione non dovrebbe mai essere riscontrata dalle applicazioni.</exception>
      <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
      <summary>Tenta di accedere al blocco in modalità aggiornabile.</summary>
      <exception cref="T:System.Threading.LockRecursionException">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco in tutte le modalità.
-oppure-
Il thread corrente ha acceduto alla modalità di lettura, pertanto il tentativo di accedere alla modalità aggiornabile creerebbe la possibilità di un deadlock.
-oppure-
Il numero di ricorsione supererebbe la capacità del contatore. Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</exception>
      <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
      <summary>Tenta di accedere al blocco in modalità di scrittura.</summary>
      <exception cref="T:System.Threading.LockRecursionException">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco in tutte le modalità.
-oppure-
Il thread corrente ha acceduto alla modalità di lettura e non possiede già un blocco in scrittura, pertanto il tentativo di accedere al blocco in modalità di scrittura creerebbe la possibilità di un deadlock.
-oppure-
Il numero di ricorsione supererebbe la capacità del contatore. Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</exception>
      <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
      <summary>Riduce il conteggio della ricorsione per la modalità di lettura ed esce da questa modalità se il conteggio risultante è 0 (zero).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">Il thread corrente non ha acceduto al blocco in modalità di lettura.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
      <summary>Riduce il conteggio della ricorsione per la modalità aggiornabile ed esce da questa modalità se il conteggio risultante è 0 (zero).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">Il thread corrente non ha acceduto al blocco in modalità aggiornabile.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
      <summary>Riduce il conteggio della ricorsione per la modalità di scrittura ed esce da questa modalità se il conteggio risultante è 0 (zero).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">Il thread corrente non ha acceduto al blocco in modalità di scrittura.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
      <summary>Ottiene un valore che indica se il thread corrente ha acceduto al blocco in modalità di lettura.</summary>
      <returns>
        <see langword="true" /> se il thread corrente ha acceduto alla modalità di lettura; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
      <summary>Ottiene un valore che indica se il thread corrente ha acceduto al blocco in modalità aggiornabile.</summary>
      <returns>
        <see langword="true" /> se il thread corrente ha acceduto alla modalità aggiornabile; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
      <summary>Ottiene un valore che indica se il thread corrente ha acceduto al blocco in modalità di scrittura.</summary>
      <returns>
        <see langword="true" /> se il thread corrente ha acceduto alla modalità di scrittura; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
      <summary>Ottiene un valore che indica i criteri di ricorsione per l'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> corrente.</summary>
      <returns>Uno dei valori di enumerazione che specifica i criteri di ricorsione del blocco.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
      <summary>Ottiene il numero di volte in cui il thread corrente ha acceduto al blocco in modalità di lettura, come indicazione della ricorsione.</summary>
      <returns>0 (zero) se per il thread corrente non è stata attivata la modalità lettura, 1 se per il thread è stata attivata la modalità lettura ma non in modo ricorsivo o n se per il thread è stato attivato il blocco in modo ricorsivo n - 1 volte.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
      <summary>Ottiene il numero di volte in cui il thread corrente ha acceduto al blocco in modalità aggiornabile, come indicazione della ricorsione.</summary>
      <returns>0 (zero) se per il thread corrente non è stata attivata la modalità aggiornabile, 1 se per il thread è stata attivata la modalità aggiornabile ma non in modo ricorsivo o n se per il thread è stata attivata la modalità aggiornabile in modo ricorsivo n - 1 volte.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
      <summary>Ottiene il numero di volte in cui il thread corrente ha acceduto al blocco in modalità di scrittura, come indicazione della ricorsione.</summary>
      <returns>0 (zero) se per il thread corrente non è stata attivata la modalità scrittura, 1 se per il thread è stata attivata la modalità scrittura ma non in modo ricorsivo o n se per il thread è stata attivata la modalità scrittura in modo ricorsivo n - 1 volte.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
      <summary>Tenta di accedere al blocco in modalità di lettura con un timeout intero facoltativo.</summary>
      <param name="millisecondsTimeout">Numero di millisecondi di attesa, oppure -1 (<see cref="F:System.Threading.Timeout.Infinite" />) per attendere per un periodo di tempo indefinito.</param>
      <returns>
        <see langword="true" /> se il thread chiamante ha acceduto alla modalità di lettura; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco.
In alternativa
Il numero di ricorsione supererebbe la capacità del contatore. Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="millisecondsTimeout" /> è negativo, ma non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /> (-1), ovvero l'unico valore negativo consentito.</exception>
      <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
      <summary>Tenta di accedere al blocco in modalità di lettura con un timeout facoltativo.</summary>
      <param name="timeout">Intervallo di attesa, oppure -1 millisecondi per attendere per un periodo di tempo indefinito.</param>
      <returns>
        <see langword="true" /> se il thread chiamante ha acceduto alla modalità di lettura; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco.
-oppure-
Il numero di ricorsione supererebbe la capacità del contatore. Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="timeout" /> è negativo, ma non è uguale a -1 millisecondi, ovvero l'unico valore negativo consentito.
-oppure-
Il valore di <paramref name="timeout" /> è superiore a <see cref="F:System.Int32.MaxValue" /> millisecondi.</exception>
      <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
      <summary>Tenta di accedere al blocco in modalità aggiornabile con un timeout facoltativo.</summary>
      <param name="millisecondsTimeout">Numero di millisecondi di attesa, oppure -1 (<see cref="F:System.Threading.Timeout.Infinite" />) per attendere per un periodo di tempo indefinito.</param>
      <returns>
        <see langword="true" /> se il thread chiamante ha acceduto alla modalità aggiornabile; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco.
-oppure-
Il thread corrente ha inizialmente acceduto al blocco in modalità di lettura, pertanto il tentativo di accedere alla modalità aggiornabile creerebbe la possibilità di un deadlock.
-oppure-
Il numero di ricorsione supererebbe la capacità del contatore. Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="millisecondsTimeout" /> è negativo, ma non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /> (-1), ovvero l'unico valore negativo consentito.</exception>
      <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
      <summary>Tenta di accedere al blocco in modalità aggiornabile con un timeout facoltativo.</summary>
      <param name="timeout">Intervallo di attesa, oppure -1 millisecondi per attendere per un periodo di tempo indefinito.</param>
      <returns>
        <see langword="true" /> se il thread chiamante ha acceduto alla modalità aggiornabile; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco.
-oppure-
Il thread corrente ha inizialmente acceduto al blocco in modalità di lettura, pertanto il tentativo di accedere alla modalità aggiornabile creerebbe la possibilità di un deadlock.
-oppure-
Il numero di ricorsione supererebbe la capacità del contatore. Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="timeout" /> è negativo, ma non è uguale a -1 millisecondi, ovvero l'unico valore negativo consentito.
-oppure-
Il valore di <paramref name="timeout" /> è superiore a <see cref="F:System.Int32.MaxValue" /> millisecondi.</exception>
      <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
      <summary>Tenta di accedere al blocco in modalità di scrittura con un timeout facoltativo.</summary>
      <param name="millisecondsTimeout">Numero di millisecondi di attesa, oppure -1 (<see cref="F:System.Threading.Timeout.Infinite" />) per attendere per un periodo di tempo indefinito.</param>
      <returns>
        <see langword="true" /> se il thread chiamante ha acceduto alla modalità di scrittura; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco.
-oppure-
Il thread corrente ha inizialmente acceduto al blocco in modalità di lettura, pertanto il tentativo di accedere alla modalità di scrittura creerebbe la possibilità di un deadlock.
-oppure-
Il numero di ricorsione supererebbe la capacità del contatore. Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="millisecondsTimeout" /> è negativo, ma non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /> (-1), ovvero l'unico valore negativo consentito.</exception>
      <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
      <summary>Tenta di accedere al blocco in modalità di scrittura con un timeout facoltativo.</summary>
      <param name="timeout">Intervallo di attesa, oppure -1 millisecondi per attendere per un periodo di tempo indefinito.</param>
      <returns>
        <see langword="true" /> se il thread chiamante ha acceduto alla modalità di scrittura; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco.
-oppure-
Il thread corrente ha inizialmente acceduto al blocco in modalità di lettura, pertanto il tentativo di accedere alla modalità di scrittura creerebbe la possibilità di un deadlock.
-oppure-
Il numero di ricorsione supererebbe la capacità del contatore. Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="timeout" /> è negativo, ma non è uguale a -1 millisecondi, ovvero l'unico valore negativo consentito.
-oppure-
Il valore di <paramref name="timeout" /> è superiore a <see cref="F:System.Int32.MaxValue" /> millisecondi.</exception>
      <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
      <summary>Ottiene il numero complessivo di thread in attesa di accedere al blocco in modalità di lettura.</summary>
      <returns>Numero complessivo di thread in attesa di accedere alla modalità di lettura.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
      <summary>Ottiene il numero complessivo di thread in attesa di accedere al blocco in modalità aggiornabile.</summary>
      <returns>Numero complessivo di thread in attesa di accedere in modalità aggiornabile.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
      <summary>Ottiene il numero complessivo di thread in attesa di accedere al blocco in modalità di scrittura.</summary>
      <returns>Numero complessivo di thread in attesa di accedere alla modalità di scrittura.</returns>
    </member>
    <member name="T:System.Threading.Semaphore">
      <summary>Limita il numero di thread che possono accedere simultaneamente a una risorsa o a un pool di risorse.</summary>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Semaphore" />, specificando il numero di voci iniziale e il numero massimo di voci contemporanei.</summary>
      <param name="initialCount">Numero iniziale di richieste per il semaforo che possono essere concesse simultaneamente.</param>
      <param name="maximumCount">Numero massimo di richieste per il semaforo che possono essere concesse simultaneamente.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="initialCount" /> è maggiore di <paramref name="maximumCount" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maximumCount" /> è minore di 1.
-oppure-
<paramref name="initialCount" /> è minore di 0.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Semaphore" />, specificando il numero di voci iniziale e il numero massimo di voci contemporanee, nonché indicando facoltativamente il nome di un oggetto semaforo di sistema.</summary>
      <param name="initialCount">Numero iniziale di richieste per il semaforo che possono essere concesse simultaneamente.</param>
      <param name="maximumCount">Numero massimo di richieste per il semaforo che possono essere concesse simultaneamente.</param>
      <param name="name">Nome di un oggetto semaforo di sistema denominato.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="initialCount" /> è maggiore di <paramref name="maximumCount" />.
-oppure-
La lunghezza di<paramref name="name" /> supera i 260 caratteri.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maximumCount" /> è minore di 1.
-oppure-
<paramref name="initialCount" /> è minore di 0.</exception>
      <exception cref="T:System.IO.IOException">Errore Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Il semaforo denominato esiste e ha accesso alla sicurezza controllo, ma l'utente non dispone di <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Il semaforo denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Semaphore" />, specificando il numero di accessi iniziale e il numero massimo di accessi contemporanei, indicando facoltativamente il nome di un oggetto semaforo di sistema e specificando una variabile che riceve un valore che indica se è stato creato un nuovo semaforo di sistema.</summary>
      <param name="initialCount">Numero iniziale di richieste per il semaforo che possono essere soddisfatte contemporaneamente.</param>
      <param name="maximumCount">Numero massimo di richieste per il semaforo che possono essere soddisfatte contemporaneamente.</param>
      <param name="name">Nome di un oggetto semaforo di sistema denominato.</param>
      <param name="createdNew">Quando questo metodo viene restituito, contiene <see langword="true" /> se è stato creato un semaforo locale (ovvero, se il valore di <paramref name="name" /> è <see langword="null" /> o una stringa vuota) oppure se è stato creato il semaforo di sistema denominato specificato; <see langword="false" /> se il semaforo di sistema denominato specificato è già esistente. Questo parametro viene passato non inizializzato.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="initialCount" /> è maggiore di <paramref name="maximumCount" />.
-oppure-
La lunghezza di<paramref name="name" /> supera i 260 caratteri.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maximumCount" /> è minore di 1.
-oppure-
<paramref name="initialCount" /> è minore di 0.</exception>
      <exception cref="T:System.IO.IOException">Errore Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Il semaforo denominato esiste e ha accesso alla sicurezza controllo, ma l'utente non dispone di <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Il semaforo denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.OpenExisting(System.String)">
      <summary>Apre il semaforo denominato specificato, se esistente.</summary>
      <param name="name">Nome del semaforo di sistema da aprire.</param>
      <returns>Oggetto che rappresenta il semaforo di sistema denominato.</returns>
      <exception cref="T:System.ArgumentException">Il parametro <paramref name="name" /> è una stringa vuota.
-oppure-
La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> è <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Il semaforo denominato non esiste.</exception>
      <exception cref="T:System.IO.IOException">Errore Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Il semaforo denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per usarlo.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.Release">
      <summary>Esce dal semaforo e restituisce il conteggio precedente.</summary>
      <returns>Conteggio del semaforo prima della chiamata del metodo <see cref="Overload:System.Threading.Semaphore.Release" />.</returns>
      <exception cref="T:System.Threading.SemaphoreFullException">Il conteggio del semaforo ha già raggiunto il valore massimo.</exception>
      <exception cref="T:System.IO.IOException">Si è verificato un errore Win32 relativo a un semaforo denominato.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Il semaforo corrente rappresenta un semaforo di sistema denominato, ma l'utente non dispone di <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.
-oppure-
Il semaforo corrente rappresenta un semaforo di sistema denominato, ma non è stato aperto con <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.Release(System.Int32)">
      <summary>Esce dal semaforo il numero di volte specificato e restituisce il conteggio precedente.</summary>
      <param name="releaseCount">Numero di uscite dal semaforo.</param>
      <returns>Conteggio del semaforo prima della chiamata del metodo <see cref="Overload:System.Threading.Semaphore.Release" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="releaseCount" /> è minore di 1.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException">Il conteggio del semaforo ha già raggiunto il valore massimo.</exception>
      <exception cref="T:System.IO.IOException">Si è verificato un errore Win32 relativo a un semaforo denominato.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Il semaforo corrente rappresenta un semaforo di sistema denominato, ma l'utente non dispone di diritti <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.
-oppure-
Il semaforo corrente rappresenta un semaforo di sistema denominato, ma non è stato aperto con i diritti <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
      <summary>Apre il semaforo denominato specificato, se esistente, e restituisce un valore che indica se l'operazione è riuscita.</summary>
      <param name="name">Nome del semaforo di sistema da aprire.</param>
      <param name="result">Quando viene eseguita la restituzione del metodo, quest'ultimo contiene un oggetto <see cref="T:System.Threading.Semaphore" /> che rappresenta il semaforo denominato se la chiamata è riuscita o <see langword="null" /> se la chiamata non è riuscita. Questo parametro viene trattato come non inizializzato.</param>
      <returns>
        <see langword="true" /> se l'apertura del semaforo denominato è riuscita; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException">Il parametro <paramref name="name" /> è una stringa vuota.
-oppure-
La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> è <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException">Errore Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Il semaforo denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per usarlo.</exception>
    </member>
    <member name="T:System.Threading.SemaphoreFullException">
      <summary>Eccezione generata quando il metodo <see cref="Overload:System.Threading.Semaphore.Release" /> viene chiamato su un semaforo il cui conteggio ha già raggiunto il valore massimo.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.SemaphoreFullException" /> con i valori predefiniti.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.SemaphoreFullException" /> con dati serializzati.</summary>
      <param name="info">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> che contiene i dati di oggetto serializzati relativi all'eccezione generata.</param>
      <param name="context">Oggetto <see cref="T:System.Runtime.Serialization.StreamingContext" /> contenente le informazioni contestuali sull'origine o sulla destinazione.</param>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.String)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.SemaphoreFullException" /> con un messaggio di errore specificato.</summary>
      <param name="message">Messaggio di errore in cui viene indicato il motivo dell'eccezione.</param>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.String,System.Exception)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.SemaphoreFullException" /> con un messaggio di errore specificato e un riferimento all'eccezione interna che è la causa dell'eccezione corrente.</summary>
      <param name="message">Messaggio di errore in cui viene indicato il motivo dell'eccezione.</param>
      <param name="innerException">Eccezione che ha determinato l'eccezione corrente. Se il parametro <paramref name="innerException" /> non è <see langword="null" />, l'eccezione corrente viene generata in un blocco <see langword="catch" /> in cui viene gestita l'eccezione interna.</param>
    </member>
    <member name="T:System.Threading.SemaphoreSlim">
      <summary>Rappresenta un'alternativa semplificata a <see cref="T:System.Threading.Semaphore" /> che limita il numero di thread che possono accedere simultaneamente a una risorsa o a un pool di risorse.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.SemaphoreSlim" /> specificando il numero iniziale di richieste che possono essere concesse simultaneamente.</summary>
      <param name="initialCount">Numero iniziale di richieste per il semaforo che possono essere concesse simultaneamente.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="initialCount" /> è minore di 0.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.SemaphoreSlim" /> specificando il numero iniziale e massimo di richieste che possono essere concesse contemporaneamente.</summary>
      <param name="initialCount">Numero iniziale di richieste per il semaforo che possono essere concesse simultaneamente.</param>
      <param name="maxCount">Numero massimo delle richieste per il semaforo che possono essere concesse contemporaneamente.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="initialCount" /> è minore di 0, o <paramref name="initialCount" /> è maggiore di <paramref name="maxCount" /> o <paramref name="maxCount" /> è uguale o minore di 0.</exception>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.AvailableWaitHandle">
      <summary>Restituisce un oggetto <see cref="T:System.Threading.WaitHandle" /> che può essere utilizzato per attendere il semaforo.</summary>
      <returns>Oggetto <see cref="T:System.Threading.WaitHandle" /> che può essere usato per attendere il semaforo.</returns>
      <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.SemaphoreSlim" /> è stata eliminata.</exception>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.CurrentCount">
      <summary>Ottiene il numero di thread rimanenti che possono accedere all'oggetto <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <returns>Numero di thread rimanenti che possono accedere al semaforo.</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose">
      <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)">
      <summary>Rilascia le risorse non gestite usate dall'oggetto <see cref="T:System.Threading.SemaphoreSlim" /> e, facoltativamente, le risorse gestite.</summary>
      <param name="disposing">
        <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite, <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release">
      <summary>Rilascia l'oggetto <see cref="T:System.Threading.SemaphoreSlim" /> una volta.</summary>
      <returns>Numero precedente di <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException">
        <see cref="T:System.Threading.SemaphoreSlim" /> ha già raggiunto la dimensione massima.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release(System.Int32)">
      <summary>Rilascia l'oggetto <see cref="T:System.Threading.SemaphoreSlim" /> un numero di volte specificato.</summary>
      <param name="releaseCount">Numero di uscite dal semaforo.</param>
      <returns>Numero precedente di <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="releaseCount" /> è minore di 1.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException">
        <see cref="T:System.Threading.SemaphoreSlim" /> ha già raggiunto la dimensione massima.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait">
      <summary>Blocca il thread corrente finché non può immettere <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32)">
      <summary>Blocca il thread corrente finché non è in grado di accedere all'oggetto <see cref="T:System.Threading.SemaphoreSlim" />, utilizzando un intero con segno a 32 bit che specifica il timeout.</summary>
      <param name="millisecondsTimeout">Numero di millisecondi di attesa, <see cref="F:System.Threading.Timeout.Infinite" />(-1) per un'attesa illimitata oppure zero per testare lo stato dell'handle di attesa e tornare immediatamente.</param>
      <returns>
        <see langword="true" /> se il thread corrente ha immesso correttamente <see cref="T:System.Threading.SemaphoreSlim" />; altrimenti, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1 che rappresenta un timeout infinito oppure il timeout è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.SemaphoreSlim" /> è stata eliminata.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary>Blocca il thread corrente finché non è in grado di accedere all'oggetto <see cref="T:System.Threading.SemaphoreSlim" />, utilizzando un intero con segno a 32 bit che specifica il timeout mentre al contempo osservando un oggetto <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout">Numero di millisecondi di attesa, <see cref="F:System.Threading.Timeout.Infinite" />(-1) per un'attesa illimitata oppure zero per testare lo stato dell'handle di attesa e tornare immediatamente.</param>
      <param name="cancellationToken">Oggetto <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <returns>
        <see langword="true" /> se il thread corrente ha immesso correttamente <see cref="T:System.Threading.SemaphoreSlim" />; altrimenti, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.
-oppure-
<paramref name="millisecondsTimeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">È stata eliminata l'istanza di <see cref="T:System.Threading.SemaphoreSlim" /> o <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)">
      <summary>Blocca il thread corrente finché non può accedere all'oggetto <see cref="T:System.Threading.SemaphoreSlim" /> osservando un oggetto <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken">Token <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.
-oppure-
L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" /> è già stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan)">
      <summary>Blocca il thread corrente finché quest'ultimo non può accedere all'oggetto <see cref="T:System.Threading.SemaphoreSlim" />, utilizzando un oggetto <see cref="T:System.TimeSpan" /> per specificare il timeout.</summary>
      <param name="timeout">
        <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa, <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi di attesa illimitata o <see cref="T:System.TimeSpan" /> che rappresenta 0 millisecondi per testare l'handle di attesa e tornare immediatamente.</param>
      <returns>
        <see langword="true" /> se il thread corrente ha immesso correttamente <see cref="T:System.Threading.SemaphoreSlim" />; altrimenti, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.
-oppure-
<paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">L'istanza di semaphoreSlim è stata eliminata.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>Blocca il thread corrente finché non è in grado di accedere all'oggetto <see cref="T:System.Threading.SemaphoreSlim" />, utilizzando un oggetto <see cref="T:System.TimeSpan" /> che specifica il timeout e al contempo osservando un oggetto <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout">
        <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa, <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi di attesa illimitata o <see cref="T:System.TimeSpan" /> che rappresenta 0 millisecondi per testare l'handle di attesa e tornare immediatamente.</param>
      <param name="cancellationToken">Oggetto <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <returns>
        <see langword="true" /> se il thread corrente ha immesso correttamente <see cref="T:System.Threading.SemaphoreSlim" />; altrimenti, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.
-oppure-
<paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">L'istanza di semaphoreSlim è stata eliminata.
-oppure-
L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" /> è già stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync">
      <summary>In modo asincrono attende di immettere <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <returns>Attività che verrà completata quando si accede al semaforo.</returns>
      <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.SemaphoreSlim" /> è stata eliminata.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32)">
      <summary>In modo asincrono attende di immettere <see cref="T:System.Threading.SemaphoreSlim" />, utilizzando un Integer con segno a 32 bit per misurare l'intervallo di tempo.</summary>
      <param name="millisecondsTimeout">Numero di millisecondi di attesa, <see cref="F:System.Threading.Timeout.Infinite" />(-1) per un'attesa illimitata oppure zero per testare lo stato dell'handle di attesa e tornare immediatamente.</param>
      <returns>Attività che verrà completata con un risultato <see langword="true" /> se il thread corrente ha immesso correttamente <see cref="T:System.Threading.SemaphoreSlim" />, in caso contrario, con un risultato <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.
-oppure-
<paramref name="millisecondsTimeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)">
      <summary>In modo asincrono attende di immettere <see cref="T:System.Threading.SemaphoreSlim" />, utilizzando un Integer con segno a 32 bit per misurare l'intervallo di tempo, mentre osserva <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout">Numero di millisecondi di attesa, <see cref="F:System.Threading.Timeout.Infinite" />(-1) per un'attesa illimitata oppure zero per testare lo stato dell'handle di attesa e tornare immediatamente.</param>
      <param name="cancellationToken">Oggetto <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <returns>Attività che verrà completata con un risultato <see langword="true" /> se il thread corrente ha immesso correttamente <see cref="T:System.Threading.SemaphoreSlim" />, in caso contrario, con un risultato <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> è un numero diverso da -1, che rappresenta un timeout infinito.
-oppure-
<paramref name="millisecondsTimeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)">
      <summary>In modo asincrono attende di immettere <see cref="T:System.Threading.SemaphoreSlim" />, mentre osserva <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken">Token <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <returns>Attività che verrà completata quando il semaforo verrà inserito.</returns>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)">
      <summary>In modo asincrono attende di immettere <see cref="T:System.Threading.SemaphoreSlim" />, utilizzando <see cref="T:System.TimeSpan" /> per misurare l'intervallo di tempo.</summary>
      <param name="timeout">
        <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa, <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi di attesa illimitata o <see cref="T:System.TimeSpan" /> che rappresenta 0 millisecondi per testare l'handle di attesa e tornare immediatamente.</param>
      <returns>Attività che verrà completata con un risultato <see langword="true" /> se il thread corrente ha immesso correttamente <see cref="T:System.Threading.SemaphoreSlim" />, in caso contrario, con un risultato <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.
-oppure-
<paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>In modo asincrono attende di immettere <see cref="T:System.Threading.SemaphoreSlim" />, utilizzando <see cref="T:System.TimeSpan" /> per misurare l'intervallo di tempo, mentre osserva <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout">
        <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa, <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi di attesa illimitata o <see cref="T:System.TimeSpan" /> che rappresenta 0 millisecondi per testare l'handle di attesa e tornare immediatamente.</param>
      <param name="cancellationToken">Token <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <returns>Attività che verrà completata con un risultato <see langword="true" /> se il thread corrente ha immesso correttamente <see cref="T:System.Threading.SemaphoreSlim" />, in caso contrario, con un risultato <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.
-oppure-
<paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
      <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.SemaphoreSlim" /> è stata eliminata.</exception>
    </member>
    <member name="T:System.Threading.SendOrPostCallback">
      <summary>Rappresenta un metodo da chiamare quando un messaggio deve essere inviato a un contesto di sincronizzazione.</summary>
      <param name="state">Oggetto passato al delegato.</param>
    </member>
    <member name="T:System.Threading.SpinLock">
      <summary>Fornisce una primitiva di blocco a esclusione reciproca in cui un thread che tenta di acquisire il blocco rimane in attesa in un ciclo eseguendo controlli ripetuti finché il blocco non diventa disponibile.</summary>
    </member>
    <member name="M:System.Threading.SpinLock.#ctor(System.Boolean)">
      <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Threading.SpinLock" /> con l'opzione di rilevamento degli ID dei thread per migliorare il debug.</summary>
      <param name="enableThreadOwnerTracking">Valore che indica se acquisire e utilizzare gli ID dei thread per scopi di debug.</param>
    </member>
    <member name="M:System.Threading.SpinLock.Enter(System.Boolean@)">
      <summary>Acquisisce il blocco in modo affidabile, in modo tale che anche se si verifica un'eccezione all'interno della chiamata al metodo, è possibile esaminare l'oggetto <paramref name="lockTaken" /> in maniera affidabile per determinare se il blocco è stato acquisito.</summary>
      <param name="lockTaken">True se il blocco è stato acquisito. In caso contrario, False. Prima di chiamare questo metodo è necessario inizializzare <paramref name="lockTaken" /> su False.</param>
      <exception cref="T:System.ArgumentException">È necessario inizializzare l'argomento <paramref name="lockTaken" /> su False prima della chiamata a Enter.</exception>
      <exception cref="T:System.Threading.LockRecursionException">Il rilevamento della proprietà dei thread è abilitato e il thread corrente ha già acquisito questo blocco.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit">
      <summary>Rilascia il blocco.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">Il rilevamento della proprietà dei thread è abilitato e il thread corrente non è il proprietario di questo blocco.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit(System.Boolean)">
      <summary>Rilascia il blocco.</summary>
      <param name="useMemoryBarrier">Valore booleano che indica se generare un limite di memoria per pubblicare immediatamente l'operazione di uscita agli altri thread.</param>
      <exception cref="T:System.Threading.SynchronizationLockException">Il rilevamento della proprietà dei thread è abilitato e il thread corrente non è il proprietario di questo blocco.</exception>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeld">
      <summary>Ottiene un valore che indica se attualmente il blocco è mantenuto da un thread.</summary>
      <returns>true se attualmente il blocco è mantenuto da un thread; in caso contrario, false.</returns>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeldByCurrentThread">
      <summary>Ottiene un valore che indica se il blocco è mantenuto dal thread corrente.</summary>
      <returns>true se il blocco è mantenuto dal thread corrente; in caso contrario, false.</returns>
      <exception cref="T:System.InvalidOperationException">Il rilevamento della proprietà dei thread è disabilitato.</exception>
    </member>
    <member name="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled">
      <summary>Ottiene un valore che indica se per questa istanza è abilitato il rilevamento della proprietà dei thread.</summary>
      <returns>true se per questa istanza è abilitato il rilevamento della proprietà dei thread; in caso contrario, false.</returns>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
      <summary>Tenta di acquisire il blocco in modo affidabile, in modo tale che anche se si verifica un'eccezione all'interno della chiamata al metodo, è possibile esaminare l'oggetto <paramref name="lockTaken" /> in maniera affidabile per determinare se il blocco è stato acquisito.</summary>
      <param name="lockTaken">True se il blocco è stato acquisito. In caso contrario, False. Prima di chiamare questo metodo è necessario inizializzare <paramref name="lockTaken" /> su False.</param>
      <exception cref="T:System.ArgumentException">È necessario inizializzare l'argomento <paramref name="lockTaken" /> su False prima della chiamata a TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException">Il rilevamento della proprietà dei thread è abilitato e il thread corrente ha già acquisito questo blocco.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
      <summary>Tenta di acquisire il blocco in modo affidabile, in modo tale che anche se si verifica un'eccezione all'interno della chiamata al metodo, è possibile esaminare l'oggetto <paramref name="lockTaken" /> in maniera affidabile per determinare se il blocco è stato acquisito.</summary>
      <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
      <param name="lockTaken">True se il blocco è stato acquisito. In caso contrario, False. Prima di chiamare questo metodo è necessario inizializzare <paramref name="lockTaken" /> su False.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
      <exception cref="T:System.ArgumentException">È necessario inizializzare l'argomento <paramref name="lockTaken" /> su False prima della chiamata a TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException">Il rilevamento della proprietà dei thread è abilitato e il thread corrente ha già acquisito questo blocco.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
      <summary>Tenta di acquisire il blocco in modo affidabile, in modo tale che anche se si verifica un'eccezione all'interno della chiamata al metodo, è possibile esaminare l'oggetto <paramref name="lockTaken" /> in maniera affidabile per determinare se il blocco è stato acquisito.</summary>
      <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
      <param name="lockTaken">True se il blocco è stato acquisito. In caso contrario, False. Prima di chiamare questo metodo è necessario inizializzare <paramref name="lockTaken" /> su False.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi che rappresenta un timeout infinito o il timeout è più grande di <see cref="F:System.Int32.MaxValue" /> millisecondi.</exception>
      <exception cref="T:System.ArgumentException">È necessario inizializzare l'argomento <paramref name="lockTaken" /> su False prima della chiamata a TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException">Il rilevamento della proprietà dei thread è abilitato e il thread corrente ha già acquisito questo blocco.</exception>
    </member>
    <member name="T:System.Threading.SpinWait">
      <summary>Fornisce il supporto per l'attesa basata su rotazione.</summary>
    </member>
    <member name="P:System.Threading.SpinWait.Count">
      <summary>Ottiene il numero di chiamate di <see cref="M:System.Threading.SpinWait.SpinOnce" /> su questa istanza.</summary>
      <returns>Restituisce un intero che rappresenta il numero di volte in cui <see cref="M:System.Threading.SpinWait.SpinOnce" /> è stato chiamato su questa istanza.</returns>
    </member>
    <member name="P:System.Threading.SpinWait.NextSpinWillYield">
      <summary>Ottiene un valore che indica se la chiamata successiva a <see cref="M:System.Threading.SpinWait.SpinOnce" /> comporterà la cessione del processore, attivando un cambio imposto di contesto.</summary>
      <returns>Valore che indica se la chiamata successiva a <see cref="M:System.Threading.SpinWait.SpinOnce" /> comporterà la cessione del processore, attivando un cambio imposto di contesto.</returns>
    </member>
    <member name="M:System.Threading.SpinWait.Reset">
      <summary>Reimposta il contatore delle rotazioni.</summary>
    </member>
    <member name="M:System.Threading.SpinWait.SpinOnce">
      <summary>Esegue una sola rotazione.</summary>
    </member>
    <member name="M:System.Threading.SpinWait.SpinOnce(System.Int32)">
      <summary>Esegue un solo spin e chiama <see cref="M:System.Threading.Thread.Sleep(System.Int32)" /> dopo un numero spin minimo.</summary>
      <param name="sleep1Threshold">Numero spin minimo dopo il quale è possibile usare <see langword="Thread.Sleep(1)" />. Il valore -1 disabilita l'uso di <see langword="Thread.Sleep(1)" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="sleep1Threshold" /> è minore di -1.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean})">
      <summary>Esegue rotazioni finché non è stata soddisfatta la condizione specificata.</summary>
      <param name="condition">Delegato da eseguire ripetutamente finché non restituisce true.</param>
      <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="condition" /> è Null.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.Int32)">
      <summary>Esegue rotazioni finché non è stata soddisfatta la condizione specificata o fino allo scadere del timeout specificato.</summary>
      <param name="condition">Delegato da eseguire ripetutamente finché non restituisce true.</param>
      <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
      <returns>
        <see langword="true" /> se la condizione viene soddisfatta entro lo scadere del timeout; in caso contrario, false</returns>
      <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="condition" /> è Null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.TimeSpan)">
      <summary>Esegue rotazioni finché non è stata soddisfatta la condizione specificata o fino allo scadere del timeout specificato.</summary>
      <param name="condition">Delegato da eseguire ripetutamente finché non restituisce true.</param>
      <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa. In alternativa, per un'attesa indefinita, oggetto TimeSpan che rappresenta -1 millisecondi.</param>
      <returns>
        <see langword="true" /> se la condizione viene soddisfatta entro lo scadere del timeout; in caso contrario, false</returns>
      <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="condition" /> è Null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi che rappresenta un timeout infinito - o - il timeout è più grande di <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="T:System.Threading.SynchronizationContext">
      <summary>Fornisce la funzionalità di base per propagare un contesto di sincronizzazione in vari modelli di sincronizzazione.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.#ctor">
      <summary>Crea una nuova istanza della classe <see cref="T:System.Threading.SynchronizationContext" />.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.CreateCopy">
      <summary>Quando ne viene eseguito l'override in una classe derivata, crea una copia del contesto di sincronizzazione.</summary>
      <returns>Nuovo oggetto <see cref="T:System.Threading.SynchronizationContext" />.</returns>
    </member>
    <member name="P:System.Threading.SynchronizationContext.Current">
      <summary>Ottiene il contesto di sincronizzazione per il thread corrente.</summary>
      <returns>Oggetto <see cref="T:System.Threading.SynchronizationContext" /> che rappresenta il contesto di sincronizzazione corrente.</returns>
    </member>
    <member name="M:System.Threading.SynchronizationContext.IsWaitNotificationRequired">
      <summary>Determina se è necessaria la notifica dell'attesa.</summary>
      <returns>
        <see langword="true" /> se è richiesta la notifica dell'attesa; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.SynchronizationContext.OperationCompleted">
      <summary>Quando ne viene eseguito l'override in una classe derivata, risponde alla notifica di completamento di un'operazione.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.OperationStarted">
      <summary>Quando ne viene eseguito l'override in una classe derivata, risponde alla notifica di avvio di un'operazione.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
      <summary>Quando ne viene eseguito l'override in una classe derivata, invia un messaggio asincrono a un contesto di sincronizzazione.</summary>
      <param name="d">Delegato di <see cref="T:System.Threading.SendOrPostCallback" /> da chiamare.</param>
      <param name="state">Oggetto passato al delegato.</param>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
      <summary>Quando ne viene eseguito l'override in una classe derivata, invia un messaggio sincrono a un contesto di sincronizzazione.</summary>
      <param name="d">Delegato di <see cref="T:System.Threading.SendOrPostCallback" /> da chiamare.</param>
      <param name="state">Oggetto passato al delegato.</param>
      <exception cref="T:System.NotSupportedException">Il metodo è stato chiamato in un'App Windows Store. L'implementazione di <see cref="T:System.Threading.SynchronizationContext" /> per le applicazioni Windows Store non supporta il metodo <see cref="M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)" />.</exception>
    </member>
    <member name="M:System.Threading.SynchronizationContext.SetSynchronizationContext(System.Threading.SynchronizationContext)">
      <summary>Imposta il contesto di sincronizzazione corrente.</summary>
      <param name="syncContext">Oggetto <see cref="T:System.Threading.SynchronizationContext" /> da impostare.</param>
    </member>
    <member name="M:System.Threading.SynchronizationContext.SetWaitNotificationRequired">
      <summary>Imposta la notifica che indica che è richiesta la notifica di attesa e prepara il metodo di callback in modo che possa essere chiamato in modo più affidabile in caso di attesa.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Wait(System.IntPtr[],System.Boolean,System.Int32)">
      <summary>Attende che uno qualsiasi o tutti gli elementi della matrice specificata ricevano un segnale.</summary>
      <param name="waitHandles">Matrice di tipo <see cref="T:System.IntPtr" /> contenente gli handle nativi del sistema operativo.</param>
      <param name="waitAll">
        <see langword="true" /> per attendere tutti gli handle; <see langword="false" /> per attendere un handle qualsiasi.</param>
      <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
      <returns>Indice della matrice dell'oggetto che ha soddisfatto l'attesa.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="waitHandles" /> è null.</exception>
    </member>
    <member name="M:System.Threading.SynchronizationContext.WaitHelper(System.IntPtr[],System.Boolean,System.Int32)">
      <summary>Funzione di supporto che attende che uno qualsiasi o tutti gli elementi della matrice specificata ricevano un segnale.</summary>
      <param name="waitHandles">Matrice di tipo <see cref="T:System.IntPtr" /> contenente gli handle nativi del sistema operativo.</param>
      <param name="waitAll">
        <see langword="true" /> per attendere tutti gli handle; <see langword="false" /> per attendere un handle qualsiasi.</param>
      <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
      <returns>Indice della matrice dell'oggetto che ha soddisfatto l'attesa.</returns>
    </member>
    <member name="T:System.Threading.SynchronizationLockException">
      <summary>Eccezione generata quando un metodo richiede che il chiamante sia il proprietario del blocco su un Monitor specifico, e tale metodo viene richiamato da un chiamante che non è proprietario del blocco.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.SynchronizationLockException" /> con le proprietà predefinite.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.SynchronizationLockException" /> con dati serializzati.</summary>
      <param name="info">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> che contiene i dati oggetto serializzati relativi all'eccezione generata.</param>
      <param name="context">Oggetto <see cref="T:System.Runtime.Serialization.StreamingContext" /> contenente le informazioni contestuali sull'origine o sulla destinazione.</param>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.String)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.SynchronizationLockException" /> con un messaggio di errore specificato.</summary>
      <param name="message">Messaggio di errore in cui viene indicato il motivo dell'eccezione.</param>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.String,System.Exception)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.SynchronizationLockException" /> con un messaggio di errore specificato e un riferimento all'eccezione interna che è la causa dell'eccezione corrente.</summary>
      <param name="message">Messaggio di errore in cui viene indicato il motivo dell'eccezione.</param>
      <param name="innerException">Eccezione che ha determinato l'eccezione corrente. Se il parametro <paramref name="innerException" /> non è <see langword="null" />, l'eccezione corrente viene generata in un blocco <see langword="catch" /> in cui viene gestita l'eccezione interna.</param>
    </member>
    <member name="T:System.Threading.ThreadLocal`1">
      <summary>Consente l'archiviazione dei dati nella memoria locale dei thread.</summary>
      <typeparam name="T">Specifica il tipo di dati archiviati per thread.</typeparam>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor">
      <summary>Inizializza l'istanza di <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Boolean)">
      <summary>Inizializza l'istanza di <see cref="T:System.Threading.ThreadLocal`1" /> e specifica se tutti i valori sono accessibili da qualsiasi thread.</summary>
      <param name="trackAllValues">
        <see langword="true" /> per tenere traccia di tutti i valori impostati sull'istanza ed esporli tramite la proprietà <see cref="P:System.Threading.ThreadLocal`1.Values" />. In caso contrario, <see langword="false" />.</param>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0})">
      <summary>Inizializza l'istanza di <see cref="T:System.Threading.ThreadLocal`1" /> con la funzione <paramref name="valueFactory" /> specificata.</summary>
      <param name="valueFactory">Oggetto <see cref="T:System.Func`1" /> richiamato per produrre un valore con inizializzazione differita quando si prova a recuperare l'oggetto <see cref="P:System.Threading.ThreadLocal`1.Value" /> senza che sia stato inizializzato in precedenza.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="valueFactory" /> è un riferimento null (Nothing in Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0},System.Boolean)">
      <summary>Inizializza l'istanza di <see cref="T:System.Threading.ThreadLocal`1" /> con la funzione <paramref name="valueFactory" /> specificata e un flag che indica se tutti i valori sono accessibili da qualsiasi thread.</summary>
      <param name="valueFactory">Oggetto <see cref="T:System.Func`1" /> richiamato per produrre un valore con inizializzazione differita quando si tenta di recuperare l'oggetto <see cref="P:System.Threading.ThreadLocal`1.Value" /> senza che sia stato inizializzato in precedenza.</param>
      <param name="trackAllValues">
        <see langword="true" /> per tenere traccia di tutti i valori impostati sull'istanza ed esporli tramite la proprietà <see cref="P:System.Threading.ThreadLocal`1.Values" />. In caso contrario, <see langword="false" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="valueFactory" /> è un riferimento <see langword="null" /> (<see langword="Nothing" /> in Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose">
      <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose(System.Boolean)">
      <summary>Rilascia le risorse usate dall'istanza di <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
      <param name="disposing">Valore booleano che indica se questo metodo viene chiamato a causa di una chiamata a <see cref="M:System.Threading.ThreadLocal`1.Dispose" />.</param>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Finalize">
      <summary>Rilascia le risorse usate dall'istanza di <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.IsValueCreated">
      <summary>Ottiene un valore che indica se l'oggetto <see cref="P:System.Threading.ThreadLocal`1.Value" /> è inizializzato sul thread corrente.</summary>
      <returns>true se <see cref="P:System.Threading.ThreadLocal`1.Value" /> viene inizializzato sul thread corrente; in caso contrario, false.</returns>
      <exception cref="T:System.ObjectDisposedException">L’istanza di <see cref="T:System.Threading.ThreadLocal`1" /> è stata eliminata.</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.ToString">
      <summary>Crea e restituisce una rappresentazione di stringa di questa istanza per il thread corrente.</summary>
      <returns>Risultato della chiamata di <see cref="M:System.Object.ToString" /> su <see cref="P:System.Threading.ThreadLocal`1.Value" />.</returns>
      <exception cref="T:System.ObjectDisposedException">L’istanza di <see cref="T:System.Threading.ThreadLocal`1" /> è stata eliminata.</exception>
      <exception cref="T:System.NullReferenceException">L'oggetto <see cref="P:System.Threading.ThreadLocal`1.Value" /> per il thread corrente è un riferimento Null (Nothing in Visual Basic).</exception>
      <exception cref="T:System.InvalidOperationException">La funzione di inizializzazione tenta di fare riferimento in modo ricorsivo a <see cref="P:System.Threading.ThreadLocal`1.Value" />.</exception>
      <exception cref="T:System.MissingMemberException">Non viene fornito alcun costruttore senza parametri e non è specificato alcun valore di factory.</exception>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Value">
      <summary>Ottiene o imposta il valore di questa istanza per il thread corrente.</summary>
      <returns>Restituisce un'istanza dell'oggetto della cui inizializzazione è responsabile questo oggetto ThreadLocal.</returns>
      <exception cref="T:System.ObjectDisposedException">L’istanza di <see cref="T:System.Threading.ThreadLocal`1" /> è stata eliminata.</exception>
      <exception cref="T:System.InvalidOperationException">La funzione di inizializzazione tenta di fare riferimento in modo ricorsivo a <see cref="P:System.Threading.ThreadLocal`1.Value" />.</exception>
      <exception cref="T:System.MissingMemberException">Non viene fornito alcun costruttore senza parametri e non è specificato alcun valore di factory.</exception>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Values">
      <summary>Ottiene un elenco di tutti i valori attualmente archiviati da tutti i thread che hanno eseguito l'accesso a questa istanza.</summary>
      <returns>Elenco di tutti i valori attualmente archiviati da tutti i thread che hanno eseguito l'accesso a questa istanza.</returns>
      <exception cref="T:System.InvalidOperationException">I valori archiviati da tutti i thread non sono disponibili perché questa istanza è stata inizializzata con l'argomento <paramref name="trackAllValues" /> impostato su <see langword="false" /> nella chiamata al costruttore di una classe.</exception>
      <exception cref="T:System.ObjectDisposedException">L’istanza di <see cref="T:System.Threading.ThreadLocal`1" /> è stata eliminata.</exception>
    </member>
    <member name="T:System.Threading.Volatile">
      <summary>Contiene metodi per l'esecuzione di operazioni relative alla memoria volatile.</summary>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Boolean@)">
      <summary>Legge il valore del campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location">Campo da leggere.</param>
      <returns>Valore letto. Questo valore è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Byte@)">
      <summary>Legge il valore del campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location">Campo da leggere.</param>
      <returns>Valore letto. Questo valore è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Double@)">
      <summary>Legge il valore del campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location">Campo da leggere.</param>
      <returns>Valore letto. Questo valore è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int16@)">
      <summary>Legge il valore del campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location">Campo da leggere.</param>
      <returns>Valore letto. Questo valore è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int32@)">
      <summary>Legge il valore del campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location">Campo da leggere.</param>
      <returns>Valore letto. Questo valore è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int64@)">
      <summary>Legge il valore del campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location">Campo da leggere.</param>
      <returns>Valore letto. Questo valore è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.IntPtr@)">
      <summary>Legge il valore del campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location">Campo da leggere.</param>
      <returns>Valore letto. Questo valore è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.SByte@)">
      <summary>Legge il valore del campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location">Campo da leggere.</param>
      <returns>Valore letto. Questo valore è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Single@)">
      <summary>Legge il valore del campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location">Campo da leggere.</param>
      <returns>Valore letto. Questo valore è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt16@)">
      <summary>Legge il valore del campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location">Campo da leggere.</param>
      <returns>Valore letto. Questo valore è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt32@)">
      <summary>Legge il valore del campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location">Campo da leggere.</param>
      <returns>Valore letto. Questo valore è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt64@)">
      <summary>Legge il valore del campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location">Campo da leggere.</param>
      <returns>Valore letto. Questo valore è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UIntPtr@)">
      <summary>Legge il valore del campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location">Campo da leggere.</param>
      <returns>Valore letto. Questo valore è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read``1(``0@)">
      <summary>Legge il riferimento a un oggetto dal campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location">Campo da leggere.</param>
      <typeparam name="T">Tipo di campo da leggere. Deve essere un tipo di riferimento, non un tipo di valore.</typeparam>
      <returns>Riferimento a <paramref name="T" /> che è stato letto. Questo riferimento è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Boolean@,System.Boolean)">
      <summary>Scrive il valore specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location">Campo in cui viene scritto il valore.</param>
      <param name="value">Valore da scrivere. Il valore viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Byte@,System.Byte)">
      <summary>Scrive il valore specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location">Campo in cui viene scritto il valore.</param>
      <param name="value">Valore da scrivere. Il valore viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Double@,System.Double)">
      <summary>Scrive il valore specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location">Campo in cui viene scritto il valore.</param>
      <param name="value">Valore da scrivere. Il valore viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int16@,System.Int16)">
      <summary>Scrive il valore specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location">Campo in cui viene scritto il valore.</param>
      <param name="value">Valore da scrivere. Il valore viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int32@,System.Int32)">
      <summary>Scrive il valore specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location">Campo in cui viene scritto il valore.</param>
      <param name="value">Valore da scrivere. Il valore viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int64@,System.Int64)">
      <summary>Scrive il valore specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location">Campo in cui viene scritto il valore.</param>
      <param name="value">Valore da scrivere. Il valore viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.IntPtr@,System.IntPtr)">
      <summary>Scrive il valore specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location">Campo in cui viene scritto il valore.</param>
      <param name="value">Valore da scrivere. Il valore viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.SByte@,System.SByte)">
      <summary>Scrive il valore specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location">Campo in cui viene scritto il valore.</param>
      <param name="value">Valore da scrivere. Il valore viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Single@,System.Single)">
      <summary>Scrive il valore specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location">Campo in cui viene scritto il valore.</param>
      <param name="value">Valore da scrivere. Il valore viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt16@,System.UInt16)">
      <summary>Scrive il valore specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location">Campo in cui viene scritto il valore.</param>
      <param name="value">Valore da scrivere. Il valore viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt32@,System.UInt32)">
      <summary>Scrive il valore specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location">Campo in cui viene scritto il valore.</param>
      <param name="value">Valore da scrivere. Il valore viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt64@,System.UInt64)">
      <summary>Scrive il valore specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location">Campo in cui viene scritto il valore.</param>
      <param name="value">Valore da scrivere. Il valore viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UIntPtr@,System.UIntPtr)">
      <summary>Scrive il valore specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location">Campo in cui viene scritto il valore.</param>
      <param name="value">Valore da scrivere. Il valore viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write``1(``0@,``0)">
      <summary>Scrive il riferimento a un oggetto specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location">Campo in cui viene scritto il riferimento a un oggetto.</param>
      <param name="value">Riferimento a un oggetto da scrivere. Il riferimento viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
      <typeparam name="T">Tipo di campo da scrivere. Deve essere un tipo di riferimento, non un tipo di valore.</typeparam>
    </member>
    <member name="T:System.Threading.WaitHandleCannotBeOpenedException">
      <summary>Eccezione generata quando viene effettuato un tentativo di aprire un mutex di sistema, un semaforo o un handle di attesa evento inesistente.</summary>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> con i valori predefiniti.</summary>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> con dati serializzati.</summary>
      <param name="info">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> che contiene i dati di oggetto serializzati relativi all'eccezione generata.</param>
      <param name="context">Oggetto <see cref="T:System.Runtime.Serialization.StreamingContext" /> contenente le informazioni contestuali sull'origine o sulla destinazione.</param>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> con un messaggio di errore specificato.</summary>
      <param name="message">Messaggio di errore in cui viene indicato il motivo dell'eccezione.</param>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String,System.Exception)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> con un messaggio di errore specificato e un riferimento all'eccezione interna che è la causa dell'eccezione corrente.</summary>
      <param name="message">Messaggio di errore in cui viene indicato il motivo dell'eccezione.</param>
      <param name="innerException">Eccezione che ha determinato l'eccezione corrente. Se il parametro <paramref name="innerException" /> non è <see langword="null" />, l'eccezione corrente viene generata in un blocco <see langword="catch" /> in cui viene gestita l'eccezione interna.</param>
    </member>
  </members>
</doc>