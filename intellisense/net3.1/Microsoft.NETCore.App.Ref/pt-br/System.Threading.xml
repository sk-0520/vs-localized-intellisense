<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Threading</name>
  </assembly>
  <members>
    <member name="T:System.Threading.AbandonedMutexException">
      <summary>A exceção gerada quando um thread adquire um objeto <see cref="T:System.Threading.Mutex" /> que outro thread abandonou ao ser fechado sem liberá-lo.</summary>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.AbandonedMutexException" /> com valores padrão.</summary>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.Int32,System.Threading.WaitHandle)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.AbandonedMutexException" /> com um índice especificado para o mutex abandonado, se aplicável, e um objeto <see cref="T:System.Threading.Mutex" /> que representa o mutex.</summary>
      <param name="location">O índice do mutex abandonado na matriz de identificadores de espera, se a exceção é gerada para o método <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, ou -1, se a exceção é gerada para os métodos <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> ou <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle">Um objeto <see cref="T:System.Threading.Mutex" /> que representa o mutex abandonado.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.AbandonedMutexException" /> com dados serializados.</summary>
      <param name="info">O objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que mantém os dados de objeto serializados sobre a exceção que está sendo lançada.</param>
      <param name="context">O objeto <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contém informações contextuais sobre a fonte ou o destino.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.AbandonedMutexException" /> com uma mensagem de erro especificada.</summary>
      <param name="message">Uma mensagem de erro que explica a razão da exceção.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.AbandonedMutexException" /> com uma exceção interna e uma mensagem de erro especificadas.</summary>
      <param name="message">Uma mensagem de erro que explica a razão da exceção.</param>
      <param name="inner">A exceção que é a causa da exceção atual. Caso o parâmetro <paramref name="inner" /> não seja <see langword="null" />, a exceção atual é acionada em um bloco <see langword="catch" /> que identifica a exceção interna.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception,System.Int32,System.Threading.WaitHandle)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.AbandonedMutexException" /> com uma mensagem de erro, a exceção interna, o índice para o mutex abandonado, se aplicável, e um objeto <see cref="T:System.Threading.Mutex" /> que representa o mutex especificados.</summary>
      <param name="message">Uma mensagem de erro que explica a razão da exceção.</param>
      <param name="inner">A exceção que é a causa da exceção atual. Caso o parâmetro <paramref name="inner" /> não seja <see langword="null" />, a exceção atual é acionada em um bloco <see langword="catch" /> que identifica a exceção interna.</param>
      <param name="location">O índice do mutex abandonado na matriz de identificadores de espera, se a exceção é gerada para o método <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, ou -1, se a exceção é gerada para os métodos <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> ou <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle">Um objeto <see cref="T:System.Threading.Mutex" /> que representa o mutex abandonado.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Int32,System.Threading.WaitHandle)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.AbandonedMutexException" /> com uma mensagem de erro, o índice do mutex abandonado, se aplicável, e o mutex abandonado especificados.</summary>
      <param name="message">Uma mensagem de erro que explica a razão da exceção.</param>
      <param name="location">O índice do mutex abandonado na matriz de identificadores de espera, se a exceção é gerada para o método <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, ou -1, se a exceção é gerada para os métodos <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> ou <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle">Um objeto <see cref="T:System.Threading.Mutex" /> que representa o mutex abandonado.</param>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.Mutex">
      <summary>Obtém o mutex abandonado que causou a exceção, se for conhecido.</summary>
      <returns>Um <see cref="T:System.Threading.Mutex" /> objeto que representa o mutex abandonado ou <see langword="null" /> se o mutex abandonado não pôde ser identificado.</returns>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.MutexIndex">
      <summary>Obtém o índice do mutex abandonado que causou a exceção, se for conhecido.</summary>
      <returns>O índice, na matriz de identificadores de espera passado para <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> o método, <see cref="T:System.Threading.Mutex" /> do objeto que representa o mutex abandonado, ou-1 se o índice do mutex abandonado não puder ser determinado.</returns>
    </member>
    <member name="T:System.Threading.AsyncFlowControl">
      <summary>Fornece a funcionalidade para restaurar a migração ou o fluxo do contexto de execução entre threads.</summary>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Dispose">
      <summary>Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.AsyncFlowControl" />.</summary>
      <exception cref="T:System.InvalidOperationException">A estrutura <see cref="T:System.Threading.AsyncFlowControl" /> não é usada no thread em que ela foi criada.
- ou -
A estrutura <see cref="T:System.Threading.AsyncFlowControl" /> já foi usada para chamar <see cref="M:System.Threading.AsyncFlowControl.Dispose" /> ou <see cref="M:System.Threading.AsyncFlowControl.Undo" />.</exception>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Equals(System.Object)">
      <summary>Determina se o objeto especificado é igual à estrutura <see cref="T:System.Threading.AsyncFlowControl" /> atual.</summary>
      <param name="obj">Um objeto a ser comparado com a estrutura atual.</param>
      <returns>
        <see langword="true" /> se <paramref name="obj" /> for uma estrutura <see cref="T:System.Threading.AsyncFlowControl" /> e for igual à estrutura <see cref="T:System.Threading.AsyncFlowControl" /> atual, caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Equals(System.Threading.AsyncFlowControl)">
      <summary>Determina se a estrutura <see cref="T:System.Threading.AsyncFlowControl" /> especificada é igual à estrutura <see cref="T:System.Threading.AsyncFlowControl" /> atual.</summary>
      <param name="obj">Uma estrutura <see cref="T:System.Threading.AsyncFlowControl" /> a comparar à estrutura atual.</param>
      <returns>
        <see langword="true" /> se <paramref name="obj" /> for igual à estrutura <see cref="T:System.Threading.AsyncFlowControl" /> atual; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.GetHashCode">
      <summary>Obtém um código hash para a estrutura <see cref="T:System.Threading.AsyncFlowControl" /> atual.</summary>
      <returns>Um código hash para a estrutura <see cref="T:System.Threading.AsyncFlowControl" /> atual.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.op_Equality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)">
      <summary>Compara duas estruturas <see cref="T:System.Threading.AsyncFlowControl" /> para determinar se elas são iguais.</summary>
      <param name="a">Uma estrutura <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <param name="b">Uma estrutura <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <returns>
        <see langword="true" /> se as duas estruturas forem iguais, caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.op_Inequality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)">
      <summary>Compara duas estruturas <see cref="T:System.Threading.AsyncFlowControl" /> para determinar se elas não são iguais.</summary>
      <param name="a">Uma estrutura <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <param name="b">Uma estrutura <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <returns>
        <see langword="true" /> se as estruturas não forem iguais; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Undo">
      <summary>Restaura o fluxo do contexto de execução entre threads.</summary>
      <exception cref="T:System.InvalidOperationException">A estrutura <see cref="T:System.Threading.AsyncFlowControl" /> não é usada no thread em que ela foi criada.
- ou -
A estrutura <see cref="T:System.Threading.AsyncFlowControl" /> já foi usada para chamar <see cref="M:System.Threading.AsyncFlowControl.Dispose" /> ou <see cref="M:System.Threading.AsyncFlowControl.Undo" />.</exception>
    </member>
    <member name="T:System.Threading.AsyncLocal`1">
      <summary>Representa dados de ambiente que são locais para um determinado fluxo de controle assíncrono, como um método assíncrono.</summary>
      <typeparam name="T">O tipo dos dados do ambiente.</typeparam>
    </member>
    <member name="M:System.Threading.AsyncLocal`1.#ctor">
      <summary>Cria uma instância <see cref="T:System.Threading.AsyncLocal`1" /> que não recebe notificações de alteração.</summary>
    </member>
    <member name="M:System.Threading.AsyncLocal`1.#ctor(System.Action{System.Threading.AsyncLocalValueChangedArgs{`0}})">
      <summary>Cria uma instância local <see cref="T:System.Threading.AsyncLocal`1" /> que recebe notificações de alteração.</summary>
      <param name="valueChangedHandler">O delegado que é chamado sempre que o valor atual é alterado em qualquer thread.</param>
    </member>
    <member name="P:System.Threading.AsyncLocal`1.Value">
      <summary>Obtém ou define o valor dos dados ambiente.</summary>
      <returns>O valor dos dados de ambiente. Se nenhum valor tiver sido definido, o valor retornado será <c>padrão (T)</c>.</returns>
    </member>
    <member name="T:System.Threading.AsyncLocalValueChangedArgs`1">
      <summary>A classe que fornece informações de alteração de dados para instâncias <see cref="T:System.Threading.AsyncLocal`1" /> que se registram para notificações de alteração.</summary>
      <typeparam name="T">O tipo de dados.</typeparam>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.CurrentValue">
      <summary>Obtém o valor atual dos dados.</summary>
      <returns>O valor atual dos dados.</returns>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.PreviousValue">
      <summary>Obtém o valor anterior dos dados.</summary>
      <returns>O valor anterior dos dados.</returns>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.ThreadContextChanged">
      <summary>Retorna um valor que indica se o valor é alterado devido a uma alteração do contexto de execução.</summary>
      <returns>
        <see langword="true" />Se o valor foi alterado devido a uma alteração de contexto de execução; caso contrário <see langword="false" />,.</returns>
    </member>
    <member name="T:System.Threading.AutoResetEvent">
      <summary>Representa um evento de sincronização de thread que, quando sinalizado, é redefinido automaticamente após a liberação de um thread em espera único. Essa classe não pode ser herdada.</summary>
    </member>
    <member name="M:System.Threading.AutoResetEvent.#ctor(System.Boolean)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.AutoResetEvent" /> com um valor booliano que indica se é necessário definir o estado inicial como sinalizado.</summary>
      <param name="initialState">
        <see langword="true" /> para definir o estado inicial como sinalizado; <see langword="false" /> para defini-lo como não sinalizado.</param>
    </member>
    <member name="T:System.Threading.Barrier">
      <summary>Permite que várias tarefas trabalhem de forma colaborativa em um algoritmo em paralelo por meio de várias fases.</summary>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Barrier" />.</summary>
      <param name="participantCount">O número de threads participantes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="participantCount" /> é menor que 0 ou maior que 32.767.</exception>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32,System.Action{System.Threading.Barrier})">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Barrier" />.</summary>
      <param name="participantCount">O número de threads participantes.</param>
      <param name="postPhaseAction">O <see cref="T:System.Action`1" /> a ser executado após cada fase. null (Nothing no Visual Basic) pode ser passado para indicar que nenhuma ação é executada.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="participantCount" /> é menor que 0 ou maior que 32.767.</exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipant">
      <summary>Notifica o <see cref="T:System.Threading.Barrier" /> de que haverá um participante adicional.</summary>
      <returns>O número de fase da barreira em que os novos participantes participarão primeiro.</returns>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
      <exception cref="T:System.InvalidOperationException">Adicionar um participante fará com que a contagem de participantes da barreira exceda 32.767.
- ou -
O método foi invocado de dentro de uma ação pós-fase.</exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipants(System.Int32)">
      <summary>Notifica o <see cref="T:System.Threading.Barrier" /> de que haverá participantes adicionais.</summary>
      <param name="participantCount">O número de participantes adicionais a serem adicionados à barreira.</param>
      <returns>O número de fase da barreira em que os novos participantes participarão primeiro.</returns>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="participantCount" /> é menor que 0.
- ou -
Adicionar <paramref name="participantCount" /> participantes fará com que a contagem de participantes da barreira exceda 32.767.</exception>
      <exception cref="T:System.InvalidOperationException">O método foi invocado de dentro de uma ação pós-fase.</exception>
    </member>
    <member name="P:System.Threading.Barrier.CurrentPhaseNumber">
      <summary>Obtém o número da fase atual da barreira.</summary>
      <returns>Retorna o número da fase atual da barreira.</returns>
    </member>
    <member name="M:System.Threading.Barrier.Dispose">
      <summary>Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.Barrier" />.</summary>
      <exception cref="T:System.InvalidOperationException">O método foi invocado de dentro de uma ação pós-fase.</exception>
    </member>
    <member name="M:System.Threading.Barrier.Dispose(System.Boolean)">
      <summary>Libera os recursos não gerenciados usados pelo <see cref="T:System.Threading.Barrier" /> e opcionalmente libera os recursos gerenciados.</summary>
      <param name="disposing">true para liberar os recursos gerenciados e não gerenciados; false para liberar somente os recursos não gerenciados.</param>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantCount">
      <summary>Obtém o número total de participantes na barreira.</summary>
      <returns>Retorna o número total de participantes na barreira.</returns>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantsRemaining">
      <summary>Obtém o número de participantes na barreira que ainda não foram sinalizados na fase atual.</summary>
      <returns>Retorna o número de participantes na barreira que ainda não foram sinalizados na fase atual.</returns>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipant">
      <summary>Notifica o <see cref="T:System.Threading.Barrier" /> de que haverá um participante a menos.</summary>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
      <exception cref="T:System.InvalidOperationException">A barreira já tem 0 participantes.
- ou -
O método foi invocado de dentro de uma ação pós-fase.</exception>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipants(System.Int32)">
      <summary>Notifica o <see cref="T:System.Threading.Barrier" /> de que haverá menos participantes.</summary>
      <param name="participantCount">O número de participantes adicionais a serem removidos da barreira.</param>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">A contagem total de participantes é menor que a <paramref name="participantCount" /> especificada</exception>
      <exception cref="T:System.InvalidOperationException">A barreira já tem 0 participantes.
- ou -
O método foi invocado de dentro de uma ação pós-fase.
- ou -
A contagem de participantes atual é menor do que a participantCount especificada</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait">
      <summary>Indica que um participante atingiu a barreira e aguarda até que todos os outros participantes atinjam a barreira também.</summary>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
      <exception cref="T:System.InvalidOperationException">O método foi invocado em uma ação pós-fase, a barreira atualmente tem 0 participantes ou a barreira é sinalizada por um número maior de threads do que os que estão registrados como participantes.</exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException">Se uma exceção for gerada com base na ação pós-fase de um Barrier depois que todos os threads participantes tiverem chamado SignalAndWait, a exceção será encapsulada em um BarrierPostPhaseException e gerada em todos os threads participantes.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32)">
      <summary>Indica que um participante atingiu a barreira e aguarda até que todos os outros participantes atinjam a barreira também, usando um inteiro com sinal de 32 bits para medir o tempo limite.</summary>
      <param name="millisecondsTimeout">O número de milissegundos de espera ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar por tempo indefinido.</param>
      <returns>
        <see langword="true" /> se todos os participantes atingirem a barreira dentro do tempo especificado, caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
      <exception cref="T:System.InvalidOperationException">O método foi invocado em uma ação pós-fase, a barreira atualmente tem 0 participantes ou a barreira é sinalizada por um número maior de threads do que os que estão registrados como participantes.</exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException">Se uma exceção for gerada com base na ação pós-fase de um Barrier depois que todos os threads participantes tiverem chamado SignalAndWait, a exceção será encapsulada em um BarrierPostPhaseException e gerada em todos os threads participantes.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32,System.Threading.CancellationToken)">
      <summary>Indica que um participante atingiu a barreira e aguarda até que todos os outros participantes atinjam a barreira também, usando um inteiro com sinal de 32 bits para medir o tempo limite, enquanto observa um token de cancelamento.</summary>
      <param name="millisecondsTimeout">O número de milissegundos de espera ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar por tempo indefinido.</param>
      <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <returns>se todos os participantes atingirem a barreira dentro do tempo especificado, caso contrário, false</returns>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
      <exception cref="T:System.InvalidOperationException">O método foi invocado em uma ação pós-fase, a barreira atualmente tem 0 participantes ou a barreira é sinalizada por um número maior de threads do que os que estão registrados como participantes.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Threading.CancellationToken)">
      <summary>Indica que um participante atingiu a barreira e aguarda até que todos os outros participantes atinjam a barreira, enquanto observa um token de cancelamento.</summary>
      <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
      <exception cref="T:System.InvalidOperationException">O método foi invocado em uma ação pós-fase, a barreira atualmente tem 0 participantes ou a barreira é sinalizada por um número maior de threads do que os que estão registrados como participantes.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan)">
      <summary>Indica que um participante atingiu a barreira e aguarda até que todos os outros participantes atinjam a barreira também, usando um objeto <see cref="T:System.TimeSpan" /> para medir o intervalo de tempo.</summary>
      <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
      <returns>
        <see langword="true" /> se todos os outros participantes atingirem a barreira, caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito ou é maior que 32.767.</exception>
      <exception cref="T:System.InvalidOperationException">O método foi invocado em uma ação pós-fase, a barreira atualmente tem 0 participantes ou a barreira é sinalizada por um número maior de threads do que os que estão registrados como participantes.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>Indica que um participante atingiu a barreira e aguarda até que todos os outros participantes atinjam a barreira também, usando um objeto <see cref="T:System.TimeSpan" /> para medir o intervalo de tempo, enquanto observa um token de cancelamento.</summary>
      <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
      <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <returns>
        <see langword="true" /> se todos os outros participantes atingirem a barreira, caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.</exception>
      <exception cref="T:System.InvalidOperationException">O método foi invocado em uma ação pós-fase, a barreira atualmente tem 0 participantes ou a barreira é sinalizada por um número maior de threads do que os que estão registrados como participantes.</exception>
    </member>
    <member name="T:System.Threading.BarrierPostPhaseException">
      <summary>A exceção que é lançada quando a ação pós-fase de um <see cref="T:System.Threading.Barrier" /> falha.</summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.BarrierPostPhaseException" /> com uma mensagem fornecida pelo sistema que descreve o erro.</summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Exception)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.BarrierPostPhaseException" /> com a exceção interna especificada.</summary>
      <param name="innerException">A exceção que é a causa da exceção atual.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.BarrierPostPhaseException" /> com dados serializados.</summary>
      <param name="info">O objeto que mantém os dados de objeto serializados.</param>
      <param name="context">As informações contextuais sobre a origem ou o destino.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.BarrierPostPhaseException" /> com uma mensagem especificada que descreve o erro.</summary>
      <param name="message">A mensagem que descreve a exceção. O chamador desse construtor é necessário para garantir que essa cadeia de caracteres tenha sido localizada para a cultura do sistema atual.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String,System.Exception)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.BarrierPostPhaseException" /> com uma mensagem de erro especificada e uma referência à exceção interna que é a causa da exceção.</summary>
      <param name="message">A mensagem que descreve a exceção. O chamador desse construtor é necessário para garantir que essa cadeia de caracteres tenha sido localizada para a cultura do sistema atual.</param>
      <param name="innerException">A exceção que é a causa da exceção atual. Caso o parâmetro <paramref name="innerException" /> não seja <see langword="null" />, a exceção atual é acionada em um bloco <see langword="catch" /> que identifica a exceção interna.</param>
    </member>
    <member name="T:System.Threading.ContextCallback">
      <summary>Representa um método a ser chamado dentro de um novo contexto.</summary>
      <param name="state">Um objeto que contém as informações a serem usadas pelo método de retorno de chamada sempre que ele for executado.</param>
    </member>
    <member name="T:System.Threading.CountdownEvent">
      <summary>Representa um primitivo de sincronização que é sinalizado quando sua contagem atinge zero.</summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.#ctor(System.Int32)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.CountdownEvent" /> com a contagem especificada.</summary>
      <param name="initialCount">O número de sinais inicialmente necessários para definir o <see cref="T:System.Threading.CountdownEvent" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="initialCount" /> é menor que 0.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount">
      <summary>Incrementa a contagem atual de <see cref="T:System.Threading.CountdownEvent" /> em um.</summary>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
      <exception cref="T:System.InvalidOperationException">A instância atual já está definida.
- ou -
<see cref="P:System.Threading.CountdownEvent.CurrentCount" /> é igual a ou maior que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount(System.Int32)">
      <summary>Incrementa a contagem atual de <see cref="T:System.Threading.CountdownEvent" /> em um valor especificado.</summary>
      <param name="signalCount">O valor pelo qual aumentar <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</param>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signalCount" /> é menor ou igual a 0.</exception>
      <exception cref="T:System.InvalidOperationException">A instância atual já está definida.
- ou -
<see cref="P:System.Threading.CountdownEvent.CurrentCount" /> é igual ou maior que <see cref="F:System.Int32.MaxValue" /> depois que a contagem é incrementada em <paramref name="signalCount." /></exception>
    </member>
    <member name="P:System.Threading.CountdownEvent.CurrentCount">
      <summary>Obtém o número de sinais restantes necessárias para definir o evento.</summary>
      <returns>O número de sinais restantes necessários para definir o evento.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose">
      <summary>Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.CountdownEvent" />.</summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose(System.Boolean)">
      <summary>Libera os recursos não gerenciados usados pelo <see cref="T:System.Threading.CountdownEvent" /> e opcionalmente libera os recursos gerenciados.</summary>
      <param name="disposing">true para liberar os recursos gerenciados e não gerenciados; false para liberar somente os recursos não gerenciados.</param>
    </member>
    <member name="P:System.Threading.CountdownEvent.InitialCount">
      <summary>Obtém os números de sinais inicialmente necessários para definir o evento.</summary>
      <returns>O número de sinais inicialmente exigidos para definir o evento.</returns>
    </member>
    <member name="P:System.Threading.CountdownEvent.IsSet">
      <summary>Indica se a contagem atual do objeto <see cref="T:System.Threading.CountdownEvent" /> chegou a zero.</summary>
      <returns>
        <see langword="true" /> se a contagem atual for zero; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset">
      <summary>Redefine o <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> para o valor de <see cref="P:System.Threading.CountdownEvent.InitialCount" />.</summary>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset(System.Int32)">
      <summary>Redefine a propriedade <see cref="P:System.Threading.CountdownEvent.InitialCount" /> com um valor especificado.</summary>
      <param name="count">O número de sinais necessários para definir o <see cref="T:System.Threading.CountdownEvent" />.</param>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> é menor que 0.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal">
      <summary>Registra um sinal com o <see cref="T:System.Threading.CountdownEvent" />, diminuindo o valor de <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</summary>
      <returns>
        <see langword="true" /> se o sinal tiver feito a contagem alcançar zero e o evento tiver sido definido; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
      <exception cref="T:System.InvalidOperationException">A instância atual já está definida.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal(System.Int32)">
      <summary>Registra vários sinais com o <see cref="T:System.Threading.CountdownEvent" />, diminuindo o valor de <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> pelo valor especificado.</summary>
      <param name="signalCount">O número de sinais a serem registrados.</param>
      <returns>
        <see langword="true" /> se os sinais tiverem feito a contagem alcançar zero e o evento tiver sido definido; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signalCount" /> é menor que 1.</exception>
      <exception cref="T:System.InvalidOperationException">A instância atual já está definida. – ou – Ou <paramref name="signalCount" /> é maior que <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount">
      <summary>Tenta incrementar <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> por um.</summary>
      <returns>
        <see langword="true" /> se o incremento foi bem-sucedido, caso contrário, false. Se <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> já estiver em zero, esse método retornará <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> é igual a <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount(System.Int32)">
      <summary>Tenta incrementar <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> em um valor especificado.</summary>
      <param name="signalCount">O valor pelo qual aumentar <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</param>
      <returns>
        <see langword="true" /> se o incremento foi bem-sucedido, caso contrário, false. Se <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> já estiver em zero, isso retornará <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signalCount" /> é menor ou igual a 0.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> + <paramref name="signalCount" /> é igual a ou maior que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait">
      <summary>Bloqueia o thread atual até que o <see cref="T:System.Threading.CountdownEvent" /> seja definido.</summary>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32)">
      <summary>Bloqueia o thread atual até que o <see cref="T:System.Threading.CountdownEvent" /> seja definido, usando um inteiro com sinal de 32 bits para medir o tempo limite.</summary>
      <param name="millisecondsTimeout">O número de milissegundos de espera ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar por tempo indefinido.</param>
      <returns>
        <see langword="true" /> se o <see cref="T:System.Threading.CountdownEvent" /> foi definido; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary>Bloqueia o thread atual até que o <see cref="T:System.Threading.CountdownEvent" /> seja definido, usando um inteiro com sinal de 32 bits para medir o tempo limite, enquanto observa um <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout">O número de milissegundos de espera ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar por tempo indefinido.</param>
      <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <returns>
        <see langword="true" /> se o <see cref="T:System.Threading.CountdownEvent" /> foi definido; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada. – ou – O <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> já foi descartado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Threading.CancellationToken)">
      <summary>Bloqueia o thread atual até que o <see cref="T:System.Threading.CountdownEvent" /> seja definido, enquanto observa um <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada. – ou – O <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> já foi descartado.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan)">
      <summary>Bloqueia o thread atual até que o <see cref="T:System.Threading.CountdownEvent" /> seja definido, usando um <see cref="T:System.TimeSpan" /> para medir o tempo limite.</summary>
      <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
      <returns>
        <see langword="true" /> se o <see cref="T:System.Threading.CountdownEvent" /> foi definido; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> é um número negativo diferente de -1 milissegundos, que representa um tempo limite infinito ou o tempo limite é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>Bloqueia o thread atual até que o <see cref="T:System.Threading.CountdownEvent" /> seja definido, usando um <see cref="T:System.TimeSpan" /> para medir o tempo limite, enquanto observa um <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
      <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <returns>
        <see langword="true" /> se o <see cref="T:System.Threading.CountdownEvent" /> foi definido; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada. – ou – O <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> já foi descartado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> é um número negativo diferente de -1 milissegundos, que representa um tempo limite infinito ou o tempo limite é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="P:System.Threading.CountdownEvent.WaitHandle">
      <summary>Obtém um <see cref="T:System.Threading.WaitHandle" /> que é usado para aguardar o evento a ser definido.</summary>
      <returns>Um <see cref="T:System.Threading.WaitHandle" /> que é usado para aguardar a definição do evento.</returns>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
    </member>
    <member name="T:System.Threading.EventResetMode">
      <summary>Indica se um <see cref="T:System.Threading.EventWaitHandle" /> é redefinido de forma automática ou manual após receber um sinal.</summary>
    </member>
    <member name="F:System.Threading.EventResetMode.AutoReset">
      <summary>Quando sinalizado, o <see cref="T:System.Threading.EventWaitHandle" /> é redefinido automaticamente após o lançamento de um único thread. Se nenhum thread estiver aguardando, o <see cref="T:System.Threading.EventWaitHandle" /> permanece sinalizado até que um thread seja bloqueado e é redefinido após a liberação do thread.</summary>
    </member>
    <member name="F:System.Threading.EventResetMode.ManualReset">
      <summary>Quando sinalizado, o <see cref="T:System.Threading.EventWaitHandle" /> libera todos os threads em espera e permanece sinalizado até ser redefinido manualmente.</summary>
    </member>
    <member name="T:System.Threading.EventWaitHandle">
      <summary>Representa um evento de sincronização de thread.</summary>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.EventWaitHandle" />, especificando se o identificador de espera é sinalizado inicialmente e se ele redefine automática ou manualmente.</summary>
      <param name="initialState">
        <see langword="true" /> para definir o estado inicial como sinalizado; <see langword="false" /> para defini-lo como não sinalizado.</param>
      <param name="mode">Um dos valores <see cref="T:System.Threading.EventResetMode" /> que determina se o evento redefine automática ou manualmente.</param>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.EventWaitHandle" />, especificando se o identificador de espera é sinalizado inicialmente se for criado como resultado dessa chamada, se ele é redefinido manual ou automaticamente e o nome de um evento de sincronização do sistema.</summary>
      <param name="initialState">
        <see langword="true" /> para definir o estado inicial como sinalizado se o evento nomeado for criado como resultado dessa chamada, <see langword="false" /> para defini-lo como não sinalizado.</param>
      <param name="mode">Um dos valores <see cref="T:System.Threading.EventResetMode" /> que determina se o evento redefine automática ou manualmente.</param>
      <param name="name">O nome de um evento de sincronização de todo o sistema.</param>
      <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">O evento nomeado existe e tem segurança de controle de acesso, mas o usuário não tem <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Não foi possível criar o evento nomeado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> tem mais de 260 caracteres.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.EventWaitHandle" />, especificando se o identificador de espera é sinalizado inicialmente se for criado como resultado dessa chamada, se ele é redefinido manual ou automaticamente, o nome de um evento de sincronização do sistema e uma variável booliana cujo valor após a chamada indica se o evento de sistema nomeado foi criado.</summary>
      <param name="initialState">
        <see langword="true" /> para definir o estado inicial como sinalizado se o evento nomeado for criado como resultado dessa chamada, <see langword="false" /> para defini-lo como não sinalizado.</param>
      <param name="mode">Um dos valores <see cref="T:System.Threading.EventResetMode" /> que determina se o evento redefine automática ou manualmente.</param>
      <param name="name">O nome de um evento de sincronização de todo o sistema.</param>
      <param name="createdNew">Quando esse método for retornado, conterá <see langword="true" /> se um evento local tiver sido criado (ou seja, se <paramref name="name" /> for <see langword="null" /> ou uma cadeia de caracteres vazia) ou se o evento de sistema nomeado especificado tiver sido criado; <see langword="false" /> se o evento de sistema nomeado especificado já existia. Este parâmetro é passado não inicializado.</param>
      <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">O evento nomeado existe e tem segurança de controle de acesso, mas o usuário não tem <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Não foi possível criar o evento nomeado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> tem mais de 260 caracteres.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
      <summary>Abre o evento de sincronização nomeado especificado, caso ele já exista.</summary>
      <param name="name">O nome do evento de sincronização de sistema a ser aberto.</param>
      <returns>Um objeto que representa o evento do sistema nomeado.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> é uma cadeia de caracteres vazia.
-ou-
<paramref name="name" /> tem mais de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">O evento do sistema nomeado não existe.</exception>
      <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">O evento nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Reset">
      <summary>Define o estado do evento como não sinalizado, fazendo com que os threads sejam bloqueados.</summary>
      <returns>
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">O método <see cref="M:System.Threading.WaitHandle.Close" /> foi chamado anteriormente neste <see cref="T:System.Threading.EventWaitHandle" />.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Set">
      <summary>Define o estado do evento a ser sinalizado, permitindo que um ou mais threads de espera prossigam.</summary>
      <returns>
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">O método <see cref="M:System.Threading.WaitHandle.Close" /> foi chamado anteriormente neste <see cref="T:System.Threading.EventWaitHandle" />.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
      <summary>Abre o evento de sincronização nomeado especificado, se ele já existir e retorna um valor que indica se a operação foi bem-sucedida.</summary>
      <param name="name">O nome do evento de sincronização de sistema a ser aberto.</param>
      <param name="result">Quando é retornado, esse método contém um objeto <see cref="T:System.Threading.EventWaitHandle" /> que representa o evento de sincronização nomeado se a chamada tiver sido bem-sucedida ou <see langword="null" /> se a chamada tiver falhado. Esse parâmetro é tratado como não inicializado.</param>
      <returns>
        <see langword="true" /> se o evento de sincronização nomeado foi aberto com êxito; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> é uma cadeia de caracteres vazia.
-ou-
<paramref name="name" /> tem mais de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">O evento nomeado existe, mas o usuário não tem o acesso de segurança desejado.</exception>
    </member>
    <member name="T:System.Threading.ExecutionContext">
      <summary>Gerencia o contexto de execução do thread atual. Essa classe não pode ser herdada.</summary>
    </member>
    <member name="M:System.Threading.ExecutionContext.Capture">
      <summary>Captura o contexto de execução do thread atual.</summary>
      <returns>Um objeto <see cref="T:System.Threading.ExecutionContext" /> que representa o contexto de execução do thread atual.</returns>
    </member>
    <member name="M:System.Threading.ExecutionContext.CreateCopy">
      <summary>Cria uma cópia do contexto de execução atual.</summary>
      <returns>Um objeto <see cref="T:System.Threading.ExecutionContext" /> que representa o contexto de execução atual.</returns>
      <exception cref="T:System.InvalidOperationException">Não é possível copiar neste contexto porque ele é usado. Apenas contextos recém-capturados podem ser copiados.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.Dispose">
      <summary>Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.ExecutionContext" />.</summary>
    </member>
    <member name="M:System.Threading.ExecutionContext.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Define o objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> especificado com as informações lógicas do contexto necessárias para recriar uma instância do contexto de execução atual.</summary>
      <param name="info">O objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> a ser preenchido com informações de serialização.</param>
      <param name="context">A estrutura <see cref="T:System.Runtime.Serialization.StreamingContext" /> que representa o contexto de destino da serialização.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="info" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.IsFlowSuppressed">
      <summary>Indica se o fluxo do contexto de execução está suprimido no momento.</summary>
      <returns>
        <see langword="true" /> se o fluxo for suprimido; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ExecutionContext.RestoreFlow">
      <summary>Restaura o fluxo do contexto de execução em threads assíncronos.</summary>
      <exception cref="T:System.InvalidOperationException">O fluxo do contexto não pode ser restaurado porque não está sendo suprimido.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)">
      <summary>Executa um método em um contexto de execução especificado no thread atual.</summary>
      <param name="executionContext">
        <see cref="T:System.Threading.ExecutionContext" /> ao dataset.</param>
      <param name="callback">Um <see cref="T:System.Threading.ContextCallback" /> delegado que representa o método a ser executado no contexto de execução fornecido.</param>
      <param name="state">O objeto a passar para o método de retorno de chamada.</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="executionContext" /> é <see langword="null" />.
- ou -
<paramref name="executionContext" /> não foi adquirido por meio de uma operação de captura.
- ou -
<paramref name="executionContext" /> já foi usado como argumento para uma chamada <see cref="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)" />.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.SuppressFlow">
      <summary>Suprime o fluxo do contexto de execução em threads assíncronos.</summary>
      <returns>Uma estrutura <see cref="T:System.Threading.AsyncFlowControl" /> para restaurar o fluxo.</returns>
      <exception cref="T:System.InvalidOperationException">O fluxo do contexto já está suprimido.</exception>
    </member>
    <member name="T:System.Threading.HostExecutionContext">
      <summary>Encapsula e propaga o contexto de execução do host em threads.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.#ctor">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.HostExecutionContext" />.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.#ctor(System.Object)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.HostExecutionContext" /> usando o estado especificado.</summary>
      <param name="state">Um objeto que representa o estado do contexto de execução do host.</param>
    </member>
    <member name="M:System.Threading.HostExecutionContext.CreateCopy">
      <summary>Cria uma cópia do contexto de execução do host atual.</summary>
      <returns>Um objeto <see cref="T:System.Threading.HostExecutionContext" /> que representa o contexto do host para o thread atual.</returns>
    </member>
    <member name="M:System.Threading.HostExecutionContext.Dispose">
      <summary>Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.HostExecutionContext" />.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.Dispose(System.Boolean)">
      <summary>Quando substituído em uma classe derivada, libera os recursos não gerenciados usados pelo <see cref="T:System.Threading.WaitHandle" /> e, opcionalmente, libera os recursos gerenciados.</summary>
      <param name="disposing">
        <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
    </member>
    <member name="P:System.Threading.HostExecutionContext.State">
      <summary>Obtém ou define o estado do contexto de execução do host.</summary>
      <returns>Um objeto que representa o estado do contexto de execução do host.</returns>
    </member>
    <member name="T:System.Threading.HostExecutionContextManager">
      <summary>Fornece a funcionalidade que permite que um host Common Language Runtime participe do fluxo ou migração do contexto de execução.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.#ctor">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.HostExecutionContextManager" />.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.Capture">
      <summary>Captura o contexto de execução do host do thread atual.</summary>
      <returns>Um objeto <see cref="T:System.Threading.HostExecutionContext" /> que representa o contexto de execução do host do thread atual.</returns>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.Revert(System.Object)">
      <summary>Restaura o contexto de execução do host para seu estado anterior.</summary>
      <param name="previousState">O estado de contexto anterior para o qual reverter.</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="previousState" /> é <see langword="null" />.
- ou -
<paramref name="previousState" /> não foi criado no thread atual.
- ou -
<paramref name="previousState" /> não é o último estado para o <see cref="T:System.Threading.HostExecutionContext" />.</exception>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)">
      <summary>Define o contexto de execução do host atual para o contexto de execução do host especificado.</summary>
      <param name="hostExecutionContext">O <see cref="T:System.Threading.HostExecutionContext" /> a ser definido.</param>
      <returns>Um objeto para restaurar o <see cref="T:System.Threading.HostExecutionContext" /> a seu estado anterior.</returns>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="hostExecutionContext" /> não foi adquirido por meio de uma operação de captura.
- ou -
<paramref name="hostExecutionContext" /> tem sido o argumento para uma chamada de método <see cref="M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)" /> anterior.</exception>
    </member>
    <member name="T:System.Threading.Interlocked">
      <summary>Fornece operações atômicas para variáveis que são compartilhadas por vários threads.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
      <summary>Adiciona dois números inteiros de 32 bits e substitui o primeiro inteiro com a soma, como uma operação atômica.</summary>
      <param name="location1">Uma variável que contém o primeiro valor a ser adicionado. A soma dos dois valores é armazenada em <paramref name="location1" />.</param>
      <param name="value">O valor a ser adicionado ao inteiro em <paramref name="location1" />.</param>
      <returns>O novo valor armazenado em <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
      <summary>Adiciona dois números inteiros de 64 bits e substitui o primeiro inteiro com a soma, como uma operação atômica.</summary>
      <param name="location1">Uma variável que contém o primeiro valor a ser adicionado. A soma dos dois valores é armazenada em <paramref name="location1" />.</param>
      <param name="value">O valor a ser adicionado ao inteiro em <paramref name="location1" />.</param>
      <returns>O novo valor armazenado em <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
      <summary>Compara se dois pontos flutuantes de precisão dupla são iguais e, se eles forem, substitui o primeiro valor.</summary>
      <param name="location1">O destino, cujo valor é comparado com <paramref name="comparand" /> e possivelmente substituído.</param>
      <param name="value">O valor que substitui o valor de destino quando a comparação resulta em igualdade.</param>
      <param name="comparand">O valor comparado ao valor em <paramref name="location1" />.</param>
      <returns>O valor original em <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
      <summary>Compara dois inteiros com sinal de 32 bits para verificar se são iguais e, em caso de igualdade, substitui o primeiro valor.</summary>
      <param name="location1">O destino, cujo valor é comparado com <paramref name="comparand" /> e possivelmente substituído.</param>
      <param name="value">O valor que substitui o valor de destino quando a comparação resulta em igualdade.</param>
      <param name="comparand">O valor comparado ao valor em <paramref name="location1" />.</param>
      <returns>O valor original em <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
      <summary>Compara dois inteiros com sinal de 64 bits para verificar se são iguais e, em caso de igualdade, substitui o primeiro valor.</summary>
      <param name="location1">O destino, cujo valor é comparado com <paramref name="comparand" /> e possivelmente substituído.</param>
      <param name="value">O valor que substitui o valor de destino quando a comparação resulta em igualdade.</param>
      <param name="comparand">O valor comparado ao valor em <paramref name="location1" />.</param>
      <returns>O valor original em <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
      <summary>Compara dois ponteiros ou identificadores específicos da plataforma quanto à igualdade e, se eles são iguais, substitui o primeiro.</summary>
      <param name="location1">O <see cref="T:System.IntPtr" /> de destino, cujo valor é comparado com o valor de <paramref name="comparand" /> e possivelmente substituído por <paramref name="value" />.</param>
      <param name="value">O <see cref="T:System.IntPtr" /> que substitui o valor de destino quando a comparação resulta em igualdade.</param>
      <param name="comparand">O <see cref="T:System.IntPtr" /> comparado ao valor em <paramref name="location1" />.</param>
      <returns>O valor original em <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
      <summary>Compara dois objetos quanto à igualdade de referência e, se eles forem iguais, substitui o primeiro objeto.</summary>
      <param name="location1">O objeto de destino que é comparado pela referência com <paramref name="comparand" /> e possivelmente substituído.</param>
      <param name="value">O objeto que substitui o objeto de destino quando a comparação de referência resulta em igualdade.</param>
      <param name="comparand">O objeto que é comparado pela referência ao objeto em <paramref name="location1" />.</param>
      <returns>O valor original em <paramref name="location1" />.</returns>
      <exception cref="T:System.ArgumentNullException">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
      <summary>Compara se dois números de ponto flutuante de precisão simples são iguais e, se eles são, substitui o primeiro valor.</summary>
      <param name="location1">O destino, cujo valor é comparado com <paramref name="comparand" /> e possivelmente substituído.</param>
      <param name="value">O valor que substitui o valor de destino quando a comparação resulta em igualdade.</param>
      <param name="comparand">O valor comparado ao valor em <paramref name="location1" />.</param>
      <returns>O valor original em <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
      <summary>Compara duas instâncias do tipo de referência <paramref name="T" /> especificado em relação à igualdade e, se elas forem iguais, substitui a primeira.</summary>
      <param name="location1">O destino, cujo valor é comparado por referência com <paramref name="comparand" /> e possivelmente substituído. Esse é um parâmetro de referência (<see langword="ref" /> no C# e <see langword="ByRef" /> no Visual Basic).</param>
      <param name="value">O valor que substitui o valor de destino quando a comparação pela referência resulta em igualdade.</param>
      <param name="comparand">O valor que é comparado pela referência com o valor em <paramref name="location1" />.</param>
      <typeparam name="T">O tipo a ser usado para <paramref name="location1" />, <paramref name="value" /> e <paramref name="comparand" />. Esse tipo deve ser um tipo de referência.</typeparam>
      <returns>O valor original em <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int32@)">
      <summary>Decrementa uma variável especificada e armazena o resultado, como uma operação atômica.</summary>
      <param name="location">A variável cujo valor deve ser decrementado.</param>
      <returns>O valor decrementado.</returns>
      <exception cref="T:System.ArgumentNullException">O endereço de <paramref name="location" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int64@)">
      <summary>Diminui uma variável especificada e armazena o resultado como uma operação atômica.</summary>
      <param name="location">A variável cujo valor deve ser decrementado.</param>
      <returns>O valor decrementado.</returns>
      <exception cref="T:System.ArgumentNullException">O endereço de <paramref name="location" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
      <summary>Define um número de ponto flutuante de precisão dupla para um valor especificado e retorna o valor original, como uma operação atômica.</summary>
      <param name="location1">A variável a ser definida com o valor especificado.</param>
      <param name="value">O valor para o qual o parâmetro <paramref name="location1" /> é definido.</param>
      <returns>O valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
      <summary>Define um inteiro com sinal de 32 bits com um valor especificado e retorna o valor original, como uma operação atômica.</summary>
      <param name="location1">A variável a ser definida com o valor especificado.</param>
      <param name="value">O valor para o qual o parâmetro <paramref name="location1" /> é definido.</param>
      <returns>O valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.ArgumentNullException">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
      <summary>Define um inteiro com sinal de 64 bits com um valor especificado e retorna o valor original, como uma operação atômica.</summary>
      <param name="location1">A variável a ser definida com o valor especificado.</param>
      <param name="value">O valor para o qual o parâmetro <paramref name="location1" /> é definido.</param>
      <returns>O valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
      <summary>Define um identificador específico de plataforma ou um ponteiro para um valor especificado e retorna o valor original como uma operação atômica.</summary>
      <param name="location1">A variável a ser definida com o valor especificado.</param>
      <param name="value">O valor para o qual o parâmetro <paramref name="location1" /> é definido.</param>
      <returns>O valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
      <summary>Define um objeto com um valor especificado e retorna uma referência ao objeto original, como uma operação atômica.</summary>
      <param name="location1">A variável a ser definida com o valor especificado.</param>
      <param name="value">O valor para o qual o parâmetro <paramref name="location1" /> é definido.</param>
      <returns>O valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.ArgumentNullException">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
      <summary>Define um número de ponto flutuante de precisão simples para um valor especificado e retorna o valor original como uma operação atômica.</summary>
      <param name="location1">A variável a ser definida com o valor especificado.</param>
      <param name="value">O valor para o qual o parâmetro <paramref name="location1" /> é definido.</param>
      <returns>O valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
      <summary>Define uma variável do tipo <paramref name="T" /> especificado como um valor especificado e retorna o valor original como uma operação atômica.</summary>
      <param name="location1">A variável a ser definida com o valor especificado. Esse é um parâmetro de referência (<see langword="ref" /> no C# e <see langword="ByRef" /> no Visual Basic).</param>
      <param name="value">O valor para o qual o parâmetro <paramref name="location1" /> é definido.</param>
      <typeparam name="T">O tipo a ser usado para o <paramref name="location1" /> e <paramref name="value" />. Esse tipo deve ser um tipo de referência.</typeparam>
      <returns>O valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.Int32@)">
      <summary>Incrementa uma variável especificada e armazena o resultado, como uma operação atômica.</summary>
      <param name="location">A variável cujo valor deve ser incrementado.</param>
      <returns>O valor incrementado.</returns>
      <exception cref="T:System.NullReferenceException">O endereço de <paramref name="location" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.Int64@)">
      <summary>Incrementa uma variável especificada e armazena o resultado, como uma operação atômica.</summary>
      <param name="location">A variável cujo valor deve ser incrementado.</param>
      <returns>O valor incrementado.</returns>
      <exception cref="T:System.NullReferenceException">O endereço de <paramref name="location" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.MemoryBarrier">
      <summary>Sincroniza o acesso à memória da seguinte maneira: o processador que executa o thread atual não pode reorganizar as instruções de forma que os acessos à memória anteriores à chamada para <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> sejam executados depois dos acessos à memória posteriores à chamada para <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.MemoryBarrierProcessWide">
      <summary>Fornece uma barreira de memória em todo o processo, que garante que leituras e gravações de qualquer CPU não possam se mover pela barreira.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.Read(System.Int64@)">
      <summary>Retorna um valor de 64 bits, carregado como uma operação atômica.</summary>
      <param name="location">O valor de 64 bits a ser carregado.</param>
      <returns>O valor carregado.</returns>
    </member>
    <member name="T:System.Threading.LazyInitializer">
      <summary>Fornece rotinas de inicialização lentas.</summary>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
      <summary>Inicializa um tipo de referência de destino com o construtor sem parâmetro de tipo se ele ainda não foi inicializado.</summary>
      <param name="target">Uma referência para inicializar se ela ainda não tiver sido inicializada.</param>
      <typeparam name="T">O tipo da referência a ser inicializada.</typeparam>
      <returns>O objeto inicializado.</returns>
      <exception cref="T:System.MemberAccessException">Permissões para acessar o construtor do tipo <paramref name="T" /> estavam ausentes.</exception>
      <exception cref="T:System.MissingMemberException">O tipo <paramref name="T" /> não tem um construtor sem parâmetros.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
      <summary>Inicializa uma referência de destino ou um tipo de valor com seu construtor sem parâmetro se ele ainda não foi inicializado.</summary>
      <param name="target">Uma referência ou um valor do tipo <c>T</c> a ser inicializado se já não tiver sido inicializado.</param>
      <param name="initialized">Uma referência a um valor booliano que determina se o destino já foi inicializado.</param>
      <param name="syncLock">Uma referência a um objeto usado como o bloqueio mutuamente exclusivo para inicializar <paramref name="target" />. Se <paramref name="syncLock" /> for <see langword="null" />, será criada uma instância de um novo objeto.</param>
      <typeparam name="T">O tipo da referência a ser inicializada.</typeparam>
      <returns>O objeto inicializado.</returns>
      <exception cref="T:System.MemberAccessException">Permissões para acessar o construtor do tipo <paramref name="T" /> estavam ausentes.</exception>
      <exception cref="T:System.MissingMemberException">O tipo <paramref name="T" /> não tem um construtor sem parâmetros.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
      <summary>Inicializa um tipo de valor ou referência de destino usando uma função especificadas se ainda não tiver sido inicializada.</summary>
      <param name="target">Uma referência ou um valor do tipo <c>T</c> a ser inicializado se já não tiver sido inicializado.</param>
      <param name="initialized">Uma referência a um valor booliano que determina se o destino já foi inicializado.</param>
      <param name="syncLock">Uma referência a um objeto usado como o bloqueio mutuamente exclusivo para inicializar <paramref name="target" />. Se <paramref name="syncLock" /> for <see langword="null" />, será criada uma instância de um novo objeto.</param>
      <param name="valueFactory">A função que é chamada para inicializar a referência ou valor.</param>
      <typeparam name="T">O tipo da referência a ser inicializada.</typeparam>
      <returns>O objeto inicializado.</returns>
      <exception cref="T:System.MemberAccessException">Permissões para acessar o construtor do tipo <paramref name="T" /> estavam ausentes.</exception>
      <exception cref="T:System.MissingMemberException">O tipo <paramref name="T" /> não tem um construtor sem parâmetros.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
      <summary>Inicializa um tipo de referência de destino usando uma função especificadas se ainda não tiver sido inicializada.</summary>
      <param name="target">Uma referência a ser inicializada se ainda não tiver sido.</param>
      <param name="valueFactory">A função que é chamada para inicializar a referência.</param>
      <typeparam name="T">O tipo da referência a ser inicializada.</typeparam>
      <returns>O objeto inicializado.</returns>
      <exception cref="T:System.MissingMemberException">O tipo <paramref name="T" /> não tem um construtor sem parâmetros.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="valueFactory" /> retornou null (Nothing no Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Object@,System.Func{``0})">
      <summary>Inicializará um tipo de referência de destino com uma função especificada se ainda não tiver sido inicializado.</summary>
      <param name="target">Uma referência para inicializar se ela ainda não tiver sido inicializada.</param>
      <param name="syncLock">Uma referência a um objeto usado como o bloqueio mutuamente exclusivo para inicializar <paramref name="target" />. Se <paramref name="syncLock" /> for <see langword="null" />, será criada uma instância de um novo objeto.</param>
      <param name="valueFactory">O método a ser invocado para inicializar <paramref name="target" />.</param>
      <typeparam name="T">O tipo da referência a ser inicializada.</typeparam>
      <returns>O objeto inicializado.</returns>
    </member>
    <member name="T:System.Threading.LockCookie">
      <summary>Define o bloqueio que implementa a semântica de único gravador/vários leitores. Este é um tipo de valor.</summary>
    </member>
    <member name="M:System.Threading.LockCookie.Equals(System.Object)">
      <summary>Indica se o objeto especificado é um <see cref="T:System.Threading.LockCookie" /> e é igual à instância atual.</summary>
      <param name="obj">O objeto a ser comparado com a instância atual.</param>
      <returns>
        <see langword="true" /> se o valor de <paramref name="obj" /> for igual ao valor da instância atual; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.Equals(System.Threading.LockCookie)">
      <summary>Indica se a instância atual é igual ao <see cref="T:System.Threading.LockCookie" /> especificado.</summary>
      <param name="obj">O <see cref="T:System.Threading.LockCookie" /> a ser comparado com a instância atual.</param>
      <returns>
        <see langword="true" /> se <paramref name="obj" /> é igual ao valor da instância atual; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.GetHashCode">
      <summary>Retorna o código hash para essa instância.</summary>
      <returns>Um código de hash do inteiro assinado de 32 bits.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.op_Equality(System.Threading.LockCookie,System.Threading.LockCookie)">
      <summary>Indica se duas estruturas <see cref="T:System.Threading.LockCookie" /> são iguais.</summary>
      <param name="a">O <see cref="T:System.Threading.LockCookie" /> para comparar com <paramref name="b" />.</param>
      <param name="b">O <see cref="T:System.Threading.LockCookie" /> para comparar com <paramref name="a" />.</param>
      <returns>
        <see langword="true" /> se <paramref name="a" /> for igual a <paramref name="b" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.op_Inequality(System.Threading.LockCookie,System.Threading.LockCookie)">
      <summary>Indica se duas estruturas <see cref="T:System.Threading.LockCookie" /> não são iguais.</summary>
      <param name="a">O <see cref="T:System.Threading.LockCookie" /> para comparar com <paramref name="b" />.</param>
      <param name="b">O <see cref="T:System.Threading.LockCookie" /> para comparar com <paramref name="a" />.</param>
      <returns>
        <see langword="true" /> se <paramref name="a" /> não for igual a <paramref name="b" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.LockRecursionException">
      <summary>A exceção que é lançada quando a entrada recursiva em um bloqueio não é compatível com a política de recursão para o bloqueio.</summary>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.LockRecursionException" /> com uma mensagem fornecida pelo sistema que descreve o erro.</summary>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.LockRecursionException" /> com dados serializados.</summary>
      <param name="info">O objeto que mantém os dados de objeto serializados.</param>
      <param name="context">As informações contextuais sobre a origem ou o destino.</param>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.String)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.LockRecursionException" /> com uma mensagem especificada que descreve o erro.</summary>
      <param name="message">A mensagem que descreve a exceção. O chamador desse construtor deve garantir que essa cadeia de caracteres tenha sido localizada para a cultura do sistema atual.</param>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.String,System.Exception)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.LockRecursionException" /> com uma mensagem de erro especificada e uma referência à exceção interna que é a causa da exceção.</summary>
      <param name="message">A mensagem que descreve a exceção. O chamador desse construtor deve garantir que essa cadeia de caracteres tenha sido localizada para a cultura do sistema atual.</param>
      <param name="innerException">A exceção que causou a exceção atual. Caso o parâmetro <paramref name="innerException" /> não seja <see langword="null" />, a exceção atual é acionada em um bloco <see langword="catch" /> que identifica a exceção interna.</param>
    </member>
    <member name="T:System.Threading.LockRecursionPolicy">
      <summary>Especifica se um bloqueio pode ser inserido várias vezes pelo mesmo thread.</summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.NoRecursion">
      <summary>Se um thread tentar inserir um bloqueio recursivamente, uma exceção será lançada. Algumas classes podem permitir determinadas recursões quando essa configuração está em vigor.</summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.SupportsRecursion">
      <summary>Um thread pode inserir um bloqueio recursivamente. Algumas classes podem restringir essa funcionalidade.</summary>
    </member>
    <member name="T:System.Threading.ManualResetEvent">
      <summary>Representa um evento de sincronização de thread que, quando sinalizado, deve ser redefinido manualmente. Essa classe não pode ser herdada.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEvent.#ctor(System.Boolean)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.ManualResetEvent" /> com um valor booliano que indica se é necessário definir o estado inicial como sinalizado.</summary>
      <param name="initialState">
        <see langword="true" /> para definir o estado inicial como sinalizado; <see langword="false" /> para defini-lo como não sinalizado.</param>
    </member>
    <member name="T:System.Threading.ManualResetEventSlim">
      <summary>Representa um evento de sincronização de thread que, quando sinalizado, deve ser redefinido manualmente. Esta classe é uma alternativa leve para <see cref="T:System.Threading.ManualResetEvent" />.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.ManualResetEventSlim" /> com um estado inicial de não sinalizado.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.ManualResetEventSlim" /> com um valor booliano que indica se é necessário definir o estado inicial como sinalizado.</summary>
      <param name="initialState">true para definir o estado inicial como sinalizado; false para defini-lo como não sinalizado.</param>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean,System.Int32)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.ManualResetEventSlim" /> com um valor booliano que indica se é necessário definir o estado inicial como sinalizado e uma contagem de rotação especificada.</summary>
      <param name="initialState">true para definir o estado inicial como sinalizado; false para defini-lo como não sinalizado.</param>
      <param name="spinCount">O número de esperas de rotação que ocorrerão antes de retornar para uma operação de espera com base em kernel.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="spinCount" /> é menor que 0 ou maior que o valor máximo permitido.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose">
      <summary>Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.ManualResetEventSlim" />.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose(System.Boolean)">
      <summary>Libera os recursos não gerenciados usados pelo <see cref="T:System.Threading.ManualResetEventSlim" /> e opcionalmente libera os recursos gerenciados.</summary>
      <param name="disposing">true para liberar os recursos gerenciados e não gerenciados; false para liberar somente os recursos não gerenciados.</param>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.IsSet">
      <summary>Descobre se o evento está definido.</summary>
      <returns>true se o evento for definido; caso contrário, false.</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Reset">
      <summary>Define o estado do evento como não sinalizado, o que causa o bloqueio dos threads.</summary>
      <exception cref="T:System.ObjectDisposedException">O objeto já foi descartado.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Set">
      <summary>Define o estado do evento a ser sinalizado, que permite que um ou mais threads aguardem a continuação do evento.</summary>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.SpinCount">
      <summary>Obtém o número de esperas de rotação que ocorrerão antes de retornar para uma operação de espera com base em kernel.</summary>
      <returns>Retorna o número de esperas de rotação que ocorrerão antes de fazer fallback para uma operação de espera baseada em kernel.</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait">
      <summary>Bloqueia o thread atual até que o <see cref="T:System.Threading.ManualResetEventSlim" /> seja definido.</summary>
      <exception cref="T:System.InvalidOperationException">O número máximo de erros foi excedido.</exception>
      <exception cref="T:System.ObjectDisposedException">O objeto já foi descartado.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32)">
      <summary>Bloqueia o thread atual até que o <see cref="T:System.Threading.ManualResetEventSlim" /> atual seja definido, usando um inteiro com sinal de 32 bits para medir o intervalo de tempo.</summary>
      <param name="millisecondsTimeout">O número de milissegundos de espera ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar por tempo indefinido.</param>
      <returns>
        <see langword="true" /> se o <see cref="T:System.Threading.ManualResetEventSlim" /> foi definido; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
      <exception cref="T:System.InvalidOperationException">O número máximo de erros foi excedido.</exception>
      <exception cref="T:System.ObjectDisposedException">O objeto já foi descartado.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary>Bloqueia o thread atual até que o <see cref="T:System.Threading.ManualResetEventSlim" /> atual seja definido, usando um inteiro com sinal de 32 bits para medir o intervalo de tempo, enquanto observa um <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout">O número de milissegundos de espera ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar por tempo indefinido.</param>
      <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <returns>
        <see langword="true" /> se o <see cref="T:System.Threading.ManualResetEventSlim" /> foi definido; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException">O <paramref name="cancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
      <exception cref="T:System.InvalidOperationException">O número máximo de erros foi excedido.</exception>
      <exception cref="T:System.ObjectDisposedException">O objeto já foi descartado ou o <see cref="T:System.Threading.CancellationTokenSource" /> que criou o <paramref name="cancellationToken" /> foi descartado.</exception>
      <exception cref="T:System.OperationCanceledException">O <paramref name="cancellationToken" /> foi cancelado.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Threading.CancellationToken)">
      <summary>Bloqueia o thread atual até que o <see cref="T:System.Threading.ManualResetEventSlim" /> atual receba um sinal, enquanto observa um <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <exception cref="T:System.InvalidOperationException">O número máximo de erros foi excedido.</exception>
      <exception cref="T:System.OperationCanceledException">O <paramref name="cancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ObjectDisposedException">O objeto já foi descartado ou o <see cref="T:System.Threading.CancellationTokenSource" /> que criou o <paramref name="cancellationToken" /> foi descartado.</exception>
      <exception cref="T:System.OperationCanceledException">O <paramref name="cancellationToken" /> foi cancelado.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan)">
      <summary>Bloqueia o thread atual até que o <see cref="T:System.Threading.ManualResetEventSlim" /> atual seja definido, usando um <see cref="T:System.TimeSpan" /> para medir o intervalo de tempo.</summary>
      <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
      <returns>
        <see langword="true" /> se o <see cref="T:System.Threading.ManualResetEventSlim" /> foi definido; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.
- ou -
O número de milissegundos em <paramref name="timeout" /> é maior do que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException">O número máximo de erros foi excedido.</exception>
      <exception cref="T:System.ObjectDisposedException">O objeto já foi descartado.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>Bloqueia o thread atual até que o <see cref="T:System.Threading.ManualResetEventSlim" /> atual seja definido, usando um <see cref="T:System.TimeSpan" /> para medir o intervalo de tempo, enquanto observa um <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
      <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <returns>
        <see langword="true" /> se o <see cref="T:System.Threading.ManualResetEventSlim" /> foi definido; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException">O <paramref name="cancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.
- ou -
O número de milissegundos em <paramref name="timeout" /> é maior do que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException">O número máximo de erros foi excedido.</exception>
      <exception cref="T:System.ObjectDisposedException">O objeto já foi descartado ou o <see cref="T:System.Threading.CancellationTokenSource" /> que criou o <paramref name="cancellationToken" /> foi descartado.</exception>
      <exception cref="T:System.OperationCanceledException">O <paramref name="cancellationToken" /> foi cancelado.</exception>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.WaitHandle">
      <summary>Obtém o objeto <see cref="T:System.Threading.WaitHandle" /> subjacente para este <see cref="T:System.Threading.ManualResetEventSlim" />.</summary>
      <returns>O objeto de evento <see cref="T:System.Threading.WaitHandle" /> subjacente deste <see cref="T:System.Threading.ManualResetEventSlim" />.</returns>
    </member>
    <member name="T:System.Threading.Monitor">
      <summary>Fornece um mecanismo que sincroniza o acesso a objetos.</summary>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object)">
      <summary>Adquire um bloqueio exclusivo no objeto especificado.</summary>
      <param name="obj">O objeto no qual adquirir o bloqueio do monitor.</param>
      <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
      <summary>Obtém um bloqueio exclusivo no objeto especificado e define automaticamente um valor que indica se o bloqueio foi realizado.</summary>
      <param name="obj">O objeto no qual aguardar.</param>
      <param name="lockTaken">O resultado da tentativa de adquirir o bloqueio, passado por referência. A entrada deve ser <see langword="false" />. A saída será <see langword="true" /> se o bloqueio for adquirido; caso contrário, a saída será <see langword="false" />. A saída é definida mesmo se ocorrer uma exceção durante a tentativa de adquirir o bloqueio.
Observação   Se não nenhuma exceção ocorrer, a saída desse método sempre será <see langword="true" />.</param>
      <exception cref="T:System.ArgumentException">A entrada para <paramref name="lockTaken" /> é <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Exit(System.Object)">
      <summary>Libera um bloqueio exclusivo no objeto especificado.</summary>
      <param name="obj">O objeto no qual liberar o bloqueio.</param>
      <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">O thread atual não é o proprietário do bloqueio do objeto especificado.</exception>
    </member>
    <member name="M:System.Threading.Monitor.IsEntered(System.Object)">
      <summary>Determina se o thread atual mantém o bloqueio no objeto especificado.</summary>
      <param name="obj">O objeto a ser testado.</param>
      <returns>
        <see langword="true" /> se o thread atual mantiver o bloqueio no <paramref name="obj" />; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> é <see langword="null" />.</exception>
    </member>
    <member name="P:System.Threading.Monitor.LockContentionCount">
      <summary>Obtém o número de vezes em que houve contenção ao tentar realizar o bloqueio do monitor.</summary>
      <returns>O número de vezes que houve contenção ao tentar usar o bloqueio do monitor.</returns>
    </member>
    <member name="M:System.Threading.Monitor.Pulse(System.Object)">
      <summary>Notifica um thread na fila de espera de uma alteração no estado do objeto bloqueado.</summary>
      <param name="obj">O objeto ao qual um thread está aguardando.</param>
      <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">O thread de chamada não é proprietário do bloqueio do objeto especificado.</exception>
    </member>
    <member name="M:System.Threading.Monitor.PulseAll(System.Object)">
      <summary>Notifica todos os threads em espera de uma alteração no estado do objeto.</summary>
      <param name="obj">O objeto que envia o pulso.</param>
      <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">O thread de chamada não é proprietário do bloqueio do objeto especificado.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object)">
      <summary>Tenta adquirir um bloqueio exclusivo no objeto especificado.</summary>
      <param name="obj">O objeto no qual adquirir o bloqueio.</param>
      <returns>
        <see langword="true" /> se o thread atual adquirir o bloqueio; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
      <summary>Tenta obter um bloqueio exclusivo no objeto especificado e define automaticamente um valor que indica se o bloqueio foi realizado.</summary>
      <param name="obj">O objeto no qual adquirir o bloqueio.</param>
      <param name="lockTaken">O resultado da tentativa de adquirir o bloqueio, passado por referência. A entrada deve ser <see langword="false" />. A saída será <see langword="true" /> se o bloqueio for adquirido; caso contrário, a saída será <see langword="false" />. A saída é definida mesmo se ocorrer uma exceção durante a tentativa de adquirir o bloqueio.</param>
      <exception cref="T:System.ArgumentException">A entrada para <paramref name="lockTaken" /> é <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
      <summary>Tentativas, durante o período especificado de milésimos de segundos, para adquirir um bloqueio exclusivo no objeto especificado.</summary>
      <param name="obj">O objeto no qual adquirir o bloqueio.</param>
      <param name="millisecondsTimeout">O número de milésimos de segundos de espera do bloqueio.</param>
      <returns>
        <see langword="true" /> se o thread atual adquirir o bloqueio; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> é negativo e diferente de <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
      <summary>Tenta, pelo número de milissegundos especificado, obter um bloqueio exclusivo no objeto especificado e define de forma atômica um valor que indica se o bloqueio foi realizado.</summary>
      <param name="obj">O objeto no qual adquirir o bloqueio.</param>
      <param name="millisecondsTimeout">O número de milésimos de segundos de espera do bloqueio.</param>
      <param name="lockTaken">O resultado da tentativa de adquirir o bloqueio, passado por referência. A entrada deve ser <see langword="false" />. A saída será <see langword="true" /> se o bloqueio for adquirido; caso contrário, a saída será <see langword="false" />. A saída é definida mesmo se ocorrer uma exceção durante a tentativa de adquirir o bloqueio.</param>
      <exception cref="T:System.ArgumentException">A entrada para <paramref name="lockTaken" /> é <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> é negativo e diferente de <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
      <summary>Tentativas, durante o período especificado de tempo, para adquirir um bloqueio exclusivo no objeto especificado.</summary>
      <param name="obj">O objeto no qual adquirir o bloqueio.</param>
      <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa a quantidade de tempo a esperar pelo bloqueio. Um valor de -1 milissegundo especifica uma espera infinita.</param>
      <returns>
        <see langword="true" /> se o thread atual adquirir o bloqueio; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">O valor de <paramref name="timeout" /> em milissegundos é negativo e não é igual a <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milissegundo) ou é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
      <summary>Tenta, pelo período especificado, obter um bloqueio exclusivo no objeto especificado e define automaticamente um valor que indica se o bloqueio foi realizado.</summary>
      <param name="obj">O objeto no qual adquirir o bloqueio.</param>
      <param name="timeout">A quantidade de tempo a esperar pelo bloqueio. Um valor de -1 milissegundo especifica uma espera infinita.</param>
      <param name="lockTaken">O resultado da tentativa de adquirir o bloqueio, passado por referência. A entrada deve ser <see langword="false" />. A saída será <see langword="true" /> se o bloqueio for adquirido; caso contrário, a saída será <see langword="false" />. A saída é definida mesmo se ocorrer uma exceção durante a tentativa de adquirir o bloqueio.</param>
      <exception cref="T:System.ArgumentException">A entrada para <paramref name="lockTaken" /> é <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">O valor de <paramref name="timeout" /> em milissegundos é negativo e não é igual a <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milissegundo) ou é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object)">
      <summary>Libera o bloqueio de um objeto e bloqueia o thread atual até que ele adquira o bloqueio novamente.</summary>
      <param name="obj">O objeto no qual aguardar.</param>
      <returns>
        <see langword="true" /> se a chamada foi retornada porque o chamador adquiriu o bloqueio novamente para o objeto especificado. Este método não será retornado se o bloqueio não for adquirido novamente.</returns>
      <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">O thread de chamada não é proprietário do bloqueio do objeto especificado.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">O thread que invoca <see langword="Wait" /> é posteriormente interrompido do estado de espera. Isso acontece quando outro thread chama o método <see cref="M:System.Threading.Thread.Interrupt" /> desse thread.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
      <summary>Libera o bloqueio de um objeto e bloqueia o thread atual até que ele adquira o bloqueio novamente. Se o intervalo de tempo limite especificado transcorrer, o thread entrará na fila pronta.</summary>
      <param name="obj">O objeto no qual aguardar.</param>
      <param name="millisecondsTimeout">O número de milissegundos de espera antes que o thread entre na fila pronta.</param>
      <returns>
        <see langword="true" /> se o bloqueio foi readquirido antes de ter decorrido o tempo especificado e <see langword="false" /> se o bloqueio foi readquirido depois que o tempo especificado foi decorrido. O método não retorna até que o bloqueio seja readquirido.</returns>
      <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">O thread de chamada não é proprietário do bloqueio do objeto especificado.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">O thread que invoca <see langword="Wait" /> é posteriormente interrompido do estado de espera. Isso acontece quando outro thread chama o método <see cref="M:System.Threading.Thread.Interrupt" /> desse thread.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">O valor do parâmetro <paramref name="millisecondsTimeout" /> é negativo e não é igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
      <summary>Libera o bloqueio de um objeto e bloqueia o thread atual até que ele adquira o bloqueio novamente. Se o intervalo de tempo limite especificado transcorrer, o thread entrará na fila pronta. Esse método também especifica se o domínio de sincronização para o contexto (se estiver em um contexto sincronizado) é encerrado antes do tempo de espera e readquirido posteriormente.</summary>
      <param name="obj">O objeto no qual aguardar.</param>
      <param name="millisecondsTimeout">O número de milissegundos de espera antes que o thread entre na fila pronta.</param>
      <param name="exitContext">
        <see langword="true" /> para sair e readquirir o domínio de sincronização para o contexto (se estiver em um contexto sincronizado) antes do tempo de espera; caso contrário, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> se o bloqueio foi readquirido antes de ter decorrido o tempo especificado e <see langword="false" /> se o bloqueio foi readquirido depois que o tempo especificado foi decorrido. O método não retorna até que o bloqueio seja readquirido.</returns>
      <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">
        <see langword="Wait" /> não é invocado de dentro de um bloco de código sincronizado.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">O thread que invoca <see langword="Wait" /> é posteriormente interrompido do estado de espera. Isso acontece quando outro thread chama o método <see cref="M:System.Threading.Thread.Interrupt" /> desse thread.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">O valor do parâmetro <paramref name="millisecondsTimeout" /> é negativo e não é igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
      <summary>Libera o bloqueio de um objeto e bloqueia o thread atual até que ele adquira o bloqueio novamente. Se o intervalo de tempo limite especificado transcorrer, o thread entrará na fila pronta.</summary>
      <param name="obj">O objeto no qual aguardar.</param>
      <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o período de tempo de espera antes que o thread entre na fila pronta.</param>
      <returns>
        <see langword="true" /> se o bloqueio foi readquirido antes de ter decorrido o tempo especificado e <see langword="false" /> se o bloqueio foi readquirido depois que o tempo especificado foi decorrido. O método não retorna até que o bloqueio seja readquirido.</returns>
      <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">O thread de chamada não é proprietário do bloqueio do objeto especificado.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">O thread que invoca <see langword="Wait" /> é posteriormente interrompido do estado de espera. Isso acontece quando outro thread chama o método <see cref="M:System.Threading.Thread.Interrupt" /> desse thread.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">O valor do parâmetro <paramref name="timeout" /> em milissegundos é negativo e não representa <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milissegundos) ou é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
      <summary>Libera o bloqueio de um objeto e bloqueia o thread atual até que ele adquira o bloqueio novamente. Se o intervalo de tempo limite especificado transcorrer, o thread entrará na fila pronta. Opcionalmente, encerra o domínio de sincronização para o contexto sincronizado antes do tempo de espera e, depois disso, readquire o domínio.</summary>
      <param name="obj">O objeto no qual aguardar.</param>
      <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o período de tempo de espera antes que o thread entre na fila pronta.</param>
      <param name="exitContext">
        <see langword="true" /> para sair e readquirir o domínio de sincronização para o contexto (se estiver em um contexto sincronizado) antes do tempo de espera; caso contrário, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> se o bloqueio foi readquirido antes de ter decorrido o tempo especificado e <see langword="false" /> se o bloqueio foi readquirido depois que o tempo especificado foi decorrido. O método não retorna até que o bloqueio seja readquirido.</returns>
      <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">
        <see langword="Wait" /> não é invocado de dentro de um bloco de código sincronizado.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">O thread que invoca Wait é interrompido posteriormente do estado de espera. Isso acontece quando outro thread chama o método <see cref="M:System.Threading.Thread.Interrupt" /> desse thread.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">O parâmetro <paramref name="timeout" /> é negativo e não representa <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milissegundo) ou é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="T:System.Threading.Mutex">
      <summary>Um primitivo de sincronização que também pode ser usado para sincronização entre processos.</summary>
    </member>
    <member name="M:System.Threading.Mutex.#ctor">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Mutex" /> com propriedades padrão.</summary>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Mutex" /> com um valor booliano que indica se o thread de chamada deve ter a propriedade inicial do mutex.</summary>
      <param name="initiallyOwned">
        <see langword="true" /> para dar ao thread de chamada propriedade inicial do mutex; caso contrário, <see langword="false" />.</param>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Mutex" /> com um valor booliano que indica se o thread de chamada deve ter uma propriedade inicial do mutex e uma cadeia de caracteres que é o nome do mutex.</summary>
      <param name="initiallyOwned">
        <see langword="true" /> para dar ao thread de chamada a propriedade inicial do mutex do sistema nomeado se o mutex nomeado sistema foi criado como resultado dessa chamada; caso contrário, <see langword="false" />.</param>
      <param name="name">O nome do <see cref="T:System.Threading.Mutex" />. Se o valor for <see langword="null" />, o <see cref="T:System.Threading.Mutex" /> estará sem nome.</param>
      <exception cref="T:System.UnauthorizedAccessException">O mutex nomeado existe e tem segurança de controle de acesso, mas o usuário não tem <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
      <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Não foi possível criar o mutex nomeado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> tem mais de 260 caracteres.</exception>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Mutex" /> com um valor booliano que indica se o thread de chamada deve ter a propriedade inicial de mutex, uma cadeia de caracteres que é o nome do mutex e um valor booliano que, quando o método retorna, indica se o thread de chamada foi concedido a propriedade inicial do mutex.</summary>
      <param name="initiallyOwned">
        <see langword="true" /> para dar ao thread de chamada a propriedade inicial do mutex do sistema nomeado se o mutex nomeado sistema foi criado como resultado dessa chamada; caso contrário, <see langword="false" />.</param>
      <param name="name">O nome do <see cref="T:System.Threading.Mutex" />. Se o valor for <see langword="null" />, o <see cref="T:System.Threading.Mutex" /> estará sem nome.</param>
      <param name="createdNew">Quando este método retorna, contém um valor booliano que é <see langword="true" /> se um mutex local foi criado (ou seja, se <paramref name="name" /> é <see langword="null" /> ou uma cadeia de caracteres vazia) ou se o mutex do sistema nomeado especificado foi criado; <see langword="false" /> se o mutex do sistema nomeado já existia. Este parâmetro é passado não inicializado.</param>
      <exception cref="T:System.UnauthorizedAccessException">O mutex nomeado existe e tem segurança de controle de acesso, mas o usuário não tem <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
      <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Não foi possível criar o mutex nomeado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> tem mais de 260 caracteres.</exception>
    </member>
    <member name="M:System.Threading.Mutex.OpenExisting(System.String)">
      <summary>Abre o mutex nomeado especificado, caso ele já exista.</summary>
      <param name="name">O nome do mutex do sistema a ser aberto.</param>
      <returns>Um objeto que representa o mutex do sistema nomeado.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> é uma cadeia de caracteres vazia.
-ou-
<paramref name="name" /> tem mais de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">O mutex nomeado não existe.</exception>
      <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">O mutex nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</exception>
    </member>
    <member name="M:System.Threading.Mutex.ReleaseMutex">
      <summary>Libera o <see cref="T:System.Threading.Mutex" /> uma vez.</summary>
      <exception cref="T:System.ApplicationException">O thread de chamada não tem o mutex.</exception>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
    </member>
    <member name="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
      <summary>Abre o mutex nomeado especificado, quando ele já existe e retorna um valor que indica se a operação foi bem-sucedida.</summary>
      <param name="name">O nome do mutex do sistema a ser aberto.</param>
      <param name="result">Quando este método retorna, ele contém um objeto <see cref="T:System.Threading.Mutex" /> que representa o mutex nomeado se a chamada foi bem-sucedida ou <see langword="null" /> se a chamada falhou. Esse parâmetro é tratado como não inicializado.</param>
      <returns>
        <see langword="true" /> se o mutex nomeado foi aberto com sucesso, caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> é uma cadeia de caracteres vazia.
-ou-
<paramref name="name" /> tem mais de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">O mutex nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</exception>
    </member>
    <member name="T:System.Threading.ReaderWriterLock">
      <summary>Define um bloqueio que dá suporte a autores únicos e múltiplos leitores.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.#ctor">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.ReaderWriterLock" />.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
      <summary>Adquire um bloqueio de leitor, usando um valor <see cref="T:System.Int32" /> para o tempo limite.</summary>
      <param name="millisecondsTimeout">O tempo limite em milissegundos.</param>
      <exception cref="T:System.ApplicationException">O <paramref name="millisecondsTimeout" /> expira antes que a solicitação de bloqueio seja concedida.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
      <summary>Adquire um bloqueio de leitor, usando um valor <see cref="T:System.TimeSpan" /> para o tempo limite.</summary>
      <param name="timeout">Um <see langword="TimeSpan" /> que especifica o período de tempo limite.</param>
      <exception cref="T:System.ApplicationException">O <paramref name="timeout" /> expira antes que a solicitação de bloqueio seja concedida.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> especifica um valor negativo diferente de -1 milissegundo.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
      <summary>Adquire um bloqueio de gravador, usando um valor <see cref="T:System.Int32" /> para o tempo limite.</summary>
      <param name="millisecondsTimeout">O tempo limite em milissegundos.</param>
      <exception cref="T:System.ApplicationException">O <paramref name="timeout" /> expira antes que a solicitação de bloqueio seja concedida.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
      <summary>Adquire um bloqueio de gravador, usando um valor <see cref="T:System.TimeSpan" /> para o tempo limite.</summary>
      <param name="timeout">O <see langword="TimeSpan" /> que especifica o período de tempo limite.</param>
      <exception cref="T:System.ApplicationException">O <paramref name="timeout" /> expira antes que a solicitação de bloqueio seja concedida.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> especifica um valor negativo diferente de -1 milissegundo.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)">
      <summary>Indica se o bloqueio de gravador foi concedido a qualquer thread desde que o número de sequência foi obtido.</summary>
      <param name="seqNum">O número de sequência.</param>
      <returns>
        <see langword="true" /> se o bloqueio de gravador tiver sido concedido a qualquer thread desde que o número de sequência foi obtido; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)">
      <summary>Restaura o status de bloqueio do thread para o status prévio antes de <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" /> ser chamado.</summary>
      <param name="lockCookie">Um <see cref="T:System.Threading.LockCookie" /> retornado por <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</param>
      <exception cref="T:System.ApplicationException">O thread não tem o bloqueio de gravador.</exception>
      <exception cref="T:System.NullReferenceException">O endereço de <paramref name="lockCookie" /> é um ponteiro nulo.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.IsReaderLockHeld">
      <summary>Obtém um valor que indica se o thread atual mantém um bloqueio de leitor.</summary>
      <returns>
        <see langword="true" /> se o thread atual mantém um bloqueio de leitor; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.IsWriterLockHeld">
      <summary>Obtém um valor que indica se o thread atual mantém um bloqueio de gravador.</summary>
      <returns>
        <see langword="true" /> se o thread atual mantiver o bloqueio do gravador; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseLock">
      <summary>Libera o bloqueio, independentemente do número de vezes que o thread adquiriu o bloqueio.</summary>
      <returns>Um valor <see cref="T:System.Threading.LockCookie" /> que representa o bloqueio liberado.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseReaderLock">
      <summary>Diminui a contagem de bloqueio.</summary>
      <exception cref="T:System.ApplicationException">O thread não tem nenhum bloqueio de leitor ou de gravador.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseWriterLock">
      <summary>Diminui a contagem de bloqueio no bloqueio de gravador.</summary>
      <exception cref="T:System.ApplicationException">O thread não tem o bloqueio de gravador.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)">
      <summary>Restaura o status de bloqueio do thread para o que era antes de chamar <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</summary>
      <param name="lockCookie">Um <see cref="T:System.Threading.LockCookie" /> retornado por <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</param>
      <exception cref="T:System.NullReferenceException">O endereço de <paramref name="lockCookie" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
      <summary>Atualiza um bloqueio de leitor para o bloqueio de gravador, usando um valor <see langword="Int32" /> para o tempo limite.</summary>
      <param name="millisecondsTimeout">O tempo limite em milissegundos.</param>
      <returns>Um valor <see cref="T:System.Threading.LockCookie" />.</returns>
      <exception cref="T:System.ApplicationException">O <paramref name="millisecondsTimeout" /> expira antes que a solicitação de bloqueio seja concedida.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
      <summary>Faz o upgrade de um bloqueio de leitor para o bloqueio de gravador usando um valor <see langword="TimeSpan" /> para o tempo limite.</summary>
      <param name="timeout">O <see langword="TimeSpan" /> que especifica o período de tempo limite.</param>
      <returns>Um valor <see cref="T:System.Threading.LockCookie" />.</returns>
      <exception cref="T:System.ApplicationException">O <paramref name="timeout" /> expira antes que a solicitação de bloqueio seja concedida.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> especifica um valor negativo diferente de -1 milissegundo.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.WriterSeqNum">
      <summary>Obtém o número de sequência atual.</summary>
      <returns>O número de sequência atual.</returns>
    </member>
    <member name="T:System.Threading.ReaderWriterLockSlim">
      <summary>Representa um bloqueio que é usado para gerenciar o acesso a um recurso, permitindo vários threads para leitura ou acesso exclusivo para gravação.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.ReaderWriterLockSlim" /> com os valores da propriedade padrão.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.ReaderWriterLockSlim" />, especificando a política de recursão de bloqueio.</summary>
      <param name="recursionPolicy">Um dos valores de enumeração que especifica a política de recursão de bloqueio.</param>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
      <summary>Obtém o número total de threads exclusivos que inseriram o bloqueio no modo de leitura.</summary>
      <returns>O número de threads exclusivos que inseriram o bloqueio no modo de leitura.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.Dispose">
      <summary>Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.ReaderWriterLockSlim" />.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">
        <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> é maior que zero.
- ou -
<see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> é maior que zero.
- ou -
<see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> é maior que zero.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
      <summary>Tenta entrar no bloqueio em modo de leitura.</summary>
      <exception cref="T:System.Threading.LockRecursionException">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual tentou adquirir o bloqueio de leitura quando ele já retinha o bloqueio de leitura.
- ou -
A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual tentou adquirir o bloqueio de leitura quando ele já retinha o bloqueio de gravação.
- ou -
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca devem encontrar essa exceção.</exception>
      <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
      <summary>Tenta entrar no bloqueio no modo atualizável.</summary>
      <exception cref="T:System.Threading.LockRecursionException">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio em qualquer modo.
- ou -
O thread atual entrou no modo de leitura, portanto, tentar entrar no modo atualizável criará a possibilidade de um deadlock.
- ou -
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca o alcançariam.</exception>
      <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
      <summary>Tenta entrar no bloqueio em modo de gravação.</summary>
      <exception cref="T:System.Threading.LockRecursionException">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio em qualquer modo.
- ou -
O thread atual entrou no modo de leitura e ainda não tem um bloqueio de gravação. Portanto, tentar entrar no bloqueio em modo de gravação criará a possibilidade de um deadlock.
- ou -
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca o alcançariam.</exception>
      <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
      <summary>Reduz a contagem de recursão para o modo de leitura e sai do modo de leitura se a contagem resultante é 0 (zero).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">O thread atual não entrou no bloqueio no modo de leitura.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
      <summary>Reduz a contagem de recursão para o modo de upgrade e sai do modo de upgrade se a contagem resultante é 0 (zero).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">O thread atual não entrou no bloqueio em modo de upgrade.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
      <summary>Reduz a contagem de recursão para o modo de gravação e sai do modo de gravação se a contagem resultante é 0 (zero).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">O thread atual não entrou no bloqueio em modo de gravação.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
      <summary>Obtém um valor que indica se o thread atual inseriu o bloqueio no modo de leitura.</summary>
      <returns>
        <see langword="true" />Se o thread atual tiver entrado no modo de leitura; caso contrário <see langword="false" />,.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
      <summary>Obtém um valor que indica se o thread atual inseriu o bloqueio no modo de upgrade.</summary>
      <returns>
        <see langword="true" />Se o thread atual tiver inserido o modo atualizável; caso contrário <see langword="false" />,.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
      <summary>Obtém um valor que indica se o thread atual inseriu o bloqueio no modo de gravação.</summary>
      <returns>
        <see langword="true" />Se o thread atual tiver entrado no modo de gravação; caso contrário <see langword="false" />,.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
      <summary>Obtém um valor que indica a política de recursão do objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> atual.</summary>
      <returns>Um dos valores de enumeração que especifica a política de recursão de bloqueio.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
      <summary>Obtém o número de vezes que o thread atual inseriu o bloqueio no modo de leitura, como uma indicação de recursão.</summary>
      <returns>0 (zero) se o thread atual não tiver entrado no modo de leitura, 1 se o thread tiver entrado no modo de leitura, mas não o tiver inserido recursivamente, ou n se o thread tiver inserido o bloqueio recursivamente n -1 vezes.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
      <summary>Obtém o número de vezes que o thread atual inseriu o bloqueio no modo de upgrade, como uma indicação de recursão.</summary>
      <returns>0 se o thread atual não tiver inserido o modo atualizável, 1 se o thread tiver inserido o modo atualizável, mas não o tiver inserido recursivamente, ou n se o thread tiver inserido o modo atualizável recursivamente n -1 vezes.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
      <summary>Obtém o número de vezes que o thread atual inseriu o bloqueio no modo de gravação, como uma indicação de recursão.</summary>
      <returns>0 se o thread atual não tiver entrado no modo de gravação, 1 se o thread tiver entrado no modo de gravação, mas não o tiver inserido recursivamente, ou n se o thread tiver entrado no modo de gravação recursivamente n -1 vezes.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
      <summary>Tenta inserir o bloqueio no modo de gravação com um tempo limite inteiro opcional.</summary>
      <param name="millisecondsTimeout">O número de milissegundos a aguardar ou -1 (<see cref="F:System.Threading.Timeout.Infinite" />) para aguardar indefinidamente.</param>
      <returns>
        <see langword="true" /> se o thread de chamada tiver entrado no modo de leitura; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio.
- ou -
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca o alcançariam.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">O valor de <paramref name="millisecondsTimeout" /> é negativo, mas não é igual a <see cref="F:System.Threading.Timeout.Infinite" /> (-1), que é o único valor negativo permitido.</exception>
      <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
      <summary>Tenta entrar no bloqueio no modo de leitura, com um tempo limite opcional.</summary>
      <param name="timeout">O intervalo para esperar ou -1 milissegundo para aguardar indefinidamente.</param>
      <returns>
        <see langword="true" /> se o thread de chamada tiver entrado no modo de leitura; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio.
- ou -
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca o alcançariam.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">O valor de <paramref name="timeout" /> é negativo, mas não é igual a -1 milissegundo, que é o único valor negativo permitido.
- ou -
O valor de <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" /> milissegundos.</exception>
      <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
      <summary>Tenta inserir o bloqueio no modo de upgrade, com um tempo limite opcional.</summary>
      <param name="millisecondsTimeout">O número de milissegundos a aguardar ou -1 (<see cref="F:System.Threading.Timeout.Infinite" />) para aguardar indefinidamente.</param>
      <returns>
        <see langword="true" /> se o thread de chamada tiver entrado no modo de upgrade, caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio.
- ou -
O thread atual inseriu inicialmente o bloqueio no modo de leitura, portanto, tentar entrar no modo de upgrade geraria a possibilidade de um deadlock.
- ou -
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca o alcançariam.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">O valor de <paramref name="millisecondsTimeout" /> é negativo, mas não é igual a <see cref="F:System.Threading.Timeout.Infinite" /> (-1), que é o único valor negativo permitido.</exception>
      <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
      <summary>Tenta inserir o bloqueio no modo de upgrade, com um tempo limite opcional.</summary>
      <param name="timeout">O intervalo para esperar ou -1 milissegundo para aguardar indefinidamente.</param>
      <returns>
        <see langword="true" /> se o thread de chamada tiver entrado no modo de upgrade, caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio.
- ou -
O thread atual inseriu inicialmente o bloqueio no modo de leitura, portanto, tentar entrar no modo de upgrade geraria a possibilidade de um deadlock.
- ou -
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca o alcançariam.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">O valor de <paramref name="timeout" /> é negativo, mas não é igual a -1 milissegundo, que é o único valor negativo permitido.
- ou -
O valor de <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" /> milissegundos.</exception>
      <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
      <summary>Tenta entrar no bloqueio no modo de gravação, com um tempo limite opcional.</summary>
      <param name="millisecondsTimeout">O número de milissegundos a aguardar ou -1 (<see cref="F:System.Threading.Timeout.Infinite" />) para aguardar indefinidamente.</param>
      <returns>
        <see langword="true" /> se o thread de chamada tiver entrado no modo de gravação, caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio.
- ou -
O thread atual inseriu inicialmente o bloqueio no modo de leitura, portanto, tentar entrar no modo de gravação criará a possibilidade de um deadlock.
- ou -
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca o alcançariam.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">O valor de <paramref name="millisecondsTimeout" /> é negativo, mas não é igual a <see cref="F:System.Threading.Timeout.Infinite" /> (-1), que é o único valor negativo permitido.</exception>
      <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
      <summary>Tenta entrar no bloqueio no modo de gravação, com um tempo limite opcional.</summary>
      <param name="timeout">O intervalo para esperar ou -1 milissegundo para aguardar indefinidamente.</param>
      <returns>
        <see langword="true" /> se o thread de chamada tiver entrado no modo de gravação, caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio.
- ou -
O thread atual inseriu inicialmente o bloqueio no modo de leitura, portanto, tentar entrar no modo de gravação criará a possibilidade de um deadlock.
- ou -
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca o alcançariam.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">O valor de <paramref name="timeout" /> é negativo, mas não é igual a -1 milissegundo, que é o único valor negativo permitido.
- ou -
O valor de <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" /> milissegundos.</exception>
      <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
      <summary>Obtém o número total de threads que estão esperando para inserir o bloqueio no modo de leitura.</summary>
      <returns>O número total de threads que estão aguardando para entrar no modo de leitura.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
      <summary>Obtém o número total de threads que estão esperando para inserir o bloqueio no modo de upgrade.</summary>
      <returns>O número total de threads que estão aguardando para entrar no modo atualizável.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
      <summary>Obtém o número total de threads que estão esperando para inserir o bloqueio no modo de gravação.</summary>
      <returns>O número total de threads que estão aguardando para entrar no modo de gravação.</returns>
    </member>
    <member name="T:System.Threading.Semaphore">
      <summary>Limita o número de threads que podem acessar um recurso ou um pool de recursos simultaneamente.</summary>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Semaphore" />, especificando o número inicial de entradas e o número máximo de entradas simultâneas.</summary>
      <param name="initialCount">O número inicial de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</param>
      <param name="maximumCount">O número máximo de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="initialCount" /> é maior que <paramref name="maximumCount" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maximumCount" /> é menor que 1.
-ou-
<paramref name="initialCount" /> é menor que 0.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Semaphore" />, especificando o número inicial de entradas e o número máximo de entradas simultâneas e, opcionalmente, especificando o nome de um objeto de sinal de sistema.</summary>
      <param name="initialCount">O número inicial de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</param>
      <param name="maximumCount">O número máximo de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</param>
      <param name="name">O nome de um objeto de sinal de sistema nomeado.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="initialCount" /> é maior que <paramref name="maximumCount" />.
-ou-
<paramref name="name" /> tem mais de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maximumCount" /> é menor que 1.
-ou-
<paramref name="initialCount" /> é menor que 0.</exception>
      <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">O sinal nomeado existe e tem segurança de controle de acesso e o usuário não tem <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">O sinal nomeado não pode ser criado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Semaphore" />, especificando o número inicial de entradas e o número máximo de entradas simultâneas, opcionalmente especificando o nome de um objeto de semáforo de sistema e especificando uma variável que recebe um valor que indica se um novo semáforo do sistema foi criado.</summary>
      <param name="initialCount">O número inicial de solicitações para o semáforo que podem ser atendidas simultaneamente.</param>
      <param name="maximumCount">O número máximo de solicitações para o semáforo que podem ser atendidas simultaneamente.</param>
      <param name="name">O nome de um objeto de sinal de sistema nomeado.</param>
      <param name="createdNew">Quando este método retorna, ele conterá <see langword="true" />, se um semáforo local tiver sido criado (isto é, se <paramref name="name" /> for <see langword="null" /> ou uma cadeia de caracteres vazia) ou se o semáforo de sistema nomeado especificado tiver sido criado, <see langword="false" /> se o semáforo de sistema nomeado especificado já existia. Este parâmetro é passado não inicializado.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="initialCount" /> é maior que <paramref name="maximumCount" />.
-ou-
<paramref name="name" /> tem mais de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maximumCount" /> é menor que 1.
-ou-
<paramref name="initialCount" /> é menor que 0.</exception>
      <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">O sinal nomeado existe e tem segurança de controle de acesso e o usuário não tem <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">O sinal nomeado não pode ser criado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.OpenExisting(System.String)">
      <summary>Abre o semáforo nomeado especificado, caso ele já exista.</summary>
      <param name="name">O nome do semáforo do sistema a ser aberto.</param>
      <returns>Um objeto que representa o semáforo do sistema nomeado.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> é uma cadeia de caracteres vazia.
-ou-
<paramref name="name" /> tem mais de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">O semáforo nomeado não existe.</exception>
      <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">O semáforo nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.Release">
      <summary>Sai do sinal e retorna à contagem anterior.</summary>
      <returns>A contagem no sinal antes do método <see cref="Overload:System.Threading.Semaphore.Release" /> ser chamado.</returns>
      <exception cref="T:System.Threading.SemaphoreFullException">A contagem de semáforo já está no valor máximo.</exception>
      <exception cref="T:System.IO.IOException">Ocorreu um erro de Win32 com um semáforo nomeado.</exception>
      <exception cref="T:System.UnauthorizedAccessException">O semáforo atual representa um semáforo de sistema nomeado, mas o usuário não tem <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.
-ou-
O sinal do atual representa um sinal de sistema nomeado, mas não foi aberto com <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.Release(System.Int32)">
      <summary>Sai do sinal de um número de vezes especificado e retorna à contagem anterior.</summary>
      <param name="releaseCount">O número de vezes para sair do sinal.</param>
      <returns>A contagem no sinal antes do método <see cref="Overload:System.Threading.Semaphore.Release" /> ser chamado.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="releaseCount" /> é menor que 1.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException">A contagem de semáforo já está no valor máximo.</exception>
      <exception cref="T:System.IO.IOException">Ocorreu um erro de Win32 com um semáforo nomeado.</exception>
      <exception cref="T:System.UnauthorizedAccessException">O semáforo atual representa um semáforo de sistema nomeado, mas o usuário não tem direitos de <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.
-ou-
O sinal atual representa um sinal de sistema nomeado, mas não foi aberto com direitos de <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
      <summary>Abre o semáforo nomeado especificado, caso ele já exista e retorna um valor que indica se a operação foi bem-sucedida.</summary>
      <param name="name">O nome do semáforo do sistema a ser aberto.</param>
      <param name="result">Quando esse método retorna, contém um objeto <see cref="T:System.Threading.Semaphore" /> que representa o semáforo nomeado se a chamada foi bem-sucedida ou <see langword="null" /> se a chamada falhou. Esse parâmetro é tratado como não inicializado.</param>
      <returns>
        <see langword="true" /> se o semáforo nomeado foi aberto com êxito; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> é uma cadeia de caracteres vazia.
-ou-
<paramref name="name" /> tem mais de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">O semáforo nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</exception>
    </member>
    <member name="T:System.Threading.SemaphoreFullException">
      <summary>A exceção que é lançada quando o método <see cref="Overload:System.Threading.Semaphore.Release" /> é chamado em um semáforo cuja contagem já está no máximo.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.SemaphoreFullException" /> com valores padrão.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.SemaphoreFullException" /> com dados serializados.</summary>
      <param name="info">O objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que mantém os dados de objeto serializados sobre a exceção que está sendo lançada.</param>
      <param name="context">O objeto <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contém informações contextuais sobre a fonte ou o destino.</param>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.String)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.SemaphoreFullException" /> com uma mensagem de erro especificada.</summary>
      <param name="message">A mensagem de erro que explica a razão da exceção.</param>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.String,System.Exception)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.SemaphoreFullException" /> com uma mensagem de erro especificada e uma referência à exceção interna que é a causa da exceção.</summary>
      <param name="message">A mensagem de erro que explica a razão da exceção.</param>
      <param name="innerException">A exceção que é a causa da exceção atual. Caso o parâmetro <paramref name="innerException" /> não seja <see langword="null" />, a exceção atual é acionada em um bloco <see langword="catch" /> que identifica a exceção interna.</param>
    </member>
    <member name="T:System.Threading.SemaphoreSlim">
      <summary>Representa uma alternativa leve para <see cref="T:System.Threading.Semaphore" /> que limita o número de threads que podem acessar um recurso ou um pool de recursos simultaneamente.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.SemaphoreSlim" />, especificando o número inicial de solicitações que podem ser concedidas simultaneamente.</summary>
      <param name="initialCount">O número inicial de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="initialCount" /> é menor que 0.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.SemaphoreSlim" />, especificando o número inicial e o máximo de solicitações que podem ser concedidas simultaneamente.</summary>
      <param name="initialCount">O número inicial de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</param>
      <param name="maxCount">O número máximo de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="initialCount" /> é menor que 0, <paramref name="initialCount" /> é maior que <paramref name="maxCount" /> ou <paramref name="maxCount" /> é igual ou menor que 0.</exception>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.AvailableWaitHandle">
      <summary>Retorna um <see cref="T:System.Threading.WaitHandle" /> que pode ser usado para aguardar o semáforo.</summary>
      <returns>Um <see cref="T:System.Threading.WaitHandle" /> que pode ser usado para aguardar o semáforo.</returns>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.SemaphoreSlim" /> foi descartado.</exception>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.CurrentCount">
      <summary>Obtém o número de threads restantes que podem inserir o objeto <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <returns>O número de threads restantes que podem inserir o semáforo.</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose">
      <summary>Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)">
      <summary>Libera os recursos não gerenciados usados pelo <see cref="T:System.Threading.SemaphoreSlim" /> e opcionalmente libera os recursos gerenciados.</summary>
      <param name="disposing">
        <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release">
      <summary>Libera o objeto <see cref="T:System.Threading.SemaphoreSlim" /> uma única vez.</summary>
      <returns>A contagem anterior do <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException">O <see cref="T:System.Threading.SemaphoreSlim" /> já atingiu seu tamanho máximo.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release(System.Int32)">
      <summary>Libera o objeto <see cref="T:System.Threading.SemaphoreSlim" /> um número de vezes especificado.</summary>
      <param name="releaseCount">O número de vezes para sair do sinal.</param>
      <returns>A contagem anterior do <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="releaseCount" /> é menor que 1.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException">O <see cref="T:System.Threading.SemaphoreSlim" /> já atingiu seu tamanho máximo.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait">
      <summary>Bloqueia o thread atual até que o <see cref="T:System.Threading.SemaphoreSlim" /> possa ser inserido.</summary>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32)">
      <summary>Bloqueia o thread atual até que ele possa inserir o <see cref="T:System.Threading.SemaphoreSlim" />, usando um inteiro com sinal de 32 bits que especifica o tempo limite.</summary>
      <param name="millisecondsTimeout">O número de milissegundos de espera, <see cref="F:System.Threading.Timeout.Infinite" />(-1) de espera indefinidamente ou zero para testar o estado do identificador de espera e retornar imediatamente.</param>
      <returns>
        <see langword="true" /> se o thread atual inseriu o <see cref="T:System.Threading.SemaphoreSlim" /> com êxito; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito ou o tempo limite é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.SemaphoreSlim" /> foi descartado.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary>Bloqueia o thread atual até que ele possa inserir o <see cref="T:System.Threading.SemaphoreSlim" />, usando um inteiro com sinal de 32 bits que especifica o tempo limite, observando simultaneamente um <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout">O número de milissegundos de espera, <see cref="F:System.Threading.Timeout.Infinite" />(-1) de espera indefinidamente ou zero para testar o estado do identificador de espera e retornar imediatamente.</param>
      <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <returns>
        <see langword="true" /> se o thread atual inseriu o <see cref="T:System.Threading.SemaphoreSlim" /> com êxito; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException">O <paramref name="cancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.
- ou -
<paramref name="millisecondsTimeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">A instância de <see cref="T:System.Threading.SemaphoreSlim" /> foi descartada ou o <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> foi descartado.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)">
      <summary>Bloqueia o thread atual até que ele possa inserir o <see cref="T:System.Threading.SemaphoreSlim" />, enquanto observar uma <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken">O token <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <exception cref="T:System.OperationCanceledException">O <paramref name="cancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.
- ou -
O <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> já foi descartado.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan)">
      <summary>Bloqueia o thread atual até que ele possa inserir o <see cref="T:System.Threading.SemaphoreSlim" />, usando um <see cref="T:System.TimeSpan" /> para especificar o tempo limite.</summary>
      <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos de espera, um <see cref="T:System.TimeSpan" /> que representa -1 milissegundo de espera indefinidamente ou um <see cref="T:System.TimeSpan" /> que representa 0 milissegundo para testar o identificador de espera e retornar imediatamente.</param>
      <returns>
        <see langword="true" /> se o thread atual inseriu o <see cref="T:System.Threading.SemaphoreSlim" /> com êxito; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.
- ou -
<paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">A instância semaphoreSlim foi descartada.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>Bloqueia o thread atual até que ele possa inserir o <see cref="T:System.Threading.SemaphoreSlim" />, usando um <see cref="T:System.TimeSpan" /> que especifica o tempo limite, observando simultaneamente um <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos de espera, um <see cref="T:System.TimeSpan" /> que representa -1 milissegundo de espera indefinidamente ou um <see cref="T:System.TimeSpan" /> que representa 0 milissegundo para testar o identificador de espera e retornar imediatamente.</param>
      <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <returns>
        <see langword="true" /> se o thread atual inseriu o <see cref="T:System.Threading.SemaphoreSlim" /> com êxito; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException">O <paramref name="cancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.
-ou-.
<paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">A instância semaphoreSlim foi descartada.
- ou -
O <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> já foi descartado.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync">
      <summary>Espera assincronamente para inserir o <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <returns>Uma tarefa que será concluída quando o semáforo for inserido.</returns>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.SemaphoreSlim" /> foi descartado.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32)">
      <summary>Aguarda de forma assíncrona para inserir o <see cref="T:System.Threading.SemaphoreSlim" />, usando um inteiro com sinal de 32 bits para medir o intervalo de tempo.</summary>
      <param name="millisecondsTimeout">O número de milissegundos de espera, <see cref="F:System.Threading.Timeout.Infinite" /> (-1) de espera indefinidamente ou zero para testar o estado do identificador de espera e retornar imediatamente.</param>
      <returns>Uma tarefa será concluída com um resultado de <see langword="true" /> se o thread atual tiver inserido com êxito o <see cref="T:System.Threading.SemaphoreSlim" />, caso contrário, com um resultado de <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.
- ou -
<paramref name="millisecondsTimeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)">
      <summary>Espera assincronamente para inserir o <see cref="T:System.Threading.SemaphoreSlim" />, usando um inteiro com sinal de 32 bits para medir o intervalo de tempo, enquanto observa um <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout">O número de milissegundos de espera, <see cref="F:System.Threading.Timeout.Infinite" /> (-1) de espera indefinidamente ou zero para testar o estado do identificador de espera e retornar imediatamente.</param>
      <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <returns>Uma tarefa será concluída com um resultado de <see langword="true" /> se o thread atual tiver inserido com êxito o <see cref="T:System.Threading.SemaphoreSlim" />, caso contrário, com um resultado de <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> é um número diferente de -1, que representa um tempo limite infinito.
- ou -
<paramref name="millisecondsTimeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
      <exception cref="T:System.OperationCanceledException">O <paramref name="cancellationToken" /> foi cancelado.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)">
      <summary>Espera assincronamente para inserir o <see cref="T:System.Threading.SemaphoreSlim" />, ao observar um <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken">O token <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <returns>Uma tarefa que será concluída quando o semáforo for inserido.</returns>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
      <exception cref="T:System.OperationCanceledException">O <paramref name="cancellationToken" /> foi cancelado.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)">
      <summary>Espera assincronamente para inserir o <see cref="T:System.Threading.SemaphoreSlim" />, usando um <see cref="T:System.TimeSpan" /> para medir o intervalo de tempo.</summary>
      <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos de espera, um <see cref="T:System.TimeSpan" /> que representa -1 milissegundo de espera indefinidamente ou um <see cref="T:System.TimeSpan" /> que representa 0 milissegundo para testar o identificador de espera e retornar imediatamente.</param>
      <returns>Uma tarefa será concluída com um resultado de <see langword="true" /> se o thread atual tiver inserido com êxito o <see cref="T:System.Threading.SemaphoreSlim" />, caso contrário, com um resultado de <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.
- ou -
<paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>Espera assincronamente para inserir o <see cref="T:System.Threading.SemaphoreSlim" />, usando um <see cref="T:System.TimeSpan" /> para medir o intervalo de tempo, enquanto observa um <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos de espera, um <see cref="T:System.TimeSpan" /> que representa -1 milissegundo de espera indefinidamente ou um <see cref="T:System.TimeSpan" /> que representa 0 milissegundo para testar o identificador de espera e retornar imediatamente.</param>
      <param name="cancellationToken">O token <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <returns>Uma tarefa será concluída com um resultado de <see langword="true" /> se o thread atual tiver inserido com êxito o <see cref="T:System.Threading.SemaphoreSlim" />, caso contrário, com um resultado de <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.
- ou -
<paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.OperationCanceledException">O <paramref name="cancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.SemaphoreSlim" /> foi descartado.</exception>
    </member>
    <member name="T:System.Threading.SendOrPostCallback">
      <summary>Representa um método a ser chamado quando uma mensagem deve ser distribuída em um contexto de sincronização.</summary>
      <param name="state">O objeto passado ao delegado.</param>
    </member>
    <member name="T:System.Threading.SpinLock">
      <summary>Fornece um primitivo de bloqueio de exclusão mútua onde um thread que tenta adquirir o bloqueio aguarda em um loop, fazendo verificações repetidamente até que o bloqueio esteja disponível.</summary>
    </member>
    <member name="M:System.Threading.SpinLock.#ctor(System.Boolean)">
      <summary>Inicializa uma nova instância da estrutura <see cref="T:System.Threading.SpinLock" /> com a opção para acompanhar IDs de thread para melhorar a depuração.</summary>
      <param name="enableThreadOwnerTracking">Indica se IDs de threads serão capturadas e usadas para fins de depuração.</param>
    </member>
    <member name="M:System.Threading.SpinLock.Enter(System.Boolean@)">
      <summary>Adquire o bloqueio de maneira confiável, de forma que mesmo se uma exceção ocorrer dentro da chamada de método, <paramref name="lockTaken" /> poderá ser examinado com confiança para determinar se o bloqueio foi adquirido.</summary>
      <param name="lockTaken">True se o bloqueio tiver sido adquirido; caso contrário, false. <paramref name="lockTaken" /> deve ser inicializado como false antes de chamar esse método.</param>
      <exception cref="T:System.ArgumentException">O argumento <paramref name="lockTaken" /> deve ser inicializado como false antes de chamar Enter.</exception>
      <exception cref="T:System.Threading.LockRecursionException">O acompanhamento de propriedade de thread está habilitado e o thread atual há adquiriu este bloqueio.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit">
      <summary>Libera o bloqueio.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">O acompanhamento de propriedade de thread está habilitado e o thread atual não é o proprietário deste bloqueio.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit(System.Boolean)">
      <summary>Libera o bloqueio.</summary>
      <param name="useMemoryBarrier">Um valor booliano que indica se um limite de memória deve ser emitido para publicar imediatamente a operação de saída em outros threads.</param>
      <exception cref="T:System.Threading.SynchronizationLockException">O acompanhamento de propriedade de thread está habilitado e o thread atual não é o proprietário deste bloqueio.</exception>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeld">
      <summary>Especifica se o bloqueio é mantido atualmente por algum thread.</summary>
      <returns>true se o bloqueio estiver sendo mantido por qualquer thread; caso contrário, false.</returns>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeldByCurrentThread">
      <summary>Especifica se o bloqueio é mantido pelo thread atual.</summary>
      <returns>true se o bloqueio for mantido pelo thread atual; caso contrário, false.</returns>
      <exception cref="T:System.InvalidOperationException">O acompanhamento de propriedade de thread está desabilitado.</exception>
    </member>
    <member name="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled">
      <summary>Especifica se o acompanhamento de propriedade de thread está habilitado para esta instância.</summary>
      <returns>true se o rastreamento de propriedade de thread estiver habilitado para esta instância; caso contrário, false.</returns>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
      <summary>Tenta adquirir o bloqueio de maneira confiável, de forma que mesmo se uma exceção ocorrer dentro da chamada de método, <paramref name="lockTaken" /> poderá ser examinado com confiança para determinar se o bloqueio foi adquirido.</summary>
      <param name="lockTaken">True se o bloqueio tiver sido adquirido; caso contrário, false. <paramref name="lockTaken" /> deve ser inicializado como false antes de chamar esse método.</param>
      <exception cref="T:System.ArgumentException">O argumento <paramref name="lockTaken" /> deve ser inicializado como false antes de chamar TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException">O acompanhamento de propriedade de thread está habilitado e o thread atual há adquiriu este bloqueio.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
      <summary>Tenta adquirir o bloqueio de maneira confiável, de forma que mesmo se uma exceção ocorrer dentro da chamada de método, <paramref name="lockTaken" /> poderá ser examinado com confiança para determinar se o bloqueio foi adquirido.</summary>
      <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
      <param name="lockTaken">True se o bloqueio tiver sido adquirido; caso contrário, false. <paramref name="lockTaken" /> deve ser inicializado como false antes de chamar esse método.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
      <exception cref="T:System.ArgumentException">O argumento <paramref name="lockTaken" /> deve ser inicializado como false antes de chamar TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException">O acompanhamento de propriedade de thread está habilitado e o thread atual há adquiriu este bloqueio.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
      <summary>Tenta adquirir o bloqueio de maneira confiável, de forma que mesmo se uma exceção ocorrer dentro da chamada de método, <paramref name="lockTaken" /> poderá ser examinado com confiança para determinar se o bloqueio foi adquirido.</summary>
      <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
      <param name="lockTaken">True se o bloqueio tiver sido adquirido; caso contrário, false. <paramref name="lockTaken" /> deve ser inicializado como false antes de chamar esse método.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito ou o tempo limite é maior que <see cref="F:System.Int32.MaxValue" /> milissegundos.</exception>
      <exception cref="T:System.ArgumentException">O argumento <paramref name="lockTaken" /> deve ser inicializado como false antes de chamar TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException">O acompanhamento de propriedade de thread está habilitado e o thread atual há adquiriu este bloqueio.</exception>
    </member>
    <member name="T:System.Threading.SpinWait">
      <summary>Fornece suporte à espera baseada em rotação.</summary>
    </member>
    <member name="P:System.Threading.SpinWait.Count">
      <summary>Obtém o número de vezes que <see cref="M:System.Threading.SpinWait.SpinOnce" /> foi chamado nessa instância.</summary>
      <returns>Retorna um inteiro que representa o número de vezes que <see cref="M:System.Threading.SpinWait.SpinOnce" /> foi chamado nessa instância.</returns>
    </member>
    <member name="P:System.Threading.SpinWait.NextSpinWillYield">
      <summary>Especifica se a próxima chamada para <see cref="M:System.Threading.SpinWait.SpinOnce" /> produzirá o processador, disparando uma alternância de contexto forçado.</summary>
      <returns>Se a próxima chamada para <see cref="M:System.Threading.SpinWait.SpinOnce" /> gerará o processador, disparando uma alternância de contexto forçada.</returns>
    </member>
    <member name="M:System.Threading.SpinWait.Reset">
      <summary>Redefine o contador de rotação.</summary>
    </member>
    <member name="M:System.Threading.SpinWait.SpinOnce">
      <summary>Executa uma única rotação.</summary>
    </member>
    <member name="M:System.Threading.SpinWait.SpinOnce(System.Int32)">
      <summary>Executa uma única rotação e chama <see cref="M:System.Threading.Thread.Sleep(System.Int32)" /> após uma contagem mínima de rotação.</summary>
      <param name="sleep1Threshold">Uma contagem mínima de rotação após a qual o <see langword="Thread.Sleep(1)" /> pode ser usado. Um valor de -1 desabilita o uso de <see langword="Thread.Sleep(1)" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="sleep1Threshold" /> é menor que -1.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean})">
      <summary>Gira até que a condição especificada seja atendida.</summary>
      <param name="condition">Um delegado a ser executado repetidamente até retornar true.</param>
      <exception cref="T:System.ArgumentNullException">O argumento <paramref name="condition" /> é nulo.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.Int32)">
      <summary>Gira até que a condição especificada seja atendida ou até que o tempo limite especificado expire.</summary>
      <param name="condition">Um delegado a ser executado repetidamente até retornar true.</param>
      <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
      <returns>
        <see langword="true" /> se a condição for atendida dentro do tempo limite; caso contrário, false</returns>
      <exception cref="T:System.ArgumentNullException">O argumento <paramref name="condition" /> é nulo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.TimeSpan)">
      <summary>Gira até que a condição especificada seja atendida ou até que o tempo limite especificado expire.</summary>
      <param name="condition">Um delegado a ser executado repetidamente até retornar true.</param>
      <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos de espera ou um TimeSpan que representa -1 milissegundo de espera indefinidamente.</param>
      <returns>
        <see langword="true" /> se a condição for atendida dentro do tempo limite; caso contrário, false</returns>
      <exception cref="T:System.ArgumentNullException">O argumento <paramref name="condition" /> é nulo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> é um número negativo diferente de -1 milissegundos, que representa um tempo limite infinito ou o tempo limite é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="T:System.Threading.SynchronizationContext">
      <summary>Fornece a funcionalidade básica para propagação de um contexto de sincronização em vários modelos de sincronização.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.#ctor">
      <summary>Cria uma nova instância da classe <see cref="T:System.Threading.SynchronizationContext" />.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.CreateCopy">
      <summary>Quando substituído em uma classe derivada, cria uma cópia do contexto de sincronização.</summary>
      <returns>Um novo objeto <see cref="T:System.Threading.SynchronizationContext" />.</returns>
    </member>
    <member name="P:System.Threading.SynchronizationContext.Current">
      <summary>Obtém o contexto de sincronização do thread atual.</summary>
      <returns>Um objeto <see cref="T:System.Threading.SynchronizationContext" /> que representa o contexto de sincronização atual.</returns>
    </member>
    <member name="M:System.Threading.SynchronizationContext.IsWaitNotificationRequired">
      <summary>Determina se a notificação de espera é necessária.</summary>
      <returns>
        <see langword="true" /> se a notificação de espera for necessária, caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.SynchronizationContext.OperationCompleted">
      <summary>Quando substituído em uma classe derivada, responde à notificação de que uma operação foi concluída.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.OperationStarted">
      <summary>Quando substituído em uma classe derivada, responde à notificação de que uma operação foi iniciada.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
      <summary>Quando substituído em uma classe derivada, envia uma mensagem assíncrona a um contexto de sincronização.</summary>
      <param name="d">O delegado de <see cref="T:System.Threading.SendOrPostCallback" /> a ser chamado.</param>
      <param name="state">O objeto passado ao delegado.</param>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
      <summary>Quando substituído em uma classe derivada, expede uma mensagem síncrona a um contexto de sincronização.</summary>
      <param name="d">O delegado de <see cref="T:System.Threading.SendOrPostCallback" /> a ser chamado.</param>
      <param name="state">O objeto passado ao delegado.</param>
      <exception cref="T:System.NotSupportedException">O método foi chamado em um aplicativo da Windows Store. A implementação de <see cref="T:System.Threading.SynchronizationContext" /> para aplicativos da Windows Store não dá suporte ao método <see cref="M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)" />.</exception>
    </member>
    <member name="M:System.Threading.SynchronizationContext.SetSynchronizationContext(System.Threading.SynchronizationContext)">
      <summary>Define o contexto de sincronização atual.</summary>
      <param name="syncContext">O objeto <see cref="T:System.Threading.SynchronizationContext" /> a ser definido.</param>
    </member>
    <member name="M:System.Threading.SynchronizationContext.SetWaitNotificationRequired">
      <summary>Define a notificação de que a notificação de espera é necessária e prepara o método de retorno de chamada para que possa ser chamado com mais confiança quando ocorre uma espera.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Wait(System.IntPtr[],System.Boolean,System.Int32)">
      <summary>Aguarda até que um ou todos os elementos da matriz especificada recebam um sinal.</summary>
      <param name="waitHandles">Uma matriz do tipo <see cref="T:System.IntPtr" /> que contém os identificadores do sistema operacional nativo.</param>
      <param name="waitAll">
        <see langword="true" /> para aguardar todos os identificadores; <see langword="false" /> para aguardar qualquer identificador.</param>
      <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
      <returns>O índice da matriz do objeto que atendeu à espera.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="waitHandles" /> é nulo.</exception>
    </member>
    <member name="M:System.Threading.SynchronizationContext.WaitHelper(System.IntPtr[],System.Boolean,System.Int32)">
      <summary>Função auxiliar que aguarda até que um ou todos os elementos da matriz especificada recebam um sinal.</summary>
      <param name="waitHandles">Uma matriz do tipo <see cref="T:System.IntPtr" /> que contém os identificadores do sistema operacional nativo.</param>
      <param name="waitAll">
        <see langword="true" /> para aguardar todos os identificadores; <see langword="false" /> para aguardar qualquer identificador.</param>
      <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
      <returns>O índice da matriz do objeto que atendeu à espera.</returns>
    </member>
    <member name="T:System.Threading.SynchronizationLockException">
      <summary>A exceção que é lançada quando um método exige que o chamador possua o bloqueio em um determinado Monitor, e o método é invocado por um chamador que não possui o bloqueio.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.SynchronizationLockException" /> com propriedades padrão.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.SynchronizationLockException" /> com dados serializados.</summary>
      <param name="info">O <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que mantém os dados de objeto serializados sobre a exceção que está sendo lançada.</param>
      <param name="context">O <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contém informações contextuais sobre a fonte ou o destino.</param>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.String)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.SynchronizationLockException" /> com uma mensagem de erro especificada.</summary>
      <param name="message">A mensagem de erro que explica a razão da exceção.</param>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.String,System.Exception)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.SynchronizationLockException" /> com uma mensagem de erro especificada e uma referência à exceção interna que é a causa da exceção.</summary>
      <param name="message">A mensagem de erro que explica a razão da exceção.</param>
      <param name="innerException">A exceção que é a causa da exceção atual. Caso o parâmetro <paramref name="innerException" /> não seja <see langword="null" />, a exceção atual é acionada em um bloco <see langword="catch" /> que identifica a exceção interna.</param>
    </member>
    <member name="T:System.Threading.ThreadLocal`1">
      <summary>Fornece armazenamento de dados local de thread.</summary>
      <typeparam name="T">Especifica o tipo dos dados armazenados por thread.</typeparam>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor">
      <summary>Inicializa a instância <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Boolean)">
      <summary>Inicializa a instância <see cref="T:System.Threading.ThreadLocal`1" /> e especifica se todos os valores podem ser acessados de qualquer thread.</summary>
      <param name="trackAllValues">
        <see langword="true" /> para controlar valores definidos na instância e expô-los por meio da propriedade <see cref="P:System.Threading.ThreadLocal`1.Values" />; caso contrário <see langword="false" />.</param>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0})">
      <summary>Inicializa a instância <see cref="T:System.Threading.ThreadLocal`1" /> com função <paramref name="valueFactory" /> especificada.</summary>
      <param name="valueFactory">O <see cref="T:System.Func`1" /> invocado para produzir um valor inicializado lentamente quando é feita uma tentativa de recuperar o <see cref="P:System.Threading.ThreadLocal`1.Value" /> sem ele ter sido anteriormente inicializado.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="valueFactory" /> é uma referência nula (Nada no Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0},System.Boolean)">
      <summary>Inicializa a instância <see cref="T:System.Threading.ThreadLocal`1" /> com a função <paramref name="valueFactory" /> especificada e um sinalizador que indica se todos os valores estão acessíveis em qualquer thread.</summary>
      <param name="valueFactory">O <see cref="T:System.Func`1" /> invocado para produzir um valor inicializado lentamente quando é feita uma tentativa de recuperar o <see cref="P:System.Threading.ThreadLocal`1.Value" /> sem ele ter sido anteriormente inicializado.</param>
      <param name="trackAllValues">
        <see langword="true" /> para controlar valores definidos na instância e expô-los por meio da propriedade <see cref="P:System.Threading.ThreadLocal`1.Values" />; caso contrário <see langword="false" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="valueFactory" /> é uma referência <see langword="null" /> (<see langword="Nothing" /> no Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose">
      <summary>Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose(System.Boolean)">
      <summary>Libera os recursos usados por esta instância <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
      <param name="disposing">Um valor booliano que indica se esse método está sendo chamado devido a uma chamada a <see cref="M:System.Threading.ThreadLocal`1.Dispose" />.</param>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Finalize">
      <summary>Libera os recursos usados por esta instância <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.IsValueCreated">
      <summary>Indica se <see cref="P:System.Threading.ThreadLocal`1.Value" /> é inicializado no thread atual.</summary>
      <returns>true se <see cref="P:System.Threading.ThreadLocal`1.Value" /> for inicializado no thread atual; caso contrário, false.</returns>
      <exception cref="T:System.ObjectDisposedException">A instância <see cref="T:System.Threading.ThreadLocal`1" /> foi descartada.</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.ToString">
      <summary>Cria e retorna uma representação de cadeia de caracteres desta instância para o thread atual.</summary>
      <returns>O resultado da chamada a <see cref="M:System.Object.ToString" /> no <see cref="P:System.Threading.ThreadLocal`1.Value" />.</returns>
      <exception cref="T:System.ObjectDisposedException">A instância <see cref="T:System.Threading.ThreadLocal`1" /> foi descartada.</exception>
      <exception cref="T:System.NullReferenceException">O <see cref="P:System.Threading.ThreadLocal`1.Value" /> para o thread atual é uma referência nula (Nothing no Visual Basic).</exception>
      <exception cref="T:System.InvalidOperationException">A função de inicialização tentou referenciar <see cref="P:System.Threading.ThreadLocal`1.Value" /> recursivamente.</exception>
      <exception cref="T:System.MissingMemberException">Nenhum construtor sem parâmetros é fornecido e nenhum alocador de valor é fornecido.</exception>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Value">
      <summary>Obtém ou define o valor dessa instância para o thread atual.</summary>
      <returns>Retorna uma instância do objeto que este ThreadLocal é responsável por inicializar.</returns>
      <exception cref="T:System.ObjectDisposedException">A instância <see cref="T:System.Threading.ThreadLocal`1" /> foi descartada.</exception>
      <exception cref="T:System.InvalidOperationException">A função de inicialização tentou referenciar <see cref="P:System.Threading.ThreadLocal`1.Value" /> recursivamente.</exception>
      <exception cref="T:System.MissingMemberException">Nenhum construtor sem parâmetros é fornecido e nenhum alocador de valor é fornecido.</exception>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Values">
      <summary>Obtém uma lista de todos os valores armazenados no momento por todos os threads que acessaram essa instância.</summary>
      <returns>Uma lista de todos os valores armazenados no momento por todos os threads que acessaram essa instância.</returns>
      <exception cref="T:System.InvalidOperationException">Os valores armazenados por todos os threads não estão disponíveis porque a instância foi inicializada com o argumento <paramref name="trackAllValues" /> definido como <see langword="false" /> na chamada para um construtor de classe.</exception>
      <exception cref="T:System.ObjectDisposedException">A instância <see cref="T:System.Threading.ThreadLocal`1" /> foi descartada.</exception>
    </member>
    <member name="T:System.Threading.Volatile">
      <summary>Contém métodos para executar operações de memória voláteis.</summary>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Boolean@)">
      <summary>Lê o valor do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location">O campo a ser lido.</param>
      <returns>O valor que foi lido. Este valor é o último gravado por qualquer processador no computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Byte@)">
      <summary>Lê o valor do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location">O campo a ser lido.</param>
      <returns>O valor que foi lido. Este valor é o último gravado por qualquer processador no computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Double@)">
      <summary>Lê o valor do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location">O campo a ser lido.</param>
      <returns>O valor que foi lido. Este valor é o último gravado por qualquer processador no computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int16@)">
      <summary>Lê o valor do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location">O campo a ser lido.</param>
      <returns>O valor que foi lido. Este valor é o último gravado por qualquer processador no computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int32@)">
      <summary>Lê o valor do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location">O campo a ser lido.</param>
      <returns>O valor que foi lido. Este valor é o último gravado por qualquer processador no computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int64@)">
      <summary>Lê o valor do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location">O campo a ser lido.</param>
      <returns>O valor que foi lido. Este valor é o último gravado por qualquer processador no computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.IntPtr@)">
      <summary>Lê o valor do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location">O campo a ser lido.</param>
      <returns>O valor que foi lido. Este valor é o último gravado por qualquer processador no computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.SByte@)">
      <summary>Lê o valor do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location">O campo a ser lido.</param>
      <returns>O valor que foi lido. Este valor é o último gravado por qualquer processador no computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Single@)">
      <summary>Lê o valor do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location">O campo a ser lido.</param>
      <returns>O valor que foi lido. Este valor é o último gravado por qualquer processador no computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt16@)">
      <summary>Lê o valor do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location">O campo a ser lido.</param>
      <returns>O valor que foi lido. Este valor é o último gravado por qualquer processador no computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt32@)">
      <summary>Lê o valor do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location">O campo a ser lido.</param>
      <returns>O valor que foi lido. Este valor é o último gravado por qualquer processador no computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt64@)">
      <summary>Lê o valor do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location">O campo a ser lido.</param>
      <returns>O valor que foi lido. Este valor é o último gravado por qualquer processador no computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UIntPtr@)">
      <summary>Lê o valor do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location">O campo a ser lido.</param>
      <returns>O valor que foi lido. Este valor é o último gravado por qualquer processador no computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read``1(``0@)">
      <summary>Lê a referência de objeto do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location">O campo a ser lido.</param>
      <typeparam name="T">O tipo do campo a ser lido. Este deve ser um tipo de referência, não um tipo de valor.</typeparam>
      <returns>A referência a <paramref name="T" /> que foi lida. A referência é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Boolean@,System.Boolean)">
      <summary>Grava o valor especificado no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location">O campo em que o valor é gravado.</param>
      <param name="value">O valor a ser gravado. O valor é gravado imediatamente para que fique visível a todos os processadores no computador.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Byte@,System.Byte)">
      <summary>Grava o valor especificado no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location">O campo em que o valor é gravado.</param>
      <param name="value">O valor a ser gravado. O valor é gravado imediatamente para que fique visível a todos os processadores no computador.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Double@,System.Double)">
      <summary>Grava o valor especificado no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location">O campo em que o valor é gravado.</param>
      <param name="value">O valor a ser gravado. O valor é gravado imediatamente para que fique visível a todos os processadores no computador.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int16@,System.Int16)">
      <summary>Grava o valor especificado no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location">O campo em que o valor é gravado.</param>
      <param name="value">O valor a ser gravado. O valor é gravado imediatamente para que fique visível a todos os processadores no computador.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int32@,System.Int32)">
      <summary>Grava o valor especificado no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location">O campo em que o valor é gravado.</param>
      <param name="value">O valor a ser gravado. O valor é gravado imediatamente para que fique visível a todos os processadores no computador.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int64@,System.Int64)">
      <summary>Grava o valor especificado no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location">O campo em que o valor é gravado.</param>
      <param name="value">O valor a ser gravado. O valor é gravado imediatamente para que fique visível a todos os processadores no computador.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.IntPtr@,System.IntPtr)">
      <summary>Grava o valor especificado no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location">O campo em que o valor é gravado.</param>
      <param name="value">O valor a ser gravado. O valor é gravado imediatamente para que fique visível a todos os processadores no computador.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.SByte@,System.SByte)">
      <summary>Grava o valor especificado no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location">O campo em que o valor é gravado.</param>
      <param name="value">O valor a ser gravado. O valor é gravado imediatamente para que fique visível a todos os processadores no computador.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Single@,System.Single)">
      <summary>Grava o valor especificado no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location">O campo em que o valor é gravado.</param>
      <param name="value">O valor a ser gravado. O valor é gravado imediatamente para que fique visível a todos os processadores no computador.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt16@,System.UInt16)">
      <summary>Grava o valor especificado no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location">O campo em que o valor é gravado.</param>
      <param name="value">O valor a ser gravado. O valor é gravado imediatamente para que fique visível a todos os processadores no computador.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt32@,System.UInt32)">
      <summary>Grava o valor especificado no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location">O campo em que o valor é gravado.</param>
      <param name="value">O valor a ser gravado. O valor é gravado imediatamente para que fique visível a todos os processadores no computador.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt64@,System.UInt64)">
      <summary>Grava o valor especificado no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location">O campo em que o valor é gravado.</param>
      <param name="value">O valor a ser gravado. O valor é gravado imediatamente para que fique visível a todos os processadores no computador.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UIntPtr@,System.UIntPtr)">
      <summary>Grava o valor especificado no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location">O campo em que o valor é gravado.</param>
      <param name="value">O valor a ser gravado. O valor é gravado imediatamente para que fique visível a todos os processadores no computador.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write``1(``0@,``0)">
      <summary>Grava a referência de objeto especificada no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location">O campo em que a referência de objeto é gravada.</param>
      <param name="value">A referência de objeto a gravar. A referência é gravada imediatamente para que fique visível a todos os processadores no computador.</param>
      <typeparam name="T">O tipo de campo a ser gravado. Este deve ser um tipo de referência, não um tipo de valor.</typeparam>
    </member>
    <member name="T:System.Threading.WaitHandleCannotBeOpenedException">
      <summary>A exceção que é gerada quando é feita uma tentativa de abrir um semáforo, um mutex do sistema ou um identificador de espera de evento que não existe.</summary>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> com valores padrão.</summary>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> com dados serializados.</summary>
      <param name="info">O objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que mantém os dados de objeto serializados sobre a exceção que está sendo lançada.</param>
      <param name="context">O objeto <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contém informações contextuais sobre a fonte ou o destino.</param>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> com uma mensagem de erro especificada.</summary>
      <param name="message">A mensagem de erro que explica a razão da exceção.</param>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String,System.Exception)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> com uma mensagem de erro especificada e uma referência à exceção interna que é a causa da exceção.</summary>
      <param name="message">A mensagem de erro que explica a razão da exceção.</param>
      <param name="innerException">A exceção que é a causa da exceção atual. Caso o parâmetro <paramref name="innerException" /> não seja <see langword="null" />, a exceção atual é acionada em um bloco <see langword="catch" /> que identifica a exceção interna.</param>
    </member>
  </members>
</doc>