<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Reflection.Emit</name>
  </assembly>
  <members>
    <member name="T:System.Reflection.Emit.AssemblyBuilder">
      <summary>Define e representa um assembly dinâmico.</summary>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.CodeBase">
      <summary>Obtém o local do assembly como especificado originalmente (como em um objeto <see cref="T:System.Reflection.AssemblyName" />).</summary>
      <returns>O local do assembly, conforme especificado originalmente.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para este método atualmente.</exception>
      <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
      <summary>Define um assembly dinâmico que tem o nome e os direitos de acesso especificados.</summary>
      <param name="name">O nome do assembly.</param>
      <param name="access">Os direitos de acesso do assembly.</param>
      <returns>Um objeto que representa o novo assembly.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
      <summary>Define um novo assembly que tem o nome, os direitos de acesso e os atributos especificados.</summary>
      <param name="name">O nome do assembly.</param>
      <param name="access">Os direitos de acesso do assembly.</param>
      <param name="assemblyAttributes">Uma coleção que contém os atributos do assembly.</param>
      <returns>Um objeto que representa o novo assembly.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
      <summary>Define um módulo dinâmico transitório nomeado nesse assembly.</summary>
      <param name="name">O nome do módulo dinâmico.</param>
      <returns>Um <see cref="T:System.Reflection.Emit.ModuleBuilder" /> que representa o módulo dinâmico definido.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> começa com um espaço em branco.
-ou-
O comprimento de <paramref name="name" /> é zero.
-ou-
O comprimento de <paramref name="name" /> é maior que o comprimento máximo definido pelo sistema.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
      <exception cref="T:System.ExecutionEngineException">Não é possível carregar o assembly para o gravador de símbolo padrão.
-ou-
Não foi possível encontrar o tipo que implementa a interface do gravador de símbolo padrão.</exception>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.EntryPoint">
      <summary>Retorna o ponto de entrada desse assembly.</summary>
      <returns>O ponto de entrada deste assembly.</returns>
      <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.Equals(System.Object)">
      <summary>Retorna um valor que indica se essa instância é igual ao objeto especificado.</summary>
      <param name="obj">Um objeto a ser comparado com essa instância ou <see langword="null" />.</param>
      <returns>
        <see langword="true" /> se <paramref name="obj" /> for igual ao tipo e ao valor dessa instância, caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.FullName">
      <summary>Obtém o nome de exibição do assembly dinâmico atual.</summary>
      <returns>O nome de exibição do assembly dinâmico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Retorna todos os atributos personalizados que foram aplicados ao <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> atual.</summary>
      <param name="inherit">Este argumento é ignorado para objetos deste tipo.</param>
      <returns>Uma matriz que contém os atributos personalizados; a matriz será vazia se não houver nenhum atributo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Retorna todos os atributos personalizados que foram aplicados ao <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> atual e que derivam de um tipo de atributo especificado.</summary>
      <param name="attributeType">O tipo base do qual derivam os atributos.</param>
      <param name="inherit">Este argumento é ignorado para objetos deste tipo.</param>
      <returns>Uma matriz que contém os atributos personalizados que são derivados em qualquer nível de <paramref name="attributeType" />; a matriz será vazia se não houver nenhum desses atributos.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributeType" /> não é um objeto <see cref="T:System.Type" /> fornecido pelo tempo de execução. Por exemplo, <paramref name="attributeType" /> é um objeto <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributesData">
      <summary>Retorna objetos <see cref="T:System.Reflection.CustomAttributeData" /> que contêm informações sobre os atributos que foram aplicados ao <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> atual.</summary>
      <returns>Uma lista genérica de objetos <see cref="T:System.Reflection.CustomAttributeData" /> que representam dados sobre os atributos que foram aplicados ao módulo atual.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule(System.String)">
      <summary>Retorna o módulo dinâmico com o nome especificado.</summary>
      <param name="name">O nome do módulo dinâmico solicitado.</param>
      <returns>Um objeto ModuleBuilder que representa o módulo dinâmico solicitado.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">O comprimento de <paramref name="name" /> é zero.</exception>
      <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetExportedTypes">
      <summary>Obtém os tipos exportados definidos neste assembly.</summary>
      <returns>Uma matriz de <see cref="T:System.Type" /> que contém os tipos exportados definidos neste assembly.</returns>
      <exception cref="T:System.NotSupportedException">Este método não está implementado.</exception>
      <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetFile(System.String)">
      <summary>Obtém um <see cref="T:System.IO.FileStream" /> para o arquivo especificado na tabela de arquivo do manifesto desse assembly.</summary>
      <param name="name">O nome do arquivo especificado.</param>
      <returns>Um <see cref="T:System.IO.FileStream" /> para o arquivo especificado, ou <see langword="null" /> se o arquivo não for encontrado.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para este método atualmente.</exception>
      <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetFiles(System.Boolean)">
      <summary>Obtém os arquivos na tabela de arquivos de um manifesto do assembly, especificando se deseja-se incluir os módulos de recursos.</summary>
      <param name="getResourceModules">
        <see langword="true" /> para incluir os módulos de recursos; caso contrário, <see langword="false" />.</param>
      <returns>Uma matriz de objetos de <see cref="T:System.IO.FileStream" />.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para este método atualmente.</exception>
      <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetHashCode">
      <summary>Retorna o código hash para essa instância.</summary>
      <returns>Um código de hash do inteiro assinado de 32 bits.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetLoadedModules(System.Boolean)">
      <summary>Retorna todos os módulos carregados que fazem parte desse assembly e, opcionalmente, inclui módulos de recursos.</summary>
      <param name="getResourceModules">
        <see langword="true" /> para incluir os módulos de recursos; caso contrário, <see langword="false" />.</param>
      <returns>Os módulos carregados que fazem parte desse assembly.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceInfo(System.String)">
      <summary>Retorna informações sobre como o recurso em questão foi persistido.</summary>
      <param name="resourceName">O nome do recurso.</param>
      <returns>
        <see cref="T:System.Reflection.ManifestResourceInfo" /> é preenchido com informações sobre a topologia do recurso ou <see langword="null" />, se o recurso não for encontrado.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para este método atualmente.</exception>
      <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceNames">
      <summary>Carrega o recurso de manifesto especificado desse assembly.</summary>
      <returns>Uma matriz do tipo <see langword="String" /> que contém os nomes de todos os recursos.</returns>
      <exception cref="T:System.NotSupportedException">Este método não tem suporte em um assembly dinâmico. Para obter os nomes de recurso de manifesto, use <see cref="M:System.Reflection.Assembly.GetManifestResourceNames" />.</exception>
      <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.String)">
      <summary>Carrega o recurso de manifesto especificado desse assembly.</summary>
      <param name="name">O nome do recurso de manifesto solicitado.</param>
      <returns>Um <see cref="T:System.IO.Stream" /> que representa esse recurso de manifesto.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para este método atualmente.</exception>
      <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.Type,System.String)">
      <summary>Carrega o recurso de manifesto especificado, o escopo pelo namespace do tipo especificado, desse assembly.</summary>
      <param name="type">O tipo cujo namespace é usado para definir o escopo do nome de recurso de manifesto.</param>
      <param name="name">O nome do recurso de manifesto solicitado.</param>
      <returns>Um <see cref="T:System.IO.Stream" /> que representa esse recurso de manifesto.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para este método atualmente.</exception>
      <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetModule(System.String)">
      <summary>Obtém o módulo especificado nesse assembly.</summary>
      <param name="name">O nome do módulo solicitado.</param>
      <returns>O módulo que está sendo solicitado ou <see langword="null" />, se o módulo não tiver sido encontrado.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetModules(System.Boolean)">
      <summary>Obtém todos os módulos que fazem parte desse assembly e, opcionalmente, inclui módulos de recursos.</summary>
      <param name="getResourceModules">
        <see langword="true" /> para incluir os módulos de recursos; caso contrário, <see langword="false" />.</param>
      <returns>Os módulos que fazem parte desse assembly.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetName(System.Boolean)">
      <summary>Obtém o <see cref="T:System.Reflection.AssemblyName" />, que foi especificado quando o assembly dinâmico atual foi criado e define a base de código como especificado.</summary>
      <param name="copiedName">
        <see langword="true" /> para definir a base de código para o local do assembly depois que tiver sido feita uma cópia de sombra dele; <see langword="false" /> para definir a base de código com o local original.</param>
      <returns>O nome do assembly dinâmico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetReferencedAssemblies">
      <summary>Obtém uma lista incompleta de objetos <see cref="T:System.Reflection.AssemblyName" /> para os assemblies que são referenciados por este <see cref="T:System.Reflection.Emit.AssemblyBuilder" />.</summary>
      <returns>Uma matriz de nomes de assembly para os assemblies referenciados. Esta matriz não é uma lista completa.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo)">
      <summary>Obtém o assembly satélite para a cultura especificada.</summary>
      <param name="culture">A cultura especificada.</param>
      <returns>O assembly satélite especificado.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="culture" /> é <see langword="null" />.</exception>
      <exception cref="T:System.IO.FileNotFoundException">Não foi possível localizar o assembly.</exception>
      <exception cref="T:System.IO.FileLoadException">O assembly satélite com um nome de arquivo correspondente foi encontrado, mas o <see langword="CultureInfo" /> não correspondia ao especificado.</exception>
      <exception cref="T:System.BadImageFormatException">O assembly satélite não é um assembly válido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
      <summary>Obtém a versão especificada do assembly satélite para a cultura especificada.</summary>
      <param name="culture">A cultura especificada.</param>
      <param name="version">A versão do assembly satélite.</param>
      <returns>O assembly satélite especificado.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="culture" /> é <see langword="null" />.</exception>
      <exception cref="T:System.IO.FileLoadException">O assembly satélite com um nome de arquivo correspondente foi encontrado, mas o <see langword="CultureInfo" /> ou a versão não correspondia ao especificado.</exception>
      <exception cref="T:System.IO.FileNotFoundException">Não foi possível localizar o assembly.</exception>
      <exception cref="T:System.BadImageFormatException">O assembly satélite não é um assembly válido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetType(System.String,System.Boolean,System.Boolean)">
      <summary>Obtém o tipo especificado dos tipos que foram definidos e criados no <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> atual.</summary>
      <param name="name">O nome do tipo a ser pesquisado.</param>
      <param name="throwOnError">
        <see langword="true" /> para gerar uma exceção se o tipo não for encontrado; caso contrário <see langword="false" />.</param>
      <param name="ignoreCase">
        <see langword="true" /> para ignorar maiúsculas e minúsculas do nome do tipo durante a pesquisa; caso contrário, <see langword="false" />.</param>
      <returns>O tipo especificado, ou <see langword="null" /> se o tipo não for encontrado ou ainda não tiver sido criado.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.GlobalAssemblyCache">
      <summary>Obtém um valor que indica se o assembly foi carregado do cache de assembly global.</summary>
      <returns>Sempre <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.HostContext">
      <summary>Obtém o contexto do host em que o assembly dinâmico está sendo criado.</summary>
      <returns>Um valor que indica o contexto de host em que o assembly dinâmico está sendo criado.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.ImageRuntimeVersion">
      <summary>Obtém a versão do Common Language Runtime que será salvo no arquivo que contém o manifesto.</summary>
      <returns>Uma cadeia de caracteres que representa a versão de Common Language Runtime.</returns>
      <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Retorna um valor que indica se uma ou mais instâncias do tipo de atributo especificado será aplicada a esse membro.</summary>
      <param name="attributeType">O tipo de atributo a ser testado.</param>
      <param name="inherit">Este argumento é ignorado para objetos deste tipo.</param>
      <returns>
        <see langword="true" /> se uma ou mais instâncias de <paramref name="attributeType" /> for aplicada a este assembly dinâmico; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.IsDynamic">
      <summary>Obtém um valor que indica que o assembly atual é um assembly dinâmico.</summary>
      <returns>Sempre <see langword="true" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.Location">
      <summary>Obtém o local, no formato de base de código, do arquivo carregado que contém o manifesto, caso não tenha sido feita cópia de sombra dele.</summary>
      <returns>A localização do arquivo carregado que contém o manifesto. Se o arquivo carregado tiver sido copiado por sombra, o <see langword="Location" /> será o do arquivo antes de ser copiado por sombra.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para este método atualmente.</exception>
      <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.ManifestModule">
      <summary>Obtém o módulo no <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> atual que contém o manifesto do assembly.</summary>
      <returns>O módulo de manifesto.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.ReflectionOnly">
      <summary>Obtém um valor que indica se o assembly dinâmico está no contexto de somente reflexão.</summary>
      <returns>
        <see langword="true" /> se o assembly dinâmico estiver no contexto somente de reflexão; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Defina um atributo personalizado neste assembly usando um blob de atributos personalizados especificado.</summary>
      <param name="con">O construtor do atributo personalizado.</param>
      <param name="binaryAttribute">Um blob de bytes que representa os atributos.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="con" /> não é um objeto <see langword="RuntimeConstructorInfo" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Defina um atributo personalizado neste assembly usando um construtor de atributos personalizados.</summary>
      <param name="customBuilder">Uma instância de uma classe auxiliar para definir o atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="T:System.Reflection.Emit.AssemblyBuilderAccess">
      <summary>Define os modos de acesso para um assembly dinâmico.</summary>
    </member>
    <member name="F:System.Reflection.Emit.AssemblyBuilderAccess.Run">
      <summary>O assembly dinâmico pode ser executado, mas não salvo.</summary>
    </member>
    <member name="F:System.Reflection.Emit.AssemblyBuilderAccess.RunAndCollect">
      <summary>O assembly dinâmico será descarregado automaticamente e sua memória será recuperada quando ele não estiver mais acessível.</summary>
    </member>
    <member name="T:System.Reflection.Emit.ConstructorBuilder">
      <summary>Define e representa um construtor de uma classe dinâmica.</summary>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.Attributes">
      <summary>Obtém os atributos para esse construtor.</summary>
      <returns>Os atributos para este construtor.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.CallingConvention">
      <summary>Obtém um valor <see cref="T:System.Reflection.CallingConventions" /> que depende de se o tipo declarativo é genérico.</summary>
      <returns>
        <see cref="F:System.Reflection.CallingConventions.HasThis" /> se o tipo declarativo for genérico; caso contrário, <see cref="F:System.Reflection.CallingConventions.Standard" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.DeclaringType">
      <summary>Obtém uma referência para o objeto <see cref="T:System.Type" /> para o tipo que declara esse membro.</summary>
      <returns>O tipo que declara esse membro.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
      <summary>Define um parâmetro deste construtor.</summary>
      <param name="iSequence">A posição do parâmetro na lista de parâmetros. Os parâmetros são indexados começando com o número 1 para o primeiro parâmetro.</param>
      <param name="attributes">Os atributos do parâmetro.</param>
      <param name="strParamName">O nome do parâmetro. O nome pode ser a cadeia de caracteres nula.</param>
      <returns>Um objeto que representa o novo parâmetro deste construtor.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="iSequence" /> é menor que 0 (zero) ou é maior que o número de parâmetros do construtor.</exception>
      <exception cref="T:System.InvalidOperationException">O tipo recipiente foi criado usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Retorna todos os atributos personalizados definidos para esse construtor.</summary>
      <param name="inherit">Controla a herança de atributos personalizados de classes base. Este parâmetro é ignorado.</param>
      <returns>Uma matriz de objetos que representa todos os atributos personalizados do construtor representados por essa instância <see cref="T:System.Reflection.Emit.ConstructorBuilder" />.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para este método atualmente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Retorna os atributos personalizados identificados pelo tipo determinado.</summary>
      <param name="attributeType">O tipo de atributo personalizado.</param>
      <param name="inherit">Controla a herança de atributos personalizados de classes base. Este parâmetro é ignorado.</param>
      <returns>Uma matriz de objeto que representa os atributos deste construtor.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para este método atualmente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator">
      <summary>Obtém um <see cref="T:System.Reflection.Emit.ILGenerator" /> para esse construtor.</summary>
      <returns>Um objeto <see cref="T:System.Reflection.Emit.ILGenerator" /> para esse construtor.</returns>
      <exception cref="T:System.InvalidOperationException">O construtor é um construtor sem parâmetros.
-ou-
O construtor tem sinalizadores <see cref="T:System.Reflection.MethodAttributes" /> ou <see cref="T:System.Reflection.MethodImplAttributes" /> indicando que ele não deve ter um corpo de método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator(System.Int32)">
      <summary>Obtém um objeto <see cref="T:System.Reflection.Emit.ILGenerator" />, com o tamanho de fluxo MSIL especificado, que pode ser usado para criar um corpo de método para esse construtor.</summary>
      <param name="streamSize">O tamanho do fluxo MSIL, em bytes.</param>
      <returns>Um <see cref="T:System.Reflection.Emit.ILGenerator" /> para esse construtor.</returns>
      <exception cref="T:System.InvalidOperationException">O construtor é um construtor sem parâmetros.
-ou-
O construtor tem sinalizadores <see cref="T:System.Reflection.MethodAttributes" /> ou <see cref="T:System.Reflection.MethodImplAttributes" /> indicando que ele não deve ter um corpo de método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetMethodImplementationFlags">
      <summary>Retorna os sinalizadores de implementação de método para esse construtor.</summary>
      <returns>Os sinalizadores de implementação de método para esse construtor.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetParameters">
      <summary>Retorna os parâmetros desse construtor.</summary>
      <returns>Uma matriz que representa os parâmetros deste construtor.</returns>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> não foi chamado nesse tipo de construtor, no .NET Framework versões 1.0 e 1.1.</exception>
      <exception cref="T:System.NotSupportedException">
        <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> não foi chamado nesse tipo de construtor, no .NET Framework versão 2.0.</exception>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.InitLocals">
      <summary>Obtém ou define se as variáveis locais neste construtor devem ser inicializadas do zero.</summary>
      <returns>Leitura/gravação. Obtém ou define se as variáveis locais neste construtor devem ser inicializadas do zero.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>Invoca dinamicamente o construtor refletido por esta instância com os argumentos especificados, sob as restrições do <see langword="Binder" /> especificado.</summary>
      <param name="obj">O objeto que precisa ser reiniciado.</param>
      <param name="invokeAttr">Um dos valores <see langword="BindingFlags" /> que especifica o tipo de associação desejada.</param>
      <param name="binder">Um <see langword="Binder" /> que define um conjunto de propriedades e permite a associação, coerção de tipos de argumento e invocação de membros usando a reflexão. Se <paramref name="binder" /> for <see langword="null" />, Binder.DefaultBinding será usado.</param>
      <param name="parameters">Uma lista de argumentos. Essa é uma matriz de argumentos com o mesmo número, ordem e tipo que os parâmetros do construtor a ser invocado. Se não houver nenhum parâmetro, isso deverá ser uma referência nula (<see langword="Nothing" /> no Visual Basic).</param>
      <param name="culture">Um <see cref="T:System.Globalization.CultureInfo" /> usado para reger a coerção de tipos. Se isso for nulo, será usado o <see cref="T:System.Globalization.CultureInfo" /> do thread atual.</param>
      <returns>Uma instância da classe associada ao construtor.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para este método atualmente. Você pode recuperar o construtor usando <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chamar <see cref="M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /> no <see cref="T:System.Reflection.ConstructorInfo" /> retornado.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>Invoca o construtor dinamicamente representado por esta instância no objeto determinado, passando os parâmetros especificados e sob as restrições do associador determinado.</summary>
      <param name="invokeAttr">Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como InvokeMethod, NonPublic e assim por diante.</param>
      <param name="binder">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see langword="MemberInfo" /> usando reflexão. Se o associador for <see langword="null" />, o associador padrão será usado. Consulte <see cref="T:System.Reflection.Binder" />.</param>
      <param name="parameters">Uma lista de argumentos. Essa é uma matriz de argumentos com o mesmo número, ordem e tipo que os parâmetros do construtor a ser invocado. Se não houver nenhum parâmetro, isso deverá ser <see langword="null" />.</param>
      <param name="culture">Uma instância de <see cref="T:System.Globalization.CultureInfo" /> usada para determinar a coerção de tipos. Se isso for nulo, será usado o <see cref="T:System.Globalization.CultureInfo" /> do thread atual. (Por exemplo, isso é necessário para converter um <see cref="T:System.String" /> que representa 1000 para um valor <see cref="T:System.Double" />, uma vez que 1000 é representado de forma diferente por diferentes culturas.)</param>
      <returns>O valor retornado pelo construtor invocado.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para este método atualmente. Você pode recuperar o construtor usando <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chamar <see cref="M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /> no <see cref="T:System.Reflection.ConstructorInfo" /> retornado.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Verifica se o tipo de atributo personalizado especificado é definido.</summary>
      <param name="attributeType">Um tipo de atributo personalizado.</param>
      <param name="inherit">Controla a herança de atributos personalizados de classes base. Este parâmetro é ignorado.</param>
      <returns>
        <see langword="true" /> se o tipo de atributo personalizado especificado estiver definido, caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para este método atualmente. Você pode recuperar o construtor usando <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chamar <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> no <see cref="T:System.Reflection.ConstructorInfo" /> retornado.</exception>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.MethodHandle">
      <summary>Obtém o identificador interno para o método. Use esse identificador para acessar o identificador de metadados subjacente.</summary>
      <returns>O identificador interno do método. Use esse identificador para acessar o identificador de metadados subjacente.</returns>
      <exception cref="T:System.NotSupportedException">Esta propriedade não tem suporte nesta classe.</exception>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.Module">
      <summary>Obtém o módulo dinâmico no qual este construtor é definido.</summary>
      <returns>Um objeto <see cref="T:System.Reflection.Module" /> que representa o módulo dinâmico no qual esse construtor é definido.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.Name">
      <summary>Recupera o nome desse construtor.</summary>
      <returns>O nome deste construtor.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.ReflectedType">
      <summary>Contém uma referência para o objeto <see cref="T:System.Type" /> do qual esse objeto foi definido.</summary>
      <returns>O objeto <see langword="Type" /> do qual esse objeto foi obtido.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Define um atributo personalizado usando um blob de atributo personalizado especificado.</summary>
      <param name="con">O construtor do atributo personalizado.</param>
      <param name="binaryAttribute">Um blob de bytes que representa os atributos.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Defina um atributo personalizado usando um construtor de atributos personalizados.</summary>
      <param name="customBuilder">Uma instância de uma classe auxiliar para definir o atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
      <summary>Define os sinalizadores de implementação de método para esse construtor.</summary>
      <param name="attributes">Os sinalizadores de implementação de método.</param>
      <exception cref="T:System.InvalidOperationException">O tipo recipiente foi criado usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.ToString">
      <summary>Retorna essa instância <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> como um <see cref="T:System.String" />.</summary>
      <returns>Uma cadeia de caracteres contém o nome, os atributos e as exceções desse construtor, seguidos pelo fluxo do MSIL (Microsoft Intermediate Language) atual.</returns>
    </member>
    <member name="T:System.Reflection.Emit.EnumBuilder">
      <summary>Descreve e representa um tipo de enumeração.</summary>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Assembly">
      <summary>Recupera o assembly dinâmico que contém essa definição enum.</summary>
      <returns>Somente leitura. O assembly dinâmico que contém essa definição de enumeração.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.AssemblyQualifiedName">
      <summary>Retorna o caminho completo dessa enum qualificado pelo nome de exibição do assembly pai.</summary>
      <returns>Somente leitura. O caminho completo desta enumeração qualificado pelo nome de exibição do assembly pai.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.BaseType">
      <summary>Retorna o <see cref="T:System.Type" /> pai desse tipo, que é sempre <see cref="T:System.Enum" />.</summary>
      <returns>Somente leitura. O <see cref="T:System.Type" /> pai deste tipo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.CreateTypeInfo">
      <summary>Obtém um objeto <see cref="T:System.Reflection.TypeInfo" /> que representa essa enumeração.</summary>
      <returns>Um objeto que representa essa enumeração.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.DeclaringType">
      <summary>Retorna o tipo que declarou esse <see cref="T:System.Reflection.Emit.EnumBuilder" />.</summary>
      <returns>Somente leitura. O tipo que declarou este <see cref="T:System.Reflection.Emit.EnumBuilder" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.DefineLiteral(System.String,System.Object)">
      <summary>Define o campo estático chamado em um tipo de enumeração com o valor constante especificado.</summary>
      <param name="literalName">O nome do campo estático.</param>
      <param name="literalValue">O valor constante do literal.</param>
      <returns>O campo definido.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.FullName">
      <summary>Retorna o caminho completo dessa enum.</summary>
      <returns>Somente leitura. O caminho completo desta enumeração.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetConstructors(System.Reflection.BindingFlags)">
      <summary>Retorna uma matriz de objetos <see cref="T:System.Reflection.ConstructorInfo" /> que representam os construtores público e não público definidos para essa classe, conforme especificado.</summary>
      <param name="bindingAttr">Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns>Retorna uma matriz de objetos <see cref="T:System.Reflection.ConstructorInfo" /> que representam os construtores especificados definidos para esta classe. Se nenhum construtor for definido, uma matriz vazia será retornada.</returns>
      <exception cref="T:System.NotSupportedException">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Retorna todos os atributos personalizados definidos para esse construtor.</summary>
      <param name="inherit">Especifica se deve-se pesquisar ou não a cadeia de herança desse membro para localizar os atributos.</param>
      <returns>Retorna uma matriz de objetos que representa todos os atributos personalizados do construtor representados por essa instância <see cref="T:System.Reflection.Emit.ConstructorBuilder" />.</returns>
      <exception cref="T:System.NotSupportedException">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Retorna os atributos personalizados identificados pelo tipo determinado.</summary>
      <param name="attributeType">O objeto <see langword="Type" /> ao qual os atributos personalizados são aplicados.</param>
      <param name="inherit">Especifica se deve-se pesquisar ou não a cadeia de herança desse membro para localizar os atributos.</param>
      <returns>Retorna uma matriz de objetos que representa os atributos desse construtor que são de <see cref="T:System.Type" /><paramref name="attributeType" />.</returns>
      <exception cref="T:System.NotSupportedException">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetElementType">
      <summary>A chamada desse método sempre lança <see cref="T:System.NotSupportedException" />.</summary>
      <returns>Não há suporte para o método. Nenhum valor é retornado.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para este método atualmente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEnumUnderlyingType">
      <summary>Retorna o tipo inteiro subjacente da enumeração atual, que é definido quando o construtor de enumeração é definido.</summary>
      <returns>O tipo subjacente.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
      <summary>Retorna o evento com o nome especificado.</summary>
      <param name="name">O nome do evento a ser obtido.</param>
      <param name="bindingAttr">Esse atributo de invocação. Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns>Retorna um objeto <see cref="T:System.Reflection.EventInfo" /> que representa o evento declarado ou herdado por esse tipo com o nome especificado. Se não houver correspondências, <see langword="null" /> será retornado.</returns>
      <exception cref="T:System.NotSupportedException">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEvents">
      <summary>Retorna os eventos para os eventos públicos declarados ou herdados por esse tipo.</summary>
      <returns>Retorna uma matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representa os eventos públicos declarados ou herdados por esse tipo. Uma matriz vazia será retornada se não houver eventos públicos.</returns>
      <exception cref="T:System.NotSupportedException">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEvents(System.Reflection.BindingFlags)">
      <summary>Retorna os eventos públicos e não públicos que são declarados por esse tipo.</summary>
      <param name="bindingAttr">Esse deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns>Retorna uma matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representam os eventos públicos e não públicos declarados ou herdados por esse tipo. Se não há eventos, uma matriz vazia é retornada, conforme especificado.</returns>
      <exception cref="T:System.NotSupportedException">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary>Retorna o campo especificado pelo nome fornecido.</summary>
      <param name="name">O nome do campo a ser obtido.</param>
      <param name="bindingAttr">Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns>Retorna o objeto <see cref="T:System.Reflection.FieldInfo" /> que representa o campo declarado ou herdado por esse tipo com o nome especificado e o modificador público ou não público. Se não houver correspondências, nulo será retornado.</returns>
      <exception cref="T:System.NotSupportedException">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary>Retorna os campos públicos e não públicos que são declarados por esse tipo.</summary>
      <param name="bindingAttr">Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como InvokeMethod, NonPublic e assim por diante.</param>
      <returns>Retorna uma matriz de objetos <see cref="T:System.Reflection.FieldInfo" /> que representam os campos públicos e não públicos declarados ou herdados por esse tipo. Se não há campos, uma matriz vazia é retornada, conforme especificado.</returns>
      <exception cref="T:System.NotSupportedException">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetInterface(System.String,System.Boolean)">
      <summary>Retorna a interface implementada (direta ou indiretamente) por este tipo, com o nome totalmente qualificado especificado.</summary>
      <param name="name">O nome da interface.</param>
      <param name="ignoreCase">Se <see langword="true" />, a pesquisa não diferenciará maiúsculas de minúsculas. Se <see langword="false" />, a pesquisa diferenciará maiúsculas de minúsculas.</param>
      <returns>Retorna um objeto <see cref="T:System.Type" /> que representa a interface implementada. Retorna nulo se nenhum nome de interface correspondente for encontrado.</returns>
      <exception cref="T:System.NotSupportedException">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetInterfaceMap(System.Type)">
      <summary>Retorna um mapeamento de interface para a interface solicitada.</summary>
      <param name="interfaceType">O tipo de interface para a qual o mapeamento da interface deve ser recuperado.</param>
      <returns>O mapeamento de interface solicitado.</returns>
      <exception cref="T:System.ArgumentException">O tipo não implementa a interface.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetInterfaces">
      <summary>Retorna que uma matriz de todas as interfaces implementadas em uma classe e suas classes base.</summary>
      <returns>Retorna uma matriz de objetos <see cref="T:System.Type" /> que representam as interfaces implementadas. Se nenhum deles for definido, uma matriz vazia será retornada.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
      <summary>Retorna todos os membros com o nome especificado, o tipo e a associação que são declaradas ou herdadas por esse tipo.</summary>
      <param name="name">O nome do membro.</param>
      <param name="type">O tipo do membro que deve ser retornado.</param>
      <param name="bindingAttr">Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns>Retorna uma matriz de <see cref="T:System.Reflection.MemberInfo" /> objetos que representam os membros públicos e não públicos definidos nesse tipo se <paramref name="nonPublic" /> for usado; caso contrário, somente os membros públicos serão retornados.</returns>
      <exception cref="T:System.NotSupportedException">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetMembers(System.Reflection.BindingFlags)">
      <summary>Retorna os membros especificados declarados ou herdados por esse tipo.</summary>
      <param name="bindingAttr">Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns>Retorna uma matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representam os membros públicos e não públicos declarados ou herdados por esse tipo. Se não houver membros correspondentes, uma matriz vazia será retornada.</returns>
      <exception cref="T:System.NotSupportedException">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary>Retorna todos os métodos públicos e não públicos declarados ou herdados por esse tipo, conforme especificado.</summary>
      <param name="bindingAttr">Esse deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns>Retorna uma matriz de objetos <see cref="T:System.Reflection.MethodInfo" /> que representam os métodos públicos e não públicos definidos neste tipo se <paramref name="nonPublic" /> for usado; caso contrário, somente os métodos públicos serão retornados.</returns>
      <exception cref="T:System.NotSupportedException">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
      <summary>Retorna o tipo aninhado especificado que é declarado por esse tipo.</summary>
      <param name="name">O <see cref="T:System.String" /> que contém o nome do tipo aninhado a ser obtido.</param>
      <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.
-ou-
Zero, para realizar uma pesquisa que diferencia maiúsculas de minúsculas para métodos públicos.</param>
      <returns>Um objeto <see cref="T:System.Type" /> que representa o tipo aninhado que corresponde aos requisitos especificados, se encontrado; caso contrário, <see langword="null" />.</returns>
      <exception cref="T:System.NotSupportedException">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
      <summary>Retorna os tipos aninhados públicos e não públicos que são declarados ou herdados por esse tipo.</summary>
      <param name="bindingAttr">Esse deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns>Uma matriz de objetos <see cref="T:System.Type" /> que representa todos os tipos aninhados no <see cref="T:System.Type" /> atual que correspondem às restrições de associação especificadas.
Uma matriz vazia do tipo <see cref="T:System.Type" /> se nenhum tipo estiver aninhado no <see cref="T:System.Type" /> atual ou se nenhum dos tipos aninhados corresponderem às restrições de associação.</returns>
      <exception cref="T:System.NotSupportedException">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetProperties(System.Reflection.BindingFlags)">
      <summary>Retorna todas as propriedades públicas e não públicas declaradas ou herdadas por esse tipo, conforme especificado.</summary>
      <param name="bindingAttr">Esse atributo de invocação. Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns>Retorna uma matriz de objetos <see cref="T:System.Reflection.PropertyInfo" /> que representam as propriedades públicas e não públicas definidas nesse tipo se <paramref name="nonPublic" /> for usado; caso contrário, somente as propriedades públicas serão retornadas.</returns>
      <exception cref="T:System.NotSupportedException">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.GUID">
      <summary>Retorna o GUID desta enum.</summary>
      <returns>Somente leitura. O GUID desta enumeração.</returns>
      <exception cref="T:System.NotSupportedException">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
      <summary>Invoca o membro especificado. O método a ser invocado deve ser acessível e fornecer a correspondência mais específica com a lista de argumentos especificada, sob as restrições dos atributos associadores e de invocação especificados.</summary>
      <param name="name">O nome do membro a ser invocado. Isso pode ser um construtor, um método, uma propriedade ou um campo. É necessário especificar um atributo de invocação adequado. Observe que é possível invocar o membro padrão de uma classe, passando uma cadeia de caracteres vazia como o nome do membro.</param>
      <param name="invokeAttr">O atributo de invocação. Isso deve ser um sinalizador de bit de <see langword="BindingFlags" />.</param>
      <param name="binder">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see langword="MemberInfo" /> usando reflexão. Se o associador for <see langword="null" />, o associador padrão será usado. Consulte <see cref="T:System.Reflection.Binder" />.</param>
      <param name="target">O objeto no qual invocar o membro especificado. Se o membro é estático, esse parâmetro é ignorado.</param>
      <param name="args">Uma lista de argumentos. Essa é uma matriz de objetos que contém o número, a ordem e o tipo dos parâmetros do membro a ser invocado. Se não houver nenhum parâmetro, isso deverá ser nulo.</param>
      <param name="modifiers">Uma matriz do mesmo comprimento que <paramref name="args" /> com elementos que representam os atributos associados com os argumentos do membro a ser invocado. Um parâmetro com atributos associados a ele nos metadados. Eles são usados por diversos serviços de interoperabilidade. Consulte as especificações de metadados para obter detalhes como esse.</param>
      <param name="culture">Uma instância de <see langword="CultureInfo" /> usada para determinar a coerção de tipos. Se isso for nulo, será usado o <see langword="CultureInfo" /> do thread atual. (Por exemplo, isso é necessário para converter uma cadeia de caracteres que representa 1000 para um valor de tipo double, uma vez que 1000 é representado de forma diferente por diferentes culturas.)</param>
      <param name="namedParameters">Cada parâmetro na matriz <paramref name="namedParameters" /> obtém o valor no elemento correspondente na matriz <paramref name="args" />. Se o comprimento de <paramref name="args" /> for maior que o de <paramref name="namedParameters" />, os valores de argumento restantes serão passados em ordem.</param>
      <returns>Retorna o valor retornado do membro invocado.</returns>
      <exception cref="T:System.NotSupportedException">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.IsByRefLike" />
    <member name="P:System.Reflection.Emit.EnumBuilder.IsConstructedGenericType">
      <summary>Obtém um valor que indica se este objeto representa um tipo genérico construído.</summary>
      <returns>
        <see langword="true" /> se este objeto representar um tipo genérico construído; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Verifica se o tipo de atributo personalizado especificado é definido.</summary>
      <param name="attributeType">O objeto <see langword="Type" /> ao qual os atributos personalizados são aplicados.</param>
      <param name="inherit">Especifica se deve-se pesquisar ou não a cadeia de herança desse membro para localizar os atributos.</param>
      <returns>
        <see langword="true" /> se uma ou mais instâncias de <paramref name="attributeType" /> estão definidas nesse membro; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">Atualmente, esse método não tem suporte em tipos que não estão completos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.IsSZArray" />
    <member name="P:System.Reflection.Emit.EnumBuilder.IsTypeDefinition" />
    <member name="P:System.Reflection.Emit.EnumBuilder.IsVariableBoundArray" />
    <member name="M:System.Reflection.Emit.EnumBuilder.MakeArrayType">
      <summary>Retorna um objeto <see cref="T:System.Type" /> que representa uma matriz unidimensional do tipo atual, com um limite inferior de zero.</summary>
      <returns>Um objeto <see cref="T:System.Type" /> que representa uma matriz unidimensional do tipo atual, com um limite inferior de zero.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.MakeArrayType(System.Int32)">
      <summary>Retorna um objeto <see cref="T:System.Type" /> que representa uma matriz do tipo atual, com o número de dimensões especificado.</summary>
      <param name="rank">O número de dimensões da matriz. Esse número deve ser menor ou igual a 32.</param>
      <returns>Um objeto que representa uma matriz do tipo atual, com o número de dimensões especificado.</returns>
      <exception cref="T:System.IndexOutOfRangeException">
        <paramref name="rank" /> é menor que 1.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.MakeByRefType">
      <summary>Retorna um objeto <see cref="T:System.Type" /> que representa o tipo atual quando passado como um parâmetro ref (parâmetro ByRef no Visual Basic).</summary>
      <returns>Um objeto <see cref="T:System.Type" /> que representa o tipo atual quando passado como um parâmetro ref (parâmetro ByRef no Visual Basic).</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.MakePointerType">
      <summary>Retorna um objeto <see cref="T:System.Type" /> que representa um ponteiro para o tipo atual.</summary>
      <returns>Um objeto <see cref="T:System.Type" /> que representa um ponteiro para o tipo atual.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Module">
      <summary>Recupera o módulo dinâmico que contém essa definição <see cref="T:System.Reflection.Emit.EnumBuilder" />.</summary>
      <returns>Somente leitura. O módulo dinâmico que contém essa definição de <see cref="T:System.Reflection.Emit.EnumBuilder" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Name">
      <summary>Retorna o nome dessa enum.</summary>
      <returns>Somente leitura. O nome desta enumeração.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Namespace">
      <summary>Retorna o namespace dessa enum.</summary>
      <returns>Somente leitura. O namespace desta enumeração.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.ReflectedType">
      <summary>Retorna o tipo que foi usado para obter esse <see cref="T:System.Reflection.Emit.EnumBuilder" />.</summary>
      <returns>Somente leitura. O tipo que foi usado para obter esse <see cref="T:System.Reflection.Emit.EnumBuilder" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Define um atributo personalizado usando um blob de atributo personalizado especificado.</summary>
      <param name="con">O construtor do atributo personalizado.</param>
      <param name="binaryAttribute">Um blob de bytes que representa os atributos.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Define um atributo personalizado usando um construtor de atributos personalizados.</summary>
      <param name="customBuilder">Uma instância de uma classe auxiliar para definir o atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> é <see langword="null" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.TypeHandle">
      <summary>Recupera o identificador interno para essa enum.</summary>
      <returns>Somente leitura. O identificador interno para esta enumeração.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para esta propriedade atualmente.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.UnderlyingField">
      <summary>Retorna o campo subjacente para essa enum.</summary>
      <returns>Somente leitura. O campo subjacente para esta enumeração.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.UnderlyingSystemType">
      <summary>Retorna o tipo de sistema subjacente para essa enum.</summary>
      <returns>Somente leitura. Retorna o tipo de sistema subjacente.</returns>
    </member>
    <member name="T:System.Reflection.Emit.EventBuilder">
      <summary>Define os eventos para uma classe.</summary>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.AddOtherMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Adiciona um dos "outros" métodos associados a esse evento. "Outros" métodos são métodos diferente dos métodos "on" e "raise" associados a um evento. Essa função pode ser chamada várias vezes para adicionar quantos "outros" métodos forem necessários.</summary>
      <param name="mdBuilder">Um objeto <see langword="MethodBuilder" /> que representa o outro método.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado no tipo de delimitador.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetAddOnMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Define o método usado para assinar este evento.</summary>
      <param name="mdBuilder">Um objeto <see langword="MethodBuilder" /> que representa o método usado para assinar este evento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado no tipo de delimitador.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Define um atributo personalizado usando um blob de atributo personalizado especificado.</summary>
      <param name="con">O construtor do atributo personalizado.</param>
      <param name="binaryAttribute">Um blob de bytes que representa os atributos.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado no tipo de delimitador.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Define um atributo personalizado usando um construtor de atributos personalizados.</summary>
      <param name="customBuilder">Uma instância de uma classe auxiliar para descrever o atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado no tipo de delimitador.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetRaiseMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Define o método usado para acionar este evento.</summary>
      <param name="mdBuilder">Um objeto <see langword="MethodBuilder" /> que representa o método usado para acionar este evento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado no tipo de delimitador.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetRemoveOnMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Define o método usado para cancelar a assinatura a este evento.</summary>
      <param name="mdBuilder">Um objeto <see langword="MethodBuilder" /> que representa o método usado para cancelar a assinatura a este evento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado no tipo de delimitador.</exception>
    </member>
    <member name="T:System.Reflection.Emit.FieldBuilder">
      <summary>Define e representa um campo. Essa classe não pode ser herdada.</summary>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.Attributes">
      <summary>Indica os atributos desse campo. Esta propriedade é somente para leitura.</summary>
      <returns>Os atributos deste campo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.DeclaringType">
      <summary>Indica uma referência para o objeto <see cref="T:System.Type" /> para o tipo que declara esse membro. Esta propriedade é somente para leitura.</summary>
      <returns>Uma referência ao objeto <see cref="T:System.Type" /> para o tipo que declara esse campo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.FieldHandle">
      <summary>Indica o identificador de metadados internos para esse campo. Esta propriedade é somente para leitura.</summary>
      <returns>O identificador de metadados interno para este campo.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para o método.</exception>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.FieldType">
      <summary>Indica o objeto <see cref="T:System.Type" /> que representa o tipo desse campo. Esta propriedade é somente para leitura.</summary>
      <returns>O objeto <see cref="T:System.Type" /> que representa o tipo desse campo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Retorna todos os atributos personalizados definidos para esse campo.</summary>
      <param name="inherit">Controla a herança de atributos personalizados de classes base.</param>
      <returns>Uma matriz de tipo <see cref="T:System.Object" /> que representa todos os atributos personalizados do construtor representados por essa instância de <see cref="T:System.Reflection.Emit.FieldBuilder" />.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para o método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Retorna todos os atributos personalizados definidos para esse campo identificado pelo tipo fornecido.</summary>
      <param name="attributeType">O tipo de atributo personalizado.</param>
      <param name="inherit">Controla a herança de atributos personalizados de classes base.</param>
      <returns>Uma matriz de tipo <see cref="T:System.Object" /> que representa todos os atributos personalizados do construtor representados por essa instância de <see cref="T:System.Reflection.Emit.FieldBuilder" />.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para o método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.GetValue(System.Object)">
      <summary>Recupera o valor do campo com suporte no objeto especificado.</summary>
      <param name="obj">O objeto no qual acessar o campo.</param>
      <returns>Um <see cref="T:System.Object" /> que contém o valor do campo refletido por essa instância.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para o método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Indica se um atributo contendo o tipo especificado é definido em um campo.</summary>
      <param name="attributeType">O tipo do atributo.</param>
      <param name="inherit">Controla a herança de atributos personalizados de classes base.</param>
      <returns>
        <see langword="true" /> se uma ou mais instâncias de <paramref name="attributeType" /> estão definidas nesse campo; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para este método atualmente. Recuperar o campo usando <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" /> e chamar <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> no <see cref="T:System.Reflection.FieldInfo" /> retornado.</exception>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.Module">
      <summary>Obtém o módulo no qual o tipo que contém esse campo está sendo definido.</summary>
      <returns>Um <see cref="T:System.Reflection.Module" /> que representa o módulo dinâmico no qual esse campo está sendo definido.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.Name">
      <summary>Indica o nome desse campo. Esta propriedade é somente para leitura.</summary>
      <returns>Um <see cref="T:System.String" /> que contém o nome deste campo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.ReflectedType">
      <summary>Indica a referência para o objeto <see cref="T:System.Type" /> do qual esse objeto foi definido. Esta propriedade é somente para leitura.</summary>
      <returns>Uma referência ao objeto <see cref="T:System.Type" /> do qual essa instância foi obtida.</returns>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetConstant(System.Object)">
      <summary>Define o novo valor padrão desse campo.</summary>
      <param name="defaultValue">O novo valor padrão desse campo.</param>
      <exception cref="T:System.InvalidOperationException">O tipo recipiente foi criado usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      <exception cref="T:System.ArgumentException">O campo não é um dos tipos com suporte.
-ou-
O tipo de <paramref name="defaultValue" /> não coincide ao tipo do campo.
-ou-
O campo é do tipo <see cref="T:System.Object" /> ou outro tipo de referência, <paramref name="defaultValue" /> não é <see langword="null" /> e o valor não pode ser atribuído ao tipo de referência.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Define um atributo personalizado usando um blob de atributo personalizado especificado.</summary>
      <param name="con">O construtor do atributo personalizado.</param>
      <param name="binaryAttribute">Um blob de bytes que representa os atributos.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O tipo pai desse campo é concluído.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Define um atributo personalizado usando um construtor de atributos personalizados.</summary>
      <param name="customBuilder">Uma instância de uma classe auxiliar para definir o atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O tipo pai desse campo é concluído.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetOffset(System.Int32)">
      <summary>Especifica o layout do campo.</summary>
      <param name="iOffset">O deslocamento do campo dentro do tipo que contém esse campo.</param>
      <exception cref="T:System.InvalidOperationException">O tipo recipiente foi criado usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="iOffset" /> é menor que zero.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
      <summary>Define o valor do campo com suporte no objeto especificado.</summary>
      <param name="obj">O objeto no qual acessar o campo.</param>
      <param name="val">O valor a ser atribuído ao campo.</param>
      <param name="invokeAttr">Um membro de <see langword="IBinder" /> que especifica o tipo de associação que é desejada (por exemplo, IBinder.CreateInstance, IBinder.ExactBinding).</param>
      <param name="binder">Um conjunto de propriedades e permissão para associação e coerção de tipos de argumento, bem como invocação de membros usando reflexão. Se binder for nulo, IBinder.DefaultBinding será usado.</param>
      <param name="culture">As preferências de software de uma determinada cultura.</param>
      <exception cref="T:System.NotSupportedException">Não há suporte para o método.</exception>
    </member>
    <member name="T:System.Reflection.Emit.GenericTypeParameterBuilder">
      <summary>Define e cria parâmetros de tipo genérico para métodos e tipos genéricos definidos dinamicamente. Essa classe não pode ser herdada.</summary>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Assembly">
      <summary>Obtém um objeto <see cref="T:System.Reflection.Assembly" /> que representa o assembly dinâmico que contém a definição de tipo genérico à qual o parâmetro de tipo atual pertence.</summary>
      <returns>Um objeto <see cref="T:System.Reflection.Assembly" /> que representa o assembly dinâmico que contém a definição de tipo genérico ao qual o parâmetro de tipo atual pertence.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.AssemblyQualifiedName">
      <summary>Obtém <see langword="null" /> em todos os casos.</summary>
      <returns>Uma referência nula (<see langword="Nothing" /> no Visual Basic) em todos os casos.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.BaseType">
      <summary>Obtém a restrição de tipo base do parâmetro de tipo genérico atual.</summary>
      <returns>Um objeto <see cref="T:System.Type" /> que representa a restrição de tipo base do parâmetro de tipo genérico ou <see langword="null" /> se o parâmetro de tipo não tiver nenhuma restrição de tipo base.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.ContainsGenericParameters">
      <summary>Obtém <see langword="true" /> em todos os casos.</summary>
      <returns>
        <see langword="true" /> em todos os casos.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.DeclaringMethod">
      <summary>Obtém um <see cref="T:System.Reflection.MethodInfo" /> que representa o método declarativo, se o <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> atual representa um parâmetro de tipo de um método genérico.</summary>
      <returns>Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método declarativo, se a <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> atual representar um parâmetro de tipo de um método genérico; caso contrário, <see langword="null" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.DeclaringType">
      <summary>Obtém a definição de tipo genérico ou definição de método genérico à qual o parâmetro de tipo genérico pertence.</summary>
      <returns>Se o parâmetro de tipo pertencer a um tipo genérico, um objeto <see cref="T:System.Type" /> representando esse tipo genérico; Se o parâmetro de tipo pertencer a um método genérico, um objeto <see cref="T:System.Type" /> representando esse tipo que declarou esse método genérico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.Equals(System.Object)">
      <summary>Testa se o objeto fornecido é uma instância de <see langword="EventToken" /> e é igual à instância atual.</summary>
      <param name="o">O objeto a ser comparado com a instância atual.</param>
      <returns>
        <see langword="true" /> se <paramref name="o" /> for uma instância de <see langword="EventToken" /> e igual à instância atual; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.FullName">
      <summary>Obtém <see langword="null" /> em todos os casos.</summary>
      <returns>Uma referência nula (<see langword="Nothing" /> no Visual Basic) em todos os casos.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.GenericParameterAttributes">
      <summary>Obtém uma combinação de <see cref="T:System.Reflection.GenericParameterAttributes" /> sinalizadores que descrevem a covariância e restrições especiais do parâmetro de tipo genérico atual.</summary>
      <returns>Uma combinação de bits de valores que descreve a covariância e as restrições especiais do parâmetro de tipo genérico atual.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.GenericParameterPosition">
      <summary>Obtém a posição do parâmetro de tipo na lista de parâmetros de tipo do método ou tipo genérico que declarou o parâmetro.</summary>
      <returns>A posição do parâmetro de tipo na lista de parâmetros de tipo do tipo ou método genérico que declarou o parâmetro.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetConstructors(System.Reflection.BindingFlags)">
      <summary>Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr">Sem suporte.</param>
      <returns>Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="inherit">Especifica se deve-se pesquisar ou não a cadeia de herança desse membro para localizar os atributos.</param>
      <returns>Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="attributeType">O tipo de atributo a ser pesquisado. Somente os atributos que podem ser atribuídos a esse tipo são retornados.</param>
      <param name="inherit">Especifica se deve-se pesquisar ou não a cadeia de herança desse membro para localizar os atributos.</param>
      <returns>Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetElementType">
      <summary>Gera um <see cref="T:System.NotSupportedException" /> em todos os casos.</summary>
      <returns>O tipo conhecido pelo tipo de matriz atual, tipo de ponteiro ou tipo <see langword="ByRef" /> ou então <see langword="null" />, se o tipo atual não é um tipo de matriz, não é um tipo de ponteiro e não é passado por referência.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
      <summary>Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="name">Sem suporte.</param>
      <param name="bindingAttr">Sem suporte.</param>
      <returns>Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetEvents">
      <summary>Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <returns>Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetEvents(System.Reflection.BindingFlags)">
      <summary>Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr">Sem suporte.</param>
      <returns>Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary>Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="name">Sem suporte.</param>
      <param name="bindingAttr">Sem suporte.</param>
      <returns>Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary>Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr">Sem suporte.</param>
      <returns>Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetGenericArguments">
      <summary>Não é válido para parâmetros de tipo genérico.</summary>
      <returns>Não é válido para parâmetros de tipo genérico.</returns>
      <exception cref="T:System.InvalidOperationException">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetGenericTypeDefinition">
      <summary>Não é válido para parâmetros de tipo genérico.</summary>
      <returns>Não é válido para parâmetros de tipo genérico.</returns>
      <exception cref="T:System.InvalidOperationException">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetHashCode">
      <summary>Retorna um código hash de inteiro de 32 bits para a instância atual.</summary>
      <returns>Um código hash de inteiro de 32 bits.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetInterface(System.String,System.Boolean)">
      <summary>Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="name">O nome da interface.</param>
      <param name="ignoreCase">
        <see langword="true" /> para pesquisar sem levar em consideração maiúsculas e minúsculas; <see langword="false" /> para fazer uma pesquisa diferenciando maiúsculas e minúsculas.</param>
      <returns>Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetInterfaceMap(System.Type)">
      <summary>Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="interfaceType">Um objeto <see cref="T:System.Type" /> que representa o tipo de interface para o qual o mapeamento deve ser recuperado.</param>
      <returns>Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetInterfaces">
      <summary>Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <returns>Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
      <summary>Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="name">Sem suporte.</param>
      <param name="type">Sem suporte.</param>
      <param name="bindingAttr">Sem suporte.</param>
      <returns>Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetMembers(System.Reflection.BindingFlags)">
      <summary>Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr">Sem suporte.</param>
      <returns>Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary>Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr">Sem suporte.</param>
      <returns>Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
      <summary>Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="name">Sem suporte.</param>
      <param name="bindingAttr">Sem suporte.</param>
      <returns>Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
      <summary>Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr">Sem suporte.</param>
      <returns>Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetProperties(System.Reflection.BindingFlags)">
      <summary>Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr">Sem suporte.</param>
      <returns>Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.GUID">
      <summary>Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <returns>Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
      <summary>Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="name">Sem suporte.</param>
      <param name="invokeAttr">Sem suporte.</param>
      <param name="binder">Sem suporte.</param>
      <param name="target">Sem suporte.</param>
      <param name="args">Sem suporte.</param>
      <param name="modifiers">Sem suporte.</param>
      <param name="culture">Sem suporte.</param>
      <param name="namedParameters">Sem suporte.</param>
      <returns>Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.IsAssignableFrom(System.Type)">
      <summary>Gera uma exceção <see cref="T:System.NotSupportedException" /> em todos os casos.</summary>
      <param name="c">O objeto a ser testado.</param>
      <returns>Gera uma exceção <see cref="T:System.NotSupportedException" /> em todos os casos.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsByRefLike" />
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsConstructedGenericType">
      <summary>Obtém um valor que indica se este objeto representa um tipo genérico construído.</summary>
      <returns>
        <see langword="true" /> se este objeto representar um tipo genérico construído; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="attributeType">Sem suporte.</param>
      <param name="inherit">Sem suporte.</param>
      <returns>Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsGenericParameter">
      <summary>Obtém <see langword="true" /> em todos os casos.</summary>
      <returns>
        <see langword="true" /> em todos os casos.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsGenericType">
      <summary>Retorna <see langword="false" /> em todos os casos.</summary>
      <returns>
        <see langword="false" /> em todos os casos.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsGenericTypeDefinition">
      <summary>Obtém <see langword="false" /> em todos os casos.</summary>
      <returns>
        <see langword="false" /> em todos os casos.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.IsSubclassOf(System.Type)">
      <summary>Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <param name="c">Sem suporte.</param>
      <returns>Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsSZArray" />
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsTypeDefinition" />
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsVariableBoundArray" />
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeArrayType">
      <summary>Retorna o tipo de uma matriz unidimensional cujo tipo de elemento é o parâmetro de tipo genérico.</summary>
      <returns>Um objeto <see cref="T:System.Type" /> que representa o tipo de uma matriz unidimensional cujo tipo de elemento é o parâmetro de tipo genérico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeArrayType(System.Int32)">
      <summary>Retorna o tipo de uma matriz cujo tipo de elemento é o parâmetro de tipo genérico, com o número de dimensões especificado.</summary>
      <param name="rank">O número de dimensões da matriz.</param>
      <returns>Um objeto <see cref="T:System.Type" /> que representa o tipo de uma matriz cujo tipo de elemento é o parâmetro de tipo genérico, com o número de dimensões especificado.</returns>
      <exception cref="T:System.IndexOutOfRangeException">
        <paramref name="rank" /> não é um número de dimensões válido. Por exemplo, seu valor é menor que 1.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeByRefType">
      <summary>Retorna um objeto <see cref="T:System.Type" /> que representa o parâmetro de tipo genérico atual quando passado como um parâmetro de referência.</summary>
      <returns>Um objeto <see cref="T:System.Type" /> que representa o parâmetro de tipo genérico atual quando passado como um parâmetro de referência.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeGenericType(System.Type[])">
      <summary>Não é válido para parâmetros de tipo genérico incompletos.</summary>
      <param name="typeArguments">Uma matriz de argumentos de tipo.</param>
      <returns>Esse método é inválido para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.InvalidOperationException">Em todos os casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakePointerType">
      <summary>Retorna um objeto <see cref="T:System.Type" /> que representa um ponteiro para o parâmetro de tipo genérico atual.</summary>
      <returns>Um objeto <see cref="T:System.Type" /> que representa um ponteiro para o parâmetro de tipo genérico atual.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Module">
      <summary>Obtém o módulo dinâmico que contém o parâmetro de tipo genérico.</summary>
      <returns>Um objeto <see cref="T:System.Reflection.Module" /> que representa o módulo dinâmico que contém o parâmetro de tipo genérico.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Name">
      <summary>Obtém o nome do parâmetro de tipo genérico.</summary>
      <returns>O nome do parâmetro de tipo genérico.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Namespace">
      <summary>Obtém <see langword="null" /> em todos os casos.</summary>
      <returns>Uma referência nula (<see langword="Nothing" /> no Visual Basic) em todos os casos.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.ReflectedType">
      <summary>Obtém o objeto <see cref="T:System.Type" /> que foi usado para obter o <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</summary>
      <returns>O objeto <see cref="T:System.Type" /> que foi usado para obter o <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetBaseTypeConstraint(System.Type)">
      <summary>Define o tipo base que um tipo deve herdar para ser substituído pelo parâmetro de tipo.</summary>
      <param name="baseTypeConstraint">O <see cref="T:System.Type" /> que deve ser herdado por qualquer tipo que deve ser substituído pelo parâmetro de tipo.</param>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Define um atributo personalizado usando um blob de atributo personalizado especificado.</summary>
      <param name="con">O construtor do atributo personalizado.</param>
      <param name="binaryAttribute">Um blob de byte que representa o atributo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> é <see langword="null" />.
- ou -
<paramref name="binaryAttribute" /> é uma referência nula.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Defina um atributo personalizado usando um construtor de atributos personalizados.</summary>
      <param name="customBuilder">Uma instância de uma classe auxiliar que define o atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes(System.Reflection.GenericParameterAttributes)">
      <summary>Define as características de variação e restrições especiais do parâmetro genérico, tais como a restrição de construtor sem parâmetros.</summary>
      <param name="genericParameterAttributes">Uma combinação bit a bit de valores <see cref="T:System.Reflection.GenericParameterAttributes" /> que representam as características de variação e restrições especiais do parâmetro de tipo genérico.</param>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetInterfaceConstraints(System.Type[])">
      <summary>Define as interfaces que um tipo deve implementar para ser substituído pelo parâmetro de tipo.</summary>
      <param name="interfaceConstraints">Uma matriz de objetos <see cref="T:System.Type" /> que representam as interfaces que um tipo deve implementar para ser substituído pelo parâmetro de tipo.</param>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.ToString">
      <summary>Retorna uma representação de cadeia de caracteres do parâmetro de tipo genérico atual.</summary>
      <returns>Uma cadeia de caracteres que contém o nome do parâmetro de tipo genérico.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.TypeHandle">
      <summary>Sem suporte para parâmetros de tipo genérico incompletos.</summary>
      <returns>Sem suporte para parâmetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.UnderlyingSystemType">
      <summary>Obtém o parâmetro de tipo genérico atual.</summary>
      <returns>O objeto <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> atual.</returns>
    </member>
    <member name="T:System.Reflection.Emit.MethodBuilder">
      <summary>Define e representa um método (ou construtor) em uma classe dinâmica.</summary>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.Attributes">
      <summary>Recupera os atributos para este método.</summary>
      <returns>Somente leitura. Recupera o <see langword="MethodAttributes" /> para este método.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.CallingConvention">
      <summary>Retorna a convenção de chamada do método.</summary>
      <returns>Somente leitura. A convenção de chamada do método.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
      <summary>Não tem suporte para esse tipo.</summary>
      <returns>Sem suporte.</returns>
      <exception cref="T:System.NotSupportedException">O método chamado não é suportado na classe base.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.DeclaringType">
      <summary>Retorna o tipo que declara a este método.</summary>
      <returns>Somente leitura. O tipo que declara esse método.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
      <summary>Define o número de parâmetros de tipo genérico para o método atual, especifica seus nomes e retorna uma matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que pode ser usada para definir suas restrições.</summary>
      <param name="names">Uma matriz de cadeias de caracteres que representa os nomes dos parâmetros de tipo genérico.</param>
      <returns>Uma matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que representam os parâmetros de tipo do método genérico.</returns>
      <exception cref="T:System.InvalidOperationException">Parâmetros de tipo genérico já foram definidos para este método.
-ou-
O método já foi concluído.
-ou-
O método <see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" /> foi chamado para o método atual.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="names" /> é <see langword="null" />.
-ou-
Um elemento de <paramref name="names" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="names" /> é uma matriz vazia.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
      <summary>Define os atributos de parâmetro e o nome de um parâmetro deste método, ou do valor retornado deste método. Retorna um ParameterBuilder que pode ser usado para aplicar os atributos personalizados.</summary>
      <param name="position">A posição do parâmetro na lista de parâmetros. Parâmetros são indexados começando com o número 1 para o primeiro parâmetro; o número 0 representa o valor retornado do método.</param>
      <param name="attributes">Os atributos de parâmetro do parâmetro.</param>
      <param name="strParamName">O nome do parâmetro. O nome pode ser a cadeia de caracteres nula.</param>
      <returns>Retorna um objeto <see langword="ParameterBuilder" /> que representa um parâmetro deste método ou o valor retornado deste método.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">O método não tem parâmetros.
-ou-
<paramref name="position" /> é menor que zero.
-ou-
<paramref name="position" /> é maior que o número de parâmetros do método.</exception>
      <exception cref="T:System.InvalidOperationException">O tipo recipiente foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.
-ou-
Para o método atual, a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)">
      <summary>Determina se o objeto especificado é igual a esta instância.</summary>
      <param name="obj">O objeto a ser comparado com essa instância <see langword="MethodBuilder" />.</param>
      <returns>
        <see langword="true" /> se <paramref name="obj" /> for uma instância de <see langword="MethodBuilder" /> e for igual a este objeto; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition">
      <summary>Retorna a implementação de base para um método.</summary>
      <returns>A implementação de base deste método.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Retorna todos os atributos personalizados definidos para esse método.</summary>
      <param name="inherit">Especifica se deve-se pesquisar na cadeia de herança deste membro para localizar os atributos personalizados.</param>
      <returns>Retorna uma matriz de objetos que representam todos os atributos personalizados desse método.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para este método atualmente. Recupere o método usando <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chame <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> no <see cref="T:System.Reflection.MethodInfo" /> retornado.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Retorna os atributos personalizados identificados pelo tipo determinado.</summary>
      <param name="attributeType">O tipo de atributo personalizado.</param>
      <param name="inherit">Especifica se deve-se pesquisar na cadeia de herança deste membro para localizar os atributos personalizados.</param>
      <returns>Retorna uma matriz de objetos que representam os atributos desse método que são do tipo <paramref name="attributeType" />.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para este método atualmente. Recupere o método usando <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chame <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> no <see cref="T:System.Reflection.MethodInfo" /> retornado.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
      <summary>Retorna uma matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que representam os parâmetros de tipo do método, se for genérico.</summary>
      <returns>Uma matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que representam os parâmetros de tipo, se o método for genérico ou <see langword="null" />, se o método não for genérico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
      <summary>Retorna este método.</summary>
      <returns>A instância atual do <see cref="T:System.Reflection.Emit.MethodBuilder" />.</returns>
      <exception cref="T:System.InvalidOperationException">O método atual não é genérico. Ou seja, a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> do método retorna <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetHashCode">
      <summary>Obtém o código hash para este método.</summary>
      <returns>O código hash para este método.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
      <summary>Retorna um <see langword="ILGenerator" /> para esse método com um tamanho de fluxo MSIL (linguagem intermediária da Microsoft) padrão de 64 bytes.</summary>
      <returns>Retorna um objeto <see langword="ILGenerator" /> para este método.</returns>
      <exception cref="T:System.InvalidOperationException">O método não deve ter um corpo devido aos seus sinalizadores <see cref="T:System.Reflection.MethodAttributes" /> ou <see cref="T:System.Reflection.MethodImplAttributes" />, por exemplo, porque ele tem o sinalizador <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" />.
-ou-
O método é genérico, mas não é uma definição de método genérico. Ou seja, a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
      <summary>Retorna um <see langword="ILGenerator" /> pra esse método com o tamanho de fluxo MSIL (linguagem intermediária da Microsoft) especificado.</summary>
      <param name="size">O tamanho do fluxo MSIL, em bytes.</param>
      <returns>Retorna um objeto <see langword="ILGenerator" /> para este método.</returns>
      <exception cref="T:System.InvalidOperationException">O método não deve ter um corpo devido aos seus sinalizadores <see cref="T:System.Reflection.MethodAttributes" /> ou <see cref="T:System.Reflection.MethodImplAttributes" />, por exemplo, porque ele tem o sinalizador <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" />.
-ou-
O método é genérico, mas não é uma definição de método genérico. Ou seja, a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags">
      <summary>Retorna os sinalizadores de implementação para o método.</summary>
      <returns>Retorna os sinalizadores de implementação para o método.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetParameters">
      <summary>Retorna os parâmetros deste método.</summary>
      <returns>Uma matriz de objetos <see langword="ParameterInfo" /> que representam os parâmetros do método.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para este método atualmente. Recupere o método usando <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chame <see langword="GetParameters" /> no <see cref="T:System.Reflection.MethodInfo" /> retornado.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.InitLocals">
      <summary>Obtém ou define um valor booliano que especifica se as variáveis locais nesse método são inicializadas em zero. O valor padrão dessa propriedade é <see langword="true" />.</summary>
      <returns>
        <see langword="true" /> se as variáveis locais nesse método devem ser inicializadas com zero; caso contrário <see langword="false" />.</returns>
      <exception cref="T:System.InvalidOperationException">Para o método atual, a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> é <see langword="false" />. (Get ou set.)</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>Invoca dinamicamente o método refletido por esta instância no objeto fornecido, passando os parâmetros especificados e sob as restrições do associador determinado.</summary>
      <param name="obj">O objeto no qual invocar o método especificado. Se o método for estático, esse parâmetro será ignorado.</param>
      <param name="invokeAttr">Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <param name="binder">Um objeto que permite a associação, a coerção de tipos de argumentos, a invocação de membros e a recuperação de objetos MemberInfo por meio de reflexão. Se o associador for <see langword="null" />, o associador padrão será usado. Para obter mais detalhes, consulte <see cref="T:System.Reflection.Binder" />.</param>
      <param name="parameters">Uma lista de argumentos. Essa é uma matriz de argumentos com o mesmo número, ordem e tipo que os parâmetros do método a ser invocado. Se não houver nenhum parâmetro, isso deverá ser <see langword="null" />.</param>
      <param name="culture">Uma instância de <see cref="T:System.Globalization.CultureInfo" /> usada para determinar a coerção de tipos. Se isso for nulo, será usado o <see cref="T:System.Globalization.CultureInfo" /> do thread atual. (Observe que isso é necessário para, por exemplo, converter um <see cref="T:System.String" /> que represente 1000 para um valor <see cref="T:System.Double" />, desde que 1000 seja representado de maneira diferente por diferentes culturas.)</param>
      <returns>Retorna um objeto que contém o valor retornado do método invocado.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para este método atualmente. Recupere o método usando <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chame <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> no <see cref="T:System.Reflection.MethodInfo" /> retornado.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsConstructedGenericMethod" />
    <member name="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Verifica se o tipo de atributo personalizado especificado é definido.</summary>
      <param name="attributeType">O tipo de atributo personalizado.</param>
      <param name="inherit">Especifica se deve-se pesquisar na cadeia de herança deste membro para localizar os atributos personalizados.</param>
      <returns>
        <see langword="true" /> se o tipo de atributo personalizado especificado estiver definido, caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para este método atualmente. Recupere o método usando <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chame <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> no <see cref="T:System.Reflection.MethodInfo" /> retornado.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
      <summary>Obtém um valor que indica se o método é um método genérico.</summary>
      <returns>
        <see langword="true" /> se o método for genérico; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
      <summary>Obtém um valor que indica se o objeto <see cref="T:System.Reflection.Emit.MethodBuilder" /> atual representa a definição de um método genérico.</summary>
      <returns>
        <see langword="true" /> se o objeto <see cref="T:System.Reflection.Emit.MethodBuilder" /> atual representa a definição de um método genérico; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
      <summary>Gera um <see cref="T:System.NotSupportedException" /> em todos os casos.</summary>
      <returns>Gera um <see cref="T:System.NotSupportedException" /> em todos os casos.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos. Não há suporte para essa propriedade em assemblies dinâmicos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
      <summary>Gera um <see cref="T:System.NotSupportedException" /> em todos os casos.</summary>
      <returns>Gera um <see cref="T:System.NotSupportedException" /> em todos os casos.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos. Não há suporte para essa propriedade em assemblies dinâmicos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
      <summary>Gera um <see cref="T:System.NotSupportedException" /> em todos os casos.</summary>
      <returns>Gera um <see cref="T:System.NotSupportedException" /> em todos os casos.</returns>
      <exception cref="T:System.NotSupportedException">Em todos os casos. Não há suporte para essa propriedade em assemblies dinâmicos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
      <summary>Retorna um método genérico construído da definição de método genérico atual usando os argumentos de tipo genérico especificados.</summary>
      <param name="typeArguments">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo para o método genérico.</param>
      <returns>Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método genérico construído com base na definição de método genérico atual usando os argumentos de tipo genérico especificados.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
      <summary>Recupera o identificador interno para o método. Use esse identificador para acessar o identificador de metadados subjacente.</summary>
      <returns>Somente leitura. O identificador interno do método. Use esse identificador para acessar o identificador de metadados subjacente.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para este método atualmente. Recupere o método usando <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chame <see cref="P:System.Reflection.MethodBase.MethodHandle" /> no <see cref="T:System.Reflection.MethodInfo" /> retornado.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.Module">
      <summary>Obtém o módulo no qual o método atual está sendo definido.</summary>
      <returns>O <see cref="T:System.Reflection.Module" /> no qual o membro representado pela <see cref="T:System.Reflection.MemberInfo" /> atual está sendo definido.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.Name">
      <summary>Recupera o nome desse método.</summary>
      <returns>Somente leitura. Recupera uma cadeia de caracteres que contém o nome simples desse método.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReflectedType">
      <summary>Recupera a classe que foi usada em reflexão para obter esse objeto.</summary>
      <returns>Somente leitura. O tipo usado para obter esse método.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReturnParameter">
      <summary>Obtém um objeto <see cref="T:System.Reflection.ParameterInfo" /> que contém informações sobre o tipo de retorno do método, como se o tipo de retorno tem modificadores personalizados.</summary>
      <returns>Um objeto <see cref="T:System.Reflection.ParameterInfo" /> que contém informações sobre o tipo de retorno.</returns>
      <exception cref="T:System.InvalidOperationException">O tipo de declaração não foi criado.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReturnType">
      <summary>Obtém o tipo de retorno do método representado por esse <see cref="T:System.Reflection.Emit.MethodBuilder" />.</summary>
      <returns>O tipo de retorno do método.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
      <summary>Retorna os atributos personalizados do tipo de retorno do método.</summary>
      <returns>Somente leitura. Os atributos personalizados do tipo de retorno do método.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Define um atributo personalizado usando um blob de atributo personalizado especificado.</summary>
      <param name="con">O construtor do atributo personalizado.</param>
      <param name="binaryAttribute">Um blob de bytes que representa os atributos.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Para o método atual, a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Define um atributo personalizado usando um construtor de atributos personalizados.</summary>
      <param name="customBuilder">Uma instância de uma classe auxiliar para descrever o atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Para o método atual, a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
      <summary>Define os sinalizadores de implementação para este método.</summary>
      <param name="attributes">Os sinalizadores de implementação a definir.</param>
      <exception cref="T:System.InvalidOperationException">O tipo recipiente foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.
-ou-
Para o método atual, a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
      <summary>Define o número e tipos de parâmetros para um método.</summary>
      <param name="parameterTypes">Uma matriz de objetos <see cref="T:System.Type" /> que representam os tipos de parâmetro.</param>
      <exception cref="T:System.InvalidOperationException">O método atual é genérico, mas não é uma definição de método genérico. Ou seja, a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
      <summary>Define o tipo retornado do método.</summary>
      <param name="returnType">Um objeto <see cref="T:System.Type" /> que representa o tipo de retorno do método.</param>
      <exception cref="T:System.InvalidOperationException">O método atual é genérico, mas não é uma definição de método genérico. Ou seja, a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>Define a assinatura do método, incluindo o tipo retornado, os tipos de parâmetro e os modificadores personalizados obrigatórios e opcionais do tipo retornado e dos tipos de parâmetro.</summary>
      <param name="returnType">O tipo de retorno do método.</param>
      <param name="returnTypeRequiredCustomModifiers">Uma matriz de tipos que representam os modificadores personalizados obrigatórios, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno do método. Se o tipo de retorno não tiver modificadores personalizados obrigatórios, especifique <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers">Uma matriz de tipos que representam os modificadores personalizados opcionais, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno do método. Se o tipo de retorno não tiver modificadores personalizados opcionais, especifique <see langword="null" />.</param>
      <param name="parameterTypes">Os tipos dos parâmetros do método.</param>
      <param name="parameterTypeRequiredCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados obrigatórios para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
      <param name="parameterTypeOptionalCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
      <exception cref="T:System.InvalidOperationException">O método atual é genérico, mas não é uma definição de método genérico. Ou seja, a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.ToString">
      <summary>Retorna esta instância <see langword="MethodBuilder" /> como uma cadeia de caracteres.</summary>
      <returns>Retorna uma cadeia de caracteres que contém o nome, os atributos, a assinatura do método, as exceções e a assinatura local desse método seguidos pelo fluxo MSIL (linguagem intermediária da Microsoft) atual.</returns>
    </member>
    <member name="T:System.Reflection.Emit.ModuleBuilder">
      <summary>Define e representa um módulo em um assembly dinâmico.</summary>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.Assembly">
      <summary>Obtém o assembly dinâmico que definiu esta instância do <see cref="T:System.Reflection.Emit.ModuleBuilder" />.</summary>
      <returns>O assembly dinâmico que definiu o módulo dinâmico atual.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
      <summary>Conclui a definições de função global e dados globais para esse módulo dinâmico.</summary>
      <exception cref="T:System.InvalidOperationException">Esse método foi chamado anteriormente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
      <summary>Define um tipo de enumeração que é um tipo de valor com um único campo não estático chamado <paramref name="value__" /> do tipo especificado.</summary>
      <param name="name">O caminho completo do tipo de enumeração. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="visibility">Os atributos de tipo para a enumeração. Os atributos são quaisquer bits definidos pelo <see cref="F:System.Reflection.TypeAttributes.VisibilityMask" />.</param>
      <param name="underlyingType">O tipo subjacente para a enumeração. Isso deve ser um tipo inteiro interno.</param>
      <returns>A enumeração definida.</returns>
      <exception cref="T:System.ArgumentException">Atributos que não sejam os atributos de visibilidade são fornecidos.
-ou-
Uma enumeração com o nome especificado existe no assembly pai deste módulo.
-ou-
Os atributos de visibilidade não coincidem com o escopo da enumeração. Por exemplo, <see cref="F:System.Reflection.TypeAttributes.NestedPublic" /> é especificado para <paramref name="visibility" />, mas a enumeração não é um tipo aninhado.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary>Define um método global com o nome, os atributos, a convenção de chamada, o tipo de retorno e os tipos de parâmetro especificados.</summary>
      <param name="name">O nome do método. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attributes">Os atributos do método. <paramref name="attributes" /> deve incluir <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
      <param name="callingConvention">A convenção de chamada para o método.</param>
      <param name="returnType">O tipo de retorno do método.</param>
      <param name="parameterTypes">Os tipos de parâmetros do método.</param>
      <returns>O método global definido.</returns>
      <exception cref="T:System.ArgumentException">O método não é estático. Ou seja, <paramref name="attributes" /> não inclui <see cref="F:System.Reflection.MethodAttributes.Static" />.
-ou-
Um elemento na matriz <see cref="T:System.Type" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> foi chamado anteriormente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>Define um método global com os valores especificado de nome, atributos, convenção de chamada, tipo de retorno, modificadores personalizados para o tipo de retorno, tipos de parâmetro e modificadores personalizados para os tipos de parâmetro.</summary>
      <param name="name">O nome do método. <paramref name="name" /> não pode conter caracteres nulos inseridos.</param>
      <param name="attributes">Os atributos do método. <paramref name="attributes" /> deve incluir <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
      <param name="callingConvention">A convenção de chamada para o método.</param>
      <param name="returnType">O tipo de retorno do método.</param>
      <param name="requiredReturnTypeCustomModifiers">Uma matriz de tipos que representa os modificadores personalizados obrigatórios para o tipo de retorno, como <see cref="T:System.Runtime.CompilerServices.IsConst" /> ou <see cref="T:System.Runtime.CompilerServices.IsBoxed" />. Se o tipo de retorno não tiver modificadores personalizados obrigatórios, especifique <see langword="null" />.</param>
      <param name="optionalReturnTypeCustomModifiers">Uma matriz de tipos que representa os modificadores personalizados opcionais para o tipo de retorno, como <see cref="T:System.Runtime.CompilerServices.IsConst" /> ou <see cref="T:System.Runtime.CompilerServices.IsBoxed" />. Se o tipo de retorno não tiver modificadores personalizados opcionais, especifique <see langword="null" />.</param>
      <param name="parameterTypes">Os tipos de parâmetros do método.</param>
      <param name="requiredParameterTypeCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados necessários para o parâmetro correspondente do método global. Se um argumento específico não tiver nenhum modificador personalizado obrigatório, especifique <see langword="null" />, em vez de uma matriz de tipos. Se o método global não tiver nenhum argumento ou se nenhum argumento tiver modificadores personalizados obrigatórios, especifique <see langword="null" />, em vez de uma matriz de matrizes.</param>
      <param name="optionalParameterTypeCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente. Se um argumento específico não tiver nenhum modificador personalizado opcional, especifique <see langword="null" />, em vez de uma matriz de tipos. Se o método global não tiver nenhum argumento ou se nenhum argumento tiver modificadores personalizados opcionais, especifique <see langword="null" />, em vez de uma matriz de matrizes.</param>
      <returns>O método global definido.</returns>
      <exception cref="T:System.ArgumentException">O método não é estático. Ou seja, <paramref name="attributes" /> não inclui <see cref="F:System.Reflection.MethodAttributes.Static" />.
-ou-
Um elemento na matriz <see cref="T:System.Type" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O método <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> foi chamado anteriormente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
      <summary>Define um método global com o nome, os atributos, o tipo de retorno e os tipos de parâmetro especificados.</summary>
      <param name="name">O nome do método. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attributes">Os atributos do método. <paramref name="attributes" /> deve incluir <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
      <param name="returnType">O tipo de retorno do método.</param>
      <param name="parameterTypes">Os tipos de parâmetros do método.</param>
      <returns>O método global definido.</returns>
      <exception cref="T:System.ArgumentException">O método não é estático. Ou seja, <paramref name="attributes" /> não inclui <see cref="F:System.Reflection.MethodAttributes.Static" />.
-ou-
O comprimento de <paramref name="name" /> é zero
-ou-
Um elemento na matriz <see cref="T:System.Type" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> foi chamado anteriormente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
      <summary>Define o campo de dados inicializado na seção .sdata do arquivo PE (executável portátil).</summary>
      <param name="name">O nome usado para fazer referência aos dados. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="data">O BLOB (objeto binário grande) de dados.</param>
      <param name="attributes">Os atributos do campo. O padrão é <see langword="Static" />.</param>
      <returns>Um campo para fazer referência aos dados.</returns>
      <exception cref="T:System.ArgumentException">O comprimento de <paramref name="name" /> é zero.
-ou-
O tamanho de <paramref name="data" /> é menor ou igual a zero, ou maior ou igual a 0x3f0000.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ou <paramref name="data" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> foi chamado anteriormente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary>Define um método <see langword="PInvoke" /> com o nome especificado, o nome da DLL em que o método é definido, os atributos do método, a convenção de chamada do método, o tipo de retorno do método, os tipos dos parâmetros do método e os sinalizadores <see langword="PInvoke" />.</summary>
      <param name="name">O nome do método <see langword="PInvoke" />. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="dllName">O nome da DLL na qual o método <see langword="PInvoke" /> é definido.</param>
      <param name="attributes">Os atributos do método.</param>
      <param name="callingConvention">A convenção de chamada do método.</param>
      <param name="returnType">O tipo de retorno do método.</param>
      <param name="parameterTypes">Os tipos de parâmetros do método.</param>
      <param name="nativeCallConv">A convenção de chamada nativa.</param>
      <param name="nativeCharSet">O conjunto de caracteres nativos do método.</param>
      <returns>O método <see langword="PInvoke" /> definido.</returns>
      <exception cref="T:System.ArgumentException">O método não é estático ou o tipo de conteúdo é uma interface.
-ou-
O método é abstrato.
-ou-
O método foi definido anteriormente.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ou <paramref name="dllName" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O tipo recipiente foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /></exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary>Define um método <see langword="PInvoke" /> com o nome especificado, o nome da DLL em que o método é definido, os atributos do método, a convenção de chamada do método, o tipo de retorno do método, os tipos dos parâmetros do método e os sinalizadores <see langword="PInvoke" />.</summary>
      <param name="name">O nome do método <see langword="PInvoke" />. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="dllName">O nome da DLL na qual o método <see langword="PInvoke" /> é definido.</param>
      <param name="entryName">O nome do ponto de entrada na DLL.</param>
      <param name="attributes">Os atributos do método.</param>
      <param name="callingConvention">A convenção de chamada do método.</param>
      <param name="returnType">O tipo de retorno do método.</param>
      <param name="parameterTypes">Os tipos de parâmetros do método.</param>
      <param name="nativeCallConv">A convenção de chamada nativa.</param>
      <param name="nativeCharSet">O conjunto de caracteres nativos do método.</param>
      <returns>O método <see langword="PInvoke" /> definido.</returns>
      <exception cref="T:System.ArgumentException">O método não é estático ou se o tipo de conteúdo é uma interface ou se o método é abstract se o método foi definido anteriormente.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ou <paramref name="dllName" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O tipo recipiente foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /></exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
      <summary>Constrói um <see langword="TypeBuilder" /> para um tipo particular com o nome especificado neste módulo.</summary>
      <param name="name">O caminho completo do tipo, incluindo o namespace. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <returns>Um tipo particular com o nome especificado.</returns>
      <exception cref="T:System.ArgumentException">Existe um tipo com o nome especificado no assembly pai deste módulo.
-ou-
Atributos de tipo aninhado são definidos em um tipo que não está aninhado.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
      <summary>Constrói um <see langword="TypeBuilder" /> considerando o nome do tipo e os atributos de tipo.</summary>
      <param name="name">O caminho completo do tipo. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attr">Os atributos do tipo definido.</param>
      <returns>Um <see langword="TypeBuilder" /> criado com todos os atributos solicitados.</returns>
      <exception cref="T:System.ArgumentException">Existe um tipo com o nome especificado no assembly pai deste módulo.
-ou-
Atributos de tipo aninhado são definidos em um tipo que não está aninhado.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
      <summary>Constrói um <see langword="TypeBuilder" /> dado o nome do tipo, seus atributos e o tipo que o tipo definido estende.</summary>
      <param name="name">O caminho completo do tipo. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attr">O atributo a ser associado ao tipo.</param>
      <param name="parent">O tipo que o tipo definido estende.</param>
      <returns>Um <see langword="TypeBuilder" /> criado com todos os atributos solicitados.</returns>
      <exception cref="T:System.ArgumentException">Existe um tipo com o nome especificado no assembly pai deste módulo.
-ou-
Atributos de tipo aninhado são definidos em um tipo que não está aninhado.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
      <summary>Constrói um <see langword="TypeBuilder" /> dado o nome do tipo, os atributos, o tipo que o tipo definido estende e o tamanho total do tipo.</summary>
      <param name="name">O caminho completo do tipo. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attr">Os atributos do tipo definido.</param>
      <param name="parent">O tipo que o tipo definido estende.</param>
      <param name="typesize">O tamanho total do tipo.</param>
      <returns>Um objeto <see langword="TypeBuilder" />.</returns>
      <exception cref="T:System.ArgumentException">Existe um tipo com o nome especificado no assembly pai deste módulo.
-ou-
Atributos de tipo aninhado são definidos em um tipo que não está aninhado.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
      <summary>Constrói um <see langword="TypeBuilder" /> dado o nome do tipo, os atributos, o tipo que o tipo definido estende e o tamanho de empacotamento do tipo.</summary>
      <param name="name">O caminho completo do tipo. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attr">Os atributos do tipo definido.</param>
      <param name="parent">O tipo que o tipo definido estende.</param>
      <param name="packsize">O tamanho de empacotamento do tipo.</param>
      <returns>Um objeto <see langword="TypeBuilder" />.</returns>
      <exception cref="T:System.ArgumentException">Existe um tipo com o nome especificado no assembly pai deste módulo.
-ou-
Atributos de tipo aninhado são definidos em um tipo que não está aninhado.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
      <summary>Constrói um <see langword="TypeBuilder" /> dado o nome do tipo, os atributos, o tipo que o tipo definido estende, o tamanho de empacotamento do tipo definido e o tamanho total do tipo definido.</summary>
      <param name="name">O caminho completo do tipo. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attr">Os atributos do tipo definido.</param>
      <param name="parent">O tipo que o tipo definido estende.</param>
      <param name="packingSize">O tamanho de empacotamento do tipo.</param>
      <param name="typesize">O tamanho total do tipo.</param>
      <returns>Um <see langword="TypeBuilder" /> criado com todos os atributos solicitados.</returns>
      <exception cref="T:System.ArgumentException">Existe um tipo com o nome especificado no assembly pai deste módulo.
-ou-
Atributos de tipo aninhado são definidos em um tipo que não está aninhado.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
      <summary>Constrói um <see langword="TypeBuilder" /> dado o nome do tipo, os atributos, o tipo que o tipo definido estende e as interfaces que o tipo definido implementa.</summary>
      <param name="name">O caminho completo do tipo. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attr">Os atributos a serem associado ao tipo.</param>
      <param name="parent">O tipo que o tipo definido estende.</param>
      <param name="interfaces">A lista de interfaces que o tipo implementa.</param>
      <returns>Um <see langword="TypeBuilder" /> criado com todos os atributos solicitados.</returns>
      <exception cref="T:System.ArgumentException">Existe um tipo com o nome especificado no assembly pai deste módulo.
-ou-
Atributos de tipo aninhado são definidos em um tipo que não está aninhado.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
      <summary>Define o campo de dados não inicializado na seção .sdata do arquivo PE (executável portátil).</summary>
      <param name="name">O nome usado para fazer referência aos dados. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="size">O tamanho do campo de dados.</param>
      <param name="attributes">Os atributos do campo.</param>
      <returns>Um campo para fazer referência aos dados.</returns>
      <exception cref="T:System.ArgumentException">O comprimento de <paramref name="name" /> é zero.
-ou-
<paramref name="size" /> é menor que ou igual a zero, ou maior que ou igual a 0x003f0000.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> foi chamado anteriormente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.Equals(System.Object)">
      <summary>Retorna um valor que indica se essa instância é igual ao objeto especificado.</summary>
      <param name="obj">Um objeto a ser comparado com essa instância ou <see langword="null" />.</param>
      <returns>
        <see langword="true" /> se <paramref name="obj" /> for igual ao tipo e ao valor dessa instância, caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName">
      <summary>Obtém uma <see langword="String" /> que representa o nome totalmente qualificado e o caminho para esse módulo.</summary>
      <returns>O nome do módulo totalmente qualificado.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary>Retorna o método nomeado em uma classe de matriz.</summary>
      <param name="arrayClass">Uma classe de matriz.</param>
      <param name="methodName">O nome de um método na classe de matriz.</param>
      <param name="callingConvention">A convenção de chamada do método.</param>
      <param name="returnType">O tipo de retorno do método.</param>
      <param name="parameterTypes">Os tipos de parâmetros do método.</param>
      <returns>O método nomeado em uma classe de matriz.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="arrayClass" /> não é uma matriz.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="arrayClass" /> ou <paramref name="methodName" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Retorna todos os atributos personalizados que foram aplicados ao <see cref="T:System.Reflection.Emit.ModuleBuilder" /> atual.</summary>
      <param name="inherit">Este argumento é ignorado para objetos deste tipo.</param>
      <returns>Uma matriz que contém os atributos personalizados; a matriz será vazia se não houver nenhum atributo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Retorna todos os atributos personalizados que foram aplicados ao <see cref="T:System.Reflection.Emit.ModuleBuilder" /> atual e que derivam de um tipo de atributo especificado.</summary>
      <param name="attributeType">O tipo base do qual derivam os atributos.</param>
      <param name="inherit">Este argumento é ignorado para objetos deste tipo.</param>
      <returns>Uma matriz que contém os atributos personalizados que são derivados em qualquer nível de <paramref name="attributeType" />; a matriz será vazia se não houver nenhum desses atributos.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributeType" /> não é um objeto <see cref="T:System.Type" /> fornecido pelo tempo de execução. Por exemplo, <paramref name="attributeType" /> é um objeto <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData">
      <summary>Retorna informações sobre os atributos que foram aplicados ao <see cref="T:System.Reflection.Emit.ModuleBuilder" /> atual, expressos como objetos <see cref="T:System.Reflection.CustomAttributeData" />.</summary>
      <returns>Uma lista genérica de objetos <see cref="T:System.Reflection.CustomAttributeData" /> que representam dados sobre os atributos que foram aplicados ao módulo atual.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary>Retorna um campo no nível de módulo, definido na região de .sdata o arquivo PE (executável portátil), que tem o nome e os atributos de associação especificados.</summary>
      <param name="name">O nome do campo.</param>
      <param name="bindingAttr">Uma combinação dos sinalizadores de bit <see langword="BindingFlags" /> usados para controlar a pesquisa.</param>
      <returns>Um campo que tem o nome e os atributos de associação especificados ou <see langword="null" />, se o campo não existir.</returns>
      <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary>Retorna todos os campos definidos na região .sdata do arquivo PE (executável portátil) que correspondem aos sinalizadores de associação especificados.</summary>
      <param name="bindingFlags">Uma combinação dos sinalizadores de bit <see langword="BindingFlags" /> usados para controlar a pesquisa.</param>
      <returns>Uma matriz de campos que coincidem com os sinalizadores especificados; a matriz estará vazia se não existirem esses campos.</returns>
      <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetHashCode">
      <summary>Retorna o código hash para essa instância.</summary>
      <returns>Um código de hash do inteiro assinado de 32 bits.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary>Retorna todos os métodos que foram definidos no nível de módulo para o <see cref="T:System.Reflection.Emit.ModuleBuilder" /> atual e que corresponde aos sinalizadores de associação especificados.</summary>
      <param name="bindingFlags">Uma combinação de sinalizadores de bit <see langword="BindingFlags" /> usados para controlar a pesquisa.</param>
      <returns>Uma matriz que contém todos os métodos de nível de módulo que correspondem a <paramref name="bindingFlags" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
      <summary>Obtém um par de valores que indica a natureza do código em um módulo e a plataforma de destino do módulo.</summary>
      <param name="peKind">Quando este método retorna, uma combinação dos valores <see cref="T:System.Reflection.PortableExecutableKinds" /> indicando a natureza do código no módulo.</param>
      <param name="machine">Quando este método retorna, um dos valores <see cref="T:System.Reflection.ImageFileMachine" /> indicando a plataforma de destino no módulo.</param>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
      <summary>Obtém o tipo nomeado definido no módulo.</summary>
      <param name="className">O nome do <see cref="T:System.Type" /> a obter.</param>
      <returns>O tipo solicitado, se o tipo estiver definido neste módulo; caso contrário, <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentException">O comprimento de <paramref name="className" /> é igual a zero ou maior que 1023.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="className" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">O <see cref="T:System.Type" /> solicitado é não público e o chamador não tem <see cref="T:System.Security.Permissions.ReflectionPermission" /> para refletir objetos não públicos fora do assembly atual.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador de classe é invocado e lança uma exceção.</exception>
      <exception cref="T:System.TypeLoadException">Um erro é encontrado ao carregar o <see cref="T:System.Type" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
      <summary>Obtém o tipo nomeado definido no módulo, opcionalmente ignorando maiúsculas e minúsculas do nome do tipo.</summary>
      <param name="className">O nome do <see cref="T:System.Type" /> a obter.</param>
      <param name="ignoreCase">Se <see langword="true" />, a pesquisa não diferenciará maiúsculas de minúsculas. Se <see langword="false" />, a pesquisa diferenciará maiúsculas de minúsculas.</param>
      <returns>O tipo solicitado, se o tipo estiver definido neste módulo; caso contrário, <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentException">O comprimento de <paramref name="className" /> é igual a zero ou maior que 1023.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="className" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">O <see cref="T:System.Type" /> solicitado é não público e o chamador não tem <see cref="T:System.Security.Permissions.ReflectionPermission" /> para refletir objetos não públicos fora do assembly atual.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador de classe é invocado e lança uma exceção.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
      <summary>Obtém o tipo nomeado definido no módulo, opcionalmente ignorando maiúsculas e minúsculas do nome do tipo. Opcionalmente, gerará uma exceção se o tipo não for encontrado.</summary>
      <param name="className">O nome do <see cref="T:System.Type" /> a obter.</param>
      <param name="throwOnError">
        <see langword="true" /> para gerar uma exceção se não for possível encontrar o tipo; <see langword="false" /> para retornar <see langword="null" />.</param>
      <param name="ignoreCase">Se <see langword="true" />, a pesquisa não diferenciará maiúsculas de minúsculas. Se <see langword="false" />, a pesquisa diferenciará maiúsculas de minúsculas.</param>
      <returns>O tipo especificado, se o tipo for declarado neste módulo; caso contrário, <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentException">O comprimento de <paramref name="className" /> é igual a zero ou maior que 1023.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="className" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">O <see cref="T:System.Type" /> solicitado é não público e o chamador não tem <see cref="T:System.Security.Permissions.ReflectionPermission" /> para refletir objetos não públicos fora do assembly atual.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador de classe é invocado e lança uma exceção.</exception>
      <exception cref="T:System.TypeLoadException">
        <paramref name="throwOnError" /> é <see langword="true" /> e o tipo especificado não foi encontrado.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
      <summary>Retorna todas as classes definidas neste módulo.</summary>
      <returns>Uma matriz que contém os tipos definidos dentro do módulo que é refletido por esta instância.</returns>
      <exception cref="T:System.Reflection.ReflectionTypeLoadException">Uma ou mais classes em um módulo não puderam ser carregadas.</exception>
      <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Retorna um valor que indica se o tipo de atributo especificado foi aplicado a este módulo.</summary>
      <param name="attributeType">O tipo de atributo personalizado para o qual testar.</param>
      <param name="inherit">Este argumento é ignorado para objetos deste tipo.</param>
      <returns>
        <see langword="true" /> se uma ou mais instâncias de <paramref name="attributeType" /> tiver sido aplicada a este módulo; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributeType" /> não é um objeto <see cref="T:System.Type" /> fornecido pelo tempo de execução. Por exemplo, <paramref name="attributeType" /> é um objeto <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.IsResource">
      <summary>Obtém um valor que indica se o objeto é um recurso.</summary>
      <returns>
        <see langword="true" /> se o objeto for um recurso; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion">
      <summary>Obtém a versão de fluxo de metadados.</summary>
      <returns>Um inteiro de 32 bits que representa a versão do fluxo de metadados. Os dois bytes de ordem superior representam o número de versão principal e os dois bytes de ordem inferior representam o número de versão secundária.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.MetadataToken">
      <summary>Obtém um token que identifica o módulo dinâmico atual nos metadados.</summary>
      <returns>Um token de número inteiro que identifica o módulo atual nos metadados.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId">
      <summary>Obtém um UUID (identificador universal exclusivo) que pode ser usado para distinguir entre duas versões de um módulo.</summary>
      <returns>Um <see cref="T:System.Guid" /> que pode ser usado para distinguir entre duas versões de um módulo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.Name">
      <summary>Uma cadeia de caracteres que indica que este é um módulo na memória.</summary>
      <returns>Texto que indica que este é um módulo na memória.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
      <summary>Retorna o campo identificado pelo token de metadados especificado, no contexto definido pelos parâmetros de tipo genérico especificados.</summary>
      <param name="metadataToken">Um token de metadados que identifica um campo no módulo.</param>
      <param name="genericTypeArguments">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo genérico do tipo em que o token está no escopo ou <see langword="null" /> se esse tipo não for genérico.</param>
      <param name="genericMethodArguments">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo genérico do método em que o token está no escopo ou <see langword="null" /> se esse método não for genérico.</param>
      <returns>Um objeto <see cref="T:System.Reflection.FieldInfo" /> que representa o campo que é identificado pelo token de metadados especificado.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> não é um token para um campo no escopo do módulo atual.
-ou-
<paramref name="metadataToken" /> identifica um campo cujo <see langword="TypeSpec" /> pai tem uma assinatura que contém o tipo de elemento <see langword="var" /> (um parâmetro de tipo de um tipo genérico) ou <see langword="mvar" /> (um parâmetro de tipo de um método genérico) e os argumentos de tipo genérico necessários não foram fornecidos para <paramref name="genericTypeArguments" /> ou <paramref name="genericMethodArguments" /> ou ambos.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> não é um token válido no escopo do módulo atual.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
      <summary>Retorna o tipo ou o membro identificado pelo token de metadados especificado, no contexto definido pelos parâmetros de tipo genérico especificados.</summary>
      <param name="metadataToken">Um token de metadados que identifica um tipo ou membro no módulo.</param>
      <param name="genericTypeArguments">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo genérico do tipo em que o token está no escopo ou <see langword="null" /> se esse tipo não for genérico.</param>
      <param name="genericMethodArguments">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo genérico do método em que o token está no escopo ou <see langword="null" /> se esse método não for genérico.</param>
      <returns>Um objeto <see cref="T:System.Reflection.MemberInfo" /> que representa o tipo ou o membro que é identificado pelo token de metadados especificado.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> não é um token para um tipo ou membro no escopo do módulo atual.
-ou-
<paramref name="metadataToken" /> é um <see langword="MethodSpec" /> ou <see langword="TypeSpec" /> cuja assinatura contém o tipo de elemento <see langword="var" /> (um parâmetro de tipo de um tipo genérico) ou <see langword="mvar" /> (um parâmetro de tipo de um método genérico) e os argumentos de tipo genérico necessários não foram fornecidos para <paramref name="genericTypeArguments" /> ou <paramref name="genericMethodArguments" /> ou ambos.
-ou-
<paramref name="metadataToken" /> identifica uma propriedade ou evento.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> não é um token válido no escopo do módulo atual.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
      <summary>Retorna o método ou o construtor identificado pelo token de metadados especificado, no contexto definido pelos parâmetros de tipo genérico especificados.</summary>
      <param name="metadataToken">Um token de metadados que identifica um método ou um construtor no módulo.</param>
      <param name="genericTypeArguments">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo genérico do tipo em que o token está no escopo ou <see langword="null" /> se esse tipo não for genérico.</param>
      <param name="genericMethodArguments">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo genérico do método em que o token está no escopo ou <see langword="null" /> se esse método não for genérico.</param>
      <returns>Um objeto <see cref="T:System.Reflection.MethodBase" /> que representa o método que é identificado pelo token de metadados especificado.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> não é um token de um método ou construtor no escopo do módulo atual.
-ou-
<paramref name="metadataToken" /> é um <see langword="MethodSpec" /> cuja assinatura contém o tipo de elemento <see langword="var" /> (um parâmetro de tipo de um tipo genérico) ou <see langword="mvar" /> (um parâmetro de tipo de um método genérico) e os argumentos de tipo genérico necessários não foram fornecidos para <paramref name="genericTypeArguments" /> ou <paramref name="genericMethodArguments" />, ou para ambos.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> não é um token válido no escopo do módulo atual.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
      <summary>Retorna o blob de assinatura identificado por um token de metadados.</summary>
      <param name="metadataToken">Um token de metadados que identifica uma assinatura no módulo.</param>
      <returns>Uma matriz de bytes que representa o blob de assinatura.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> não é um <see langword="MemberRef" />, <see langword="MethodDef" />, <see langword="TypeSpec" />, assinatura ou token <see langword="FieldDef" /> válido no escopo do módulo atual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> não é um token válido no escopo do módulo atual.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
      <summary>Retorna a cadeia de caracteres identificada pelo token de metadados especificado.</summary>
      <param name="metadataToken">Um token de metadados que identifica uma cadeia de caracteres no heap de cadeia de caracteres do módulo.</param>
      <returns>Um <see cref="T:System.String" /> que contém um valor de cadeia de caracteres do heap de cadeia de caracteres de metadados.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> não é um token para uma cadeia de caracteres no escopo do módulo atual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> não é um token válido no escopo do módulo atual.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
      <summary>Retorna o tipo identificado pelo token de metadados especificado no contexto definido pelos parâmetros de tipo genérico especificados.</summary>
      <param name="metadataToken">Um token de metadados que identifica um tipo no módulo.</param>
      <param name="genericTypeArguments">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo genérico do tipo em que o token está no escopo ou <see langword="null" /> se esse tipo não for genérico.</param>
      <param name="genericMethodArguments">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo genérico do método em que o token está no escopo ou <see langword="null" /> se esse método não for genérico.</param>
      <returns>Um objeto <see cref="T:System.Type" /> que representa o tipo que é identificado pelo token de metadados especificado.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> não é um token para um tipo no escopo do módulo atual.
-ou-
<paramref name="metadataToken" /> é um <see langword="TypeSpec" /> cuja assinatura contém o tipo de elemento <see langword="var" /> (um parâmetro de tipo de um tipo genérico) ou <see langword="mvar" /> (um parâmetro de tipo de um método genérico) e os argumentos de tipo genérico necessários não foram fornecidos para <paramref name="genericTypeArguments" /> ou <paramref name="genericMethodArguments" />, ou para ambos.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> não é um token válido no escopo do módulo atual.</exception>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.ScopeName">
      <summary>Obtém uma cadeia de caracteres que representa o nome do módulo dinâmico.</summary>
      <returns>O nome do módulo dinâmico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Aplica um atributo personalizado a esse módulo usando um BLOB (objeto binário grande) especificado que representa o atributo.</summary>
      <param name="con">O construtor do atributo personalizado.</param>
      <param name="binaryAttribute">Um BLOB de Byte que representa o atributo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Aplica um atributo personalizado a esse módulo usando um construtor de atributo personalizado.</summary>
      <param name="customBuilder">Uma instância de uma classe auxiliar que especifica o atributo personalizado a aplicar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> é <see langword="null" />.</exception>
    </member>
    <member name="T:System.Reflection.Emit.PropertyBuilder">
      <summary>Define as propriedades de um tipo.</summary>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.AddOtherMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Adiciona um dos outros métodos associados a essa propriedade.</summary>
      <param name="mdBuilder">Um objeto <see langword="MethodBuilder" /> que representa o outro método.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado no tipo de delimitador.</exception>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.Attributes">
      <summary>Obtém os atributos desta propriedade.</summary>
      <returns>Atributos desta propriedade.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.CanRead">
      <summary>Obtém um valor que indica se a propriedade pode ser lida.</summary>
      <returns>
        <see langword="true" /> se essa propriedade puder ser lida; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.CanWrite">
      <summary>Obtém um valor que indica se a propriedade pode ser usada para gravação.</summary>
      <returns>
        <see langword="true" /> se essa propriedade puder ser usada para gravação; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.DeclaringType">
      <summary>Obtém a classe que declara esse membro.</summary>
      <returns>O objeto <see langword="Type" /> para a classe que declara esse membro.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetAccessors(System.Boolean)">
      <summary>Retorna uma matriz de acessadores <see langword="get" /> e <see langword="set" /> públicos e não públicos nesta propriedade.</summary>
      <param name="nonPublic">Indica se os métodos não públicos devem ser retornados na matriz <see langword="MethodInfo" />. <see langword="true" /> se os métodos não públicos devem ser incluídos; caso contrário, <see langword="false" />.</param>
      <returns>Uma matriz do tipo <see langword="MethodInfo" /> que contém os acessadores públicos ou não públicos correspondentes ou uma matriz vazia, se não houver acessadores correspondentes nesta propriedade.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para o método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Retorna uma matriz de todos os atributos personalizados para essa propriedade.</summary>
      <param name="inherit">Se <see langword="true" />, percorrerá a cadeia de herança dessa propriedade para localizar os atributos personalizados</param>
      <returns>Uma matriz de todos os atributos personalizados.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para o método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Retorna uma matriz de atributos personalizados identificados por <see cref="T:System.Type" />.</summary>
      <param name="attributeType">Uma matriz de atributos personalizados identificados por tipo.</param>
      <param name="inherit">Se <see langword="true" />, percorrerá a cadeia de herança dessa propriedade para localizar os atributos personalizados.</param>
      <returns>Uma matriz de atributos personalizados definidos neste membro refletido ou <see langword="null" />, se nenhum atributo estiver definido neste membro.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para o método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetGetMethod(System.Boolean)">
      <summary>Retorna o acessador get público e não público para essa propriedade.</summary>
      <param name="nonPublic">Indica se os acessadores get não públicos devem ser retornados. <see langword="true" /> se os métodos não públicos devem ser incluídos; caso contrário, <see langword="false" />.</param>
      <returns>Um objeto <see langword="MethodInfo" /> que representa o acessador get para essa propriedade, se <paramref name="nonPublic" /> for <see langword="true" />. Retorna <see langword="null" /> se <paramref name="nonPublic" /> for <see langword="false" /> e o acessador get não for público ou, se <paramref name="nonPublic" /> for <see langword="true" />, mas nenhum acessador get existir.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetIndexParameters">
      <summary>Retorna uma matriz de todos os parâmetros de índice para a propriedade.</summary>
      <returns>Uma matriz do tipo <see langword="ParameterInfo" /> que contém os parâmetros dos índices.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para o método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetSetMethod(System.Boolean)">
      <summary>Retorna o acessador set para essa propriedade.</summary>
      <param name="nonPublic">Indica se o acessador deverá ser retornado se ele não for público. <see langword="true" /> se os métodos não públicos devem ser incluídos; caso contrário, <see langword="false" />.</param>
      <returns>O método <see langword="Set" /> da propriedade ou <see langword="null" />, conforme mostrado na tabela a seguir.
  Valor 
  Condição 
  Um objeto <see cref="T:System.Reflection.MethodInfo" /> que representa o método Set para essa propriedade.  
  
  O acessador set é público.  
  
 <paramref name="nonPublic" /> é verdadeiro e métodos não públicos podem ser retornados.  
  
  nulo 
 <paramref name="nonPublic" /> é true, mas a propriedade é somente leitura.  
  
 <paramref name="nonPublic" /> é false e o conjunto de acessador é não público.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetValue(System.Object,System.Object[])">
      <summary>Obtém o valor da propriedade indexada chamando o método getter da propriedade.</summary>
      <param name="obj">O objeto cujo valor da propriedade será retornado.</param>
      <param name="index">Valores de índice opcionais para propriedades indexadas. Esse valor deve ser <see langword="null" /> para propriedades não indexadas.</param>
      <returns>O valor da propriedade indexada especificada.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para o método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetValue(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>Obtém o valor de uma propriedade com a associação, o índice e o <see langword="CultureInfo" /> especificados.</summary>
      <param name="obj">O objeto cujo valor da propriedade será retornado.</param>
      <param name="invokeAttr">O atributo de invocação. Isso deve ser um sinalizador de bit de <see langword="BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="Static" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />. É necessário especificar um atributo de invocação adequado. Caso um membro estático deva ser chamado, o sinalizador <see langword="Static" /> de <see langword="BindingFlags" /> deverá ser definido.</param>
      <param name="binder">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see langword="MemberInfo" /> usando reflexão. Caso <paramref name="binder" /> seja <see langword="null" />, o associador padrão é usado.</param>
      <param name="index">Valores de índice opcionais para propriedades indexadas. Esse valor deve ser <see langword="null" /> para propriedades não indexadas.</param>
      <param name="culture">O objeto <see langword="CultureInfo" /> que representa a cultura para qual o recurso deve ser localizado. Observe que se o recurso não estiver localizado para essa cultura, o método <see langword="CultureInfo.Parent" /> será chamado sucessivamente pesquisando uma correspondência. Se esse valor for <see langword="null" />, o <see langword="CultureInfo" /> será obtido da propriedade <see langword="CultureInfo.CurrentUICulture" />.</param>
      <returns>O valor da propriedade <paramref name="obj" />.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para o método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Indica se uma ou mais instância de <paramref name="attributeType" /> está definida nessa propriedade.</summary>
      <param name="attributeType">O objeto <see langword="Type" /> ao qual os atributos personalizados são aplicados.</param>
      <param name="inherit">Especifica se deve percorrer cadeia de herança dessa propriedade para localizar os atributos personalizados.</param>
      <returns>
        <see langword="true" /> se um ou mais instância de <paramref name="attributeType" /> estiver definida nessa propriedade; caso contrário <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para o método.</exception>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.Module">
      <summary>Obtém o módulo no qual o tipo que declara a propriedade atual está sendo definido.</summary>
      <returns>O <see cref="T:System.Reflection.Module" /> no qual o tipo que declara a propriedade Current é definido.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.Name">
      <summary>Obtém o nome desse membro.</summary>
      <returns>Um <see cref="T:System.String" /> que contém o nome do computador.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.PropertyType">
      <summary>Obtém o tipo do campo dessa propriedade.</summary>
      <returns>O tipo dessa propriedade.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.ReflectedType">
      <summary>Obtém o objeto de classe que foi usado para obter esta instância de <see langword="MemberInfo" />.</summary>
      <returns>O objeto <see langword="Type" /> por meio do qual este objeto <see langword="MemberInfo" /> foi obtido.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetConstant(System.Object)">
      <summary>Define o valor padrão dessa propriedade.</summary>
      <param name="defaultValue">O valor padrão dessa propriedade.</param>
      <exception cref="T:System.InvalidOperationException">O <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado no tipo de delimitador.</exception>
      <exception cref="T:System.ArgumentException">A propriedade não é de um dos tipos com suporte.
-ou-
O tipo de <paramref name="defaultValue" /> não corresponde ao tipo da propriedade.
-ou-
A propriedade é do tipo <see cref="T:System.Object" /> ou outro tipo de referência, <paramref name="defaultValue" /> não é <see langword="null" /> e o valor não pode ser atribuído ao tipo de referência.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Define um atributo personalizado usando um blob de atributo personalizado especificado.</summary>
      <param name="con">O construtor do atributo personalizado.</param>
      <param name="binaryAttribute">Um blob de bytes que representa os atributos.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado no tipo de delimitador.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Defina um atributo personalizado usando um construtor de atributos personalizados.</summary>
      <param name="customBuilder">Uma instância de uma classe auxiliar para definir o atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Se <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado no tipo de delimitador.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetGetMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Define o método que obtém o valor da propriedade.</summary>
      <param name="mdBuilder">Um objeto <see langword="MethodBuilder" /> que representa o método que obtém o valor da propriedade.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado no tipo de delimitador.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetSetMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Define o método que define o valor da propriedade.</summary>
      <param name="mdBuilder">Um objeto <see langword="MethodBuilder" /> que representa o método que define o valor da propriedade.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado no tipo de delimitador.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetValue(System.Object,System.Object,System.Object[])">
      <summary>Define o valor da propriedade com valores de índice opcionais para propriedades do índice.</summary>
      <param name="obj">O objeto cujo valor da propriedade será definido.</param>
      <param name="value">O novo valor dessa propriedade.</param>
      <param name="index">Valores de índice opcionais para propriedades indexadas. Esse valor deve ser <see langword="null" /> para propriedades não indexadas.</param>
      <exception cref="T:System.NotSupportedException">Não há suporte para o método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>Define o valor da propriedade para o objeto fornecido para o valor fornecido.</summary>
      <param name="obj">O objeto cujo valor da propriedade será retornado.</param>
      <param name="value">O novo valor dessa propriedade.</param>
      <param name="invokeAttr">O atributo de invocação. Isso deve ser um sinalizador de bit de <see langword="BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="Static" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />. É necessário especificar um atributo de invocação adequado. Caso um membro estático deva ser chamado, o sinalizador <see langword="Static" /> de <see langword="BindingFlags" /> deverá ser definido.</param>
      <param name="binder">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see langword="MemberInfo" /> usando reflexão. Caso <paramref name="binder" /> seja <see langword="null" />, o associador padrão é usado.</param>
      <param name="index">Valores de índice opcionais para propriedades indexadas. Esse valor deve ser <see langword="null" /> para propriedades não indexadas.</param>
      <param name="culture">O objeto <see langword="CultureInfo" /> que representa a cultura para qual o recurso deve ser localizado. Observe que se o recurso não estiver localizado para essa cultura, o método <see langword="CultureInfo.Parent" /> será chamado sucessivamente pesquisando uma correspondência. Se esse valor for <see langword="null" />, o <see langword="CultureInfo" /> será obtido da propriedade <see langword="CultureInfo.CurrentUICulture" />.</param>
      <exception cref="T:System.NotSupportedException">Não há suporte para o método.</exception>
    </member>
    <member name="T:System.Reflection.Emit.TypeBuilder">
      <summary>Define e cria novas instâncias de classes no tempo de execução.</summary>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
      <summary>Adiciona uma interface implementada por esse tipo.</summary>
      <param name="interfaceType">A interface implementada por esse tipo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="interfaceType" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Assembly">
      <summary>Recupera o assembly dinâmico que contém essa definição de tipo.</summary>
      <returns>Somente leitura. Recupera o assembly dinâmico que contém essa definição de tipo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
      <summary>Retorna o nome completo desse tipo qualificado pelo nome de exibição do assembly.</summary>
      <returns>Somente leitura. O nome completo desse tipo qualificado pelo nome de exibição do assembly.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.BaseType">
      <summary>Recupera o tipo base deste tipo.</summary>
      <returns>Somente leitura. Recupera o tipo base deste tipo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.CreateType">
      <summary>Cria um objeto <see cref="T:System.Type" /> para a classe. Depois de definir campos e métodos na classe, <see langword="CreateType" /> é chamado para carregar seu objeto <see langword="Type" />.</summary>
      <returns>Retorna o novo objeto <see cref="T:System.Type" /> dessa classe.</returns>
      <exception cref="T:System.InvalidOperationException">O tipo delimitador não foi criado.
- ou -
Esse tipo é não abstrato e contém um método abstrato.
- ou -
Esse tipo não é uma classe abstrata nem uma interface e tem um método sem um corpo do método.</exception>
      <exception cref="T:System.ArgumentException">Conteúdo de rótulo inválido em <see cref="T:System.Reflection.Emit.ILGenerator" />: você definiu um rótulo sem chamar <see cref="M:System.Reflection.Emit.ILGenerator.MarkLabel(System.Reflection.Emit.Label)" />.</exception>
      <exception cref="T:System.NotSupportedException">O tipo contém código MSIL (Microsoft Intermediate Language) inválido.
- ou -
O destino da ramificação é especificado usando um deslocamento de 1 byte, mas está em uma distância maior que 127 bytes da ramificação.</exception>
      <exception cref="T:System.TypeLoadException">O tipo não pode ser carregado. Por exemplo, contém um método <see langword="static" /> com a convenção de chamada <see cref="F:System.Reflection.CallingConventions.HasThis" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo">
      <summary>Obtém um objeto <see cref="T:System.Reflection.TypeInfo" /> que representa esse tipo.</summary>
      <returns>Um objeto que representa esse tipo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod">
      <summary>Obtém o método que declarou o parâmetro de tipo genérico atual.</summary>
      <returns>Um <see cref="T:System.Reflection.MethodBase" /> que representa o método que declarou o tipo atual, se o tipo atual for um parâmetro de tipo genérico; caso contrário, <see langword="null" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.DeclaringType">
      <summary>Retorna o tipo que declarou esse tipo.</summary>
      <returns>Somente leitura. O tipo que declarou este tipo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
      <summary>Adiciona um novo construtor ao tipo, com a assinatura e os atributos determinados.</summary>
      <param name="attributes">Os atributos do construtor.</param>
      <param name="callingConvention">A convenção de chamada do construtor.</param>
      <param name="parameterTypes">Os tipos de parâmetro do construtor.</param>
      <returns>O construtor definido.</returns>
      <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
      <summary>Adiciona um novo construtor ao tipo, com os atributos, a assinatura e os modificadores personalizados determinados.</summary>
      <param name="attributes">Os atributos do construtor.</param>
      <param name="callingConvention">A convenção de chamada do construtor.</param>
      <param name="parameterTypes">Os tipos de parâmetro do construtor.</param>
      <param name="requiredCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados obrigatórios para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
      <param name="optionalCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
      <returns>O construtor definido.</returns>
      <exception cref="T:System.ArgumentException">O tamanho de <paramref name="requiredCustomModifiers" /> ou <paramref name="optionalCustomModifiers" /> não é igual ao tamanho de <paramref name="parameterTypes" />.</exception>
      <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.
- ou -
Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
      <summary>Define o construtor sem parâmetros. O construtor definido aqui simplesmente chamará o construtor sem parâmetros do pai.</summary>
      <param name="attributes">Um objeto <see langword="MethodAttributes" /> que representa os atributos a serem aplicados ao construtor.</param>
      <returns>Retorna o construtor.</returns>
      <exception cref="T:System.NotSupportedException">O tipo pai (tipo base) não tem um construtor sem parâmetros.</exception>
      <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.
- ou -
Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
      <summary>Adiciona um novo evento ao tipo, com o nome, os atributos e o tipo de evento determinados.</summary>
      <param name="name">O nome do evento. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attributes">Os atributos do evento.</param>
      <param name="eventtype">O tipo do evento.</param>
      <returns>O evento definido.</returns>
      <exception cref="T:System.ArgumentException">O comprimento de <paramref name="name" /> é zero.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.
- ou -
<paramref name="eventtype" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
      <summary>Adiciona um novo campo ao tipo, com o nome, os atributos e o tipo de campo determinados.</summary>
      <param name="fieldName">O nome do campo. <paramref name="fieldName" /> não pode conter nulos inseridos.</param>
      <param name="type">O tipo do campo</param>
      <param name="attributes">Os atributos do campo.</param>
      <returns>O campo definido.</returns>
      <exception cref="T:System.ArgumentException">O comprimento de <paramref name="fieldName" /> é zero.
- ou -
<paramref name="type" /> é System.Void.
- ou -
Um tamanho total foi especificado para a classe pai desse campo.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="fieldName" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
      <summary>Adiciona um novo campo ao tipo, com o nome, os atributos, o tipo de campo e os modificadores personalizados determinados.</summary>
      <param name="fieldName">O nome do campo. <paramref name="fieldName" /> não pode conter nulos inseridos.</param>
      <param name="type">O tipo do campo</param>
      <param name="requiredCustomModifiers">Uma matriz de tipos que representa os modificadores personalizados obrigatórios para o campo, como <see cref="T:Microsoft.VisualC.IsConstModifier" />.</param>
      <param name="optionalCustomModifiers">Uma matriz de tipos que representa os modificadores personalizados opcionais para o campo, como <see cref="T:Microsoft.VisualC.IsConstModifier" />.</param>
      <param name="attributes">Os atributos do campo.</param>
      <returns>O campo definido.</returns>
      <exception cref="T:System.ArgumentException">O comprimento de <paramref name="fieldName" /> é zero.
- ou -
<paramref name="type" /> é System.Void.
- ou -
Um tamanho total foi especificado para a classe pai desse campo.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="fieldName" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
      <summary>Define os parâmetros de tipo genérico do tipo atual, especificando seus números e nomes, e retorna uma matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que podem ser usados para definir suas restrições.</summary>
      <param name="names">Uma matriz de nomes para os parâmetros de tipo genérico.</param>
      <returns>Uma matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que podem ser usados para definir as restrições dos parâmetros de tipo genérico do tipo atual.</returns>
      <exception cref="T:System.InvalidOperationException">Os parâmetros de tipo genérico já foram definidos para esse tipo.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="names" /> é <see langword="null" />.
- ou -
Um elemento de <paramref name="names" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="names" /> é uma matriz vazia.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
      <summary>Define o campo de dados inicializado na seção .sdata do arquivo PE (executável portátil).</summary>
      <param name="name">O nome usado para fazer referência aos dados. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="data">O blob de dados.</param>
      <param name="attributes">Os atributos do campo.</param>
      <returns>Um campo para fazer referência aos dados.</returns>
      <exception cref="T:System.ArgumentException">O tamanho de <paramref name="name" /> é zero.
- ou -
O tamanho dos dados é menor que ou igual a zero, ou maior que ou igual a 0x3f0000.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ou <paramref name="data" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado anteriormente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
      <summary>Adiciona um novo método ao tipo, com o nome e os atributos de método especificados.</summary>
      <param name="name">O nome do método. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attributes">Os atributos do método.</param>
      <returns>Um <see cref="T:System.Reflection.Emit.MethodBuilder" /> representando o método recém-definido.</returns>
      <exception cref="T:System.ArgumentException">O comprimento de <paramref name="name" /> é zero.
- ou -
O tipo de pai desse método é uma interface e esse método não é virtual (<see langword="Overridable" /> no Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.
- ou -
Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
      <summary>Adiciona um novo método ao tipo, com o nome, os atributos de método e a convenção de chamada especificados.</summary>
      <param name="name">O nome do método. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attributes">Os atributos do método.</param>
      <param name="callingConvention">A convenção de chamada do método.</param>
      <returns>Um <see cref="T:System.Reflection.Emit.MethodBuilder" /> representando o método recém-definido.</returns>
      <exception cref="T:System.ArgumentException">O comprimento de <paramref name="name" /> é zero.
- ou -
O tipo de pai desse método é uma interface e esse método não é virtual (<see langword="Overridable" /> no Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.
- ou -
Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary>Adiciona um novo método ao tipo, com o nome, atributos de método, convenção de chamada e assinatura de método especificados.</summary>
      <param name="name">O nome do método. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attributes">Os atributos do método.</param>
      <param name="callingConvention">A convenção de chamada do método.</param>
      <param name="returnType">O tipo de retorno do método.</param>
      <param name="parameterTypes">Os tipos dos parâmetros do método.</param>
      <returns>Um <see cref="T:System.Reflection.Emit.MethodBuilder" /> representando o método recém-definido.</returns>
      <exception cref="T:System.ArgumentException">O comprimento de <paramref name="name" /> é zero.
- ou -
O tipo de pai desse método é uma interface e esse método não é virtual (<see langword="Overridable" /> no Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.
- ou -
Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>Adiciona um novo método ao tipo, com o nome, os atributos de método, a convenção de chamada, a assinatura de método e os modificadores personalizados especificados.</summary>
      <param name="name">O nome do método. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attributes">Os atributos do método.</param>
      <param name="callingConvention">A convenção de chamada do método.</param>
      <param name="returnType">O tipo de retorno do método.</param>
      <param name="returnTypeRequiredCustomModifiers">Uma matriz de tipos que representam os modificadores personalizados obrigatórios, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno do método. Se o tipo de retorno não tiver modificadores personalizados obrigatórios, especifique <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers">Uma matriz de tipos que representam os modificadores personalizados opcionais, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno do método. Se o tipo de retorno não tiver modificadores personalizados opcionais, especifique <see langword="null" />.</param>
      <param name="parameterTypes">Os tipos dos parâmetros do método.</param>
      <param name="parameterTypeRequiredCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados obrigatórios para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
      <param name="parameterTypeOptionalCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
      <returns>Um objeto <see cref="T:System.Reflection.Emit.MethodBuilder" /> que representa o método recém-adicionado.</returns>
      <exception cref="T:System.ArgumentException">O comprimento de <paramref name="name" /> é zero.
- ou -
O tipo de pai desse método é uma interface e esse método não é virtual (<see langword="Overridable" /> no Visual Basic).
- ou -
O tamanho de <paramref name="parameterTypeRequiredCustomModifiers" /> ou <paramref name="parameterTypeOptionalCustomModifiers" /> não é igual ao tamanho de <paramref name="parameterTypes" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.
- ou -
Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
      <summary>Adiciona um novo método ao tipo, com o nome, os atributos de método e a assinatura de método especificados.</summary>
      <param name="name">O nome do método. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attributes">Os atributos do método.</param>
      <param name="returnType">O tipo de retorno do método.</param>
      <param name="parameterTypes">Os tipos dos parâmetros do método.</param>
      <returns>O método definido.</returns>
      <exception cref="T:System.ArgumentException">O comprimento de <paramref name="name" /> é zero.
- ou -
O tipo de pai desse método é uma interface e esse método não é virtual (<see langword="Overridable" /> no Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.
- ou -
Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
      <summary>Especifica um corpo de um determinado método que implementa uma declaração do mesmo, possivelmente com um nome diferente.</summary>
      <param name="methodInfoBody">O corpo do método a ser usado. Isso deve ser um objeto <see langword="MethodBuilder" />.</param>
      <param name="methodInfoDeclaration">O método cuja declaração deve ser usada.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="methodInfoBody" /> não pertence a esta classe.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="methodInfoBody" /> ou <paramref name="methodInfoDeclaration" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.
- ou -
O tipo de declaração de <paramref name="methodInfoBody" /> não é do tipo representado por este <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
      <summary>Define um tipo aninhado, após ser informado seu nome.</summary>
      <param name="name">O nome curto do tipo. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <returns>O tipo aninhado definido.</returns>
      <exception cref="T:System.ArgumentException">O comprimento de <paramref name="name" /> é zero ou maior que 1023.
- ou -
Essa operação criaria um tipo com um <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado no assembly atual.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
      <summary>Define um tipo aninhado, após serem informados seu nome e atributos.</summary>
      <param name="name">O nome curto do tipo. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attr">Os atributos do tipo.</param>
      <returns>O tipo aninhado definido.</returns>
      <exception cref="T:System.ArgumentException">O atributo aninhado não é especificado.
- ou -
Esse tipo está lacrado.
- ou -
Esse tipo é uma matriz.
- ou -
Esse tipo é uma interface, mas o tipo aninhado não é uma interface.
- ou -
O comprimento de <paramref name="name" /> é zero ou maior que 1023.
- ou -
Essa operação criaria um tipo com um <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado no assembly atual.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
      <summary>Define um tipo aninhado, após serem informados seu nome, atributos e o tipo que ele estende.</summary>
      <param name="name">O nome curto do tipo. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attr">Os atributos do tipo.</param>
      <param name="parent">O tipo que o tipo aninhado estende.</param>
      <returns>O tipo aninhado definido.</returns>
      <exception cref="T:System.ArgumentException">O atributo aninhado não é especificado.
- ou -
Esse tipo está lacrado.
- ou -
Esse tipo é uma matriz.
- ou -
Esse tipo é uma interface, mas o tipo aninhado não é uma interface.
- ou -
O comprimento de <paramref name="name" /> é zero ou maior que 1023.
- ou -
Essa operação criaria um tipo com um <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado no assembly atual.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
      <summary>Define um tipo aninhado, após serem informados seu nome, atributos, tamanho total do tipo e o tipo que ele estende.</summary>
      <param name="name">O nome curto do tipo. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attr">Os atributos do tipo.</param>
      <param name="parent">O tipo que o tipo aninhado estende.</param>
      <param name="typeSize">O tamanho total do tipo.</param>
      <returns>O tipo aninhado definido.</returns>
      <exception cref="T:System.ArgumentException">O atributo aninhado não é especificado.
- ou -
Esse tipo está lacrado.
- ou -
Esse tipo é uma matriz.
- ou -
Esse tipo é uma interface, mas o tipo aninhado não é uma interface.
- ou -
O comprimento de <paramref name="name" /> é zero ou maior que 1023.
- ou -
Essa operação criaria um tipo com um <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado no assembly atual.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
      <summary>Define um tipo aninhado, após serem informados seu nome, atributos, tipo que ele estende e tamanho de empacotamento.</summary>
      <param name="name">O nome curto do tipo. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attr">Os atributos do tipo.</param>
      <param name="parent">O tipo que o tipo aninhado estende.</param>
      <param name="packSize">O tamanho de empacotamento do tipo.</param>
      <returns>O tipo aninhado definido.</returns>
      <exception cref="T:System.ArgumentException">O atributo aninhado não é especificado.
- ou -
Esse tipo está lacrado.
- ou -
Esse tipo é uma matriz.
- ou -
Esse tipo é uma interface, mas o tipo aninhado não é uma interface.
- ou -
O comprimento de <paramref name="name" /> é zero ou maior que 1023.
- ou -
Essa operação criaria um tipo com um <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado no assembly atual.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
      <summary>Define um tipo aninhado, após serem informados seu nome, atributos, tamanho e o tipo que ele estende.</summary>
      <param name="name">O nome curto do tipo. <paramref name="name" /> não pode conter valores nulos inseridos.</param>
      <param name="attr">Os atributos do tipo.</param>
      <param name="parent">O tipo que o tipo aninhado estende.</param>
      <param name="packSize">O tamanho de empacotamento do tipo.</param>
      <param name="typeSize">O tamanho total do tipo.</param>
      <returns>O tipo aninhado definido.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
      <summary>Define um tipo aninhado, após serem informados seu nome, atributos, tipo que ele estende e as interfaces implementadas por ele.</summary>
      <param name="name">O nome curto do tipo. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attr">Os atributos do tipo.</param>
      <param name="parent">O tipo que o tipo aninhado estende.</param>
      <param name="interfaces">As interface implementadas pelo tipo aninhado.</param>
      <returns>O tipo aninhado definido.</returns>
      <exception cref="T:System.ArgumentException">O atributo aninhado não é especificado.
- ou -
Esse tipo está lacrado.
- ou -
Esse tipo é uma matriz.
- ou -
Esse tipo é uma interface, mas o tipo aninhado não é uma interface.
- ou -
O comprimento de <paramref name="name" /> é zero ou maior que 1023.
- ou -
Essa operação criaria um tipo com um <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado no assembly atual.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.
- ou -
Um elemento da matriz <paramref name="interfaces" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary>Define um método <see langword="PInvoke" /> após serem informados seu nome, o nome da DLL em que o método é definido, os atributos do método, a convenção de chamada do método, o tipo de retorno do método, os tipos dos parâmetros do método e os sinalizadores <see langword="PInvoke" />.</summary>
      <param name="name">O nome do método <see langword="PInvoke" />. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="dllName">O nome da DLL na qual o método <see langword="PInvoke" /> é definido.</param>
      <param name="attributes">Os atributos do método.</param>
      <param name="callingConvention">A convenção de chamada do método.</param>
      <param name="returnType">O tipo de retorno do método.</param>
      <param name="parameterTypes">Os tipos de parâmetros do método.</param>
      <param name="nativeCallConv">A convenção de chamada nativa.</param>
      <param name="nativeCharSet">O conjunto de caracteres nativos do método.</param>
      <returns>O método <see langword="PInvoke" /> definido.</returns>
      <exception cref="T:System.ArgumentException">O método não é estático.
- ou -
O tipo pai é uma interface.
- ou -
O método é abstrato.
- ou -
O método foi definido anteriormente.
- ou -
O comprimento de <paramref name="name" /> ou <paramref name="dllName" /> é zero.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ou <paramref name="dllName" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O tipo recipiente foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary>Define um método <see langword="PInvoke" /> após serem informados seu nome, o nome da DLL no qual o método é definido, o nome do ponto de entrada, os atributos do método, a convenção de chamada do método, o tipo de retorno do método, os tipos dos parâmetros do método, os sinalizadores <see langword="PInvoke" />.</summary>
      <param name="name">O nome do método <see langword="PInvoke" />. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="dllName">O nome da DLL na qual o método <see langword="PInvoke" /> é definido.</param>
      <param name="entryName">O nome do ponto de entrada na DLL.</param>
      <param name="attributes">Os atributos do método.</param>
      <param name="callingConvention">A convenção de chamada do método.</param>
      <param name="returnType">O tipo de retorno do método.</param>
      <param name="parameterTypes">Os tipos de parâmetros do método.</param>
      <param name="nativeCallConv">A convenção de chamada nativa.</param>
      <param name="nativeCharSet">O conjunto de caracteres nativos do método.</param>
      <returns>O método <see langword="PInvoke" /> definido.</returns>
      <exception cref="T:System.ArgumentException">O método não é estático.
- ou -
O tipo pai é uma interface.
- ou -
O método é abstrato.
- ou -
O método foi definido anteriormente.
- ou -
O comprimento de <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> é zero.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O tipo recipiente foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][])">
      <summary>Define um método <see langword="PInvoke" /> após serem informados seu nome, o nome da DLL no qual o método é definido, o nome do ponto de entrada, os atributos do método, a convenção de chamada do método, o tipo de retorno do método, os tipos dos parâmetros do método, os sinalizadores <see langword="PInvoke" /> e os modificadores personalizados para os parâmetros e o tipo de retorno.</summary>
      <param name="name">O nome do método <see langword="PInvoke" />. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="dllName">O nome da DLL na qual o método <see langword="PInvoke" /> é definido.</param>
      <param name="parameterTypeOptionalCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
      <param name="nativeCallConv">A convenção de chamada nativa.</param>
      <param name="nativeCharSet">O conjunto de caracteres nativos do método.</param>
      <param name="entryName">O nome do ponto de entrada na DLL.</param>
      <param name="attributes">Os atributos do método.</param>
      <param name="callingConvention">A convenção de chamada do método.</param>
      <param name="returnType">O tipo de retorno do método.</param>
      <param name="returnTypeRequiredCustomModifiers">Uma matriz de tipos que representam os modificadores personalizados obrigatórios, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno do método. Se o tipo de retorno não tiver modificadores personalizados obrigatórios, especifique <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers">Uma matriz de tipos que representam os modificadores personalizados opcionais, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno do método. Se o tipo de retorno não tiver modificadores personalizados opcionais, especifique <see langword="null" />.</param>
      <param name="parameterTypes">Os tipos de parâmetros do método.</param>
      <param name="parameterTypeRequiredCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados obrigatórios para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
      <returns>Um <see cref="T:System.Reflection.Emit.MethodBuilder" /> representando o método <see langword="PInvoke" /> definido.</returns>
      <exception cref="T:System.ArgumentException">O método não é estático.
- ou -
O tipo pai é uma interface.
- ou -
O método é abstrato.
- ou -
O método foi definido anteriormente.
- ou -
O comprimento de <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> é zero.
- ou -
O tamanho de <paramref name="parameterTypeRequiredCustomModifiers" /> ou <paramref name="parameterTypeOptionalCustomModifiers" /> não é igual ao tamanho de <paramref name="parameterTypes" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.
- ou -
Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary>Adiciona uma nova propriedade ao tipo, com o nome, os atributos, a convenção de chamada e assinatura de propriedade fornecidos.</summary>
      <param name="name">O nome da propriedade. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attributes">Os atributos da propriedade.</param>
      <param name="callingConvention">A convenção de chamada dos acessadores de propriedade.</param>
      <param name="returnType">O tipo de retorno da propriedade.</param>
      <param name="parameterTypes">Os tipos dos parâmetros da propriedade.</param>
      <returns>A propriedade definida.</returns>
      <exception cref="T:System.ArgumentException">O comprimento de <paramref name="name" /> é zero.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.
- ou -
Qualquer um dos elementos da matriz de <paramref name="parameterTypes" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>Adiciona uma nova propriedade ao tipo, com o nome, a convenção de chamada, a assinatura de propriedade e os modificadores personalizados fornecidos.</summary>
      <param name="name">O nome da propriedade. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attributes">Os atributos da propriedade.</param>
      <param name="callingConvention">A convenção de chamada dos acessadores de propriedade.</param>
      <param name="returnType">O tipo de retorno da propriedade.</param>
      <param name="returnTypeRequiredCustomModifiers">Uma matriz de tipos que representa os modificadores personalizados obrigatórios, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno da propriedade. Se o tipo de retorno não tiver modificadores personalizados obrigatórios, especifique <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers">Uma matriz de tipos que representa os modificadores personalizados opcionais, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno da propriedade. Se o tipo de retorno não tiver modificadores personalizados opcionais, especifique <see langword="null" />.</param>
      <param name="parameterTypes">Os tipos dos parâmetros da propriedade.</param>
      <param name="parameterTypeRequiredCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados obrigatórios para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
      <param name="parameterTypeOptionalCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
      <returns>A propriedade definida.</returns>
      <exception cref="T:System.ArgumentException">O comprimento de <paramref name="name" /> é zero.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.
- ou -
Qualquer um dos elementos da matriz de <paramref name="parameterTypes" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
      <summary>Adiciona uma nova propriedade ao tipo, com o nome e assinatura de propriedade fornecidos.</summary>
      <param name="name">O nome da propriedade. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attributes">Os atributos da propriedade.</param>
      <param name="returnType">O tipo de retorno da propriedade.</param>
      <param name="parameterTypes">Os tipos dos parâmetros da propriedade.</param>
      <returns>A propriedade definida.</returns>
      <exception cref="T:System.ArgumentException">O comprimento de <paramref name="name" /> é zero.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.
- ou -
Qualquer um dos elementos da matriz de <paramref name="parameterTypes" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>Adiciona uma nova propriedade ao tipo, com o nome, a assinatura de propriedade e os modificadores personalizado fornecidos.</summary>
      <param name="name">O nome da propriedade. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="attributes">Os atributos da propriedade.</param>
      <param name="returnType">O tipo de retorno da propriedade.</param>
      <param name="returnTypeRequiredCustomModifiers">Uma matriz de tipos que representa os modificadores personalizados obrigatórios, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno da propriedade. Se o tipo de retorno não tiver modificadores personalizados obrigatórios, especifique <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers">Uma matriz de tipos que representa os modificadores personalizados opcionais, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno da propriedade. Se o tipo de retorno não tiver modificadores personalizados opcionais, especifique <see langword="null" />.</param>
      <param name="parameterTypes">Os tipos dos parâmetros da propriedade.</param>
      <param name="parameterTypeRequiredCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados obrigatórios para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
      <param name="parameterTypeOptionalCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
      <returns>A propriedade definida.</returns>
      <exception cref="T:System.ArgumentException">O comprimento de <paramref name="name" /> é zero.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />
- ou -
Qualquer um dos elementos da matriz de <paramref name="parameterTypes" /> é <see langword="null" /></exception>
      <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
      <summary>Define o inicializador desse tipo.</summary>
      <returns>Retorna um inicializador de tipo.</returns>
      <exception cref="T:System.InvalidOperationException">O tipo recipiente foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
      <summary>Define um campo de dados não inicializado na seção <see langword=".sdata" /> do arquivo PE (executável portátil).</summary>
      <param name="name">O nome usado para fazer referência aos dados. <paramref name="name" /> não pode conter nulos inseridos.</param>
      <param name="size">O tamanho do campo de dados.</param>
      <param name="attributes">Os atributos do campo.</param>
      <returns>Um campo para fazer referência aos dados.</returns>
      <exception cref="T:System.ArgumentException">O tamanho de <paramref name="name" /> é zero.
- ou -
<paramref name="size" /> é menor que ou igual a zero, ou maior que ou igual a 0x003f0000.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.FullName">
      <summary>Recupera o caminho completo desse tipo.</summary>
      <returns>Somente leitura. Recupera o caminho completo desse tipo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes">
      <summary>Obtém um valor que indica a covariância e as restrições especiais do parâmetro de tipo genérico atual.</summary>
      <returns>Uma combinação bit a bit de valores <see cref="T:System.Reflection.GenericParameterAttributes" /> que descrevem a covariância e restrições especiais do parâmetro de tipo genérico atual.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
      <summary>Obtém a posição de um parâmetro de tipo na lista de parâmetros de tipo do tipo genérico declarado no parâmetro.</summary>
      <returns>Se o objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> atual representar um parâmetro de tipo genérico, a posição do parâmetro de tipo na lista de parâmetros de tipo do tipo genérico que declarou o parâmetro; caso contrário, indefinido.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
      <summary>Retorna o construtor do tipo genérico construído especificado que corresponde ao construtor especificado da definição de tipo genérico.</summary>
      <param name="type">O tipo genérico construído cujo construtor será retornado.</param>
      <param name="constructor">Um construtor na definição de tipo genérico de <paramref name="type" />, que especifica qual construtor de <paramref name="type" /> será retornado.</param>
      <returns>Um objeto <see cref="T:System.Reflection.ConstructorInfo" /> que representa o construtor de <paramref name="type" /> correspondente a <paramref name="constructor" />, que especifica um construtor pertencente à definição de tipo genérico de <paramref name="type" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> não representa um tipo genérico.
- ou -
<paramref name="type" /> não é do tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.
- ou -
O tipo declarativo de <paramref name="constructor" /> não é uma definição de tipo genérico.
- ou -
O tipo declarativo de <paramref name="constructor" /> não é a definição de tipo genérico de <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
      <summary>Retorna uma matriz de objetos <see cref="T:System.Reflection.ConstructorInfo" /> que representam os construtores público e não público definidos para essa classe, conforme especificado.</summary>
      <param name="bindingAttr">Esse deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como em <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns>Retorna uma matriz de objetos <see cref="T:System.Reflection.ConstructorInfo" /> que representam os construtores especificados definidos para esta classe. Se nenhum construtor for definido, uma matriz vazia será retornada.</returns>
      <exception cref="T:System.NotSupportedException">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Retorna todos os atributos personalizados definidos para esse tipo.</summary>
      <param name="inherit">Especifica se deve-se pesquisar ou não a cadeia de herança desse membro para localizar os atributos.</param>
      <returns>Retorna uma matriz de objetos que representa todos os atributos personalizados desse tipo.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para tipos incompletos nesse método atualmente. Recupere o tipo usando <see cref="M:System.Type.GetType" /> e chame <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> no <see cref="T:System.Type" /> retornado.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Retorna todos os atributos personalizados do tipo atual que podem ser atribuídos a um tipo especificado.</summary>
      <param name="attributeType">O tipo de atributo a ser pesquisado. Somente os atributos que podem ser atribuídos a esse tipo são retornados.</param>
      <param name="inherit">Especifica se deve-se pesquisar ou não a cadeia de herança desse membro para localizar os atributos.</param>
      <returns>Uma matriz de atributos personalizados definida no tipo atual.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para tipos incompletos nesse método atualmente. Recupere o tipo usando <see cref="M:System.Type.GetType" /> e chame <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> no <see cref="T:System.Type" /> retornado.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">O tipo deve ser um tipo fornecido pelo sistema de runtime subjacente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetElementType">
      <summary>A chamada desse método sempre lança <see cref="T:System.NotSupportedException" />.</summary>
      <returns>Não há suporte para o método. Nenhum valor é retornado.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para o método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
      <summary>Retorna o evento com o nome especificado.</summary>
      <param name="name">O nome do evento a ser pesquisado.</param>
      <param name="bindingAttr">Uma combinação bit a bit de valores <see cref="T:System.Reflection.BindingFlags" /> que limita a pesquisa.</param>
      <returns>Um objeto <see cref="T:System.Reflection.EventInfo" /> que representa o evento declarado ou herdado por esse tipo com o nome especificado ou <see langword="null" /> se não houver correspondências.</returns>
      <exception cref="T:System.NotSupportedException">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetEvents">
      <summary>Retorna os eventos públicos declarados ou herdados por esse tipo.</summary>
      <returns>Retorna uma matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representa os eventos públicos declarados ou herdados por esse tipo. Uma matriz vazia será retornada se não houver eventos públicos.</returns>
      <exception cref="T:System.NotSupportedException">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
      <summary>Retorna os eventos públicos e não públicos que são declarados por esse tipo.</summary>
      <param name="bindingAttr">Uma combinação bit a bit de valores <see cref="T:System.Reflection.BindingFlags" /> que limita a pesquisa.</param>
      <returns>Retorna uma matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representa os eventos declarados ou herdados por esse tipo que correspondem aos sinalizadores de associação especificados. Uma matriz vazia será retornada se não houver eventos correspondentes.</returns>
      <exception cref="T:System.NotSupportedException">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary>Retorna o campo especificado pelo nome fornecido.</summary>
      <param name="name">O nome do campo a ser obtido.</param>
      <param name="bindingAttr">Esse deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como em <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns>Retorna o objeto <see cref="T:System.Reflection.FieldInfo" /> que representa o campo declarado ou herdado por esse tipo com o nome especificado e o modificador público ou não público. Se não houver correspondências, <see langword="null" /> será retornado.</returns>
      <exception cref="T:System.NotSupportedException">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
      <summary>Retorna o campo de tipo genérico construído especificado que corresponde ao campo especificado da definição de tipo genérico.</summary>
      <param name="type">O tipo genérico construído cujo campo será retornado.</param>
      <param name="field">Um campo na definição de tipo genérico de <paramref name="type" />, que especifica qual campo de <paramref name="type" /> será retornado.</param>
      <returns>Um objeto <see cref="T:System.Reflection.FieldInfo" /> que representa o campo de <paramref name="type" /> correspondente a <paramref name="field" />, que especifica um campo pertencente à definição de tipo genérico de <paramref name="type" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> não representa um tipo genérico.
- ou -
<paramref name="type" /> não é do tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.
- ou -
O tipo declarativo de <paramref name="field" /> não é uma definição de tipo genérico.
- ou -
O tipo declarativo de <paramref name="field" /> não é a definição de tipo genérico de <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary>Retorna os campos públicos e não públicos que são declarados por esse tipo.</summary>
      <param name="bindingAttr">Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns>Retorna uma matriz de objetos <see cref="T:System.Reflection.FieldInfo" /> que representam os campos públicos e não públicos declarados ou herdados por esse tipo. Se não há campos, uma matriz vazia é retornada, conforme especificado.</returns>
      <exception cref="T:System.NotSupportedException">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
      <summary>Retorna uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo de um tipo genérico ou os parâmetros de tipo de uma definição de tipo genérico.</summary>
      <returns>Uma matriz de objetos de <see cref="T:System.Type" />. Os elementos da matriz representam os argumentos de tipo de um tipo genérico ou os parâmetros de tipo de uma definição de tipo genérico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
      <summary>Retorna um objeto <see cref="T:System.Type" /> que representa uma definição de tipo genérico da qual o tipo atual pode ser obtido.</summary>
      <returns>Um objeto <see cref="T:System.Type" /> que representa uma definição de tipo genérico da qual o tipo atual pode ser obtido.</returns>
      <exception cref="T:System.InvalidOperationException">O tipo atual não é genérico. Ou seja, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> retorna <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
      <summary>Retorna a interface implementada (direta ou indiretamente) por essa classe com o nome totalmente qualificado correspondente ao nome de interface fornecido.</summary>
      <param name="name">O nome da interface.</param>
      <param name="ignoreCase">Se <see langword="true" />, a pesquisa não diferenciará maiúsculas de minúsculas. Se <see langword="false" />, a pesquisa diferenciará maiúsculas de minúsculas.</param>
      <returns>Retorna um objeto <see cref="T:System.Type" /> que representa a interface implementada. Retorna nulo se nenhum nome de interface correspondente for encontrado.</returns>
      <exception cref="T:System.NotSupportedException">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
      <summary>Retorna um mapeamento de interface para a interface solicitada.</summary>
      <param name="interfaceType">O <see cref="T:System.Type" /> da interface para a qual o mapeamento deve ser recuperado.</param>
      <returns>Retorna o mapeamento de interface solicitado.</returns>
      <exception cref="T:System.NotSupportedException">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetInterfaces">
      <summary>Retorna uma matriz de todas as interfaces implementadas nesse tipo e seus tipos base.</summary>
      <returns>Retorna uma matriz de objetos <see cref="T:System.Type" /> que representam as interfaces implementadas. Se nenhum deles for definido, uma matriz vazia será retornada.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
      <summary>Retorna todos os membros públicos e não públicos declarados ou herdados por esse tipo, conforme especificado.</summary>
      <param name="name">O nome do membro.</param>
      <param name="type">O tipo do membro a se retornar.</param>
      <param name="bindingAttr">Esse deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como em <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns>Retorna uma matriz de <see cref="T:System.Reflection.MemberInfo" /> objetos que representam os membros públicos e não públicos definidos nesse tipo se <paramref name="nonPublic" /> for usado; caso contrário, somente os membros públicos serão retornados.</returns>
      <exception cref="T:System.NotSupportedException">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
      <summary>Retorna os membros dos membros públicos e não públicos declarados ou herdados por esse tipo.</summary>
      <param name="bindingAttr">Esse deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns>Retorna uma matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representam os membros públicos e não públicos declarados ou herdados por esse tipo. Se não houver membros correspondentes, uma matriz vazia será retornada.</returns>
      <exception cref="T:System.NotSupportedException">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
      <summary>Retorna o método do tipo genérico construído especificado que corresponde ao método especificado da definição de tipo genérico.</summary>
      <param name="type">O tipo genérico construído cujo método será retornado.</param>
      <param name="method">Um método na definição de tipo genérico de <paramref name="type" /> que especifica qual método de <paramref name="type" /> será retornado.</param>
      <returns>Um objeto <see cref="T:System.Reflection.MethodInfo" /> que representa o método de <paramref name="type" /> correspondente a <paramref name="method" />, que especifica um método pertencente à definição de tipo genérico de <paramref name="type" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> é um método genérico que não é uma definição de método genérico.
- ou -
<paramref name="type" /> não representa um tipo genérico.
- ou -
<paramref name="type" /> não é do tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.
- ou -
O tipo declarativo de <paramref name="method" /> não é uma definição de tipo genérico.
- ou -
O tipo declarativo de <paramref name="method" /> não é a definição de tipo genérico de <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary>Retorna todos os métodos públicos e não públicos declarados ou herdados por esse tipo, conforme especificado.</summary>
      <param name="bindingAttr">Esse deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como em <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns>Retorna uma matriz de objetos <see cref="T:System.Reflection.MethodInfo" /> que representam os métodos públicos e não públicos definidos neste tipo se <paramref name="nonPublic" /> for usado; caso contrário, somente os métodos públicos serão retornados.</returns>
      <exception cref="T:System.NotSupportedException">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
      <summary>Retorna os tipos aninhados públicos e não públicos declarados por esse tipo.</summary>
      <param name="name">O <see cref="T:System.String" /> que contém o nome do tipo aninhado a ser obtido.</param>
      <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.
- ou -
Zero, para realizar uma pesquisa que diferencia maiúsculas de minúsculas para métodos públicos.</param>
      <returns>Um objeto <see cref="T:System.Type" /> que representa o tipo aninhado que corresponde aos requisitos especificados, se encontrado; caso contrário, <see langword="null" />.</returns>
      <exception cref="T:System.NotSupportedException">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
      <summary>Retorna os tipos aninhados públicos e não públicos que são declarados ou herdados por esse tipo.</summary>
      <param name="bindingAttr">Esse deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como em <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns>Uma matriz de objetos <see cref="T:System.Type" /> que representa todos os tipos aninhados no <see cref="T:System.Type" /> atual que correspondem às restrições de associação especificadas.
Uma matriz vazia do tipo <see cref="T:System.Type" /> se nenhum tipo estiver aninhado no <see cref="T:System.Type" /> atual ou se nenhum dos tipos aninhados corresponderem às restrições de associação.</returns>
      <exception cref="T:System.NotSupportedException">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
      <summary>Retorna todas as propriedades públicas e não públicas declaradas ou herdadas por esse tipo, conforme especificado.</summary>
      <param name="bindingAttr">Esse atributo de invocação. Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</param>
      <returns>Retorna uma matriz de objetos <see langword="PropertyInfo" /> que representam as propriedades públicas e não públicas definidas nesse tipo se <paramref name="nonPublic" /> for usado; caso contrário, somente as propriedades públicas serão retornadas.</returns>
      <exception cref="T:System.NotSupportedException">Esse método não está implementado para tipos incompletos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.GUID">
      <summary>Recupera o GUID desse tipo.</summary>
      <returns>Somente leitura. Recupera o GUID deste tipo</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para tipos incompletos nesse método atualmente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
      <summary>Invoca o membro especificado. O método a ser invocado deve ser acessível e fornecer a correspondência mais específica com a lista de argumentos especificada, sob as restrições dos atributos associadores e de invocação especificados.</summary>
      <param name="name">O nome do membro a ser invocado. Isso pode ser um construtor, um método, uma propriedade ou um campo. É necessário especificar um atributo de invocação adequado. Observe que é possível invocar o membro padrão de uma classe, passando uma cadeia de caracteres vazia como o nome do membro.</param>
      <param name="invokeAttr">O atributo de invocação. Isso deve ser um sinalizador de bit de <see langword="BindingFlags" />.</param>
      <param name="binder">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see langword="MemberInfo" /> usando reflexão. Se o associador for <see langword="null" />, o associador padrão será usado. Consulte <see cref="T:System.Reflection.Binder" />.</param>
      <param name="target">O objeto no qual invocar o membro especificado. Se o membro é estático, esse parâmetro é ignorado.</param>
      <param name="args">Uma lista de argumentos. Essa é uma matriz de objetos que contém o número, a ordem e o tipo dos parâmetros do membro a ser invocado. Se não houver nenhum parâmetro, isso deverá ser nulo.</param>
      <param name="modifiers">Uma matriz do mesmo comprimento que <paramref name="args" /> com elementos que representam os atributos associados com os argumentos do membro a ser invocado. Um parâmetro com atributos associados a ele nos metadados. Eles são usados por diversos serviços de interoperabilidade. Consulte as especificações de metadados para obter mais detalhes.</param>
      <param name="culture">Uma instância de <see langword="CultureInfo" /> usada para determinar a coerção de tipos. Se isso for nulo, será usado o <see langword="CultureInfo" /> do thread atual. (Por exemplo, isso é necessário para converter uma cadeia de caracteres que representa 1000 para um valor de tipo double, uma vez que 1000 é representado de forma diferente por diferentes culturas.)</param>
      <param name="namedParameters">Cada parâmetro na matriz <paramref name="namedParameters" /> obtém o valor no elemento correspondente na matriz <paramref name="args" />. Se o comprimento de <paramref name="args" /> for maior que o de <paramref name="namedParameters" />, os valores de argumento restantes serão passados em ordem.</param>
      <returns>Retorna o valor retornado do membro invocado.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para tipos incompletos nesse método atualmente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
      <summary>Obtém um valor que indica se um <see cref="T:System.Type" /> especificado pode ser atribuído a esse objeto.</summary>
      <param name="c">O objeto a ser testado.</param>
      <returns>
        <see langword="true" /> se o parâmetro <paramref name="c" /> e o tipo atual representarem o mesmo tipo, se o tipo atual estiver na hierarquia de herança de <paramref name="c" /> ou se o tipo atual for uma interface à qual <paramref name="c" /> dá suporte. <see langword="false" /> se nenhuma dessas condições for válida ou se <paramref name="c" /> for <see langword="null" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsByRefLike" />
    <member name="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType">
      <summary>Obtém um valor que indica se este objeto representa um tipo genérico construído.</summary>
      <returns>
        <see langword="true" /> se este objeto representar um tipo genérico construído; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsCreated">
      <summary>Retorna um valor que indica se o tipo dinâmico atual foi criado.</summary>
      <returns>
        <see langword="true" /> se o método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> tiver sido chamado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Determina se um atributo personalizado é aplicado ou tipo atual.</summary>
      <param name="attributeType">O tipo de atributo a ser pesquisado. Somente os atributos que podem ser atribuídos a esse tipo são retornados.</param>
      <param name="inherit">Especifica se deve-se pesquisar ou não a cadeia de herança desse membro para localizar os atributos.</param>
      <returns>
        <see langword="true" /> se uma ou mais instâncias de <paramref name="attributeType" /> ou um atributo derivado de <paramref name="attributeType" /> forem definidos nesse tipo; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">Não há suporte para tipos incompletos nesse método atualmente. Recupere o tipo usando <see cref="M:System.Type.GetType" /> e chame <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> no <see cref="T:System.Type" /> retornado.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributeType" /> não está definido.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> é <see langword="null" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter">
      <summary>Obtém um valor que indica se o tipo atual é um parâmetro de tipo genérico.</summary>
      <returns>
        <see langword="true" /> se o objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> atual representar um parâmetro de tipo genérico; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
      <summary>Obtém um valor que indica se o tipo atual é um tipo genérico.</summary>
      <returns>
        <see langword="true" /> se o tipo representado pelo objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> atual for genérico; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
      <summary>Obtém um valor que indica se o <see cref="T:System.Reflection.Emit.TypeBuilder" /> atual representa uma definição de tipo genérico, da qual outros tipos genéricos podem ser construídos.</summary>
      <returns>
        <see langword="true" /> se este objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> representa uma definição de tipo genérico; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
      <summary>Obtém um valor que indica se o tipo atual é crítico para segurança ou crítico para segurança e disponível no código transparente e, portanto, pode executar operações críticas.</summary>
      <returns>
        <see langword="true" /> se o tipo atual for Security-Critical ou Security-Safe-Critical; <see langword="false" /> se for transparente.</returns>
      <exception cref="T:System.NotSupportedException">O tipo dinâmico atual não foi criado chamando o método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
      <summary>Obtém um valor que indica se o tipo atual é crítico para segurança e disponível no código transparente, ou seja, se pode executar operações críticas e ser acessado por código transparente.</summary>
      <returns>
        <see langword="true" /> se o tipo atual for segurança-seguro-crítico; <see langword="false" /> se for de segurança crítica ou transparente.</returns>
      <exception cref="T:System.NotSupportedException">O tipo dinâmico atual não foi criado chamando o método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
      <summary>Obtém um valor que indica se o tipo atual é transparente e, portanto, não pode executar operações críticas.</summary>
      <returns>
        <see langword="true" /> se o tipo for de segurança transparente; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">O tipo dinâmico atual não foi criado chamando o método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
      <summary>Determina se esse tipo é derivado de um tipo especificado.</summary>
      <param name="c">Um <see cref="T:System.Type" /> que será verificado.</param>
      <returns>Somente leitura. Retorna <see langword="true" /> se esse tipo for igual ao tipo <paramref name="c" /> ou um subtipo do tipo <paramref name="c" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSZArray" />
    <member name="P:System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
    <member name="P:System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
      <summary>Retorna um objeto <see cref="T:System.Type" /> que representa uma matriz unidimensional do tipo atual, com um limite inferior de zero.</summary>
      <returns>Um objeto <see cref="T:System.Type" /> que representa uma matriz unidimensional do tipo cujo tipo de elemento é o tipo atual, com um limite inferior de zero.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
      <summary>Retorna um objeto <see cref="T:System.Type" /> que representa uma matriz do tipo atual, com o número de dimensões especificado.</summary>
      <param name="rank">O número de dimensões da matriz.</param>
      <returns>Um objeto <see cref="T:System.Type" /> que representa uma matriz unidimensional do tipo atual.</returns>
      <exception cref="T:System.IndexOutOfRangeException">
        <paramref name="rank" /> não é uma dimensão de matriz válida.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
      <summary>Retorna um objeto <see cref="T:System.Type" /> que representa o tipo atual quando passado como um parâmetro <see langword="ref" /> (<see langword="ByRef" /> no Visual Basic).</summary>
      <returns>Um objeto <see cref="T:System.Type" /> que representa o tipo atual quando passado como um parâmetro <see langword="ref" /> (<see langword="ByRef" /> no Visual Basic).</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
      <summary>Substitui os elementos de uma matriz de tipos pelos parâmetros de tipo da definição de tipo genérico atual e retorna o tipo construído resultante.</summary>
      <param name="typeArguments">Uma matriz de tipos a serem substituídos pelos parâmetros da definição de tipo genérico atual.</param>
      <returns>Um <see cref="T:System.Type" /> representando o tipo construído formado substituindo os elementos do <paramref name="typeArguments" /> pelos parâmetros de tipo do tipo genérico atual.</returns>
      <exception cref="T:System.InvalidOperationException">O tipo atual não representa a definição de um tipo genérico. Ou seja, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> retorna <see langword="false" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArguments" /> é <see langword="null" />.
- ou -
Qualquer elemento de <paramref name="typeArguments" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">A propriedade <see cref="P:System.Type.Module" /> de qualquer elemento de <paramref name="typeArguments" /> é <see langword="null" />.
- ou -
A propriedade <see cref="P:System.Reflection.Module.Assembly" /> do módulo de qualquer elemento de <paramref name="typeArguments" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
      <summary>Retorna um objeto <see cref="T:System.Type" /> que representa o tipo de um ponteiro não gerenciado para o tipo atual.</summary>
      <returns>Um objeto <see cref="T:System.Type" /> que representa o tipo de um ponteiro não gerenciado para o tipo atual.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Module">
      <summary>Recupera o módulo dinâmico que contém essa definição de tipo.</summary>
      <returns>Somente leitura. Recupera o módulo dinâmico que contém essa definição de tipo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Name">
      <summary>Recupera o nome desse tipo.</summary>
      <returns>Somente leitura. Recupera o nome <see cref="T:System.String" /> desse tipo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Namespace">
      <summary>Recupera o namespace em que esse <see langword="TypeBuilder" /> é definido.</summary>
      <returns>Somente leitura. Recupera o namespace em que esse <see langword="TypeBuilder" /> é definido.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.PackingSize">
      <summary>Recupera o tamanho de empacotamento desse tipo.</summary>
      <returns>Somente leitura. Recupera o tamanho de empacotamento desse tipo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.ReflectedType">
      <summary>Retorna o tipo usado para obter esse tipo.</summary>
      <returns>Somente leitura. O tipo que foi usado para obter esse tipo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Define um atributo personalizado usando um blob de atributo personalizado especificado.</summary>
      <param name="con">O construtor do atributo personalizado.</param>
      <param name="binaryAttribute">Um blob de bytes que representa os atributos.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Defina um atributo personalizado usando um construtor de atributos personalizados.</summary>
      <param name="customBuilder">Uma instância de uma classe auxiliar para definir o atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
      <summary>Define o tipo base do tipo em construção atualmente.</summary>
      <param name="parent">O novo tipo base.</param>
      <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.
- ou -
<paramref name="parent" /> é <see langword="null" /> e a instância atual representa uma interface cujos atributos não incluem <see cref="F:System.Reflection.TypeAttributes.Abstract" />.
- ou -
Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> é uma interface. Essa condição de exceção é nova na versão 2.0 do .NET Framework.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Size">
      <summary>Recupera o tamanho total de um tipo.</summary>
      <returns>Somente leitura. Recupera o tamanho total deste tipo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.ToString">
      <summary>Retorna o nome do tipo excluindo o namespace.</summary>
      <returns>Somente leitura. O nome do tipo excluindo o namespace.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
      <summary>Não tem suporte em módulos dinâmicos.</summary>
      <returns>Somente leitura.</returns>
      <exception cref="T:System.NotSupportedException">Não tem suporte em módulos dinâmicos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
      <summary>Retorna o tipo de sistema subjacente para esse <see langword="TypeBuilder" />.</summary>
      <returns>Somente leitura. Retorna o tipo de sistema subjacente.</returns>
      <exception cref="T:System.InvalidOperationException">Esse tipo é uma enumeração, mas não há um tipo de sistema subjacente.</exception>
    </member>
    <member name="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize">
      <summary>Representa a não especificação do tamanho total do tipo.</summary>
    </member>
  </members>
</doc>