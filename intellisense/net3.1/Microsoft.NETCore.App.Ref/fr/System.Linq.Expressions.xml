<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Linq.Expressions</name>
  </assembly>
  <members>
    <member name="T:System.Dynamic.BinaryOperationBinder">
      <summary>Représente l’opération dynamique binaire sur le site d’appel, en fournissant la sémantique de liaison et les détails de l’opération.</summary>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.#ctor(System.Linq.Expressions.ExpressionType)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Dynamic.BinaryOperationBinder" />.</summary>
      <param name="operation">Type d'opération binaire.</param>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération binaire dynamique.</summary>
      <param name="target">Cible de l'opération dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération dynamique.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.FallbackBinaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Effectue la liaison de l'opération dynamique binaire si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target">Cible de l'opération binaire dynamique.</param>
      <param name="arg">Opérande droit de l'opération binaire dynamique.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.FallbackBinaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>En cas de substitution dans la classe dérivée, exécute la liaison de l'opération dynamique binaire si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target">Cible de l'opération binaire dynamique.</param>
      <param name="arg">Opérande droit de l'opération binaire dynamique.</param>
      <param name="errorSuggestion">Résultat de liaison si la liaison échoue, ou Null.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.BinaryOperationBinder.Operation">
      <summary>Type d'opération binaire.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.ExpressionType" /> représentant le type d'opération binaire.</returns>
    </member>
    <member name="P:System.Dynamic.BinaryOperationBinder.ReturnType">
      <summary>Type de résultat de l'opération.</summary>
      <returns>Type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.BindingRestrictions">
      <summary>Représente un jeu de restrictions de liaison sur le <see cref="T:System.Dynamic.DynamicMetaObject" /> sous lequel la liaison dynamique est valide.</summary>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.Combine(System.Collections.Generic.IList{System.Dynamic.DynamicMetaObject})">
      <summary>Combine les restrictions de liaison de la liste d'instances de <see cref="T:System.Dynamic.DynamicMetaObject" /> en un jeu de restrictions.</summary>
      <param name="contributingObjects">Liste des instances de <see cref="T:System.Dynamic.DynamicMetaObject" /> à partir desquelles combiner les restrictions.</param>
      <returns>Nouveau jeu de restrictions de liaison.</returns>
    </member>
    <member name="F:System.Dynamic.BindingRestrictions.Empty">
      <summary>Représente un jeu de restrictions de liaison vide. Ce champ est en lecture seule.</summary>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetExpressionRestriction(System.Linq.Expressions.Expression)">
      <summary>Crée la restriction de liaison qui vérifie si l'expression contient des propriétés immuables arbitraires.</summary>
      <param name="expression">Expression qui représente les restrictions.</param>
      <returns>Restrictions applicables à la nouvelle liaison.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetInstanceRestriction(System.Linq.Expressions.Expression,System.Object)">
      <summary>Crée la restriction de liaison qui vérifie l'identité de l'instance de l'objet dans l'expression.</summary>
      <param name="expression">Expression à tester.</param>
      <param name="instance">Instance exacte de l'objet à tester.</param>
      <returns>Restrictions applicables à la nouvelle liaison.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetTypeRestriction(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée la restriction de liaison qui vérifie l'identité du type au moment de l'exécution dans l'expression.</summary>
      <param name="expression">Expression à tester.</param>
      <param name="type">Type exact à tester.</param>
      <returns>Restrictions applicables à la nouvelle liaison.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.Merge(System.Dynamic.BindingRestrictions)">
      <summary>Fusionne le jeu de restrictions de liaison avec les restrictions de liaison actuelles.</summary>
      <param name="restrictions">Jeu de restrictions à fusionner avec les restrictions de liaison actuelles.</param>
      <returns>Nouveau jeu de restrictions de liaison.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.ToExpression">
      <summary>Crée le <see cref="T:System.Linq.Expressions.Expression" /> qui représente les restrictions de liaison.</summary>
      <returns>Arborescence de l'expression qui représente les restrictions.</returns>
    </member>
    <member name="T:System.Dynamic.CallInfo">
      <summary>Décrit les arguments dans le processus de liaison dynamique.</summary>
    </member>
    <member name="M:System.Dynamic.CallInfo.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.String})">
      <summary>Crée un nouveau CallInfo qui représente des arguments dans le processus de liaison dynamique.</summary>
      <param name="argCount">Le nombre d’arguments.</param>
      <param name="argNames">Noms d'arguments.</param>
    </member>
    <member name="M:System.Dynamic.CallInfo.#ctor(System.Int32,System.String[])">
      <summary>Crée un <c>PositionalArgumentInfo</c>.</summary>
      <param name="argCount">Le nombre d’arguments.</param>
      <param name="argNames">Noms d'arguments.</param>
    </member>
    <member name="P:System.Dynamic.CallInfo.ArgumentCount">
      <summary>Le nombre d’arguments.</summary>
      <returns>Le nombre d’arguments.</returns>
    </member>
    <member name="P:System.Dynamic.CallInfo.ArgumentNames">
      <summary>Noms d'arguments.</summary>
      <returns>Collection en lecture seule de noms d'arguments.</returns>
    </member>
    <member name="M:System.Dynamic.CallInfo.Equals(System.Object)">
      <summary>Détermine si l'instance de CallInfo spécifiée est considérée comme étant égale à l'instance en cours.</summary>
      <param name="obj">Instance de <see cref="T:System.Dynamic.CallInfo" /> à comparer avec l'instance actuelle.</param>
      <returns>
        <see langword="true" /> si l’instance spécifiée est égale à l’instance actuelle ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Dynamic.CallInfo.GetHashCode">
      <summary>Sert de fonction de hachage pour le <see cref="T:System.Dynamic.CallInfo" /> actuel.</summary>
      <returns>Code de hachage du <see cref="T:System.Dynamic.CallInfo" /> actuel.</returns>
    </member>
    <member name="T:System.Dynamic.ConvertBinder">
      <summary>Représente l’opération dynamique de conversion sur le site d’appel, en fournissant la sémantique de liaison et les détails de l’opération.</summary>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.#ctor(System.Type,System.Boolean)">
      <summary>Initialise une nouvelle instance de l'objet <see cref="T:System.Dynamic.ConvertBinder" />.</summary>
      <param name="type">Type vers lequel effectuer la conversion.</param>
      <param name="explicit">A la valeur true si la conversion doit prendre en compte les conversions de type explicite ; sinon, false.</param>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération de conversion dynamique.</summary>
      <param name="target">Cible de l'opération de conversion dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération de conversion dynamique.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.Explicit">
      <summary>Obtient la valeur qui indique si la conversion doit prendre en compte les conversions de type explicite.</summary>
      <returns>
        <see langword="true" />s’il existe une conversion explicite ; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.FallbackConvert(System.Dynamic.DynamicMetaObject)">
      <summary>Effectue la liaison de l'opération de conversion dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target">Cible de l'opération de conversion dynamique.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.FallbackConvert(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>En cas de substitution dans la classe dérivée, exécute la liaison de l'opération de conversion dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target">Cible de l'opération de conversion dynamique.</param>
      <param name="errorSuggestion">Résultat de liaison à utiliser si la liaison échoue, ou Null.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.ReturnType">
      <summary>Type de résultat de l'opération.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.Type">
      <summary>Type vers lequel effectuer la conversion.</summary>
      <returns>Objet <see cref="T:System.Type" /> qui représente le type vers lequel effectuer la conversion.</returns>
    </member>
    <member name="T:System.Dynamic.CreateInstanceBinder">
      <summary>Représente l’opération de création dynamique sur le site d’appel, en fournissant la sémantique de liaison et les détails de l’opération.</summary>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Initialise une nouvelle instance de l'objet <see cref="T:System.Dynamic.CreateInstanceBinder" />.</summary>
      <param name="callInfo">Signature des arguments au niveau du site d’appel.</param>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération de création dynamique.</summary>
      <param name="target">Cible de l'opération de création dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération de création dynamique.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.CreateInstanceBinder.CallInfo">
      <summary>Obtient la signature des arguments au niveau du site d’appel.</summary>
      <returns>Signature des arguments au niveau du site d’appel.</returns>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.FallbackCreateInstance(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Effectue la liaison de l'opération de création dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target">Cible de l'opération de création dynamique.</param>
      <param name="args">Arguments de l'opération de création dynamique.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.FallbackCreateInstance(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>En cas de substitution dans la classe dérivée, exécute la liaison de l'opération de création dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target">Cible de l'opération de création dynamique.</param>
      <param name="args">Arguments de l'opération de création dynamique.</param>
      <param name="errorSuggestion">Résultat de liaison à utiliser si la liaison échoue, ou Null.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.CreateInstanceBinder.ReturnType">
      <summary>Type de résultat de l'opération.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.DeleteIndexBinder">
      <summary>Représente l'opération de suppression d'index dynamique au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Initialise une nouvelle instance de l'objet <see cref="T:System.Dynamic.DeleteIndexBinder" />.</summary>
      <param name="callInfo">Signature des arguments au niveau du site d’appel.</param>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération de suppression d'index dynamique.</summary>
      <param name="target">Cible de l'opération de suppression d'index dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération de suppression d'index dynamique.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteIndexBinder.CallInfo">
      <summary>Obtient la signature des arguments au niveau du site d’appel.</summary>
      <returns>Signature des arguments au niveau du site d’appel.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.FallbackDeleteIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Effectue la liaison de l'opération de suppression d'index dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target">Cible de l'opération de suppression d'index dynamique.</param>
      <param name="indexes">Arguments de l'opération de suppression d'index dynamique.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.FallbackDeleteIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>En cas de substitution dans la classe dérivée, exécute la liaison de l'opération de suppression d'index dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target">Cible de l'opération de suppression d'index dynamique.</param>
      <param name="indexes">Arguments de l'opération de suppression d'index dynamique.</param>
      <param name="errorSuggestion">Résultat de liaison à utiliser si la liaison échoue, ou Null.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteIndexBinder.ReturnType">
      <summary>Type de résultat de l'opération.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.DeleteMemberBinder">
      <summary>Représente l'opération de suppression de membre dynamique au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.#ctor(System.String,System.Boolean)">
      <summary>Initialise une nouvelle instance de l'objet <see cref="T:System.Dynamic.DeleteIndexBinder" />.</summary>
      <param name="name">Nom du membre à supprimer.</param>
      <param name="ignoreCase">True si la correspondance avec le nom doit ignorer la casse ; sinon, False.</param>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération de suppression de membre dynamique.</summary>
      <param name="target">Cible de l'opération de suppression de membre dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération de suppression de membre dynamique.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.FallbackDeleteMember(System.Dynamic.DynamicMetaObject)">
      <summary>Effectue la liaison de l'opération de suppression de membre dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target">Cible de l'opération de suppression de membre dynamique.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.FallbackDeleteMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>En cas de substitution dans la classe dérivée, exécute la liaison de l'opération de suppression de membre dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target">Cible de l'opération de suppression de membre dynamique.</param>
      <param name="errorSuggestion">Résultat de liaison à utiliser si la liaison échoue, ou Null.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.IgnoreCase">
      <summary>Obtient la valeur indiquant si la comparaison de chaîne doit ignorer la casse du nom du membre.</summary>
      <returns>
        <see langword="true" />Si la comparaison de chaînes doit ignorer la casse ; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.Name">
      <summary>Obtient le nom du membre à supprimer.</summary>
      <returns>Nom du membre à supprimer.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.ReturnType">
      <summary>Type de résultat de l'opération.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicMetaObject">
      <summary>Représente la liaison dynamique et une logique de liaison d'un objet qui participe à la liaison dynamique.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.#ctor(System.Linq.Expressions.Expression,System.Dynamic.BindingRestrictions)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <param name="expression">Expression représentant cet objet <see cref="T:System.Dynamic.DynamicMetaObject" /> durant le processus de liaison dynamique.</param>
      <param name="restrictions">Ensemble de restrictions de liaisons sous lequel la liaison est valide.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.#ctor(System.Linq.Expressions.Expression,System.Dynamic.BindingRestrictions,System.Object)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <param name="expression">Expression représentant cet objet <see cref="T:System.Dynamic.DynamicMetaObject" /> durant le processus de liaison dynamique.</param>
      <param name="restrictions">Ensemble de restrictions de liaisons sous lequel la liaison est valide.</param>
      <param name="value">Valeur d'exécution représentée par <see cref="T:System.Dynamic.DynamicMetaObject" />.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Dynamic.DynamicMetaObject)">
      <summary>Exécute la liaison de l'opération binaire dynamique.</summary>
      <param name="binder">Instance du <see cref="T:System.Dynamic.BinaryOperationBinder" /> qui représente les détails de l'opération dynamique.</param>
      <param name="arg">Instance de <see cref="T:System.Dynamic.DynamicMetaObject" /> qui représente le côté droit de l'opération binaire.</param>
      <returns>Nouveau <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindConvert(System.Dynamic.ConvertBinder)">
      <summary>Exécute la liaison de l'opération de conversion dynamique.</summary>
      <param name="binder">Instance du <see cref="T:System.Dynamic.ConvertBinder" /> qui représente les détails de l'opération dynamique.</param>
      <returns>Nouveau <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindCreateInstance(System.Dynamic.CreateInstanceBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération de création d'instance dynamique.</summary>
      <param name="binder">Instance du <see cref="T:System.Dynamic.CreateInstanceBinder" /> qui représente les détails de l'opération dynamique.</param>
      <param name="args">Tableau d'instances <see cref="T:System.Dynamic.DynamicMetaObject" />, arguments de l'opération de création d'instance.</param>
      <returns>Nouveau <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération de suppression d'index dynamique.</summary>
      <param name="binder">Instance du <see cref="T:System.Dynamic.DeleteIndexBinder" /> qui représente les détails de l'opération dynamique.</param>
      <param name="indexes">Tableau d'instances de <see cref="T:System.Dynamic.DynamicMetaObject" />, index pour l'opération de suppression d'index.</param>
      <returns>Nouveau <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindDeleteMember(System.Dynamic.DeleteMemberBinder)">
      <summary>Exécute la liaison de l'opération de suppression de membre dynamique.</summary>
      <param name="binder">Instance du <see cref="T:System.Dynamic.DeleteMemberBinder" /> qui représente les détails de l'opération dynamique.</param>
      <returns>Nouveau <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindGetIndex(System.Dynamic.GetIndexBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération d'obtention d'index dynamique.</summary>
      <param name="binder">Instance du <see cref="T:System.Dynamic.GetIndexBinder" /> qui représente les détails de l'opération dynamique.</param>
      <param name="indexes">Tableau d'instances de <see cref="T:System.Dynamic.DynamicMetaObject" />, index pour l'opération d'obtention d'index.</param>
      <returns>Nouveau <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindGetMember(System.Dynamic.GetMemberBinder)">
      <summary>Exécute la liaison de l'opération d'obtention de membre dynamique.</summary>
      <param name="binder">Instance du <see cref="T:System.Dynamic.GetMemberBinder" /> qui représente les détails de l'opération dynamique.</param>
      <returns>Nouveau <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindInvoke(System.Dynamic.InvokeBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Effectue la liaison de l’opération d’appel dynamique.</summary>
      <param name="binder">Instance du <see cref="T:System.Dynamic.InvokeBinder" /> qui représente les détails de l'opération dynamique.</param>
      <param name="args">Tableau d'instances <see cref="T:System.Dynamic.DynamicMetaObject" />, arguments de l'opération d'appel.</param>
      <returns>Nouveau <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindInvokeMember(System.Dynamic.InvokeMemberBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération d'appel de membre dynamique.</summary>
      <param name="binder">Instance du <see cref="T:System.Dynamic.InvokeMemberBinder" /> qui représente les détails de l'opération dynamique.</param>
      <param name="args">Tableau d'instances <see cref="T:System.Dynamic.DynamicMetaObject" />, arguments de l'opération d'appel de membres.</param>
      <returns>Nouveau <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindSetIndex(System.Dynamic.SetIndexBinder,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Exécute la liaison de l'opération de définition d'index dynamique.</summary>
      <param name="binder">Instance du <see cref="T:System.Dynamic.SetIndexBinder" /> qui représente les détails de l'opération dynamique.</param>
      <param name="indexes">Tableau d'instances de <see cref="T:System.Dynamic.DynamicMetaObject" />, index pour l'opération de définition d'index.</param>
      <param name="value">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant la valeur pour l'opération de définition d'index.</param>
      <returns>Nouveau <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindSetMember(System.Dynamic.SetMemberBinder,System.Dynamic.DynamicMetaObject)">
      <summary>Exécute la liaison de l'opération de définition de membre dynamique.</summary>
      <param name="binder">Instance du <see cref="T:System.Dynamic.SetMemberBinder" /> qui représente les détails de l'opération dynamique.</param>
      <param name="value">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant la valeur pour l'opération de définition de membre.</param>
      <returns>Nouveau <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindUnaryOperation(System.Dynamic.UnaryOperationBinder)">
      <summary>Exécute la liaison de l'opération unaire dynamique.</summary>
      <param name="binder">Instance du <see cref="T:System.Dynamic.UnaryOperationBinder" /> qui représente les détails de l'opération dynamique.</param>
      <returns>Nouveau <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.Create(System.Object,System.Linq.Expressions.Expression)">
      <summary>Crée un objet méta pour l'objet spécifié.</summary>
      <param name="value">Objet pour lequel obtenir un objet méta.</param>
      <param name="expression">Expression représentant cet objet <see cref="T:System.Dynamic.DynamicMetaObject" /> durant le processus de liaison dynamique.</param>
      <returns>Si l'objet spécifié implémente <see cref="T:System.Dynamic.IDynamicMetaObjectProvider" /> et n'est pas un objet distant extérieur au AppDomain actuel, retourne l'objet méta spécifique à l'objet retourné par <see cref="M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)" />. Sinon, un nouvel objet méta brut sans restrictions est créé et retourné.</returns>
    </member>
    <member name="F:System.Dynamic.DynamicMetaObject.EmptyMetaObjects">
      <summary>Représente un tableau vide du type <see cref="T:System.Dynamic.DynamicMetaObject" />. Ce champ est en lecture seule.</summary>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Expression">
      <summary>Expression représentant <see cref="T:System.Dynamic.DynamicMetaObject" /> durant le processus de liaison dynamique.</summary>
      <returns>Expression représentant <see cref="T:System.Dynamic.DynamicMetaObject" /> durant le processus de liaison dynamique.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.GetDynamicMemberNames">
      <summary>Retourne l'énumération de tous les noms de membres dynamiques.</summary>
      <returns>Liste des noms de membres dynamiques.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.HasValue">
      <summary>Obtient une valeur indiquant si <see cref="T:System.Dynamic.DynamicMetaObject" /> a la valeur d'exécution.</summary>
      <returns>
        <see langword="true" />Si le <see cref="T:System.Dynamic.DynamicMetaObject" /> a la valeur d’exécution ; sinon <see langword="false" />,.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.LimitType">
      <summary>Obtient le type de limite de <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <returns>
        <see cref="P:System.Dynamic.DynamicMetaObject.RuntimeType" /> si la valeur d'exécution est disponible, sinon type de <see cref="P:System.Dynamic.DynamicMetaObject.Expression" />.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Restrictions">
      <summary>Ensemble de restrictions de liaisons sous lequel la liaison est valide.</summary>
      <returns>Jeu des restrictions de liaison.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.RuntimeType">
      <summary>Obtient le <see cref="T:System.Type" /> de la valeur d'exécution ou null si <see cref="T:System.Dynamic.DynamicMetaObject" /> n'est associé à aucune valeur.</summary>
      <returns>
        <see cref="T:System.Type" /> de la valeur d'exécution ou null.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Value">
      <summary>Valeur d'exécution représentée par <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <returns>Valeur d'exécution représentée par <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicMetaObjectBinder">
      <summary>Binder de site d'appel dynamique qui participe au protocole de liaison <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Dynamic.DynamicMetaObjectBinder" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>En cas de substitution dans la classe dérivée, exécute la liaison de l'opération dynamique.</summary>
      <param name="target">Cible de l'opération dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération dynamique.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Bind(System.Object[],System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.LabelTarget)">
      <summary>Exécute la liaison au moment de l'exécution de l'opération dynamique sur un jeu d'arguments.</summary>
      <param name="args">Tableau d'arguments de l'opération dynamique.</param>
      <param name="parameters">Tableau des instances <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui représentent les paramètres du site d'appel dans le processus de liaison.</param>
      <param name="returnLabel">LabelTarget utilisé pour retourner le résultat de la liaison dynamique.</param>
      <returns>Expression qui exécute des tests sur les arguments d'opération dynamique, et exécute l'opération dynamique si les tests sont valides. Si les tests échouent sur les occurrences suivantes de l'opération dynamique, Bind est à nouveau appelé pour produire un nouveau <see cref="T:System.Linq.Expressions.Expression" /> pour les nouveaux types d'arguments.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Defer(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Diffère la liaison de l'opération jusqu'à ce que les valeurs d'exécution de tous les arguments d'opération dynamique soient calculées.</summary>
      <param name="target">Cible de l'opération dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération dynamique.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Defer(System.Dynamic.DynamicMetaObject[])">
      <summary>Diffère la liaison de l'opération jusqu'à ce que les valeurs d'exécution de tous les arguments d'opération dynamique soient calculées.</summary>
      <param name="args">Tableau d'arguments de l'opération dynamique.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.GetUpdateExpression(System.Type)">
      <summary>Obtient une expression qui entraîne la mise à jour de la liaison. Indique que la liaison de l'expression n'est plus valide. Cela est utilisé en général lorsque la « version » d'un objet dynamique a changé.</summary>
      <param name="type">Propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de l'expression résultante ; tous les types sont autorisés.</param>
      <returns>Expression de mise à jour.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObjectBinder.ReturnType">
      <summary>Type de résultat de l'opération.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicObject">
      <summary>Fournit une classe de base pour la spécification du comportement dynamique pendant l'exécution. Cette classe doit être héritée ; vous ne pouvez pas l'instancier directement.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicObject.#ctor">
      <summary>Permet aux types dérivés d'initialiser une nouvelle instance du type <see cref="T:System.Dynamic.DynamicObject" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicObject.GetDynamicMemberNames">
      <summary>Retourne l'énumération de tous les noms de membres dynamiques.</summary>
      <returns>Séquence qui contient des noms de membre dynamiques.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>Fournit un <see cref="T:System.Dynamic.DynamicMetaObject" /> qui distribue aux méthodes virtuelles dynamiques. L'objet peut être encapsulé dans un autre <see cref="T:System.Dynamic.DynamicMetaObject" /> pour définir un comportement personnalisé pour des actions individuelles. Cette méthode prend en charge l'infrastructure Dynamic Language Runtime pour les implémenteurs de langage et n'est pas conçue pour être utilisée directement dans votre code.</summary>
      <param name="parameter">Expression qui représente le <see cref="T:System.Dynamic.DynamicMetaObject" /> à distribuer aux méthodes virtuelles dynamiques.</param>
      <returns>Objet de type <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
      <summary>Fournit une implémentation pour les opérations binaires. Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode afin de spécifier le comportement dynamique pour certaines opérations telles que l'addition et la multiplication.</summary>
      <param name="binder">Fournit des informations sur l'opération binaire. La propriété <c>binder.Operation</c> retourne un objet <see cref="T:System.Linq.Expressions.ExpressionType" />. Par exemple, pour l’instruction <c>sum = first + second</c>, où <c>first</c> et <c>second</c> sont dérivés de la classe <see langword="DynamicObject" />, <c>binder.Operation</c> retourne <c>ExpressionType.Add</c>.</param>
      <param name="arg">Opérande droit pour l'opération binaire. Par exemple, pour l’instruction <c>sum = first + second</c>, où <c>first</c> et <c>second</c> sont dérivés de la classe <see langword="DynamicObject" />, <paramref name="arg" /> est égal à <c>second</c>.</param>
      <param name="result">Résultat de l'opération binaire.</param>
      <returns>
        <see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d'exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
      <summary>Fournit l'implémentation pour les opérations de conversion de type. Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode pour spécifier le comportement dynamique pour certaines opérations qui convertissent un objet d'un type en un autre.</summary>
      <param name="binder">Fournit des informations sur l'opération de conversion. La propriété <c>binder.Type</c> fournit le type dans lequel l’objet doit être converti. Par exemple, pour l’instruction <c>(String)sampleObject</c> en C# (<c>CType(sampleObject, Type)</c> en Visual Basic), où <c>sampleObject</c> est une instance de la classe dérivée de la classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Type</c> retourne le type <see cref="T:System.String" />. La propriété <c>binder.Explicit</c> fournit des informations sur le genre de conversion qui se produit. Elle retourne la valeur <see langword="true" /> pour la conversion explicite et la valeur <see langword="false" /> pour la conversion implicite.</param>
      <param name="result">Résultat de l'opération de conversion de type.</param>
      <returns>
        <see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d'exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
      <summary>Fournit l'implémentation pour les opérations qui initialisent une nouvelle instance d'un objet dynamique. Cette méthode n'est pas destinée à être utilisée en C# ou en Visual Basic.</summary>
      <param name="binder">Fournit des informations sur l'opération d'initialisation.</param>
      <param name="args">Arguments passés à l'objet pendant l'initialisation. Par exemple, pour l’opération <c>new SampleType(100)</c>, où <c>SampleType</c> est le type dérivé la classe <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> est égal à 100.</param>
      <param name="result">Résultat de l'initialisation.</param>
      <returns>
        <see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d'exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
      <summary>Fournit l'implémentation pour les opérations qui suppriment un objet par index. Cette méthode n'est pas destinée à être utilisée en C# ou en Visual Basic.</summary>
      <param name="binder">Fournit des informations sur la suppression.</param>
      <param name="indexes">Index à supprimer.</param>
      <returns>
        <see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d'exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
      <summary>Fournit l'implémentation pour les opérations qui suppriment un membre objet. Cette méthode n'est pas destinée à être utilisée en C# ou en Visual Basic.</summary>
      <param name="binder">Fournit des informations sur la suppression.</param>
      <returns>
        <see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d'exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
      <summary>Fournit l'implémentation pour les opérations qui obtiennent une valeur par index. Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode afin de spécifier le comportement dynamique pour les opérations d'indexation.</summary>
      <param name="binder">Fournit des informations sur l'opération.</param>
      <param name="indexes">Index utilisés pendant l'opération. Par exemple, pour l’opération <c>sampleObject[3]</c> en C# (<c>sampleObject(3)</c> en Visual Basic), où <c>sampleObject</c> est dérivé de la classe <see langword="DynamicObject" />, <c>index[0]</c> est égal à 3.</param>
      <param name="result">Résultat de l'opération d'indexation.</param>
      <returns>
        <see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d'exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime est levée.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
      <summary>Fournit l'implémentation pour les opérations qui obtiennent des valeurs de membre. Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode afin de spécifier le comportement dynamique pour certaines opérations telles que l'obtention d'une valeur pour une propriété.</summary>
      <param name="binder">Fournit des informations sur l'objet qui a appelé l'opération dynamique. La propriété <c>binder.Name</c> fournit le nom du membre sur lequel l’opération dynamique est exécutée. Par exemple, pour l’instruction <c>console.WriteLine(sampleObject.SampleProperty)</c>, où <c>sampleObject</c> est une instance de la classe dérivée de la classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> retourne " SampleProperty ". La propriété <c>binder.IgnoreCase</c> spécifie si le nom du membre respecte la casse.</param>
      <param name="result">Résultat de l'opération d'extraction. Par exemple, si la méthode est appelée pour une propriété, vous pouvez assigner la valeur de la propriété à <paramref name="result" />.</param>
      <returns>
        <see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d'exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime est levée.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
      <summary>Fournit l'implémentation pour les opérations qui appellent un objet. Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode afin de spécifier le comportement dynamique pour certaines opérations telles que l'appel d'un objet ou d'un délégué.</summary>
      <param name="binder">Fournit des informations sur l'opération d'appel.</param>
      <param name="args">Arguments passés à l'objet pendant l'opération d'appel. Par exemple, pour l’opération <c>sampleObject[100]</c>, où <c>sampleObject</c> est dérivé de la classe <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> est égal à 100.</param>
      <param name="result">Résultat de l'appel de l'objet.</param>
      <returns>
        <see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d'exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
      <summary>Fournit l'implémentation pour les opérations qui appellent un membre. Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode afin de spécifier le comportement dynamique pour certaines opérations telles que l'appel d'une méthode.</summary>
      <param name="binder">Fournit des informations sur l'opération dynamique. La propriété <c>binder.Name</c> fournit le nom du membre sur lequel l’opération dynamique est exécutée. Par exemple, pour l’instruction <c>sampleObject.SampleMethod(100)</c>, où <c>sampleObject</c> est une instance de la classe dérivée de la classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> retourne " SampleMethod ". La propriété <c>binder.IgnoreCase</c> spécifie si le nom du membre respecte la casse.</param>
      <param name="args">Arguments passés au membre d'objet pendant l'opération d'appel. Par exemple, pour l’instruction <c>sampleObject.SampleMethod(100)</c>, où <c>sampleObject</c> est dérivé de la classe <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> est égal à 100.</param>
      <param name="result">Résultat de l'appel du membre.</param>
      <returns>
        <see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d'exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
      <summary>Fournit l'implémentation pour les opérations qui définissent une valeur par index. Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode pour spécifier le comportement dynamique pour certaines opérations qui accèdent aux objets par un index spécifié.</summary>
      <param name="binder">Fournit des informations sur l'opération.</param>
      <param name="indexes">Index utilisés pendant l'opération. Par exemple, pour l’opération <c>sampleObject[3] = 10</c> en C# (<c>sampleObject(3) = 10</c> en Visual Basic), où <c>sampleObject</c> est dérivé de la classe <see cref="T:System.Dynamic.DynamicObject" />, <c>index[0]</c> est égal à 3.</param>
      <param name="value">Valeur à définir pour l'objet qui a l'index spécifié. Par exemple, pour l’opération <c>sampleObject[3] = 10</c> en C# (<c>sampleObject(3) = 10</c> en Visual Basic), où <c>sampleObject</c> est dérivé de la classe <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="value" /> est égal à 10.</param>
      <returns>
        <see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d'exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
      <summary>Fournit l'implémentation pour les opérations qui définissent des valeurs de membre. Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode afin de spécifier le comportement dynamique pour certaines opérations telles que la définition d'une valeur pour une propriété.</summary>
      <param name="binder">Fournit des informations sur l'objet qui a appelé l'opération dynamique. La propriété <c>binder.Name</c> fournit le nom du membre auquel la valeur est attribuée. Par exemple, pour l’instruction <c>sampleObject.SampleProperty = "Test"</c>, où <c>sampleObject</c> est une instance de la classe dérivée de la classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> retourne " SampleProperty ". La propriété <c>binder.IgnoreCase</c> spécifie si le nom du membre respecte la casse.</param>
      <param name="value">Valeur à affecter au membre. Par exemple, pour <c>sampleObject.SampleProperty = "Test"</c>, où <c>sampleObject</c> est une instance de la classe dérivée de la classe <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="value" /> est " Test ".</param>
      <returns>
        <see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d'exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
      <summary>Fournit l'implémentation pour les opérations unaires. Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode afin de spécifier le comportement dynamique pour certaines opérations telles que la négation, l'incrémentation ou la décrémentation.</summary>
      <param name="binder">Fournit des informations sur l'opération unaire. La propriété <c>binder.Operation</c> retourne un objet <see cref="T:System.Linq.Expressions.ExpressionType" />. Par exemple, pour l’instruction <c>negativeNumber = -number</c>, où <c>number</c> est dérivé de la classe <see langword="DynamicObject" />, <c>binder.Operation</c> retourne "Negate".</param>
      <param name="result">Résultat de l'opération unaire.</param>
      <returns>
        <see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d'exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
    </member>
    <member name="T:System.Dynamic.ExpandoObject">
      <summary>Représente un objet dont les membres peuvent être ajoutés et supprimés de manière dynamique au moment de l'exécution.</summary>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.#ctor">
      <summary>Initialise un nouveau <see langword="ExpandoObject" /> qui n'a pas de membres.</summary>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>
        <see cref="T:System.Collections.IEnumerator" /> qui peut être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="E:System.Dynamic.ExpandoObject.System#ComponentModel#INotifyPropertyChanged#PropertyChanged">
      <summary>Se produit en cas de modification d'une valeur de propriété.</summary>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Dynamic#IDynamicMetaObjectProvider#GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>Le MetaObject fourni est distribué aux méthodes virtuelles dynamiques. L'objet peut être encapsulé dans un autre MetaObject pour définir un comportement personnalisé pour des actions individuelles.</summary>
      <param name="parameter">Expression qui représente le MetaObject à distribuer aux méthodes virtuelles dynamiques.</param>
      <returns>Objet de type <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
    </member>
    <member name="T:System.Dynamic.GetIndexBinder">
      <summary>Représente l'opération d'obtention d'index dynamique au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Initialise une nouvelle instance de l'objet <see cref="T:System.Dynamic.GetIndexBinder" />.</summary>
      <param name="callInfo">Signature des arguments au niveau du site d’appel.</param>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération d'obtention d'index dynamique.</summary>
      <param name="target">Cible de l'opération d'obtention d'index dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération d'obtention d'index dynamique.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.GetIndexBinder.CallInfo">
      <summary>Obtient la signature des arguments au niveau du site d’appel.</summary>
      <returns>Signature des arguments au niveau du site d’appel.</returns>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.FallbackGetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Effectue la liaison de l'opération d'obtention d'index dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target">Cible de l'opération d'obtention d'index dynamique.</param>
      <param name="indexes">Arguments de l'opération d'obtention d'index dynamique.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.FallbackGetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>En cas de substitution dans la classe dérivée, exécute la liaison de l'opération d'obtention d'index dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target">Cible de l'opération d'obtention d'index dynamique.</param>
      <param name="indexes">Arguments de l'opération d'obtention d'index dynamique.</param>
      <param name="errorSuggestion">Résultat de liaison à utiliser si la liaison échoue, ou Null.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.GetIndexBinder.ReturnType">
      <summary>Type de résultat de l'opération.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.GetMemberBinder">
      <summary>Représente l'opération d'obtention de membre dynamique au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.#ctor(System.String,System.Boolean)">
      <summary>Initialise une nouvelle instance de l'objet <see cref="T:System.Dynamic.GetMemberBinder" />.</summary>
      <param name="name">Nom du membre à obtenir.</param>
      <param name="ignoreCase">True si la correspondance avec le nom doit ignorer la casse ; sinon, False.</param>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération d'obtention de membre dynamique.</summary>
      <param name="target">Cible de l'opération d'obtention de membre dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération d'obtention de membre dynamique.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.FallbackGetMember(System.Dynamic.DynamicMetaObject)">
      <summary>Effectue la liaison de l'opération d'obtention de membre dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target">Cible de l'opération d'obtention de membre dynamique.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.FallbackGetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>En cas de substitution dans la classe dérivée, exécute la liaison de l'opération d'obtention de membre dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target">Cible de l'opération d'obtention de membre dynamique.</param>
      <param name="errorSuggestion">Résultat de la liaison à utiliser si la liaison échoue, ou null.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.IgnoreCase">
      <summary>Obtient la valeur indiquant si la comparaison de chaîne doit ignorer la casse du nom du membre.</summary>
      <returns>
        <see langword="true" /> si la casse est ignorée ; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.Name">
      <summary>Obtient le nom du membre à obtenir.</summary>
      <returns>Nom du membre à obtenir.</returns>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.ReturnType">
      <summary>Type de résultat de l’opération.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de résultat de l’opération.</returns>
    </member>
    <member name="T:System.Dynamic.IDynamicMetaObjectProvider">
      <summary>Représente un objet dynamique, dont les opérations peuvent être liées pendant l'exécution.</summary>
    </member>
    <member name="M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>Retourne le <see cref="T:System.Dynamic.DynamicMetaObject" /> responsable de la liaison des opérations effectuées sur cet objet.</summary>
      <param name="parameter">Représentation de l'arborescence de l'expression de la valeur d'exécution.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> à lier à cet objet.</returns>
    </member>
    <member name="T:System.Dynamic.IInvokeOnGetBinder">
      <summary>Représente les informations relatives à une opération d'obtention de membre dynamique qui indique si l'obtention de membre doit appeler des propriétés lorsqu'elles exécutent l'opération d'extraction.</summary>
    </member>
    <member name="P:System.Dynamic.IInvokeOnGetBinder.InvokeOnGet">
      <summary>Obtient la valeur indiquant si cette opération d'obtention de membre doit appeler des propriétés lorsqu'elles exécutent l'opération d'extraction. La valeur par défaut lorsque cette interface n'est pas présente est True.</summary>
      <returns>
        <see langword="true" />Si cette opération d’extraction de membre doit appeler des propriétés lorsqu’elles exécutent l’opération d’extraction ; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Dynamic.InvokeBinder">
      <summary>Représente l'opération d'appel dynamique au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Initialise une nouvelle instance de l'objet <see cref="T:System.Dynamic.InvokeBinder" />.</summary>
      <param name="callInfo">Signature des arguments au niveau du site d’appel.</param>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Effectue la liaison de l’opération d’appel dynamique.</summary>
      <param name="target">Cible de l’opération d’appel dynamique.</param>
      <param name="args">Tableau d’arguments de l’opération d’appel dynamique.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeBinder.CallInfo">
      <summary>Obtient la signature des arguments au niveau du site d’appel.</summary>
      <returns>Signature des arguments au niveau du site d’appel.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Effectue la liaison de l'opération d'appel dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target">Cible de l’opération d’appel dynamique.</param>
      <param name="args">Arguments de l'opération d'appel dynamique.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Effectue la liaison de l'opération d'appel dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target">Cible de l’opération d’appel dynamique.</param>
      <param name="args">Arguments de l'opération d'appel dynamique.</param>
      <param name="errorSuggestion">Résultat de liaison à utiliser si la liaison échoue, ou Null.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeBinder.ReturnType">
      <summary>Type de résultat de l'opération.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.InvokeMemberBinder">
      <summary>Représente l'opération d'appel de membre dynamique au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.#ctor(System.String,System.Boolean,System.Dynamic.CallInfo)">
      <summary>Initialise une nouvelle instance de l'objet <see cref="T:System.Dynamic.InvokeMemberBinder" />.</summary>
      <param name="name">Nom du membre à appeler.</param>
      <param name="ignoreCase">True si la correspondance avec le nom doit ignorer la casse ; sinon, false.</param>
      <param name="callInfo">Signature des arguments au niveau du site d’appel.</param>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération d'appel de membre dynamique.</summary>
      <param name="target">Cible de l'opération d'appel de membre dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération d'appel de membre dynamique.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.CallInfo">
      <summary>Obtient la signature des arguments au niveau du site d’appel.</summary>
      <returns>Signature des arguments au niveau du site d’appel.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>En cas de substitution dans la classe dérivée, exécute la liaison de l'opération d'appel dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target">Cible de l’opération d’appel dynamique.</param>
      <param name="args">Arguments de l'opération d'appel dynamique.</param>
      <param name="errorSuggestion">Résultat de liaison à utiliser si la liaison échoue, ou Null.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvokeMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Effectue la liaison de l'opération d'appel de membre dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target">Cible de l'opération d'appel de membre dynamique.</param>
      <param name="args">Arguments de l'opération d'appel de membre dynamique.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvokeMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>En cas de substitution dans la classe dérivée, exécute la liaison de l'opération d'appel de membre dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target">Cible de l'opération d'appel de membre dynamique.</param>
      <param name="args">Arguments de l'opération d'appel de membre dynamique.</param>
      <param name="errorSuggestion">Résultat de liaison à utiliser si la liaison échoue, ou Null.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.IgnoreCase">
      <summary>Obtient la valeur indiquant si la comparaison de chaîne doit ignorer la casse du nom du membre.</summary>
      <returns>
        <see langword="true" />Si la casse est ignorée ; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.Name">
      <summary>Obtient le nom du membre à appeler.</summary>
      <returns>Nom du membre à appeler.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.ReturnType">
      <summary>Type de résultat de l'opération.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.SetIndexBinder">
      <summary>Représente l'opération de définition d'index dynamique au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Initialise une nouvelle instance de l'objet <see cref="T:System.Dynamic.SetIndexBinder" />.</summary>
      <param name="callInfo">Signature des arguments au niveau du site d’appel.</param>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération de définition d'index dynamique.</summary>
      <param name="target">Cible de l'opération de définition d'index dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération de définition d'index dynamique.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.SetIndexBinder.CallInfo">
      <summary>Obtient la signature des arguments au niveau du site d’appel.</summary>
      <returns>Signature des arguments au niveau du site d’appel.</returns>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.FallbackSetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Effectue la liaison de l'opération de définition d'index dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target">Cible de l'opération de définition d'index dynamique.</param>
      <param name="indexes">Arguments de l'opération de définition d'index dynamique.</param>
      <param name="value">Valeur à affecter à la collection.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.FallbackSetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>En cas de substitution dans la classe dérivée, exécute la liaison de l'opération de définition d'index dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target">Cible de l'opération de définition d'index dynamique.</param>
      <param name="indexes">Arguments de l'opération de définition d'index dynamique.</param>
      <param name="value">Valeur à affecter à la collection.</param>
      <param name="errorSuggestion">Résultat de liaison à utiliser si la liaison échoue, ou Null.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.SetIndexBinder.ReturnType">
      <summary>Type de résultat de l'opération.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.SetMemberBinder">
      <summary>Représente l’opération dynamique de définition de membre sur le site d’appel, en fournissant la sémantique de liaison et les détails de l’opération.</summary>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.#ctor(System.String,System.Boolean)">
      <summary>Initialise une nouvelle instance de l'objet <see cref="T:System.Dynamic.SetMemberBinder" />.</summary>
      <param name="name">Nom du membre à obtenir.</param>
      <param name="ignoreCase">True si la correspondance avec le nom doit ignorer la casse ; sinon, False.</param>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération de définition de membre dynamique.</summary>
      <param name="target">Cible de l'opération de définition de membre dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération de définition de membre dynamique.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.FallbackSetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Effectue la liaison de l'opération de définition de membre dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target">Cible de l'opération de définition de membre dynamique.</param>
      <param name="value">Valeur à affecter au membre.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.FallbackSetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Effectue la liaison de l'opération de définition de membre dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target">Cible de l'opération de définition de membre dynamique.</param>
      <param name="value">Valeur à affecter au membre.</param>
      <param name="errorSuggestion">Résultat de la liaison à utiliser si la liaison échoue, ou null.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.IgnoreCase">
      <summary>Obtient la valeur indiquant si la comparaison de chaîne doit ignorer la casse du nom du membre.</summary>
      <returns>
        <see langword="true" />Si la casse est ignorée ; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.Name">
      <summary>Obtient le nom du membre à obtenir.</summary>
      <returns>Nom du membre à obtenir.</returns>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.ReturnType">
      <summary>Type de résultat de l'opération.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.UnaryOperationBinder">
      <summary>Représente l'opération dynamique unaire au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.#ctor(System.Linq.Expressions.ExpressionType)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Dynamic.BinaryOperationBinder" />.</summary>
      <param name="operation">Type d'opération unaire.</param>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération unaire dynamique.</summary>
      <param name="target">Cible de l'opération dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération dynamique.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.FallbackUnaryOperation(System.Dynamic.DynamicMetaObject)">
      <summary>Effectue la liaison de l'opération dynamique unaire si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target">Cible de l'opération unaire dynamique.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.FallbackUnaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Effectue la liaison de l'opération dynamique unaire si l'objet dynamique cible ne peut pas être lié.</summary>
      <param name="target">Cible de l'opération unaire dynamique.</param>
      <param name="errorSuggestion">Résultat de la liaison en cas d'échec, ou null.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant les résultats de la liaison.</returns>
    </member>
    <member name="P:System.Dynamic.UnaryOperationBinder.Operation">
      <summary>Type d'opération unaire.</summary>
      <returns>Objet de <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente le type d'opération unaire.</returns>
    </member>
    <member name="P:System.Dynamic.UnaryOperationBinder.ReturnType">
      <summary>Type de résultat de l'opération.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Linq.Expressions.BinaryExpression">
      <summary>Représente une expression qui comporte un opérateur binaire.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud. Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
      <returns>Résultat de la visite de ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.CanReduce">
      <summary>Obtient une valeur qui indique si le nœud d’arborescence de l’expression peut être réduit.</summary>
      <returns>
        <see langword="true" />Si le nœud d’arborescence d’expression peut être réduit ; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Conversion">
      <summary>Obtient la fonction de conversion de type utilisée par une opération de fusion ou d’assignation composée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> qui représente une fonction de conversion de type.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLifted">
      <summary>Obtient une valeur qui indique si le nœud d’arborescence de l’expression représente un appel levé vers un opérateur.</summary>
      <returns>
        <see langword="true" /> si le nœud représente un appel levé ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull">
      <summary>Obtient une valeur qui indique si le nœud d’arborescence de l’expression représente un appel levé vers un opérateur dont le type de retour est levé vers un type nullable.</summary>
      <returns>
        <see langword="true" /> si le type de retour de l'opérateur est levé vers un type nullable ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Left">
      <summary>Obtient l’opérande gauche de l’opération binaire.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande gauche de l'opération binaire.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Method">
      <summary>Obtient la méthode d’implémentation pour l’opération binaire.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Reduce">
      <summary>Réduit le nœud d’expression binaire en une expression plus simple.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Right">
      <summary>Obtient l’opérande droit de l’opération binaire.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande droit de l'opération binaire.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="left">Propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> du résultat.</param>
      <param name="conversion">Propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> du résultat.</param>
      <param name="right">Propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.BlockExpression">
      <summary>Représente un bloc qui contient une séquence d'expressions où des variables peuvent être définies.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud. Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
      <returns>Résultat de la visite de ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Expressions">
      <summary>Obtient les expressions contenues dans ce bloc.</summary>
      <returns>Collection en lecture seule qui contient toutes les expressions contenues dans ce bloc.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression. Les nœuds d’extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Result">
      <summary>Obtient la dernière expression contenue dans ce bloc.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente la dernière expression contenue dans ce bloc.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.BlockExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="variables">Propriété <see cref="P:System.Linq.Expressions.BlockExpression.Variables" /> du résultat.</param>
      <param name="expressions">Propriété <see cref="P:System.Linq.Expressions.BlockExpression.Expressions" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n’est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Variables">
      <summary>Obtient les variables définies dans ce bloc.</summary>
      <returns>Collection en lecture seule qui contient toutes les variables définies dans ce bloc.</returns>
    </member>
    <member name="T:System.Linq.Expressions.CatchBlock">
      <summary>Représente une instruction catch dans un bloc try.</summary>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Body">
      <summary>Obtient le corps du bloc catch.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> représentant le corps du bloc catch.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Filter">
      <summary>Obtient le corps du filtre <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> représentant le corps du filtre <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Test">
      <summary>Obtient le type de <see cref="T:System.Exception" /> que ce gestionnaire intercepte.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de <see cref="T:System.Exception" /> que ce gestionnaire intercepte.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.ToString">
      <summary>Retourne une <see cref="T:System.String" /> qui représente l'<see cref="T:System.Object" /> actuel.</summary>
      <returns>
        <see cref="T:System.String" /> qui représente le <see cref="T:System.Object" /> actuel.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.Update(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="variable">Propriété <see cref="P:System.Linq.Expressions.CatchBlock.Variable" /> du résultat.</param>
      <param name="filter">Propriété <see cref="P:System.Linq.Expressions.CatchBlock.Filter" /> du résultat.</param>
      <param name="body">Propriété <see cref="P:System.Linq.Expressions.CatchBlock.Body" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Variable">
      <summary>Obtient une référence à l’objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConditionalExpression">
      <summary>Représente une expression qui comporte un opérateur conditionnel.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud. Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
      <returns>Résultat de la visite de ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfFalse">
      <summary>Obtient l'expression à exécuter si le test a la valeur <see langword="false" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'expression à exécuter si le test a la valeur <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfTrue">
      <summary>Obtient l'expression à exécuter si le test a la valeur <see langword="true" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'expression à exécuter si le test a la valeur <see langword="true" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression. Les nœuds d’extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Test">
      <summary>Obtient le test de l'opération conditionnelle.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le test de l'opération conditionnelle.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConditionalExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une expression qui est semblable à celle-ci, mais en utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="test">Propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> du résultat.</param>
      <param name="ifTrue">Propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> du résultat.</param>
      <param name="ifFalse">Propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n’est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConstantExpression">
      <summary>Représente une expression qui comporte une valeur de constante.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConstantExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud. Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
      <returns>Résultat de la visite de ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression. Les nœuds d’extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConstantExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Value">
      <summary>Obtient la valeur de l'expression constante.</summary>
      <returns>
        <see cref="T:System.Object" /> égal à la valeur de l'expression représentée.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DebugInfoExpression">
      <summary>Émet ou efface un point de séquence pour les informations de débogage. Cela permet au débogueur de mettre en surbrillance le code source correct lors du débogage.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DebugInfoExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud. Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
      <returns>Résultat de la visite de ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Document">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> qui représente le fichier source.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> qui représente le fichier source.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndColumn">
      <summary>Obtient la colonne de fin de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numéro de la colonne de fin du code qui a été utilisé pour générer l'expression incluse dans un wrapper.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndLine">
      <summary>Obtient la ligne de fin de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numéro de la ligne de fin du code qui a été utilisé pour générer l'expression incluse dans un wrapper.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.IsClear">
      <summary>Obtient la valeur qui indique si <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> a pour but d'effacer un point de séquence.</summary>
      <returns>
        <see langword="true" />Si le <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> est destiné à l’effacement d’un point <see langword="false" />de séquence ; sinon,.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartColumn">
      <summary>Obtient la colonne de début de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numéro de la colonne de début du code qui a été utilisé pour générer l'expression incluse dans un wrapper.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartLine">
      <summary>Obtient la ligne de début de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numéro de la ligne de début du code qui a été utilisé pour générer l'expression incluse dans un wrapper.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DebugInfoExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DefaultExpression">
      <summary>Représente la valeur par défaut d'un type ou une expression vide.</summary>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression. Les nœuds d’extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DefaultExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DynamicExpression">
      <summary>Représente une opération dynamique.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud. Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
      <returns>Résultat de la visite de ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Arguments">
      <summary>Obtient les arguments de l’opération dynamique.</summary>
      <returns>Collections en lecture seule contenant  les arguments de l’opération dynamique.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Binder">
      <summary>Obtient le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />, qui détermine le comportement au moment de l’exécution du site dynamique.</summary>
      <returns>
        <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />, qui détermine le comportement au moment de l’exécution du site dynamique.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.DelegateType">
      <summary>Type du délégué utilisé par l’objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type du délégué utilisé par l’objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="binder">Classeur de runtime de l'opération dynamique.</param>
      <param name="returnType">Type de résultat de l'expression dynamique.</param>
      <param name="arguments">Arguments de l’opération dynamique.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="binder">Classeur de runtime de l'opération dynamique.</param>
      <param name="returnType">Type de résultat de l'expression dynamique.</param>
      <param name="arg0">Premier argument de l’opération dynamique.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="binder">Classeur de runtime de l'opération dynamique.</param>
      <param name="returnType">Type de résultat de l'expression dynamique.</param>
      <param name="arg0">Premier argument de l’opération dynamique.</param>
      <param name="arg1">Deuxième argument de l'opération dynamique.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="binder">Classeur de runtime de l'opération dynamique.</param>
      <param name="returnType">Type de résultat de l'expression dynamique.</param>
      <param name="arg0">Premier argument de l’opération dynamique.</param>
      <param name="arg1">Deuxième argument de l'opération dynamique.</param>
      <param name="arg2">Troisième argument de l'opération dynamique.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="binder">Classeur de runtime de l'opération dynamique.</param>
      <param name="returnType">Type de résultat de l'expression dynamique.</param>
      <param name="arg0">Premier argument de l’opération dynamique.</param>
      <param name="arg1">Deuxième argument de l'opération dynamique.</param>
      <param name="arg2">Troisième argument de l'opération dynamique.</param>
      <param name="arg3">Quatrième argument de l’opération dynamique.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="binder">Classeur de runtime de l'opération dynamique.</param>
      <param name="returnType">Type de résultat de l'expression dynamique.</param>
      <param name="arguments">Arguments de l’opération dynamique.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="delegateType">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Classeur de runtime de l'opération dynamique.</param>
      <param name="arguments">Arguments de l’opération dynamique.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et un argument.</summary>
      <param name="delegateType">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Classeur de runtime de l'opération dynamique.</param>
      <param name="arg0">Argument de l'opération dynamique.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et deux arguments.</summary>
      <param name="delegateType">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Classeur de runtime de l'opération dynamique.</param>
      <param name="arg0">Premier argument de l’opération dynamique.</param>
      <param name="arg1">Deuxième argument de l'opération dynamique.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et trois arguments.</summary>
      <param name="delegateType">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Classeur de runtime de l'opération dynamique.</param>
      <param name="arg0">Premier argument de l’opération dynamique.</param>
      <param name="arg1">Deuxième argument de l'opération dynamique.</param>
      <param name="arg2">Troisième argument de l'opération dynamique.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et quatre arguments.</summary>
      <param name="delegateType">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Classeur de runtime de l'opération dynamique.</param>
      <param name="arg0">Premier argument de l’opération dynamique.</param>
      <param name="arg1">Deuxième argument de l'opération dynamique.</param>
      <param name="arg2">Troisième argument de l'opération dynamique.</param>
      <param name="arg3">Quatrième argument de l’opération dynamique.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="delegateType">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Classeur de runtime de l'opération dynamique.</param>
      <param name="arguments">Arguments de l’opération dynamique.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression. Les nœuds d’extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary>Retourne le nombre d’arguments du nœud d’arborescence d’expression. Vous ne devez pas utiliser ce membre. Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances.</summary>
      <returns>Retourne <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary>Retourne l’argument à l’index, en levant une exception si l’index est hors limites. Vous ne devez pas utiliser ce membre. Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances.</summary>
      <param name="index">Index de l’argument.</param>
      <returns>Retourne <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IDynamicExpression#CreateCallSite">
      <summary>Crée éventuellement CallSite et retourne CallSite pour le cache inline polymorphe de DynamicExpression. Vous ne devez pas utiliser ce membre. Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances.</summary>
      <returns>Retourne <see cref="T:System.Object" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IDynamicExpression#Rewrite(System.Linq.Expressions.Expression[])">
      <summary>Réécrit ce nœud en remplaçant les arguments de l’expression dynamique par les valeurs fournies. Le nombre de <paramref name="args" /> doit correspondre au nombre de l’expression actuelle. Vous ne devez pas utiliser ce type. Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances. Cette méthode d’assistance permet la réécriture de nœuds pour qu’ils soient indépendants de la classe d’implémentation spécifique dérivant de l’expression dynamique qui est utilisée sur le site d’appel.</summary>
      <param name="args">Arguments.</param>
      <returns>Retourne <see cref="T:System.Linq.Expressions.Expression" />, l’expression réécrite.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DynamicExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Compare la valeur envoyée au paramètre, <paramref name="arguments" />, à la propriété <see langword="Arguments" /> de l’instance actuelle de <see langword="DynamicExpression" />. Si les valeurs du paramètre et de la propriété sont égales, l’instance actuelle est retournée. Si elles ne sont pas égales, une nouvelle instance de <see langword="DynamicExpression" /> est retournée, qui est identique à l’instance actuelle, excepté que la propriété <see langword="Arguments" /> est définie sur la valeur du paramètre <paramref name="arguments" />.</summary>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n’est modifié, ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DynamicExpressionVisitor">
      <summary>Représente un visiteur ou module de réécriture pour les arborescences d'expression dynamiques.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpressionVisitor.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Linq.Expressions.DynamicExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpressionVisitor.VisitDynamic(System.Linq.Expressions.DynamicExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.DynamicExpression" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Retourne <see cref="T:System.Linq.Expressions.Expression" />, l'expression modifiée, si celle-ci ou toute sous-expression est modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ElementInit">
      <summary>Représente un initialiseur pour un élément unique d'une collection <see cref="T:System.Collections.IEnumerable" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.AddMethod">
      <summary>Obtient la méthode d’instance qui est utilisée pour ajouter un élément à une collection <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d’instance qui ajoute un élément à une collection.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.Arguments">
      <summary>Obtient la collection d’arguments passés à une méthode qui ajoute un élément à une collection <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>Une <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d’objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les arguments d’une méthode qui ajoute un élément à une collection.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary>Retourne le nombre d’arguments du nœud d’arborescence d’expression.  Vous ne devez pas utiliser ce membre.  Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances.</summary>
      <returns>retourne <see cref="T:System.Int32" /> ;</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary>Retourne l’argument à l’index, en levant une exception si l’index est hors limites.  Vous ne devez pas utiliser ce membre.  Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances.</summary>
      <param name="index">Index de l’argument.</param>
      <returns>retourne <see cref="T:System.Linq.Expressions.Expression" /> ;</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.ToString">
      <summary>Retourne une représentation textuelle d'un objet <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Représentation textuelle de l'objet <see cref="T:System.Linq.Expressions.ElementInit" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.Expression">
      <summary>Fournit la classe de base de laquelle sont dérivées les classes qui représentent des nœuds d'arborescence d'expression. Contient également des méthodes de fabrique <see langword="static" /> (<see langword="Shared" /> en Visual Basic) pour créer les divers types de nœuds. Il s'agit d'une classe <see langword="abstract" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor">
      <summary>Construit une nouvelle instance de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor(System.Linq.Expressions.ExpressionType,System.Type)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <param name="nodeType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> à définir comme type de nœud.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud. Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
      <returns>Résultat de la visite de ce nœud.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur d'addition n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui ne dispose pas d'une vérification de dépassement de capacité. La méthode d'implémentation peut être spécifiée.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est <see langword="null" /> et l’opérateur d’addition n’est pas défini pour les types <paramref name="left" />. et <paramref name="right" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur d'addition n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui dispose d'une vérification de dépassement de capacité. La méthode d'implémentation peut être spécifiée.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est <see langword="null" /> et l’opérateur d’addition n’est pas défini pour les types <paramref name="left" />. et <paramref name="right" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="AND" /> au niveau du bit.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.And" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de bits <see langword="AND" /> n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="AND" /> au niveau du bit. La méthode d'implémentation peut être spécifiée.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.And" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, pas <see langword="static" /> (<see langword="Shared" /> dans Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est <see langword="null" /> et l’opérateur <see langword="AND" /> au niveau du bit n’est pas défini pour les types <paramref name="left" />.et <paramref name="right" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="AND" /> conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur <see langword="true" />.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de bits <see langword="AND" /> n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.

ou -
<paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="AND" /> conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur true. La méthode d'implémentation peut être spécifiée.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, pas <see langword="static" /> (<see langword="Shared" /> dans Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est <see langword="null" /> et l’opérateur <see langword="AND" /> au niveau du bit n’est pas défini pour les types <paramref name="left" />.et <paramref name="right" />.

ou -
<paramref name="method" /> est <see langword="null" /> et <paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation AND au niveau du bit.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation AND au niveau du bit.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation AND au niveau du bit.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> pour accéder à un tableau multidimensionnel.</summary>
      <param name="array">Expression qui représente le tableau multidimensionnel.</param>
      <param name="indexes">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des expressions utilisées pour indexer le tableau.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> pour accéder à un tableau.</summary>
      <param name="array">Expression qui représente le tableau à indexer.</param>
      <param name="indexes">Tableau qui contient des expressions utilisées pour indexer le tableau.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente l'application d'un opérateur index de tableau à un tableau de rang supérieur à un.</summary>
      <param name="array">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> doit être égale.</param>
      <param name="indexes">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> ou <paramref name="indexes" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type ne représente pas un type de tableau.

ou -
Le rang de <paramref name="array" />.Type ne correspond pas au nombre d'éléments dans <paramref name="indexes" />.

ou -
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="indexes" /> ne représente pas le type <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'application d'un opérateur index de tableau à un tableau de rang un.</summary>
      <param name="array">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="index">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> ou <paramref name="index" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type ne représente pas un type de tableau.

ou -
<paramref name="array" />.Type représente un type de tableau dont le rang n'est pas 1.

ou -
<paramref name="index" />.Type ne représente pas le type <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente l'application d'un opérateur index de tableau à un tableau multidimensionnel.</summary>
      <param name="array">Tableau d'instances <see cref="T:System.Linq.Expressions.Expression" />, index pour l'opération d'index de tableau.</param>
      <param name="indexes">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> ou <paramref name="indexes" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type ne représente pas un type de tableau.

ou -
Le rang de <paramref name="array" />.Type ne correspond pas au nombre d'éléments dans <paramref name="indexes" />.

ou -
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="indexes" /> ne représente pas le type <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une expression permettant d'obtenir la longueur d'un tableau unidimensionnel.</summary>
      <param name="array">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> et la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> est égale à <paramref name="array" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type ne représente pas un type de tableau.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberAssignment" /> qui représente l'initialisation d'un champ ou d'une propriété.</summary>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberAssignment" /> dont <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égal à <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> et dont <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> ou <paramref name="expression" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.

ou -
La propriété représentée par <paramref name="member" /> n'a pas d'accesseur <see langword="set" />.

ou -
<paramref name="expression" />. Le type n’est pas assignable au type de champ ou à la propriété que <paramref name="member" /> représente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberAssignment" /> qui représente l'initialisation d'un membre à l'aide d'une méthode d'accesseur de propriété.</summary>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberAssignment" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> a pour valeur le <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont la propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> a la valeur <paramref name="expression" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> ou <paramref name="expression" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.

ou -
La propriété à laquelle <paramref name="propertyAccessor" /> accède n’a pas d’accesseur <see langword="set" />.

ou -
<paramref name="expression" />. Le type n’est pas assignable au type de champ ou à la propriété que <paramref name="member" /> représente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données et aucune variable.</summary>
      <param name="expressions">Expressions contenues dans le bloc.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</summary>
      <param name="variables">Variables contenues dans le bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</summary>
      <param name="variables">Variables contenues dans le bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient deux expressions et aucune variable.</summary>
      <param name="arg0">Première expression contenue dans le bloc.</param>
      <param name="arg1">Deuxième expression contenue dans le bloc.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient trois expressions et aucune variable.</summary>
      <param name="arg0">Première expression contenue dans le bloc.</param>
      <param name="arg1">Deuxième expression contenue dans le bloc.</param>
      <param name="arg2">Troisième expression contenue dans le bloc.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient quatre expressions et aucune variable.</summary>
      <param name="arg0">Première expression contenue dans le bloc.</param>
      <param name="arg1">Deuxième expression contenue dans le bloc.</param>
      <param name="arg2">Troisième expression contenue dans le bloc.</param>
      <param name="arg3">Quatrième expression contenue dans le bloc.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient deux expressions et aucune variable.</summary>
      <param name="arg0">Première expression contenue dans le bloc.</param>
      <param name="arg1">Deuxième expression contenue dans le bloc.</param>
      <param name="arg2">Troisième expression contenue dans le bloc.</param>
      <param name="arg3">Quatrième expression contenue dans le bloc.</param>
      <param name="arg4">Cinquième expression contenue dans le bloc.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données et aucune variable.</summary>
      <param name="expressions">Expressions contenues dans le bloc.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données, aucune variable et a un type de résultat spécifique.</summary>
      <param name="type">Type de résultat du bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</summary>
      <param name="type">Type de résultat du bloc.</param>
      <param name="variables">Variables contenues dans le bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</summary>
      <param name="type">Type de résultat du bloc.</param>
      <param name="variables">Variables contenues dans le bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données, aucune variable et a un type de résultat spécifique.</summary>
      <param name="type">Type de résultat du bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break. La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break avec le type spécifié. La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break avec le type spécifié.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui ne prend aucun argument.</summary>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel de méthode d'instance (passez <see langword="null" /> pour une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic)).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur <see langword="null" />.

ou -
<paramref name="instance" /> est <see langword="null" /> et <paramref name="method" /> représente une méthode d’instance.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />. Le type ne peut pas être affecté au type de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend des arguments.</summary>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> doit être égale (passez <see langword="null" /> pour une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic)).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> est <see langword="null" />.

ou -
<paramref name="instance" /> est <see langword="null" /> et <paramref name="method" /> représente une méthode d’instance.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />. Le type ne peut pas être affecté au type de la méthode représentée par <paramref name="method" />.

ou -
Le nombre d’éléments dans <paramref name="arguments" /> ne correspond pas au nombre de paramètres pour la méthode représentée par <paramref name="method" />.

ou -
Un ou plusieurs des éléments des <paramref name="arguments" /> n’est pas assignable au paramètre correspondant pour la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend deux arguments.</summary>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel d'instance. (Passez la valeur Null pour une méthode statique (méthode partagée en Visual Basic.)</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode cible.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend trois arguments.</summary>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel d'instance. (Passez la valeur Null pour une méthode statique (méthode partagée en Visual Basic.)</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode cible.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend des arguments.</summary>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel de méthode d'instance (passez <see langword="null" /> pour une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic)).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> est <see langword="null" />.

ou -
<paramref name="instance" /> est <see langword="null" /> et <paramref name="method" /> représente une méthode d’instance.

ou -
<paramref name="arguments" /> n’est pas <see langword="null" /> et un ou plusieurs de ses éléments sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />. Le type ne peut pas être affecté au type de la méthode représentée par <paramref name="method" />.

ou -
Le nombre d’éléments dans <paramref name="arguments" /> ne correspond pas au nombre de paramètres pour la méthode représentée par <paramref name="method" />.

ou -
Un ou plusieurs des éléments des <paramref name="arguments" /> n’est pas assignable au paramètre correspondant pour la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode en appelant la méthode de fabrique appropriée.</summary>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> dont la valeur de propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> fera l'objet d'une recherche de méthode spécifique.</param>
      <param name="methodName">Nom de la méthode.</param>
      <param name="typeArguments">Tableau d'objets <see cref="T:System.Type" /> spécifiant les paramètres de type de la méthode générique. Cet argument doit être null lorsque methodName spécifie une méthode non générique.</param>
      <param name="arguments">Tableau d’objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments de la méthode.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, dont la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> est égale à <paramref name="instance" />, dont <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> a pour valeur <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'instance spécifiée, et dont <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> a pour valeur les arguments spécifiés.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instance" /> ou <paramref name="methodName" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Aucune méthode appelée <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> n'est trouvée dans <paramref name="instance" />.Type ou ses types de base.

ou -
Plusieurs méthodes appelées <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> sont trouvées dans <paramref name="instance" />.Type ou ses types de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique (méthode partagée en Visual Basic).</summary>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode cible.</param>
      <param name="arguments">Collection de <see cref="T:System.Linq.Expressions.Expression" /> qui représente les arguments de l'appel.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic) qui prend un seul argument.</summary>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant deux arguments.</summary>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant trois arguments.</summary>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant quatre arguments.</summary>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</param>
      <param name="arg3">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le quatrième argument.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant cinq arguments.</summary>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</param>
      <param name="arg3">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le quatrième argument.</param>
      <param name="arg4">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic) comportant des arguments.</summary>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic) à laquelle la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Le nombre d’éléments dans <paramref name="arguments" /> ne correspond pas au nombre de paramètres pour la méthode représentée par <paramref name="method" />.

ou -
Un ou plusieurs des éléments des <paramref name="arguments" /> n’est pas assignable au paramètre correspondant pour la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic) en appelant la méthode de fabrique appropriée.</summary>
      <param name="type">Type contenant la méthode <see langword="static" /> (<see langword="Shared" /> dans Visual Basic) spécifiée.</param>
      <param name="methodName">Nom de la méthode.</param>
      <param name="typeArguments">Tableau d'objets <see cref="T:System.Type" /> spécifiant les paramètres de type de la méthode générique. Cet argument doit être null lorsque methodName spécifie une méthode non générique.</param>
      <param name="arguments">Tableau d’objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments de la méthode.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, dont la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> a pour valeur <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode <see langword="static" /> (<see langword="Shared" /> en Visual Basic) spécifiée, et dont la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> a pour valeur les arguments spécifiés.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="methodName" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Aucune méthode appelée <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> n'est trouvée dans <paramref name="type" /> ou ses types de base.

ou -
Plusieurs méthodes appelées <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> sont trouvées dans <paramref name="type" /> ou ses types de base.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.CanReduce">
      <summary>Indique que le nœud peut être réduit à un nœud plus simple. Si la valeur retournée est true, Reduce() peut être appelé pour produire la forme réduite.</summary>
      <returns>
        <see langword="true" /> si le nœud peut être réduit ; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec une référence à l'objet <see cref="T:System.Exception" /> intercepté pour une utilisation dans le corps du gestionnaire.</summary>
      <param name="variable">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</param>
      <param name="body">Corps de l'instruction Catch.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec un filtre <see cref="T:System.Exception" /> et une référence à l'objet <see cref="T:System.Exception" /> intercepté.</summary>
      <param name="variable">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</param>
      <param name="body">Corps de l'instruction Catch.</param>
      <param name="filter">Corps du filtre <see cref="T:System.Exception" />.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch.</summary>
      <param name="type">Propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que <see cref="T:System.Linq.Expressions.CatchBlock" /> traitera.</param>
      <param name="body">Corps de l'instruction Catch.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec un filtre <see cref="T:System.Exception" />, sans référence à l'objet <see cref="T:System.Exception" /> intercepté.</summary>
      <param name="type">Propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que <see cref="T:System.Linq.Expressions.CatchBlock" /> traitera.</param>
      <param name="body">Corps de l'instruction Catch.</param>
      <param name="filter">Corps du filtre <see cref="T:System.Exception" />.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> pour la suppression d'un point de séquence.</summary>
      <param name="document">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> qui représente le fichier source.</param>
      <returns>Instance de <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> pour le nettoyage d’un point de séquence.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de fusion.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> ne représente pas un type référence ou un type valeur Nullable.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type ne peut pas être converti en <paramref name="right" />.Type, et inversement.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de fusion, à partir d'une fonction de conversion.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type ne peut pas être converti en <paramref name="right" />.Type, et inversement.

ou -
<paramref name="conversion" /> n'est pas <see langword="null" /> et <paramref name="conversion" />.Type est un type délégué qui ne prend pas exactement un argument.</exception>
      <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> ne représente pas un type référence ou un type valeur Nullable.

ou -
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> représente un type qui ne peut pas être assigné au type de paramètre du type délégué <paramref name="conversion" />.Type.

ou -
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="right" /> n'est pas égale au type de retour du type délégué <paramref name="conversion" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente une instruction conditionnelle.</summary>
      <param name="test">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</param>
      <param name="ifTrue">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</param>
      <param name="ifFalse">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="test" /> ou <paramref name="ifTrue" /> ou <paramref name="ifFalse" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="test" />.Type n'est pas <see cref="T:System.Boolean" />.

ou -
<paramref name="ifTrue" />.Type n'est pas égal à <paramref name="ifFalse" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente une instruction conditionnelle.</summary>
      <param name="test">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</param>
      <param name="ifTrue">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</param>
      <param name="ifFalse">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> doit être égale.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> a la valeur spécifiée.</summary>
      <param name="value">
        <see cref="T:System.Object" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> et dont la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> a la valeur spécifiée.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont les propriétés <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</summary>
      <param name="value">
        <see cref="T:System.Object" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> n'est pas <see langword="null" /> et <paramref name="type" /> ne peut pas être assigné à partir du type dynamique de <paramref name="value" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Continue.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Continue avec le type spécifié.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion de type.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion pour laquelle la méthode d'implémentation est spécifiée.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.

ou -
<paramref name="expression" />.Type ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.

ou -
Le type de retour de la méthode représentée par <paramref name="method" /> ne peut pas être assigné à <paramref name="type" />.

ou -
<paramref name="expression" />.Type ou <paramref name="type" /> est un type valeur Nullable et le type valeur autre que Nullable correspondant n'est pas égal au type d'argument ou au type de retour, respectivement, de la méthode représentée par <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Plusieurs méthodes correspondant à la description <paramref name="method" /> ont été trouvées.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion qui lève une exception en cas de dépassement du type cible.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion qui lève une exception en cas de dépassement du type cible et pour lequel la méthode d'implémentation est spécifiée.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.

ou -
<paramref name="expression" />.Type ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.

ou -
Le type de retour de la méthode représentée par <paramref name="method" /> ne peut pas être assigné à <paramref name="type" />.

ou -
<paramref name="expression" />.Type ou <paramref name="type" /> est un type valeur Nullable et le type valeur autre que Nullable correspondant n'est pas égal au type d'argument ou au type de retour, respectivement, de la méthode représentée par <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Plusieurs méthodes correspondant à la description <paramref name="method" /> ont été trouvées.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> avec l'étendue spécifiée.</summary>
      <param name="document">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> qui représente le fichier source.</param>
      <param name="startLine">Ligne de début de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Doit être supérieure à 0.</param>
      <param name="startColumn">Colonne de début de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Doit être supérieure à 0.</param>
      <param name="endLine">Ligne de fin de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Doit être supérieure ou égale à la ligne de début.</param>
      <param name="endColumn">Colonne de fin de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Si la ligne de fin est la même que la ligne de début, elle doit être supérieure ou égale à la colonne de début. Dans tous les cas, elle doit être supérieure à 0.</param>
      <returns>Instance de <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente la décrémentation de l'expression par 1.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à décrémenter.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression décrémentée.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente la décrémentation de l'expression par 1.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à décrémenter.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression décrémentée.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Default(System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DefaultExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> a le type spécifié.</summary>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DefaultExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> et dont la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> a la valeur spécifiée.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de division arithmétique.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à affecter à la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à affecter à la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de division n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de division arithmétique. La méthode d'implémentation peut être spécifiée.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est <see langword="null" /> et l’opérateur de division n’est pas défini pour les types <paramref name="left" />. et <paramref name="right" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de division qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de division qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de division qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="binder">Classeur de runtime de l'opération dynamique.</param>
      <param name="returnType">Type de résultat de l'expression dynamique.</param>
      <param name="arguments">Arguments de l’opération dynamique.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="binder">Classeur de runtime de l'opération dynamique.</param>
      <param name="returnType">Type de résultat de l'expression dynamique.</param>
      <param name="arg0">Premier argument de l’opération dynamique.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="binder">Classeur de runtime de l'opération dynamique.</param>
      <param name="returnType">Type de résultat de l'expression dynamique.</param>
      <param name="arg0">Premier argument de l’opération dynamique.</param>
      <param name="arg1">Deuxième argument de l'opération dynamique.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="binder">Classeur de runtime de l'opération dynamique.</param>
      <param name="returnType">Type de résultat de l'expression dynamique.</param>
      <param name="arg0">Premier argument de l’opération dynamique.</param>
      <param name="arg1">Deuxième argument de l'opération dynamique.</param>
      <param name="arg2">Troisième argument de l'opération dynamique.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="binder">Classeur de runtime de l'opération dynamique.</param>
      <param name="returnType">Type de résultat de l'expression dynamique.</param>
      <param name="arg0">Premier argument de l’opération dynamique.</param>
      <param name="arg1">Deuxième argument de l'opération dynamique.</param>
      <param name="arg2">Troisième argument de l'opération dynamique.</param>
      <param name="arg3">Quatrième argument de l’opération dynamique.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="binder">Classeur de runtime de l'opération dynamique.</param>
      <param name="returnType">Type de résultat de l'expression dynamique.</param>
      <param name="arguments">Arguments de l’opération dynamique.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ElementInit" />, à partir d'un <see cref="T:System.Collections.Generic.IEnumerable`1" /> comme deuxième argument.</summary>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> doit être égale.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.ElementInit" /> dont les propriétés <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> et <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> ou <paramref name="arguments" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La méthode représentée par <paramref name="addMethod" /> n’est pas nommée « Add » (non-respect de la casse).

ou -
La méthode représentée par <paramref name="addMethod" /> n’est pas une méthode d’instance.

ou -
Le nombre d’éléments que contient <paramref name="arguments" /> ne correspond pas au nombre de paramètres de la méthode représentée par <paramref name="addMethod" />.

ou -
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un ou plusieurs éléments de <paramref name="arguments" /> n’est pas affectable au type du paramètre correspondant de la méthode représentée par <paramref name="addMethod" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ElementInit" />, à partir d'un tableau de valeurs comme deuxième argument.</summary>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> doit être égale.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.ElementInit" /> dont les propriétés <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> et <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> ou <paramref name="arguments" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La méthode représentée par addMethod n'est pas nommée "Add" (non respect de la casse).

ou -
La méthode représentée par addMethod n'est pas une méthode d'instance.

ou -
arguments ne contient pas le même nombre d'éléments que le nombre de paramètres pour la méthode représentée par addMethod.

ou -
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un ou plusieurs éléments de <paramref name="arguments" /> n’est pas affectable au type du paramètre correspondant de la méthode représentée par <paramref name="addMethod" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Empty">
      <summary>Crée une expression vide qui a le type <see cref="T:System.Void" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DefaultExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> et la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> est égale à <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'égalité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur d'égalité n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'égalité. La méthode d'implémentation peut être spécifiée.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull">
        <see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est <see langword="null" /> et l'opérateur d'égalité n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d’assignation <see langword="XOR" /> au niveau du bit, en utilisant <c>op_ExclusiveOr</c> pour les types définis par l’utilisateur.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur <see langword="XOR" /> n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d’assignation <see langword="XOR" /> au niveau du bit, en utilisant <c>op_ExclusiveOr</c> pour les types définis par l’utilisateur. La méthode d'implémentation peut être spécifiée.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est <see langword="null" /> et l’opérateur <see langword="XOR" /> n’est pas défini pour les types <paramref name="left" />.et <paramref name="right" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d’assignation XOR au niveau du bit, en utilisant <c>op_ExclusiveOr</c> pour les types définis par l’utilisateur.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d’assignation XOR au niveau du bit, en utilisant <c>op_ExclusiveOr</c> pour les types définis par l’utilisateur.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d’assignation XOR au niveau du bit, en utilisant <c>op_ExclusiveOr</c> pour les types définis par l’utilisateur.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> doit être égale. Pour <see langword="static" /> (<see langword="Shared" /> en Visual Basic), <paramref name="expression" /> doit être <see langword="null" />.</param>
      <param name="field">
        <see cref="T:System.Reflection.FieldInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> et <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="field" /> a la valeur <see langword="null" />.

ou -
Le champ représenté par <paramref name="field" /> n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) et <paramref name="expression" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type ne peut pas être assigné au type de déclaration du champ représenté par <paramref name="field" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ à partir du nom du champ.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> dont <see cref="P:System.Linq.Expressions.Expression.Type" /> contient un champ nommé <paramref name="fieldName" />. Cette valeur peut être null pour les champs statiques.</param>
      <param name="fieldName">Nom d'un champ auquel accéder.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> a pour valeur <paramref name="expression" /> et dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> a pour valeur le <see cref="T:System.Reflection.FieldInfo" /> qui représente le champ désigné par <paramref name="fieldName" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="fieldName" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Aucun champ nommé <paramref name="fieldName" /> n'est défini dans <paramref name="expression" />.Type ou ses types de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ.</summary>
      <param name="expression">Objet conteneur du champ. Cette valeur peut être null pour les champs statiques.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> qui contient le champ.</param>
      <param name="fieldName">Champ auquel accéder.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.MemberExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])">
      <summary>Crée un objet <see cref="T:System.Type" /> qui représente un type délégué <c>System.Action</c> générique ayant des arguments de type spécifiques.</summary>
      <param name="typeArgs">Tableau contenant jusqu’à seize objets <see cref="T:System.Type" /> qui spécifient les arguments de type pour le type délégué <see langword="System.Action" />.</param>
      <returns>Type d’un délégué <c>System.Action</c> qui a les arguments de type spécifiés.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contient plus de seize éléments.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArgs" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])">
      <summary>Obtient un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type délégué <c>System.Func</c> ou <c>System.Action</c> générique ayant des arguments de type spécifiques.</summary>
      <param name="typeArgs">Arguments de type du délégué.</param>
      <returns>Type de délégué.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])">
      <summary>Crée un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type délégué <c>System.Func</c> générique ayant des arguments de type spécifiques. Le dernier argument de type spécifie le type de retour du délégué créé.</summary>
      <param name="typeArgs">Tableau contenant entre un et dix-sept objets <see cref="T:System.Type" /> qui spécifient les arguments de type pour le type délégué <see langword="System.Func" />.</param>
      <returns>Type d’un délégué <c>System.Func</c> qui a les arguments de type spécifiés.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contient moins d'un élément ou plus de dix sept éléments.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArgs" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction GoTo.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à la valeur spécifiée et une valeur Null à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction GoTo. La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction GoTo avec le type spécifié. La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction GoTo avec le type spécifié.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à la valeur spécifiée, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et une valeur Null à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « supérieur à ».</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur "supérieur à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « supérieur à ». La méthode d'implémentation peut être spécifiée.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull">
        <see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est <see langword="null" /> et l'opérateur "supérieur à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « supérieur ou égal à ».</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur "supérieur ou égal à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « supérieur ou égal à ».</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull">
        <see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est <see langword="null" /> et l’opérateur “supérieur à ou égal à” n'est pas défini pour les types <paramref name="left" />et <paramref name="right" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente un bloc conditionnel avec une instruction <see langword="if" />.</summary>
      <param name="test">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</param>
      <param name="ifTrue">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> ont les valeurs spécifiées. Propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ayant pour valeur l'expression par défaut et dont le type du <see cref="T:System.Linq.Expressions.ConditionalExpression" /> résultant retourné par cette méthode est <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente un bloc conditionnel avec des instructions <see langword="if" /> et <see langword="else" />.</summary>
      <param name="test">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</param>
      <param name="ifTrue">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</param>
      <param name="ifFalse">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ont les valeurs spécifiées. Le type du <see cref="T:System.Linq.Expressions.ConditionalExpression" /> résultant retourné par cette méthode est <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'incrémentation de la valeur de l'expression par 1.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à incrémenter.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression incrémentée.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'incrémentation de l'expression par 1.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à incrémenter.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression incrémentée.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.InvocationExpression" /> qui applique un délégué ou une expression lambda à une liste d'expressions d'arguments.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'expression lambda ou le délégué auquel appliquer.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments auxquels le délégué ou l'expression lambda sont appliqués.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.InvocationExpression" /> qui applique le délégué ou l’expression lambda spécifiés aux arguments fournis.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type ne représente pas un type délégué ou un <see cref="T:System.Linq.Expressions.Expression`1" />.

ou -
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant du délégué représenté par <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour le délégué représenté par <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.InvocationExpression" /> qui applique un délégué ou une expression lambda à une liste d'expressions d'arguments.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le délégué ou l’expression lambda à appliquer.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les arguments auxquels le délégué ou l'expression lambda est appliquée.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.InvocationExpression" /> qui applique le délégué ou l’expression lambda spécifiés aux arguments fournis.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type ne représente pas un type délégué ou un <see cref="T:System.Linq.Expressions.Expression`1" />.

ou -
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant du délégué représenté par <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour le délégué représenté par <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)">
      <summary>Indique si l'expression prend la valeur false.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</param>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Indique si l'expression prend la valeur false.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)">
      <summary>Indique si l'expression prend la valeur true.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</param>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Indique si l'expression prend la valeur true.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LabelTarget" /> qui représente une étiquette avec le type void et aucun nom.</summary>
      <returns>Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LabelExpression" /> qui représente une étiquette sans valeur par défaut.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.LabelExpression" /> sera associé.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelExpression" /> sans valeur par défaut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LabelExpression" /> qui représente une étiquette avec la valeur par défaut donnée.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.LabelExpression" /> sera associé.</param>
      <param name="defaultValue">Valeur de ce <see cref="T:System.Linq.Expressions.LabelExpression" /> lorsque l'étiquette est atteinte via un flux de contrôle normal.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelExpression" /> avec la valeur par défaut donnée.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.String)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LabelTarget" /> représentant une étiquette avec le type void et le nom donné.</summary>
      <param name="name">Nom de l'étiquette.</param>
      <returns>Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LabelTarget" /> représentant une étiquette avec le type donné.</summary>
      <param name="type">Type de valeur passée lors de l'accès à l'étiquette.</param>
      <returns>Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LabelTarget" /> qui représente une étiquette avec le type et le nom donnés.</summary>
      <param name="type">Type de valeur passée lors de l'accès à l'étiquette.</param>
      <param name="name">Nom de l'étiquette.</param>
      <returns>Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type de délégué à partir du corps d’expression, un paramètre qui indique si l’optimisation d’appel tail est appliquée et une collection énumérable d’expressions de paramètre. Peut être utilisé lorsque le type délégué n'est pas connu au moment de la compilation.</summary>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type de délégué à partir du corps d’expression, un paramètre qui indique si l’optimisation d’appel tail est appliquée et un tableau d’expressions de paramètre. Peut être utilisé lorsque le type délégué n'est pas connu au moment de la compilation.</summary>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters">Tableau qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type de délégué à partir du corps d’expression et une collection énumérable d’expressions de paramètre. Peut être utilisé lorsque le type délégué n'est pas connu au moment de la compilation.</summary>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type de délégué à partir du corps d’expression et un tableau d’expressions de paramètre. Peut être utilisé lorsque le type délégué n'est pas connu au moment de la compilation.</summary>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> a la valeur <see langword="null" />.

ou -
Un ou plusieurs éléments de <paramref name="parameters" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="parameters" /> contient plus de seize éléments.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type de délégué à partir du corps d’expression, le nom de l’expression lambda, un paramètre qui indique si l’optimisation d’appel tail est appliquée et une collection énumérable d’expressions de paramètre. Peut être utilisé lorsque le type délégué n'est pas connu au moment de la compilation.</summary>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="name">Nom de l'expression lambda. Utilisé pour l'émission des informations de débogage.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type de délégué à partir du corps d’expression, le nom de l’expression lambda et une collection énumérable d’expressions de paramètre. Peut être utilisé lorsque le type délégué n'est pas connu au moment de la compilation.</summary>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="name">Nom de l'expression lambda. Utilisé pour l'émission des informations de débogage.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> où le type de délégué est connu au moment de la compilation, avec un paramètre qui indique si l’optimisation d’appel tail est appliquée et une collection énumérable d’expressions de paramètre.</summary>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente la signature du délégué de l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> où le type de délégué est connu au moment de la compilation, avec un paramètre qui indique si l’optimisation d’appel tail est appliquée et un tableau d’expressions de paramètre.</summary>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente la signature du délégué de l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters">Tableau qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> où le type de délégué est connu au moment de la compilation, avec une collection énumérable d’expressions de paramètre.</summary>
      <param name="delegateType">
        <see cref="T:System.Type" /> qui représente une signature de délégué pour l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>Objet qui représente une expression lambda dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="delegateType" /> ou <paramref name="body" /> est <see langword="null" />.

ou -
Un ou plusieurs éléments dans <paramref name="parameters" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> ne représente pas un type délégué.

ou -
<paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour du type délégué représenté par <paramref name="delegateType" />.

ou -
<paramref name="parameters" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour le type délégué représenté par <paramref name="delegateType" />.

ou -
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant du type délégué représenté par <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> où le type de délégué est connu au moment de la compilation, avec un tableau d’expressions de paramètre.</summary>
      <param name="delegateType">
        <see cref="T:System.Type" /> qui représente une signature de délégué pour l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>Objet qui représente une expression lambda dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="delegateType" /> ou <paramref name="body" /> est <see langword="null" />.

ou -
Un ou plusieurs éléments dans <paramref name="parameters" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> ne représente pas un type délégué.

ou -
<paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour du type délégué représenté par <paramref name="delegateType" />.

ou -
<paramref name="parameters" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour le type délégué représenté par <paramref name="delegateType" />.

ou -
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant du type délégué représenté par <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> où le type de délégué est connu au moment de la compilation, avec le nom de l’expression lambda, un paramètre qui indique si l’optimisation d’appel tail est appliquée et une collection énumérable d’expressions de paramètre.</summary>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente la signature du délégué de l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="name">Nom de l'expression lambda. Utilisé pour l'émission des informations de débogage.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> où le type de délégué est connu au moment de la compilation, avec le nom de l’expression lambda et une collection énumérable d’expressions de paramètre.</summary>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente la signature du délégué de l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="name">Nom de l'expression lambda. Utilisé pour l'émission des informations de débogage.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> où le type de délégué est connu au moment de la compilation, avec un paramètre qui indique si l’optimisation d’appel tail est appliquée et une collection énumérable d’expressions de paramètre.</summary>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Type de délégué.</typeparam>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> où le type de délégué est connu au moment de la compilation, avec un paramètre qui indique si l’optimisation d’appel tail est appliquée et un tableau d’expressions de paramètre.</summary>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters">Tableau qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Type de délégué.</typeparam>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> où le type de délégué est connu au moment de la compilation, avec une collection énumérable d’expressions de paramètre.</summary>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Type délégué.</typeparam>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> est <see langword="null" />.

ou -
Un ou plusieurs éléments dans <paramref name="parameters" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> n'est pas un type délégué.

ou -
<paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour de <paramref name="TDelegate" />.

ou -
<paramref name="parameters" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour <paramref name="TDelegate" />.

ou -
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant de <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> où le type de délégué est connu au moment de la compilation, avec un tableau d’expressions de paramètre.</summary>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Type délégué.</typeparam>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> a la valeur <see langword="null" />.

ou -
Un ou plusieurs éléments dans <paramref name="parameters" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> n'est pas un type délégué.

ou -
<paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour de <paramref name="TDelegate" />.

ou -
<paramref name="parameters" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour <paramref name="TDelegate" />.

ou -
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant de <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> où le type de délégué est connu au moment de la compilation, avec le nom de l’expression lambda, un paramètre qui indique si l’optimisation d’appel tail est appliquée et une collection énumérable d’expressions de paramètre.</summary>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="name">Nom de l'expression lambda. Utilisé pour la génération des informations de débogage.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Type de délégué.</typeparam>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> où le type de délégué est connu au moment de la compilation, avec le nom de l’expression lambda et une collection énumérable d’expressions de paramètre.</summary>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="name">Nom de l'expression lambda. Utilisé pour la génération des informations de débogage.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Type de délégué.</typeparam>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la gauche.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de décalage vers la gauche n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la gauche.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est <see langword="null" /> et l'opérateur de décalage vers la gauche n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la gauche au niveau du bit.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la gauche au niveau du bit.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la gauche au niveau du bit.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur à ».</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur "inférieur à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur à ».</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull">
        <see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> a la valeur <see langword="null" /> et l’opérateur « inférieur à » n’est pas défini pour <paramref name="left" />.Type. et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur ou égal à ».</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur "inférieur ou égal à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur ou égal à ».</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull">
        <see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est <see langword="null" /> et l'opérateur "inférieur ou égal à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberListBinding" /> dans lequel le membre est un champ ou une propriété.</summary>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> qui représente un champ ou une propriété auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> a la valeur <see langword="null" />.

ou -
Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.

ou -
Le <see cref="P:System.Reflection.FieldInfo.FieldType" /> ou <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> du champ ou de la propriété que <paramref name="member" /> représente n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberListBinding" /> dans lequel le membre est un champ ou une propriété.</summary>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> qui représente un champ ou une propriété auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> est <see langword="null" />.

ou -
Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.

ou -
Le <see cref="P:System.Reflection.FieldInfo.FieldType" /> ou <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> du champ ou de la propriété que <paramref name="member" /> représente n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crée un objet <see cref="T:System.Linq.Expressions.MemberListBinding" /> basé sur une méthode d’accesseur de propriété spécifiée.</summary>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> a pour valeur le <see cref="T:System.Reflection.MemberInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> est rempli avec les éléments de <paramref name="initializers" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> est <see langword="null" />.

ou -
Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.

ou -
Le <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" /> n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crée un objet <see cref="T:System.Linq.Expressions.MemberListBinding" /> basé sur une méthode d'accesseur de propriété spécifiée.</summary>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> a pour valeur le <see cref="T:System.Reflection.MemberInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> est rempli avec les éléments de <paramref name="initializers" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> a la valeur <see langword="null" />.

ou -
Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.

ou -
Le <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" /> n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise des objets <see cref="T:System.Linq.Expressions.ElementInit" /> spécifiés pour initialiser une collection.</summary>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> est <see langword="null" />.

ou -
Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n’implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode nommée « Add » pour ajouter des éléments à une collection.</summary>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> est <see langword="null" />.

ou -
Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n’implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">Il n’existe aucune méthode d’instance nommée « Add » (non-respect de la casse) déclaré dans <paramref name="newExpression" />.Type ou son type de base.

ou -
La méthode add sur <paramref name="newExpression" />.Type ou son type de base ne prend pas exactement un argument.

ou -
Le type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> du premier élément de <paramref name="initializers" /> n’est pas affectable au type d’argument de la méthode add sur <paramref name="newExpression" />.Type ou son type de base.

ou -
Plusieurs méthodes compatibles avec des arguments nommées « Add » (non-respect de la casse) existent sur <paramref name="newExpression" />.Type et/ou son type de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise des objets <see cref="T:System.Linq.Expressions.ElementInit" /> spécifiés pour initialiser une collection.</summary>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> est <see langword="null" />.

ou -
Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n’implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode nommée « Add » pour ajouter des éléments à une collection.</summary>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> est <see langword="null" />.

ou -
Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n’implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">Il n’existe aucune méthode d’instance nommée « Add » (non-respect de la casse) déclaré dans <paramref name="newExpression" />.Type ou son type de base.

ou -
La méthode add sur <paramref name="newExpression" />.Type ou son type de base ne prend pas exactement un argument.

ou -
Le type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> du premier élément de <paramref name="initializers" /> n’est pas affectable au type d’argument de la méthode add sur <paramref name="newExpression" />.Type ou son type de base.

ou -
Plusieurs méthodes compatibles avec des arguments nommées « Add » (non-respect de la casse) existent sur <paramref name="newExpression" />.Type et/ou son type de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode spécifiée pour ajouter des éléments à une collection.</summary>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'instance nommée "Add" (non respect de la casse), qui ajoute un élément à une collection.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> est <see langword="null" />.

ou -
Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n’implémente pas <see cref="T:System.Collections.IEnumerable" />.

ou -
<paramref name="addMethod" /> n'est pas <see langword="null" /> et ne représente pas une méthode d'instance nommée "Add" (non respect de la casse) qui prend exactement un argument.

ou -
<paramref name="addMethod" /> n'est pas <see langword="null" /> et le type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="initializers" /> ne peut pas être assigné au type d'argument de la méthode que <paramref name="addMethod" /> représente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> est <see langword="null" /> et il n'existe aucune méthode d'instance nommée "Add" prenant un argument compatible avec le type sur <paramref name="newExpression" />.Type ou son type de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode spécifiée pour ajouter des éléments à une collection.</summary>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'instance prenant un argument, qui ajoute un élément à une collection.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> est <see langword="null" />.

ou -
Un ou plusieurs éléments de <paramref name="initializers" /> sont <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n’implémente pas <see cref="T:System.Collections.IEnumerable" />.

ou -
<paramref name="addMethod" /> n'est pas <see langword="null" /> et ne représente pas une méthode d'instance nommée "Add" (non respect de la casse) qui prend exactement un argument.

ou -
<paramref name="addMethod" /> n'est pas <see langword="null" /> et le type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="initializers" /> ne peut pas être assigné au type d'argument de la méthode que <paramref name="addMethod" /> représente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> est <see langword="null" /> et il n'existe aucune méthode d'instance nommée "Add" prenant un argument compatible avec le type sur <paramref name="newExpression" />.Type ou son type de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LoopExpression" /> avec le corps donné.</summary>
      <param name="body">Corps de la boucle.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.LoopExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)">
      <summary>Crée un objet <see cref="T:System.Linq.Expressions.LoopExpression" /> avec le corps et la cible d'instruction Break donnés.</summary>
      <param name="body">Corps de la boucle.</param>
      <param name="break">Cible d'instruction Break utilisée par le corps de la boucle.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.LoopExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LoopExpression" /> avec le corps donné.</summary>
      <param name="body">Corps de la boucle.</param>
      <param name="break">Cible d'instruction Break utilisée par le corps de la boucle.</param>
      <param name="continue">Cible d'instruction Continue utilisée par le corps de la boucle.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.LoopExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" />, à partir des opérandes gauche et droit, en appelant une méthode de fabrique appropriée.</summary>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération binaire.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande gauche.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande droit.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> ne correspond pas à un nœud d'expression binaire.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" />, avec l'opérande gauche, l'opérande droit et la méthode d'implémentation, en appelant la méthode de fabrique appropriée.</summary>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération binaire.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande gauche.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande droit.</param>
      <param name="liftToNull">
        <see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui spécifie la méthode d'implémentation.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> ne correspond pas à un nœud d'expression binaire.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" />, avec l’opérande gauche, l’opérande droit, la méthode d’implémentation et la fonction de conversion de type, en appelant la méthode de fabrique appropriée.</summary>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération binaire.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande gauche.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande droit.</param>
      <param name="liftToNull">
        <see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui spécifie la méthode d'implémentation.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> qui représente une fonction de conversion de type. Ce paramètre est utilisé uniquement si <paramref name="binaryType" /> a la valeur <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> ou une assignation composée.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> ne correspond pas à un nœud d'expression binaire.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec les éléments spécifiés.</summary>
      <param name="type">Propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que <see cref="T:System.Linq.Expressions.CatchBlock" /> traitera.</param>
      <param name="variable">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</param>
      <param name="body">Corps de l'instruction Catch.</param>
      <param name="filter">Corps du filtre <see cref="T:System.Exception" />.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="delegateType">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Classeur de runtime de l'opération dynamique.</param>
      <param name="arguments">Arguments de l’opération dynamique.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et un argument.</summary>
      <param name="delegateType">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Classeur de runtime de l'opération dynamique.</param>
      <param name="arg0">Argument de l'opération dynamique.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et deux arguments.</summary>
      <param name="delegateType">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Classeur de runtime de l'opération dynamique.</param>
      <param name="arg0">Premier argument de l’opération dynamique.</param>
      <param name="arg1">Deuxième argument de l'opération dynamique.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et trois arguments.</summary>
      <param name="delegateType">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Classeur de runtime de l'opération dynamique.</param>
      <param name="arg0">Premier argument de l’opération dynamique.</param>
      <param name="arg1">Deuxième argument de l'opération dynamique.</param>
      <param name="arg2">Troisième argument de l'opération dynamique.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et quatre arguments.</summary>
      <param name="delegateType">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Classeur de runtime de l'opération dynamique.</param>
      <param name="arg0">Premier argument de l’opération dynamique.</param>
      <param name="arg1">Deuxième argument de l'opération dynamique.</param>
      <param name="arg2">Troisième argument de l'opération dynamique.</param>
      <param name="arg3">Quatrième argument de l’opération dynamique.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DynamicExpression" /> qui représente une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <param name="delegateType">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Classeur de runtime de l'opération dynamique.</param>
      <param name="arguments">Arguments de l’opération dynamique.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égal à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente un saut du <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> spécifié. La valeur passée à l'étiquette au moment du saut peut également être spécifiée.</summary>
      <param name="kind">
        <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> du <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à <paramref name="kind" />, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée dans un objet.</summary>
      <param name="instance">Objet auquel la propriété appartient. Doit avoir la valeur Null si la propriété est <see langword="static" /> (<see langword="shared" /> en Visual Basic).</param>
      <param name="indexer">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente la propriété à indexer.</param>
      <param name="arguments">
        <c>IEnumerable&lt;Expression&gt;</c> (<c>IEnumerable (Of Expression)</c> en Visual Basic) contenant les arguments qui seront utilisés pour indexer la propriété.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ ou à une propriété.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'objet auquel appartient le membre. Cette valeur peut être null pour les membres statiques.</param>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> qui décrit le champ ou la propriété auquel accéder.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> représentant un bloc Try avec les éléments spécifiés.</summary>
      <param name="type">Type de résultat de l'expression Try. Si Null, le corps et tous les gestionnaires doivent avoir le même type.</param>
      <param name="body">Corps du bloc Try.</param>
      <param name="finally">Corps du bloc Finally. Passez la valeur Null si aucun bloc Finally n'est associé au bloc Try.</param>
      <param name="fault">Corps du bloc Fault. Passez la valeur Null si aucun bloc Fault n'est associé au bloc Try.</param>
      <param name="handlers">Collection de <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente les instructions catch à associer au bloc Try.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" />, avec un opérande, en appelant la méthode de fabrique appropriée.</summary>
      <param name="unaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération unaire.</param>
      <param name="operand">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande.</param>
      <param name="type">
        <see cref="T:System.Type" /> qui spécifie le type de conversion (passez <see langword="null" /> le cas échéant).</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> ne correspond pas à un nœud d'expression unaire.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" />, avec un opérande et une méthode d'implémentation, en appelant la méthode de fabrique appropriée.</summary>
      <param name="unaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération unaire.</param>
      <param name="operand">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande.</param>
      <param name="type">
        <see cref="T:System.Type" /> qui spécifie le type de conversion (passez <see langword="null" /> le cas échéant).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> ne correspond pas à un nœud d'expression unaire.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un champ ou d'une propriété.</summary>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> ou <paramref name="bindings" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.

ou -
La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type du champ ou de la propriété représenté par <paramref name="member" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un champ ou d'une propriété.</summary>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="bindings">Tableau d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> ou <paramref name="bindings" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.

ou -
La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type du champ ou de la propriété représenté par <paramref name="member" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un membre accessible via une méthode d'accesseur de propriété.</summary>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> est égale à <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont les propriétés <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> ou <paramref name="bindings" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.

ou -
La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un membre accessible via une méthode d'accesseur de propriété.</summary>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <param name="bindings">Tableau d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> est égale à <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont les propriétés <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> ou <paramref name="bindings" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.

ou -
La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Représente une expression qui crée un nouvel objet et initialise une propriété de l'objet.</summary>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> doit être égale.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="bindings" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type représenté par <paramref name="newExpression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> doit être égale.</param>
      <param name="bindings">Tableau d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="bindings" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type représenté par <paramref name="newExpression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération arithmétique relative au reste.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur modulo n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération arithmétique relative au reste.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est <see langword="null" /> et l’opérateur modulus n’est pas défini pour les types <paramref name="left" /> et <paramref name="right" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de reste.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de reste.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de reste.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de multiplication n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est <see langword="null" /> et l'opérateur de multiplication n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de multiplication n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est <see langword="null" /> et l'opérateur de multiplication n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur moins unaire n'est pas défini pour <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est <see langword="null" /> et l'opérateur moins unaire n'est pas défini pour <paramref name="expression" />.Type.

ou -
<paramref name="expression" />.Type (ou son type non Nullable correspondant s'il s'agit d'un type valeur Nullable) ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur moins unaire n'est pas défini pour <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique qui dispose d'une vérification de dépassement de capacité. La méthode d'implémentation peut être spécifiée.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est <see langword="null" /> et l'opérateur moins unaire n'est pas défini pour <paramref name="expression" />.Type.

ou -
<paramref name="expression" />.Type (ou son type non Nullable correspondant s'il s'agit d'un type valeur Nullable) ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié qui ne prend pas d'arguments.</summary>
      <param name="constructor">
        <see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Le constructeur représenté par <paramref name="constructor" /> a au moins un paramètre.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié avec les arguments spécifiés.</summary>
      <param name="constructor">
        <see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> et <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> est <see langword="null" />.

ou -
Un élément de <paramref name="arguments" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="arguments" /> ne contient pas le même nombre d'éléments que le nombre de paramètres pour le constructeur représenté par <paramref name="constructor" />.

ou -
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un élément de <paramref name="arguments" /> n’est pas attribuable au type du paramètre correspondant du constructeur que <paramref name="constructor" /> représente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié avec les arguments spécifiés. Les membres qui accèdent aux champs initialisés du constructeur sont spécifiés.</summary>
      <param name="constructor">
        <see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Reflection.MemberInfo" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> et <see cref="P:System.Linq.Expressions.NewExpression.Members" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> a la valeur <see langword="null" />.

ou -
Un élément de <paramref name="arguments" /> est <see langword="null" />.

ou -
Un élément de <paramref name="members" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="arguments" /> ne contient pas le même nombre d'éléments que le nombre de paramètres pour le constructeur représenté par <paramref name="constructor" />.

ou -
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un élément de <paramref name="arguments" /> n’est pas attribuable au type du paramètre correspondant du constructeur que <paramref name="constructor" /> représente.

ou -
Le paramètre <paramref name="members" /> n'a pas le même nombre d'éléments que le paramètre <paramref name="arguments" />.

ou -
Un élément du paramètre <paramref name="arguments" /> a une propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type qui ne peut pas être assigné au type du membre représenté par l'élément correspondant du paramètre <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié avec les arguments spécifiés. Les membres qui accèdent aux champs initialisés du constructeur sont spécifiés sous forme de tableau.</summary>
      <param name="constructor">
        <see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">Tableau d'objets <see cref="T:System.Reflection.MemberInfo" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> et <see cref="P:System.Linq.Expressions.NewExpression.Members" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> est <see langword="null" />.

ou -
Un élément de <paramref name="arguments" /> est <see langword="null" />.

ou -
Un élément de <paramref name="members" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="arguments" /> ne contient pas le même nombre d'éléments que le nombre de paramètres pour le constructeur représenté par <paramref name="constructor" />.

ou -
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un élément de <paramref name="arguments" /> n’est pas attribuable au type du paramètre correspondant du constructeur que <paramref name="constructor" /> représente.

ou -
Le paramètre <paramref name="members" /> n'a pas le même nombre d'éléments que le paramètre <paramref name="arguments" />.

ou -
Un élément du paramètre <paramref name="arguments" /> a une propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type qui ne peut pas être assigné au type du membre représenté par l'élément correspondant du paramètre <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié avec les arguments spécifiés.</summary>
      <param name="constructor">
        <see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> et <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> est <see langword="null" />.

ou -
Un élément de <paramref name="arguments" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La longueur de <paramref name="arguments" /> correspond au nombre de paramètres du constructeur que <paramref name="constructor" /> représente.

ou -
La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un élément de <paramref name="arguments" /> n’est pas attribuable au type du paramètre correspondant du constructeur que <paramref name="constructor" /> représente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur sans paramètre du type spécifié.</summary>
      <param name="type">
        <see cref="T:System.Type" /> ayant un constructeur qui ne prend pas d'arguments.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> égale à <see cref="T:System.Reflection.ConstructorInfo" />, laquelle représente le constructeur sans paramètre pour le type spécifié.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Le type représenté par <paramref name="type" /> n'a pas de constructeur sans paramètres.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau ayant un rang spécifié.</summary>
      <param name="type">
        <see cref="T:System.Type" /> qui représente le type d'élément du tableau.</param>
      <param name="bounds">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="bounds" /> est <see langword="null" />.

ou -
Un élément de <paramref name="bounds" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="bounds" /> ne représente pas un type intégral.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau ayant un rang spécifié.</summary>
      <param name="type">
        <see cref="T:System.Type" /> qui représente le type d'élément du tableau.</param>
      <param name="bounds">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="bounds" /> est <see langword="null" />.

ou -
Un élément de <paramref name="bounds" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="bounds" /> ne représente pas un type intégral.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau unidimensionnel et son initialisation à partir d'une liste d'éléments.</summary>
      <param name="type">
        <see cref="T:System.Type" /> qui représente le type d'élément du tableau.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="initializers" /> est <see langword="null" />.

ou -
Un élément de <paramref name="initializers" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément du paramètre <paramref name="initializers" /> représente un type qui ne peut pas être assigné au type représenté par <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau unidimensionnel et son initialisation à partir d'une liste d'éléments.</summary>
      <param name="type">
        <see cref="T:System.Type" /> qui représente le type d'élément du tableau.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="initializers" /> est <see langword="null" />.

ou -
Un élément de <paramref name="initializers" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="initializers" /> représente un type qui ne peut pas être assigné au type <paramref name="type" />.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.NodeType">
      <summary>Obtient le type de nœud de ce <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Une des valeurs de l'objet <see cref="T:System.Linq.Expressions.ExpressionType" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de bits de complément.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur NOT unaire n'est pas défini pour <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de bits de complément. La méthode d'implémentation peut être spécifiée.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est <see langword="null" /> et l'opérateur NOT unaire n'est pas défini pour <paramref name="expression" />.Type.

ou -
<paramref name="expression" />.Type (ou son type non Nullable correspondant s'il s'agit d'un type valeur Nullable) ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'inégalité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur d'inégalité n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'inégalité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull">
        <see langword="true" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="true" /> ; <see langword="false" /> pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur <see langword="false" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est <see langword="null" /> et l'opérateur d'inégalité n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)">
      <summary>Retourne l'expression qui représente le complément à 1.</summary>
      <param name="expression">Élément <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Retourne l'expression qui représente le complément à 1.</summary>
      <param name="expression">Élément <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="OR" /> au niveau du bit.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de bits <see langword="OR" /> n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="OR" /> au niveau du bit.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, pas <see langword="static" /> (<see langword="Shared" /> dans Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est <see langword="null" /> et l’opérateur <see langword="OR" /> au niveau du bit n’est pas défini pour les types <paramref name="left" />.et <paramref name="right" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation OR au niveau du bit.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation OR au niveau du bit.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation OR au niveau du bit.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="OR" /> conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur <see langword="false" />.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de bits <see langword="OR" /> n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.

ou -
<paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération <see langword="OR" /> conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur <see langword="false" />.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, pas <see langword="static" /> (<see langword="Shared" /> dans Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est <see langword="null" /> et l’opérateur <see langword="OR" /> au niveau du bit n’est pas défini pour les types <paramref name="left" />.et <paramref name="right" />.

ou -
<paramref name="method" /> est <see langword="null" /> et <paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type)">
      <summary>Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d’expression.</summary>
      <param name="type">Type du paramètre ou de la variable.</param>
      <returns>Nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> avec le nom et le type spécifiés.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)">
      <summary>Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d’expression.</summary>
      <param name="type">Type du paramètre ou de la variable.</param>
      <param name="name">Nom du paramètre ou de la variable, utilisé à des fins de débogage ou d'impression uniquement.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> et dont les propriétés <see cref="P:System.Linq.Expressions.Expression.Type" /> et <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une décrémentation de 1 de l'expression d'origine.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une décrémentation de 1 de l'expression d'origine.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une incrémentation de 1 de l'expression d'origine.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une incrémentation de 1 de l'expression d'origine.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'un nombre à une puissance.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur d'exponentiation n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.

ou -
<paramref name="left" />.Type et/ou <paramref name="right" />.Type ne sont pas <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'un nombre à une puissance.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> a la valeur <see langword="null" /> et l’opérateur d’élévation à une puissance n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.

ou -
<paramref name="method" /> a la valeur <see langword="null" /> et <paramref name="left" />.Type et/ou <paramref name="right" />.Type ne sont pas <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'une expression à une puissance et la réassignation du résultat à l'expression.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'une expression à une puissance et la réassignation du résultat à l'expression.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'une expression à une puissance et la réassignation du résultat à l'expression.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui décrémente l'expression de 1 et réassigne le résultat à l'expression.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui décrémente l'expression de 1 et réassigne le résultat à l'expression.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui incrémente l'expression de 1 et réassigne le résultat à l'expression.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui incrémente l'expression de 1 et réassigne le résultat à l'expression.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété à l'aide d'une méthode d'accesseur de propriété.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> doit être égale. Cette valeur peut être null pour les propriétés statiques.</param>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> a pour valeur <paramref name="expression" /> et la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> a pour valeur le <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> est <see langword="null" />.

ou -
La méthode représentée par <paramref name="propertyAccessor" /> n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) et <paramref name="expression" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />. Le type ne peut pas être affecté au type de la méthode représentée par <paramref name="propertyAccessor" />.

ou -
La méthode représentée par <paramref name="propertyAccessor" /> n'est pas une méthode d'accesseur de propriété.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> doit être égale. Cette valeur peut être null pour les propriétés statiques.</param>
      <param name="property">
        <see cref="T:System.Reflection.PropertyInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> et <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="property" /> a la valeur <see langword="null" />.

ou -
La propriété représentée par <paramref name="property" /> n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) et <paramref name="expression" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type ne peut pas être assigné au type de déclaration de la propriété que <paramref name="property" /> représente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée.</summary>
      <param name="instance">Objet auquel la propriété appartient. Si la propriété est statique/partagée, doit avoir la valeur Null.</param>
      <param name="indexer">
        <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété à indexer.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> utilisés pour indexer la propriété.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée.</summary>
      <param name="instance">Objet auquel la propriété appartient. Si la propriété est statique/partagée, doit avoir la valeur Null.</param>
      <param name="indexer">
        <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété à indexer.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> utilisés pour indexer la propriété.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> dont <see cref="P:System.Linq.Expressions.Expression.Type" /> contient une propriété nommée <paramref name="propertyName" />. Cette valeur peut être <see langword="null" /> pour les propriétés statiques.</param>
      <param name="propertyName">Nom d'une propriété à laquelle accéder.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> a pour valeur <paramref name="expression" /> et dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> a pour valeur le <see cref="T:System.Reflection.PropertyInfo" /> qui représente le champ désigné par <paramref name="propertyName" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="propertyName" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Aucune propriété nommée <paramref name="propertyName" /> n'est définie dans <paramref name="expression" />.Type ou ses types de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée.</summary>
      <param name="instance">Objet auquel la propriété appartient. Si la propriété est statique/partagée, doit avoir la valeur Null.</param>
      <param name="propertyName">Nom de l'indexeur.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> utilisés pour indexer la propriété.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui accède à une propriété.</summary>
      <param name="expression">Objet contenant la propriété. Cette valeur peut être null pour les propriétés statiques.</param>
      <param name="type">Objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui contient la propriété.</param>
      <param name="propertyName">Propriété à laquelle accéder.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.MemberExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété ou un champ.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> dont <see cref="P:System.Linq.Expressions.Expression.Type" /> contient une propriété ou un champ nommé <paramref name="propertyOrFieldName" />. Cette valeur peut être null pour les membres statiques.</param>
      <param name="propertyOrFieldName">Nom d'une propriété ou d'un champ auquel accéder.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> est égale à <paramref name="expression" />, et la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> est égale à <see cref="T:System.Reflection.PropertyInfo" /> ou à <see cref="T:System.Reflection.FieldInfo" /> qui représente la propriété ou le champ désigné par <paramref name="propertyOrFieldName" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="propertyOrFieldName" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Aucune propriété ou aucun champ nommé <paramref name="propertyOrFieldName" /> n'est défini dans <paramref name="expression" />.Type ou ses types de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une expression ayant une valeur de constante de type <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Reduce">
      <summary>Réduit le nœud en une expression plus simple. Si CanReduce retourne la valeur true, cela doit retourner une expression valide. Cette méthode peut retourner un autre nœud qui doit lui-même être réduit.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceAndCheck">
      <summary>Réduit le nœud en une expression plus simple. Si CanReduce retourne la valeur true, cela doit retourner une expression valide. Cette méthode peut retourner un autre nœud qui doit lui-même être réduit.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceExtensions">
      <summary>Réduit l'expression à un type de nœud connu (qui n'est pas un nœud Extension) ou retourne simplement l'expression s'il s'agit d'un type déjà connu.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'égalité des références.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'inégalité des références.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'exception.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'exception.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow(System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'une exception avec un type donné.</summary>
      <param name="type">Nouveau <see cref="T:System.Type" /> d'une expression.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'exception.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Return, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return. La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return avec le type spécifié. La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return avec le type spécifié.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Return, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la droite.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de décalage vers la droite n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la droite.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n’est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est <see langword="null" /> et l'opérateur de décalage vers la droite n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la droite au niveau du bit.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la droite au niveau du bit.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la droite au niveau du bit.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <param name="variables">Collection d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
      <returns>Instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> et la propriété <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> égale à la valeur spécifiée.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <param name="variables">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
      <returns>Instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> et la propriété <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> égale à la valeur spécifiée.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de soustraction n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, pas <see langword="static" /> (<see langword="Shared" /> dans Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est <see langword="null" /> et l’opérateur de soustraction n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de soustraction n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, pas <see langword="static" /> (<see langword="Shared" /> dans Visual Basic) ou ne prend pas exactement deux arguments.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est <see langword="null" /> et l’opérateur de soustraction n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction <see langword="switch" /> avec la casse par défaut.</summary>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction <see langword="switch" /> avec la casse par défaut.</summary>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</param>
      <param name="comparison">Méthode de comparaison d'égalité à utiliser.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction <see langword="switch" /> avec la casse par défaut.</summary>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</param>
      <param name="comparison">Méthode de comparaison d'égalité à utiliser.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction <see langword="switch" /> sans casse par défaut.</summary>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction <see langword="switch" /> avec la casse par défaut.</summary>
      <param name="type">Type de résultat du commutateur.</param>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</param>
      <param name="comparison">Méthode de comparaison d'égalité à utiliser.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction <see langword="switch" /> avec la casse par défaut.</summary>
      <param name="type">Type de résultat du commutateur.</param>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</param>
      <param name="comparison">Méthode de comparaison d'égalité à utiliser.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un objet <see cref="T:System.Linq.Expressions.SwitchCase" /> à utiliser dans un objet <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <param name="body">Corps du cas.</param>
      <param name="testValues">Valeurs de test du cas.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchCase" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchCase" /> pour une utilisation dans un <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <param name="body">Corps du cas.</param>
      <param name="testValues">Valeurs de test du cas.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchCase" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName">
        <see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> a la valeur spécifiée.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName">
        <see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
      <param name="language">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont les propriétés <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> et <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> ont la valeur spécifiée.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName">
        <see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
      <param name="language">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> doit être égale.</param>
      <param name="languageVendor">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont les propriétés <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> et <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> ont la valeur spécifiée.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName">
        <see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
      <param name="language">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> doit être égale.</param>
      <param name="languageVendor">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> doit être égale.</param>
      <param name="documentType">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont les propriétés <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> et <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> ont la valeur spécifiée.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une levée d'exception.</summary>
      <param name="value">Élément <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <returns>Objet <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'exception.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente la levée d'une exception avec un type donné.</summary>
      <param name="value">Élément <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">Nouveau <see cref="T:System.Type" /> d'une expression.</param>
      <returns>Objet <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'exception.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ToString">
      <summary>Retourne une représentation textuelle de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Représentation textuelle de <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un nombre quelconque d'instructions Catch mais ni une erreur, ni un bloc Finally.</summary>
      <param name="body">Corps du bloc Try.</param>
      <param name="handlers">Tableau de zéro ou plusieurs expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente les instructions Catch à associer au bloc Try.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un nombre quelconque d'instructions Catch et un bloc Finally.</summary>
      <param name="body">Corps du bloc Try.</param>
      <param name="finally">Corps du bloc Finally.</param>
      <param name="handlers">Tableau de zéro ou plusieurs expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente les instructions Catch à associer au bloc Try.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un bloc Fault et aucune instruction Catch.</summary>
      <param name="body">Corps du bloc Try.</param>
      <param name="fault">Corps du bloc Fault.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un bloc Finally et aucune instruction Catch.</summary>
      <param name="body">Corps du bloc Try.</param>
      <param name="finally">Corps du bloc Finally.</param>
      <returns>Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)">
      <summary>Crée un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type délégué System.Action générique comportant des arguments de type spécifiques.</summary>
      <param name="typeArgs">Tableau d’objets Type qui spécifient les arguments de type pour le type délégué System.Action.</param>
      <param name="actionType">Cette méthode retourne le type délégué System.Action générique qui comporte des arguments de type spécifiques. Contient la valeur Null s'il n'y a aucun délégué System.Action générique qui correspond au <paramref name="typeArgs" />. Ce paramètre est passé sans être initialisé.</param>
      <returns>
        <see langword="true" /> si le type délégué System.Action générique a été créé pour un <paramref name="typeArgs" /> spécifique, sinon <see langword="false" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)">
      <summary>Crée un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type délégué System.Func générique comportant des arguments de type spécifiques. Le dernier argument de type spécifie le type de retour du délégué créé.</summary>
      <param name="typeArgs">Tableau d'objets Type qui spécifient les arguments de type pour le type délégué System.Func.</param>
      <param name="funcType">Cette méthode retourne le type délégué System.Func générique qui comporte des arguments de type spécifiques. Contient la valeur null s'il n'existe aucun délégué System.Func générique qui correspond au <paramref name="typeArgs" />. Ce paramètre est passé sans être initialisé.</param>
      <returns>
        <see langword="true" /> si le type délégué System.Func générique a été créé pour un <paramref name="typeArgs" /> spécifique, sinon <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.Expression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="T:System.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une référence explicite ou une conversion boxing où la valeur <see langword="null" /> est fournie en cas d'échec de la conversion.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> qui compare l'identité de type à l'exécution.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="T:System.Linq.Expressions.Expression" /> doit être égale.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> et dont les propriétés <see cref="T:System.Linq.Expressions.Expression" /> et <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> ont les valeurs spécifiées.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> doit être égale.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> et dont les propriétés <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> et <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération plus unaire.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur plus unaire n'est pas défini pour <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération plus unaire.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas <see langword="null" /> et la méthode représentée retourne <see langword="void" />, n'est pas <see langword="static" /> (<see langword="Shared" /> en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est <see langword="null" /> et l'opérateur plus unaire n'est pas défini pour <paramref name="expression" />.Type.

ou -
<paramref name="expression" />.Type (ou son type non Nullable correspondant s'il s'agit d'un type valeur Nullable) ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente un unboxing explicite.</summary>
      <param name="expression">Objet <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer un unboxing.</param>
      <param name="type">Nouveau <see cref="T:System.Type" /> d'une expression.</param>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type)">
      <summary>Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d’expression.</summary>
      <param name="type">Type du paramètre ou de la variable.</param>
      <returns>Nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> avec le nom et le type spécifiés.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)">
      <summary>Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d’expression.</summary>
      <param name="type">Type du paramètre ou de la variable.</param>
      <param name="name">Nom du paramètre ou de la variable. Ce nom est utilisé à des fins de débogage ou d'impression uniquement.</param>
      <returns>Nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> avec le nom et le type spécifiés.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Réduit le nœud puis appelle le délégué visiteur sur l'expression réduite. La méthode lève une exception si le nœud n'est pas réductible.</summary>
      <param name="visitor">Instance de <see cref="T:System.Func`2" />.</param>
      <returns>Expression qui est visitée ou expression qui doit la remplacer dans l’arborescence.</returns>
    </member>
    <member name="T:System.Linq.Expressions.Expression`1">
      <summary>Représente une expression lambda fortement typée comme une structure de données sous forme d'arborescence de l'expression. Cette classe ne peut pas être héritée.</summary>
      <typeparam name="TDelegate">Type du délégué représenté par le <see cref="T:System.Linq.Expressions.Expression`1" />.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile">
      <summary>Compile l'expression lambda décrite par l'arborescence de l'expression dans le code exécutable et produit un délégué qui représente l'expression lambda.</summary>
      <returns>Délégué de type <paramref name="TDelegate" /> qui représente l'expression lambda compilée décrite par <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile(System.Boolean)">
      <summary>Compile l’expression lambda décrite par l’arborescence de l’expression dans du code interprété ou compilé, et produit un délégué qui représente l’expression lambda.</summary>
      <param name="preferInterpretation">
        <see langword="true" /> pour indiquer que l’expression doit être compilée en un formulaire interprété, si disponible ; <see langword="false" /> dans le cas contraire.</param>
      <returns>Délégué qui représente l’expression lambda compilée décrite par <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile(System.Runtime.CompilerServices.DebugInfoGenerator)">
      <summary>Produit un délégué qui représente l'expression lambda.</summary>
      <param name="debugInfoGenerator">Générateur d'informations de débogage utilisé par le compilateur pour marquer les points de séquence et annoter les variables locales.</param>
      <returns>Délégué qui contient la version compilée du lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="body">Propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> du résultat.</param>
      <param name="parameters">Propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionType">
      <summary>Décrit les types de nœuds d'une arborescence d'expression.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Add">
      <summary>Opération d’addition, telle que <c>a + b</c>, sans contrôle de dépassement de capacité, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssign">
      <summary>Opération d’assignation composée d’addition, telle que <c>(a += b)</c>, sans contrôle de dépassement de capacité, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssignChecked">
      <summary>Opération d’assignation composée d’addition, telle que <c>(a += b)</c>, avec contrôle de dépassement de capacité, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddChecked">
      <summary>Opération d’addition telle que <c>(a + b)</c>, avec contrôle de dépassement de capacité, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.And">
      <summary>Opération <see langword="AND" /> logique ou au niveau du bit, telle que <c>(a &amp;b)</c> en C# et <c>(a And b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAlso">
      <summary>Opération <see langword="AND" /> conditionnelle qui évalue la deuxième opérande uniquement si la première opérande a la valeur <see langword="true" />. Correspond à <c>(a &amp;&amp; b)</c> en C# et <c>(a AndAlso b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAssign">
      <summary>Opération d’assignation composée <see langword="AND" /> logique ou au niveau du bit, telle que <c>(a &amp;= b)</c> en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayIndex">
      <summary>Opération d’indexation dans un tableau unidimensionnel, telle que <c>array[index]</c> en C# ou <c>array(index)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayLength">
      <summary>Opération qui obtient la longueur d’un tableau unidimensionnel, telle que <c>array.Length</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Assign">
      <summary>Opération d’assignation telle que <c>(a = b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Block">
      <summary>Bloc d'expressions.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Call">
      <summary>Appel de méthode, comme dans l’expression <c>obj.sampleMethod()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Coalesce">
      <summary>Nœud qui représente une opération de fusion nulle, telle que <c>(a ?? b)</c> en C# ou <c>If(a, b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Conditional">
      <summary>Opération conditionnelle, telle que <c>a &gt; b ? a : b</c> en C# ou <c>If(a &gt;b, a, b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Constant">
      <summary>Valeur de constante.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Convert">
      <summary>Opération de cast ou de conversion, telle que <c>(SampleType)obj</c> en C# ou <c>CType(obj, SampleType)</c> en Visual Basic. Pour une conversion numérique, si la valeur convertie est trop grande pour le type de destination, aucune exception n'est levée.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ConvertChecked">
      <summary>Opération de cast ou de conversion, telle que <c>(SampleType)obj</c> en C# ou <c>CType(obj, SampleType)</c> en Visual Basic. Pour une conversion numérique, si la valeur convertie ne correspond pas au type cible, une exception est levée.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DebugInfo">
      <summary>Informations de débogage.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Decrement">
      <summary>Opération de décrémentation unaire, telle que <c>(a - 1)</c> en C# et Visual Basic. L’objet <c>a</c> ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Default">
      <summary>Valeur par défaut.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Divide">
      <summary>Opération de division, telle que <c>(a / b)</c>, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DivideAssign">
      <summary>Opération d’assignation composée de division, telle que <c>(a /= b)</c>, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Dynamic">
      <summary>Opération dynamique.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Equal">
      <summary>Nœud qui représente une comparaison d’égalité, telle que <c>(a == b)</c> en C# ou <c>(a = b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOr">
      <summary>Opération <see langword="XOR" /> logique ou au niveau du bit, telle que <c>(a ^ b)</c> en C# ou <c>(a Xor b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign">
      <summary>Opération d’assignation composée <see langword="XOR" /> logique ou au niveau du bit, telle que <c>(a ^= b)</c> en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Extension">
      <summary>Expression d'extension.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Goto">
      <summary>Expression " go to ", telle que <c>goto Label</c> en C# ou <c>GoTo Label</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThan">
      <summary>Comparaison numérique " supérieur à ", telle que <c>(a &gt;b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual">
      <summary>Comparaison " supérieur ou égal à ", telle que <c>(a &gt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Increment">
      <summary>Opération d’incrémentation unaire, telle que <c>(a + 1)</c> en C# et Visual Basic. L’objet <c>a</c> ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Index">
      <summary>Opération d'index ou opération qui accède à une propriété qui prend des arguments.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Invoke">
      <summary>Opération qui appelle un délégué ou une expression lambda, telle que <c>sampleDelegate.Invoke()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsFalse">
      <summary>Valeur de condition <see langword="false" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsTrue">
      <summary>Valeur de condition <see langword="true" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Label">
      <summary>Étiquette.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Lambda">
      <summary>Expression lambda, telle que <c>a =&gt;a + a</c> en C# ou <c>Function(a) a + a</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShift">
      <summary>Opération de décalage vers la gauche au niveau du bit, telle que <c>(a &lt;&lt;b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign">
      <summary>Assignation composée de décalage vers la gauche au niveau du bit, telle que <c>(a &lt;&lt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThan">
      <summary>Comparaison " inférieur à ", telle que <c>(a &lt;b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual">
      <summary>Comparaison " inférieur ou égal à ", telle que <c>(a &lt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ListInit">
      <summary>Opération qui crée un objet <see cref="T:System.Collections.IEnumerable" /> et l’initialise à partir d’une liste d’éléments, telle que <c>new List&lt;SampleType&gt;(){ a, b, c }</c> en C# ou <c>Dim sampleList = { a, b, c }</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Loop">
      <summary>Boucle, telle que <c>for</c> ou <c>while</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberAccess">
      <summary>Opération qui lit un champ ou une propriété, telle que <c>obj.SampleProperty</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberInit">
      <summary>Opération qui crée un objet et initialise un ou plusieurs de ses membres, telle que <c>new Point { X = 1, Y = 2 }</c> en C# ou <c>New Point With {.X = 1, .Y = 2}</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Modulo">
      <summary>Opération arithmétique relative au reste, telle que <c>(a % b)</c> en C# ou <c>(a Mod b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ModuloAssign">
      <summary>Opération arithmétique d’assignation composée du reste, telle que <c>(a %= b)</c> en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Multiply">
      <summary>Opération de multiplication, telle que <c>(a * b)</c>, sans contrôle de dépassement de capacité, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssign">
      <summary>Opération d’assignation composée de multiplication, telle que <c>(a *= b)</c>, sans contrôle de dépassement de capacité, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked">
      <summary>Opération d’assignation composée de multiplication, telle que <c>(a *= b)</c>, avec contrôle de dépassement de capacité, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyChecked">
      <summary>Opération de multiplication, telle que <c>(a * b)</c>, avec contrôle de dépassement de capacité, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Negate">
      <summary>Opération arithmétique de négation, telle que <c>(-a)</c>. L’objet <c>a</c> ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NegateChecked">
      <summary>Opération arithmétique de négation, telle que <c>(-a)</c>, avec contrôle de dépassement de capacité. L’objet <c>a</c> ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.New">
      <summary>Opération qui appelle un constructeur pour créer un objet, telle que <c>new SampleType()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayBounds">
      <summary>Opération qui crée un tableau dans lequel les limites de chaque dimension sont spécifiées, telle que <c>new SampleType[dim1, dim2]</c> en C# ou <c>New SampleType(dim1, dim2)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayInit">
      <summary>Opération qui crée un tableau unidimensionnel et l’initialise à partir d’une liste d’éléments, telle que <c>new SampleType[]{a, b, c}</c> en C# ou <c>New SampleType(){a, b, c}</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Not">
      <summary>Complément de bits ou opération de négation logique. En C#, équivaut à <c>(~a)</c> pour les types intégraux et à <c>(!a)</c> pour les valeurs booléennes. En Visual Basic, équivaut à <c>(Not a)</c>. L’objet <c>a</c> ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NotEqual">
      <summary>Comparaison d’inégalité, telle que <c>(a != b)</c> en C# ou <c>(a &lt;&gt;b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OnesComplement">
      <summary>Opération de complément à 1, telle que <c>(~a)</c> en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Or">
      <summary>Opération <see langword="OR" /> logique ou au niveau du bit, telle que <c>(a | b)</c> en C# ou <c>(a Or b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrAssign">
      <summary>Assignation composée <see langword="OR" /> logique ou au niveau du bit, telle que <c>(a |= b)</c> en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrElse">
      <summary>Opération <see langword="OR" /> conditionnelle de court-circuit, telle que <c>(a || b)</c> en C# ou <c>(a OrElse b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Parameter">
      <summary>Référence à un paramètre ou une variable défini(e) dans le contexte de l'expression. Pour plus d'informations, consultez <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostDecrementAssign">
      <summary>Décrément suffixé unaire, tel que <c>(a--)</c>. L’objet <c>a</c> doit être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostIncrementAssign">
      <summary>Incrément suffixé unaire, tel que <c>(a++)</c>. L’objet <c>a</c> doit être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Power">
      <summary>Opération mathématique qui élève un nombre à une puissance, telle que <c>(a ^ b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PowerAssign">
      <summary>Opération d’assignation composée qui élève un nombre à une puissance, telle que <c>(a ^= b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreDecrementAssign">
      <summary>Décrément préfixé unaire, tel que <c>(--a)</c>. L’objet <c>a</c> doit être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreIncrementAssign">
      <summary>Incrément préfixé unaire, tel que <c>(++a)</c>. L’objet <c>a</c> doit être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Quote">
      <summary>Expression comportant une valeur constante de type <see cref="T:System.Linq.Expressions.Expression" />. Un nœud <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> peut contenir les références aux paramètres définis dans le contexte de l'expression qu'il représente.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShift">
      <summary>Opération de décalage vers la droite au niveau du bit, telle que <c>(a &gt;&gt; b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShiftAssign">
      <summary>Opération d’assignation composée de décalage vers la droite au niveau du bit, telle que <c>(a &gt;&gt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RuntimeVariables">
      <summary>Liste de variables d'exécution. Pour plus d'informations, consultez <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Subtract">
      <summary>Opération de soustraction, telle que <c>(a - b)</c>, sans contrôle de dépassement de capacité, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssign">
      <summary>Opération d’assignation composée de soustraction, telle que <c>(a -= b)</c>, sans contrôle de dépassement de capacité, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked">
      <summary>Opération d’assignation composée de soustraction, telle que <c>(a -= b)</c>, avec contrôle de dépassement de capacité, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractChecked">
      <summary>Opération de soustraction arithmétique, telle que <c>(a - b)</c>, avec contrôle de dépassement de capacité, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Switch">
      <summary>Opération de commutateur, telle que <see langword="switch" /> en C# ou <see langword="Select Case" /> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Throw">
      <summary>Opération qui lève une exception, telle que <c>throw new Exception()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Try">
      <summary>Expression <see langword="try-catch" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeAs">
      <summary>Référence explicite ou conversion boxing dans laquelle la valeur <see langword="null" /> est fournie si la conversion échoue, telle que <c>(obj as SampleType)</c> en C# ou <c>TryCast(obj, SampleType)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeEqual">
      <summary>Test de type exact.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeIs">
      <summary>Test de type, tel que <c>obj is SampleType</c> en C# ou <c>TypeOf obj is SampleType</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.UnaryPlus">
      <summary>Opération plus unaire, telle que <c>(+a)</c>. Le résultat d'une opération plus unaire prédéfinie est la valeur de l'opérande, mais les implémentations définies par l'utilisateur peuvent avoir des résultats inhabituels.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Unbox">
      <summary>Opération de type valeur unbox, telle que les instructions <see langword="unbox" /> et <see langword="unbox.any" /> en MSIL.</summary>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionVisitor">
      <summary>Représente un visiteur ou module de réécriture pour les arborescences d'expression.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Linq.Expressions.ExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.Expression})">
      <summary>Distribue la liste des expressions à l'une des méthodes de visite les plus spécialisées dans cette classe.</summary>
      <param name="nodes">Expressions à visiter.</param>
      <returns>Liste d'expressions modifiées, si l'un des éléments a été modifié ; sinon, retourne la liste d'expressions d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Linq.Expressions.Expression)">
      <summary>Distribue l'expression à l'une des méthodes de visite les plus spécialisées dans cette classe.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Func{``0,``0})">
      <summary>Visite tous les nœuds dans la collection à l'aide d'un visiteur d'élément spécifié.</summary>
      <param name="nodes">Nœuds à visiter.</param>
      <param name="elementVisitor">Délégué qui visite un élément unique, éventuellement le remplaçant par un nouvel élément.</param>
      <typeparam name="T">Type des nœuds.</typeparam>
      <returns>Liste de nœuds modifiés, si des éléments ont été modifiés ; sinon, retourne la liste de nœuds d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(``0,System.String)">
      <summary>Visite une expression, en effectuant un cast arrière du résultat vers le type d'expression d'origine.</summary>
      <param name="node">Expression à visiter.</param>
      <param name="callerName">Nom de la méthode d'appel ; utilisé pour signaler un meilleur message d'erreur.</param>
      <typeparam name="T">Type de l'expression.</typeparam>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <exception cref="T:System.InvalidOperationException">La méthode de visite pour ce nœud a retourné un type différent.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.String)">
      <summary>Visite toutes les expressions de la collection, en effectuant un cast des résultats vers le type d’expression d’origine.</summary>
      <param name="nodes">Expressions à visiter.</param>
      <param name="callerName">Nom de la méthode d’appel ; utilisé pour signaler un meilleur message d’erreur.</param>
      <typeparam name="T">Type des expressions.</typeparam>
      <returns>Collection de l’expression modifiée, si une expression a été modifiée ; sinon, retourne la collection de l’expression d’origine.</returns>
      <exception cref="T:System.InvalidOperationException">La méthode de visite pour l’une des expressions a retourné un type différent.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.BinaryExpression" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.BlockExpression" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitCatchBlock(System.Linq.Expressions.CatchBlock)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.ConditionalExpression" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
      <summary>Visite <see cref="T:System.Linq.Expressions.ConstantExpression" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDebugInfo(System.Linq.Expressions.DebugInfoExpression)">
      <summary>Visite <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDefault(System.Linq.Expressions.DefaultExpression)">
      <summary>Visite <see cref="T:System.Linq.Expressions.DefaultExpression" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDynamic(System.Linq.Expressions.DynamicExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.DynamicExpression" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitElementInit(System.Linq.Expressions.ElementInit)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitExtension(System.Linq.Expressions.Expression)">
      <summary>Visite les enfants de l'expression d'extension.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitGoto(System.Linq.Expressions.GotoExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitIndex(System.Linq.Expressions.IndexExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.IndexExpression" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.InvocationExpression" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabel(System.Linq.Expressions.LabelExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.LabelExpression" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabelTarget(System.Linq.Expressions.LabelTarget)">
      <summary>Visite <see cref="T:System.Linq.Expressions.LabelTarget" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.Expression`1" />.</summary>
      <param name="node">Expression à visiter.</param>
      <typeparam name="T">Type du délégué.</typeparam>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.ListInitExpression" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLoop(System.Linq.Expressions.LoopExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.LoopExpression" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMember(System.Linq.Expressions.MemberExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberExpression" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberAssignment" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberBinding(System.Linq.Expressions.MemberBinding)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberListBinding" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberMemberBinding" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.NewExpression" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.NewArrayExpression" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
      <summary>Visite <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitRuntimeVariables(System.Linq.Expressions.RuntimeVariablesExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitch(System.Linq.Expressions.SwitchExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitchCase(System.Linq.Expressions.SwitchCase)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTry(System.Linq.Expressions.TryExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.TryExpression" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTypeBinary(System.Linq.Expressions.TypeBinaryExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</summary>
      <param name="node">Expression à visiter.</param>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpression">
      <summary>Représente un saut inconditionnel. Cela inclut des instructions return, des instructions break et continue et d'autres sauts.</summary>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Kind">
      <summary>Type d'expression « go to ». Sert uniquement à des fins d'information.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> qui représente le type d'expression « go to ».</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Target">
      <summary>Étiquette cible à laquelle ce nœud accède.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.LabelTarget" /> qui représente l'étiquette cible pour ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.GotoExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.GotoExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="target">Propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> du résultat.</param>
      <param name="value">Propriété <see cref="P:System.Linq.Expressions.GotoExpression.Value" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Value">
      <summary>Valeur passée à la cible, ou null si la cible est de type System.Void.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente la valeur passée à la cible ou null.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpressionKind">
      <summary>Spécifie le type de saut que <see cref="T:System.Linq.Expressions.GotoExpression" /> représente.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Break">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction break.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Continue">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction continue.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Goto">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente un saut vers un emplacement.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Return">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction return.</summary>
    </member>
    <member name="T:System.Linq.Expressions.IArgumentProvider">
      <summary>Fournit une interface interne pour accéder aux arguments de plusieurs nœuds d’arborescence (DynamicExpression, ElementInit, MethodCallExpression, InvocationExpression, NewExpression et IndexExpression).  Cette API est destinée à un usage interne uniquement.</summary>
    </member>
    <member name="P:System.Linq.Expressions.IArgumentProvider.ArgumentCount">
      <summary>Retourne le nombre d’arguments du nœud d’arborescence d’expression. Cette API est destinée à un usage interne uniquement.</summary>
      <returns>Nombre d’arguments du nœud d’arborescence d’expression, au format <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IArgumentProvider.GetArgument(System.Int32)">
      <summary>Retourne l’argument à l’<paramref name="index" />, en levant une exception si l’<paramref name="index" /> est hors limites. Cette API est destinée à un usage interne uniquement.</summary>
      <param name="index">Index de l’argument.</param>
      <returns>Argument à l’index.</returns>
    </member>
    <member name="T:System.Linq.Expressions.IDynamicExpression">
      <summary>Fournit une interface interne pour accéder aux arguments des nœuds d’arborescence DynamicExpression, ainsi qu’aux fonctionnalités CallSite et Rewriting.  Vous ne devez pas utiliser cette API.  Elle est publique uniquement en raison de la refactorisation de la DLL, et existe seulement pour optimiser les performances internes.</summary>
    </member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.CreateCallSite">
      <summary>Crée éventuellement CallSite et retourne CallSite pour le cache inline polymorphe de DynamicExpression.  Vous ne devez pas utiliser ce type.  Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances.</summary>
      <returns>CallSite du cache inline polymorphe de DynamicExpression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IDynamicExpression.DelegateType">
      <summary>Obtient le type délégué utilisé par CallSite, qui représente le type des règles utilisées dans le cache inline polymorphe de l’expression dynamique.</summary>
      <returns>Le type de délégué utilisé par le CallSite.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.Rewrite(System.Linq.Expressions.Expression[])">
      <summary>Réécrit ce nœud en remplaçant les arguments de l’expression dynamique par les valeurs fournies.  Le nombre de <paramref name="args" /> doit correspondre au nombre de l’expression actuelle.  Vous ne devez pas utiliser ce type.  Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances.  Cette méthode d’assistance permet la réécriture de nœuds pour qu’ils soient indépendants de la classe d’implémentation spécifique dérivant de l’expression dynamique qui est utilisée sur le site d’appel.</summary>
      <param name="args">Arguments utilisés pour remplacer ce nœud.</param>
      <returns>Nœud réécrit, mais retourne le même nœud si aucune modification n’a été apportée.</returns>
    </member>
    <member name="T:System.Linq.Expressions.IndexExpression">
      <summary>Représente l'indexation d'une propriété ou d'un tableau.</summary>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Arguments">
      <summary>Obtient les arguments qui seront utilisés pour indexer la propriété ou le tableau.</summary>
      <returns>Collection en lecture seule contenant les arguments qui seront utilisés pour indexer la propriété ou le tableau.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Indexer">
      <summary>Obtient le <see cref="T:System.Reflection.PropertyInfo" /> pour la propriété si l'expression représente une propriété indexée, sinon retourne null.</summary>
      <returns>
        <see cref="T:System.Reflection.PropertyInfo" /> pour la propriété si l'expression représente une propriété indexée, sinon null.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Object">
      <summary>Objet à indexer.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> représentant l'objet à indexer.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary>Retourne le nombre d’arguments du nœud d’arborescence d’expression.  Vous ne devez pas utiliser ce membre.  Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances.</summary>
      <returns>retourne <see cref="T:System.Int32" /> ;</returns>
    </member>
    <member name="M:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary>Retourne l’argument à l’index, en levant une exception si l’index est hors limites.  Vous ne devez pas utiliser ce membre.  Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances.</summary>
      <param name="index">Index de l’argument.</param>
      <returns>retourne <see cref="T:System.Linq.Expressions.Expression" /> ;</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.IndexExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IndexExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="object">Propriété <see cref="P:System.Linq.Expressions.IndexExpression.Object" /> du résultat.</param>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.IndexExpression.Arguments" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.InvocationExpression">
      <summary>Représente une expression qui applique un délégué ou une expression lambda à une liste d'expressions d'arguments.</summary>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Arguments">
      <summary>Obtient les arguments auxquels le délégué ou l’expression lambda s’applique.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d’objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les arguments auxquels le délégué est appliqué.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Expression">
      <summary>Obtient le délégué ou l'expression lambda à appliquer.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le délégué à appliquer.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression. Les nœuds d’extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary>Retourne le nombre d’arguments du nœud d’arborescence d’expression.  Vous ne devez pas utiliser ce membre.  Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances.</summary>
      <returns>Nombre d’arguments du nœud d’arborescence d’expression, au format <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary>Retourne l’argument à l’index, en levant une exception si l’index est hors limites.  Vous ne devez pas utiliser ce membre.  Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances.</summary>
      <param name="index">Index de l’argument.</param>
      <returns>Argument à l’index, avec une exception levée si l’index est hors limites, comme <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.InvocationExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="expression">Propriété <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> du résultat.</param>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.InvocationExpression.Arguments" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LabelExpression">
      <summary>Représente une étiquette, qui peut être placée dans tout contexte <see cref="T:System.Linq.Expressions.Expression" />. En cas de saut à cette étiquette, elle a la valeur fournie par le <see cref="T:System.Linq.Expressions.GotoExpression" /> correspondant. Sinon, elle reçoit la valeur indiquée dans <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" />. Si <see cref="T:System.Type" /> est System.Void, aucune valeur ne doit être fournie.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.DefaultValue">
      <summary>La valeur de <see cref="T:System.Linq.Expressions.LabelExpression" /> lorsque l'étiquette est atteinte via le flux de contrôle normal (par exemple, sans saut).</summary>
      <returns>Objet Expression représentant la valeur de <see cref="T:System.Linq.Expressions.LabelExpression" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Target">
      <summary>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel cette étiquette est associée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel cette étiquette est associée.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LabelExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="target">Propriété <see cref="P:System.Linq.Expressions.LabelExpression.Target" /> du résultat.</param>
      <param name="defaultValue">Propriété <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LabelTarget">
      <summary>Utilisé pour représenter la cible d'un <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Name">
      <summary>Obtient le nom de l'étiquette.</summary>
      <returns>Nom de l'étiquette.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelTarget.ToString">
      <summary>Retourne une <see cref="T:System.String" /> qui représente l'<see cref="T:System.Object" /> actuel.</summary>
      <returns>
        <see cref="T:System.String" /> qui représente le <see cref="T:System.Object" /> actuel.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Type">
      <summary>Type de valeur passée lors de l'accès à l'étiquette (ou <see cref="T:System.Void" /> si aucune valeur ne doit être passée).</summary>
      <returns>Objet <see cref="T:System.Type" /> qui représente le type de la valeur passée lors de l'accès à l'étiquette ou <see cref="T:System.Void" /> si aucune valeur ne doit être passée.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LambdaExpression">
      <summary>Décrit une expression lambda. Capture un bloc de code semblable au corps d'une méthode .NET.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Body">
      <summary>Obtient le corps de l'expression lambda.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le corps de l'expression lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile">
      <summary>Produit un délégué qui représente l'expression lambda.</summary>
      <returns>
        <see cref="T:System.Delegate" /> qui contient la version compilée de l'expression lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile(System.Boolean)">
      <summary>Produit un délégué interprété ou compilé qui représente l’expression lambda.</summary>
      <param name="preferInterpretation">
        <see langword="true" /> pour indiquer que l’expression doit être compilée en formulaire interprété, si disponible ; sinon, <see langword="false" />.</param>
      <returns>Délégué qui représente l’expression lambda compilée décrite par l’objet <see cref="T:System.Linq.Expressions.LambdaExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile(System.Runtime.CompilerServices.DebugInfoGenerator)">
      <summary>Produit un délégué qui représente l'expression lambda.</summary>
      <param name="debugInfoGenerator">Générateur d'informations de débogage utilisé par le compilateur pour marquer les points de séquence et annoter les variables locales.</param>
      <returns>Délégué qui contient la version compilée du lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Name">
      <summary>Obtient le nom de l'expression lambda.</summary>
      <returns>Nom de l'expression lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Parameters">
      <summary>Obtient les paramètres de l'expression lambda.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui représentent les paramètres de l'expression lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.ReturnType">
      <summary>Obtient le type de retour de l'expression lambda.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de l'expression lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.TailCall">
      <summary>Obtient la valeur qui indique si l'expression lambda doit être compilée avec l'optimisation d'appel tail.</summary>
      <returns>
        <see langword="true" />Si l’expression lambda doit être compilée avec l’optimisation d’appel tail ; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LambdaExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ListInitExpression">
      <summary>Représente un appel de constructeur ayant un initialiseur de collection.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.CanReduce">
      <summary>Obtient une valeur qui indique si le nœud d’arborescence de l’expression peut être réduit.</summary>
      <returns>
        <see langword="true" />Si le nœud peut être réduit ; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Initializers">
      <summary>Obtient les initialiseurs de l'élément utilisés pour initialiser une collection.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> qui représentent les éléments utilisés pour initialiser la collection.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NewExpression">
      <summary>Obtient l'expression qui contient un appel au constructeur d'un type de collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel au constructeur d'un type de collection.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Reduce">
      <summary>Réduit le nœud d’expression binaire en une expression plus simple.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ListInitExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="newExpression">Propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> du résultat.</param>
      <param name="initializers">Propriété <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LoopExpression">
      <summary>Représente une boucle infinie. Elle peut être quittée avec « break ».</summary>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Body">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.Expression" /> qui correspond au corps de la boucle.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui correspond au corps de la boucle.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.BreakLabel">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.LabelTarget" /> utilisé par le corps de la boucle comme cible d'instruction break.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> utilisé par le corps de la boucle comme cible d'instruction break.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.ContinueLabel">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.LabelTarget" /> utilisé par le corps de la boucle comme cible d'instruction continue.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> utilisé par le corps de la boucle comme cible d'instruction continue.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression. Les nœuds d’extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LoopExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LoopExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="breakLabel">Propriété <see cref="P:System.Linq.Expressions.LoopExpression.BreakLabel" /> du résultat.</param>
      <param name="continueLabel">Propriété <see cref="P:System.Linq.Expressions.LoopExpression.ContinueLabel" /> du résultat.</param>
      <param name="body">Propriété <see cref="P:System.Linq.Expressions.LoopExpression.Body" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberAssignment">
      <summary>Représente l'opération d'assignation d'un champ ou d'une propriété à un objet.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberAssignment.Expression">
      <summary>Obtient l'expression à assigner au champ ou à la propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente la valeur à assigner au champ ou à la propriété.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberAssignment.Update(System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="expression">Propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBinding">
      <summary>Fournit la classe de base à partir de laquelle sont dérivées les classes qui représentent les liaisons utilisées pour initialiser les membres d'un objet nouvellement créé.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.#ctor(System.Linq.Expressions.MemberBindingType,System.Reflection.MemberInfo)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <param name="type">
        <see cref="T:System.Linq.Expressions.MemberBindingType" /> qui discrimine le type de liaison représenté.</param>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> qui représente un champ ou une propriété à initialiser.</param>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.BindingType">
      <summary>Obtient le type de liaison représenté.</summary>
      <returns>Une des valeurs de l'objet <see cref="T:System.Linq.Expressions.MemberBindingType" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.Member">
      <summary>Obtient le champ ou la propriété à initialiser.</summary>
      <returns>
        <see cref="T:System.Reflection.MemberInfo" /> qui représente le champ ou la propriété à initialiser.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.ToString">
      <summary>Retourne une représentation textuelle de <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Représentation textuelle de <see cref="T:System.Linq.Expressions.MemberBinding" />.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBindingType">
      <summary>Décrit les types de liaison utilisés dans les objets <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.Assignment">
      <summary>Liaison qui représente l'initialisation d'un membre avec la valeur d'une expression.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.ListBinding">
      <summary>Liaison qui représente l'initialisation d'un membre de type <see cref="T:System.Collections.IList" /> ou <see cref="T:System.Collections.Generic.ICollection`1" /> dans une liste d'éléments.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.MemberBinding">
      <summary>Liaison qui représente l'initialisation récurrente des membres d'un membre.</summary>
    </member>
    <member name="T:System.Linq.Expressions.MemberExpression">
      <summary>Représente l'accès à un champ ou à une propriété.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud. Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
      <returns>Résultat de la visite de ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Expression">
      <summary>Obtient l'objet contenant du champ ou de la propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'objet contenant du champ ou de la propriété.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Member">
      <summary>Obtient le champ ou la propriété auquel accéder.</summary>
      <returns>
        <see cref="T:System.Reflection.MemberInfo" /> qui représente le champ ou la propriété auquel accéder.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="expression">Propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberInitExpression">
      <summary>Représente l'appel d'un constructeur et l'initialisation d'un ou de plusieurs membres du nouvel objet.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Bindings">
      <summary>Obtient les liaisons qui décrivent comment initialiser les membres de l'objet nouvellement créé.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> qui décrivent comment initialiser les membres.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.CanReduce">
      <summary>Obtient une valeur qui indique si le nœud d’arborescence de l’expression peut être réduit.</summary>
      <returns>
        <see langword="true" />Si le nœud peut être réduit ; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NewExpression">
      <summary>Obtient l'expression qui représente l'appel de constructeur.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel de constructeur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression. Les nœuds d’extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Reduce">
      <summary>Réduit <see cref="T:System.Linq.Expressions.MemberInitExpression" /> à une expression plus simple.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MemberInitExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="newExpression">Propriété <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> du résultat.</param>
      <param name="bindings">Propriété <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberListBinding">
      <summary>Représente l'initialisation des éléments d'un membre de collection d'un objet nouvellement créé.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberListBinding.Initializers">
      <summary>Obtient les initialiseurs de l'élément pour initialiser un membre de collection d'un objet nouvellement créé.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> avec lequel initialiser un membre de collection.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberListBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="initializers">Propriété <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberMemberBinding">
      <summary>Représente l'initialisation des membres d'un membre d'un objet nouvellement créé.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberMemberBinding.Bindings">
      <summary>Obtient les liaisons qui décrivent comment initialiser les membres d'un membre.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> qui décrivent comment initialiser les membres du membre.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberMemberBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="bindings">Propriété <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MethodCallExpression">
      <summary>Représente un appel à une méthode statique ou une méthode d'instance.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud. Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
      <returns>Résultat de la visite de ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Arguments">
      <summary>Obtient une collection d'expressions qui représentent les arguments de la méthode appelée.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les arguments de la méthode appelée.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Method">
      <summary>Obtient l'objet <see cref="T:System.Reflection.MethodInfo" /> pour la méthode à appeler.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode appelée.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Object">
      <summary>Obtient l'objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'instance pour les appels de méthode d'instance ou null pour les appels de méthode statique.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'objet de réception de la méthode.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary>Retourne le nombre d’arguments du nœud d’arborescence d’expression.  Vous ne devez pas utiliser ce membre.  Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances.</summary>
      <returns>Nombre d’arguments du nœud d’arborescence d’expression sous <see cref="T:System.Int32" />la forme.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary>Retourne l’argument à l’index, en levant une exception si l’index est hors limites.  Vous ne devez pas utiliser ce membre.  Il est public uniquement en raison de la refactorisation de l’assembly, et il est utilisé en interne pour optimiser les performances.</summary>
      <param name="index">Index de l’argument.</param>
      <returns>retourne <see cref="T:System.Linq.Expressions.Expression" /> ;</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MethodCallExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="object">Propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> du résultat.</param>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.NewArrayExpression">
      <summary>Représente la création d'un tableau et l'éventuelle initialisation des éléments du nouveau tableau.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud. Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
      <returns>Résultat de la visite de ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Expressions">
      <summary>Obtient les limites du tableau si la valeur de la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" />, ou les valeurs pour initialiser les éléments du nouveau tableau si la valeur de la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les limites du tableau ou les valeurs d'initialisation.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewArrayExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="expressions">Propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.NewExpression">
      <summary>Représente un appel de constructeur.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud. Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
      <returns>Résultat de la visite de ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Arguments">
      <summary>Obtient les arguments pour le constructeur.</summary>
      <returns>Collection d’objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les arguments pour le constructeur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Constructor">
      <summary>Obtient le constructeur appelé.</summary>
      <returns>
        <see cref="T:System.Reflection.ConstructorInfo" /> qui représente le constructeur appelé.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Members">
      <summary>Obtient les membres qui peuvent récupérer les valeurs des champs initialisés avec les arguments de constructeur.</summary>
      <returns>Collection d'objets <see cref="T:System.Reflection.MemberInfo" /> qui représentent les membres qui peuvent récupérer les valeurs des champs initialisés avec les arguments de constructeur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary>Obtient le nombre d’arguments du nœud d’arborescence d’expression.</summary>
      <returns>Nombre d’arguments du nœud d’arborescence d’expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary>Retourne l’argument à l’index, en levant une exception si l’index est hors limites.</summary>
      <param name="index">Index de l’argument.</param>
      <returns>L’argument à l’index, avec une exception levée si l’index est hors limites.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ParameterExpression">
      <summary>Représente une expression de paramètre nommée.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ParameterExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud. Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
      <returns>Résultat de la visite de ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.IsByRef">
      <summary>Indique que <c>ParameterExpression</c> doit être traité comme un paramètre <see langword="ByRef" />.</summary>
      <returns>
        <see langword="true" />Si ce <c>ParameterExpression</c> est un <see langword="ByRef" /> paramètre ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Name">
      <summary>Obtient le nom du paramètre ou de la variable.</summary>
      <returns>
        <see cref="T:System.String" /> qui contient le nom du paramètre.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ParameterExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="T:System.Linq.Expressions.RuntimeVariablesExpression">
      <summary>Expression qui fournit l'autorisation de lecture/écriture d'exécution pour les variables.</summary>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression. Les nœuds d’extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.RuntimeVariablesExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="variables">Propriété <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables">
      <summary>Variables ou paramètres auxquels fournir l'accès d'exécution.</summary>
      <returns>Collection en lecture seule qui contient des paramètres qui se verront octroyer l'accès d'exécution.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchCase">
      <summary>Représente le cas d'un <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.Body">
      <summary>Obtient le corps de ce cas.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente le corps du bloc case.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.TestValues">
      <summary>Obtient les valeurs de ce cas. Ce cas est sélectionné pour être exécuté lorsque le <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> correspond à chacune de ces valeurs.</summary>
      <returns>Collection en lecture seule des valeurs de ce bloc case.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.ToString">
      <summary>Retourne une <see cref="T:System.String" /> qui représente l'<see cref="T:System.Object" /> actuel.</summary>
      <returns>
        <see cref="T:System.String" /> qui représente le <see cref="T:System.Object" /> actuel.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="testValues">Propriété <see cref="P:System.Linq.Expressions.SwitchCase.TestValues" /> du résultat.</param>
      <param name="body">Propriété <see cref="P:System.Linq.Expressions.SwitchCase.Body" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchExpression">
      <summary>Représente une expression de contrôle qui gère des sélections multiples en transmettant le contrôle à <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Cases">
      <summary>Obtient la collection d'objets <see cref="T:System.Linq.Expressions.SwitchCase" /> pour le commutateur.</summary>
      <returns>Collection d'objets <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Comparison">
      <summary>Obtient la méthode de comparaison d'égalité, le cas échéant.</summary>
      <returns>Objet <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode de comparaison d'égalité.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.DefaultBody">
      <summary>Obtient le test pour le commutateur.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente le test pour le commutateur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression. Les nœuds d’extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.SwitchValue">
      <summary>Obtient le test pour le commutateur.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente le test pour le commutateur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.SwitchExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase},System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="switchValue">Propriété <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> du résultat.</param>
      <param name="cases">Propriété <see cref="P:System.Linq.Expressions.SwitchExpression.Cases" /> du résultat.</param>
      <param name="defaultBody">Propriété <see cref="P:System.Linq.Expressions.SwitchExpression.DefaultBody" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SymbolDocumentInfo">
      <summary>Stocke les informations nécessaires pour émettre les informations de symboles de débogage pour un fichier source, en particulier le nom de fichier et l'identificateur de langue unique.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType">
      <summary>Retourne l'identificateur unique du type de document, le cas échéant. La valeur par défaut est le GUID pour un fichier texte.</summary>
      <returns>Identificateur unique du type de document.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.FileName">
      <summary>Nom du fichier source.</summary>
      <returns>Chaîne représentant le nom du fichier source.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.Language">
      <summary>Retourne l'identificateur unique de langue, le cas échéant.</summary>
      <returns>Identificateur unique de langue.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor">
      <summary>Retourne l'identificateur unique du fournisseur de langue, le cas échéant.</summary>
      <returns>Identificateur unique du fournisseur de langue.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TryExpression">
      <summary>Représente un bloc try/catch/finally/fault.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Body">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.Expression" /> représentant le corps du bloc try.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le corps du bloc try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Fault">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.Expression" /> qui représente le bloc fault.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le bloc fault.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Finally">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.Expression" /> qui représente le bloc finally.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le bloc finally.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Handlers">
      <summary>Obtient la collection d'expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> associée au bloc try.</summary>
      <returns>Collection d'expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> associée au bloc try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TryExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TryExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="body">Propriété <see cref="P:System.Linq.Expressions.TryExpression.Body" /> du résultat.</param>
      <param name="handlers">Propriété <see cref="P:System.Linq.Expressions.TryExpression.Handlers" /> du résultat.</param>
      <param name="finally">Propriété <see cref="P:System.Linq.Expressions.TryExpression.Finally" /> du résultat.</param>
      <param name="fault">Propriété <see cref="P:System.Linq.Expressions.TryExpression.Fault" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TypeBinaryExpression">
      <summary>Représente une opération entre une expression et un type.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Expression">
      <summary>Obtient l'opérande d'expression d'une opération de test de type.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande d'expression d'une opération de test de type.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression. Les nœuds d’extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand">
      <summary>Obtient l'opérande de type d'une opération de test de type.</summary>
      <returns>
        <see cref="T:System.Type" /> qui représente l'opérande de type d'une opération de test de type.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TypeBinaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="expression">Propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.Expressions.UnaryExpression">
      <summary>Représente une expression qui comporte un opérateur unaire.</summary>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.CanReduce">
      <summary>Obtient une valeur qui indique si le nœud d’arborescence de l’expression peut être réduit.</summary>
      <returns>
        <see langword="true" />Si un nœud peut être réduit ; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLifted">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence d'expression représente un appel levé vers un opérateur.</summary>
      <returns>
        <see langword="true" /> si le nœud représente un appel levé ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLiftedToNull">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence d'expression représente un appel levé vers un opérateur dont le type de retour est levé vers un type nullable.</summary>
      <returns>
        <see langword="true" /> si le type de retour de l'opérateur est levé vers un type nullable ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Method">
      <summary>Obtient la méthode d'implémentation pour l'opération unaire.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Operand">
      <summary>Obtient l'opérande de l'opération unaire.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande de l'opération unaire.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Reduce">
      <summary>Réduit le nœud d'expression en une expression plus simple.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.UnaryExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis. Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <param name="operand">Propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> du résultat.</param>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
    </member>
    <member name="T:System.Linq.IOrderedQueryable">
      <summary>Représente le résultat d'une opération de tri.</summary>
    </member>
    <member name="T:System.Linq.IOrderedQueryable`1">
      <summary>Représente le résultat d'une opération de tri.</summary>
      <typeparam name="T">Le type de contenu de la source de données.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryable">
      <summary>Fournit les fonctionnalités permettant d'évaluer les requêtes appliquées à une source de données spécifique dont le type de données n'est pas défini.</summary>
    </member>
    <member name="P:System.Linq.IQueryable.ElementType">
      <summary>Obtient le type des éléments retournés lors de l'exécution de l'arborescence d'expression associée à cette instance de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>
        <see cref="T:System.Type" /> qui représente le type des éléments retournés lorsque l'arborescence d'expression associé à cet objet est exécutée.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Expression">
      <summary>Obtient l'arborescence d'expression associée à l'instance de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.Expression" /> associée à cette instance de l'interface <see cref="T:System.Linq.IQueryable" />.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Provider">
      <summary>Obtient le fournisseur de requêtes associé à cette source de données.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryProvider" /> associé à cette source de données.</returns>
    </member>
    <member name="T:System.Linq.IQueryable`1">
      <summary>Fournit les fonctionnalités permettant d'évaluer les requêtes appliquées à une source de données spécifique dont le type de données est connu.</summary>
      <typeparam name="T">Type des données contenues dans la source de données.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryProvider">
      <summary>Définit des méthodes destinées à créer et exécuter des requêtes décrites par un objet <see cref="T:System.Linq.IQueryable" />.</summary>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery(System.Linq.Expressions.Expression)">
      <summary>Construit un objet <see cref="T:System.Linq.IQueryable" /> capable d'évaluer la requête représentée par une arborescence d'expression spécifiée.</summary>
      <param name="expression">Arborescence d'expression qui représente une requête LINQ.</param>
      <returns>Objet <see cref="T:System.Linq.IQueryable" /> capable d'évaluer la requête représentée par l'arborescence d'expression spécifiée.</returns>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery``1(System.Linq.Expressions.Expression)">
      <summary>Construit un objet <see cref="T:System.Linq.IQueryable`1" /> capable d'évaluer la requête représentée par une arborescence d'expression spécifiée.</summary>
      <param name="expression">Arborescence d'expression qui représente une requête LINQ.</param>
      <typeparam name="TElement">Type des éléments du <see cref="T:System.Linq.IQueryable`1" /> retourné.</typeparam>
      <returns>Objet <see cref="T:System.Linq.IQueryable`1" /> capable d'évaluer la requête représentée par l'arborescence d'expression spécifiée.</returns>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute(System.Linq.Expressions.Expression)">
      <summary>Exécute la requête représentée par une arborescence d'expression spécifiée.</summary>
      <param name="expression">Arborescence d'expression qui représente une requête LINQ.</param>
      <returns>Valeur qui résulte de l'exécution de la requête spécifiée.</returns>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute``1(System.Linq.Expressions.Expression)">
      <summary>Exécute la requête fortement typée représentée par une arborescence d'expression spécifiée.</summary>
      <param name="expression">Arborescence d'expression qui représente une requête LINQ.</param>
      <typeparam name="TResult">Type de la valeur qui résulte de l'exécution de la requête.</typeparam>
      <returns>Valeur qui résulte de l'exécution de la requête spécifiée.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSite">
      <summary>Classe de base d'un site d'appel dynamique. Ce type est utilisé comme type de paramètre pour les cibles d'un site dynamique.</summary>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSite.Binder">
      <summary>Classe responsable de la liaison des opérations dynamiques sur le site dynamique.</summary>
      <returns>Objet <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> responsable de la liaison des opérations dynamiques.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSite.Create(System.Type,System.Runtime.CompilerServices.CallSiteBinder)">
      <summary>Crée un site d'appel à l'aide du type délégué et du binder donnés.</summary>
      <param name="delegateType">Type délégué du site d'appel.</param>
      <param name="binder">Binder du site d'appel.</param>
      <returns>Nouveau site d'appel.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSite`1">
      <summary>Type de site dynamique.</summary>
      <typeparam name="T">Type de délégué.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSite`1.Create(System.Runtime.CompilerServices.CallSiteBinder)">
      <summary>Crée une instance du site d'appel dynamique, initialisée à l'aide du binder responsable de la liaison au moment de l'exécution des opérations dynamiques sur ce site d'appel.</summary>
      <param name="binder">Binder responsable de la liaison au moment de l'exécution des opérations dynamiques sur ce site d'appel.</param>
      <returns>Nouvelle instance du site d'appel dynamique.</returns>
    </member>
    <member name="F:System.Runtime.CompilerServices.CallSite`1.Target">
      <summary>Cache de niveau 0 - Délégué spécialisé basé sur l'historique du site.</summary>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSite`1.Update">
      <summary>Délégué de mise à jour. Appelée lorsque le site dynamique rencontre des échecs dans le cache.</summary>
      <returns>Délégué de mise à jour.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSiteBinder">
      <summary>Classe responsable de la liaison au moment de l'exécution des opérations dynamiques sur le site d'appel dynamique.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.Bind(System.Object[],System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.LabelTarget)">
      <summary>Exécute la liaison au moment de l'exécution de l'opération dynamique sur un jeu d'arguments.</summary>
      <param name="args">Tableau d'arguments de l'opération dynamique.</param>
      <param name="parameters">Tableau des instances <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui représentent les paramètres du site d'appel dans le processus de liaison.</param>
      <param name="returnLabel">LabelTarget utilisé pour retourner le résultat de la liaison dynamique.</param>
      <returns>Expression qui exécute des tests sur les arguments d'opération dynamique, et exécute l'opération dynamique si les tests sont valides. Si les tests échouent sur les occurrences suivantes de l'opération dynamique, Bind est à nouveau appelé pour produire un nouveau <see cref="T:System.Linq.Expressions.Expression" /> pour les nouveaux types d'arguments.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.BindDelegate``1(System.Runtime.CompilerServices.CallSite{``0},System.Object[])">
      <summary>Fournit une prise en charge de bas niveau de la liaison au moment de l'exécution. Les classes peuvent substituer ceci et fournir un délégué direct pour l'implémentation de la règle. Cela permet d'enregistrer des règles sur disque, de disposer de règles spécialisées au moment de l'exécution ou de fournir une stratégie de mise en cache différente.</summary>
      <param name="site">CallSite pour lequel la liaison est exécutée.</param>
      <param name="args">Arguments du binder.</param>
      <typeparam name="T">Type cible de CallSite.</typeparam>
      <returns>Nouveau délégué qui remplace la cible de CallSite.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.CacheTarget``1(``0)">
      <summary>Ajoute une cible au cache des cibles connues. Les cibles mises en cache sont analysées avant d'appeler BindDelegate pour produire la nouvelle règle.</summary>
      <param name="target">Délégué cible à ajouter au cache.</param>
      <typeparam name="T">Type de cible ajouté.</typeparam>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSiteBinder.UpdateLabel">
      <summary>Obtient une étiquette qui peut être utilisée pour provoquer la mise à jour de la liaison. Indique que la liaison de l'expression n'est plus valide. Cela est utilisé en général lorsque la « version » d'un objet dynamique a changé.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.LabelTarget" /> représentant une étiquette qui peut être utilisée pour déclencher la mise à jour de la liaison.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSiteHelpers">
      <summary>Classe qui contient des méthodes d'assistance pour les CallSites DLR.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteHelpers.IsInternalFrame(System.Reflection.MethodBase)">
      <summary>Vérifie si <see cref="T:System.Reflection.MethodBase" /> est utilisé en interne par DLR et s'il ne doit pas être affiché dans la pile du code de langue.</summary>
      <param name="mb">
        <see cref="T:System.Reflection.MethodBase" /> d'entrée.</param>
      <returns>
        <see langword="true" /> si le <see cref="T:System.Reflection.MethodBase" /> d’entrée est utilisé de manière interne par DLR, et s’il ne doit pas être affiché dans la pile du code de langage. Sinon, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.DebugInfoGenerator">
      <summary>Génère des informations de débogage pour les expressions lambda dans une arborescence d’expression.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DebugInfoGenerator.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Runtime.CompilerServices.DebugInfoGenerator" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DebugInfoGenerator.CreatePdbGenerator">
      <summary>Crée un générateur de symboles de base de données de programme (PDB).</summary>
      <returns>Générateur de symboles PDB.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.DebugInfoGenerator.MarkSequencePoint(System.Linq.Expressions.LambdaExpression,System.Int32,System.Linq.Expressions.DebugInfoExpression)">
      <summary>Marque un point de séquence dans du code MSIL (Microsoft Intermediate Language).</summary>
      <param name="method">Expression lambda générée.</param>
      <param name="ilOffset">Décalage dans le code MSIL où marquer le point de séquence.</param>
      <param name="sequencePoint">Informations de débogage qui correspondent au point de séquence.</param>
    </member>
    <member name="T:System.Runtime.CompilerServices.DynamicAttribute">
      <summary>Indique que l'utilisation de <see cref="T:System.Object" /> sur un membre doit être traitée en tant que type distribué dynamiquement.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DynamicAttribute.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Runtime.CompilerServices.DynamicAttribute" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DynamicAttribute.#ctor(System.Boolean[])">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Runtime.CompilerServices.DynamicAttribute" />.</summary>
      <param name="transformFlags">Spécifie, dans le parcours d'un préfixe de la construction d'un type, que les occurrences de <see cref="T:System.Object" /> doivent être traitées en tant que type distribué dynamiquement.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.DynamicAttribute.TransformFlags">
      <summary>Spécifie, dans le parcours d'un préfixe de la construction d'un type, que les occurrences de <see cref="T:System.Object" /> doivent être traitées en tant que type distribué dynamiquement.</summary>
      <returns>Liste des occurrences de <see cref="T:System.Object" /> qui doivent être traitées en tant que type distribué dynamiquement.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.IRuntimeVariables">
      <summary>Représente les valeurs des variables au moment de l'exécution.</summary>
    </member>
    <member name="P:System.Runtime.CompilerServices.IRuntimeVariables.Count">
      <summary>Obtient le nombre des variables au moment de l'exécution.</summary>
      <returns>Nombre des variables au moment de l'exécution.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.IRuntimeVariables.Item(System.Int32)">
      <summary>Obtient la valeur de la variable au moment de l'exécution à l'index spécifié.</summary>
      <param name="index">Index de base zéro de la variable au moment de l'exécution dont la valeur doit être retournée.</param>
      <returns>Valeur de la variable au moment de l'exécution.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1">
      <summary>Générateur pour la collection en lecture seule.</summary>
      <typeparam name="T">Type de l'élément de la collection.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.#ctor">
      <summary>Construit un objet <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>Construit <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> en copiant le contenu de la collection donnée.</summary>
      <param name="collection">Collection à partir de laquelle copier les éléments.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.#ctor(System.Int32)">
      <summary>Construit <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> avec une capacité initiale donnée. Le contenu est vide mais le générateur réserve de l’espace pour un nombre donné d’éléments avant que des réallocations ne soient nécessaires.</summary>
      <param name="capacity">Capacité initiale.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Add(`0)">
      <summary>Ajoute un élément à <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <param name="item">Objet à ajouter à <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Capacity">
      <summary>Obtient ou définit la capacité de ce <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <returns>Capacité de ce <c>ReadOnlyCollectionBuilder.</c></returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Clear">
      <summary>Supprime tous les éléments de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Contains(`0)">
      <summary>Détermine si <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> contient une valeur spécifique.</summary>
      <param name="item">Objet à localiser dans <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
      <returns>
        <see langword="true" /> si l'élément est trouvé dans <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.CopyTo(`0[],System.Int32)">
      <summary>Copie les éléments de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> dans <see cref="T:System.Array" />, en commençant à un index particulier de <see cref="T:System.Array" />.</summary>
      <param name="array">
        <see cref="T:System.Array" /> unidimensionnel qui constitue la destination des éléments copiés à partir de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
      <param name="arrayIndex">Index de base zéro dans un tableau au niveau duquel commencer la copie.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Count">
      <summary>Obtient le nombre d’éléments dans <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <returns>Nombre d'éléments dans <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerator`1" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.IndexOf(`0)">
      <summary>Retourne l’index de la première occurrence d’une valeur donnée dans le générateur.</summary>
      <param name="item">Élément à rechercher.</param>
      <returns>Index de la première occurrence d’un élément.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Insert(System.Int32,`0)">
      <summary>Insère un élément dans <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> à l'index spécifié.</summary>
      <param name="index">Index de base zéro au niveau duquel l'élément doit être inséré.</param>
      <param name="item">Objet à insérer dans <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Item(System.Int32)">
      <summary>Obtient ou définit l'élément au niveau de l'index spécifié.</summary>
      <param name="index">Index de base zéro de l'élément à obtenir ou à définir.</param>
      <returns>Élément au niveau de l'index spécifié.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Remove(`0)">
      <summary>Supprime la première occurrence d'un objet spécifique de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <param name="item">Objet à supprimer de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
      <returns>
        <see langword="true" /> si l’élément a été correctement supprimé de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> ; sinon, false. Cette méthode retourne également false si l’élément est introuvable dans le <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> d’origine.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.RemoveAt(System.Int32)">
      <summary>Supprime l'élément <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> au niveau de l'index spécifié.</summary>
      <param name="index">Index de base zéro de l'élément à supprimer.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Reverse">
      <summary>Inverse l'ordre des éléments dans l'ensemble de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Reverse(System.Int32,System.Int32)">
      <summary>Inverse l'ordre des éléments dans la plage spécifiée.</summary>
      <param name="index">Index de début de base zéro de la plage à inverser.</param>
      <param name="count">Nombre d'éléments à inverser dans la plage.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
      <summary>Obtient une valeur indiquant si <see cref="T:System.Collections.Generic.ICollection`1" /> est en lecture seule.</summary>
      <returns>
        <see langword="true" /> si <see cref="T:System.Collections.Generic.ICollection`1" /> est en lecture seule ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <summary>Copie les éléments de <see cref="T:System.Collections.Generic.ICollection`1" /> dans un tableau, en commençant au niveau d'un index de tableau spécifié.</summary>
      <param name="array">Tableau unidimensionnel correspondant à la destination des éléments copiés à partir depuis <see cref="T:System.Collections.Generic.ICollection`1" />. Ce tableau doit avoir une indexation de base zéro.</param>
      <param name="index">Index de base zéro dans l'<paramref name="array" /> à partir duquel la copie commence.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#ICollection#IsSynchronized">
      <summary>Obtient une valeur indiquant si l'accès à <see cref="T:System.Collections.ICollection" /> est synchronisé (thread-safe).</summary>
      <returns>
        <see langword="true" /> si l'accès à <see cref="T:System.Collections.ICollection" /> est synchronisé (thread-safe) ; sinon <see langword="false" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#ICollection#SyncRoot">
      <summary>Obtient un objet qui peut être utilisé pour synchroniser l'accès à <see cref="T:System.Collections.ICollection" />.</summary>
      <returns>Objet qui peut être utilisé pour synchroniser l'accès à <see cref="T:System.Collections.ICollection" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
      <returns>
        <see cref="T:System.Collections.IEnumerator" /> qui peut être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Add(System.Object)">
      <summary>Ajoute un élément à <see cref="T:System.Collections.IList" />.</summary>
      <param name="value">
        <see cref="T:System.Object" /> à ajouter à <see cref="T:System.Collections.IList" />.</param>
      <returns>Position à laquelle le nouvel élément est inséré.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Contains(System.Object)">
      <summary>Détermine si <see cref="T:System.Collections.IList" /> contient une valeur spécifique.</summary>
      <param name="value">
        <see cref="T:System.Object" /> à rechercher dans <see cref="T:System.Collections.IList" />.</param>
      <returns>
        <see langword="true" /> si <paramref name="item" /> existe dans <see cref="T:System.Collections.IList" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#IndexOf(System.Object)">
      <summary>Détermine l'index d'un élément spécifique d'<see cref="T:System.Collections.IList" />.</summary>
      <param name="value">Objet à rechercher dans <see cref="T:System.Collections.IList" />.</param>
      <returns>Index de <paramref name="item" /> s'il figure dans la liste ; sinon, -1.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Insert(System.Int32,System.Object)">
      <summary>Insère un élément dans <see cref="T:System.Collections.IList" /> à l'index spécifié.</summary>
      <param name="index">Index de base zéro au niveau duquel <paramref name="item" /> doit être inséré.</param>
      <param name="value">Objet à insérer dans <see cref="T:System.Collections.IList" />.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#IsFixedSize">
      <summary>Obtient une valeur indiquant si <see cref="T:System.Collections.IList" /> est de taille fixe.</summary>
      <returns>
        <see langword="true" /> si <see cref="T:System.Collections.IList" /> est de taille fixe ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#IsReadOnly">
      <summary>Obtient une valeur indiquant si <see cref="T:System.Collections.IList" /> est en lecture seule.</summary>
      <returns>
        <see langword="true" /> si <see cref="T:System.Collections.IList" /> est en lecture seule ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Item(System.Int32)">
      <summary>Obtient ou définit l'élément au niveau de l'index spécifié.</summary>
      <param name="index">Index de base zéro de l'élément à obtenir ou à définir.</param>
      <returns>Élément au niveau de l'index spécifié.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Remove(System.Object)">
      <summary>Supprime la première occurrence d'un objet spécifique de <see cref="T:System.Collections.IList" />.</summary>
      <param name="value">Objet à supprimer de <see cref="T:System.Collections.IList" />.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.ToArray">
      <summary>Copie les éléments de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> dans un nouveau tableau.</summary>
      <returns>Tableau contenant les copies des éléments de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.ToReadOnlyCollection">
      <summary>Crée un <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> qui contient tous les éléments de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />, en évitant si possible de copier les éléments vers le nouveau tableau. Réinitialise <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> après la création de <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</summary>
      <returns>Nouvelle instance de <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.RuleCache`1">
      <summary>Représente un cache des règles de liaison au moment de l'exécution.</summary>
      <typeparam name="T">Type de délégué.</typeparam>
    </member>
  </members>
</doc>