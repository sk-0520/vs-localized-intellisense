<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Memory</name>
  </assembly>
  <members>
    <member name="T:System.Buffers.ArrayBufferWriter`1">
      <summary>Stellt eine heapbasierte, arraygesicherte Ausgabesenke dar, in die <typeparam name="T" /> Daten geschrieben werden können.</summary>
      <typeparam name="T">Der Typ der Elemente in dieser <see cref="T:System.Buffers.ArrayBufferWriter`1" /> Instanz.</typeparam>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.#ctor">
      <summary>Erstellt eine <see cref="T:System.Buffers.ArrayBufferWriter`1" />-Instanz, in die Daten geschrieben werden können, mit der standardmäßigen Anfangskapazität.</summary>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.#ctor(System.Int32)">
      <summary>Erstellt eine <see cref="T:System.Buffers.ArrayBufferWriter`1" />-Instanz, in die Daten geschrieben werden können, mit einer angegebenen Anfangskapazität.</summary>
      <param name="initialCapacity">Die Mindestkapazität zum Initialisieren der zugrunde liegenden Puffer.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="initialCapacity" /> ist kleiner oder gleich 0.</exception>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.Advance(System.Int32)">
      <summary>Teilt <see cref="T:System.Buffers.IBufferWriter`1" /> mit, dass <paramref name="count" /> Elemente in die Ausgabe <see cref="T:System.Span`1" />/<see cref="T:System.Memory`1" /> geschrieben wurden.</summary>
      <param name="count">Die Anzahl der geschriebenen Elemente.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="count" /> ist ein negativer Wert.</exception>
      <exception cref="T:System.InvalidOperationException">Der Methodenaufruf versucht, hinter das Ende des zugrunde liegenden Puffer zu gelangen.</exception>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.Capacity">
      <summary>Ruft die Gesamtmenge des Speicherplatzes im zugrunde liegenden Puffer ab.</summary>
      <returns>Die Gesamtkapazität des zugrunde liegenden Puffers.</returns>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.Clear">
      <summary>Löscht die in den zugrunde liegenden Puffer geschriebenen Daten.</summary>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.FreeCapacity">
      <summary>Ruft die Menge des verfügbaren Speicherplatzes ab, in den geschrieben werden kann, ohne dass der zugrunde liegende Puffer gezwungen wird, zu wachsen.</summary>
      <returns>Der zum Schreiben verfügbare Speicherplatz, ohne dass der zugrunde liegende Puffer vergrößert werden soll.</returns>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.GetMemory(System.Int32)">
      <summary>Gibt ein <see cref="T:System.Memory`1" />-Element zurück, in das geschrieben werden kann, das mindestens die durch <paramref name="sizeHint" /> angegebene Länge aufweist.</summary>
      <param name="sizeHint">Die mindestens angeforderte Länge von <see cref="T:System.Memory`1" />.</param>
      <returns>Ein <see cref="T:System.Memory`1" />-Element, dessen Länge mindestens <paramref name="sizeHint" /> beträgt.  Wenn <paramref name="sizeHint" /> nicht angegeben oder gleich null (0) ist, wird ein nicht leerer Puffer zurückgegeben.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="sizeHint" /> ist ein negativer Wert.</exception>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.GetSpan(System.Int32)">
      <summary>Gibt ein <see cref="T:System.Span`1" />-Element zurück, in das geschrieben werden kann, das mindestens die angegebene Länge aufweist.</summary>
      <param name="sizeHint">Die mindestens angeforderte Länge von <see cref="T:System.Span`1" />.</param>
      <returns>Eine Spanne mit einer Länge von mindestens <paramref name="sizeHint" />. Wenn <paramref name="sizeHint" /> nicht angegeben oder gleich null (0) ist, wird ein nicht leerer Puffer zurückgegeben.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="sizeHint" /> ist ein negativer Wert.</exception>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenCount">
      <summary>Ruft die Menge der in den zugrunde liegenden Puffer geschriebenen Daten ab.</summary>
      <returns>Die Menge der Daten, die in den zugrunde liegenden Puffer geschrieben werden.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenMemory">
      <summary>Ruft ein <see cref="T:System.ReadOnlyMemory`1" />-Element ab, das die bisher in den zugrunde liegenden Puffer geschriebenen Daten enthält.</summary>
      <returns>Die Daten, die in den zugrunde liegenden Puffer geschrieben werden.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenSpan">
      <summary>Ruft ein <see cref="T:System.ReadOnlySpan`1" />-Element auf, das die bisher in den zugrunde liegenden Puffer geschriebenen Daten enthält.</summary>
      <returns>Die Daten, die in den zugrunde liegenden Puffer geschrieben werden.</returns>
    </member>
    <member name="T:System.Buffers.Binary.BinaryPrimitives">
      <summary>Liest Bytes als primitive Werte mit einer bestimmten Bytereihenfolge</summary>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Liest eine <see cref="T:System.Int16" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source">Der zu lesende schreibgeschützte Bereich</param>
      <returns>Der big-endian-Wert</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.Int16" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Liest eine <see cref="T:System.Int16" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source">Der zu lesende schreibgeschützte Bereich</param>
      <returns>Der Little-Endian-Wert</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.Int16" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Liest eine <see cref="T:System.Int32" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source">Der zu lesende schreibgeschützte Bereich</param>
      <returns>Der big-endian-Wert</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.Int32" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Liest eine <see cref="T:System.Int32" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source">Der zu lesende schreibgeschützte Bereich</param>
      <returns>Der Little-Endian-Wert</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.Int32" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Liest eine <see cref="T:System.Int64" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source">Der zu lesende schreibgeschützte Bereich</param>
      <returns>Der big-endian-Wert</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.Int64" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Liest eine <see cref="T:System.Int64" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source">Der zu lesende schreibgeschützte Bereich</param>
      <returns>Der Little-Endian-Wert</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.Int64" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Liest eine <see cref="T:System.UInt16" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source">Der zu lesende schreibgeschützte Bereich</param>
      <returns>Der big-endian-Wert</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.UInt16" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Liest eine <see cref="T:System.UInt16" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source">Der zu lesende schreibgeschützte Bereich</param>
      <returns>Der Little-Endian-Wert</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.UInt16" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Liest eine <see cref="T:System.UInt32" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source">Der zu lesende schreibgeschützte Bereich</param>
      <returns>Der big-endian-Wert</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.UInt32" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Liest eine <see cref="T:System.UInt32" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <returns>Der Little-Endian-Wert</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.UInt32" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Liest eine <see cref="T:System.UInt64" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <returns>Der big-endian-Wert</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.UInt64" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Liest eine <see cref="T:System.UInt64" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <returns>Der Little-Endian-Wert</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> ist zu klein für eine <see cref="T:System.UInt64" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Byte)">
      <summary>Kehrt einen primitiven Wert um, indem die Bytereihenfolge des angegebenen <see cref="T:System.Byte" />-Werts geändert wird, der nicht für eine <see cref="T:System.Byte" />-Struktur benötigt wird</summary>
      <param name="value">Der umzukehrende Wert</param>
      <returns>Der übergebene Wert in unveränderter Form</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int16)">
      <summary>Kehrt einen primitiven Wert um, indem die Bytereihenfolge des angegebenen <see cref="T:System.Int16" />-Werts geändert wird</summary>
      <param name="value">Der umzukehrende Wert</param>
      <returns>Der umgekehrte Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int32)">
      <summary>Kehrt einen primitiven Wert um, indem die Bytereihenfolge des angegebenen <see cref="T:System.Int32" />-Werts geändert wird</summary>
      <param name="value">Der umzukehrende Wert</param>
      <returns>Der umgekehrte Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int64)">
      <summary>Kehrt einen primitiven Wert um, indem die Bytereihenfolge des angegebenen <see cref="T:System.Int64" />-Werts geändert wird</summary>
      <param name="value">Der umzukehrende Wert</param>
      <returns>Der umgekehrte Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.SByte)">
      <summary>Kehrt einen primitiven Wert um, indem die Bytereihenfolge des angegebenen <see cref="T:System.SByte" />-Werts geändert wird, der nicht für eine <see cref="T:System.SByte" />-Struktur benötigt wird</summary>
      <param name="value">Der umzukehrende Wert</param>
      <returns>Der übergebene Wert in unveränderter Form</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt16)">
      <summary>Kehrt einen primitiven Wert um, indem die Bytereihenfolge des angegebenen <see cref="T:System.UInt16" />-Werts geändert wird</summary>
      <param name="value">Der umzukehrende Wert</param>
      <returns>Der umgekehrte Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt32)">
      <summary>Kehrt einen primitiven Wert um, indem die Bytereihenfolge des angegebenen <see cref="T:System.UInt32" />-Werts geändert wird</summary>
      <param name="value">Der umzukehrende Wert</param>
      <returns>Der umgekehrte Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt64)">
      <summary>Kehrt einen primitiven Wert um, indem die Bytereihenfolge des angegebenen <see cref="T:System.UInt64" />-Werts geändert wird</summary>
      <param name="value">Der umzukehrende Wert</param>
      <returns>Der umgekehrte Wert</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16BigEndian(System.ReadOnlySpan{System.Byte},System.Int16@)">
      <summary>Liest eine <see cref="T:System.Int16" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als big-endian-Wert gelesen.</param>
      <returns>
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int16" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.Int16@)">
      <summary>Liest eine <see cref="T:System.Int16" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als Little-Endian-Wert gelesen.</param>
      <returns>
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int16" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32BigEndian(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Liest eine <see cref="T:System.Int32" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als big-endian-Wert gelesen.</param>
      <returns>
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int32" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Liest eine <see cref="T:System.Int32" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als Little-Endian-Wert gelesen.</param>
      <returns>
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int32" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64BigEndian(System.ReadOnlySpan{System.Byte},System.Int64@)">
      <summary>Liest eine <see cref="T:System.Int64" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als big-endian-Wert gelesen.</param>
      <returns>
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int64" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.Int64@)">
      <summary>Liest eine <see cref="T:System.Int64" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als Little-Endian-Wert gelesen.</param>
      <returns>
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int64" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16BigEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)">
      <summary>Liest eine <see cref="T:System.UInt16" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als big-endian-Wert gelesen.</param>
      <returns>
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt16" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)">
      <summary>Liest eine <see cref="T:System.UInt16" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als Little-Endian-Wert gelesen.</param>
      <returns>
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt16" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32BigEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)">
      <summary>Liest eine <see cref="T:System.UInt32" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als big-endian-Wert gelesen.</param>
      <returns>
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt32" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)">
      <summary>Liest eine <see cref="T:System.UInt32" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als Little-Endian-Wert gelesen.</param>
      <returns>
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt32" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64BigEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)">
      <summary>Liest eine <see cref="T:System.UInt64" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</summary>
      <param name="source">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als big-endian-Wert gelesen.</param>
      <returns>
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt64" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)">
      <summary>Liest eine <see cref="T:System.UInt64" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</summary>
      <param name="source">Der schreibgeschützte Bereich der zu lesenden Bytes</param>
      <param name="value">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als Little-Endian-Wert gelesen.</param>
      <returns>
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt64" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16BigEndian(System.Span{System.Byte},System.Int16)">
      <summary>Schreibt eine <see cref="T:System.Int16" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns>
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int16" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16LittleEndian(System.Span{System.Byte},System.Int16)">
      <summary>Schreibt eine <see cref="T:System.Int16" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns>
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int16" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32BigEndian(System.Span{System.Byte},System.Int32)">
      <summary>Schreibt eine <see cref="T:System.Int32" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns>
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int32" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32LittleEndian(System.Span{System.Byte},System.Int32)">
      <summary>Schreibt eine <see cref="T:System.Int32" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns>
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int32" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64BigEndian(System.Span{System.Byte},System.Int64)">
      <summary>Schreibt eine <see cref="T:System.Int64" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns>
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int64" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64LittleEndian(System.Span{System.Byte},System.Int64)">
      <summary>Schreibt eine <see cref="T:System.Int64" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns>
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int64" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)">
      <summary>Schreibt eine <see cref="T:System.UInt16" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns>
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt16" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)">
      <summary>Schreibt eine <see cref="T:System.UInt16" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns>
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt16" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)">
      <summary>Schreibt eine <see cref="T:System.UInt32" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns>
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt32" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)">
      <summary>Schreibt eine <see cref="T:System.UInt32" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns>
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt32" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)">
      <summary>Schreibt eine <see cref="T:System.UInt64" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns>
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt64" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)">
      <summary>Schreibt eine <see cref="T:System.UInt64" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <returns>
        <see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt64" />-Struktur ist; andernfalls <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16BigEndian(System.Span{System.Byte},System.Int16)">
      <summary>Schreibt eine <see cref="T:System.Int16" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.Int16" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16LittleEndian(System.Span{System.Byte},System.Int16)">
      <summary>Schreibt eine <see cref="T:System.Int16" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.Int16" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32BigEndian(System.Span{System.Byte},System.Int32)">
      <summary>Schreibt eine <see cref="T:System.Int32" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.Int32" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32LittleEndian(System.Span{System.Byte},System.Int32)">
      <summary>Schreibt eine <see cref="T:System.Int32" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.Int32" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64BigEndian(System.Span{System.Byte},System.Int64)">
      <summary>Schreibt eine <see cref="T:System.Int64" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.Int64" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64LittleEndian(System.Span{System.Byte},System.Int64)">
      <summary>Schreibt eine <see cref="T:System.Int64" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.Int64" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)">
      <summary>Schreibt eine <see cref="T:System.UInt16" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.UInt16" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)">
      <summary>Schreibt eine <see cref="T:System.UInt16" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.UInt16" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)">
      <summary>Schreibt eine <see cref="T:System.UInt32" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.UInt32" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)">
      <summary>Schreibt eine <see cref="T:System.UInt32" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.UInt32" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)">
      <summary>Schreibt eine <see cref="T:System.UInt64" />-Struktur als big-endian-Wert in einen Bytebereich</summary>
      <param name="destination">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</param>
      <param name="value">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.UInt64" />-Struktur.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)">
      <summary>Schreibt eine <see cref="T:System.UInt64" />-Struktur als Little-Endian-Wert in einen Bytebereich</summary>
      <param name="destination">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</param>
      <param name="value">Der Wert, der in den Bytebereich geschrieben werden soll</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> ist zu klein für eine <see cref="T:System.UInt64" />-Struktur.</exception>
    </member>
    <member name="T:System.Buffers.BuffersExtensions">
      <summary>Stellt Erweiterungsmethoden für <see cref="T:System.Buffers.ReadOnlySequence`1" /> bereit.</summary>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.CopyTo``1(System.Buffers.ReadOnlySequence{``0},System.Span{``0})">
      <summary>Kopiert die <see cref="T:System.Buffers.ReadOnlySequence`1" /> in die angegebene <see cref="T:System.Span`1" />.</summary>
      <param name="source">Der Quell-<see cref="T:System.Buffers.ReadOnlySequence`1" />.</param>
      <param name="destination">Das Ziel-<see cref="T:System.Span`1" />.</param>
      <typeparam name="T">Der Typ der Elemente in der <see cref="T:System.Buffers.ReadOnlySequence`1" />.</typeparam>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.PositionOf``1(System.Buffers.ReadOnlySequence{``0},``0)">
      <summary>Gibt die Position des ersten Vorkommens von <paramref name="item" /> in der <see cref="T:System.Buffers.ReadOnlySequence`1" /> zurück.</summary>
      <param name="source">Der Quell-<see cref="T:System.Buffers.ReadOnlySequence`1" />.</param>
      <param name="value">Das in <see cref="T:System.Buffers.ReadOnlySequence`1" /> zu suchende Element.</param>
      <typeparam name="T">Der Typ der Elemente in der <see cref="T:System.Buffers.ReadOnlySequence`1" />.</typeparam>
      <returns>Ein Objekt, dessen <see cref="M:System.SequencePosition.GetInteger" />-Methode die Position des ersten Vorkommens von <paramref name="item" /> zurückgibt, oder ein Objekt, dessen <see langword="Nullable&lt;SequencePosition&gt;.HasValue" />-Eigenschaft <see langword="false" /> ist.</returns>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.ToArray``1(System.Buffers.ReadOnlySequence{``0})">
      <summary>Konvertiert die <see cref="T:System.Buffers.ReadOnlySequence`1" /> in ein Array.</summary>
      <param name="sequence">Die schreibgeschützte Sequenz, die in ein Array konvertiert werden soll.</param>
      <typeparam name="T">Der Typ der Elemente in der <see cref="T:System.Buffers.ReadOnlySequence`1" />.</typeparam>
      <returns>Ein Array das die Daten der aktuellen schreibgeschützten Sequenz enthält.</returns>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.Write``1(System.Buffers.IBufferWriter{``0},System.ReadOnlySpan{``0})">
      <summary>Schreibt den Inhalt von <paramref name="value" /> in <paramref name="writer" />.</summary>
      <param name="writer">Der Pufferwriter, in den <paramref name="value" /> geschrieben werden soll.</param>
      <param name="value">Der schreibgeschützte Bereich, der in <paramref name="writer" /> geschrieben werden soll.</param>
      <typeparam name="T">Der Typ der Elemente in der <see cref="T:System.ReadOnlySpan`1" />.</typeparam>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="writer" /> ist kürzer als <paramref name="value" />.</exception>
    </member>
    <member name="T:System.Buffers.IBufferWriter`1">
      <summary>Stellt eine Ausgabesenke dar, in die <typeparamref name="T" />-Daten geschrieben werden können.</summary>
      <typeparam name="T">Der Typ der Elemente in der <see cref="T:System.Buffers.IBufferWriter`1" />.</typeparam>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.Advance(System.Int32)">
      <summary>Teilt <see cref="T:System.Buffers.IBufferWriter`1" /> mit, dass <paramref name="count" /> Datenelemente in die Ausgabe <see cref="T:System.Span`1" /> oder <see cref="T:System.Memory`1" /> geschrieben wurden.</summary>
      <param name="count">Die Anzahl der in <see cref="T:System.Span`1" /> oder <see cref="T:System.Memory`1" /> geschriebenen Datenelemente.</param>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.GetMemory(System.Int32)">
      <summary>Gibt ein <see cref="T:System.Memory`1" />-Element zum Zurückschreiben zurück, das mindestens die angeforderte (von <paramref name="sizeHint" /> angegebene) Größe aufweist.</summary>
      <param name="sizeHint">Die Mindestlänge des zurückgegebenen <see cref="T:System.Memory`1" />-Elements. Wenn dieser Wert 0 lautet, wird ein nicht leerer Puffer zurückgegeben.</param>
      <returns>Ein <see cref="T:System.Memory`1" />-Element, dessen Größe mindestens <paramref name="sizeHint" /> beträgt. Gibt einen nicht leeren Puffer zurück, wenn <paramref name="sizeHint" /> 0 ist.</returns>
      <exception cref="T:System.OutOfMemoryException">Die angeforderte Puffergröße ist nicht verfügbar.</exception>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)">
      <summary>Gibt ein <see cref="T:System.Span`1" />-Element zum Zurückschreiben zurück, das mindestens die angeforderte (von <paramref name="sizeHint" /> angegebene) Größe aufweist.</summary>
      <param name="sizeHint">Die Mindestlänge des zurückgegebenen <see cref="T:System.Span`1" />-Elements. Wenn dieser Wert 0 lautet, wird ein nicht leerer Puffer zurückgegeben.</param>
      <returns>Ein <see cref="T:System.Span`1" />-Element, dessen Größe mindestens <paramref name="sizeHint" /> beträgt. Gibt einen nicht leeren Puffer zurück, wenn <paramref name="sizeHint" /> 0 ist.</returns>
    </member>
    <member name="T:System.Buffers.MemoryPool`1">
      <summary>Stellt einen Pool von Speicherblöcken dar.</summary>
      <typeparam name="T">Der Typ der Elemente im Speicherpool.</typeparam>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.#ctor">
      <summary>Erstellt eine neue Instanz eines Speicherpools.</summary>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Dispose">
      <summary>Gibt alle vom Speicherpool verwendeten Ressourcen frei.</summary>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Dispose(System.Boolean)">
      <summary>Gibt die vom Speicherpool verwendeten nicht verwalteten Ressourcen und optional auch die verwalteten Ressourcen frei.</summary>
      <param name="disposing">
        <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, , um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
    </member>
    <member name="P:System.Buffers.MemoryPool`1.MaxBufferSize">
      <summary>Ruft die maximale Puffergröße ab, die von diesem Pool unterstützt wird.</summary>
      <returns>Die maximale Puffergröße, die von diesem Pool unterstützt wird.</returns>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Rent(System.Int32)">
      <summary>Gibt einen Speicherblock zurück, der mindestens <paramref name="minBufferSize" /> Elemente von T aufnehmen kann.</summary>
      <param name="minBufferSize">Die minimale Anzahl von Elementen von <typeparamref name="T" />, die der Speicherpool enthalten kann. Der Wert -1 gibt einen Speicherpool zurück, der auf die Standardgröße für den Pool festgelegt ist.</param>
      <returns>Ein Speicherblock, der mindestens <paramref name="minBufferSize" /> Elemente von T aufnehmen kann.</returns>
    </member>
    <member name="P:System.Buffers.MemoryPool`1.Shared">
      <summary>Ruft eine Singletoninstanz eines Speicherpools basierend auf Arrays ab.</summary>
      <returns>Eine Singleton Instanz eines Speicherpools.</returns>
    </member>
    <member name="T:System.Buffers.OperationStatus">
      <summary>Definiert die Werte, die von bereichsbasierten Vorgängen zurückgegeben werden können, die die Verarbeitung der Eingabe unterstützen, die in mehreren nicht zusammenhängenden Puffern enthalten ist.</summary>
    </member>
    <member name="F:System.Buffers.OperationStatus.DestinationTooSmall">
      <summary>Die Eingabe wird teilweise verarbeitet, bis zu dem, was in den Zielpuffer passt. Der Aufrufer kann den Zielpuffer vergrößern, die Puffer entsprechend segmentieren, und es erneut versuchen.</summary>
    </member>
    <member name="F:System.Buffers.OperationStatus.Done">
      <summary>Der gesamte Eingabepuffer wurde verarbeitet, und der Vorgang ist abgeschlossen.</summary>
    </member>
    <member name="F:System.Buffers.OperationStatus.InvalidData">
      <summary>Die Eingabe enthält ungültige Bytes, die nicht verarbeitet werden konnten. Wenn die Eingabe teilweise verarbeitet wird, enthält das Ziel das Teilergebnis. Dadurch wird sichergestellt, dass keine zusätzlichen Daten, die der Eingabe angefügt werden, die ungültige Sequenz gültig machen.</summary>
    </member>
    <member name="F:System.Buffers.OperationStatus.NeedMoreData">
      <summary>Die Eingabe ist teilweise verarbeitet, bis zum letzten gültigen Block der Eingabe, der genutzt werden konnte. Der Aufrufer kann die verbleibende nicht verarbeitete Eingabe mit mehr Daten zusammenfügen, die Puffer entsprechend segmentieren, und es erneut versuchen.</summary>
    </member>
    <member name="T:System.Buffers.ReadOnlySequence`1">
      <summary>Stellt eine Sequenz dar, die eine sequenzielle Reihe von <typeparamref name="T" /> lesen kann.</summary>
      <typeparam name="T" />
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[])">
      <summary>Erstellt eine Instanz von <see cref="T:System.Buffers.ReadOnlySequence`1" /> aus <paramref name="array" />.</summary>
      <param name="array">Das Array, aus dem eine schreibgeschützte Sequenz erstellt werden soll.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[],System.Int32,System.Int32)">
      <summary>Erstellt eine Instanz einer <see cref="T:System.Buffers.ReadOnlySequence`1" /> aus einem Abschnitt eines Arrays.</summary>
      <param name="array">Das Array, aus dem die schreibgeschützte Sequenz erstellt werden soll.</param>
      <param name="start">Der nullbasierte (0) Index des ersten Elements im Array, das in die schreibgeschützte Sequenz eingeschlossen werden soll.</param>
      <param name="length">Die Anzahl von Elementen, die in die schreibgeschützte Sequenz eingeschlossen werden sollen.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.Buffers.ReadOnlySequenceSegment{`0},System.Int32,System.Buffers.ReadOnlySequenceSegment{`0},System.Int32)">
      <summary>Erstellt eine Instanz einer <see cref="T:System.Buffers.ReadOnlySequence`1" /> aus einer verknüpften Speicherliste, die durch Start- und Endsegmente und die entsprechenden Indizes darin dargestellt wird.</summary>
      <param name="startSegment" />
      <param name="startIndex" />
      <param name="endSegment" />
      <param name="endIndex" />
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.ReadOnlyMemory{`0})">
      <summary>Erstellt eine Instanz von <see cref="T:System.Buffers.ReadOnlySequence`1" /> aus <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <param name="memory" />
    </member>
    <member name="F:System.Buffers.ReadOnlySequence`1.Empty">
      <summary>Gibt eine leere <see cref="T:System.Buffers.ReadOnlySequence`1" /> zurück.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.End">
      <summary>Ruft die Position am Ende der <see cref="T:System.Buffers.ReadOnlySequence`1" /> ab.</summary>
    </member>
    <member name="T:System.Buffers.ReadOnlySequence`1.Enumerator">
      <summary>Stellt ein Enumeratorobjekt über einer <see cref="T:System.Buffers.ReadOnlySequence`1" /> dar.</summary>
      <typeparam name="T" />
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.#ctor(System.Buffers.ReadOnlySequence{`0}@)">
      <summary>Initialisiert den Enumerator.</summary>
      <param name="sequence">Die aufzulistende <see cref="T:System.Buffers.ReadOnlySequence`1" />.</param>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Enumerator.Current">
      <summary>Ruft den aktuellen <see cref="T:System.ReadOnlyMemory`1" /> ab.</summary>
      <returns>Der aktuelle <see cref="T:System.ReadOnlyMemory`1" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.MoveNext">
      <summary>Wechselt zum nächsten <see cref="T:System.ReadOnlyMemory`1" /> in der <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <returns>
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element festgelegt wurde; <see langword="false" />, wenn das Ende der Sequenz erreicht wurde.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.First">
      <summary>Ruft das <see cref="T:System.ReadOnlyMemory`1" /> aus dem ersten Segment ab.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.FirstSpan">
      <summary>Ruft das <see cref="T:System.ReadOnlySpan`1" /> aus dem ersten Segment ab.</summary>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetEnumerator">
      <summary>Gibt einen Enumerator über die <see cref="T:System.Buffers.ReadOnlySequence`1" /> zurück.</summary>
      <returns>Gibt einen Enumerator über die <see cref="T:System.Buffers.ReadOnlySequence`1" /> zurück.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64)">
      <summary>Gibt eine neue <see cref="T:System.SequencePosition" /> an einem <paramref name="offset" /> ab dem Anfang der Sequenz zurück.</summary>
      <param name="offset" />
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64,System.SequencePosition)">
      <summary>Gibt eine neue <see cref="T:System.SequencePosition" /> an einem <paramref name="offset" /> aus <paramref name="origin" /> zurück.</summary>
      <param name="offset" />
      <param name="origin" />
      <returns>Ein neues Objekt, das an der <paramref name="offset" />-Position des ursprünglichen Objekts beginnt.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.IsEmpty">
      <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Buffers.ReadOnlySequence`1" /> leer ist.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.IsSingleSegment">
      <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Buffers.ReadOnlySequence`1" /> ein einzelnes <see cref="T:System.ReadOnlyMemory`1" />-Segment enthält.</summary>
      <returns>
        <see langword="true" />, wenn die schreibgeschützte Sequenz leer ist. <see langword="false" />andernfalls.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Length">
      <summary>Ruft die Länge der <see cref="T:System.Buffers.ReadOnlySequence`1" /> ab.</summary>
      <returns>Die Länge der schreibgeschützten Sequenz.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.Int32)">
      <summary>Bildet einen Slice aus der aktuellen <see cref="T:System.Buffers.ReadOnlySequence`1" />, beginnend bei <paramref name="start" />, mit <paramref name="length" /> Elementen.</summary>
      <param name="start">Der Index, an dem dieser Slice beginnen soll.</param>
      <param name="length">Die Länge des Slices.</param>
      <returns>Ein Slice, der aus <paramref name="length" /> Elementen der aktuellen Instanz besteht, beginnend bei Index <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.SequencePosition)">
      <summary>Bildet einen Slice aus der aktuellen <see cref="T:System.Buffers.ReadOnlySequence`1" />, beginnend bei <paramref name="start" /> und endend bei <paramref name="end" /> (exklusiv).</summary>
      <param name="start">Der Index, an dem dieser Slice beginnen soll.</param>
      <param name="end">Das Ende (exklusiv) <see cref="T:System.SequencePosition" /> des Slices.</param>
      <returns>Ein Slice, der aus Elementen aus dem <paramref name="start" />-Index besteht, aber nicht die Sequenzposition <paramref name="end" /> in der aktuellen schreibgeschützten Sequenz einschließt.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64)">
      <summary>Bildet einen Slice aus der aktuellen <see cref="T:System.Buffers.ReadOnlySequence`1" />, beginnend am angegebenen Index und bis zum Ende der schreibgeschützten Sequenz fortgesetzt.</summary>
      <param name="start">Der Startindex, an dem dieser Slice beginnen soll.</param>
      <returns>Ein Slice, der bei Index <paramref name="start" /> beginnt und bis zum Ende der schreibgeschützten Sequenz reicht.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.Int64)">
      <summary>Bildet einen Slice aus der vorgegebenen <see cref="T:System.Buffers.ReadOnlySequence`1" />, beginnend bei <paramref name="start" />, mit <paramref name="length" /> Elementen.</summary>
      <param name="start">Der Index, an dem dieser Slice beginnen soll.</param>
      <param name="length">Die Länge des Slices.</param>
      <returns>Ein Slice, der aus <paramref name="length" /> Elementen der aktuellen Instanz besteht, beginnend bei Index <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.SequencePosition)">
      <summary>Bildet einen Slice aus der aktuellen <see cref="T:System.Buffers.ReadOnlySequence`1" />, beginnend bei <paramref name="start" /> und endend bei <paramref name="end" /> (exklusiv).</summary>
      <param name="start">Der Index, an dem dieser Slice beginnen soll.</param>
      <param name="end">Das Ende (exklusiv) des Slices.</param>
      <returns>Ein Slice, der aus Elementen aus dem <paramref name="start" />-Index besteht, aber nicht die Sequenzposition <paramref name="end" /> in der aktuellen schreibgeschützten Sequenz einschließt.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition)">
      <summary>Bildet einen Slice aus der aktuellen <see cref="T:System.Buffers.ReadOnlySequence`1" />, beginnend an der angegebenen Sequenzposition und bis zum Ende der schreibgeschützten Sequenz reichend.</summary>
      <param name="start">Die <see cref="T:System.SequencePosition" /> (inklusiv) des Beginns dieses Slices.</param>
      <returns>Ein Slice, der bei Sequenzposition <paramref name="start" /> beginnt und bis zum Ende der schreibgeschützten Sequenz reicht.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int32)">
      <summary>Bildet einen Slice aus der aktuellen <see cref="T:System.Buffers.ReadOnlySequence`1" />, beginnend bei <paramref name="start" />, mit <paramref name="length" /> Elementen.</summary>
      <param name="start">Die <see cref="T:System.SequencePosition" /> (inklusiv) des Beginns dieses Slices.</param>
      <param name="length">Die Länge des Slices.</param>
      <returns>Ein Slice, der aus <paramref name="length" /> Elementen der aktuellen Instanz besteht, beginnend bei Sequenzposition <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int64)">
      <summary>Bildet einen Slice aus der aktuellen <see cref="T:System.Buffers.ReadOnlySequence`1" />, beginnend bei <paramref name="start" />, mit <paramref name="length" /> Elementen.</summary>
      <param name="start">Die <see cref="T:System.SequencePosition" /> (inklusiv) des Beginns dieses Slices.</param>
      <param name="length">Die Länge des Slices.</param>
      <returns>Ein Slice, der aus <paramref name="length" /> Elementen der aktuellen Instanz besteht, beginnend bei Sequenzposition <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.SequencePosition)">
      <summary>Bildet einen Slice aus der aktuellen <see cref="T:System.Buffers.ReadOnlySequence`1" />, beginnend bei <paramref name="start" /> und endend bei <paramref name="end" /> (exklusiv).</summary>
      <param name="start">Die <see cref="T:System.SequencePosition" /> (inklusiv) des Beginns dieses Slices.</param>
      <param name="end">Das Ende (exklusiv) <see cref="T:System.SequencePosition" /> des Slices.</param>
      <returns>Ein Slice, der aus Elementen von der <paramref name="start" />-Sequenzposition bis zur <paramref name="end" />-Sequenzposition, diese aber nicht einschließend, in der aktuellen schreibgeschützten Sequenz besteht.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Start">
      <summary>Ruft die Position, an den Anfang der <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.ToString" />
    <member name="M:System.Buffers.ReadOnlySequence`1.TryGet(System.SequencePosition@,System.ReadOnlyMemory{`0}@,System.Boolean)">
      <summary>Damit wird versucht, das nächste Segment nach <paramref name="position" /> abzurufen, und es wird ein Wert zurückgegeben, der angibt, ob der Vorgang erfolgreich war.</summary>
      <param name="position">Die aktuelle Sequenzposition.</param>
      <param name="memory">Ein Bereich von schreibgeschütztem Speicher, der das nächste Segment nach <paramref name="position" /> enthält.</param>
      <param name="advance">
        <see langword="true" />, wenn <paramref name="position" /> am Anfang des nächsten Segments liegen sollte; anderenfalls <see langword="false" />.</param>
      <returns>Gibt <see langword="true" /> zurück, wenn die Methode das nächste Segment zurückgegeben hat, oder <see langword="false" />, wenn das Ende der schreibgeschützten Sequenz erreicht wurde.</returns>
    </member>
    <member name="T:System.Buffers.ReadOnlySequenceSegment`1">
      <summary>Stellt eine verknüpfte Liste von <see cref="T:System.ReadOnlyMemory`1" />-Knoten dar.</summary>
      <typeparam name="T" />
    </member>
    <member name="M:System.Buffers.ReadOnlySequenceSegment`1.#ctor" />
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Memory">
      <summary>Ruft einen <see cref="T:System.ReadOnlyMemory`1" />-Wert für den aktuellen Knoten ab oder legt ihn fest.</summary>
      <returns>Ein <see cref="T:System.ReadOnlyMemory`1" /> -Wert für den aktuellen Knoten.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Next">
      <summary>Ruft den nächsten Knoten ab oder legt ihn fest.</summary>
      <returns>Der nächste Knoten.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.RunningIndex">
      <summary>Ruft die Summe der Knotenlängen vor dem aktuellen Knoten ab oder legt sie fest.</summary>
      <returns>Die Summe der Knoten Längen vor dem aktuellen Knoten.</returns>
    </member>
    <member name="T:System.Buffers.SequenceReader`1">
      <summary>Stellt Methoden zum Lesen von Binär-und Textdaten aus <see cref="T:System.Buffers.ReadOnlySequence`1" /> mit dem Fokus auf die Leistung und minimale oder keine Heapzuteilungen bereit</summary>
      <typeparam name="T">Der Typ der schreibgeschützten Sequenz.</typeparam>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.#ctor(System.Buffers.ReadOnlySequence{`0})">
      <summary>Erstellt einen <see cref="T:System.Buffers.SequenceReader`1" /> über eine angegebene <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <param name="sequence">Die schreibgeschützte Sequenz, über die der <see cref="T:System.Buffers.SequenceReader`1" /> erstellt werden soll.</param>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.Advance(System.Int64)">
      <summary>Verschiebt den Reader eine angegebene Anzahl von Elementen nach vorn.</summary>
      <param name="count">Die Anzahl der Elemente, um die vorgerückt wird.</param>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePast(`0)">
      <summary>Bewegt sich an aufeinander folgenden Instanzen des angegebenen <paramref name="value" /> vorbei.</summary>
      <param name="value">Der Wert um, den sich der Reader vorbeibewegt.</param>
      <returns>Die Anzahl der Positionen, um die der Reader vorgerückt ist.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0)">
      <summary>Bewegt sich an aufeinander folgenden Instanzen eines beliebigen von zwei angegebenen Werten vorbei.</summary>
      <param name="value0">Der erste zu überspringende Wert.</param>
      <param name="value1">Der zweite zu überspringende Wert.</param>
      <returns>Die Anzahl der Positionen, um die der Reader vorgerückt ist.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0)">
      <summary>Bewegt sich an aufeinander folgenden Instanzen beliebiger von drei angegebenen Werten vorbei.</summary>
      <param name="value0">Der erste zu überspringende Wert.</param>
      <param name="value1">Der zweite zu überspringende Wert.</param>
      <param name="value2">Der dritte zu überspringende Wert.</param>
      <returns>Die Anzahl der Positionen, um die der Reader vorgerückt ist.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0,`0)">
      <summary>Bewegt sich an aufeinander folgenden Instanzen beliebiger von vier angegebenen Werten vorbei.</summary>
      <param name="value0">Der erste zu überspringende Wert.</param>
      <param name="value1">Der zweite zu überspringende Wert.</param>
      <param name="value2">Der dritte zu überspringende Wert.</param>
      <param name="value3">Der vierte zu überspringende Wert.</param>
      <returns>Die Anzahl der Positionen, um die der Reader vorgerückt ist.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(System.ReadOnlySpan{`0})">
      <summary>Überspringt aufeinander folgende Instanzen beliebiger der angegebenen <paramref name="values" />.</summary>
      <param name="values">Die zu überspringenden Werte.</param>
      <returns>Die Anzahl der Positionen, um die der Reader vorgerückt ist.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Consumed">
      <summary>Ruft die Gesamtzahl der vom Reader verarbeiteten <typeparamref name="T" />-Werte ab.</summary>
      <returns>Die Gesamtanzahl der vom Reader verarbeiteten Werte.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.CurrentSpan">
      <summary>Ruft eine <see cref="T:System.Span`1" /> ab, die das aktuelle Segment in der <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> enthält.</summary>
      <returns>Eine Spanne, die das aktuelle Segment in der Sequenz enthält.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.CurrentSpanIndex">
      <summary>Ruft den Index in der <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> ab.</summary>
      <returns>Der Index in der <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.End">
      <summary>Ruft einen Wert ab, der angibt, ob keine Daten mehr in der <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> vorhanden sind.</summary>
      <returns>
        <see langword="true" />
        <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> ,<see langword="false" />wenn keine weiteren Daten in der vorhanden sind, andernfalls.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.IsNext(`0,System.Boolean)">
      <summary>Überprüft, ob ein angegebener Wert der nächste in der Sequenz ist.</summary>
      <param name="next">Der Wert, mit dem die nächsten Elemente verglichen werden.</param>
      <param name="advancePast">
        <see langword="true" /> zum Vorbeibewegen an den <paramref name="next" />-Werten, wenn sie gefunden werden; sonst <see langword="false" />.</param>
      <returns>
        <see langword="true" />, wenn die Werte in der Sequenz als nächstes kommen; sonst <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.IsNext(System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Überprüft, ob die in einer schreibgeschützten Spanne angegebenen Werte die nächsten in der Sequenz sind.</summary>
      <param name="next">Die Spanne, mit der die nächsten Elemente verglichen werden.</param>
      <param name="advancePast">
        <see langword="true" /> zum Vorbeibewegen an den <paramref name="next" />-Werten, wenn sie gefunden werden; sonst <see langword="false" />.</param>
      <returns>
        <see langword="true" />, wenn die Werte in der Sequenz als nächstes kommen; sonst <see langword="false" />.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Length">
      <summary>Ruft die Anzahl der Elemente in der <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> des Readers ab.</summary>
      <returns>Die Anzahl der Elemente in der des Readers <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Position">
      <summary>Ruft die aktuelle Position in der <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> ab.</summary>
      <returns>Die aktuelle Position in <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Remaining">
      <summary>Ruft die verbleibenden Elemente in der <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> des Readers ab.</summary>
      <returns>Die restlichen Elemente im Reader<see cref="P:System.Buffers.SequenceReader`1.Sequence" /></returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.Rewind(System.Int64)">
      <summary>Verschiebt den Reader eine angegebene Anzahl von Elementen zurück.</summary>
      <param name="count">Eine -Anzahl von Elementen.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> ist negativ oder größer als <see cref="P:System.Buffers.SequenceReader`1.Consumed" />.</exception>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Sequence">
      <summary>Ruft die zugrunde liegende <see cref="T:System.Buffers.ReadOnlySequence`1" /> für den Reader ab.</summary>
      <returns>Die zugrunde liegende schreibgeschützte Sequenz für den Reader.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryAdvanceTo(`0,System.Boolean)">
      <summary>Sucht nach einem angegebenen Trennzeichen und bewegt sich optional an ihm vorbei, wenn es gefunden wird.</summary>
      <param name="delimiter">Das Trennzeichen, das gesucht werden soll.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> zum Vorbeibewegen am <paramref name="delimiter" />, wenn er gefunden wird; andernfalls <see langword="false" />.</param>
      <returns>
        <see langword="true" />, wenn der angegebene <paramref name="delimiter" /> gefunden wurde; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryAdvanceToAny(System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Sucht nach beliebigen einer Anzahl angegebener Trennzeichen und bewegt sich optional an dem ersten gefundenen vorbei.</summary>
      <param name="delimiters">Die Trennzeichen, die gesucht werden sollen.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> zum Vorbeibewegen an der ersten Instanz eines der angegebenen <paramref name="delimiters" />; , um sich nicht an dem Trennzeichen vorbei zu bewegen.</param>
      <returns>
        <see langword="true" />, wenn ein beliebiges der angegebenen <paramref name="delimiters" /> gefunden wurde; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryCopyTo(System.Span{`0})">
      <summary>Kopiert Daten von der aktuellen Position zur angegebenen Zielspanne, wenn genügend Daten vorhanden sind, um sie zu füllen.</summary>
      <param name="destination">Zielspanne, in die kopiert werden soll.</param>
      <returns>
        <see langword="true" />, wenn genügend Daten vorhanden sind, um die <paramref name="destination" />-Spanne vollständig zu füllen; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryPeek(`0@)">
      <summary>Schaut auf den nächsten Wert, ohne den Reader vorzurücken.</summary>
      <param name="value">Der nächste Wert, oder der Standardwert, wenn das Ende des Readers erreicht ist.</param>
      <returns>
        <see langword="true" />, wenn sich der Reader nicht am Ende befindet und der Schauvorgang erfolgreich war; <see langword="false" />, wenn sich der Reader am Ende befindet.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryRead(`0@)">
      <summary>Liest den nächsten Wert und rückt den Reader vor.</summary>
      <param name="value">Der nächste Wert, oder der Standardwert, wenn das Ende des Readers erreicht ist.</param>
      <returns>
        <see langword="true" />, wenn sich der Reader nicht am Ende befindet und der Lesevorgang erfolgreich war; <see langword="false" />, wenn sich der Reader am Ende befindet.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,`0,System.Boolean)">
      <summary>Versucht, alles bis zum angegebenen <paramref name="delimiter" /> zu lesen, wobei Trennzeichen ignoriert werden, denen <paramref name="delimiterEscape" /> vorangestellt ist.</summary>
      <param name="sequence">Enthält die ggf. von der Methode gelesenen Daten.</param>
      <param name="delimiter">Das Trennzeichen, das gesucht werden soll.</param>
      <param name="delimiterEscape">Ein Wert, der angibt, dass ein unmittelbar nachfolgender <paramref name="delimiter" /> übersprungen werden soll.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> zum Vorbeibewegen am <paramref name="delimiter" />, wenn er gefunden wird; andernfalls <see langword="false" />.</param>
      <returns>
        <see langword="true" />, wenn der <paramref name="delimiter" /> gefunden wurde; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,System.Boolean)">
      <summary>Versucht, alles bis zum angegebenen <paramref name="delimiter" /> zu lesen.</summary>
      <param name="sequence">Enthält die ggf. von der Methode gelesenen Daten.</param>
      <param name="delimiter">Das Trennzeichen, das gesucht werden soll.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> zum Vorbeibewegen am <paramref name="delimiter" />, wenn er gefunden wird; andernfalls <see langword="false" />.</param>
      <returns>
        <see langword="true" />, wenn der <paramref name="delimiter" /> gefunden wurde; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Versucht, bis zur Übereinstimmung mit dem als schreibgeschützte Spanne angegebenen gesamten Trennzeichen Daten zu lesen.</summary>
      <param name="sequence">Enthält die ggf. von der Methode gelesenen Daten.</param>
      <param name="delimiter">Eine schreibgeschützte Spanne, die mindestens ein Trennzeichen enthält.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> zum Vorbeibewegen am <paramref name="delimiter" />, wenn er gefunden wird; andernfalls <see langword="false" />.</param>
      <returns>
        <see langword="true" />, wenn der <paramref name="delimiter" /> gefunden wurde; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,`0,System.Boolean)">
      <summary>Versucht, alles bis zum angegebenen <paramref name="delimiter" /> zu lesen, wobei Trennzeichen ignoriert werden, denen <paramref name="delimiterEscape" /> vorangestellt ist.</summary>
      <param name="span">Enthält die ggf. von der Methode gelesenen Daten.</param>
      <param name="delimiter">Das Trennzeichen, das gesucht werden soll.</param>
      <param name="delimiterEscape">Ein Wert, der angibt, dass ein unmittelbar nachfolgender <paramref name="delimiter" /> übersprungen werden soll.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> zum Vorbeibewegen am <paramref name="delimiter" />, wenn er gefunden wird; andernfalls <see langword="false" />.</param>
      <returns>
        <see langword="true" />, wenn der <paramref name="delimiter" /> gefunden wurde; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,System.Boolean)">
      <summary>Versucht, alles bis zum angegebenen <paramref name="delimiter" /> zu lesen.</summary>
      <param name="span">Enthält die ggf. von der Methode gelesenen Daten.</param>
      <param name="delimiter">Das Trennzeichen, das gesucht werden soll.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> zum Vorbeibewegen am <paramref name="delimiter" />, wenn er gefunden wird; andernfalls <see langword="false" />.</param>
      <returns>
        <see langword="true" />, wenn der <paramref name="delimiter" /> gefunden wurde; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadToAny(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Versucht, alles bis zu einem der angegebenen <paramref name="delimiters" /> zu lesen.</summary>
      <param name="sequence">Enthält die ggf. von der Methode gelesenen Daten.</param>
      <param name="delimiters">Die Trennzeichen, die gesucht werden sollen.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> zum Vorbeibewegen an der ersten gefundenen Instanz eines beliebigen der angegebenen <paramref name="delimiters" />; andernfalls <see langword="false" />.</param>
      <returns>
        <see langword="true" />, falls beliebige der <paramref name="delimiters" /> gefunden wurden; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadToAny(System.ReadOnlySpan{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Versucht, alles bis zu einem der angegebenen <paramref name="delimiters" /> zu lesen.</summary>
      <param name="span">Enthält die ggf. von der Methode gelesenen Daten.</param>
      <param name="delimiters">Die Trennzeichen, die gesucht werden sollen.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> zum Vorbeibewegen an der ersten gefundenen Instanz eines beliebigen der angegebenen <paramref name="delimiters" />; andernfalls <see langword="false" />.</param>
      <returns>
        <see langword="true" />, falls beliebige der <paramref name="delimiters" /> gefunden wurden; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.UnreadSpan">
      <summary>Ruft den ungelesenen Teil der <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> ab.</summary>
      <returns>Der ungelesene Teil <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />von.</returns>
    </member>
    <member name="T:System.Buffers.SequenceReaderExtensions">
      <summary>Stellt erweiterte Funktionen für die <see cref="T:System.Buffers.SequenceReader`1" />-Klasse bereit, die das Lesen von Endian-spezifischen numerischen Werten aus Binärdaten ermöglicht</summary>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int16@)">
      <summary>Versucht, <see cref="T:System.Int16" /> als big-endian zu lesen</summary>
      <param name="reader">Die Instanz des Bytesequenzlesers, aus der der Wert gelesen werden soll</param>
      <param name="value">Wenn die Methode zurückgegeben wird, wird der Wert aus dem Bytesequenzleser als big-endian ausgelesen.</param>
      <returns>
        <see langword="true" />, wenn der Lesevorgang erfolgreich ist; <see langword="false" />, wenn nicht genügend Daten für einen <see cref="T:System.Int16" />-Wert vorhanden sind.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int32@)">
      <summary>Versucht, <see cref="T:System.Int32" /> als big-endian zu lesen</summary>
      <param name="reader">Der Bytesequenzleser, aus dem der Wert gelesen werden soll</param>
      <param name="value">Wenn die Methode zurückgegeben wird, wird der Wert aus dem Bytesequenzleser als big-endian ausgelesen.</param>
      <returns>
        <see langword="true" />, wenn der Lesevorgang erfolgreich ist; <see langword="false" />, wenn nicht genügend Daten für einen <see cref="T:System.Int32" />-Wert vorhanden sind.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int64@)">
      <summary>Versucht, <see cref="T:System.Int64" /> als big-endian zu lesen</summary>
      <param name="reader">Die Instanz des Bytesequenzlesers, aus der der Wert gelesen werden soll</param>
      <param name="value">Wenn die Methode zurückgegeben wird, wird der Wert aus dem Bytesequenzleser als big-endian ausgelesen.</param>
      <returns>
        <see langword="true" />, wenn der Lesevorgang erfolgreich ist; <see langword="false" />, wenn nicht genügend Daten für einen <see cref="T:System.Int64" />-Wert vorhanden sind.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int16@)">
      <summary>Versucht, <see cref="T:System.Int16" /> als Little-Endian zu lesen</summary>
      <param name="reader">Die Instanz des Bytesequenzlesers, aus der der Wert gelesen werden soll</param>
      <param name="value">Wenn die Methode zurückgegeben wird, wird der Wert aus dem Bytesequenzleser als Little-Endian ausgelesen.</param>
      <returns>
        <see langword="true" />, wenn der Lesevorgang erfolgreich ist; <see langword="false" />, wenn nicht genügend Daten für einen <see cref="T:System.Int16" />-Wert vorhanden sind.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int32@)">
      <summary>Versucht, <see cref="T:System.Int32" /> als Little-Endian zu lesen</summary>
      <param name="reader">Die Instanz des Bytesequenzlesers, aus der der Wert gelesen werden soll</param>
      <param name="value">Wenn die Methode zurückgegeben wird, wird der Wert aus dem Bytesequenzleser als Little-Endian ausgelesen.</param>
      <returns>
        <see langword="true" />, wenn der Lesevorgang erfolgreich ist; <see langword="false" />, wenn nicht genügend Daten für einen <see cref="T:System.Int32" />-Wert vorhanden sind.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int64@)">
      <summary>Versucht, <see cref="T:System.Int64" /> als Little-Endian zu lesen</summary>
      <param name="reader">Die Instanz des Bytesequenzlesers, aus der der Wert gelesen werden soll</param>
      <param name="value">Wenn die Methode zurückgegeben wird, wird der Wert aus dem Bytesequenzleser als Little-Endian ausgelesen.</param>
      <returns>
        <see langword="true" />, wenn der Lesevorgang erfolgreich ist; <see langword="false" />, wenn nicht genügend Daten für einen <see cref="T:System.Int64" />-Wert vorhanden sind.</returns>
    </member>
    <member name="T:System.Buffers.StandardFormat">
      <summary>Stellt eine Standardformatzeichenfolge ohne Verwendung einer tatsächlichen Zeichenfolge dar.</summary>
    </member>
    <member name="M:System.Buffers.StandardFormat.#ctor(System.Char,System.Byte)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Buffers.StandardFormat" />-Struktur.</summary>
      <param name="symbol">Ein typspezifischer Formatbezeichner, z.B. „G“, „D“ oder „X“.</param>
      <param name="precision">Eine optionale Genauigkeit zwischen 0 und 99 oder der spezielle Wert <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> (Standard).</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="symbol" /> ist nicht <see cref="F:System.Buffers.StandardFormat.NoPrecision" />, und der zugehörige Wert ist größer als <see cref="F:System.Buffers.StandardFormat.MaxPrecision" />.

oder -

<paramref name="symbol" /> kann nicht in ein <see cref="T:System.Byte" /> konvertiert werden.</exception>
    </member>
    <member name="M:System.Buffers.StandardFormat.Equals(System.Buffers.StandardFormat)">
      <summary>Gibt einen Wert zurück, der angibt, ob das aktuelle <see cref="T:System.Buffers.StandardFormat" /> der aktuellen Instanz entspricht.</summary>
      <param name="other">Das Format, das mit der aktuellen Instanz verglichen werden soll.</param>
      <returns>
        <see langword="true" />, wenn die beiden Instanzen gleich sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Equals(System.Object)">
      <summary>Gibt einen Wert zurück, der angibt, ob das angegebene Objekt ein <see cref="T:System.Buffers.StandardFormat" />-Objekt ist, das der aktuellen Instanz entspricht.</summary>
      <param name="obj">Ein Objekt, das mit der aktuellen Instanz verglichen werden soll.</param>
      <returns>
        <see langword="true" />, wenn die beiden Instanzen gleich sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.GetHashCode">
      <summary>Gibt den Hashcode für diese Instanz zurück.</summary>
      <returns>Der Hashcode für diese Instanz.</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.HasPrecision">
      <summary>Ruft einen Wert ab, der angibt, ob ein Format eine definierte Genauigkeit aufweist.</summary>
      <returns>
        <see langword="true" />
        <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> ,<see langword="false" />wenn das Format eine andere Genauigkeit als aufweist, andernfalls.</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.IsDefault">
      <summary>Ruft einen Wert ab, der angibt, ob die aktuelle Instanz ein Standardformat ist.</summary>
      <returns>
        <see langword="true" />, wenn die aktuelle Instanz ein Standardformat ist. <see langword="false" />andernfalls.</returns>
    </member>
    <member name="F:System.Buffers.StandardFormat.MaxPrecision">
      <summary>Definiert den maximal gültigen Genauigkeitswert.</summary>
    </member>
    <member name="F:System.Buffers.StandardFormat.NoPrecision">
      <summary>Gibt an, dass ein Format keine Genauigkeit verwendet oder dass die Genauigkeit nicht angegeben wurde.</summary>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Equality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
      <summary>Gibt einen Wert zurück, der angibt, ob zwei <see cref="T:System.Buffers.StandardFormat" />-Instanzen gleich sind.</summary>
      <param name="left">Das erste Format für den Vergleich.</param>
      <param name="right">Das zweite Format für den Vergleich.</param>
      <returns>
        <see langword="true" />, wenn die beiden Instanzen gleich sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Implicit(System.Char)~System.Buffers.StandardFormat">
      <summary>Konvertiert ein Zeichen mit der Genauigkeit <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> in eine <see cref="T:System.Buffers.StandardFormat" />-Instanz.</summary>
      <param name="symbol">Das in einen <see cref="T:System.Buffers.StandardFormat" />-Wert umzuwandelnde Zeichen.</param>
      <returns>Ein Format mit einer <see cref="P:System.Buffers.StandardFormat.Symbol" />-Eigenschaft gleich <paramref name="symbol" /> und einer <see cref="P:System.Buffers.StandardFormat.Precision" />-Eigenschaft gleich <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Inequality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
      <summary>Stellt fest, ob zwei <see cref="T:System.Buffers.StandardFormat" />-Instanzen ungleich sind.</summary>
      <param name="left">Das erste Format für den Vergleich.</param>
      <param name="right">Das zweite Format für den Vergleich.</param>
      <returns>
        <see langword="true" />, wenn die beiden Formate nicht identisch sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Parse(System.ReadOnlySpan{System.Char})">
      <summary>Konvertiert <see langword="ReadOnlySpan&lt;System.Char&gt;" /> mit der Genauigkeit <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> in eine <see cref="T:System.Buffers.StandardFormat" />-Instanz.</summary>
      <param name="format">Ein schreibgeschützter Bereich, der das zu analysierende Zeichen enthält.</param>
      <returns>Ein Wert, dessen <see cref="P:System.Buffers.StandardFormat.Symbol" />-Eigenschaftswert das Zeichen in <paramref name="format" /> ist und dessen <see cref="P:System.Buffers.StandardFormat.Precision" />-Eigenschaftswert <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> lautet.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Parse(System.String)">
      <summary>Konvertiert eine klassische .NET-Standardformatzeichenfolge in eine <see cref="T:System.Buffers.StandardFormat" />-Instanz.</summary>
      <param name="format">Eine klassische .NET-Standardformatzeichenfolge.</param>
      <returns>Ein Format.</returns>
      <exception cref="T:System.FormatException">
        <paramref name="format" /> ist keine gültige Standard-Formatzeichenfolge.</exception>
    </member>
    <member name="P:System.Buffers.StandardFormat.Precision">
      <summary>Ruft die Genauigkeitskomponente des Formats ab.</summary>
      <returns>Die Genauigkeits Komponente, die <see cref="F:System.Buffers.StandardFormat.NoPrecision" />sein kann, oder zwischen 0 und 9 liegen kann.</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.Symbol">
      <summary>Ruft die Zeichenkomponente des Formats ab.</summary>
      <returns>Die Zeichen Komponente des Formats.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.ToString">
      <summary>Gibt die Zeichenfolgendarstellung dieses Formats zurück.</summary>
      <returns>Die Zeichenfolgendarstellung dieses Formats.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.TryParse(System.ReadOnlySpan{System.Char},System.Buffers.StandardFormat@)">
      <summary>Versucht, ein <see langword="ReadOnlySpan&lt;Char&gt;" /> in eine <see cref="T:System.Buffers.StandardFormat" />-Instanz zu konvertieren, und gibt einen Wert zurück, der angibt, ob der Analysevorgang erfolgreich war.</summary>
      <param name="format">Ein schreibgeschützter Bereich, der das zu konvertierende Zeichen enthält.</param>
      <param name="result">Wenn diese Methode beendet wird, enthält sie die analysierte <see cref="T:System.Buffers.StandardFormat" />-Instanz, sofern der Vorgang erfolgreich war.</param>
      <returns>
        <see langword="true" />, wenn der Analysevorgang erfolgreich war, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="T:System.Buffers.Text.Base64">
      <summary>Konvertiert zwischen binären Daten und UTF-8-codiertem Text, der als Base64 dargestellt wird.</summary>
    </member>
    <member name="M:System.Buffers.Text.Base64.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean)">
      <summary>Decodiert den Bereich des UTF-8-codierten Texts in Base64-Darstellung in binäre Daten. Wenn die Eingabe kein Vielfaches von 4 ist, wird so viel wie möglich bis zum nächsten Vielfachen von 4 decodiert.</summary>
      <param name="utf8">Der Eingabebereich, der UTF-8-codierten Text in Base64-Darstellung enthält, der decodiert werden muss.</param>
      <param name="bytes">Der Ausgabebereich, der das Ergebnis des Vorgangs enthält, d.h. die decodierten binären Daten.</param>
      <param name="bytesConsumed">Die Anzahl der während des Vorgangs verwendeten eingegebenen Bytes. Dies kann verwendet werden, um die Eingabe ggf. für nachfolgende Aufrufe zu unterteilen.</param>
      <param name="bytesWritten">Die Anzahl der in den Ausgabebereich geschriebenen Bytes. Dies kann verwendet werden, um die Ausgabe ggf. für nachfolgende Aufrufe zu unterteilen.</param>
      <param name="isFinalBlock">
        <see langword="true" /> (Standard), wenn der Eingabebereich die gesamten zu decodierenden Daten enthält. <see langword="false" />, wenn der Eingabebereich Teildaten enthält, auf die weitere Daten folgen.</param>
      <returns>Einer der Enumerationswerte, der den Status der Decodierung anzeigt.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.DecodeFromUtf8InPlace(System.Span{System.Byte},System.Int32@)">
      <summary>Decodiert den Bereich des UTF-8-codierten Texts in Base64-Darstellung (direkt) in binäre Daten. Die Ausgabe des decodierten binären Texts ist kleiner als die Textdaten, die in der Eingabe enthalten sind (der Vorgang verkleinert die Daten). Wenn die Eingabe kein Vielfaches von 4 ist, decodiert die Methode keine Daten.</summary>
      <param name="buffer">Der Eingabebereich, der Base64-Text enthält, der decodiert werden muss.</param>
      <param name="bytesWritten">Die Anzahl der in den Puffer geschriebenen Bytes.</param>
      <returns>Einer der Enumerationswerte, der den Status der Decodierung anzeigt.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.EncodeToUtf8(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean)">
      <summary>Codiert den Bereich der binären Daten in UTF-8-codierten Text in Base64-Darstellung.</summary>
      <param name="bytes">Der Eingabebereich, der Binärdaten enthält, die codiert werden müssen.</param>
      <param name="utf8">Der Ausgabebereich, der das Ergebnis des Vorgangs enthält, d.h. den UTF-8-codierten Text in Base64-Darstellung.</param>
      <param name="bytesConsumed">Die Anzahl der während des Vorgangs verwendeten eingegebenen Bytes. Dies kann verwendet werden, um die Eingabe ggf. für nachfolgende Aufrufe zu unterteilen.</param>
      <param name="bytesWritten">Die Anzahl der in den Ausgabebereich geschriebenen Bytes. Dies kann verwendet werden, um die Ausgabe ggf. für nachfolgende Aufrufe zu unterteilen.</param>
      <param name="isFinalBlock">
        <see langword="true" /> (Standard), wenn der Eingabebereich die gesamten zu codierenden Daten enthält. <see langword="false" />, wenn der Eingabebereich Teildaten enthält, auf die weitere Daten folgen.</param>
      <returns>Einer der Enumerationswerte, der den Status der Codierung anzeigt.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.EncodeToUtf8InPlace(System.Span{System.Byte},System.Int32,System.Int32@)">
      <summary>Codiert den Bereich der binären Daten (direkt) in UTF-8-codierten Text in Base64-Darstellung. Die Ausgabe des codierten Texts ist größer als die binären Daten, die in der Eingabe enthalten sind (der Vorgang vergrößert die Daten).</summary>
      <param name="buffer">Der Eingabebereich, der Binärdaten enthält, die codiert werden müssen. Da die Methode eine direkte Konvertierung ausführt, muss sie groß genug zum Speichern des Ergebnisses des Vorgangs sein.</param>
      <param name="dataLength">Die Anzahl der Bytes aus Binärdaten, die im Puffer enthalten sind, der codiert werden muss. Dieser Wert muss kleiner als die Pufferlänge sein.</param>
      <param name="bytesWritten">Die Anzahl der in den Puffer geschriebenen Bytes.</param>
      <returns>Einer der Enumerationswerte, der den Status der Codierung anzeigt.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.GetMaxDecodedFromUtf8Length(System.Int32)">
      <summary>Gibt die maximale Länge (in Bytes) des Ergebnisses zurück, wenn Sie Base64-codierten Text innerhalb eines Bytebereichs mit der angegebenen Länge decodieren würden.</summary>
      <param name="length">Die Größe der Bytespanne</param>
      <returns>Die maximal zulässige Länge des Ergebnisses in Bytes.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> ist kleiner als 0.</exception>
    </member>
    <member name="M:System.Buffers.Text.Base64.GetMaxEncodedToUtf8Length(System.Int32)">
      <summary>Gibt die maximale Länge (in Bytes) des Ergebnisses zurück, wenn Sie binäre Daten innerhalb eines Bytebereichs mit der angegebenen Länge codieren würden.</summary>
      <param name="length">Die Größe der Bytespanne</param>
      <returns>Die maximal zulässige Länge des Ergebnisses in Bytes.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> ist kleiner als 0 oder größer als 1.610.612.733 (da Codieren die Daten mit dem Faktor 4/3 vergrößert).</exception>
    </member>
    <member name="T:System.Buffers.Text.Utf8Formatter">
      <summary>Bietet statische Methoden zum Formatieren allgemeiner Datentypen als UTF8-Zeichenfolgen.</summary>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Boolean,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatiert einen <see cref="T:System.Boolean" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value">Der zu formatierende Wert.</param>
      <param name="destination">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format">Das zu verwendende Standardformat.</param>
      <returns>
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Byte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatiert einen <see cref="T:System.Byte" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value">Der zu formatierende Wert.</param>
      <param name="destination">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format">Das zu verwendende Standardformat.</param>
      <returns>
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTime,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatiert einen <see cref="T:System.DateTime" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value">Der zu formatierende Wert.</param>
      <param name="destination">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format">Das zu verwendende Standardformat.</param>
      <returns>
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTimeOffset,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatiert einen <see cref="T:System.DateTimeOffset" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value">Der zu formatierende Wert.</param>
      <param name="destination">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format">Das zu verwendende Standardformat.</param>
      <returns>
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Decimal,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatiert einen <see cref="T:System.Decimal" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value">Der zu formatierende Wert.</param>
      <param name="destination">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format">Das zu verwendende Standardformat.</param>
      <returns>
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Double,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatiert einen <see cref="T:System.Double" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value">Der zu formatierende Wert.</param>
      <param name="destination">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format">Das zu verwendende Standardformat.</param>
      <returns>
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Guid,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatiert einen <see cref="T:System.Guid" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value">Der zu formatierende Wert.</param>
      <param name="destination">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format">Das zu verwendende Standardformat.</param>
      <returns>
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatiert einen <see cref="T:System.Int16" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value">Der zu formatierende Wert.</param>
      <param name="destination">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format">Das zu verwendende Standardformat.</param>
      <returns>
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatiert einen <see cref="T:System.Int32" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value">Der zu formatierende Wert.</param>
      <param name="destination">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format">Das zu verwendende Standardformat.</param>
      <returns>
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatiert einen <see cref="T:System.Int64" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value">Der zu formatierende Wert.</param>
      <param name="destination">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format">Das zu verwendende Standardformat.</param>
      <returns>
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.SByte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatiert einen <see cref="T:System.SByte" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value">Der zu formatierende Wert.</param>
      <param name="destination">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format">Das zu verwendende Standardformat.</param>
      <returns>
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Single,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatiert einen <see cref="T:System.Single" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value">Der zu formatierende Wert.</param>
      <param name="destination">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format">Das zu verwendende Standardformat.</param>
      <returns>
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.TimeSpan,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatiert einen <see cref="T:System.TimeSpan" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value">Der zu formatierende Wert.</param>
      <param name="destination">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format">Das zu verwendende Standardformat.</param>
      <returns>
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatiert einen <see cref="T:System.UInt16" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value">Der zu formatierende Wert.</param>
      <param name="destination">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format">Das zu verwendende Standardformat.</param>
      <returns>
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatiert einen <see cref="T:System.UInt32" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value">Der zu formatierende Wert.</param>
      <param name="destination">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format">Das zu verwendende Standardformat.</param>
      <returns>
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatiert einen <see cref="T:System.UInt64" />-Wert als UTF8-Zeichenfolge.</summary>
      <param name="value">Der zu formatierende Wert.</param>
      <param name="destination">Der Puffer, in den der UTF8-formatierte Wert geschrieben wird.</param>
      <param name="bytesWritten">Enthält bei der Rückgabe der Methode die Länge des formatierten Texts in Bytes.</param>
      <param name="format">Das zu verwendende Standardformat.</param>
      <returns>
        <see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist; <see langword="false" />, wenn <paramref name="buffer" /> zu klein ist.</returns>
    </member>
    <member name="T:System.Buffers.Text.Utf8Parser">
      <summary>Bietet statische Methoden zum Analysieren von UTF8-Zeichenfolgen in allgemeine Datentypen.</summary>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Boolean@,System.Int32@,System.Char)">
      <summary>Analysiert einen <see cref="T:System.Boolean" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns>
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Byte@,System.Int32@,System.Char)">
      <summary>Analysiert einen <see cref="T:System.Byte" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns>
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.DateTime@,System.Int32@,System.Char)">
      <summary>Analysiert einen <see cref="T:System.DateTime" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns>
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.DateTimeOffset@,System.Int32@,System.Char)">
      <summary>Analysiert einen <see cref="T:System.DateTimeOffset" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns>
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Decimal@,System.Int32@,System.Char)">
      <summary>Analysiert einen <see cref="T:System.Decimal" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns>
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Double@,System.Int32@,System.Char)">
      <summary>Analysiert einen <see cref="T:System.Double" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns>
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Guid@,System.Int32@,System.Char)">
      <summary>Analysiert einen <see cref="T:System.Guid" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns>
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int16@,System.Int32@,System.Char)">
      <summary>Analysiert einen <see cref="T:System.Int16" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns>
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int32@,System.Int32@,System.Char)">
      <summary>Analysiert einen <see cref="T:System.Int32" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns>
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int64@,System.Int32@,System.Char)">
      <summary>Analysiert einen <see cref="T:System.Int64" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns>
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.SByte@,System.Int32@,System.Char)">
      <summary>Analysiert einen <see cref="T:System.SByte" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns>
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Single@,System.Int32@,System.Char)">
      <summary>Analysiert einen <see cref="T:System.Single" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns>
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.TimeSpan@,System.Int32@,System.Char)">
      <summary>Analysiert einen <see cref="T:System.TimeSpan" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns>
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt16@,System.Int32@,System.Char)">
      <summary>Analysiert einen <see cref="T:System.UInt16" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns>
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt32@,System.Int32@,System.Char)">
      <summary>Analysiert einen <see cref="T:System.UInt32" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns>
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt64@,System.Int32@,System.Char)">
      <summary>Analysiert einen <see cref="T:System.UInt64" />-Wert am Anfang einer UTF8-Zeichenfolge.</summary>
      <param name="source">Die zu analysierende UTF8-Zeichenfolge.</param>
      <param name="value">Enthält nach Rückgabe der Methode den aus <paramref name="source" /> analysierten Wert, wenn der Analysevorgang erfolgreich war.</param>
      <param name="bytesConsumed">Enthält bei Rückgabe der Methode die Länge der analysierten Teilzeichenfolge in Bytes, wenn der Analysevorgang erfolgreich war. Wenn bei der Methode ein Fehler auftritt, wird <paramref name="bytesConsumed" /> auf 0 gesetzt.</param>
      <param name="standardFormat">Das erwartete Format der UTF8-Zeichenfolge.</param>
      <returns>
        <see langword="true" /> für Erfolg; <see langword="false" />, wenn die Zeichenfolge syntaktisch ungültig war oder ein Über- bzw. Unterlauf aufgetreten ist.</returns>
    </member>
    <member name="T:System.MemoryExtensions">
      <summary>Bietet Erweiterungsmethoden für die Memory- und Span-bezogenen Typen wie <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />, <see cref="T:System.Span`1" /> und <see cref="T:System.ReadOnlySpan`1" />.</summary>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String)">
      <summary>Erstellt ein neues <see langword="ReadOnlyMemory&lt;Char&gt;" /> über den Abschnitt der Zielzeichenfolge.</summary>
      <param name="text">Die Zielzeichenfolge.</param>
      <returns>Die schreibgeschützte Zeichenspeicherdarstellung der Zeichenfolge oder <see langword="default" />, wenn <paramref name="text" /><see langword="null" /> ist.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Index)">
      <summary>Erstellt ein neues <see langword="ReadOnlyMemory&lt;Char&gt;" /> über einen Abschnitt der Zielzeichenfolge, beginnend bei einem angegebenen Index.</summary>
      <param name="text">Die Zielzeichenfolge.</param>
      <param name="startIndex">Der Index, an dem dieser Slice beginnen soll.</param>
      <returns>Die schreibgeschützte Zeichenspeicherdarstellung der Zeichenfolge.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32)">
      <summary>Erstellt ein neues <see langword="ReadOnlyMemory&lt;Char&gt;" /> über einen Abschnitt der Zielzeichenfolge, beginnend bei einer angegebenen Zeichenposition.</summary>
      <param name="text">Die Zielzeichenfolge.</param>
      <param name="start">Der Index, an dem dieser Slice beginnen soll.</param>
      <returns>Die schreibgeschützte Zeichenspeicherdarstellung der Zeichenfolge oder <see langword="default" />, wenn <paramref name="text" /><see langword="null" /> ist.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> liegt nicht im Bereich von <paramref name="text" />. (<paramref name="start" /> ist &lt; 0 oder &gt; <c>text.Length</c>).</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32,System.Int32)">
      <summary>Erstellt ein neues <see langword="ReadOnlyMemory&lt;Char&gt;" /> über einen Abschnitt der Zielzeichenfolge, beginnend bei einer angegebenen Position mit einer Länge.</summary>
      <param name="text">Die Zielzeichenfolge.</param>
      <param name="start">Der Index, an dem dieser Slice beginnen soll.</param>
      <param name="length">Die gewünschte Länge des Slices.</param>
      <returns>Die schreibgeschützte Zeichenspeicherdarstellung der Zeichenfolge oder <see langword="default" />, wenn <paramref name="text" /><see langword="null" /> ist.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> oder <paramref name="start" /> + <paramref name="length" /> liegt nicht im Bereich von <paramref name="text" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Range)">
      <summary>Erstellt ein neues <see langword="ReadOnlyMemory&lt;Char&gt;" /> über einen angegebenen Bereich der Zielzeichenfolge.</summary>
      <param name="text">Die Zielzeichenfolge.</param>
      <param name="range">Der Bereich, der den Anfang und die Länge der unterteilten Zeichenfolge angibt.</param>
      <returns>Die schreibgeschützte Zeichenspeicherdarstellung der Zeichenfolge.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[])">
      <summary>Erstellt einen neuen Speicherbereich über dem Zielarray.</summary>
      <param name="array">Das zu konvertierende Array.</param>
      <typeparam name="T">Der Typ des Arrays.</typeparam>
      <returns>Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Index)">
      <summary>Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarrays, beginnend bei einem angegebenen Index bis zum Ende des Arrays.</summary>
      <param name="array">Das zu konvertierende Array.</param>
      <param name="startIndex">Die erste Position des Arrays.</param>
      <typeparam name="T">Der Typ des Arrays.</typeparam>
      <returns>Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32)">
      <summary>Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarrays, beginnend an einem angegebenen Position bis zum Ende des Arrays.</summary>
      <param name="array">Das Zielarray.</param>
      <param name="start">Der Index, an dem der Speicher beginnen soll.</param>
      <typeparam name="T">Der Typ des Arrays.</typeparam>
      <returns>Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="array" /> ist kovariant, und der Typ des Arrays ist nicht genau <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />-Index kleiner als 0 oder größer als <see langword="array.Length" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32,System.Int32)">
      <summary>Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarrays, beginnend an einer angegebenen Position mit einer angegebenen Länge.</summary>
      <param name="array">Das Zielarray.</param>
      <param name="start">Der Index, an dem der Speicherbereich beginnen soll.</param>
      <param name="length">Die Anzahl der Elemente im Speicherbereich.</param>
      <typeparam name="T">Der Typ des Arrays.</typeparam>
      <returns>Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="array" /> ist kovariant, und der Typ des Arrays ist nicht genau <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> oder <paramref name="start" /> + <paramref name="length" /> liegt nicht im Bereich von <paramref name="array" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Range)">
      <summary>Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarrays, beginnend mit dem inklusiven Startindex des Bereichs und endend mit dem exklusiven Endindex des Bereichs.</summary>
      <param name="array">Das zu konvertierende Array.</param>
      <param name="range">Der aus dem Array zu konvertierende Bereich.</param>
      <typeparam name="T">Der Typ des Arrays.</typeparam>
      <returns>Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0})">
      <summary>Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarraysegments.</summary>
      <param name="segment">Das zu konvertierende Segment.</param>
      <typeparam name="T">Der Typ des Segments.</typeparam>
      <returns>Die Speicherdarstellung des Segments.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32)">
      <summary>Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarraysegments, beginnend an einer angegebenen Position bis zum Ende des Segments.</summary>
      <param name="segment">Das Zielarraysegment.</param>
      <param name="start">Der Index, an dem der Speicher beginnen soll.</param>
      <typeparam name="T">Der Typ des Arrays.</typeparam>
      <returns>Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="segment" /> ist kovariant, und den Typ von <paramref name="segment" /> ist nicht genau <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> ist kleiner als 0 oder größer als <see langword="segment.Count" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32,System.Int32)">
      <summary>Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarraysegments, beginnend an einer angegebenen Position mit einer angegebenen Länge.</summary>
      <param name="segment">Das Zielarraysegment.</param>
      <param name="start">Der Index, an dem der Speicher beginnen soll.</param>
      <param name="length">Die Anzahl der Elemente im Speicher.</param>
      <typeparam name="T">Der Typ des Arrays.</typeparam>
      <returns>Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="segment" /> ist kovariant, und der Typ des Arrays ist nicht genau <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> oder <paramref name="start" /> + <paramref name="length" /> liegt nicht im Bereich von <paramref name="segment" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String)">
      <summary>Erstellt eine neue schreibgeschützte Spanne über einen Abschnitt der Zielzeichenfolge von einer angegebenen Position aus für eine angegebene Anzahl von Zeichen.</summary>
      <param name="text">Die Zielzeichenfolge.</param>
      <returns>Die schreibgeschützte Spannendarstellung der Zeichenfolge.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32)">
      <summary>Erstellt eine neue schreibgeschützte Spanne über einen Abschnitt der Zielzeichenfolge von einer angegebenen Position aus bis zum Ende der Zeichenfolge.</summary>
      <param name="text">Die Zielzeichenfolge.</param>
      <param name="start">Der Index, an dem dieser Slice beginnen soll.</param>
      <returns>Die schreibgeschützte Spannendarstellung der Zeichenfolge.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="text" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> ist kleiner als 0 oder größer als <see langword="text.Length" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32,System.Int32)">
      <summary>Erstellt eine neue schreibgeschützte Spanne über eine Zeichenfolge.</summary>
      <param name="text">Die Zielzeichenfolge.</param>
      <param name="start">Der Index, an dem dieser Slice beginnen soll.</param>
      <param name="length">Die gewünschte Länge des Slices.</param>
      <returns>Die schreibgeschützte Spannendarstellung der Zeichenfolge.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> oder <paramref name="start" /> + <paramref name="length" /> liegt nicht im Bereich von <paramref name="text" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[])">
      <summary>Erstellt eine neue Spanne über einem Zielarray.</summary>
      <param name="array">Das zu konvertierende Array.</param>
      <typeparam name="T">Der Typ des Arrays.</typeparam>
      <returns>Die Spannendarstellung des Arrays.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Index)">
      <summary>Erstellt eine neue Spanne über dem Abschnitt des Zielarrays, das durch einen <see cref="T:System.Index" />-Wert definiert ist.</summary>
      <param name="array">Das zu konvertierende Array.</param>
      <param name="startIndex">Der Startindex.</param>
      <typeparam name="T">Der Arraytyp.</typeparam>
      <returns>Die Spannendarstellung des Arrays.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32)">
      <summary>Erstellt eine neue Spanne über einem Abschnitt des Zielarrays, beginnend an einer angegebenen Position bis zum Ende des Arrays.</summary>
      <param name="array">Das zu konvertierende Array.</param>
      <param name="start">Der anfängliche Index, aus dem das Array konvertiert wird.</param>
      <typeparam name="T">Der Typ des Arrays.</typeparam>
      <returns>Die Spannendarstellung des Arrays.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32,System.Int32)">
      <summary>Erstellt eine neue Spanne über dem Abschnitt des Zielarrays, beginnend an einer angegebenen Position für eine bestimmte Länge.</summary>
      <param name="array">Das Zielarray.</param>
      <param name="start">Der Index, an dem die Spanne beginnen soll.</param>
      <param name="length">Die Anzahl der Elemente in der Spanne.</param>
      <typeparam name="T">Der Typ des Arrays.</typeparam>
      <returns>Die Spannendarstellung des Arrays.</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="array" /> ist kovariant, und der Typ des Arrays ist nicht genau <see langword="T[]" />".</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> oder <paramref name="start" /> + <paramref name="length" /> liegt nicht im Bereich von <paramref name="text" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Range)">
      <summary>Erstellt eine neue Spanne über einem Abschnitt eines Zielarrays, das durch einen <see cref="T:System.Range" />-Wert definiert ist.</summary>
      <param name="array">Das zu konvertierende Array.</param>
      <param name="range">Der Bereich des zu konvertierenden Arrays.</param>
      <typeparam name="T">Der Typ des Arrays.</typeparam>
      <returns>Die Spannendarstellung des Arrays.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0})">
      <summary>Erstellt eine neue Spanne über einem Zielarraysegment.</summary>
      <param name="segment">Das zu konvertierende Arraysegment.</param>
      <typeparam name="T">Der Typ des Array Segments.</typeparam>
      <returns>Die Spannendarstellung des Arraysegments.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Index)">
      <summary>Erstellt eine neue Spanne über einem Abschnitt des Zielarraysegments, beginnend mit einem angegebenen Index und endend mit dem Segmentende.</summary>
      <param name="segment">Das Zielarraysegment.</param>
      <param name="startIndex">Der Index, an dem die Spanne beginnen soll.</param>
      <typeparam name="T">Der Typ des Array Segments.</typeparam>
      <returns>Die Spannendarstellung des Arraysegments.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32)">
      <summary>Erstellt eine neue Spanne über einem Abschnitt eines Zielarraysegments von einer bestimmten Position aus bis zum Segmentende.</summary>
      <param name="segment">Das Zielarraysegment.</param>
      <param name="start">Der Index, an dem die Spanne beginnen soll.</param>
      <typeparam name="T">Der Typ des Array Segments.</typeparam>
      <returns>Die Spannendarstellung des Arraysegments.</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="segment" /> ist kovariant, und der Typ des Arrays ist nicht genau <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> ist kleiner als 0 oder größer als <see langword="segment.Count" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32,System.Int32)">
      <summary>Erstellt eine neue Spanne über einem Abschnitt eines Zielarraysegments von einer bestimmten Position aus für eine angegebene Länge.</summary>
      <param name="segment">Das Zielarraysegment.</param>
      <param name="start">Der Index, an dem die Spanne beginnen soll.</param>
      <param name="length">Die Anzahl der Elemente in der Spanne.</param>
      <typeparam name="T">Der Typ des Array Segments.</typeparam>
      <returns>Die Spannendarstellung des Arrays.</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="segment" /> ist kovariant, und der Typ des Arrays ist nicht genau <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> oder <paramref name="start" /> + <paramref name="length" /> liegt nicht im Bereich von <paramref name="segment" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Range)">
      <summary>Erstellt eine neue Spanne über einem Abschnitt eines Zielarraysegments unter Verwendung der Start- und Endindizes des Bereichs.</summary>
      <param name="segment">Das Zielarraysegment.</param>
      <param name="range">Der Bereich, der Start- und Endindizes aufweist, die für das Unterteilen des Arrays verwendet werden können.</param>
      <typeparam name="T">Der Typ des Array Segments.</typeparam>
      <returns>Die Spannendarstellung des Arraysegments.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``1(System.ReadOnlySpan{``0},System.IComparable{``0})">
      <summary>Durchsucht ein ganzes sortiertes <see cref="T:System.ReadOnlySpan`1" /> mithilfe der angegebenen generischen <see cref="T:System.IComparable`1" />-Schnittstelle nach einem Wert.</summary>
      <param name="span">Das zu durchsuchende sortierte <see cref="T:System.ReadOnlySpan`1" />.</param>
      <param name="comparable">
        <see cref="T:System.IComparable`1" />, das beim Vergleich verwendet werden soll.</param>
      <typeparam name="T">Der Elementtyp der Spanne.</typeparam>
      <returns>Der nullbasierte Index von <paramref name="comparable" /> in der sortierten <paramref name="span" />, sofern <paramref name="comparable" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="comparable" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``1(System.Span{``0},System.IComparable{``0})">
      <summary>Durchsucht ein ganzes sortiertes <see cref="T:System.Span`1" /> mithilfe der angegebenen generischen <see cref="T:System.IComparable`1" />-Schnittstelle nach einem Wert.</summary>
      <param name="span">Das zu durchsuchende sortierte <see cref="T:System.Span`1" />.</param>
      <param name="comparable">
        <see cref="T:System.IComparable`1" />, das beim Vergleich verwendet werden soll.</param>
      <typeparam name="T">Der Elementtyp der Spanne.</typeparam>
      <returns>Der nullbasierte Index von <paramref name="comparable" /> in der sortierten <paramref name="span" />, sofern <paramref name="comparable" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="comparable" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.Span`1.Length" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``0,``1)">
      <summary>Durchsucht ein ganzes sortiertes <see cref="T:System.ReadOnlySpan`1" /> mithilfe des angegebenen generischen <typeparamref name="TComparer" />-Typs nach einem angegebenen Wert.</summary>
      <param name="span">Das zu durchsuchende sortierte <see cref="T:System.ReadOnlySpan`1" />.</param>
      <param name="value">Das zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
      <param name="comparer">
        <typeparamref name="TComparer" />, das beim Vergleich verwendet werden soll.</param>
      <typeparam name="T">Der Elementtyp der Spanne.</typeparam>
      <typeparam name="TComparer">Der spezifische Typ von <see cref="T:System.Collections.Generic.IComparer`1" />.</typeparam>
      <returns>Der nullbasierte Index von <paramref name="value" /> in der sortierten <paramref name="span" />, sofern <paramref name="value" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="value" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparer" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``1)">
      <summary>Durchsucht ein ganzes sortiertes <see cref="T:System.ReadOnlySpan`1" /> mithilfe des angegebenen generischen <typeparamref name="TComparable" />-Typs nach einem Wert.</summary>
      <param name="span">Das zu durchsuchende sortierte <see cref="T:System.ReadOnlySpan`1" />.</param>
      <param name="comparable">
        <typeparamref name="TComparable" />, das beim Vergleich verwendet werden soll.</param>
      <typeparam name="T">Der Elementtyp der Spanne.</typeparam>
      <typeparam name="TComparable">Der spezifische Typ von <see cref="T:System.IComparable`1" />.</typeparam>
      <returns>Der nullbasierte Index von <paramref name="comparable" /> in der sortierten <paramref name="span" />, sofern <paramref name="comparable" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="comparable" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``0,``1)">
      <summary>Durchsucht ein ganzes sortiertes <see cref="T:System.Span`1" /> mithilfe des angegebenen generischen <typeparamref name="TComparer" />-Typs nach einem angegebenen Wert.</summary>
      <param name="span">Das zu durchsuchende sortierte <see cref="T:System.Span`1" />.</param>
      <param name="value">Das zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
      <param name="comparer">
        <typeparamref name="TComparer" />, das beim Vergleich verwendet werden soll.</param>
      <typeparam name="T">Der Elementtyp der Spanne.</typeparam>
      <typeparam name="TComparer">Der spezifische Typ von <see cref="T:System.Collections.Generic.IComparer`1" />.</typeparam>
      <returns>Der nullbasierte Index von <paramref name="value" /> in der sortierten <paramref name="span" />, sofern <paramref name="value" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="value" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.Span`1.Length" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparer" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``1)">
      <summary>Durchsucht ein ganzes sortiertes <see cref="T:System.Span`1" /> mithilfe des angegebenen generischen <typeparamref name="TComparable" />-Typs nach einem Wert.</summary>
      <param name="span">Das zu durchsuchende sortierte <see cref="T:System.Span`1" />.</param>
      <param name="comparable">
        <typeparamref name="TComparable" />, das beim Vergleich verwendet werden soll.</param>
      <typeparam name="T">Der Elementtyp der Spanne.</typeparam>
      <typeparam name="TComparable">Der spezifische Typ von <see cref="T:System.IComparable`1" />.</typeparam>
      <returns>Der nullbasierte Index von <paramref name="comparable" /> in der sortierten <paramref name="span" />, sofern <paramref name="comparable" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="comparable" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.Span`1.Length" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.CompareTo(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Vergleicht eine Zeichenspanne mit einer anderen unter Verwendung eines angegebenen Zeichenfolgenvergleichs und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
      <param name="span">Die Quellspanne.</param>
      <param name="other">Der Wert, der mit der Quellspanne verglichen werden soll.</param>
      <param name="comparisonType">Ein Enumerationswert, der bestimmt, wie <paramref name="span" /> und <paramref name="other" /> verglichen werden.</param>
      <returns>Eine ganze Zahl mit Vorzeichen, die die relative Reihenfolge von <paramref name="span" /> und <paramref name="other" /> angibt:   – Wenn kleiner als 0, <paramref name="span" /> vor <paramref name="other" />.   – Wenn diese 0 (null) sind, ist <paramref name="span" /> gleich <paramref name="other" />.   – Wenn größer als 0, folgt <paramref name="span" /> auf <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Gibt an, ob ein angegebener Wert innerhalb einer schreibgeschützten Zeichenspanne auftritt.</summary>
      <param name="span">Die Quellspanne.</param>
      <param name="value">Der innerhalb der Quellspanne zu suchende Wert.</param>
      <param name="comparisonType">Ein Enumerationswert, der bestimmt, wie die Zeichen in <paramref name="span" /> und <paramref name="value" /> verglichen werden.</param>
      <returns>
        <see langword="true" />, wenn <paramref name="value" /> innerhalb der Spanne auftritt, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains``1(System.ReadOnlySpan{``0},``0)">
      <summary>Gibt an, ob ein angegebener Wert in einer schreibgeschützten Spanne gefunden wird. Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</summary>
      <param name="span">Die zu suchende Spanne.</param>
      <param name="value">Der zu suchende Wert.</param>
      <typeparam name="T">Der Typ der Spanne.</typeparam>
      <returns>
        <see langword="true" />, wenn er gefunden wurde, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains``1(System.Span{``0},``0)">
      <summary>Gibt an, ob ein angegebener Wert in einer Spanne gefunden wird. Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</summary>
      <param name="span">Die zu suchende Spanne.</param>
      <param name="value">Der zu suchende Wert.</param>
      <typeparam name="T">Der Typ der Elemente in der Spanne.</typeparam>
      <returns>
        <see langword="true" />, wenn er gefunden wurde, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Memory{``0})">
      <summary>Kopiert den Inhalt des Arrays in einen Speicherbereich.</summary>
      <param name="source">Das Array, aus dem Elemente kopiert werden sollen.</param>
      <param name="destination">Das Array, in das die Elemente kopiert werden sollen.</param>
      <typeparam name="T">Der Typ des Arrays.</typeparam>
      <exception cref="T:System.ArgumentException">Das Ziel ist kürzer als das Quellarray.</exception>
    </member>
    <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Span{``0})">
      <summary>Kopiert den Inhalt des Arrays in die Spanne.</summary>
      <param name="source">Das Array, aus dem Elemente kopiert werden sollen.</param>
      <param name="destination">Der Bereich, in den Elemente kopiert werden sollen.</param>
      <typeparam name="T">Der Typ des Arrays.</typeparam>
      <exception cref="T:System.ArgumentException">Die Zielspanne ist kürzer als das Quellarray.</exception>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Bestimmt, ob das Ende von <paramref name="span" /> mit dem angegebenen <paramref name="value" /> übereinstimmt, wenn es mit der angegebenen <paramref name="comparisonType" />-Option verglichen wird.</summary>
      <param name="span">Die Quellspanne.</param>
      <param name="value">Die Sequenz, die mit dem Ende der Quellspanne verglichen werden soll.</param>
      <param name="comparisonType">Ein Enumerationswert, der bestimmt, wie <paramref name="span" /> und <paramref name="value" /> verglichen werden.</param>
      <returns>
        <see langword="true" />, wenn <paramref name="value" /> mit dem Ende von <paramref name="span" /> übereinstimmt, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Bestimmt, ob die angegebene Sequenz am Ende einer schreibgeschützten Spanne angezeigt wird.</summary>
      <param name="span">Die Quellspanne.</param>
      <param name="value">Die Sequenz, die mit dem Ende der Quellspanne verglichen werden soll.</param>
      <typeparam name="T">Der Typ der Spanne.</typeparam>
      <returns>
        <see langword="true" />, wenn <paramref name="value" /> mit dem Ende von <paramref name="span" /> übereinstimmt, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Bestimmt, ob die angegebene Sequenz am Ende einer Spanne angezeigt wird.</summary>
      <param name="span">Die Quellspanne.</param>
      <param name="value">Die Sequenz, die mit dem Ende der Quellspanne verglichen werden soll.</param>
      <typeparam name="T">Der Typ der Spanne.</typeparam>
      <returns>
        <see langword="true" />, wenn <paramref name="value" /> mit dem Ende von <paramref name="span" /> übereinstimmt, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EnumerateRunes(System.ReadOnlySpan{System.Char})">
      <summary>Gibt eine Enumeration von <see cref="T:System.Text.Rune" /> aus der angegebenen schreibgeschützten Spanne zurück.</summary>
      <param name="span">Die Quellspanne.</param>
      <returns>Ein rune-Enumerator.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EnumerateRunes(System.Span{System.Char})">
      <summary>Gibt eine Enumeration von <see cref="T:System.Text.Rune" /> aus der angegebenen Spanne zurück.</summary>
      <param name="span">Die Quellspanne.</param>
      <returns>Ein rune-Enumerator.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Equals(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Bestimmt, ob dieser <paramref name="span" /> und die angegebene <paramref name="other" />-Spanne dieselben Zeichen aufweisen, wenn sie mit der angegebenen <paramref name="comparisonType" />-Option verglichen werden.</summary>
      <param name="span">Die Quellspanne.</param>
      <param name="other">Der Wert, der mit der Quellspanne verglichen werden soll.</param>
      <param name="comparisonType">Ein Enumerationswert, der bestimmt, wie <paramref name="span" /> und <paramref name="other" /> verglichen werden.</param>
      <returns>
        <see langword="true" />, sofern identisch, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen <paramref name="value" /> im aktuellen <paramref name="span" /> an.</summary>
      <param name="span">Die Quellspanne.</param>
      <param name="value">Der innerhalb der Quellspanne zu suchende Wert.</param>
      <param name="comparisonType">Ein Enumerationswert, der bestimmt, wie <paramref name="span" /> und <paramref name="value" /> verglichen werden.</param>
      <returns>Der Index des Vorkommens des Werts in der Spanne.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},``0)">
      <summary>Sucht nach dem angegebenen Wert und gibt den Index des ersten Vorkommens zurück. Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</summary>
      <param name="span">Die zu suchende Spanne.</param>
      <param name="value">Der zu suchende Wert.</param>
      <typeparam name="T">Der Typ der Spanne und des Werts.</typeparam>
      <returns>Der Index des Vorkommens des Werts in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Sucht nach der angegebenen Sequenz und gibt den Index des ersten Vorkommens zurück. Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</summary>
      <param name="span">Die zu suchende Spanne.</param>
      <param name="value">Die zu suchende Sequenz.</param>
      <typeparam name="T">Der Typ der Spanne und des Werts.</typeparam>
      <returns>Der Index des Vorkommens des Werts in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},``0)">
      <summary>Sucht nach dem angegebenen Wert und gibt den Index des ersten Vorkommens zurück. Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</summary>
      <param name="span">Die zu suchende Spanne.</param>
      <param name="value">Der zu suchende Wert.</param>
      <typeparam name="T">Der Typ der Spanne und des Werts.</typeparam>
      <returns>Der Index des Vorkommens des Werts in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Sucht nach der angegebenen Sequenz und gibt den Index des ersten Vorkommens zurück. Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</summary>
      <param name="span">Die zu suchende Spanne.</param>
      <param name="value">Die zu suchende Sequenz.</param>
      <typeparam name="T">Der Typ der Spanne und des Werts.</typeparam>
      <returns>Der Index des Vorkommens des Werts in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
      <summary>Sucht nach dem ersten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von IndexOf mit dem logischen OR-Operator (ODER).</summary>
      <param name="span">Die zu suchende Spanne.</param>
      <param name="value0">Einer der zu suchenden Werte.</param>
      <param name="value1">Einer der zu suchenden Werte.</param>
      <typeparam name="T">Der Typ der Spanne und der Werte.</typeparam>
      <returns>Der erste Index des Vorkommens eines der Werte in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
      <summary>Sucht nach dem ersten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von IndexOf mit dem logischen OR-Operator (ODER).</summary>
      <param name="span">Die zu suchende Spanne.</param>
      <param name="value0">Einer der zu suchenden Werte.</param>
      <param name="value1">Einer der zu suchenden Werte.</param>
      <param name="value2">Einer der zu suchenden Werte.</param>
      <typeparam name="T">Der Typ der Spanne und der Werte.</typeparam>
      <returns>Der erste Index des Vorkommens eines der Werte in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Sucht nach dem ersten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von IndexOf mit dem logischen OR-Operator (ODER).</summary>
      <param name="span">Die zu suchende Spanne.</param>
      <param name="values">Der zu suchende Satz von Werten.</param>
      <typeparam name="T">Der Typ der Spanne und der Werte.</typeparam>
      <returns>Der erste Index des Vorkommens eines der Werte in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0)">
      <summary>Sucht nach dem ersten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von IndexOf mit dem logischen OR-Operator (ODER).</summary>
      <param name="span">Die zu suchende Spanne.</param>
      <param name="value0">Einer der zu suchenden Werte.</param>
      <param name="value1">Einer der zu suchenden Werte.</param>
      <typeparam name="T">Der Typ der Spanne und der Werte.</typeparam>
      <returns>Der erste Index des Vorkommens eines der Werte in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0,``0)">
      <summary>Sucht nach dem ersten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von IndexOf mit dem logischen OR-Operator (ODER).</summary>
      <param name="span">Die zu suchende Spanne.</param>
      <param name="value0">Einer der zu suchenden Werte.</param>
      <param name="value1">Einer der zu suchenden Werte.</param>
      <param name="value2">Einer der zu suchenden Werte.</param>
      <typeparam name="T">Der Typ der Spanne und der Werte.</typeparam>
      <returns>Der erste Index des Vorkommens eines der Werte in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Sucht nach dem ersten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von IndexOf mit dem logischen OR-Operator (ODER).</summary>
      <param name="span">Die zu suchende Spanne.</param>
      <param name="values">Der zu suchende Satz von Werten.</param>
      <typeparam name="T">Der Typ der Spanne und der Werte.</typeparam>
      <returns>Der erste Index des Vorkommens eines der Werte in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IsWhiteSpace(System.ReadOnlySpan{System.Char})">
      <summary>Gibt an, ob die angegebene Spanne nur Leerzeichen enthält.</summary>
      <param name="span">Die Quellspanne.</param>
      <returns>
        <see langword="true" />, wenn die Spanne nur Leerzeichen enthält, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Gibt den NULL-basierten Index des letzten Vorkommens der angegebenen <paramref name="value" /> im aktuellen <paramref name="span" /> an.</summary>
      <param name="span">Die Quellspanne.</param>
      <param name="value">Der innerhalb der Quellspanne zu suchende Wert.</param>
      <param name="comparisonType">Ein Enumerationswert, der bestimmt, wie <paramref name="span" /> und <paramref name="value" /> verglichen werden.</param>
      <returns>Der Index des letzten Vorkommens des Werts in der Spanne.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},``0)">
      <summary>Sucht nach dem angegebenen Wert und gibt den Index des letzten Vorkommens zurück. Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</summary>
      <param name="span">Die zu suchende Spanne.</param>
      <param name="value">Der zu suchende Wert.</param>
      <typeparam name="T">Der Typ der Spanne und des Werts.</typeparam>
      <returns>Der Index des letzten Vorkommens des Werts in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Sucht nach der angegebenen Sequenz und gibt den Index des letzten Vorkommens zurück. Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</summary>
      <param name="span">Die zu suchende Spanne.</param>
      <param name="value">Die zu suchende Sequenz.</param>
      <typeparam name="T">Der Typ der Spanne und des Werts.</typeparam>
      <returns>Der Index des letzten Vorkommens des Werts in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},``0)">
      <summary>Sucht nach dem angegebenen Wert und gibt den Index des letzten Vorkommens zurück. Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</summary>
      <param name="span">Die zu suchende Spanne.</param>
      <param name="value">Der zu suchende Wert.</param>
      <typeparam name="T">Der Typ der Spanne und des Werts.</typeparam>
      <returns>Der Index des letzten Vorkommens des Werts in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Sucht nach der angegebenen Sequenz und gibt den Index des letzten Vorkommens zurück. Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</summary>
      <param name="span">Die zu suchende Spanne.</param>
      <param name="value">Die zu suchende Sequenz.</param>
      <typeparam name="T">Der Typ der Spanne und des Werts.</typeparam>
      <returns>Der Index des letzten Vorkommens des Werts in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
      <summary>Sucht nach dem letzten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von LastIndexOf mit dem logischen OR-Operator (ODER).</summary>
      <param name="span">Die zu suchende Spanne.</param>
      <param name="value0">Einer der zu suchenden Werte.</param>
      <param name="value1">Einer der zu suchenden Werte.</param>
      <typeparam name="T">Der Typ der Spanne und der Werte.</typeparam>
      <returns>Der Index des letzten Vorkommens eines der Werte in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
      <summary>Sucht nach dem letzten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von LastIndexOf mit dem logischen OR-Operator (ODER).</summary>
      <param name="span">Die zu suchende Spanne.</param>
      <param name="value0">Einer der zu suchenden Werte.</param>
      <param name="value1">Einer der zu suchenden Werte.</param>
      <param name="value2">Einer der zu suchenden Werte.</param>
      <typeparam name="T">Der Typ der Spanne und der Werte.</typeparam>
      <returns>Der Index des letzten Vorkommens eines der Werte in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Sucht nach dem letzten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von LastIndexOf mit dem logischen OR-Operator (ODER).</summary>
      <param name="span">Die zu suchende Spanne.</param>
      <param name="values">Der zu suchende Satz von Werten.</param>
      <typeparam name="T">Der Typ der Spanne und der Werte.</typeparam>
      <returns>Der Index des letzten Vorkommens eines der Werte in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0)">
      <summary>Sucht nach dem letzten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von LastIndexOf mit dem logischen OR-Operator (ODER).</summary>
      <param name="span">Die zu suchende Spanne.</param>
      <param name="value0">Einer der zu suchenden Werte.</param>
      <param name="value1">Einer der zu suchenden Werte.</param>
      <typeparam name="T">Der Typ der Spanne und der Werte.</typeparam>
      <returns>Der Index des letzten Vorkommens eines der Werte in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0,``0)">
      <summary>Sucht nach dem letzten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von LastIndexOf mit dem logischen OR-Operator (ODER).</summary>
      <param name="span">Die zu suchende Spanne.</param>
      <param name="value0">Einer der zu suchenden Werte.</param>
      <param name="value1">Einer der zu suchenden Werte.</param>
      <param name="value2">Einer der zu suchenden Werte.</param>
      <typeparam name="T">Der Typ der Spanne und der Werte.</typeparam>
      <returns>Der Index des letzten Vorkommens eines der Werte in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Sucht nach dem letzten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von LastIndexOf mit dem logischen OR-Operator (ODER).</summary>
      <param name="span">Die zu suchende Spanne.</param>
      <param name="values">Der zu suchende Satz von Werten.</param>
      <typeparam name="T">Der Typ der Spanne und der Werte.</typeparam>
      <returns>Der Index des letzten Vorkommens eines der Werte in der Spanne. Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Bestimmt, ob sich zwei schreibgeschützte Sequenzen im Speicher überlappen.</summary>
      <param name="span">Die erste Sequenz.</param>
      <param name="other">Die zweite Sequenz.</param>
      <typeparam name="T">Der Typ der in dem in der schreibgeschützten Sequenz.</typeparam>
      <returns>
        <see langword="true" />, wenn sich die beiden Sequenzen überlappen, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Int32@)">
      <summary>Bestimmt, ob sich zwei schreibgeschützte Sequenzen im Speicher überlappen, und gibt den Elementoffset aus.</summary>
      <param name="span">Die erste Sequenz.</param>
      <param name="other">Die zweite Sequenz.</param>
      <param name="elementOffset" />
      <typeparam name="T">Der Typ der Elemente in der Spanne.</typeparam>
      <returns>
        <see langword="true" />, wenn sich die beiden Sequenzen überlappen, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Bestimmt, ob sich eine Spanne und eine schreibgeschützte Spanne im Speicher überlappen.</summary>
      <param name="span">Die zu vergleichende Spanne.</param>
      <param name="other">Die zu vergleichende schreibgeschützte Spanne.</param>
      <typeparam name="T">Der Typ der Elemente in der Spanne.</typeparam>
      <returns>
        <see langword="true" />, wenn sich die beiden Sequenzen überlappen, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0},System.Int32@)">
      <summary>Bestimmt, ob sich eine Spanne und eine schreibgeschützte Spanne im Speicher überlappen, und gibt den Elementoffset aus.</summary>
      <param name="span">Die erste zu vergleichende Sequenz.</param>
      <param name="other">Die zweite zu vergleichende Sequenz.</param>
      <param name="elementOffset">Wenn die Methode zurückkehrt, enthält sie den Offset zwischen <paramref name="span" /> und <paramref name="other" />.</param>
      <typeparam name="T">Der Typ der Elemente in der Spanne.</typeparam>
      <returns>
        <see langword="true" />, wenn sich die beiden Sequenzen überlappen, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Reverse``1(System.Span{``0})">
      <summary>Kehrt die Reihenfolge der Elemente in der gesamten Spanne um.</summary>
      <param name="span">Die umzukehrende Spanne.</param>
      <typeparam name="T">Der Typ der Elemente in der Spanne.</typeparam>
    </member>
    <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Bestimmt die relative Reihenfolge von zwei schreibgeschützten Sequenzen durch Vergleichen ihrer Elemente mit „IComparable{T}.CompareTo(T)“.</summary>
      <param name="span">Die erste zu vergleichende Sequenz.</param>
      <param name="other">Die zweite zu vergleichende Sequenz.</param>
      <typeparam name="T">Der Typ der Elemente in der Sequenz.</typeparam>
      <returns>Eine ganze Zahl mit Vorzeichen, die die relative Reihenfolge von <paramref name="span" /> und <paramref name="other" /> angibt:   – Wenn kleiner als 0, <paramref name="span" /> vor <paramref name="other" />.   – Wenn diese 0 (null) sind, ist <paramref name="span" /> gleich <paramref name="other" />.   – Wenn größer als 0, folgt <paramref name="span" /> auf <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Bestimmt die relative Reihenfolge von einer Spanne und einer schreibgeschützten Spanne durch Vergleichen der Elemente mit „IComparable{T}.CompareTo(T)“.</summary>
      <param name="span">Die zu vergleichende Spanne.</param>
      <param name="other">Die zu vergleichende schreibgeschützte Spanne.</param>
      <typeparam name="T">Der Typ der Elemente in der Spanne.</typeparam>
      <returns>Eine ganze Zahl mit Vorzeichen, die die relative Reihenfolge von <paramref name="span" /> und <paramref name="other" /> angibt:   – Wenn kleiner als 0, <paramref name="span" /> vor <paramref name="other" />.   – Wenn diese 0 (null) sind, ist <paramref name="span" /> gleich <paramref name="other" />.   – Wenn größer als 0, folgt <paramref name="span" /> auf <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceEqual``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Bestimmt, ob zwei schreibgeschützte Sequenzen identisch sind, indem die Elemente mit „IEquatable{T}.Equals(T)“ verglichen werden.</summary>
      <param name="span">Die erste zu vergleichende Sequenz.</param>
      <param name="other">Die zweite zu vergleichende Sequenz.</param>
      <typeparam name="T">Der Typ der Elemente in der Sequenz.</typeparam>
      <returns>
        <see langword="true" />, wenn die beiden Sequenzen identisch sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceEqual``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Bestimmt, ob eine Spanne und eine schreibgeschützte Spanne identisch sind, indem die Elemente mit „IEquatable{T}.Equals(T)“ verglichen werden.</summary>
      <param name="span">Die zu vergleichende Spanne.</param>
      <param name="other">Die zu vergleichende schreibgeschützte Spanne.</param>
      <typeparam name="T">Der Typ der Elemente in der Sequenz.</typeparam>
      <returns>
        <see langword="true" />, wenn die beiden Sequenzen identisch sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Bestimmt, ob eine schreibgeschützte Zeichenspanne mit einem angegebenen Wert beginnt, wenn sie mit einem angegebenen <see cref="T:System.StringComparison" />-Wert verglichen wird.</summary>
      <param name="span">Die Quellspanne.</param>
      <param name="value">Die Sequenz, die mit dem Anfang der Quellspanne verglichen werden soll.</param>
      <param name="comparisonType">Ein Enumerationswert, der bestimmt, wie <paramref name="span" /> und <paramref name="value" /> verglichen werden.</param>
      <returns>
        <see langword="true" />, wenn <paramref name="value" /> mit dem Anfang von <paramref name="span" /> übereinstimmt, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Bestimmt, ob eine angegebene Sequenz am Anfang einer schreibgeschützten Spanne angezeigt wird.</summary>
      <param name="span">Die zu suchende schreibgeschützte Zeichenspanne.</param>
      <param name="value">Eine am Anfang von <paramref name="span" /> zu suchende Sequenz.</param>
      <typeparam name="T">Der Typ der Elemente in der Spanne.</typeparam>
      <returns>
        <see langword="true" />, wenn <paramref name="value" /> mit dem Anfang von <paramref name="span" /> übereinstimmt, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Bestimmt, ob eine angegebene Sequenz am Anfang einer Spanne angezeigt wird.</summary>
      <param name="span">Die zu suchende Spanne.</param>
      <param name="value">Eine am Anfang von <paramref name="span" /> zu suchende Sequenz.</param>
      <typeparam name="T">Der Typ der Elemente in der Spanne.</typeparam>
      <returns>
        <see langword="true" />, wenn <paramref name="value" /> mit dem Anfang von <paramref name="span" /> übereinstimmt, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToLower(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
      <summary>Kopiert die Zeichen aus der Quellspanne in das Ziel und konvertiert jedes Zeichen in Kleinbuchstaben, wobei die Regeln für die Groß-/Kleinschreibung der angegebenen Kultur verwendet werden.</summary>
      <param name="source">Die Quellspanne.</param>
      <param name="destination">Die Zielspanne, die die transformierten Zeichen enthält.</param>
      <param name="culture">Ein Objekt, das kulturspezifische Regeln zur Groß- und Kleinschreibung bereitstellt.</param>
      <returns>Die Anzahl der Zeichen, die in die Zielspanne geschrieben werden. Wenn das Ziel zu klein ist, wird -1 zurückgegeben.</returns>
      <exception cref="T:System.InvalidOperationException">Die Quell- und Zielpuffer überlappen sich.</exception>
    </member>
    <member name="M:System.MemoryExtensions.ToLowerInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
      <summary>Kopiert die Zeichen aus der Quellspanne in das Ziel und konvertiert jedes Zeichen in Kleinbuchstaben, wobei die Regeln für die Groß-/Kleinschreibung der invarianten Kultur verwendet werden.</summary>
      <param name="source">Die Quellspanne.</param>
      <param name="destination">Die Zielspanne, die die transformierten Zeichen enthält.</param>
      <returns>Die Anzahl der Zeichen, die in die Zielspanne geschrieben werden. Wenn das Ziel zu klein ist, wird -1 zurückgegeben.</returns>
      <exception cref="T:System.InvalidOperationException">Die Quell- und Zielpuffer überlappen sich.</exception>
    </member>
    <member name="M:System.MemoryExtensions.ToUpper(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
      <summary>Kopiert die Zeichen aus der Quellspanne in das Ziel und konvertiert jedes Zeichen in Kleinbuchstaben, wobei die Regeln für die Groß-/Kleinschreibung der angegebenen Kultur verwendet werden.</summary>
      <param name="source">Die Quellspanne.</param>
      <param name="destination">Die Zielspanne, die die transformierten Zeichen enthält.</param>
      <param name="culture">Ein Objekt, das kulturspezifische Regeln zur Groß- und Kleinschreibung bereitstellt.</param>
      <returns>Die Anzahl der Zeichen, die in die Zielspanne geschrieben werden. Wenn das Ziel zu klein ist, wird -1 zurückgegeben.</returns>
      <exception cref="T:System.InvalidOperationException">Die Quell- und Zielpuffer überlappen sich.</exception>
    </member>
    <member name="M:System.MemoryExtensions.ToUpperInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
      <summary>Kopiert die Zeichen aus der Quellspanne in das Ziel und konvertiert jedes Zeichen in Großbuchstaben, wobei die Regeln für die Groß-/Kleinschreibung der angegebenen Kultur verwendet werden.</summary>
      <param name="source">Die Quellspanne.</param>
      <param name="destination">Die Zielspanne, die die transformierten Zeichen enthält.</param>
      <returns>Die Anzahl der Zeichen, die in die Zielspanne geschrieben werden. Wenn das Ziel zu klein ist, wird -1 zurückgegeben.</returns>
      <exception cref="T:System.InvalidOperationException">Die Quell- und Zielpuffer überlappen sich.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.Memory{System.Char})">
      <summary>Entfernt alle führenden und nachfolgenden Leerzeichen aus einem Zeichenspeicherbereich.</summary>
      <param name="memory">Der Quellspeicher, aus dem die Zeichen entfernt werden.</param>
      <returns>Der zugeschnittene Zeichenspeicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlyMemory{System.Char})">
      <summary>Entfernt alle führenden und nachfolgenden Leerzeichen aus einem schreibgeschützten Zeichenspeicherbereich.</summary>
      <param name="memory">Der Quellspeicher, aus dem die Zeichen entfernt werden.</param>
      <returns>Der zugeschnittene Zeichenspeicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char})">
      <summary>Entfernt alle führenden und nachfolgenden Leerzeichen aus einer schreibgeschützten Zeichenspanne.</summary>
      <param name="span">Die Quellspanne, aus der die Zeichen entfernt werden.</param>
      <returns>Der zugeschnittene, schreibgeschützte Zeichenbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.Char)">
      <summary>Entfernt alle führenden und nachfolgenden Vorkommen eines bestimmten Zeichens aus einer schreibgeschützten Zeichenspanne.</summary>
      <param name="span">Die Quellspanne, aus der das Zeichen entfernt wird.</param>
      <param name="trimChar">Das angegebene Zeichen, das gesucht und entfernt werden soll.</param>
      <returns>Der zugeschnittene, schreibgeschützte Zeichenbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>Entfernt alle führenden und nachfolgenden Vorkommen einer Reihe von Zeichen, die in einer schreibgeschützten Spanne angegeben sind, aus einer schreibgeschützten Zeichenspanne.</summary>
      <param name="span">Die Quellspanne, aus der die Zeichen entfernt werden.</param>
      <param name="trimChars">Die Spanne, die den zu entfernenden Zeichensatz enthält.</param>
      <returns>Der zugeschnittene, schreibgeschützte Zeichenbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.Span{System.Char})">
      <summary>Entfernt alle führenden und nachfolgenden Leerzeichen aus einer Zeichenspanne.</summary>
      <param name="span">Die Quellspanne, aus der die Zeichen entfernt werden.</param>
      <returns>Der zugeschnittene Zeichenbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Memory{``0},``0)">
      <summary>Entfernt alle führenden und nachfolgenden Vorkommen eines angegebenen Elements aus einem Speicherbereich.</summary>
      <param name="memory">Der Quellspeicher, aus dem das Element entfernt wird.</param>
      <param name="trimElement">Das angegebene Element, das gesucht und entfernt werden soll.</param>
      <typeparam name="T">Der Typ der Elemente im Speicherbereich.</typeparam>
      <returns>Der zugeschnittene Speicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary>Entfernt alle führenden und nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einem Speicherbereich.</summary>
      <param name="memory">Der Quellspeicher, aus dem die Elemente entfernt werden.</param>
      <param name="trimElements">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</param>
      <typeparam name="T">Der Typ der Elemente im Speicherbereich.</typeparam>
      <returns>Der zugeschnittene Speicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},``0)">
      <summary>Entfernt alle führenden und nachfolgenden Vorkommen eines angegebenen Elements aus einem schreibgeschützten Speicherbereich.</summary>
      <param name="memory">Der Quellspeicher, aus dem das Element entfernt wird.</param>
      <param name="trimElement">Das angegebene Element, das gesucht und entfernt werden soll.</param>
      <typeparam name="T">Der Typ der Elemente im schreibgeschützten Speicherbereich.</typeparam>
      <returns>Der zugeschnittene, schreibgeschützte Speicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary>Entfernt alle führenden und nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einem schreibgeschützten Speicherbereich.</summary>
      <param name="memory">Der Quellspeicher, aus dem die Elemente entfernt werden.</param>
      <param name="trimElements">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</param>
      <typeparam name="T">Der Typ der Elemente im schreibgeschützten Speicherbereich.</typeparam>
      <returns>Der zugeschnittene, schreibgeschützte Speicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},``0)">
      <summary>Entfernt alle führenden und nachfolgenden Vorkommen eines angegebenen Elements aus einer schreibgeschützten Spanne.</summary>
      <param name="span">Die Quellspanne, aus der das Element entfernt wird.</param>
      <param name="trimElement">Das angegebene Element, das gesucht und entfernt werden soll.</param>
      <typeparam name="T">Der Typ der Elemente in der schreibgeschützten Spanne.</typeparam>
      <returns>Der zugeschnittene, schreibgeschützte Bereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Entfernt alle führenden und nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einer schreibgeschützten Spanne.</summary>
      <param name="span">Die Quellspanne, aus der die Elemente entfernt werden.</param>
      <param name="trimElements">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</param>
      <typeparam name="T">Der Typ der Elemente in der schreibgeschützten Spanne.</typeparam>
      <returns>Der zugeschnittene, schreibgeschützte Bereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Span{``0},``0)">
      <summary>Entfernt alle führenden und nachfolgenden Vorkommen eines angegebenen Elements aus einer Spanne.</summary>
      <param name="span">Die Quellspanne, aus der das Element entfernt wird.</param>
      <param name="trimElement">Das angegebene Element, das gesucht und entfernt werden soll.</param>
      <typeparam name="T">Der Typ der Elemente in der Spanne.</typeparam>
      <returns>Der zugeschnittene Bereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Entfernt alle führenden und nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einer Spanne.</summary>
      <param name="span">Die Quellspanne, aus der die Elemente entfernt werden.</param>
      <param name="trimElements">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</param>
      <typeparam name="T">Der Typ der Elemente in der Spanne.</typeparam>
      <returns>Der zugeschnittene Bereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.Memory{System.Char})">
      <summary>Entfernt alle nachfolgenden Leerzeichen aus einem Zeichenspeicherbereich.</summary>
      <param name="memory">Der Quellspeicher, aus dem die Zeichen entfernt werden.</param>
      <returns>Der zugeschnittene Zeichenspeicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlyMemory{System.Char})">
      <summary>Entfernt alle nachfolgenden Leerzeichen aus einem schreibgeschützten Zeichenspeicherbereich.</summary>
      <param name="memory">Der Quellspeicher, aus dem die Zeichen entfernt werden.</param>
      <returns>Der zugeschnittene, schreibgeschützte Zeichenbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char})">
      <summary>Entfernt alle nachfolgenden Leerzeichen aus einer schreibgeschützten Zeichenspanne.</summary>
      <param name="span">Die Quellspanne, aus der die Zeichen entfernt werden.</param>
      <returns>Der zugeschnittene, schreibgeschützte Zeichenbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.Char)">
      <summary>Entfernt alle nachfolgenden Vorkommen eines bestimmten Zeichens aus einer schreibgeschützten Spanne.</summary>
      <param name="span">Die Quellspanne, aus der das Zeichen entfernt wird.</param>
      <param name="trimChar">Das angegebene Zeichen, das gesucht und entfernt werden soll.</param>
      <returns>Der zugeschnittene, schreibgeschützte Zeichenbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>Entfernt alle nachfolgenden Vorkommen einer Reihe von Zeichen, die in einer schreibgeschützten Spanne angegeben sind, aus einer schreibgeschützten Zeichenspanne.</summary>
      <param name="span">Die Quellspanne, aus der die Zeichen entfernt werden.</param>
      <param name="trimChars">Die Spanne, die den zu entfernenden Zeichensatz enthält.</param>
      <returns>Der zugeschnittene, schreibgeschützte Zeichenbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.Span{System.Char})">
      <summary>Entfernt alle nachfolgenden Leerzeichen aus einer Zeichenspanne.</summary>
      <param name="span">Die Quellspanne, aus der die Zeichen entfernt werden.</param>
      <returns>Der zugeschnittene Zeichenbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},``0)">
      <summary>Entfernt alle nachfolgenden Vorkommen eines angegebenen Elements aus einem Zeichenspeicherbereich.</summary>
      <param name="memory">Der Quellspeicher, aus dem das Element entfernt wird.</param>
      <param name="trimElement">Das angegebene Element, das gesucht und entfernt werden soll.</param>
      <typeparam name="T">Der Typ der Elemente im Speicherbereich.</typeparam>
      <returns>Der zugeschnittene Speicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary>Entfernt alle nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einem Speicherbereich.</summary>
      <param name="memory">Der Quellspeicher, aus dem die Elemente entfernt werden.</param>
      <param name="trimElements">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</param>
      <typeparam name="T">Der Typ der Elemente im Speicherbereich.</typeparam>
      <returns>Der zugeschnittene Speicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},``0)">
      <summary>Entfernt alle nachfolgenden Vorkommen eines angegebenen Elements aus einem schreibgeschützten Speicherbereich.</summary>
      <param name="memory">Der Quellspeicher, aus dem das Element entfernt wird.</param>
      <param name="trimElement">Das angegebene Element, das gesucht und entfernt werden soll.</param>
      <typeparam name="T">Der Typ der Elemente im schreibgeschützten Speicherbereich.</typeparam>
      <returns>Der zugeschnittene, schreibgeschützte Speicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary>Entfernt alle nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einem schreibgeschützten Speicherbereich.</summary>
      <param name="memory">Der Quellspeicher, aus dem die Elemente entfernt werden.</param>
      <param name="trimElements">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</param>
      <typeparam name="T">Der Typ der Elemente im schreibgeschützten Speicherbereich.</typeparam>
      <returns>Der zugeschnittene, schreibgeschützte Speicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},``0)">
      <summary>Entfernt alle nachfolgenden Vorkommen eines angegebenen Elements aus einer schreibgeschützten Spanne.</summary>
      <param name="span">Die Quellspanne, aus der das Element entfernt wird.</param>
      <param name="trimElement">Das angegebene Element, das gesucht und entfernt werden soll.</param>
      <typeparam name="T">Der Typ der Elemente in der schreibgeschützten Spanne.</typeparam>
      <returns>Der zugeschnittene, schreibgeschützte Bereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Entfernt alle nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einer schreibgeschützten Spanne.</summary>
      <param name="span">Die Quellspanne, aus der die Elemente entfernt werden.</param>
      <param name="trimElements">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</param>
      <typeparam name="T">Der Typ der Elemente in der schreibgeschützten Spanne.</typeparam>
      <returns>Der zugeschnittene, schreibgeschützte Bereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},``0)">
      <summary>Entfernt alle nachfolgenden Vorkommen eines angegebenen Elements aus einer Spanne.</summary>
      <param name="span">Die Quellspanne, aus der das Element entfernt wird.</param>
      <param name="trimElement">Das angegebene Element, das gesucht und entfernt werden soll.</param>
      <typeparam name="T">Der Typ der Elemente in der Spanne.</typeparam>
      <returns>Der zugeschnittene Bereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Entfernt alle nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einer Spanne.</summary>
      <param name="span">Die Quellspanne, aus der die Elemente entfernt werden.</param>
      <param name="trimElements">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</param>
      <typeparam name="T">Der Typ der Elemente in der Spanne.</typeparam>
      <returns>Der zugeschnittene Bereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.Memory{System.Char})">
      <summary>Entfernt alle führenden Leerzeichen aus einem Speicherbereich.</summary>
      <param name="memory">Der Quellspeicher, aus dem die Zeichen entfernt werden.</param>
      <returns>Der zugeschnittene Zeichenspeicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlyMemory{System.Char})">
      <summary>Entfernt alle führenden Leerzeichen aus einem schreibgeschützten Speicherbereich.</summary>
      <param name="memory">Der Quellspeicher, aus dem die Zeichen entfernt werden.</param>
      <returns>Der zugeschnittene, schreibgeschützte Zeichenspeicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char})">
      <summary>Entfernt alle führenden Leerzeichen aus einer schreibgeschützten Spanne.</summary>
      <param name="span">Die Quellspanne, aus der die Zeichen entfernt werden.</param>
      <returns>Der zugeschnittene, schreibgeschützte Zeichenbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.Char)">
      <summary>Entfernt alle führenden Vorkommen eines bestimmten Zeichens aus der Spanne.</summary>
      <param name="span">Die Quellspanne, aus der das Zeichen entfernt wird.</param>
      <param name="trimChar">Das angegebene Zeichen, das gesucht und entfernt werden soll.</param>
      <returns>Der zugeschnittene, schreibgeschützte Zeichenbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>Entfernt alle führenden Vorkommen einer Reihe von Zeichen, die in einer schreibgeschützten Spanne angegeben sind, aus der Spanne.</summary>
      <param name="span">Die Quellspanne, aus der die Zeichen entfernt werden.</param>
      <param name="trimChars">Die Spanne, die den zu entfernenden Zeichensatz enthält.</param>
      <returns>Der zugeschnittene, schreibgeschützte Zeichenbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.Span{System.Char})">
      <summary>Entfernt alle führenden Leerzeichen aus einer Spanne.</summary>
      <param name="span">Die Quellspanne, aus der die Zeichen entfernt werden.</param>
      <returns>Der zugeschnittene Zeichenbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},``0)">
      <summary>Entfernt alle führenden Vorkommen eines angegebenen Elements aus einem Speicherbereich.</summary>
      <param name="memory">Der Quellspeicherbereich, aus dem das Element entfernt wird.</param>
      <param name="trimElement">Das angegebene Element, das gesucht und entfernt werden soll.</param>
      <typeparam name="T">Der Typ der Elemente im Speicherbereich.</typeparam>
      <returns>Der zugeschnittene Speicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary>Entfernt alle führenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einem Speicherbereich.</summary>
      <param name="memory">Der Quellspeicher, aus dem die Elemente entfernt werden.</param>
      <param name="trimElements">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</param>
      <typeparam name="T">Der Typ der Elemente im Speicherbereich.</typeparam>
      <returns>Der zugeschnittene Speicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},``0)">
      <summary>Entfernt alle führenden Vorkommen eines angegebenen Elements aus einem Speicherbereich.</summary>
      <param name="memory">Der Quellspeicher, aus dem das Element entfernt wird.</param>
      <param name="trimElement">Das angegebene Element, das gesucht und entfernt werden soll.</param>
      <typeparam name="T">Der Typ der Elemente im schreibgeschützten Speicherbereich.</typeparam>
      <returns>Der zugeschnittene, schreibgeschützte Speicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary>Entfernt alle führenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einem Speicherbereich.</summary>
      <param name="memory">Der Quellspeicher, aus dem die Elemente entfernt werden.</param>
      <param name="trimElements">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</param>
      <typeparam name="T">Der Typ der Elemente im schreibgeschützten Speicherbereich.</typeparam>
      <returns>Der zugeschnittene, schreibgeschützte Speicherbereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},``0)">
      <summary>Entfernt alle führenden Vorkommen eines bestimmten Elements aus der Spanne.</summary>
      <param name="span">Die Quellspanne, aus der das Element entfernt wird.</param>
      <param name="trimElement">Das angegebene Element, das gesucht und entfernt werden soll.</param>
      <typeparam name="T">Der Typ der Elemente in der schreibgeschützten Spanne.</typeparam>
      <returns>Der zugeschnittene, schreibgeschützte Bereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Entfernt alle führenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus der Spanne.</summary>
      <param name="span">Die Quellspanne, aus der die Elemente entfernt werden.</param>
      <param name="trimElements">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</param>
      <typeparam name="T">Der Typ der Elemente in der schreibgeschützten Spanne.</typeparam>
      <returns>Der zugeschnittene, schreibgeschützte Bereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},``0)">
      <summary>Entfernt alle führenden Vorkommen eines bestimmten Elements aus der Spanne.</summary>
      <param name="span">Die Quellspanne, aus der das Element entfernt wird.</param>
      <param name="trimElement">Das angegebene Element, das gesucht und entfernt werden soll.</param>
      <typeparam name="T">Der Typ der Elemente in der Spanne.</typeparam>
      <returns>Der zugeschnittene Bereich.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Entfernt alle führenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus der Spanne.</summary>
      <param name="span">Die Quellspanne, aus der die Elemente entfernt werden.</param>
      <param name="trimElements">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</param>
      <typeparam name="T">Der Typ der Elemente in der Spanne.</typeparam>
      <returns>Der zugeschnittene Bereich.</returns>
    </member>
    <member name="T:System.Runtime.InteropServices.MemoryMarshal">
      <summary>Stellt Methoden für die Interoperabilität mit <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />, <see cref="T:System.Span`1" /> und <see cref="T:System.ReadOnlySpan`1" /> bereit.</summary>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.ReadOnlySpan{``0})">
      <summary>Wandelt ein <see cref="T:System.ReadOnlySpan`1" /> eines primitiven Typs, <paramref name="T" />, in ein <see langword="ReadOnlySpan&lt;Byte&gt;" /> um.</summary>
      <param name="span">Der zu konvertierende Quellslice.</param>
      <typeparam name="T">Der Typ der Elemente in der schreibgeschützten Spanne.</typeparam>
      <returns>Der schreibgeschützte Span des Typs <see cref="T:System.Byte" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> enthält Verweise oder Zeiger.</exception>
      <exception cref="T:System.OverflowException">Die <see cref="P:System.ReadOnlySpan`1.Length" />-Eigenschaft des neuen <see cref="T:System.ReadOnlySpan`1" /> würde <see cref="F:System.Int32.MaxValue" /> überschreiten.</exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.Span{``0})">
      <summary>Wandelt ein <see cref="T:System.Span`1" /> eines primitiven Typs, <paramref name="T" />, in ein <see langword="Span&lt;Byte&gt;" /> um.</summary>
      <param name="span">Der zu konvertierende Quellslice.</param>
      <typeparam name="T">Der Typ der Elemente in der Spanne.</typeparam>
      <returns>Ein Span des Typs <see cref="T:System.Byte" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> enthält Verweise oder Zeiger.</exception>
      <exception cref="T:System.OverflowException">Die <see cref="P:System.Span`1.Length" />-Eigenschaft des neuen <see cref="T:System.Span`1" /> würde <see cref="F:System.Int32.MaxValue" /> überschreiten.</exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsMemory``1(System.ReadOnlyMemory{``0})">
      <summary>Erstellt eine <see cref="T:System.Memory`1" />-Instanz aus einem <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <param name="memory">Der schreibgeschützte Speicherpuffer.</param>
      <typeparam name="T">Der Typ der Elemente im schreibgeschützten Speicherpuffer.</typeparam>
      <returns>Ein Arbeitsspeicherblock, der den gleichen Speicher wie <see cref="T:System.ReadOnlyMemory`1" /> darstellt.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.ReadOnlySpan{System.Byte})">
      <summary>Interpretiert einen schreibgeschützten Bereich von Bytes neu als schreibgeschützten Verweis auf die Struktur vom Typ <paramref name="T" />.</summary>
      <param name="span">Der neu zu interpretierende Bereich.</param>
      <typeparam name="T">Der Typ des zurückgegebenen Verweises.</typeparam>
      <returns>Der schreibgeschützte Verweis auf die Struktur vom Typ <paramref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.Span{System.Byte})">
      <summary>Interpretiert einen Bereich von Bytes neu als Verweis auf die Struktur vom Typ <paramref name="T" />.</summary>
      <param name="span">Der neu zu interpretierende Bereich.</param>
      <typeparam name="T">Der Typ des zurückgegebenen Verweises.</typeparam>
      <returns>Der Verweis auf die Struktur vom Typ <paramref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.ReadOnlySpan{``0})">
      <summary>Wandelt einen schreibgeschützten Span eines primitiven Typs in einen schreibgeschützten Span eines anderen primitiven Typs um.</summary>
      <param name="span">Der zu konvertierende Quellslice.</param>
      <typeparam name="TFrom">Der Typ der Quell Spanne.</typeparam>
      <typeparam name="TTo">Der Typ der Zielspanne.</typeparam>
      <returns>Die konvertierte schreibgeschützte Span.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="TFrom" /> oder <paramref name="TTo" /> enthält Verweise oder Zeiger.</exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.Span{``0})">
      <summary>Wandelt einen Span eines primitiven Typs in einen Span eines anderen primitiven Typs um.</summary>
      <param name="span">Der zu konvertierende Quellslice.</param>
      <typeparam name="TFrom">Der Typ der Quell Spanne.</typeparam>
      <typeparam name="TTo">Der Typ der Zielspanne.</typeparam>
      <returns>Der konvertierte Span.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="TFrom" /> oder <paramref name="TTo" /> enthält Verweise oder Zeiger.</exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateFromPinnedArray``1(``0[],System.Int32,System.Int32)">
      <summary>Erstellt einen neuen Speicherpuffer über dem Abschnitt des bereits angehefteten Zielarrays, der beim Index <paramref name="start" /> beginnt und aus <paramref name="length" />-Elementen besteht.</summary>
      <param name="array">Das bereits angeheftete Quellarray.</param>
      <param name="start">Der Index von <paramref name="array" />, bei dem der Speicherblock begonnen wird.</param>
      <param name="length">Die Anzahl der Elemente, die in den Speicherblock eingeschlossen werden sollen.</param>
      <typeparam name="T">Der Typ des Arrays.</typeparam>
      <returns>Ein Speicherblock über die angegebenen Elemente von <paramref name="array" />. Wenn <paramref name="array" /><see langword="null" /> ist, oder wenn <paramref name="start" /> und <paramref name="length" /> 0 sind, gibt die Methode eine <see cref="T:System.Memory`1" /> Instanz von <see cref="P:System.Memory`1.Length" /> Null wieder.</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="array" /> ist kovariant, und den Typ von <paramref name="array" /> ist nicht genau <paramref name="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="start" />- oder der Endindex liegt nicht im Bereich von 0 bis <see cref="P:System.Array.Length" />.</exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan``1(``0@,System.Int32)">
      <summary>Erstellt ein neues schreibgeschützten Span über einen Teil eines regulären verwalteten Objekts.</summary>
      <param name="reference">Ein Verweis auf Daten.</param>
      <param name="length">Die Anzahl der <paramref name="T" />-Elemente, die in <paramref name="reference" /> enthalten sind.</param>
      <typeparam name="T">Der Typ der Datenelemente.</typeparam>
      <returns>Ein schreibgeschützter Span.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateSpan``1(``0@,System.Int32)">
      <summary>Erstellt einen neuen Span über einen Teil eines regulären verwalteten Objekts.</summary>
      <param name="reference">Ein Verweis auf Daten.</param>
      <param name="length">Die Anzahl der <paramref name="T" />-Elemente, die in <paramref name="reference" /> enthalten sind.</param>
      <typeparam name="T">Der Typ der Datenelemente.</typeparam>
      <returns>Ein Span.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.ReadOnlySpan{``0})">
      <summary>Gibt einen Verweis auf das Element des schreibgeschützten Span bei Index 0 zurück.</summary>
      <param name="span">Der schreibgeschützte Span, aus dem der Verweis abgerufen wird.</param>
      <typeparam name="T">Der Typ der Elemente in der Spanne.</typeparam>
      <returns>Ein Verweis auf das Element bei Index 0.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.Span{``0})">
      <summary>Gibt einen Verweis auf das Element des Span bei Index 0 zurück.</summary>
      <param name="span">Der Span, aus dem der Verweis abgerufen wird.</param>
      <typeparam name="T">Der Typ der Elemente in der Spanne.</typeparam>
      <returns>Ein Verweis auf das Element bei Index 0.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Read``1(System.ReadOnlySpan{System.Byte})">
      <summary>Liest eine Struktur des Typ <param name="T" /> aus dem schreibgeschützten Bytes-Span.</summary>
      <param name="source">Ein schreibgeschützter Span.</param>
      <typeparam name="T">Der Typ des Elements, das aus der schreibgeschützten Spanne abgerufen werden soll.</typeparam>
      <returns>Die aus dem schreibgeschützten Span abgerufene Struktur.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> enthält Verweise oder Zeiger.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> ist kleiner als <paramref name="T" />.</exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.ToEnumerable``1(System.ReadOnlyMemory{``0})">
      <summary>Erstellt eine <see cref="T:System.Collections.Generic.IEnumerable`1" />-Ansicht des angegebenen schreibgeschützten Speicherpuffers.</summary>
      <param name="memory">Ein schreibgeschützter Speicherpuffer.</param>
      <typeparam name="T">Der Typ der Elemente im schreibgeschützten Speicherpuffer.</typeparam>
      <returns>Eine aufzählbare Ansicht von <paramref name="memory" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetArray``1(System.ReadOnlyMemory{``0},System.ArraySegment{``0}@)">
      <summary>Versucht, ein Arraysegment aus dem zugrunde liegenden Speicherpuffer abzurufen. Der Rückgabewert gibt den Erfolg des Vorgangs an.</summary>
      <param name="memory">Ein schreibgeschützter Speicherpuffer.</param>
      <param name="segment">Wenn diese Methode ein Ergebnis zurückgibt, enthält sie das Arraysegment, das aus dem zugrunde liegenden schreibgeschützten Speicherpuffer abgerufen wurde. Wenn die Methode fehlschlägt, gibt die Methode ein Standardarraysegment zurück.</param>
      <typeparam name="T">Der Typ der Elemente im schreibgeschützten Speicherpuffer.</typeparam>
      <returns>
        <see langword="true" />, wenn der Aufruf der Methode erfolgreich ist; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@)">
      <summary>Versucht, den <see cref="T:System.Buffers.MemoryManager`1" /> aus dem zugrunde liegenden schreibgeschützten Speicherpuffer abzurufen.</summary>
      <param name="memory">Der schreibgeschützten Speicherpuffer, für den der Speicher-Manager abgerufen werden soll.</param>
      <param name="manager">Wenn die Methode ein Ergebnis zurückgibt, der Manager von <paramref name="memory" />.</param>
      <typeparam name="T">Der Typ der Elemente im schreibgeschützten Speicherpuffer.</typeparam>
      <typeparam name="TManager">Der Typ des <see cref="T:System.Buffers.MemoryManager`1" /> abzurufenden.</typeparam>
      <returns>
        <see langword="true" />, wenn die Methode den Speicher-Manager abruft, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@,System.Int32@,System.Int32@)">
      <summary>Versucht, den <see cref="T:System.Buffers.MemoryManager`1" />, den Startindex und die Länge aus dem zugrunde liegenden schreibgeschützten Speicherpuffer abzurufen.</summary>
      <param name="memory">Der schreibgeschützten Speicherpuffer, für den der Speicher-Manager abgerufen werden soll.</param>
      <param name="manager">Wenn die Methode ein Ergebnis zurückgibt, der Manager von <paramref name="memory" />.</param>
      <param name="start">Wenn die Methode ein Ergebnis zurückgibt, der Offset ab dem Beginn des <paramref name="manager" />, den der <paramref name="memory" /> darstellt.</param>
      <param name="length">Wenn die Methode ein Ergebnis zurückgibt, der Länge des <paramref name="manager" />, den der <paramref name="memory" /> darstellt.</param>
      <typeparam name="T">Der Typ der Elemente im schreibgeschützten Speicherpuffer.</typeparam>
      <typeparam name="TManager">Der Typ des <see cref="T:System.Buffers.MemoryManager`1" /> abzurufenden.</typeparam>
      <returns>
        <see langword="true" />, wenn die Methode erfolgreich ausgeführt wurde, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetString(System.ReadOnlyMemory{System.Char},System.String@,System.Int32@,System.Int32@)">
      <summary>Versucht, die zugrunde liegenden Zeichenfolge aus einem <see langword="System.ReadOnlyMemory&lt;Char&gt;" /> abzurufen.</summary>
      <param name="memory">Schreibgeschützter Speicher mit einem Block an Zeichen.</param>
      <param name="text">Wenn die Methode ein Ergebnis zurückgibt, die Zeichenfolge im Speicherpuffer.</param>
      <param name="start">Die Anfangsposition in <paramref name="text" />.</param>
      <param name="length">Die Anzahl von Zeichen in <paramref name="text" />.</param>
      <returns>
        <see langword="true" />, wenn die Methode die zugrunde liegende Zeichenfolge erfolgreich abruft, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryRead``1(System.ReadOnlySpan{System.Byte},``0@)">
      <summary>Versucht, eine Struktur vom Typ <paramref name="T" /> aus einem schreibgeschützten Bereich von Bytes zu lesen.</summary>
      <param name="source">Ein schreibgeschützter Bytes-Span.</param>
      <param name="value">Wenn die Methode ein Ergebnis zurückgibt, eine Instanz von <paramref name="T" />.</param>
      <typeparam name="T">Der Typ der abzurufenden-Struktur.</typeparam>
      <returns>
        <see langword="true" />, wenn die Methode erfolgreich eine Instanz der Struktur abruft, andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> enthält Verweise oder Zeiger.</exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryWrite``1(System.Span{System.Byte},``0@)">
      <summary>Versucht, eine Struktur vom Typ <paramref name="T" /> in einen Bereich von Bytes zu schreiben.</summary>
      <param name="destination">Der Bytes-Span, der die Struktur enthält.</param>
      <param name="value">Die Struktur, die in den Span geschrieben werden soll.</param>
      <typeparam name="T">Der Typ der Struktur.</typeparam>
      <returns>
        <see langword="true" />, wenn der Schreibvorgang erfolgreich ausgeführt wurde, andernfalls <see langword="false" />. Die Methode gibt <see langword="false" /> zurück, wenn der Bereich zu klein ist für den <paramref name="T" /> ist.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> enthält Verweise oder Zeiger.</exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Write``1(System.Span{System.Byte},``0@)">
      <summary>Schreibt eine Struktur vom Typ <paramref name="T" /> in einen Bereich von Bytes.</summary>
      <param name="destination">Der Bytes-Span, der die Struktur enthält.</param>
      <param name="value">Die Struktur, die in den Span geschrieben werden soll.</param>
      <typeparam name="T">Der Typ der Struktur.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> enthält Verweise oder Zeiger.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> ist zu klein für <paramref name="value" />.</exception>
    </member>
    <member name="T:System.Runtime.InteropServices.SequenceMarshal">
      <summary>Stellt eine Sammlung von Methoden für die Interoperabilität mit <see cref="T:System.Buffers.ReadOnlySequence`1" /> zur Verfügung.</summary>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetArray``1(System.Buffers.ReadOnlySequence{``0},System.ArraySegment{``0}@)">
      <summary>Ruft ein Arraysegment aus der zugrunde liegenden schreibgeschützten Sequenz ab.</summary>
      <param name="sequence">Die schreibgeschützte Sequenz, aus der das Arraysegment abgerufen wird.</param>
      <param name="segment">Das zurückgegebene Arraysegment.</param>
      <typeparam name="T">Der Typ der schreibgeschützten Sequenz.</typeparam>
      <returns>
        <see langword="true" />, wenn es möglich ist, das Arraysegment abzurufen, andernfalls wird <see langword="false" /> und ein Standardarraysegment zurückgegeben.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlyMemory``1(System.Buffers.ReadOnlySequence{``0},System.ReadOnlyMemory{``0}@)">
      <summary>Versucht, einen schreibgeschützten Arbeitsspeicher aus der angegebenen schreibgeschützten Sequenz abzurufen.</summary>
      <param name="sequence">Die schreibgeschützte Sequenz, aus der der Arbeitsspeicher abgerufen wird.</param>
      <param name="memory">Der zurückgegebene schreibgeschützte Arbeitsspeicher vom Typ T.</param>
      <typeparam name="T">Der Typ der schreibgeschützten Sequenz.</typeparam>
      <returns>
        <see langword="true" />, wenn der schreibgeschützte Arbeitsspeicher abgerufen werden kann, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlySequenceSegment``1(System.Buffers.ReadOnlySequence{``0},System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@,System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@)">
      <summary>Versucht, ein schreibgeschütztes Sequenzsegment aus der angegebenen schreibgeschützten Sequenz abzurufen.</summary>
      <param name="sequence">Die schreibgeschützte Sequenz, aus der das schreibgeschützte Sequenzsegment abgerufen wird.</param>
      <param name="startSegment">Das anfängliche schreibgeschützte Sequenzsegment.</param>
      <param name="startIndex">Die anfängliche Position.</param>
      <param name="endSegment">Das abschließende schreibgeschützte Sequenzsegment.</param>
      <param name="endIndex">Die Endposition.</param>
      <typeparam name="T">Der Typ der schreibgeschützten Sequenz.</typeparam>
      <returns>
        <see langword="true" />, wenn das schreibgeschützte Sequenzsegment abgerufen werden kann, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryRead``1(System.Buffers.SequenceReader{System.Byte}@,``0@)">
      <summary>Versucht, den angegebenen Typ aus dem Puffer zu lesen. Es ist gefährlich, diese Methode mit beliebigen Strukturen zu verwenden – weitere Informationen finden Sie unter den Hinweisen.</summary>
      <param name="reader">Ein Verweis auf den Sequenzleser.</param>
      <param name="value">Der zurückgegebene Wert, wenn der Lesevorgang erfolgreich war. Bei einem Fehler ist <paramref name="value" /><see langword="default" /> (aufgrund von unzureichendem Speicherplatz).</param>
      <typeparam name="T">Der Typ des Werts.</typeparam>
      <returns>
        <see langword="true" />, wenn der Leseversuch erfolgreich war, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="T:System.SequencePosition">
      <summary>Stellt eine Position in mehreren nicht zusammenhängenden Speichern dar. Eigenschaften dieses Typs sollten nur von dem Typ interpretiert werden, der sie erstellt hat.</summary>
    </member>
    <member name="M:System.SequencePosition.#ctor(System.Object,System.Int32)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.SequencePosition" />-Struktur.</summary>
      <param name="object">Mehrere nicht zusammenhängende Speicher.</param>
      <param name="integer">Die Position in <paramref name="object" />.</param>
    </member>
    <member name="M:System.SequencePosition.Equals(System.Object)">
      <summary>Gibt einen Wert zurück, der angibt, ob die aktuelle Instanz gleich einem anderen Objekt ist.</summary>
      <param name="obj">Das Objekt, das mit der aktuellen Instanz verglichen werden soll.</param>
      <returns>
        <see langword="true" />, wenn <paramref name="obj" /> gleich der Typstruktur <see cref="T:System.SequencePosition" /> und der aktuellen Instanz ist; sonst <see langword="false" />.</returns>
    </member>
    <member name="M:System.SequencePosition.Equals(System.SequencePosition)">
      <summary>Gibt an, ob die aktuelle Instanz gleich einer anderen <see cref="T:System.SequencePosition" />-Struktur ist.</summary>
      <param name="other">Die Sequenzposition, die mit der aktuellen Instanz verglichen werden soll.</param>
      <returns>
        <see langword="true" />, wenn die beiden Instanzen genau gleich sind; sonst <see langword="false" />.</returns>
    </member>
    <member name="M:System.SequencePosition.GetHashCode">
      <summary>Gibt den Hashcode für diese Instanz zurück.</summary>
      <returns>Der Hashcode für diese Instanz.</returns>
    </member>
    <member name="M:System.SequencePosition.GetInteger">
      <summary>Gibt den ganzzahligen Teil dieser <see cref="T:System.SequencePosition" /> zurück.</summary>
      <returns>Der ganzzahlige Teil dieser Sequenzposition.</returns>
    </member>
    <member name="M:System.SequencePosition.GetObject">
      <summary>Gibt den Objektteil dieser <see cref="T:System.SequencePosition" /> zurück.</summary>
      <returns>Der Objektteil dieser Sequenzposition.</returns>
    </member>
    <member name="T:System.Text.SpanRuneEnumerator">
      <summary>Stellt einen Enumerator für die <see cref="T:System.Text.Rune" />-Werte bereit, die durch einen Bereich dargestellt werden, der UTF-16-Text enthält</summary>
    </member>
    <member name="P:System.Text.SpanRuneEnumerator.Current">
      <summary>Ruft <see cref="T:System.Text.Rune" /> an der aktuellen Position des Enumerators ab.</summary>
      <returns>Das <see cref="T:System.Text.Rune" /> -Element an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="M:System.Text.SpanRuneEnumerator.GetEnumerator">
      <summary>Gibt die aktuelle Enumeratorinstanz zurück</summary>
      <returns>Die aktuelle Enumeratorinstanz</returns>
    </member>
    <member name="M:System.Text.SpanRuneEnumerator.MoveNext">
      <summary>Legt den Enumerator auf das nächste <see cref="T:System.Text.Rune" />-Element des Bereichs fest</summary>
      <returns>
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element festgelegt wurde; <see langword="false" />, wenn das Ende des Bereichs erreicht wurde</returns>
    </member>
  </members>
</doc>