<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Security.Cryptography.Algorithms</name>
  </assembly>
  <members>
    <member name="T:System.Security.Cryptography.Aes">
      <summary>Representa la clase base abstracta desde la que deben heredarse todas las implementaciones de AES (Advanced Encryption Standard).</summary>
    </member>
    <member name="M:System.Security.Cryptography.Aes.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.Aes" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.Aes.Create">
      <summary>Crea un objeto criptográfico que se usa para realizar el algoritmo simétrico.</summary>
      <returns>Objeto criptográfico que se usa para realizar el algoritmo simétrico.</returns>
    </member>
    <member name="M:System.Security.Cryptography.Aes.Create(System.String)">
      <summary>Crea un objeto criptográfico que especifica la implementación de AES que se usará para realizar el algoritmo simétrico.</summary>
      <param name="algorithmName">Nombre de la implementación específica de AES que se va a usar.</param>
      <returns>Objeto criptográfico que se usa para realizar el algoritmo simétrico.</returns>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="algorithmName" /> es <see langword="null" />.</exception>
    </member>
    <member name="T:System.Security.Cryptography.AesCcm">
      <summary>Representa una clave de Estándar de cifrado avanzado (AES) que se va a usar con el contador mediante el modo de operación CBC-MAC (CCM).</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.#ctor(System.Byte[])">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.AesCcm" /> con la clave proporcionada.</summary>
      <param name="key">Clave secreta que se va a usar para esta instancia.</param>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="key" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La longitud del parámetro <paramref name="key" /> es distinta de 16, 24 o 32 bytes (128, 192 o 256 bits).</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.#ctor(System.ReadOnlySpan{System.Byte})">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.AesCcm" /> con la clave proporcionada.</summary>
      <param name="key">Clave secreta que se va a usar para esta instancia.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La longitud del parámetro <paramref name="key" /> es distinta de 16, 24 o 32 bytes (128, 192 o 256 bits).</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.Decrypt(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
      <summary>Descifra el texto cifrado en el búfer de destino proporcionado si se puede validar la etiqueta de autenticación.</summary>
      <param name="nonce">Nonce asociado a este mensaje, que debe coincidir con el valor proporcionado durante el cifrado.</param>
      <param name="ciphertext">Contenido cifrado que se va a descifrar.</param>
      <param name="tag">Etiqueta de autenticación generada para este mensaje durante el cifrado.</param>
      <param name="plaintext">Matriz de bytes que va a recibir los contenidos descifrados.</param>
      <param name="associatedData">Datos adicionales asociados con este mensaje, que deben coincidir con el valor proporcionado durante el cifrado.</param>
      <exception cref="T:System.ArgumentException">El parámetro <paramref name="plaintext" /> y <paramref name="ciphertext" /> no tienen la misma longitud.
o bien
<see cref="P:System.Security.Cryptography.AesCcm.NonceByteSizes" /> no permite la longitud del parámetro <paramref name="nonce" />.
O bien
<see cref="P:System.Security.Cryptography.AesCcm.TagByteSizes" /> no permite la longitud del parámetro <paramref name="tag" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="nonce" />, <paramref name="ciphertext" />, <paramref name="tag" /> o el parámetro <paramref name="plaintext" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido comprobar el valor de la etiqueta o se ha producido un error en la operación de descifrado.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.Decrypt(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Descifra el texto cifrado en el búfer de destino proporcionado si se puede validar la etiqueta de autenticación.</summary>
      <param name="nonce">Nonce asociado a este mensaje, que debe coincidir con el valor proporcionado durante el cifrado.</param>
      <param name="ciphertext">Contenido cifrado que se va a descifrar.</param>
      <param name="tag">Etiqueta de autenticación generada para este mensaje durante el cifrado.</param>
      <param name="plaintext">Intervalo de bytes que va a recibir los contenidos descifrados.</param>
      <param name="associatedData">Datos adicionales asociados con este mensaje, que deben coincidir con el valor proporcionado durante el cifrado.</param>
      <exception cref="T:System.ArgumentException">El parámetro <paramref name="plaintext" /> y <paramref name="ciphertext" /> no tienen la misma longitud.
O bien
<see cref="P:System.Security.Cryptography.AesCcm.NonceByteSizes" /> no permite la longitud del parámetro <paramref name="nonce" />.
O bien
<see cref="P:System.Security.Cryptography.AesCcm.TagByteSizes" /> no permite la longitud del parámetro <paramref name="tag" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido comprobar el valor de la etiqueta o se ha producido un error en la operación de descifrado.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.Dispose">
      <summary>Libera los recursos utilizados por la instancia actual de la clase <see cref="T:System.Security.Cryptography.AesCcm" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.Encrypt(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
      <summary>Cifra el texto no cifrado en el búfer de destino de texto cifrado y genera la etiqueta de autenticación en un búfer independiente.</summary>
      <param name="nonce">Nonce asociado a este mensaje, que debe ser un valor único para cada operación con la misma clave.</param>
      <param name="plaintext">Contenido que se va a cifrar.</param>
      <param name="ciphertext">Matriz de bytes que va a recibir los contenidos cifrados.</param>
      <param name="tag">Matriz de bytes que va a recibir la etiqueta de autenticación generada.</param>
      <param name="associatedData">Datos adicionales asociados a este mensaje, que también se deben proporcionar durante el descifrado.</param>
      <exception cref="T:System.ArgumentException">El parámetro <paramref name="plaintext" /> y <paramref name="ciphertext" /> no tienen la misma longitud.
o bien
<see cref="P:System.Security.Cryptography.AesCcm.NonceByteSizes" /> no permite la longitud del parámetro <paramref name="nonce" />.
O bien
<see cref="P:System.Security.Cryptography.AesCcm.TagByteSizes" /> no permite la longitud del parámetro <paramref name="tag" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="nonce" />, <paramref name="ciphertext" />, <paramref name="tag" /> o el parámetro <paramref name="plaintext" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Se ha producido un error en la operación de cifrado.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.Encrypt(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Cifra el texto no cifrado en el búfer de destino de texto cifrado y genera la etiqueta de autenticación en un búfer independiente.</summary>
      <param name="nonce">Nonce asociado a este mensaje, que debe ser un valor único para cada operación con la misma clave.</param>
      <param name="plaintext">Contenido que se va a cifrar.</param>
      <param name="ciphertext">Intervalo de bytes que va a recibir el contenido cifrado.</param>
      <param name="tag">Intervalo de bytes que va a recibir la etiqueta de autenticación generada.</param>
      <param name="associatedData">Datos adicionales asociados a este mensaje, que también se deben proporcionar durante el descifrado.</param>
      <exception cref="T:System.ArgumentException">El parámetro <paramref name="plaintext" /> y <paramref name="ciphertext" /> no tienen la misma longitud.
O bien
<see cref="P:System.Security.Cryptography.AesCcm.NonceByteSizes" /> no permite la longitud del parámetro <paramref name="nonce" />.
o bien
<see cref="P:System.Security.Cryptography.AesCcm.TagByteSizes" /> no permite la longitud del parámetro <paramref name="tag" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Se ha producido un error en la operación de cifrado.</exception>
    </member>
    <member name="P:System.Security.Cryptography.AesCcm.NonceByteSizes">
      <summary>Obtiene los tamaños de nonce, en bytes, que son compatibles con esta instancia.</summary>
      <returns>Los tamaños de nonce admitidos por esta instancia: 7, 8, 9, 10, 11, 12 o 13 bytes (56, 64, 72, 80, 88, 96 o 104 bits).</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesCcm.TagByteSizes">
      <summary>Obtiene los tamaños de etiqueta, en bytes, que son compatibles con esta instancia.</summary>
      <returns>Los tamaños de etiqueta admitidos por esta instancia: 4, 6, 8, 10, 12, 14 o 16 bytes (32, 48, 64, 80, 96, 112 o 128 bits).</returns>
    </member>
    <member name="T:System.Security.Cryptography.AesGcm">
      <summary>Representa una clave de Estándar de cifrado avanzado (AES) que se va a usar con el modo de operación Galois/Counter Mode (GCM).</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.#ctor(System.Byte[])">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.AesGcm" /> con la clave proporcionada.</summary>
      <param name="key">Clave secreta que se va a usar para esta instancia.</param>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="key" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La longitud del parámetro <paramref name="key" /> es distinta de 16, 24 o 32 bytes (128, 192 o 256 bits).</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.#ctor(System.ReadOnlySpan{System.Byte})">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.AesGcm" /> con la clave proporcionada.</summary>
      <param name="key">Clave secreta que se va a usar para esta instancia.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La longitud del parámetro <paramref name="key" /> es distinta de 16, 24 o 32 bytes (128, 192 o 256 bits).</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.Decrypt(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
      <summary>Descifra el texto cifrado en el búfer de destino proporcionado si se puede validar la etiqueta de autenticación.</summary>
      <param name="nonce">Nonce asociado a este mensaje, que debe coincidir con el valor proporcionado durante el cifrado.</param>
      <param name="ciphertext">Contenido cifrado que se va a descifrar.</param>
      <param name="tag">Etiqueta de autenticación generada para este mensaje durante el cifrado.</param>
      <param name="plaintext">Matriz de bytes que va a recibir los contenidos descifrados.</param>
      <param name="associatedData">Datos adicionales asociados con este mensaje, que deben coincidir con el valor proporcionado durante el cifrado.</param>
      <exception cref="T:System.ArgumentException">El parámetro <paramref name="plaintext" /> y <paramref name="ciphertext" /> no tienen la misma longitud.
O bien
<see cref="P:System.Security.Cryptography.AesGcm.NonceByteSizes" /> no permite la longitud del parámetro <paramref name="nonce" />.
O bien
<see cref="P:System.Security.Cryptography.AesGcm.TagByteSizes" /> no permite la longitud del parámetro <paramref name="tag" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="nonce" />, <paramref name="ciphertext" />, <paramref name="tag" /> o el parámetro <paramref name="plaintext" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido comprobar el valor de la etiqueta o se ha producido un error en la operación de descifrado.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.Decrypt(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Descifra el texto cifrado en el búfer de destino proporcionado si se puede validar la etiqueta de autenticación.</summary>
      <param name="nonce">Nonce asociado a este mensaje, que debe coincidir con el valor proporcionado durante el cifrado.</param>
      <param name="ciphertext">Contenido cifrado que se va a descifrar.</param>
      <param name="tag">Etiqueta de autenticación generada para este mensaje durante el cifrado.</param>
      <param name="plaintext">Intervalo de bytes que va a recibir los contenidos descifrados.</param>
      <param name="associatedData">Datos adicionales asociados con este mensaje, que deben coincidir con el valor proporcionado durante el cifrado.</param>
      <exception cref="T:System.ArgumentException">El parámetro <paramref name="plaintext" /> y <paramref name="ciphertext" /> no tienen la misma longitud.
O bien
<see cref="P:System.Security.Cryptography.AesGcm.NonceByteSizes" /> no permite la longitud del parámetro <paramref name="nonce" />.
O bien
<see cref="P:System.Security.Cryptography.AesGcm.TagByteSizes" /> no permite la longitud del parámetro <paramref name="tag" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido comprobar el valor de la etiqueta o se ha producido un error en la operación de descifrado.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.Dispose">
      <summary>Libera los recursos utilizados por la instancia actual de la clase <see cref="T:System.Security.Cryptography.AesGcm" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.Encrypt(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
      <summary>Cifra el texto no cifrado en el búfer de destino de texto cifrado y genera la etiqueta de autenticación en un búfer independiente.</summary>
      <param name="nonce">Nonce asociado a este mensaje, que debe ser un valor único para cada operación con la misma clave.</param>
      <param name="plaintext">Contenido que se va a cifrar.</param>
      <param name="ciphertext">Matriz de bytes que va a recibir los contenidos cifrados.</param>
      <param name="tag">Matriz de bytes que va a recibir la etiqueta de autenticación generada.</param>
      <param name="associatedData">Datos adicionales asociados a este mensaje, que también se deben proporcionar durante el descifrado.</param>
      <exception cref="T:System.ArgumentException">El parámetro <paramref name="plaintext" /> y <paramref name="ciphertext" /> no tienen la misma longitud.
O bien
<see cref="P:System.Security.Cryptography.AesGcm.NonceByteSizes" /> no permite la longitud del parámetro <paramref name="nonce" />.
O bien
<see cref="P:System.Security.Cryptography.AesGcm.TagByteSizes" /> no permite la longitud del parámetro <paramref name="tag" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="nonce" />, <paramref name="ciphertext" />, <paramref name="tag" /> o el parámetro <paramref name="plaintext" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Se ha producido un error en la operación de cifrado.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.Encrypt(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Cifra el texto no cifrado en el búfer de destino de texto cifrado y genera la etiqueta de autenticación en un búfer independiente.</summary>
      <param name="nonce">Nonce asociado a este mensaje, que debe ser un valor único para cada operación con la misma clave.</param>
      <param name="plaintext">Contenido que se va a cifrar.</param>
      <param name="ciphertext">Matriz de bytes que va a recibir los contenidos cifrados.</param>
      <param name="tag">Matriz de bytes que va a recibir la etiqueta de autenticación generada.</param>
      <param name="associatedData">Datos adicionales asociados a este mensaje, que también se deben proporcionar durante el descifrado.</param>
      <exception cref="T:System.ArgumentException">El parámetro <paramref name="plaintext" /> y <paramref name="ciphertext" /> no tienen la misma longitud.
O bien
<see cref="P:System.Security.Cryptography.AesGcm.NonceByteSizes" /> no permite la longitud del parámetro <paramref name="nonce" />.
o bien
<see cref="P:System.Security.Cryptography.AesGcm.TagByteSizes" /> no permite la longitud del parámetro <paramref name="tag" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Se ha producido un error en la operación de cifrado.</exception>
    </member>
    <member name="P:System.Security.Cryptography.AesGcm.NonceByteSizes">
      <summary>Obtiene los tamaños de nonce, en bytes, que son compatibles con esta instancia.</summary>
      <returns>Los tamaños de nonce admitidos por esta instancia: 12 bytes (96 bits).</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesGcm.TagByteSizes">
      <summary>Obtiene los tamaños de etiqueta, en bytes, que son compatibles con esta instancia.</summary>
      <returns>Los tamaños de etiqueta admitidos por esta instancia: 12, 13, 14, 15 o 16 bytes (96, 104, 112, 120 o 128 bits).</returns>
    </member>
    <member name="T:System.Security.Cryptography.AesManaged">
      <summary>Proporciona una implementación administrada del algoritmo simétrico del estándar de cifrado avanzado (AES).</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.AesManaged" />.</summary>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El valor de la directiva de seguridad de Windows para FIPS está habilitado.</exception>
      <exception cref="T:System.InvalidOperationException">Esta implementación no forma parte de los algoritmos criptográficos validados por FIPS de la plataforma Windows.</exception>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.BlockSize">
      <summary>Obtiene o establece el tamaño del bloque de la operación criptográfica en bits.</summary>
      <returns>Tamaño de bloque, en bits, de la operación criptográfica. El valor predeterminado es 128 bits.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.CreateDecryptor">
      <summary>Crea un objeto descifrador simétrico que utiliza la clave y el vector de inicialización (IV) actuales.</summary>
      <returns>Objeto descifrador simétrico.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.CreateDecryptor(System.Byte[],System.Byte[])">
      <summary>Crea un objeto descifrador simétrico que utiliza la clave y el vector de inicialización (IV) especificados.</summary>
      <param name="rgbKey">La clave secreta que se va a utilizar para el algoritmo simétrico.</param>
      <param name="rgbIV">El vector de inicialización que se va a utilizar para el algoritmo simétrico.</param>
      <returns>Objeto descifrador simétrico.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> o <paramref name="iv" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="key" /> no es válido.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.CreateEncryptor">
      <summary>Crea un objeto cifrador simétrico que utiliza la clave y el vector de inicialización (IV) actuales.</summary>
      <returns>Objeto cifrador simétrico.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.CreateEncryptor(System.Byte[],System.Byte[])">
      <summary>Crea un objeto cifrador simétrico que utiliza la clave y el vector de inicialización (IV) especificados.</summary>
      <param name="rgbKey">La clave secreta que se va a utilizar para el algoritmo simétrico.</param>
      <param name="rgbIV">El vector de inicialización que se va a utilizar para el algoritmo simétrico.</param>
      <returns>Objeto cifrador simétrico.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> o <paramref name="iv" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="key" /> no es válido.</exception>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.FeedbackSize">
      <summary>Obtiene o establece el número de bits que se utiliza como comentarios.</summary>
      <returns>Tamaño de comentarios, en bits.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.GenerateIV">
      <summary>Genera un vector de inicialización aleatorio (IV) que se utiliza para el algoritmo simétrico.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.GenerateKey">
      <summary>Genera una clave aleatoria que se utiliza para el algoritmo simétrico.</summary>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.IV">
      <summary>Obtiene o establece el vector de inicialización (IV) para el algoritmo simétrico.</summary>
      <returns>Vector de inicialización que se va a utilizar para el algoritmo simétrico.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.Key">
      <summary>Obtiene o establece la clave secreta utilizada para el algoritmo simétrico.</summary>
      <returns>Clave para el algoritmo simétrico.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.KeySize">
      <summary>Obtiene o establece el tamaño de la clave secreta utilizada para el algoritmo simétrico, en bits.</summary>
      <returns>Tamaño de la clave que utiliza el algoritmo simétrico, en bits.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.LegalBlockSizes">
      <summary>Obtiene los tamaños de bloque, en bits, admitidos por el algoritmo simétrico.</summary>
      <returns>Tamaños de bloque, en bits, admitidos por el algoritmo simétrico.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.LegalKeySizes">
      <summary>Obtiene los tamaños de clave, en bits, admitidos por el algoritmo simétrico.</summary>
      <returns>Los tamaños de clave, en bits, admitidos por el algoritmo simétrico.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.Mode">
      <summary>Obtiene o establece el modo de funcionamiento del algoritmo simétrico.</summary>
      <returns>Uno de los valores de enumeración que especifica el modo de cifrado de bloques que se va a utilizar para el cifrado. De manera predeterminada, es <see cref="F:System.Security.Cryptography.CipherMode.CBC" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <see cref="P:System.Security.Cryptography.AesManaged.Mode" /> se establece en <see cref="F:System.Security.Cryptography.CipherMode.CFB" /> o en <see cref="F:System.Security.Cryptography.CipherMode.OFB" />.</exception>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.Padding">
      <summary>Obtiene o establece el modo de relleno utilizado en el algoritmo simétrico.</summary>
      <returns>Uno de los valores de enumeración que especifica el tipo de relleno que se va a aplicar. De manera predeterminada, es <see cref="F:System.Security.Cryptography.PaddingMode.PKCS7" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter">
      <summary>Representa la clase base desde la que se derivan todos los desformateadores de intercambio de claves asimétricas.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter.DecryptKeyExchange(System.Byte[])">
      <summary>Si se reemplaza en una clase derivada, extrae información secreta de los datos cifrados de intercambio de claves.</summary>
      <param name="rgb">Datos de intercambio de claves en los que la información secreta está oculta.</param>
      <returns>Información secreta derivada de los datos de intercambio de claves.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter.Parameters">
      <summary>Si se reemplaza en una clase derivada, obtiene o establece los parámetros del intercambio de claves asimétricas.</summary>
      <returns>Cadena de formato XML que contiene los parámetros de la operación de intercambio de claves asimétricas.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Cuando se invalida en una clase derivada, establece la clave privada que se usa para descifrar la información secreta.</summary>
      <param name="key">Instancia de la implementación de <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> que contiene la clave privada.</param>
    </member>
    <member name="T:System.Security.Cryptography.AsymmetricKeyExchangeFormatter">
      <summary>Representa la clase base desde la que se derivan todos los formateadores de intercambio de claves asimétricas.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeFormatter.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.AsymmetricKeyExchangeFormatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeFormatter.CreateKeyExchange(System.Byte[])">
      <summary>Si se reemplaza en una clase derivada, crea los datos de intercambio de claves cifradas a partir de los datos de entrada especificados.</summary>
      <param name="data">Información secreta que se pasará en el intercambio de claves.</param>
      <returns>Datos de intercambio de claves cifradas que se enviarán al destinatario previsto.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeFormatter.CreateKeyExchange(System.Byte[],System.Type)">
      <summary>Si se reemplaza en una clase derivada, crea los datos de intercambio de claves cifradas a partir de los datos de entrada especificados.</summary>
      <param name="data">Información secreta que se pasará en el intercambio de claves.</param>
      <param name="symAlgType">Este parámetro no se usa en la versión actual.</param>
      <returns>Datos de intercambio de claves cifradas que se enviarán al destinatario previsto.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AsymmetricKeyExchangeFormatter.Parameters">
      <summary>Cuando se invalida en una clase derivada, obtiene los parámetros del intercambio de claves asimétricas.</summary>
      <returns>Cadena de formato XML que contiene los parámetros de la operación de intercambio de claves asimétricas.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Cuando se invalida en una clase derivada, establece la clave pública que se usa para cifrar la información secreta.</summary>
      <param name="key">Instancia de la implementación de <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> que contiene la clave pública.</param>
    </member>
    <member name="T:System.Security.Cryptography.AsymmetricSignatureDeformatter">
      <summary>Representa la clase base abstracta de la que se derivan todas las implementaciones de desformateadores de firmas asimétricas.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureDeformatter.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.AsymmetricSignatureDeformatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureDeformatter.SetHashAlgorithm(System.String)">
      <summary>Cuando se invalida en una clase derivada, se establece el algoritmo hash que se usa para comprobar la firma.</summary>
      <param name="strName">Nombre del algoritmo hash que se utiliza para comprobar la firma.</param>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Cuando se invalida en una clase derivada, se establece la clave pública que se usa para comprobar la firma.</summary>
      <param name="key">Instancia de una implementación de <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> que contiene la clave pública.</param>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureDeformatter.VerifySignature(System.Byte[],System.Byte[])">
      <summary>Cuando se invalida en una clase derivada, comprueba la firma de los datos especificados.</summary>
      <param name="rgbHash">Datos firmados con <paramref name="rgbSignature" />.</param>
      <param name="rgbSignature">Firma que se va a comprobar para <paramref name="rgbHash" />.</param>
      <returns>
        <see langword="true" />, si <paramref name="rgbSignature" /> coincide con la firma calculada utilizando el algoritmo hash y la clave especificados en <paramref name="rgbHash" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureDeformatter.VerifySignature(System.Security.Cryptography.HashAlgorithm,System.Byte[])">
      <summary>Comprueba la firma del valor hash especificado.</summary>
      <param name="hash">Algoritmo hash que se utiliza para comprobar la firma.</param>
      <param name="rgbSignature">Firma que se va a comprobar.</param>
      <returns>
        <see langword="true" />, si la firma es válida para el valor hash; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="hash" /> es <see langword="null" />.</exception>
    </member>
    <member name="T:System.Security.Cryptography.AsymmetricSignatureFormatter">
      <summary>Representa la clase base desde la que se derivan todas las implementaciones de formateadores de signaturas asimétricas.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureFormatter.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.AsymmetricSignatureFormatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureFormatter.CreateSignature(System.Byte[])">
      <summary>Si se reemplaza en una clase derivada, crea la signatura para los datos especificados.</summary>
      <param name="rgbHash">Datos que van a firmar.</param>
      <returns>Firma digital del parámetro <paramref name="rgbHash" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureFormatter.CreateSignature(System.Security.Cryptography.HashAlgorithm)">
      <summary>Crea la signatura a partir del valor hash especificado.</summary>
      <param name="hash">Algoritmo hash que se va a usar para crear la signatura.</param>
      <returns>Signatura del valor hash especificado.</returns>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="hash" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureFormatter.SetHashAlgorithm(System.String)">
      <summary>Cuando se invalida en una clase derivada, se establece el algoritmo hash que se usa para crear la firma.</summary>
      <param name="strName">Nombre del algoritmo hash que se utiliza para crear la firma.</param>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Cuando se invalida en una clase derivada, se establece el algoritmo asimétrico que se usa para crear la firma.</summary>
      <param name="key">Instancia de la implementación de <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> que se utiliza para crear la firma.</param>
    </member>
    <member name="T:System.Security.Cryptography.CryptoConfig">
      <summary>Obtiene acceso a la información de configuración de criptografía.</summary>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.CryptoConfig" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.AddAlgorithm(System.Type,System.String[])">
      <summary>Agrega un conjunto de nombres a las asignaciones de algoritmo que se van a utilizar para el dominio de aplicación actual.</summary>
      <param name="algorithm">Algoritmo al que se va a realizar la asignación.</param>
      <param name="names">Matriz de los nombres que se van a asignar al algoritmo.</param>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="algorithm" /> o <paramref name="names" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">No se puede tener acceso a <paramref name="algorithm" /> desde fuera del ensamblado.  
o bien 
Una de las entradas del parámetro <paramref name="names" /> está vacía o es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.AddOID(System.String,System.String[])">
      <summary>Agrega un conjunto de nombres a las asignaciones de identificador de objetos (OID) que se van a utilizar para el dominio de aplicación actual.</summary>
      <param name="oid">Identificador de objetos (OID) al que se va a realizar la asignación.</param>
      <param name="names">Matriz de los nombres que se van a asignar al OID.</param>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="oid" /> o <paramref name="names" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Una de las entradas del parámetro <paramref name="names" /> está vacía o es <see langword="null" />.</exception>
    </member>
    <member name="P:System.Security.Cryptography.CryptoConfig.AllowOnlyFipsAlgorithms">
      <summary>Indica si el runtime debe aplicar la directiva para crear solo algoritmos certificados conformes con el Estándar federal de procesamiento de información (FIPS).</summary>
      <returns>Es <see langword="true" /> para aplicar la directiva; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.CreateFromName(System.String)">
      <summary>Crea una nueva instancia del objeto criptográfico especificado.</summary>
      <param name="name">Nombre simple del objeto criptográfico del que se va a crear una instancia.</param>
      <returns>Nueva instancia del objeto criptográfico especificado.</returns>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Se utilizó el algoritmo descrito por el parámetro <paramref name="name" /> con el modo FIPS (Estándar federal de procesamiento de información) habilitado, pero no es compatible con FIPS.</exception>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.CreateFromName(System.String,System.Object[])">
      <summary>Crea una nueva instancia del objeto criptográfico especificado con los argumentos especificados.</summary>
      <param name="name">Nombre simple del objeto criptográfico del que se va a crear una instancia.</param>
      <param name="args">Argumentos utilizados para crear el objeto criptográfico especificado.</param>
      <returns>Nueva instancia del objeto criptográfico especificado.</returns>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Se utilizó el algoritmo descrito por el parámetro <paramref name="name" /> con el modo FIPS (Estándar federal de procesamiento de información) habilitado, pero no es compatible con FIPS.</exception>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.EncodeOID(System.String)">
      <summary>Codifica el identificador de objeto (OID) especificado.</summary>
      <param name="str">Identificador de objeto (OID) que se va a codificar.</param>
      <returns>Matriz de bytes que contiene el identificador de objeto (OID) codificado.</returns>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="str" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">Se ha producido un error durante la codificación del identificador de objeto (OID).</exception>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.MapNameToOID(System.String)">
      <summary>Obtiene el identificador de objeto (OID) del algoritmo que se corresponde con el nombre simple especificado.</summary>
      <param name="name">Nombre simple del algoritmo para el que se va a obtener el identificador de objeto (OID).</param>
      <returns>Identificador de objeto (OID) del algoritmo especificado.</returns>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="T:System.Security.Cryptography.DeriveBytes">
      <summary>Representa la clase base abstracta de la que se heredan todas las clases que derivan secuencias de bytes de una longitud especificada.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DeriveBytes.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.DeriveBytes" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DeriveBytes.Dispose">
      <summary>Cuando se reemplaza en una clase derivada, libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Security.Cryptography.DeriveBytes" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DeriveBytes.Dispose(System.Boolean)">
      <summary>Cuando se reemplaza en una clase derivada, libera los recursos no administrados utilizados por la clase <see cref="T:System.Security.Cryptography.DeriveBytes" /> y, de forma opcional, libera los recursos administrados.</summary>
      <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
    </member>
    <member name="M:System.Security.Cryptography.DeriveBytes.GetBytes(System.Int32)">
      <summary>Cuando se invalida en una clase derivada, devuelve bytes de clave pseudoaleatorios.</summary>
      <param name="cb">Número de bytes de clave pseudoaleatorios que se van a generar.</param>
      <returns>Matriz de bytes rellena de bytes de clave pseudoaleatorios.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DeriveBytes.Reset">
      <summary>Cuando se invalida en una clase derivada, restablece el estado de la operación.</summary>
    </member>
    <member name="T:System.Security.Cryptography.DES">
      <summary>Representa la clase base del algoritmo Estándar de cifrado de datos (DES) de la que se deben derivar todas las implementaciones de <see cref="T:System.Security.Cryptography.DES" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DES.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.DES" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DES.Create">
      <summary>Crea una instancia de un objeto criptográfico para ejecutar el algoritmo de cifrado Estándar de cifrado de datos (<see cref="T:System.Security.Cryptography.DES" />).</summary>
      <returns>Objeto criptográfico.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DES.Create(System.String)">
      <summary>Crea una instancia de un objeto criptográfico para ejecutar la implementación especificada del algoritmo Estándar de cifrado de datos (<see cref="T:System.Security.Cryptography.DES" />).</summary>
      <param name="algName">Nombre de la implementación específica de <see cref="T:System.Security.Cryptography.DES" /> que se va a utilizar.</param>
      <returns>Objeto criptográfico.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DES.IsSemiWeakKey(System.Byte[])">
      <summary>Determina si la clave especificada es parcialmente débil.</summary>
      <param name="rgbKey">Clave secreta que se va a comprobar para determinar si es parcialmente débil.</param>
      <returns>
        <see langword="true" /> si la clave es parcialmente débil; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El tamaño del parámetro <paramref name="rgbKey" /> no es válido.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DES.IsWeakKey(System.Byte[])">
      <summary>Determina si la clave especificada es débil.</summary>
      <param name="rgbKey">Clave secreta que se va a comprobar para determinar la debilidad de la misma.</param>
      <returns>
        <see langword="true" /> si la clave es débil; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El tamaño del parámetro <paramref name="rgbKey" /> no es válido.</exception>
    </member>
    <member name="P:System.Security.Cryptography.DES.Key">
      <summary>Obtiene o establece la clave secreta para el algoritmo Estándar de cifrado de datos (<see cref="T:System.Security.Cryptography.DES" />).</summary>
      <returns>Clave secreta del algoritmo <see cref="T:System.Security.Cryptography.DES" />.</returns>
      <exception cref="T:System.ArgumentNullException">Se ha intentado establecer la clave en <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Se ha intentado establecer una clave cuya longitud no es igual a <see cref="F:System.Security.Cryptography.SymmetricAlgorithm.BlockSizeValue" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Se ha intentado establecer un clave débil (vea <see cref="M:System.Security.Cryptography.DES.IsWeakKey(System.Byte[])" />) o una clave parcialmente débil (vea <see cref="M:System.Security.Cryptography.DES.IsSemiWeakKey(System.Byte[])" />).</exception>
    </member>
    <member name="T:System.Security.Cryptography.DSA">
      <summary>Representa la clase base abstracta desde la que deben heredarse todas las implementaciones del algoritmo de firma digital (<see cref="T:System.Security.Cryptography.DSA" />).</summary>
    </member>
    <member name="M:System.Security.Cryptography.DSA.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DSA.Create">
      <summary>Crea un objeto criptográfico predeterminado para realizar el algoritmo asimétrico.</summary>
      <returns>Crea un objeto criptográfico para realizar el algoritmo asimétrico.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.Create(System.Int32)">
      <summary>Crea una clave DSA efímera con el tamaño de clave especificado.</summary>
      <param name="keySizeInBits">Tamaño de la clave (en bits).</param>
      <returns>Clave DSA efímera con el tamaño de clave especificado.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="keySizeInBits" /> no tiene el permiso de <see cref="P:System.Security.Cryptography.AsymmetricAlgorithm.LegalKeySizes" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.Create(System.Security.Cryptography.DSAParameters)">
      <summary>Crea una clave DSA efímera con los parámetros de clave DSA especificados.</summary>
      <param name="parameters">Parámetros del algoritmo <see cref="T:System.Security.Cryptography.DSA" />.</param>
      <returns>Nueva clave DSA efímera.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.Create(System.String)">
      <summary>Crea un objeto criptográfico predeterminado para realizar el algoritmo asimétrico.</summary>
      <param name="algName">Nombre de la implementación específica de <see cref="T:System.Security.Cryptography.DSA" /> que se va a utilizar.</param>
      <returns>Crea un objeto criptográfico para realizar el algoritmo asimétrico.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.CreateSignature(System.Byte[])">
      <summary>Cuando se reemplaza en una clase derivada, crea la firma <see cref="T:System.Security.Cryptography.DSA" /> para los datos especificados.</summary>
      <param name="rgbHash">Datos que van a firmar.</param>
      <returns>La firma digital de los datos especificados.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ExportParameters(System.Boolean)">
      <summary>Cuando se invalida en una clase derivada, exporta el <see cref="T:System.Security.Cryptography.DSAParameters" />.</summary>
      <param name="includePrivateParameters">Es <see langword="true" /> si se van a incluir parámetros privados; en caso contrario, es <see langword="false" />.</param>
      <returns>Parámetros de <see cref="T:System.Security.Cryptography.DSA" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.FromXmlString(System.String)">
      <summary>Reconstruye un objeto <see cref="T:System.Security.Cryptography.DSA" /> a partir de una cadena XML.</summary>
      <param name="xmlString">Cadena XML que se usa para reconstruir el objeto <see cref="T:System.Security.Cryptography.DSA" />.</param>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="xmlString" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El formato del parámetro <paramref name="xmlString" /> no es válido.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.HashData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Cuando se reemplaza en una clase derivada, calcula el valor hash de una parte especificada de una matriz de bytes usando un algoritmo hash especificado.</summary>
      <param name="data">Datos a los que se va a aplicar un algoritmo hash.</param>
      <param name="offset">Índice del primer byte de <paramref name="data" /> al que se va a aplicar un algoritmo hash.</param>
      <param name="count">Número de bytes a los que se va a aplicar un algoritmo hash.</param>
      <param name="hashAlgorithm">Algoritmo hash que se va a aplicar a los datos.</param>
      <returns>Datos a los que se aplicó un algoritmo hash.</returns>
      <exception cref="T:System.NotImplementedException">Una clase derivada debe reemplazar este método.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.HashData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Cuando se reemplaza en una clase derivada, calcula el valor hash de una secuencia binaria especificada usando un algoritmo hash especificado.</summary>
      <param name="data">Secuencia binaria a la que se va a aplicar un algoritmo hash.</param>
      <param name="hashAlgorithm">Algoritmo hash que se va a aplicar a los datos.</param>
      <returns>Datos a los que se aplicó un algoritmo hash.</returns>
      <exception cref="T:System.NotImplementedException">Una clase derivada debe reemplazar este método.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importa el par de claves pública/privada desde una estructura EncryptedPrivateKeyInfo de PKCS#8 después de descifrar con una contraseña basada en bytes, reemplazando las claves de este objeto.</summary>
      <param name="passwordBytes">Bytes que se van a usar como contraseña al descifrar el material de clave.</param>
      <param name="source">Bytes de una estructura EncryptedPrivateKeyInfo de PKCS#8 en la codificación ASN.1-BER.</param>
      <param name="bytesRead">El resultado que devuelve este método contiene un valor que indica el número de bytes leídos de <paramref name="source" />. Este parámetro se trata como sin inicializar.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La contraseña es incorrecta.
O bien
El contenido de <paramref name="source" /> indica que la función de derivación de claves (KDF) que se va a aplicar es la heredada de PKCS#12, que requiere contraseñas basadas en <see cref="T:System.Char" />.
O bien
El contenido de <paramref name="source" /> no representa una estructura EncryptedPrivateKeyInfo de PKCS#8 codificada con ASN.1-BER.
o bien
El contenido de <paramref name="source" /> indica que la clave es para un algoritmo distinto del algoritmo que representa esta instancia.
O bien
El contenido de <paramref name="source" /> representa la clave en un formato que no se admite.
O bien
No se ha podido importar la clave específica del algoritmo.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importa el par de claves pública/privada desde una estructura EncryptedPrivateKeyInfo de PKCS#8 después de descifrar con una contraseña basada en caracteres, reemplazando las claves de este objeto.</summary>
      <param name="password">Contraseña que se va a usar para descifrar el material de clave.</param>
      <param name="source">Bytes de una estructura EncryptedPrivateKeyInfo de PKCS#8 en la codificación ASN.1-BER.</param>
      <param name="bytesRead">El resultado que devuelve este método contiene un valor que indica el número de bytes leídos de <paramref name="source" />. Este parámetro se trata como sin inicializar.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La contraseña es incorrecta.
O bien
El contenido de <paramref name="source" /> no representa una estructura EncryptedPrivateKeyInfo de PKCS#8 codificada con ASN.1-BER.
O bien
El contenido de <paramref name="source" /> indica que la clave es para un algoritmo distinto del algoritmo que representa esta instancia.
o bien
El contenido de <paramref name="source" /> representa la clave en un formato que no se admite.
o bien
No se ha podido importar la clave específica del algoritmo.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ImportParameters(System.Security.Cryptography.DSAParameters)">
      <summary>Cuando se invalida en una clase derivada, importa el objeto <see cref="T:System.Security.Cryptography.DSAParameters" /> especificado.</summary>
      <param name="parameters">Parámetros de <see cref="T:System.Security.Cryptography.DSA" />.</param>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ImportPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importa el par de claves pública/privada desde una estructura PrivateKeyInfo de PKCS#8 después del descifrado, reemplazando las claves de este objeto.</summary>
      <param name="source">Bytes de una estructura PrivateKeyInfo de PKCS#8 en la codificación ASN.1-BER.</param>
      <param name="bytesRead">El resultado que devuelve este método contiene un valor que indica el número de bytes leídos de <paramref name="source" />. Este parámetro se trata como sin inicializar.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El contenido de <paramref name="source" /> no representa una estructura PrivateKeyInfo de PKCS#8 codificada con ASN.1-BER.
O bien
El contenido de <paramref name="source" /> indica que la clave es para un algoritmo distinto del algoritmo que representa esta instancia.
o bien
El contenido de <paramref name="source" /> representa la clave en un formato que no se admite.
O bien
No se ha podido importar la clave específica del algoritmo.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ImportSubjectPublicKeyInfo(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importa la clave pública desde una estructura SubjectPublicKeyInfo de X.509 después del descifrado, reemplazando las claves de este objeto.</summary>
      <param name="source">Bytes de una estructura SubjectPublicKeyInfo de X.509 en la codificación ASN.1-DER.</param>
      <param name="bytesRead">El resultado que devuelve este método contiene un valor que indica el número de bytes leídos de <paramref name="source" />. Este parámetro se trata como sin inicializar.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El contenido de <paramref name="source" /> no representa una estructura SubjectPublicKeyInfo de X.509 codificada con ASN.1-DER.
O bien
El contenido de <paramref name="source" /> indica que la clave es para un algoritmo distinto del algoritmo que representa esta instancia.
O bien
El contenido de <paramref name="source" /> representa la clave en un formato que no se admite.
o bien
No se ha podido importar la clave específica del algoritmo.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.SignData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Calcula el valor hash de una parte de la matriz de bytes especificada usando el algoritmo hash especificado y firma el valor hash resultante.</summary>
      <param name="data">Datos de entrada para los que se va a calcular el hash.</param>
      <param name="offset">Desplazamiento en la matriz en el que se empezarán a usar los datos.</param>
      <param name="count">Número de bytes de la matriz que se van a usar como datos.</param>
      <param name="hashAlgorithm">Algoritmo hash que se va a usar para crear el valor hash.</param>
      <returns>Firma DSA de los datos especificados.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> es menor que cero.  
o bien 
 <paramref name="count" /> es menor que cero.  
O bien 
 <paramref name="offset" /> + <paramref name="count" /> - 1 produce un índice que supera el límite superior de <paramref name="data" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.SignData(System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Calcula el valor hash de la matriz de bytes especificada usando el algoritmo hash especificado y firma el valor hash resultante.</summary>
      <param name="data">Datos de entrada para los que se va a calcular el hash.</param>
      <param name="hashAlgorithm">Algoritmo hash que se va a usar para crear el valor hash.</param>
      <returns>Firma DSA de los datos especificados.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.SignData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Calcula el valor hash de la secuencia especificada usando el algoritmo hash especificado y firma el valor hash resultante.</summary>
      <param name="data">Secuencia de entrada para la que se va a calcular el hash.</param>
      <param name="hashAlgorithm">Algoritmo hash que se va a usar para crear el valor hash.</param>
      <returns>Firma DSA de los datos especificados.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ToXmlString(System.Boolean)">
      <summary>Crea y devuelve una representación en forma de cadena XML del objeto <see cref="T:System.Security.Cryptography.DSA" /> actual.</summary>
      <param name="includePrivateParameters">Es <see langword="true" /> si se van a incluir parámetros privados; en caso contrario, es <see langword="false" />.</param>
      <returns>Codificación en forma de cadena XML del objeto <see cref="T:System.Security.Cryptography.DSA" /> actual.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryCreateSignature(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@)">
      <summary>Intenta crear la firma DSA para el hash especificado en el búfer proporcionado.</summary>
      <param name="hash">Valor hash que se va a firmar.</param>
      <param name="destination">Intervalo de bytes para recibir la firma.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene un valor que indica el número de bytes escritos en <paramref name="destination" />.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> es lo suficientemente grande como para recibir el resultado; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Esta instancia representa solo una clave pública.
O bien
El tipo de implementación solo admite DSA heredado (FIPS 186-2), y <paramref name="hash" /> no es un valor de 20 bytes.
O bien
Se produce un error al crear la firma de cualquier otra forma.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Intenta exportar la clave actual en el formato EncryptedPrivateKeyInfo de PKCS#8 a un búfer proporcionado, utilizando una contraseña basada en bytes.</summary>
      <param name="passwordBytes">Bytes que se van a usar como contraseña al cifrar el material de clave.</param>
      <param name="pbeParameters">Parámetros de cifrado basados en contraseña (PBE) que se van a usar al cifrar el material de clave.</param>
      <param name="destination">Intervalo de bytes que va a recibir los datos de EncryptedPrivateKeyInfo de PKCS#8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene un valor que indica el número de bytes escritos en <paramref name="destination" />. Este parámetro se trata como sin inicializar.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> es lo suficientemente grande como para recibir la salida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido exportar la clave.
O bien
<paramref name="pbeParameters" /> indica que debe usarse <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" />, el cual requiere contraseñas basadas en <see cref="T:System.Char" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Intenta exportar la clave actual en el formato EncryptedPrivateKeyInfo de PKCS#8 a un búfer proporcionado, utilizando una contraseña basada en caracteres.</summary>
      <param name="password">Contraseña que se va a usar al cifrar el material de clave.</param>
      <param name="pbeParameters">Parámetros de cifrado basados en contraseña (PBE) que se van a usar al cifrar el material de clave.</param>
      <param name="destination">Intervalo de bytes que va a recibir los datos de EncryptedPrivateKeyInfo de PKCS#8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene un valor que indica el número de bytes escritos en <paramref name="destination" />. Este parámetro se trata como sin inicializar.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> es lo suficientemente grande como para recibir la salida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido exportar la clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryExportPkcs8PrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Intenta exportar la clave actual en el formato PrivateKeyInfo de PKCS#8 a un búfer proporcionado.</summary>
      <param name="destination">Intervalo de bytes que va a recibir los datos de PrivateKeyInfo de PKCS#8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene un valor que indica el número de bytes escritos en <paramref name="destination" />. Este parámetro se trata como sin inicializar.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> es lo suficientemente grande como para recibir la salida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido exportar la clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryExportSubjectPublicKeyInfo(System.Span{System.Byte},System.Int32@)">
      <summary>Intenta exportar la clave actual en el formato SubjectPublicKeyInfo de X.509 a un búfer proporcionado.</summary>
      <param name="destination">Intervalo de bytes que va a recibir los datos de SubjectPublicKeyInfo de X.509.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene un valor que indica el número de bytes escritos en <paramref name="destination" />. Este parámetro se trata como sin inicializar.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> es lo suficientemente grande como para recibir la salida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido exportar la clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryHashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Int32@)">
      <summary>Intenta calcular el valor hash de los datos proporcionados en un búfer proporcionado.</summary>
      <param name="data">Datos a los que se va a aplicar un algoritmo hash.</param>
      <param name="destination">Intervalo de bytes para recibir el valor hash.</param>
      <param name="hashAlgorithm">Nombre del algoritmo de hash que se va a usar.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene un valor que indica el número de bytes escritos en <paramref name="destination" />.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> es lo suficientemente grande como para recibir el resultado; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TrySignData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Int32@)">
      <summary>Intenta crear la firma DSA para los datos especificados en el búfer proporcionado.</summary>
      <param name="data">Datos para aplicar un algoritmo hash y firmar.</param>
      <param name="destination">Intervalo de bytes para recibir la firma.</param>
      <param name="hashAlgorithm">Nombre del algoritmo de hash que se va a usar.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene un valor que indica el número de bytes escritos en <paramref name="destination" />.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> es lo suficientemente grande como para recibir el resultado; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyData(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Comprueba si una firma digital es válida calculando el valor hash de los datos especificados, para lo que usa el algoritmo hash especificado y lo compara con la firma proporcionada.</summary>
      <param name="data">Datos firmados.</param>
      <param name="signature">Datos de la firma que se van a comprobar.</param>
      <param name="hashAlgorithm">Algoritmo hash usado para crear el valor hash de los datos.</param>
      <returns>Es <see langword="true" /> si la firma digital es válida; en caso contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="data" /> es <see langword="null" />.  
O bien 
 <paramref name="signature" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El tipo de implementación solo admite DSA heredado (FIPS 186-2), y el algoritmo hash no es SHA-1.
o bien
Se produce un error al verificar la firma de cualquier otra forma.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyData(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Comprueba si una firma digital es válida calculando el valor hash de los datos de una parte de una matriz de bytes, para lo que usa el algoritmo hash especificado y lo compara con la firma proporcionada.</summary>
      <param name="data">Datos firmados.</param>
      <param name="offset">Índice inicial en el que se va a calcular el hash.</param>
      <param name="count">Número de bytes a los que se va a aplicar un algoritmo hash.</param>
      <param name="signature">Datos de la firma que se van a comprobar.</param>
      <param name="hashAlgorithm">Algoritmo hash usado para crear el valor hash de los datos.</param>
      <returns>Es <see langword="true" /> si la firma digital es válida; en caso contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="data" /> es <see langword="null" />.  
O bien 
 <paramref name="signature" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> es menor que cero.  
O bien 
 <paramref name="count" /> es menor que cero.  
o bien 
 <paramref name="offset" /> + <paramref name="count" /> - 1 produce un índice que supera el límite superior de <paramref name="data" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El tipo de implementación solo admite DSA heredado (FIPS 186-2), y el algoritmo hash no es SHA-1.
o bien
Se produce un error al verificar la firma de cualquier otra forma.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyData(System.IO.Stream,System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Comprueba si una firma digital es válida calculando el valor hash de la secuencia especificada, para lo que usa el algoritmo hash especificado y lo compara con la firma proporcionada.</summary>
      <param name="data">Datos firmados.</param>
      <param name="signature">Datos de la firma que se van a comprobar.</param>
      <param name="hashAlgorithm">Algoritmo hash usado para crear el valor hash de los datos.</param>
      <returns>Es <see langword="true" /> si la firma digital es válida; en caso contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="data" /> es <see langword="null" />.  
o bien 
 <paramref name="signature" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El tipo de implementación solo admite DSA heredado (FIPS 186-2), y el algoritmo hash no es SHA-1.
O bien
Se produce un error al verificar la firma de cualquier otra forma.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyData(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName)">
      <summary>Comprueba si una firma digital es válida calculando el valor hash de los datos en un intervalo de bytes, para lo que usa el algoritmo hash especificado y lo compara con la firma proporcionada.</summary>
      <param name="data">Datos firmados.</param>
      <param name="signature">Firma que se va a comprobar.</param>
      <param name="hashAlgorithm">Algoritmo hash usado para crear el valor hash de los datos.</param>
      <returns>Es <see langword="true" /> si la firma digital es válida; en caso contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El tipo de implementación solo admite DSA heredado (FIPS 186-2), y el algoritmo hash no es SHA-1.
o bien
Se produce un error al verificar la firma de cualquier otra forma.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifySignature(System.Byte[],System.Byte[])">
      <summary>Cuando se reemplaza en una clase derivada, comprueba la firma <see cref="T:System.Security.Cryptography.DSA" /> de los datos especificados.</summary>
      <param name="rgbHash">Hash de los datos firmados con <paramref name="rgbSignature" />.</param>
      <param name="rgbSignature">Firma que se va a comprobar para <c>rgbData</c>.</param>
      <returns>
        <see langword="true" />, si <paramref name="rgbSignature" /> coincide con la firma calculada utilizando el algoritmo hash y la clave especificados en <paramref name="rgbHash" />; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El tipo de implementación solo admite DSA heredado (FIPS 186-2), y el valor hash no tiene una longitud de 20 bytes.
o bien
Se produce un error al verificar la firma de cualquier otra forma.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifySignature(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Comprueba que una firma digital sea válida para un hash de datos proporcionado.</summary>
      <param name="hash">Hash de datos que se va a comprobar.</param>
      <param name="signature">Firma que se va a comprobar.</param>
      <returns>
        <see langword="true" /> si la firma digital es válida para el valor hash; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El tipo de implementación solo admite DSA heredado (FIPS 186-2), y el valor hash no tiene una longitud de 20 bytes.
O bien
Se produce un error al verificar la firma de cualquier otra forma.</exception>
    </member>
    <member name="T:System.Security.Cryptography.DSAParameters">
      <summary>Contiene los parámetros típicos para el algoritmo <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.Counter">
      <summary>Especifica el contador para el algoritmo <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.G">
      <summary>Especifica el parámetro <see langword="G" /> para el algoritmo <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.J">
      <summary>Especifica el parámetro <see langword="J" /> para el algoritmo <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.P">
      <summary>Especifica el parámetro <see langword="P" /> para el algoritmo <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.Q">
      <summary>Especifica el parámetro <see langword="Q" /> para el algoritmo <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.Seed">
      <summary>Especifica el valor inicial para el algoritmo <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.X">
      <summary>Especifica el parámetro <see langword="X" /> para el algoritmo <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.Y">
      <summary>Especifica el parámetro <see langword="Y" /> para el algoritmo <see cref="T:System.Security.Cryptography.DSA" />.</summary>
    </member>
    <member name="T:System.Security.Cryptography.DSASignatureDeformatter">
      <summary>Comprueba una firma PKCS#1 v1.5 del algoritmo de firma digital (<see cref="T:System.Security.Cryptography.DSA" />).</summary>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureDeformatter.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.DSASignatureDeformatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureDeformatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.DSASignatureDeformatter" /> con la clave especificada.</summary>
      <param name="key">La instancia del algoritmo de firma digital (<see cref="T:System.Security.Cryptography.DSA" />) que contiene la clave.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureDeformatter.SetHashAlgorithm(System.String)">
      <summary>Especifica el algoritmo hash para el desformateador de firmas del algoritmo de firma digital (<see cref="T:System.Security.Cryptography.DSA" />).</summary>
      <param name="strName">Nombre del algoritmo hash que se utiliza para el desformateador de firmas.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">El parámetro <paramref name="strName" /> no se asigna al algoritmo hash <see cref="T:System.Security.Cryptography.SHA1" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Especifica la clave que se va a utilizar para el desformateador de firmas del algoritmo de firma digital (<see cref="T:System.Security.Cryptography.DSA" />).</summary>
      <param name="key">Instancia de <see cref="T:System.Security.Cryptography.DSA" /> que contiene la clave.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureDeformatter.VerifySignature(System.Byte[],System.Byte[])">
      <summary>Comprueba la firma del algoritmo de firma digital (<see cref="T:System.Security.Cryptography.DSA" />) de los datos.</summary>
      <param name="rgbHash">Datos firmados con <paramref name="rgbSignature" />.</param>
      <param name="rgbSignature">Firma que se va a comprobar para <paramref name="rgbHash" />.</param>
      <returns>
        <see langword="true" /> si la firma es válida para los datos; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="rgbHash" /> es <see langword="null" />.  
O bien 
 <paramref name="rgbSignature" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">Falta la clave DSA.</exception>
    </member>
    <member name="T:System.Security.Cryptography.DSASignatureFormatter">
      <summary>Crea una firma del Algoritmo de firma digital (<see cref="T:System.Security.Cryptography.DSA" />).</summary>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureFormatter.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.DSASignatureFormatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureFormatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.DSASignatureFormatter" /> con la clave especificada.</summary>
      <param name="key">La instancia del algoritmo de firma digital (<see cref="T:System.Security.Cryptography.DSA" />) que contiene la clave.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureFormatter.CreateSignature(System.Byte[])">
      <summary>Crea la firma PKCS #1 del algoritmo de firma digital (<see cref="T:System.Security.Cryptography.DSA" />) para los datos especificados.</summary>
      <param name="rgbHash">Datos que van a firmar.</param>
      <returns>La firma digital de los datos especificados.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="rgbHash" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">OID es <see langword="null" />.  
O bien 
La clave DSA es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureFormatter.SetHashAlgorithm(System.String)">
      <summary>Especifica el algoritmo hash para el formateador de firmas del algoritmo de firma digital (<see cref="T:System.Security.Cryptography.DSA" />).</summary>
      <param name="strName">Nombre del algoritmo hash que se utiliza para el formateador de firmas.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">El parámetro <paramref name="strName" /> no se asigna al algoritmo hash <see cref="T:System.Security.Cryptography.SHA1" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Especifica la clave que se va a utilizar para el formateador de firmas del algoritmo de firma digital (<see cref="T:System.Security.Cryptography.DSA" />).</summary>
      <param name="key">Instancia de <see cref="T:System.Security.Cryptography.DSA" /> que contiene la clave.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> es <see langword="null" />.</exception>
    </member>
    <member name="T:System.Security.Cryptography.ECCurve">
      <summary>Representa una curva elíptica.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.A">
      <summary>El primer coeficiente de una curva explícita. <c>A</c> para curvas Weierstrass, Montgomery y Twisted Edwards cortas.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.B">
      <summary>El segundo coeficiente de una curva explícita. <c>B</c> para curvas Weierstrass cortas y <c>d</c> para curvas Twisted Edwards.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.Cofactor">
      <summary>El cofactor de la curva.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECCurve.CreateFromFriendlyName(System.String)">
      <summary>Crea una curva con nombre mediante el nombre descriptivo especificado del identificador.</summary>
      <param name="oidFriendlyName">Nombre descriptivo del identificador.</param>
      <returns>Un objeto que representa la curva con nombre.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="oidFriendlyName" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECCurve.CreateFromOid(System.Security.Cryptography.Oid)">
      <summary>Crea una curva con nombre mediante el objeto <see cref="T:System.Security.Cryptography.Oid" /> especificado.</summary>
      <param name="curveOid">El identificador de objetos que se usará.</param>
      <returns>Un objeto que representa la curva con nombre.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECCurve.CreateFromValue(System.String)">
      <summary>Crea una curva con nombre mediante la representación decimal con punto especificada del identificador.</summary>
      <param name="oidValue">El número con punto del identificador.</param>
      <returns>Un objeto que representa la curva con nombre.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="oidValue" /> es <see langword="null" />.</exception>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.CurveType">
      <summary>Identifica la composición del objeto <see cref="T:System.Security.Cryptography.ECCurve" />.</summary>
    </member>
    <member name="T:System.Security.Cryptography.ECCurve.ECCurveType">
      <summary>Indica cómo interpretar los datos que se incluyen en un objeto <see cref="T:System.Security.Cryptography.ECCurve" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.ECCurveType.Characteristic2">
      <summary>Los parámetros de curva representan una curva de característica 2.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.ECCurveType.Implicit">
      <summary>No se interpreta información alguna de la curva. Se supone que el llamador conoce la curva.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.ECCurveType.Named">
      <summary>Los parámetros de curva representan una curva con nombre.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.ECCurveType.PrimeMontgomery">
      <summary>Los parámetros de curva representan una curva de números primos con la fórmula B*y^2 = x^3 + A*x^2 + x.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.ECCurveType.PrimeShortWeierstrass">
      <summary>Los parámetros de curva representan una curva de números primos con la fórmula y^2 = x^3 + A*x + B en el campo P de números primos.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.ECCurveType.PrimeTwistedEdwards">
      <summary>Los parámetros de curva representan una curva de números primos con la fórmula A*x^2 + y^2 = 1 + B*x^2*y^2 en el campo P de números primos.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.G">
      <summary>El generador o punto base para las operaciones de la curva.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.Hash">
      <summary>El nombre del algoritmo hash que se usó para generar los coeficientes de las curvas (<see cref="F:System.Security.Cryptography.ECCurve.A" /> y <see cref="F:System.Security.Cryptography.ECCurve.B" />) desde el elemento <see cref="F:System.Security.Cryptography.ECCurve.Seed" />, situado en el algoritmo de generación ANSI X9.62. Solo se aplica a curvas explícitas.</summary>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.IsCharacteristic2">
      <summary>Obtiene un valor que indica si el tipo de curva indica una curva de característica 2 explícita.</summary>
      <returns>
        <see langword="true" /> si la curva es una curva de característica 2 explícita; <see langword="false" /> si la curva es una curva implícita, de números primos o de característica 2 con nombre.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.IsExplicit">
      <summary>Obtiene un valor que indica si el tipo de curva indica una curva explícita (de números primos o de característica 2).</summary>
      <returns>
        <see langword="true" /> si la curva es una curva explícita (de números primos o de característica 2); <see langword="false" /> si la curva es una curva con nombre o implícita.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.IsNamed">
      <summary>Obtiene un valor que indica si el tipo de curva indica una curva con nombre.</summary>
      <returns>
        <see langword="true" />Si la curva es una curva con nombre; <see langword="false" /> si la curva es una curva implícita o explícita (Primary o característico 2).</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.IsPrime">
      <summary>Obtiene un valor que indica si el tipo de curva indica una curva prime explícita.</summary>
      <returns>
        <see langword="true" /> si la curva es una curva de números primos explícita; <see langword="false" /> si la curva es una curva implícita, de característica 2 o de números primos con nombre.</returns>
    </member>
    <member name="T:System.Security.Cryptography.ECCurve.NamedCurves">
      <summary>Representa una clase de generador para crear curvas con nombre.</summary>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP160r1">
      <summary>Obtiene una curva con nombre brainpoolP160r1.</summary>
      <returns>Una curva con nombre brainpoolP160r1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP160t1">
      <summary>Obtiene una curva con nombre brainpoolP160t1.</summary>
      <returns>Una curva con nombre brainpoolP160t1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP192r1">
      <summary>Obtiene una curva con nombre brainpoolP192r1.</summary>
      <returns>Una curva con nombre brainpoolP192r1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP192t1">
      <summary>Obtiene una curva con nombre brainpoolP192t1.</summary>
      <returns>Una curva con nombre brainpoolP192t1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP224r1">
      <summary>Obtiene una curva con nombre brainpoolP224r1.</summary>
      <returns>Una curva con nombre brainpoolP224r1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP224t1">
      <summary>Obtiene una curva con nombre brainpoolP224t1.</summary>
      <returns>Una curva con nombre brainpoolP224t1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP256r1">
      <summary>Obtiene una curva con nombre brainpoolP256r1.</summary>
      <returns>Una curva con nombre brainpoolP256r1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP256t1">
      <summary>Obtiene una curva con nombre brainpoolP256t1.</summary>
      <returns>Una curva con nombre brainpoolP256t1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP320r1">
      <summary>Obtiene una curva con nombre brainpoolP320r1.</summary>
      <returns>Una curva con nombre brainpoolP320r1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP320t1">
      <summary>Obtiene una curva con nombre brainpoolP320t1.</summary>
      <returns>Una curva con nombre brainpoolP320t1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP384r1">
      <summary>Obtiene una curva con nombre brainpoolP384r1.</summary>
      <returns>Una curva con nombre brainpoolP384r1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP384t1">
      <summary>Obtiene una curva con nombre brainpoolP384t1.</summary>
      <returns>Una curva con nombre brainpoolP384t1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP512r1">
      <summary>Obtiene una curva con nombre brainpoolP512r1.</summary>
      <returns>Una curva con nombre brainpoolP512r1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP512t1">
      <summary>Obtiene una curva con nombre brainpoolP512t1.</summary>
      <returns>Una curva con nombre brainpoolP512t1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.nistP256">
      <summary>Obtiene una curva con nombre nistP256.</summary>
      <returns>Una curva con nombre nistP256.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.nistP384">
      <summary>Obtiene una curva con nombre nistP384.</summary>
      <returns>Una curva con nombre nistP384.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.nistP521">
      <summary>Obtiene una curva con nombre nistP521.</summary>
      <returns>Una curva con nombre nistP521.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.Oid">
      <summary>Obtiene el identificador de una curva con nombre.</summary>
      <returns>El identificador de una curva con nombre.</returns>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.Order">
      <summary>El orden de la curva. Solo se aplica a curvas explícitas.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.Polynomial">
      <summary>La curva polinomial. Solo se aplica a las curvas de característica 2.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.Prime">
      <summary>El primo que especifica el campo base. Solo se aplica a las curvas prime.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.Seed">
      <summary>El valor de inicialización para la generación de coeficientes en el algoritmo de generación ANSI X9.62. Solo se aplica a curvas explícitas.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECCurve.Validate">
      <summary>Valida la integridad de la curva actual. Inicia una excepción de <see cref="T:System.Security.Cryptography.CryptographicException" /> si la estructura no es válida.</summary>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Los parámetros de curva no son válidos para el tipo de curva actual.</exception>
    </member>
    <member name="T:System.Security.Cryptography.ECDiffieHellman">
      <summary>Proporciona una clase base abstracta de la que pueden derivar las implementaciones de algoritmos Diffie-Hellman de curva elíptica (ECDH). Esta clase proporciona el conjunto básico de operaciones que todas las implementaciones ECDH deben admitir.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.ECDiffieHellman" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.Create">
      <summary>Crea una nueva instancia de la implementación predeterminada del algoritmo Diffie-Hellman de curva elíptica (ECDH).</summary>
      <returns>Nueva instancia de la implementación predeterminada de esta clase.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECCurve)">
      <summary>Crea una nueva instancia de la implementación predeterminada del algoritmo de Diffie-Hellman de curva elíptica (ECDH) con un nuevo par de claves pública-privada que se genera sobre la curva especificada.</summary>
      <param name="curve">La curva que se usará para generar un nuevo par de claves pública-privada.</param>
      <returns>Una nueva instancia de la implementación predeterminada del algoritmo de Diffie-Hellman de curva elíptica (ECDH).</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="curve" /> no se valida.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECParameters)">
      <summary>Crea una nueva instancia de la implementación predeterminada del algoritmo de Diffie-Hellman de curva elíptica (ECDH) con la clave que describe el objeto <see cref="T:System.Security.Cryptography.ECParameters" /> especificado.</summary>
      <param name="parameters">Parámetros del algoritmo de criptografía de curva elíptica (ECC).</param>
      <returns>Una nueva instancia de la implementación predeterminada del algoritmo de Diffie-Hellman de curva elíptica (ECDH).</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="parameters" /> no se valida.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.Create(System.String)">
      <summary>Crea una nueva instancia de la implementación especificada del algoritmo de Diffie-Hellman de curva elíptica (ECDH).</summary>
      <param name="algorithm">Nombre de una implementación del algoritmo ECDH.</param>
      <returns>Nueva instancia de la implementación especificada de esta clase. Si el nombre del algoritmo especificado no se asigna a una implementación ECDH, este método devuelve <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="algorithm" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Deriva bytes que se pueden usar como una clave mediante una función hash, dada la clave pública de otra parte y el nombre del algoritmo hash.</summary>
      <param name="otherPartyPublicKey">Clave pública de la otra parte.</param>
      <param name="hashAlgorithm">Algoritmo hash que se va a usar para derivar el material de clave.</param>
      <returns>Material de clave del intercambio de claves con la clave pública de la otra parte.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="otherPartyPublicKey" /> está en una curva diferente de esta clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])">
      <summary>Cuando se implementa en una clase derivada, deriva bytes que se pueden usar como una clave mediante una función hash, dada la clave pública de otra parte, el nombre del algoritmo hash, un valor Prepend y un valor Append.</summary>
      <param name="otherPartyPublicKey">Clave pública de la otra parte.</param>
      <param name="hashAlgorithm">Algoritmo hash que se va a usar para derivar el material de clave.</param>
      <param name="secretPrepend">Valor para anteponer al secreto derivado antes de la operación hash.</param>
      <param name="secretAppend">Valor para anexar al secreto derivado antes de la operación hash.</param>
      <returns>Material de clave del intercambio de claves con la clave pública de la otra parte.</returns>
      <exception cref="T:System.NotImplementedException">Una clase derivada debe reemplazar este método.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="otherPartyPublicKey" /> está en una curva diferente de esta clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
      <summary>Deriva bytes que se pueden usar como una clave mediante un código de autenticación de mensajes basado en hash (HMAC).</summary>
      <param name="otherPartyPublicKey">Clave pública de la otra parte.</param>
      <param name="hashAlgorithm">Algoritmo hash que se va a usar para derivar el material de clave.</param>
      <param name="hmacKey">Clave para HMAC.</param>
      <returns>Material de clave del intercambio de claves con la clave pública de la otra parte.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="otherPartyPublicKey" /> está en una curva diferente de esta clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[],System.Byte[])">
      <summary>Cuando se implementa en un clase derivada, deriva bytes que se pueden usar como una clave mediante un código de autenticación de mensajes basado en hash (HMAC).</summary>
      <param name="otherPartyPublicKey">Clave pública de la otra parte.</param>
      <param name="hashAlgorithm">Algoritmo hash que se va a usar para derivar el material de clave.</param>
      <param name="hmacKey">Clave para HMAC.</param>
      <param name="secretPrepend">Valor para anteponer al secreto derivado antes de la operación hash.</param>
      <param name="secretAppend">Valor para anexar al secreto derivado antes de la operación hash.</param>
      <returns>Material de clave del intercambio de claves con la clave pública de la otra parte.</returns>
      <exception cref="T:System.NotImplementedException">Una clase derivada debe reemplazar este método.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="otherPartyPublicKey" /> está en una curva diferente de esta clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyMaterial(System.Security.Cryptography.ECDiffieHellmanPublicKey)">
      <summary>Deriva bytes que se pueden utilizar como clave, si hay una clave pública de la otra parte.</summary>
      <param name="otherPartyPublicKey">Clave pública de la otra parte.</param>
      <returns>Material de clave del intercambio de claves con la clave pública de la otra parte.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyTls(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Byte[],System.Byte[])">
      <summary>Cuando se implementa en una clase derivada, deriva bytes que se pueden usar como una clave mediante un algoritmo de derivación de la función pesudoaleatoria (PRF) de seguridad de capa de transporte (TLS).</summary>
      <param name="otherPartyPublicKey">Clave pública de la otra parte.</param>
      <param name="prfLabel">Etiqueta PRF con codificación ASCII.</param>
      <param name="prfSeed">Valor de inicialización de PRF de 64 bytes.</param>
      <returns>Material de clave del intercambio de claves con la clave pública de la otra parte.</returns>
      <exception cref="T:System.NotImplementedException">Una clase derivada debe reemplazar este método.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="otherPartyPublicKey" /> está en una curva diferente de esta clave.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="prfLabel" /> o <paramref name="prfSeed" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="prfSeed" /> no es exactamente 64 bytes de longitud.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ExportECPrivateKey">
      <summary>Exporta la clave actual en el formato ECPrivateKey.</summary>
      <returns>Matriz de bytes que contiene la representación ECPrivateKey de esta clave.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido exportar la clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ExportExplicitParameters(System.Boolean)">
      <summary>Si se reemplaza en una clase derivada, exporta la información de clave pública o la información de clave pública y privada con el formulario de curva explícito desde una clave <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> de trabajo a una estructura <see cref="T:System.Security.Cryptography.ECParameters" /> de modo que pueda pasarse al método <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />.</summary>
      <param name="includePrivateParameters">Es <see langword="true" /> si se van a incluir parámetros privados; en caso contrario, es <see langword="false" />.</param>
      <returns>Un objeto que representa el punto de la curva para esta clave, con el formato de curva explícito.</returns>
      <exception cref="T:System.NotImplementedException">Una clase derivada debe reemplazar este método.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ExportParameters(System.Boolean)">
      <summary>Si se reemplaza en una clase derivada, exporta la información de clave pública o la información de clave pública y privada desde una clave <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> de trabajo a una estructura <see cref="T:System.Security.Cryptography.ECParameters" /> de modo que pueda pasarse al método <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />.</summary>
      <param name="includePrivateParameters">
        <see langword="true" /> para incluir parámetros privados; en caso contrario, <see langword="false" /> para incluir solo parámetros públicos.</param>
      <returns>Un objeto que representa el punto de la curva para esta clave. Puede pasarse al método <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />.</returns>
      <exception cref="T:System.NotImplementedException">Una clase derivada debe reemplazar este método.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.FromXmlString(System.String)">
      <summary>Se produce este método en todos los casos.</summary>
      <param name="xmlString">Cadena XML que se usa para reconstruir el objeto <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" />.</param>
      <exception cref="T:System.NotImplementedException">En todos los casos.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.GenerateKey(System.Security.Cryptography.ECCurve)">
      <summary>Si se reemplaza en una clase derivada, genera un nuevo par de claves pública-privada efímeras para la curva especificada.</summary>
      <param name="curve">La curva usada para generar un par de claves pública-privada efímeras.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="curve" /> no se valida.</exception>
      <exception cref="T:System.NotImplementedException">Una clase derivada debe reemplazar este método.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportECPrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importa el par de claves pública/privada desde una estructura ECPrivateKey, reemplazando las claves de este objeto.</summary>
      <param name="source">Bytes de una estructura ECPrivateKey en la codificación ASN.1-BER.</param>
      <param name="bytesRead">El resultado que devuelve este método contiene un valor que indica el número de bytes leídos de <paramref name="source" />. Este parámetro se trata como sin inicializar.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El contenido de <paramref name="source" /> no representa una estructura ECPrivateKey de PKCS#8 codificada con ASN.1-BER.
O bien
No se puede importar la clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importa el par de claves pública/privada desde una estructura EncryptedPrivateKeyInfo de PKCS#8 después de descifrar con una contraseña basada en bytes, reemplazando las claves de este objeto.</summary>
      <param name="passwordBytes">Bytes que se van a usar como contraseña al descifrar el material de clave.</param>
      <param name="source">Bytes de una estructura EncryptedPrivateKeyInfo de PKCS#8 en la codificación ASN.1-BER.</param>
      <param name="bytesRead">El resultado que devuelve este método contiene un valor que indica el número de bytes leídos de <paramref name="source" />. Este parámetro se trata como sin inicializar.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La contraseña es incorrecta.
O bien
El contenido de <paramref name="source" /> indica que la función de derivación de claves (KDF) que se va a aplicar es la heredada de PKCS#12, que requiere contraseñas basadas en <see cref="T:System.Char" />.
O bien
El contenido de <paramref name="source" /> no representa una estructura EncryptedPrivateKeyInfo de PKCS#8 codificada con ASN.1-BER.
o bien
El contenido de <paramref name="source" /> indica que la clave es para un algoritmo distinto del algoritmo que representa esta instancia.
O bien
El contenido de <paramref name="source" /> representa la clave en un formato que no se admite.
o bien
No se ha podido importar la clave específica del algoritmo.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importa el par de claves pública/privada desde una estructura EncryptedPrivateKeyInfo de PKCS#8 después de descifrar con una contraseña basada en caracteres, reemplazando las claves de este objeto.</summary>
      <param name="password">Contraseña que se va a usar para descifrar el material de clave.</param>
      <param name="source">Bytes de una estructura EncryptedPrivateKeyInfo de PKCS#8 en la codificación ASN.1-BER.</param>
      <param name="bytesRead">El resultado que devuelve este método contiene un valor que indica el número de bytes leídos de <paramref name="source" />. Este parámetro se trata como sin inicializar.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La contraseña es incorrecta.
O bien
El contenido de <paramref name="source" /> no representa una estructura EncryptedPrivateKeyInfo de PKCS#8 codificada con ASN.1-BER.
O bien
El contenido de <paramref name="source" /> indica que la clave es para un algoritmo distinto del algoritmo que representa esta instancia.
o bien
El contenido de <paramref name="source" /> representa la clave en un formato que no se admite.
O bien
No se ha podido importar la clave específica del algoritmo.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)">
      <summary>Si se reemplaza en una clase derivada, importa los parámetros especificados para un objeto <see cref="T:System.Security.Cryptography.ECCurve" /> como clave efímera en el objeto <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> actual.</summary>
      <param name="parameters">Los parámetros de la curva que se importarán.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="parameters" /> no se valida.</exception>
      <exception cref="T:System.NotImplementedException">Una clase derivada debe reemplazar este método.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importa el par de claves pública/privada desde una estructura PrivateKeyInfo de PKCS#8 después del descifrado, reemplazando las claves de este objeto.</summary>
      <param name="source">Bytes de una estructura PrivateKeyInfo de PKCS#8 en la codificación ASN.1-BER.</param>
      <param name="bytesRead">El resultado que devuelve este método contiene un valor que indica el número de bytes leídos de <paramref name="source" />. Este parámetro se trata como sin inicializar.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El contenido de <paramref name="source" /> no representa una estructura PrivateKeyInfo de PKCS#8 codificada con ASN.1-BER.
O bien
El contenido de <paramref name="source" /> indica que la clave es para un algoritmo distinto del algoritmo que representa esta instancia.
o bien
El contenido de <paramref name="source" /> representa la clave en un formato que no se admite.
O bien
No se ha podido importar la clave específica del algoritmo.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportSubjectPublicKeyInfo(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importa la clave pública desde una estructura SubjectPublicKeyInfo de X.509 después del descifrado, reemplazando las claves de este objeto.</summary>
      <param name="source">Bytes de una estructura SubjectPublicKeyInfo de X.509 en la codificación ASN.1-DER.</param>
      <param name="bytesRead">El resultado que devuelve este método contiene un valor que indica el número de bytes leídos de <paramref name="source" />. Este parámetro se trata como sin inicializar.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El contenido de <paramref name="source" /> no representa una estructura SubjectPublicKeyInfo de X.509 codificada con ASN.1-DER.
o bien
El contenido de <paramref name="source" /> indica que la clave es para un algoritmo distinto del algoritmo que representa esta instancia.
O bien
El contenido de <paramref name="source" /> representa la clave en un formato que no se admite.
O bien
No se ha podido importar la clave específica del algoritmo.</exception>
    </member>
    <member name="P:System.Security.Cryptography.ECDiffieHellman.KeyExchangeAlgorithm">
      <summary>Obtiene el nombre del algoritmo de intercambio de claves.</summary>
      <returns>Nombre del algoritmo de intercambio de claves.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECDiffieHellman.PublicKey">
      <summary>Obtiene la clave pública que utiliza la instancia Diffie-Hellman de curva elíptica (ECDH) actual.</summary>
      <returns>Parte pública del par de claves ECDH utilizada por esta instancia <see cref="T:System.Security.Cryptography.ECDiffieHellman" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECDiffieHellman.SignatureAlgorithm">
      <summary>Obtiene el nombre del algoritmo de firma.</summary>
      <returns>Siempre es <see langword="null" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ToXmlString(System.Boolean)">
      <summary>Se produce este método en todos los casos.</summary>
      <param name="includePrivateParameters">Es <see langword="true" /> si se van a incluir parámetros privados; en caso contrario, es <see langword="false" />.</param>
      <returns>Este método no devuelve ningún valor.</returns>
      <exception cref="T:System.NotImplementedException">En todos los casos.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.TryExportECPrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Intenta exportar la clave actual en el formato ECPrivateKey a un búfer proporcionado.</summary>
      <param name="destination">Intervalo de bytes que va a recibir los datos de ECPrivateKey.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene un valor que indica el número de bytes escritos en <paramref name="destination" />. Este parámetro se trata como sin inicializar.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> es lo suficientemente grande como para recibir la salida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido exportar la clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Intenta exportar la clave actual en el formato EncryptedPrivateKeyInfo de PKCS#8 a un búfer proporcionado, utilizando una contraseña basada en bytes.</summary>
      <param name="passwordBytes">Bytes que se van a usar como contraseña al cifrar el material de clave.</param>
      <param name="pbeParameters">Parámetros de cifrado basados en contraseña (PBE) que se van a usar al cifrar el material de clave.</param>
      <param name="destination">Intervalo de bytes que va a recibir los datos de EncryptedPrivateKeyInfo de PKCS#8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene un valor que indica el número de bytes escritos en <paramref name="destination" />. Este parámetro se trata como sin inicializar.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> es lo suficientemente grande como para recibir la salida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido exportar la clave.
O bien
<paramref name="pbeParameters" /> indica que debe usarse <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" />, el cual requiere contraseñas basadas en <see cref="T:System.Char" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Intenta exportar la clave actual en el formato EncryptedPrivateKeyInfo de PKCS#8 a un búfer proporcionado, utilizando una contraseña basada en caracteres.</summary>
      <param name="password">Contraseña que se va a usar al cifrar el material de clave.</param>
      <param name="pbeParameters">Parámetros de cifrado basados en contraseña (PBE) que se van a usar al cifrar el material de clave.</param>
      <param name="destination">Intervalo de bytes que va a recibir los datos de EncryptedPrivateKeyInfo de PKCS#8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene un valor que indica el número de bytes escritos en <paramref name="destination" />. Este parámetro se trata como sin inicializar.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> es lo suficientemente grande como para recibir la salida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido exportar la clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.TryExportPkcs8PrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Intenta exportar la clave actual en el formato PrivateKeyInfo de PKCS#8 a un búfer proporcionado.</summary>
      <param name="destination">Intervalo de bytes que va a recibir los datos de PrivateKeyInfo de PKCS#8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene un valor que indica el número de bytes escritos en <paramref name="destination" />. Este parámetro se trata como sin inicializar.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> es lo suficientemente grande como para recibir la salida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido exportar la clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.TryExportSubjectPublicKeyInfo(System.Span{System.Byte},System.Int32@)">
      <summary>Intenta exportar la clave actual en el formato SubjectPublicKeyInfo de X.509 a un búfer proporcionado.</summary>
      <param name="destination">Intervalo de bytes que va a recibir los datos de SubjectPublicKeyInfo de X.509.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene un valor que indica el número de bytes escritos en <paramref name="destination" />. Este parámetro se trata como sin inicializar.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> es lo suficientemente grande como para recibir la salida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido exportar la clave.</exception>
    </member>
    <member name="T:System.Security.Cryptography.ECDiffieHellmanPublicKey">
      <summary>Proporciona una clase base abstracta de la que deben heredar todas las implementaciones <see cref="T:System.Security.Cryptography.ECDiffieHellmanCngPublicKey" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.#ctor(System.Byte[])">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" />.</summary>
      <param name="keyBlob">Matriz de bytes que representa un objeto <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="keyBlob" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.Dispose">
      <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Security.Cryptography.ECDiffieHellman" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.Dispose(System.Boolean)">
      <summary>Libera los recursos no administrados utilizados por la clase <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> y, de forma opcional, libera los recursos administrados.</summary>
      <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.ExportExplicitParameters">
      <summary>Si se reemplaza en una clase derivada, exporta el objeto <see cref="T:System.Security.Cryptography.ECParameters" /> explícito para un objeto <see cref="T:System.Security.Cryptography.ECCurve" />.</summary>
      <returns>Un objeto que representa el punto de la curva para esta clave, con el formato de curva explícito.</returns>
      <exception cref="T:System.NotSupportedException">Una clase derivada debe reemplazar este método.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.ExportParameters">
      <summary>Si se reemplaza en una clase derivada, exporta el objeto <see cref="T:System.Security.Cryptography.ECParameters" /> con nombre o explícito para un objeto <see cref="T:System.Security.Cryptography.ECCurve" />.</summary>
      <returns>Un objeto que representa el punto de la curva para esta clave.</returns>
      <exception cref="T:System.NotSupportedException">Una clase derivada debe reemplazar este método.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.ToByteArray">
      <summary>Serializa el BLOB de la clave <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" /> en una matriz de bytes.</summary>
      <returns>Matriz de bytes que contiene la clave pública Diffie-Hellman de curva elíptica (ECDH) serializada.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.ToXmlString">
      <summary>Serializa la clave pública <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" /> en una cadena XML.</summary>
      <returns>Cadena XML que contiene la clave pública Diffie-Hellman de curva elíptica (ECDH) serializada.</returns>
    </member>
    <member name="T:System.Security.Cryptography.ECDsa">
      <summary>Proporciona una clase base abstracta que encapsula el algoritmo de firma digital de curva elíptica (ECDSA, Elliptic Curve Digital Signature Algorithm).</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.ECDsa" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.Create">
      <summary>Crea una nueva instancia de la implementación predeterminada del algoritmo de firma digital de curva elíptica (ECDSA).</summary>
      <returns>Nueva instancia de la implementación predeterminada (<see cref="T:System.Security.Cryptography.ECDsaCng" />) de esta clase.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.Create(System.Security.Cryptography.ECCurve)">
      <summary>Crea una nueva instancia de la implementación predeterminada de Elliptic Curve Digital Signature Algorithm (ECDSA) con una clave recién generada sobre la curva especificada.</summary>
      <param name="curve">La curva que se usará para la generación de claves.</param>
      <returns>Nueva instancia de la implementación predeterminada (<see cref="T:System.Security.Cryptography.ECDsaCng" />) de esta clase.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.Create(System.Security.Cryptography.ECParameters)">
      <summary>Crea una nueva instancia de la implementación predeterminada de Elliptic Curve Digital Signature Algorithm (ECDSA) con los parámetros especificados como clave.</summary>
      <param name="parameters">Los parámetros que representan la clave que se usará.</param>
      <returns>Nueva instancia de la implementación predeterminada (<see cref="T:System.Security.Cryptography.ECDsaCng" />) de esta clase.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.Create(System.String)">
      <summary>Crea una nueva instancia de la implementación especificada del algoritmo de firma digital de curva elíptica (ECDSA).</summary>
      <param name="algorithm">Nombre de una implementación ECDSA. Las cadenas siguientes hacen todas referencia a la misma implementación, que es la única implementación actualmente admitida en .NET Framework: 
- "ECDsa" 
- "ECDsaCng" 
- "System.Security.Cryptography.ECDsaCng" 
También puede proporcionar el nombre de una implementación ECDSA personalizada.</param>
      <returns>Nueva instancia de la implementación especificada de esta clase. Si el nombre del algoritmo especificado no se asigna a una implementación ECDSA, este método devuelve <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="algorithm" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ExportECPrivateKey">
      <summary>Exporta la clave actual en el formato ECPrivateKey.</summary>
      <returns>Matriz de bytes que contiene la representación ECPrivateKey de esta clave.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido exportar la clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ExportExplicitParameters(System.Boolean)">
      <summary>Si se reemplaza en una clase derivada, exporta los parámetros explícitos para una curva elíptica.</summary>
      <param name="includePrivateParameters">Es <see langword="true" /> si se van a incluir parámetros privados; en caso contrario, es <see langword="false" />.</param>
      <returns>Los parámetros que representan el punto de la curva para esta clave, con el formato de curva explícito.</returns>
      <exception cref="T:System.NotSupportedException">Una clase derivada debe reemplazar este método.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ExportParameters(System.Boolean)">
      <summary>Si se reemplaza en una clase derivada, exporta los parámetros con nombre o explícitos para una curva elíptica. Si la curva tiene un nombre, el campo <see cref="F:System.Security.Cryptography.ECParameters.Curve" /> contiene parámetros de curva con nombre; en caso contrario, contiene parámetros explícitos.</summary>
      <param name="includePrivateParameters">Es <see langword="true" /> si se van a incluir parámetros privados; en caso contrario, es <see langword="false" />.</param>
      <returns>Los parámetros que representan el punto de la curva para esta clave.</returns>
      <exception cref="T:System.NotSupportedException">Una clase derivada debe reemplazar este método.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.FromXmlString(System.String)">
      <summary>Se produce este método en todos los casos.</summary>
      <param name="xmlString">Cadena XML que se usa para reconstruir el objeto <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" />.</param>
      <exception cref="T:System.NotImplementedException">En todos los casos.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.GenerateKey(System.Security.Cryptography.ECCurve)">
      <summary>Si se reemplaza en una clase derivada, genera un nuevo par de claves pública-privada para la curva especificada.</summary>
      <param name="curve">La curva que se usará.</param>
      <exception cref="T:System.NotSupportedException">Una clase derivada debe reemplazar este método.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.HashData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Cuando se reemplaza en una clase derivada, calcula el valor hash de la parte especificada de una matriz de bytes usando el algoritmo hash especificado.</summary>
      <param name="data">Datos a los que se va a aplicar un algoritmo hash.</param>
      <param name="offset">Índice del primer byte de <paramref name="data" /> al que se va a aplicar un algoritmo hash.</param>
      <param name="count">Número de bytes a los que se va a aplicar un algoritmo hash.</param>
      <param name="hashAlgorithm">Algoritmo hash que se va a aplicar a los datos.</param>
      <returns>Datos a los que se aplicó un algoritmo hash.</returns>
      <exception cref="T:System.NotImplementedException">Una clase derivada debe reemplazar este método.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.HashData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Cuando se reemplaza en una clase derivada, calcula el valor hash de la secuencia binaria especificada usando el algoritmo hash especificado.</summary>
      <param name="data">Secuencia binaria a la que se va a aplicar un algoritmo hash.</param>
      <param name="hashAlgorithm">Algoritmo hash que se va a aplicar a los datos.</param>
      <returns>Datos a los que se aplicó un algoritmo hash.</returns>
      <exception cref="T:System.NotImplementedException">Una clase derivada debe reemplazar este método.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportECPrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importa el par de claves pública/privada desde una estructura ECPrivateKey, reemplazando las claves de este objeto.</summary>
      <param name="source">Bytes de una estructura ECPrivateKey en la codificación ASN.1-BER.</param>
      <param name="bytesRead">El resultado que devuelve este método contiene un valor que indica el número de bytes leídos de <paramref name="source" />. Este parámetro se trata como sin inicializar.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El contenido de <paramref name="source" /> no representa una estructura ECPrivateKey de PKCS#8 codificada con ASN.1-BER.
O bien
No se puede importar la clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importa el par de claves pública/privada desde una estructura EncryptedPrivateKeyInfo de PKCS#8 después de descifrar con una contraseña basada en bytes, reemplazando las claves de este objeto.</summary>
      <param name="passwordBytes">Bytes que se van a usar como contraseña al descifrar el material de clave.</param>
      <param name="source">Bytes de una estructura EncryptedPrivateKeyInfo de PKCS#8 en la codificación ASN.1-BER.</param>
      <param name="bytesRead">El resultado que devuelve este método contiene un valor que indica el número de bytes leídos de <paramref name="source" />. Este parámetro se trata como sin inicializar.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La contraseña es incorrecta.
o bien
El contenido de <paramref name="source" /> indica que la función de derivación de claves (KDF) que se va a aplicar es la heredada de PKCS#12, que requiere contraseñas basadas en <see cref="T:System.Char" />.
O bien
El contenido de <paramref name="source" /> no representa una estructura EncryptedPrivateKeyInfo de PKCS#8 codificada con ASN.1-BER.
O bien
El contenido de <paramref name="source" /> indica que la clave es para un algoritmo distinto del algoritmo que representa esta instancia.
O bien
El contenido de <paramref name="source" /> representa la clave en un formato que no se admite.
O bien
No se ha podido importar la clave específica del algoritmo.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importa el par de claves pública/privada desde una estructura EncryptedPrivateKeyInfo de PKCS#8 después de descifrar con una contraseña basada en caracteres, reemplazando las claves de este objeto.</summary>
      <param name="password">Contraseña que se va a usar para descifrar el material de clave.</param>
      <param name="source">Bytes de una estructura EncryptedPrivateKeyInfo de PKCS#8 en la codificación ASN.1-BER.</param>
      <param name="bytesRead">El resultado que devuelve este método contiene un valor que indica el número de bytes leídos de <paramref name="source" />. Este parámetro se trata como sin inicializar.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La contraseña es incorrecta.
O bien
El contenido de <paramref name="source" /> no representa una estructura EncryptedPrivateKeyInfo de PKCS#8 codificada con ASN.1-BER.
O bien
El contenido de <paramref name="source" /> indica que la clave es para un algoritmo distinto del algoritmo que representa esta instancia.
o bien
El contenido de <paramref name="source" /> representa la clave en un formato que no se admite.
O bien
No se ha podido importar la clave específica del algoritmo.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportParameters(System.Security.Cryptography.ECParameters)">
      <summary>Si se reemplaza en una clase derivada, importa los parámetros especificados.</summary>
      <param name="parameters">Los parámetros de curva.</param>
      <exception cref="T:System.NotSupportedException">Una clase derivada debe reemplazar este método.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importa el par de claves pública/privada desde una estructura PrivateKeyInfo de PKCS#8 después del descifrado, reemplazando las claves de este objeto.</summary>
      <param name="source">Bytes de una estructura PrivateKeyInfo de PKCS#8 en la codificación ASN.1-BER.</param>
      <param name="bytesRead">El resultado que devuelve este método contiene un valor que indica el número de bytes leídos de <paramref name="source" />. Este parámetro se trata como sin inicializar.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El contenido de <paramref name="source" /> no representa una estructura PrivateKeyInfo de PKCS#8 codificada con ASN.1-BER.
O bien
El contenido de <paramref name="source" /> indica que la clave es para un algoritmo distinto del algoritmo que representa esta instancia.
O bien
El contenido de <paramref name="source" /> representa la clave en un formato que no se admite.
o bien
No se ha podido importar la clave específica del algoritmo.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportSubjectPublicKeyInfo(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importa la clave pública desde una estructura SubjectPublicKeyInfo de X.509 después del descifrado, reemplazando las claves de este objeto.</summary>
      <param name="source">Bytes de una estructura SubjectPublicKeyInfo de X.509 en la codificación ASN.1-DER.</param>
      <param name="bytesRead">El resultado que devuelve este método contiene un valor que indica el número de bytes leídos de <paramref name="source" />. Este parámetro se trata como sin inicializar.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El contenido de <paramref name="source" /> no representa una estructura SubjectPublicKeyInfo de X.509 codificada con ASN.1-DER.
o bien
El contenido de <paramref name="source" /> indica que la clave es para un algoritmo distinto del algoritmo que representa esta instancia.
O bien
El contenido de <paramref name="source" /> representa la clave en un formato que no se admite.
o bien
No se ha podido importar la clave específica del algoritmo.</exception>
    </member>
    <member name="P:System.Security.Cryptography.ECDsa.KeyExchangeAlgorithm">
      <summary>Obtiene el nombre del algoritmo de intercambio de claves.</summary>
      <returns>Siempre es <see langword="null" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECDsa.SignatureAlgorithm">
      <summary>Obtiene el nombre del algoritmo de firma.</summary>
      <returns>Cadena "ECDsa".</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Calcula el valor hash de una parte de la matriz de bytes especificada usando el algoritmo hash especificado y firma el valor hash resultante.</summary>
      <param name="data">Datos de entrada para los que se va a calcular el hash.</param>
      <param name="offset">Desplazamiento en la matriz en el que se empezarán a usar los datos.</param>
      <param name="count">Número de bytes de la matriz que se van a usar como datos.</param>
      <param name="hashAlgorithm">Algoritmo hash que se va a usar para crear el valor hash.</param>
      <returns>Firma ECDSA de los datos especificados.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> es menor que cero.  
O bien 
 <paramref name="count" /> es menor que cero.  
o bien 
 <paramref name="offset" /> + <paramref name="count" /> - 1 produce un índice que supera el límite superior de <paramref name="data" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignData(System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Calcula el valor hash de la matriz de bytes especificada usando el algoritmo hash especificado y firma el valor hash resultante.</summary>
      <param name="data">Datos de entrada para los que se va a calcular el hash.</param>
      <param name="hashAlgorithm">Algoritmo hash que se va a usar para crear el valor hash.</param>
      <returns>Firma ECDSA de los datos especificados.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Calcula el valor hash de la secuencia especificada usando el algoritmo hash especificado y firma el valor hash resultante.</summary>
      <param name="data">Secuencia de entrada para la que se va a calcular el hash.</param>
      <param name="hashAlgorithm">Algoritmo hash que se va a usar para crear el valor hash.</param>
      <returns>Firma ECDSA de los datos especificados.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignHash(System.Byte[])">
      <summary>Genera una firma digital del valor hash especificado.</summary>
      <param name="hash">Valor hash de los datos que se a firman.</param>
      <returns>Firma digital que consiste en el valor hash determinado cifrado con la clave privada.</returns>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="hash" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ToXmlString(System.Boolean)">
      <summary>Se produce este método en todos los casos.</summary>
      <param name="includePrivateParameters">Es <see langword="true" /> si se van a incluir parámetros privados; en caso contrario, es <see langword="false" />.</param>
      <returns>Este método no devuelve ningún valor.</returns>
      <exception cref="T:System.NotImplementedException">En todos los casos.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TryExportECPrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Intenta exportar la clave actual en el formato ECPrivateKey a un búfer proporcionado.</summary>
      <param name="destination">Intervalo de bytes que va a recibir los datos de ECPrivateKey.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene un valor que indica el número de bytes escritos en <paramref name="destination" />. Este parámetro se trata como sin inicializar.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> es lo suficientemente grande como para recibir la salida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido exportar la clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Intenta exportar la clave actual en el formato EncryptedPrivateKeyInfo de PKCS#8 a un búfer proporcionado, utilizando una contraseña basada en bytes.</summary>
      <param name="passwordBytes">Bytes que se van a usar como contraseña al cifrar el material de clave.</param>
      <param name="pbeParameters">Parámetros de cifrado basados en contraseña (PBE) que se van a usar al cifrar el material de clave.</param>
      <param name="destination">Intervalo de bytes que va a recibir los datos de EncryptedPrivateKeyInfo de PKCS#8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene un valor que indica el número de bytes escritos en <paramref name="destination" />. Este parámetro se trata como sin inicializar.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> es lo suficientemente grande como para recibir la salida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido exportar la clave.
O bien
<paramref name="pbeParameters" /> indica que debe usarse <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" />, el cual requiere contraseñas basadas en <see cref="T:System.Char" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Intenta exportar la clave actual en el formato EncryptedPrivateKeyInfo de PKCS#8 a un búfer proporcionado, utilizando una contraseña basada en caracteres.</summary>
      <param name="password">Contraseña que se va a usar al cifrar el material de clave.</param>
      <param name="pbeParameters">Parámetros de cifrado basados en contraseña (PBE) que se van a usar al cifrar el material de clave.</param>
      <param name="destination">Intervalo de bytes que va a recibir los datos de EncryptedPrivateKeyInfo de PKCS#8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene un valor que indica el número de bytes escritos en <paramref name="destination" />. Este parámetro se trata como sin inicializar.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> es lo suficientemente grande como para recibir la salida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido exportar la clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TryExportPkcs8PrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Intenta exportar la clave actual en el formato PrivateKeyInfo de PKCS#8 a un búfer proporcionado.</summary>
      <param name="destination">Intervalo de bytes que va a recibir los datos de PrivateKeyInfo de PKCS#8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene un valor que indica el número de bytes escritos en <paramref name="destination" />. Este parámetro se trata como sin inicializar.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> es lo suficientemente grande como para recibir la salida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido exportar la clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TryExportSubjectPublicKeyInfo(System.Span{System.Byte},System.Int32@)">
      <summary>Intenta exportar la clave actual en el formato SubjectPublicKeyInfo de X.509 a un búfer proporcionado.</summary>
      <param name="destination">Intervalo de bytes que va a recibir los datos de SubjectPublicKeyInfo de X.509.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene un valor que indica el número de bytes escritos en <paramref name="destination" />. Este parámetro se trata como sin inicializar.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> es lo suficientemente grande como para recibir la salida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido exportar la clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TryHashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Int32@)">
      <param name="data" />
      <param name="destination" />
      <param name="hashAlgorithm" />
      <param name="bytesWritten" />
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TrySignData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Int32@)">
      <param name="data" />
      <param name="destination" />
      <param name="hashAlgorithm" />
      <param name="bytesWritten" />
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TrySignHash(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@)">
      <param name="hash" />
      <param name="destination" />
      <param name="bytesWritten" />
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyData(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Comprueba si una firma digital es válida calculando el valor hash de los datos especificados, para lo que usa el algoritmo hash especificado y lo compara con la firma proporcionada.</summary>
      <param name="data">Datos firmados.</param>
      <param name="signature">Datos de la firma que se van a comprobar.</param>
      <param name="hashAlgorithm">Algoritmo hash usado para crear el valor hash de los datos.</param>
      <returns>
        <see langword="true" /> si la firma es válida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> es <see langword="null" />.  
O bien 
 <paramref name="signature" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyData(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Comprueba si una firma digital es válida calculando el valor hash de los datos de una parte de una matriz de bytes, para lo que usa el algoritmo hash especificado y lo compara con la firma proporcionada.</summary>
      <param name="data">Datos firmados.</param>
      <param name="offset">Índice inicial en el que se va a calcular el hash.</param>
      <param name="count">Número de bytes a los que se va a aplicar un algoritmo hash.</param>
      <param name="signature">Datos de la firma que se van a comprobar.</param>
      <param name="hashAlgorithm">Algoritmo hash usado para crear el valor hash de los datos.</param>
      <returns>
        <see langword="true" /> si la firma es válida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> es <see langword="null" />.  
O bien 
 <paramref name="signature" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> es menor que cero.  
O bien 
 <paramref name="count" /> es menor que cero.  
o bien 
 <paramref name="offset" /> + <paramref name="count" /> - 1 produce un índice que supera el límite superior de <paramref name="data" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyData(System.IO.Stream,System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Comprueba si una firma digital es válida calculando el valor hash de la secuencia especificada, para lo que usa el algoritmo hash especificado y lo compara con la firma proporcionada.</summary>
      <param name="data">Datos firmados.</param>
      <param name="signature">Datos de la firma que se van a comprobar.</param>
      <param name="hashAlgorithm">Algoritmo hash usado para crear el valor hash de los datos.</param>
      <returns>
        <see langword="true" /> si la firma es válida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> es <see langword="null" />.  
O bien 
 <paramref name="signature" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyData(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName)">
      <param name="data" />
      <param name="signature" />
      <param name="hashAlgorithm" />
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyHash(System.Byte[],System.Byte[])">
      <summary>Comprueba una firma digital con el valor hash especificado.</summary>
      <param name="hash">Valor hash de un bloque de datos.</param>
      <param name="signature">Firma digital que se va a comprobar.</param>
      <returns>Es <see langword="true" /> si el valor hash es igual a la firma descifrada; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyHash(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
      <param name="hash" />
      <param name="signature" />
    </member>
    <member name="T:System.Security.Cryptography.ECParameters">
      <summary>Representa los parámetros estándar para el algoritmo de criptografía de curva elíptica (ECC).</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECParameters.Curve">
      <summary>Representa la curva asociada a la clave pública (<see cref="F:System.Security.Cryptography.ECParameters.Q" />) y la clave privada opcional (<see cref="F:System.Security.Cryptography.ECParameters.D" />).</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECParameters.D">
      <summary>Representa la clave privada <see langword="D" /> para el algoritmo de criptografía de curva elíptica (ECC), que se almacena en formato big endian.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECParameters.Q">
      <summary>Representa la clave pública <see langword="Q" /> para el algoritmo de criptografía de curva elíptica (ECC).</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECParameters.Validate">
      <summary>Valida el objeto actual.</summary>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La clave o parámetros de curva no son válidos para el tipo de curva actual.</exception>
    </member>
    <member name="T:System.Security.Cryptography.ECPoint">
      <summary>Representa un par de coordinadas (X, Y) para estructuras de criptografía de curva elíptica (ECC).</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECPoint.X">
      <summary>Representa la coordenada X.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECPoint.Y">
      <summary>Representa la coordenada Y.</summary>
    </member>
    <member name="T:System.Security.Cryptography.HMACMD5">
      <summary>Calcula un código de autenticación de mensajes basado en hash (HMAC) mediante la función hash <see cref="T:System.Security.Cryptography.MD5" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.HMACMD5" /> mediante una clave generada aleatoriamente.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.#ctor(System.Byte[])">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.HMACMD5" /> usando la clave especificada.</summary>
      <param name="key">Clave secreta para el cifrado de <see cref="T:System.Security.Cryptography.HMACMD5" />. La clave puede tener cualquier longitud, pero si tiene más de 64 bytes se utilizará un algoritmo hash (SHA-1) para derivar una clave de 64 bytes. Por consiguiente, el tamaño recomendado de la clave secreta es de 64 bytes.</param>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="key" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.Dispose(System.Boolean)">
      <param name="disposing" />
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.HashCore(System.Byte[],System.Int32,System.Int32)">
      <param name="rgb" />
      <param name="ib" />
      <param name="cb" />
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.HashCore(System.ReadOnlySpan{System.Byte})">
      <param name="source" />
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.HashFinal" />
    <member name="M:System.Security.Cryptography.HMACMD5.Initialize" />
    <member name="P:System.Security.Cryptography.HMACMD5.Key" />
    <member name="M:System.Security.Cryptography.HMACMD5.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <param name="destination" />
      <param name="bytesWritten" />
    </member>
    <member name="T:System.Security.Cryptography.HMACSHA1">
      <summary>Calcula un código de autenticación de mensajes basado en hash (HMAC) mediante la función hash <see cref="T:System.Security.Cryptography.SHA1" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.HMACSHA1" /> con una clave generada aleatoriamente.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.#ctor(System.Byte[])">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.HMACSHA1" /> con los datos de clave especificados.</summary>
      <param name="key">Clave secreta para el cifrado de <see cref="T:System.Security.Cryptography.HMACSHA1" />. La clave puede tener cualquier longitud, pero si tiene más de 64 bytes se usa un algoritmo hash (SHA-1) para derivar una clave de 64 bytes. Por consiguiente, el tamaño recomendado de la clave secreta es de 64 bytes.</param>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="key" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.#ctor(System.Byte[],System.Boolean)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.HMACSHA1" /> con los datos de clave especificados y un valor que especifica si se debe usar la versión administrada del algoritmo SHA1.</summary>
      <param name="key">Clave secreta para el cifrado de <see cref="T:System.Security.Cryptography.HMACSHA1" />. La clave puede tener cualquier longitud, pero si tiene más de 64 bytes se usa un algoritmo hash (SHA-1) para derivar una clave de 64 bytes. Por consiguiente, el tamaño recomendado de la clave secreta es de 64 bytes.</param>
      <param name="useManagedSha1">
        <see langword="true" /> para usar la implementación administrada del algoritmo SHA1 (la clase <see cref="T:System.Security.Cryptography.SHA1Managed" />); <see langword="false" /> para usar la implementación no administrada (la clase <see cref="T:System.Security.Cryptography.SHA1CryptoServiceProvider" />).</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.Dispose(System.Boolean)">
      <summary>Este miembro reemplaza a <see cref="M:System.Security.Cryptography.KeyedHashAlgorithm.Dispose(System.Boolean)" />; puede haber documentación más completa en ese tema.
Libera los recursos no administrados que usa <see cref="T:System.Security.Cryptography.KeyedHashAlgorithm" /> y, de forma opcional, libera los recursos administrados.</summary>
      <param name="disposing">
        <see langword="true" /> para liberar tanto los recursos administrados como los no administrados; false para liberar únicamente los recursos no administrados.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.HashCore(System.Byte[],System.Int32,System.Int32)">
      <summary>Redirige los datos escritos en el objeto al algoritmo hash SHA1 para el cálculo del código de autenticación de mensajes basado en hash (HMAC).</summary>
      <param name="rgb">Datos de entrada.</param>
      <param name="ib">Desplazamiento en la matriz de bytes a partir del cual se empezarán a usar los datos.</param>
      <param name="cb">Número de bytes de la matriz que se van a usar como datos.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.HashCore(System.ReadOnlySpan{System.Byte})">
      <param name="source" />
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.HashFinal" />
    <member name="M:System.Security.Cryptography.HMACSHA1.Initialize">
      <summary>Inicializa una instancia de <see cref="T:System.Security.Cryptography.HMACSHA1" />.</summary>
    </member>
    <member name="P:System.Security.Cryptography.HMACSHA1.Key">
      <summary>Obtiene o establece la clave que se va a utilizar en el algoritmo hash.</summary>
      <returns>Clave que se va a utilizar en el algoritmo hash.</returns>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <param name="destination" />
      <param name="bytesWritten" />
    </member>
    <member name="T:System.Security.Cryptography.HMACSHA256">
      <summary>Calcula un código de autenticación de mensajes basado en hash (HMAC) mediante la función hash <see cref="T:System.Security.Cryptography.SHA256" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.HMACSHA256" /> con una clave generada aleatoriamente.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.#ctor(System.Byte[])">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.HMACSHA256" /> con los datos de clave especificados.</summary>
      <param name="key">Clave secreta para el cifrado de <see cref="T:System.Security.Cryptography.HMACSHA256" />. La clave puede tener cualquier longitud. Sin embargo, el tamaño recomendado es de 64 bytes. Si la clave tiene más de 64 bytes se usará un algoritmo hash (SHA-256) para derivar una clave de 64 bytes. Si es menor de 64 bytes de longitud, se completa en 64 bytes.</param>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="key" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.Dispose(System.Boolean)">
      <param name="disposing" />
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.HashCore(System.Byte[],System.Int32,System.Int32)">
      <param name="rgb" />
      <param name="ib" />
      <param name="cb" />
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.HashCore(System.ReadOnlySpan{System.Byte})">
      <param name="source" />
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.HashFinal" />
    <member name="M:System.Security.Cryptography.HMACSHA256.Initialize" />
    <member name="P:System.Security.Cryptography.HMACSHA256.Key" />
    <member name="M:System.Security.Cryptography.HMACSHA256.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <param name="destination" />
      <param name="bytesWritten" />
    </member>
    <member name="T:System.Security.Cryptography.HMACSHA384">
      <summary>Calcula un código de autenticación de mensajes basado en hash (HMAC) mediante la función hash <see cref="T:System.Security.Cryptography.SHA384" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.HMACSHA384" /> mediante una clave generada aleatoriamente.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.#ctor(System.Byte[])">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.HMACSHA384" /> mediante los datos de clave especificados.</summary>
      <param name="key">Clave secreta para el cifrado de <see cref="T:System.Security.Cryptography.HMACSHA384" />. La clave puede tener cualquier longitud. Sin embargo, el tamaño recomendado es de 128 bytes. Si la clave tiene más de 128 bytes se usará un algoritmo hash (SHA-384) para derivar una clave de 128 bytes. Si tiene menos de 128 bytes de longitud, se completa en 128 bytes.</param>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="key" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.Dispose(System.Boolean)">
      <param name="disposing" />
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.HashCore(System.Byte[],System.Int32,System.Int32)">
      <param name="rgb" />
      <param name="ib" />
      <param name="cb" />
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.HashCore(System.ReadOnlySpan{System.Byte})">
      <param name="source" />
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.HashFinal" />
    <member name="M:System.Security.Cryptography.HMACSHA384.Initialize" />
    <member name="P:System.Security.Cryptography.HMACSHA384.Key" />
    <member name="P:System.Security.Cryptography.HMACSHA384.ProduceLegacyHmacValues">
      <summary>Proporciona una solución alternativa para la implementación del algoritmo <see cref="T:System.Security.Cryptography.HMACSHA384" /> en .NET Framework 2.0, que es incoherente con la implementación del algoritmo en .NET Framework 2.0 Service Pack 1.</summary>
      <returns>Es <see langword="true" /> para permitir que las aplicaciones .NET Framework 2.0 Service Pack 1 interactúen con las aplicaciones .NET Framework 2.0; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <param name="destination" />
      <param name="bytesWritten" />
    </member>
    <member name="T:System.Security.Cryptography.HMACSHA512">
      <summary>Calcula un código de autenticación de mensajes basado en hash (HMAC) mediante la función hash <see cref="T:System.Security.Cryptography.SHA512" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.HMACSHA512" /> con una clave generada aleatoriamente.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.#ctor(System.Byte[])">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.HMACSHA512" /> con los datos de clave especificados.</summary>
      <param name="key">Clave secreta para el cifrado de <see cref="T:System.Security.Cryptography.HMACSHA512" />. La clave puede tener cualquier longitud. Sin embargo, el tamaño recomendado es de 128 bytes. Si la clave tiene más de 128 bytes, se usará un algoritmo hash (SHA-512) para derivar una clave de 128 bytes. Si tiene menos de 128 bytes de longitud, se completa en 128 bytes.</param>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="key" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.Dispose(System.Boolean)">
      <param name="disposing" />
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.HashCore(System.Byte[],System.Int32,System.Int32)">
      <param name="rgb" />
      <param name="ib" />
      <param name="cb" />
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.HashCore(System.ReadOnlySpan{System.Byte})">
      <param name="source" />
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.HashFinal" />
    <member name="M:System.Security.Cryptography.HMACSHA512.Initialize" />
    <member name="P:System.Security.Cryptography.HMACSHA512.Key" />
    <member name="P:System.Security.Cryptography.HMACSHA512.ProduceLegacyHmacValues">
      <summary>Proporciona una solución alternativa para la implementación del algoritmo <see cref="T:System.Security.Cryptography.HMACSHA512" /> en .NET Framework 2.0, que es incoherente con la implementación en .NET Framework 2.0 Service Pack 1.</summary>
      <returns>Es <see langword="true" /> para permitir que las aplicaciones .NET Framework 2.0 Service Pack 1 interactúen con las aplicaciones .NET Framework 2.0; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <param name="destination" />
      <param name="bytesWritten" />
    </member>
    <member name="T:System.Security.Cryptography.IncrementalHash">
      <summary>Proporciona compatibilidad para calcular un hash o un valor de código de autentificación de mensajes basado en hash (HMAC) incrementalmente a través de varios segmentos.</summary>
    </member>
    <member name="P:System.Security.Cryptography.IncrementalHash.AlgorithmName">
      <summary>Obtiene el nombre del algoritmo que se está realizando. Los algoritmos HMAC van precedidos de "HMAC" para distinguirlos de un resumen sin clave.</summary>
      <returns>Nombre del algoritmo que se está realizando.</returns>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[])">
      <summary>Anexa los datos especificados a los datos ya procesados en el hash o HMAC.</summary>
      <param name="data">Datos que se van a procesar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado el objeto <see cref="T:System.Security.Cryptography.IncrementalHash" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[],System.Int32,System.Int32)">
      <summary>Anexa el número especificado de bytes a partir de los datos especificados, comenzando en el desplazamiento especificado, a los datos ya procesados en el hash o en el código de autentificación de mensajes basado en hash (HMAC).</summary>
      <param name="data">Datos que se van a procesar.</param>
      <param name="offset">Desplazamiento en la matriz de bytes a partir del cual se empezarán a usar los datos.</param>
      <param name="count">Número de bytes que se va a usar desde <paramref name="data" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> o <paramref name="offset" /> es negativo.  
O bien 
 <paramref name="count" /> es mayor que la longitud de <paramref name="data" />.</exception>
      <exception cref="T:System.ArgumentException">La suma de <paramref name="offset" /> y <paramref name="count" /> es mayor que la longitud de los datos.</exception>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado el objeto <see cref="T:System.Security.Cryptography.IncrementalHash" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.AppendData(System.ReadOnlySpan{System.Byte})">
      <param name="data" />
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.CreateHash(System.Security.Cryptography.HashAlgorithmName)">
      <summary>Crea <see cref="T:System.Security.Cryptography.IncrementalHash" /> para el algoritmo especificado.</summary>
      <param name="hashAlgorithm">Nombre del algoritmo hash que se realizará.</param>
      <returns>Una instancia de <see cref="T:System.Security.Cryptography.IncrementalHash" /> preparada para calcular el algoritmo hash especificado por <paramref name="hashAlgorithm" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> es <see langword="null" /> o una cadena vacía.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="hashAlgorithm" /> no es un algoritmo hash conocido.</exception>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
      <summary>Crea un elemento <see cref="T:System.Security.Cryptography.IncrementalHash" /> para el algoritmo de código de autenticación de mensajes basado en Hash (HMAC) utilizando el algoritmo hash y la clave especificados.</summary>
      <param name="hashAlgorithm">Nombre del algoritmo hash que se realizará en el HMAC.</param>
      <param name="key">Clave secreta del HMAC. La clave puede tener cualquier longitud, pero se aplicará un hash a una clave mayor que el tamaño de salida del algoritmo hash especificado para derivar una clave de tamaño adecuado. Por lo tanto, el tamaño de la clave secreta recomendado es el tamaño de salida del algoritmo hash especificado.</param>
      <returns>Instancia de la clase <see cref="T:System.Security.Cryptography.IncrementalHash" /> lista para calcular el algoritmo hash especificado.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> es <see langword="null" /> o una cadena vacía.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="hashAlgorithm" /> no es un algoritmo hash conocido.</exception>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.Dispose">
      <summary>Libera los recursos utilizados por la instancia actual de la clase <see cref="T:System.Security.Cryptography.IncrementalHash" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.GetHashAndReset">
      <summary>Recupera el hash o el código de autentificación de mensajes basado en hash (HMAC) para los datos acumulados de llamadas anteriores al método <see cref="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[])" /> y restablece el objeto a su estado inicial.</summary>
      <returns>Hash o HMAC calculado.</returns>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado el objeto <see cref="T:System.Security.Cryptography.IncrementalHash" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.TryGetHashAndReset(System.Span{System.Byte},System.Int32@)">
      <param name="destination" />
      <param name="bytesWritten" />
    </member>
    <member name="T:System.Security.Cryptography.MaskGenerationMethod">
      <summary>Representa la clase abstracta de la que deben derivarse todos los algoritmos de generación de máscaras.</summary>
    </member>
    <member name="M:System.Security.Cryptography.MaskGenerationMethod.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.MaskGenerationMethod" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.MaskGenerationMethod.GenerateMask(System.Byte[],System.Int32)">
      <summary>Cuando se invalida en una clase derivada, genera una máscara con la longitud especificada utilizando el valor inicial aleatorio indicado.</summary>
      <param name="rgbSeed">Valor inicial aleatorio que se utiliza para calcular la máscara.</param>
      <param name="cbReturn">Longitud de la máscara generada en bytes.</param>
      <returns>Máscara generada aleatoriamente cuya longitud es igual que el parámetro <paramref name="cbReturn" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.MD5">
      <summary>Representa la clase abstracta desde la que se heredan todas las implementaciones del algoritmo hash <see cref="T:System.Security.Cryptography.MD5" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.MD5.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.MD5" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.MD5.Create">
      <summary>Crea una instancia de la implementación predeterminada del algoritmo hash <see cref="T:System.Security.Cryptography.MD5" />.</summary>
      <returns>Nueva instancia del algoritmo hash <see cref="T:System.Security.Cryptography.MD5" />.</returns>
      <exception cref="T:System.Reflection.TargetInvocationException">El algoritmo se usó con el modo FIPS (Estándar federal de procesamiento de información) habilitado, pero no es compatible con FIPS.</exception>
    </member>
    <member name="M:System.Security.Cryptography.MD5.Create(System.String)">
      <summary>Crea una instancia de la implementación especificada del algoritmo hash <see cref="T:System.Security.Cryptography.MD5" />.</summary>
      <param name="algName">Nombre de la implementación específica de <see cref="T:System.Security.Cryptography.MD5" /> que se va a utilizar.</param>
      <returns>Nueva instancia de la implementación especificada de <see cref="T:System.Security.Cryptography.MD5" />.</returns>
      <exception cref="T:System.Reflection.TargetInvocationException">Se utilizó el algoritmo descrito por el parámetro <paramref name="algName" /> con el modo FIPS (Estándar federal de procesamiento de información) habilitado, pero no es compatible con FIPS.</exception>
    </member>
    <member name="T:System.Security.Cryptography.PKCS1MaskGenerationMethod">
      <summary>Calcula las máscaras de acuerdo con PKCS #1 para usarse en los algoritmos de intercambio de claves.</summary>
    </member>
    <member name="M:System.Security.Cryptography.PKCS1MaskGenerationMethod.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.PKCS1MaskGenerationMethod" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.PKCS1MaskGenerationMethod.GenerateMask(System.Byte[],System.Int32)">
      <summary>Genera y devuelve una máscara a partir del valor inicial aleatorio especificado con la longitud indicada.</summary>
      <param name="rgbSeed">Valor inicial aleatorio que se utiliza para calcular la máscara.</param>
      <param name="cbReturn">Longitud de la máscara generada en bytes.</param>
      <returns>Máscara generada aleatoriamente cuya longitud es igual que el parámetro <paramref name="cbReturn" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.PKCS1MaskGenerationMethod.HashName">
      <summary>Obtiene o establece el nombre del tipo de algoritmo hash que se va a usar para generar la máscara.</summary>
      <returns>Nombre del tipo que implementa el algoritmo hash que se usará para calcular la máscara.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RandomNumberGenerator">
      <summary>Representa la clase abstracta de la que se derivan todas las implementaciones de los generadores de números aleatorios criptográficos.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.RandomNumberGenerator" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.Create">
      <summary>Crea una instancia de la implementación predeterminada de un generador de números aleatorios criptográficos que se puede usar para generar datos aleatorios.</summary>
      <returns>Nueva instancia de un generador de números aleatorios criptográficos.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.Create(System.String)">
      <summary>Crea una instancia de la implementación especificada de un generador de números aleatorios criptográficos.</summary>
      <param name="rngName">Nombre de la implementación del generador de números aleatorios que se va a usar.</param>
      <returns>Nueva instancia de un generador de números aleatorios criptográficos.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.Dispose">
      <summary>Cuando se reemplaza en una clase derivada, libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Security.Cryptography.RandomNumberGenerator" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.Dispose(System.Boolean)">
      <summary>Cuando se reemplaza en una clase derivada, libera los recursos no administrados usados por <see cref="T:System.Security.Cryptography.RandomNumberGenerator" /> y, de forma opcional, libera los recursos administrados.</summary>
      <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.Fill(System.Span{System.Byte})">
      <summary>Rellena un intervalo con bytes aleatorios criptográficamente seguros.</summary>
      <param name="data">Intervalo que se va a rellenar con bytes criptográficamente seguros.</param>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetBytes(System.Byte[])">
      <summary>Cuando se reemplaza en una clase derivada, rellena una matriz de bytes con una secuencia aleatoria de valores sólidamente cifrada.</summary>
      <param name="data">Matriz que se va a rellenar con los bytes aleatorios sólidamente cifrados.</param>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetBytes(System.Byte[],System.Int32,System.Int32)">
      <summary>Rellena la matriz de bytes especificada con una secuencia aleatoria de valores sólidamente cifrada.</summary>
      <param name="data">Matriz que se va a rellenar con los bytes aleatorios sólidamente cifrados.</param>
      <param name="offset">Índice de la matriz donde empezará la operación de relleno.</param>
      <param name="count">Número de bytes para rellenar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> o <paramref name="count" /> es menor que 0.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="offset" /> más <paramref name="count" /> supera la longitud de <paramref name="data" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetBytes(System.Span{System.Byte})">
      <summary>Rellena un intervalo con bytes aleatorios criptográficamente seguros.</summary>
      <param name="data">Intervalo que se va a rellenar con bytes criptográficamente seguros.</param>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetInt32(System.Int32)">
      <summary>Genera un entero aleatorio entre 0 (incluido) y un límite superior exclusivo especificado; para ello, usa un generador de números aleatorios criptográficamente seguro.</summary>
      <param name="toExclusive">Límite superior exclusivo del rango aleatorio.</param>
      <returns>Un entero aleatorio entre 0 (incluido) y <paramref name="toExclusive" /> (excluido).</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="toExclusive" /> es menor o igual que 0.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetInt32(System.Int32,System.Int32)">
      <summary>Genera un entero aleatorio entre un límite inferior inclusivo especificado y un límite superior exclusivo especificado mediante un generador de números aleatorios criptográficamente seguro.</summary>
      <param name="fromInclusive">Límite inferior inclusivo del rango aleatorio.</param>
      <param name="toExclusive">Límite superior exclusivo del rango aleatorio.</param>
      <returns>Un entero aleatorio entre <paramref name="fromInclusive" /> (incluido) y <paramref name="toExclusive" /> (excluido).</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="toExclusive" /> es menor o igual que el parámetro <paramref name="fromInclusive" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetNonZeroBytes(System.Byte[])">
      <summary>Cuando se reemplaza en una clase derivada, rellena una matriz de bytes con una secuencia aleatoria de valores distintos de cero sólidamente cifrada.</summary>
      <param name="data">Matriz que se va a rellenar con los bytes aleatorios sólidamente cifrados distintos de cero.</param>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetNonZeroBytes(System.Span{System.Byte})">
      <summary>Rellena un intervalo de bytes con una secuencia aleatoria criptográficamente segura de valores distintos de cero.</summary>
      <param name="data">Intervalo que se va a rellenar con bytes aleatorios criptográficamente seguros distintos de cero.</param>
    </member>
    <member name="T:System.Security.Cryptography.RC2">
      <summary>Representa la clase base de la que deben derivarse todas las implementaciones del algoritmo <see cref="T:System.Security.Cryptography.RC2" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RC2.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.RC2" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RC2.Create">
      <summary>Crea una instancia de un objeto criptográfico para realizar el algoritmo <see cref="T:System.Security.Cryptography.RC2" />.</summary>
      <returns>Una instancia de un objeto criptográfico.</returns>
      <exception cref="T:System.Reflection.TargetInvocationException">El algoritmo se usó con el modo FIPS (Estándar federal de procesamiento de información) habilitado, pero no es compatible con FIPS.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RC2.Create(System.String)">
      <summary>Crea una instancia de un objeto criptográfico para ejecutar la implementación especificada del algoritmo <see cref="T:System.Security.Cryptography.RC2" />.</summary>
      <param name="AlgName">Nombre de la implementación específica de <see cref="T:System.Security.Cryptography.RC2" /> que se va a utilizar.</param>
      <returns>Una instancia de un objeto criptográfico.</returns>
      <exception cref="T:System.Reflection.TargetInvocationException">Se utilizó el algoritmo descrito por el parámetro <paramref name="algName" /> con el modo FIPS (Estándar federal de procesamiento de información) habilitado, pero no es compatible con FIPS.</exception>
    </member>
    <member name="P:System.Security.Cryptography.RC2.EffectiveKeySize">
      <summary>Obtiene o establece el tamaño efectivo de la clave secreta utilizada por el algoritmo <see cref="T:System.Security.Cryptography.RC2" /> en bits.</summary>
      <returns>Tamaño efectivo de la clave utilizado por el algoritmo <see cref="T:System.Security.Cryptography.RC2" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El tamaño efectivo de la clave no es válido.</exception>
    </member>
    <member name="F:System.Security.Cryptography.RC2.EffectiveKeySizeValue">
      <summary>Representa el tamaño efectivo de la clave secreta utilizada por el algoritmo <see cref="T:System.Security.Cryptography.RC2" /> en bits.</summary>
    </member>
    <member name="P:System.Security.Cryptography.RC2.KeySize">
      <summary>Obtiene o establece el tamaño de la clave secreta utilizada por el algoritmo <see cref="T:System.Security.Cryptography.RC2" /> en bits.</summary>
      <returns>Tamaño de la clave secreta utilizada por el algoritmo <see cref="T:System.Security.Cryptography.RC2" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El valor del tamaño de clave de RC2 es menor que el valor del tamaño efectivo de la clave.</exception>
    </member>
    <member name="T:System.Security.Cryptography.Rfc2898DeriveBytes">
      <summary>Implementa PBKDF2 (función de derivación de claves basada en contraseña) utilizando un generador de números pseudoaleatorios basado en <see cref="T:System.Security.Cryptography.HMACSHA1" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> utilizando una contraseña, un valor salt y un número de iteraciones para derivar la clave.</summary>
      <param name="password">Contraseña utilizada para derivar la clave.</param>
      <param name="salt">Valor salt de clave que se utiliza para derivar la clave.</param>
      <param name="iterations">Número de iteraciones de la operación.</param>
      <exception cref="T:System.ArgumentException">El tamaño del valor salt especificado es menor que 8 bytes o el número de iteraciones es menor que 1.</exception>
      <exception cref="T:System.ArgumentNullException">La contraseña o el valor salt son <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> mediante la contraseña, el valor "salt", el número de iteraciones y el nombre del algoritmo hash especificados para derivar la clave.</summary>
      <param name="password">Contraseña que se va a usar para derivar la clave.</param>
      <param name="salt">Valor salt de clave que se va a utilizar para derivar la clave.</param>
      <param name="iterations">Número de iteraciones de la operación.</param>
      <param name="hashAlgorithm">Algoritmo hash que se va a utilizar para derivar la clave.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="saltSize" /> es menor que cero.</exception>
      <exception cref="T:System.ArgumentException">La propiedad <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> de <paramref name="hashAlgorithm" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El nombre del algoritmo hash no es válido.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> utilizando una contraseña y un valor salt para derivar la clave.</summary>
      <param name="password">Contraseña utilizada para derivar la clave.</param>
      <param name="salt">Valor salt de clave que se utiliza para derivar la clave.</param>
      <exception cref="T:System.ArgumentException">El tamaño del valor salt especificado es menor que 8 bytes o el número de iteraciones es menor que 1.</exception>
      <exception cref="T:System.ArgumentNullException">La contraseña o el valor salt son <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> utilizando una contraseña, un valor salt y un número de iteraciones para derivar la clave.</summary>
      <param name="password">Contraseña utilizada para derivar la clave.</param>
      <param name="salt">Valor salt de clave que se utiliza para derivar la clave.</param>
      <param name="iterations">Número de iteraciones de la operación.</param>
      <exception cref="T:System.ArgumentException">El tamaño del valor salt especificado es menor que 8 bytes o el número de iteraciones es menor que 1.</exception>
      <exception cref="T:System.ArgumentNullException">La contraseña o el valor salt son <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> mediante la contraseña, el valor "salt", el número de iteraciones y el nombre del algoritmo hash especificados para derivar la clave.</summary>
      <param name="password">Contraseña que se va a usar para derivar la clave.</param>
      <param name="salt">Valor salt de clave que se va a utilizar para derivar la clave.</param>
      <param name="iterations">Número de iteraciones de la operación.</param>
      <param name="hashAlgorithm">Algoritmo hash que se va a utilizar para derivar la clave.</param>
      <exception cref="T:System.ArgumentException">La propiedad <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> de <paramref name="hashAlgorithm" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El nombre del algoritmo hash no es válido.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> utilizando la contraseña y el tamaño del valor salt para derivar la clave.</summary>
      <param name="password">Contraseña utilizada para derivar la clave.</param>
      <param name="saltSize">Tamaño del valor salt aleatorio que se desea que la clase genere.</param>
      <exception cref="T:System.ArgumentException">El tamaño del valor salt especificado es menor que 8 bytes.</exception>
      <exception cref="T:System.ArgumentNullException">La contraseña o el valor salt son <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> utilizando una contraseña, un tamaño de valor salt y un número de iteraciones para derivar la clave.</summary>
      <param name="password">Contraseña utilizada para derivar la clave.</param>
      <param name="saltSize">Tamaño del valor salt aleatorio que se desea que la clase genere.</param>
      <param name="iterations">Número de iteraciones de la operación.</param>
      <exception cref="T:System.ArgumentException">El tamaño del valor salt especificado es menor que 8 bytes o el número de iteraciones es menor que 1.</exception>
      <exception cref="T:System.ArgumentNullException">La contraseña o el valor salt son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="iterations" /> está fuera del intervalo. Este parámetro requiere un número no negativo.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> mediante la contraseña, el tamaño del valor "salt", el número de iteraciones y el nombre del algoritmo hash especificados para derivar la clave.</summary>
      <param name="password">Contraseña que se va a usar para derivar la clave.</param>
      <param name="saltSize">Tamaño del valor salt aleatorio que se desea que la clase genere.</param>
      <param name="iterations">Número de iteraciones de la operación.</param>
      <param name="hashAlgorithm">Algoritmo hash que se va a utilizar para derivar la clave.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="saltSize" /> es menor que cero.</exception>
      <exception cref="T:System.ArgumentException">La propiedad <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> de <paramref name="hashAlgorithm" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El nombre del algoritmo hash no es válido.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
      <summary>Deriva una clave criptográfica a partir del objeto <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />.</summary>
      <param name="algname">Nombre del algoritmo para el que se va a derivar la clave.</param>
      <param name="alghashname">Nombre del algoritmo hash que se va a utilizar para derivar la clave.</param>
      <param name="keySize">Tamaño de la clave, en bits, que se va a derivar.</param>
      <param name="rgbIV">Vector de inicialización (IV) que se va a utilizar para derivar la clave.</param>
      <returns>Clave derivada.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El parámetro <paramref name="keySize" /> no es correcto.  
o bien 
No se puede adquirir el proveedor de servicios criptográficos (CSP).  
o bien 
El parámetro <paramref name="algname" /> no es un nombre de algoritmo válido.  
o bien 
El parámetro <paramref name="alghashname" /> no es un nombre de algoritmo hash válido.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)">
      <summary>Libera los recursos no administrados utilizados por la clase <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> y, de forma opcional, libera los recursos administrados.</summary>
      <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)">
      <summary>Devuelve la clave pseudoaleatoria para este objeto.</summary>
      <param name="cb">Número de bytes de clave pseudoaleatorios que se van a generar.</param>
      <returns>Matriz de bytes rellena de bytes de clave pseudoaleatorios.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="cb" /> está fuera del intervalo. Este parámetro requiere un número no negativo.</exception>
    </member>
    <member name="P:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm" />
    <member name="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount">
      <summary>Obtiene o establece el número de iteraciones de la operación.</summary>
      <returns>Número de iteraciones de la operación.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">El número de iteraciones es menor que 1.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.Reset">
      <summary>Restablece el estado de la operación.</summary>
    </member>
    <member name="P:System.Security.Cryptography.Rfc2898DeriveBytes.Salt">
      <summary>Obtiene o establece el valor salt de clave de la operación.</summary>
      <returns>Valor salt de clave de la operación.</returns>
      <exception cref="T:System.ArgumentException">El tamaño del valor salt especificado es menor que 8 bytes.</exception>
      <exception cref="T:System.ArgumentNullException">El valor salt es <see langword="null" />.</exception>
    </member>
    <member name="T:System.Security.Cryptography.Rijndael">
      <summary>Representa la clase base de la que deben heredarse todas las implementaciones del algoritmo de cifrado simétrico <see cref="T:System.Security.Cryptography.Rijndael" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.Rijndael.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.Rijndael" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.Rijndael.Create">
      <summary>Crea un objeto criptográfico para realizar el algoritmo <see cref="T:System.Security.Cryptography.Rijndael" />.</summary>
      <returns>Objeto criptográfico.</returns>
      <exception cref="T:System.Reflection.TargetInvocationException">El algoritmo se usó con el modo FIPS (Estándar federal de procesamiento de información) habilitado, pero no es compatible con FIPS.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rijndael.Create(System.String)">
      <summary>Crea un objeto criptográfico para ejecutar la implementación especificada del algoritmo <see cref="T:System.Security.Cryptography.Rijndael" />.</summary>
      <param name="algName">Nombre de la implementación específica de <see cref="T:System.Security.Cryptography.Rijndael" /> que se va a crear.</param>
      <returns>Objeto criptográfico.</returns>
      <exception cref="T:System.Reflection.TargetInvocationException">Se utilizó el algoritmo descrito por el parámetro <paramref name="algName" /> con el modo FIPS (Estándar federal de procesamiento de información) habilitado, pero no es compatible con FIPS.</exception>
    </member>
    <member name="T:System.Security.Cryptography.RijndaelManaged">
      <summary>Tiene acceso a la versión administrada del algoritmo <see cref="T:System.Security.Cryptography.Rijndael" />. Esta clase no puede heredarse.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RijndaelManaged.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.RijndaelManaged" />.</summary>
      <exception cref="T:System.InvalidOperationException">Esta clase no es compatible con el algoritmo FIPS.</exception>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.BlockSize">
      <summary>Obtiene o establece el tamaño del bloque de la operación criptográfica en bits.</summary>
      <returns>Tamaño de bloque, en bits, de la operación criptográfica. El valor predeterminado es 128 bits.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RijndaelManaged.CreateDecryptor" />
    <member name="M:System.Security.Cryptography.RijndaelManaged.CreateDecryptor(System.Byte[],System.Byte[])">
      <summary>Crea un objeto descifrador <see cref="T:System.Security.Cryptography.Rijndael" /> simétrico con la <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key" /> y el vector de inicialización (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />) especificados.</summary>
      <param name="rgbKey">Clave secreta que se va a utilizar para el algoritmo simétrico. El tamaño de clave debe ser de 128, 192 o 256 bits.</param>
      <param name="rgbIV">Vector de inicialización que se va a utilizar para el algoritmo simétrico.</param>
      <returns>Objeto descifrador <see cref="T:System.Security.Cryptography.Rijndael" /> simétrico.</returns>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="rgbKey" /> es <see langword="null" />.  
o bien 
El parámetro <paramref name="rgbIV" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El valor de la propiedad <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Mode" /> no es <see cref="F:System.Security.Cryptography.CipherMode.ECB" />, <see cref="F:System.Security.Cryptography.CipherMode.CBC" /> o <see cref="F:System.Security.Cryptography.CipherMode.CFB" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RijndaelManaged.CreateEncryptor" />
    <member name="M:System.Security.Cryptography.RijndaelManaged.CreateEncryptor(System.Byte[],System.Byte[])">
      <summary>Crea un objeto cifrador <see cref="T:System.Security.Cryptography.Rijndael" /> simétrico con la <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key" /> y el vector de inicialización especificados (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />).</summary>
      <param name="rgbKey">Clave secreta que se va a utilizar para el algoritmo simétrico. El tamaño de clave debe ser de 128, 192 o 256 bits.</param>
      <param name="rgbIV">Vector de inicialización que se va a utilizar para el algoritmo simétrico.</param>
      <returns>Objeto cifrador <see cref="T:System.Security.Cryptography.Rijndael" /> simétrico.</returns>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="rgbKey" /> es <see langword="null" />.  
O bien 
El parámetro <paramref name="rgbIV" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El valor de la propiedad <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Mode" /> no es <see cref="F:System.Security.Cryptography.CipherMode.ECB" />, <see cref="F:System.Security.Cryptography.CipherMode.CBC" /> o <see cref="F:System.Security.Cryptography.CipherMode.CFB" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RijndaelManaged.GenerateIV">
      <summary>Genera un vector de inicialización aleatorio (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />) que se va a utilizar para el algoritmo.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RijndaelManaged.GenerateKey">
      <summary>Genera una propiedad <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key" /> aleatoria que se va a utilizar para el algoritmo.</summary>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.IV">
      <summary>Obtiene o establece el vector de inicialización (IV) para el algoritmo simétrico.</summary>
      <returns>Vector de inicialización (IV) que se va a usar para el algoritmo simétrico.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.Key">
      <summary>Obtiene o establece la clave secreta utilizada para el algoritmo simétrico.</summary>
      <returns>Clave secreta utilizada para el algoritmo simétrico.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.KeySize">
      <summary>Obtiene o establece el tamaño de la clave secreta utilizada para el algoritmo simétrico, en bits.</summary>
      <returns>Tamaño, en bits, de la clave secreta utilizada para el algoritmo simétrico. El valor predeterminado es 256 bits.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.LegalKeySizes">
      <summary>Obtiene los tamaños de clave, en bits, admitidos por el algoritmo simétrico.</summary>
      <returns>Los tamaños de clave, en bits, admitidos por el algoritmo simétrico.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.Mode">
      <summary>Obtiene o establece el modo de funcionamiento del algoritmo simétrico.</summary>
      <returns>Modo de funcionamiento del algoritmo simétrico. De manera predeterminada, <see cref="F:System.Security.Cryptography.CipherMode.CBC" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.Padding">
      <summary>Obtiene o establece el modo de relleno utilizado en el algoritmo simétrico.</summary>
      <returns>Modo de relleno utilizado en el algoritmo simétrico. De manera predeterminada, es <see cref="F:System.Security.Cryptography.PaddingMode.PKCS7" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RSA">
      <summary>Representa la clase base de la que se heredan todas las implementaciones del algoritmo <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSA.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSA.Create">
      <summary>Crea una instancia de la implementación predeterminada del algoritmo <see cref="T:System.Security.Cryptography.RSA" />.</summary>
      <returns>Nueva instancia de la implementación predeterminada de <see cref="T:System.Security.Cryptography.RSA" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.Create(System.Int32)">
      <summary>Crea una clave RSA efímera con el tamaño de clave especificado.</summary>
      <param name="keySizeInBits">Tamaño de la clave (en bits).</param>
      <returns>Clave RSA efímera con el tamaño de clave especificado.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="keySizeInBits" /> es diferente de <see cref="P:System.Security.Cryptography.AsymmetricAlgorithm.KeySize" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.Create(System.Security.Cryptography.RSAParameters)">
      <summary>Crea una clave RSA efímera con los parámetros de clave RSA especificados.</summary>
      <param name="parameters">Parámetros del algoritmo <see cref="T:System.Security.Cryptography.RSA" />.</param>
      <returns>Nueva clave RSA efímera.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.Create(System.String)">
      <summary>Crea una instancia de la implementación de <see cref="T:System.Security.Cryptography.RSA" /> especificada.</summary>
      <param name="algName">Nombre de la implementación de <see cref="T:System.Security.Cryptography.RSA" /> que se va a usar.</param>
      <returns>Nueva instancia de la implementación especificada de <see cref="T:System.Security.Cryptography.RSA" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.Decrypt(System.Byte[],System.Security.Cryptography.RSAEncryptionPadding)">
      <summary>Cuando se reemplaza en una clase derivada, descifra los datos de entrada usando el modo de relleno especificado.</summary>
      <param name="data">Datos que se van a descifrar.</param>
      <param name="padding">Modo de relleno.</param>
      <returns>Datos descifrados.</returns>
      <exception cref="T:System.NotImplementedException">Una clase derivada debe reemplazar este método.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.DecryptValue(System.Byte[])">
      <summary>Cuando se invalida en una clase derivada, descifra los datos de entrada con la clave privada.</summary>
      <param name="rgb">Texto de cifrado que se va a descifrar.</param>
      <returns>Descifrado resultante del parámetro <paramref name="rgb" /> en texto sin formato.</returns>
      <exception cref="T:System.NotSupportedException">No se admite esta llamada al método. Esta excepción se produce a partir de .NET Framework 4.6.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.Encrypt(System.Byte[],System.Security.Cryptography.RSAEncryptionPadding)">
      <summary>Cuando se reemplaza en una clase derivada, cifra los datos de entrada usando el modo de relleno especificado.</summary>
      <param name="data">Datos que se van a cifrar.</param>
      <param name="padding">Modo de relleno.</param>
      <returns>Datos cifrados.</returns>
      <exception cref="T:System.NotImplementedException">Una clase derivada debe reemplazar este método.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.EncryptValue(System.Byte[])">
      <summary>Cuando se invalida en una clase derivada, cifra los datos de entrada usando la clave pública.</summary>
      <param name="rgb">Texto sin formato que se va a cifrar.</param>
      <returns>Cifrado resultante del parámetro <paramref name="rgb" /> como texto cifrado.</returns>
      <exception cref="T:System.NotSupportedException">No se admite esta llamada al método. Esta excepción se produce a partir de .NET Framework 4.6.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ExportParameters(System.Boolean)">
      <summary>Cuando se invalida en una clase derivada, exporta el <see cref="T:System.Security.Cryptography.RSAParameters" />.</summary>
      <param name="includePrivateParameters">Es <see langword="true" /> si se van a incluir parámetros privados; en caso contrario, es <see langword="false" />.</param>
      <returns>Parámetros de <see cref="T:System.Security.Cryptography.RSA" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ExportRSAPrivateKey">
      <summary>Exporta la clave actual en el formato RSAPrivateKey de PKCS#1.</summary>
      <returns>Matriz de bytes que contiene la representación RSAPrivateKey de PKCS#1 de esta clave.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido exportar la clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ExportRSAPublicKey">
      <summary>Exporta la parte de la clave pública de la clave actual en el formato RSAPublicKey de PKCS#1.</summary>
      <returns>Matriz de bytes que contiene la representación RSAPublicKey de PKCS#1 de esta clave.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.FromXmlString(System.String)">
      <summary>Inicializa un objeto <see cref="T:System.Security.Cryptography.RSA" /> de la información de clave de una cadena XML.</summary>
      <param name="xmlString">Cadena XML que contiene la información de clave <see cref="T:System.Security.Cryptography.RSA" />.</param>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="xmlString" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El formato del parámetro <paramref name="xmlString" /> no es válido.</exception>
      <exception cref="T:System.PlatformNotSupportedException">Solo .NET Core: Este miembro no se admite.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.HashData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Cuando se reemplaza en una clase derivada, calcula el valor hash de una parte especificada de una matriz de bytes usando un algoritmo hash especificado.</summary>
      <param name="data">Datos a los que se va a aplicar un algoritmo hash.</param>
      <param name="offset">Índice del primer byte de <paramref name="data" /> al que se va a aplicar un algoritmo hash.</param>
      <param name="count">Número de bytes a los que se va a aplicar un algoritmo hash.</param>
      <param name="hashAlgorithm">Algoritmo que se va a usar para aplicar un algoritmo hash a los datos.</param>
      <returns>Datos a los que se aplicó un algoritmo hash.</returns>
      <exception cref="T:System.NotImplementedException">Una clase derivada debe reemplazar este método.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.HashData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Cuando se reemplaza en una clase derivada, calcula el valor hash de una secuencia binaria especificada usando un algoritmo hash especificado.</summary>
      <param name="data">Secuencia binaria a la que se va a aplicar un algoritmo hash.</param>
      <param name="hashAlgorithm">Algoritmo hash.</param>
      <returns>Datos a los que se aplicó un algoritmo hash.</returns>
      <exception cref="T:System.NotImplementedException">Una clase derivada debe reemplazar este método.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importa el par de claves pública/privada desde una estructura EncryptedPrivateKeyInfo de PKCS#8 después de descifrar con una contraseña basada en bytes, reemplazando las claves de este objeto.</summary>
      <param name="passwordBytes">Bytes que se van a usar como contraseña al descifrar el material de clave.</param>
      <param name="source">Bytes de una estructura EncryptedPrivateKeyInfo de PKCS#8 en la codificación ASN.1-BER.</param>
      <param name="bytesRead">El resultado que devuelve este método contiene un valor que indica el número de bytes leídos de <paramref name="source" />. Este parámetro se trata como sin inicializar.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La contraseña es incorrecta.
O bien
El contenido de <paramref name="source" /> indica que la función de derivación de claves (KDF) que se va a aplicar es la heredada de PKCS#12, que requiere contraseñas basadas en <see cref="T:System.Char" />.
O bien
El contenido de <paramref name="source" /> no representa una estructura EncryptedPrivateKeyInfo de PKCS#8 codificada con ASN.1-BER.
o bien
El contenido de <paramref name="source" /> indica que la clave es para un algoritmo distinto del algoritmo que representa esta instancia.
o bien
El contenido de <paramref name="source" /> representa la clave en un formato que no se admite.
o bien
No se ha podido importar la clave específica del algoritmo.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importa el par de claves pública/privada desde una estructura EncryptedPrivateKeyInfo de PKCS#8 después de descifrar con una contraseña basada en caracteres, reemplazando las claves de este objeto.</summary>
      <param name="password">Contraseña que se va a usar para descifrar el material de clave.</param>
      <param name="source">Bytes de una estructura EncryptedPrivateKeyInfo de PKCS#8 en la codificación ASN.1-BER.</param>
      <param name="bytesRead">El resultado que devuelve este método contiene un valor que indica el número de bytes leídos de <paramref name="source" />. Este parámetro se trata como sin inicializar.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">La contraseña es incorrecta.
O bien
El contenido de <paramref name="source" /> no representa una estructura EncryptedPrivateKeyInfo de PKCS#8 codificada con ASN.1-BER.
o bien
El contenido de <paramref name="source" /> indica que la clave es para un algoritmo distinto del algoritmo que representa esta instancia.
O bien
El contenido de <paramref name="source" /> representa la clave en un formato que no se admite.
O bien
No se ha podido importar la clave específica del algoritmo.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportParameters(System.Security.Cryptography.RSAParameters)">
      <summary>Cuando se invalida en una clase derivada, importa el objeto <see cref="T:System.Security.Cryptography.RSAParameters" /> especificado.</summary>
      <param name="parameters">Parámetros de <see cref="T:System.Security.Cryptography.RSA" />.</param>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importa el par de claves pública/privada desde una estructura PrivateKeyInfo de PKCS#8 después del descifrado, reemplazando las claves de este objeto.</summary>
      <param name="source">Bytes de una estructura PrivateKeyInfo de PKCS#8 en la codificación ASN.1-BER.</param>
      <param name="bytesRead">El resultado que devuelve este método contiene un valor que indica el número de bytes leídos de <paramref name="source" />. Este parámetro se trata como sin inicializar.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El contenido de <paramref name="source" /> no representa una estructura PrivateKeyInfo de PKCS#8 codificada con ASN.1-BER.
O bien
El contenido de <paramref name="source" /> indica que la clave es para un algoritmo distinto del algoritmo que representa esta instancia.
O bien
El contenido de <paramref name="source" /> representa la clave en un formato que no se admite.
o bien
No se ha podido importar la clave específica del algoritmo.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportRSAPrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importa el par de claves pública/privada desde una estructura RSAPrivateKey de PKCS#1 después del descifrado, reemplazando las claves de este objeto.</summary>
      <param name="source">Bytes de una estructura RSAPrivateKey de PKCS#1 en la codificación ASN.1-BER.</param>
      <param name="bytesRead">El resultado que devuelve este método contiene un valor que indica el número de bytes leídos de <paramref name="source" />. Este parámetro se trata como sin inicializar.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El contenido de <paramref name="source" /> no representa una estructura RSAPrivateKey de PKCS#1 codificada con ASN.1-BER.
O bien
No se puede importar la clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportRSAPublicKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importa la clave pública desde una estructura RSAPublicKey de PKCS#1 después del descifrado, reemplazando las claves de este objeto.</summary>
      <param name="source">Bytes de una estructura RSAPublicKey de PKCS#1 en la codificación ASN.1-BER.</param>
      <param name="bytesRead">El resultado que devuelve este método contiene un valor que indica el número de bytes leídos de <paramref name="source" />. Este parámetro se trata como sin inicializar.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El contenido de <paramref name="source" /> no representa una estructura RSAPublicKey de PKCS#1 codificada con ASN.1-BER.
o bien
No se puede importar la clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportSubjectPublicKeyInfo(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importa la clave pública desde una estructura SubjectPublicKeyInfo de X.509 después del descifrado, reemplazando las claves de este objeto.</summary>
      <param name="source">Bytes de una estructura SubjectPublicKeyInfo de X.509 en la codificación ASN.1-DER.</param>
      <param name="bytesRead">El resultado que devuelve este método contiene un valor que indica el número de bytes leídos de <paramref name="source" />. Este parámetro se trata como sin inicializar.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El contenido de <paramref name="source" /> no representa una estructura SubjectPublicKeyInfo de X.509 codificada con ASN.1-DER.
O bien
El contenido de <paramref name="source" /> indica que la clave es para un algoritmo distinto del algoritmo que representa esta instancia.
O bien
El contenido de <paramref name="source" /> representa la clave en un formato que no se admite.
O bien
No se ha podido importar la clave específica del algoritmo.</exception>
    </member>
    <member name="P:System.Security.Cryptography.RSA.KeyExchangeAlgorithm">
      <summary>Obtiene el nombre del algoritmo de intercambio de claves disponible con esta implementación de <see cref="T:System.Security.Cryptography.RSA" />.</summary>
      <returns>Devuelve "RSA".</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSA.SignatureAlgorithm">
      <summary>Obtiene el nombre del algoritmo de firma disponible con esta implementación de <see cref="T:System.Security.Cryptography.RSA" />.</summary>
      <returns>Devuelve "RSA".</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.SignData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Calcula el valor hash de una parte de la matriz de bytes especificada usando el algoritmo hash y el modo de relleno especificados y firma el valor hash resultante.</summary>
      <param name="data">Datos de entrada para los que se va a calcular el hash.</param>
      <param name="offset">Desplazamiento en la matriz en el que se empezarán a usar los datos.</param>
      <param name="count">Número de bytes de la matriz que se van a usar como datos.</param>
      <param name="hashAlgorithm">Algoritmo hash que se va a usar para crear el valor hash.</param>
      <param name="padding">Modo de relleno.</param>
      <returns>Firma RSA de los datos especificados.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> es <see langword="null" />.  
o bien 
 <paramref name="padding" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> es menor que cero.  
O bien 
 <paramref name="count" /> es menor que cero.  
O bien 
 <paramref name="offset" /> + <paramref name="count" /> - 1 produce un índice que supera el límite superior de <paramref name="data" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.SignData(System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Calcula el valor hash de la matriz de bytes especificada usando el algoritmo hash y el modo de relleno especificados y firma el valor hash resultante.</summary>
      <param name="data">Datos de entrada para los que se va a calcular el hash.</param>
      <param name="hashAlgorithm">Algoritmo hash que se va a usar para crear el valor hash.</param>
      <param name="padding">Modo de relleno.</param>
      <returns>Firma RSA de los datos especificados.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> es <see langword="null" />.  
O bien 
 <paramref name="padding" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.SignData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Calcula el valor hash de la secuencia especificada usando el algoritmo hash y el modo de relleno especificados y firma el valor hash resultante.</summary>
      <param name="data">Secuencia de entrada para la que se va a calcular el hash.</param>
      <param name="hashAlgorithm">Algoritmo hash que se va a usar para crear el valor hash.</param>
      <param name="padding">Modo de relleno.</param>
      <returns>Firma RSA de los datos especificados.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> es <see langword="null" />.  
O bien 
 <paramref name="padding" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.SignHash(System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Cuando se reemplaza en una clase derivada, calcula la firma del valor hash especificado cifrándolo con la clave privada mediante el relleno especificado.</summary>
      <param name="hash">Valor hash de los datos que se van a firmar.</param>
      <param name="hashAlgorithm">Algoritmo hash usado para crear el valor hash de los datos.</param>
      <param name="padding">Relleno.</param>
      <returns>Firma RSA del valor hash especificado.</returns>
      <exception cref="T:System.NotImplementedException">Una clase derivada debe reemplazar este método.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ToXmlString(System.Boolean)">
      <summary>Crea y devuelve una cadena XML que contiene la clave del objeto <see cref="T:System.Security.Cryptography.RSA" /> actual.</summary>
      <param name="includePrivateParameters">
        <see langword="true" /> para incluir una clave RSA pública y privada; <see langword="false" /> para incluir únicamente la clave pública.</param>
      <returns>Cadena XML que contiene la clave del objeto <see cref="T:System.Security.Cryptography.RSA" /> actual.</returns>
      <exception cref="T:System.PlatformNotSupportedException">Solo .NET Core: Este miembro no se admite.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryDecrypt(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.RSAEncryptionPadding,System.Int32@)">
      <param name="data" />
      <param name="destination" />
      <param name="padding" />
      <param name="bytesWritten" />
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryEncrypt(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.RSAEncryptionPadding,System.Int32@)">
      <param name="data" />
      <param name="destination" />
      <param name="padding" />
      <param name="bytesWritten" />
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Intenta exportar la clave actual en el formato EncryptedPrivateKeyInfo de PKCS#8 a un búfer proporcionado, utilizando una contraseña basada en bytes.</summary>
      <param name="passwordBytes">Bytes que se van a usar como contraseña al cifrar el material de clave.</param>
      <param name="pbeParameters">Parámetros de cifrado basados en contraseña (PBE) que se van a usar al cifrar el material de clave.</param>
      <param name="destination">Intervalo de bytes que va a recibir los datos de EncryptedPrivateKeyInfo de PKCS#8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene un valor que indica el número de bytes escritos en <paramref name="destination" />. Este parámetro se trata como sin inicializar.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> es lo suficientemente grande como para recibir la salida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido exportar la clave.
o bien
<paramref name="pbeParameters" /> indica que debe usarse <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" />, el cual requiere contraseñas basadas en <see cref="T:System.Char" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Intenta exportar la clave actual en el formato EncryptedPrivateKeyInfo de PKCS#8 a un búfer proporcionado, utilizando una contraseña basada en caracteres.</summary>
      <param name="password">Contraseña que se va a usar al cifrar el material de clave.</param>
      <param name="pbeParameters">Parámetros de cifrado basados en contraseña (PBE) que se van a usar al cifrar el material de clave.</param>
      <param name="destination">Intervalo de bytes que va a recibir los datos de EncryptedPrivateKeyInfo de PKCS#8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene un valor que indica el número de bytes escritos en <paramref name="destination" />. Este parámetro se trata como sin inicializar.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> es lo suficientemente grande como para recibir la salida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido exportar la clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryExportPkcs8PrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Intenta exportar la clave actual en el formato PrivateKeyInfo de PKCS#8 a un búfer proporcionado.</summary>
      <param name="destination">Intervalo de bytes que va a recibir los datos de PrivateKeyInfo de PKCS#8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene un valor que indica el número de bytes escritos en <paramref name="destination" />. Este parámetro se trata como sin inicializar.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> es lo suficientemente grande como para recibir la salida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido exportar la clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryExportRSAPrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Intenta exportar la clave actual en el formato RSAPrivateKey de PKCS#1 a un búfer proporcionado.</summary>
      <param name="destination">Intervalo de bytes que va a recibir los datos de RSAPrivateKey de PKCS#1.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene un valor que indica el número de bytes escritos en <paramref name="destination" />. Este parámetro se trata como sin inicializar.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> es lo suficientemente grande como para recibir la salida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido exportar la clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryExportRSAPublicKey(System.Span{System.Byte},System.Int32@)">
      <summary>Intenta exportar la clave actual en el formato RSAPublicKey de PKCS#1 a un búfer proporcionado.</summary>
      <param name="destination">Intervalo de bytes que va a recibir los datos de RSAPublicKey de PKCS#1.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene un valor que indica el número de bytes escritos en <paramref name="destination" />. Este parámetro se trata como sin inicializar.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> es lo suficientemente grande como para recibir la salida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido exportar la clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryExportSubjectPublicKeyInfo(System.Span{System.Byte},System.Int32@)">
      <summary>Intenta exportar la clave actual en el formato SubjectPublicKeyInfo de X.509 a un búfer proporcionado.</summary>
      <param name="destination">Intervalo de bytes que va a recibir los datos de SubjectPublicKeyInfo de X.509.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene un valor que indica el número de bytes escritos en <paramref name="destination" />. Este parámetro se trata como sin inicializar.</param>
      <returns>
        <see langword="true" /> si <paramref name="destination" /> es lo suficientemente grande como para recibir la salida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">No se ha podido exportar la clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryHashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Int32@)">
      <param name="data" />
      <param name="destination" />
      <param name="hashAlgorithm" />
      <param name="bytesWritten" />
    </member>
    <member name="M:System.Security.Cryptography.RSA.TrySignData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding,System.Int32@)">
      <param name="data" />
      <param name="destination" />
      <param name="hashAlgorithm" />
      <param name="padding" />
      <param name="bytesWritten" />
    </member>
    <member name="M:System.Security.Cryptography.RSA.TrySignHash(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding,System.Int32@)">
      <param name="hash" />
      <param name="destination" />
      <param name="hashAlgorithm" />
      <param name="padding" />
      <param name="bytesWritten" />
    </member>
    <member name="M:System.Security.Cryptography.RSA.VerifyData(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Comprueba si una firma digital es válida calculando el valor hash de los datos especificados, para lo que usa el algoritmo hash y el relleno especificados y lo compara con la firma proporcionada.</summary>
      <param name="data">Datos firmados.</param>
      <param name="signature">Datos de la firma que se van a comprobar.</param>
      <param name="hashAlgorithm">Algoritmo hash usado para crear el valor hash de los datos.</param>
      <param name="padding">Modo de relleno.</param>
      <returns>
        <see langword="true" /> si la firma es válida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> es <see langword="null" />.  
O bien 
 <paramref name="signature" /> es <see langword="null" />.  
O bien 
 <paramref name="padding" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.VerifyData(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Comprueba si una firma digital es válida calculando el valor hash de los datos de una parte de una matriz de bytes, para lo que usa el algoritmo hash y el relleno especificados y lo compara con la firma proporcionada.</summary>
      <param name="data">Datos firmados.</param>
      <param name="offset">Índice inicial en el que se va a calcular el hash.</param>
      <param name="count">Número de bytes a los que se va a aplicar un algoritmo hash.</param>
      <param name="signature">Datos de la firma que se van a comprobar.</param>
      <param name="hashAlgorithm">Algoritmo hash usado para crear el valor hash de los datos.</param>
      <param name="padding">Modo de relleno.</param>
      <returns>
        <see langword="true" /> si la firma es válida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> es <see langword="null" />.  
O bien 
 <paramref name="signature" /> es <see langword="null" />.  
o bien 
 <paramref name="padding" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> es menor que cero.  
O bien 
 <paramref name="count" /> es menor que cero.  
o bien 
 <paramref name="offset" /> + <paramref name="count" /> - 1 produce un índice que supera el límite superior de <paramref name="data" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.VerifyData(System.IO.Stream,System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Comprueba si una firma digital es válida calculando el valor hash de la secuencia especificada, para lo que usa el algoritmo hash y el relleno especificados y lo compara con la firma proporcionada.</summary>
      <param name="data">Datos firmados.</param>
      <param name="signature">Datos de la firma que se van a comprobar.</param>
      <param name="hashAlgorithm">Algoritmo hash usado para crear el valor hash de los datos.</param>
      <param name="padding">Modo de relleno.</param>
      <returns>
        <see langword="true" /> si la firma es válida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> es <see langword="null" />.  
O bien 
 <paramref name="signature" /> es <see langword="null" />.  
o bien 
 <paramref name="padding" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.VerifyData(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <param name="data" />
      <param name="signature" />
      <param name="hashAlgorithm" />
      <param name="padding" />
    </member>
    <member name="M:System.Security.Cryptography.RSA.VerifyHash(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Comprueba si una firma digital es válida determinando el valor hash de la firma, para lo que usa el algoritmo hash especificado y el relleno, y lo compara con el valor hash proporcionado.</summary>
      <param name="hash">Valor hash de los datos firmados.</param>
      <param name="signature">Datos de la firma que se van a comprobar.</param>
      <param name="hashAlgorithm">Algoritmo hash usado para crear el valor hash.</param>
      <param name="padding">Modo de relleno.</param>
      <returns>
        <see langword="true" /> si la firma es válida; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.NotImplementedException">Una clase derivada debe reemplazar este método.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.VerifyHash(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <param name="hash" />
      <param name="signature" />
      <param name="hashAlgorithm" />
      <param name="padding" />
    </member>
    <member name="T:System.Security.Cryptography.RSAEncryptionPadding">
      <summary>Especifica el modo de relleno y los parámetros que se van a usar con operaciones de cifrado o descifrado RSA.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.CreateOaep(System.Security.Cryptography.HashAlgorithmName)">
      <summary>Crea una instancia de <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" /> cuyo <see cref="P:System.Security.Cryptography.RSAEncryptionPadding.Mode" /> es <see cref="F:System.Security.Cryptography.RSAEncryptionPaddingMode.Oaep" /> con el algoritmo hash especificado.</summary>
      <param name="hashAlgorithm">Algoritmo hash.</param>
      <returns>Objeto cuyo modo <see cref="P:System.Security.Cryptography.RSAEncryptionPadding.Mode" /> es <see cref="F:System.Security.Cryptography.RSAEncryptionPaddingMode.Oaep" /> con el algoritmo hash especificado por <paramref name="hashAlgorithm" />.</returns>
      <exception cref="T:System.ArgumentException">La propiedad <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> de <paramref name="hashAlgorithm" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.Equals(System.Object)">
      <summary>Determina si la instancia actual es igual que el objeto especificado.</summary>
      <param name="obj">Objeto que se va a comparar.</param>
      <returns>Es <see langword="true" /> si <paramref name="obj" /> es igual a la instancia actual; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.Equals(System.Security.Cryptography.RSAEncryptionPadding)">
      <summary>Determina si la instancia actual es igual que el objeto <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" /> especificado.</summary>
      <param name="other">Objeto que se va a comparar.</param>
      <returns>Es <see langword="true" /> si <paramref name="other" /> es igual a la instancia actual; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.GetHashCode">
      <summary>Devuelve el código hash de este objeto <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" />.</summary>
      <returns>Código hash de esta instancia.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.Mode">
      <summary>Obtiene el modo de relleno representado por esta instancia de <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" />.</summary>
      <returns>Modo de relleno.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.OaepHashAlgorithm">
      <summary>Obtiene el algoritmo hash que se usa junto con el modo de relleno <see cref="F:System.Security.Cryptography.RSAEncryptionPaddingMode.Oaep" />.</summary>
      <returns>Algoritmo hash.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.OaepSHA1">
      <summary>Obtiene un objeto que representa el estándar de cifrado de Relleno óptimo de cifrado asimétrico (OAEP) con un algoritmo hash SHA1.</summary>
      <returns>Objeto que representa el estándar de cifrado OAEP con un algoritmo hash SHA1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.OaepSHA256">
      <summary>Obtiene un objeto que representa el cifrado de Relleno óptimo de cifrado asimétrico (OAEP) estándar con un algoritmo hash SHA256.</summary>
      <returns>Objeto que representa el estándar de cifrado OAEP con un algoritmo hash SHA256.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.OaepSHA384">
      <summary>Obtiene un objeto que representa el cifrado de Relleno óptimo de cifrado asimétrico (OAEP) estándar con un algoritmo hash SHA-384.</summary>
      <returns>Objeto que representa el estándar de cifrado OAEP con un algoritmo hash SHA384.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.OaepSHA512">
      <summary>Obtiene un objeto que representa el cifrado de Relleno óptimo de cifrado asimétrico (OAEP) estándar con un algoritmo hash SHA512.</summary>
      <returns>Objeto que representa el estándar de cifrado OAEP con un algoritmo hash SHA512.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.op_Equality(System.Security.Cryptography.RSAEncryptionPadding,System.Security.Cryptography.RSAEncryptionPadding)">
      <summary>Indica si dos objetos <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" /> especificados son iguales.</summary>
      <param name="left">Primer objeto que se va a comparar.</param>
      <param name="right">Segundo objeto que se va a comparar.</param>
      <returns>
        <see langword="true" /> si <see langword="left" /> y <see langword="right" /> son iguales; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.op_Inequality(System.Security.Cryptography.RSAEncryptionPadding,System.Security.Cryptography.RSAEncryptionPadding)">
      <summary>Indica si dos objetos <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" /> especificados no son iguales.</summary>
      <param name="left">Primer objeto que se va a comparar.</param>
      <param name="right">Segundo objeto que se va a comparar.</param>
      <returns>
        <see langword="true" /> si <see langword="left" /> y <see langword="right" /> no son iguales; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.Pkcs1">
      <summary>Obtiene un objeto que representa el estándar de cifrado PKCS #1.</summary>
      <returns>Objeto que representa el estándar de cifrado PKCS #1.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.ToString">
      <summary>Devuelve la representación de cadena de la instancia <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" /> actual.</summary>
      <returns>Representación en forma de cadena del objeto actual.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RSAEncryptionPaddingMode">
      <summary>Especifica el modo de relleno que se va a usar con operaciones de cifrado o descifrado RSA.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAEncryptionPaddingMode.Oaep">
      <summary>Relleno óptimo de cifrado asimétrico. Se recomienda para las aplicaciones nuevas.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAEncryptionPaddingMode.Pkcs1">
      <summary>PKCS #1 v1.5. Se admite por compatibilidad con las aplicaciones existentes.</summary>
    </member>
    <member name="T:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter">
      <summary>Descifra los datos del intercambio de claves del Relleno óptimo de cifrado asimétrico (OAEP).</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter" /> con la clave especificada.</summary>
      <param name="key">Instancia del algoritmo <see cref="T:System.Security.Cryptography.RSA" /> que contiene la clave privada.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter.DecryptKeyExchange(System.Byte[])">
      <summary>Extrae información secreta de los datos del intercambio de claves cifradas.</summary>
      <param name="rgbData">Datos de intercambio de claves en los que la información secreta está oculta.</param>
      <returns>Información secreta derivada de los datos de intercambio de claves.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Se ha producido un error en la comprobación de los datos del intercambio de claves.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">Falta la clave.</exception>
    </member>
    <member name="P:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter.Parameters">
      <summary>Obtiene los parámetros del intercambio de claves del Relleno óptimo de cifrado asimétrico (OAEP).</summary>
      <returns>Cadena XML que contiene los parámetros de la operación de intercambio de claves OAEP.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Establece la clave privada que se usa para descifrar la información secreta.</summary>
      <param name="key">Instancia del algoritmo <see cref="T:System.Security.Cryptography.RSA" /> que contiene la clave privada.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> es <see langword="null" />.</exception>
    </member>
    <member name="T:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter">
      <summary>Crea datos del intercambio de claves del Relleno óptimo de cifrado asimétrico (OAEP) utilizando <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter" /> con la clave especificada.</summary>
      <param name="key">Instancia del algoritmo <see cref="T:System.Security.Cryptography.RSA" /> que contiene la clave pública.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.CreateKeyExchange(System.Byte[])">
      <summary>Crea los datos de intercambio de claves cifradas a partir de los datos de entrada especificados.</summary>
      <param name="rgbData">Información secreta que se pasará en el intercambio de claves.</param>
      <returns>Datos de intercambio de claves cifradas que se enviarán al destinatario previsto.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">Falta la clave.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.CreateKeyExchange(System.Byte[],System.Type)">
      <summary>Crea los datos de intercambio de claves cifradas a partir de los datos de entrada especificados.</summary>
      <param name="rgbData">Información secreta que se pasará en el intercambio de claves.</param>
      <param name="symAlgType">Este parámetro no se usa en la versión actual.</param>
      <returns>Datos de intercambio de claves cifradas que se enviarán al destinatario previsto.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.Parameter">
      <summary>Obtiene o establece el parámetro utilizado para crear el relleno en el proceso de creación de intercambio de claves.</summary>
      <returns>Valor del parámetro.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.Parameters">
      <summary>Obtiene los parámetros del intercambio de claves del Relleno óptimo de cifrado asimétrico (OAEP).</summary>
      <returns>Cadena XML que contiene los parámetros de la operación de intercambio de claves OAEP.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.Rng">
      <summary>Obtiene o establece el algoritmo de generación de números aleatorios que se usa en la creación del intercambio de claves.</summary>
      <returns>Instancia del algoritmo de generación de números aleatorios que se va a usar.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Establece la clave pública que se usa para cifrar los datos del intercambio de claves.</summary>
      <param name="key">Instancia del algoritmo <see cref="T:System.Security.Cryptography.RSA" /> que contiene la clave pública.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> es <see langword="null" />.</exception>
    </member>
    <member name="T:System.Security.Cryptography.RSAParameters">
      <summary>Representa los parámetros estándar del algoritmo <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.D">
      <summary>Representa el parámetro <see langword="D" /> para el algoritmo <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.DP">
      <summary>Representa el parámetro <see langword="DP" /> para el algoritmo <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.DQ">
      <summary>Representa el parámetro <see langword="DQ" /> para el algoritmo <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.Exponent">
      <summary>Representa el parámetro <see langword="Exponent" /> para el algoritmo <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.InverseQ">
      <summary>Representa el parámetro <see langword="InverseQ" /> para el algoritmo <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.Modulus">
      <summary>Representa el parámetro <see langword="Modulus" /> para el algoritmo <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.P">
      <summary>Representa el parámetro <see langword="P" /> para el algoritmo <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.Q">
      <summary>Representa el parámetro <see langword="Q" /> para el algoritmo <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="T:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter">
      <summary>Descifra los datos de intercambio de claves PKCS #1.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter" /> con la clave especificada.</summary>
      <param name="key">Instancia del algoritmo <see cref="T:System.Security.Cryptography.RSA" /> que contiene la clave privada.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.DecryptKeyExchange(System.Byte[])">
      <summary>Extrae información secreta de los datos del intercambio de claves cifradas.</summary>
      <param name="rgbIn">Datos de intercambio de claves en los que la información secreta está oculta.</param>
      <returns>Información secreta derivada de los datos de intercambio de claves.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">Falta la clave.</exception>
    </member>
    <member name="P:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.Parameters">
      <summary>Obtiene los parámetros del intercambio de claves PKCS #1.</summary>
      <returns>Cadena XML que contiene los parámetros de la operación de intercambio de claves PKCS #1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.RNG">
      <summary>Obtiene o establece el algoritmo de generación de números aleatorios que se usa en la creación del intercambio de claves.</summary>
      <returns>Instancia del algoritmo de generación de números aleatorios que se va a usar.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Establece la clave privada que se usa para descifrar la información secreta.</summary>
      <param name="key">Instancia del algoritmo <see cref="T:System.Security.Cryptography.RSA" /> que contiene la clave privada.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> es <see langword="null" />.</exception>
    </member>
    <member name="T:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter">
      <summary>Crea los datos del intercambio de claves PKCS#1 utilizando <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter" /> con la clave especificada.</summary>
      <param name="key">Instancia del algoritmo <see cref="T:System.Security.Cryptography.RSA" /> que contiene la clave pública.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.CreateKeyExchange(System.Byte[])">
      <summary>Crea los datos de intercambio de claves cifradas a partir de los datos de entrada especificados.</summary>
      <param name="rgbData">Información secreta que se pasará en el intercambio de claves.</param>
      <returns>Datos de intercambio de claves cifradas que se enviarán al destinatario previsto.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="rgbData" /> es demasiado grande.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">La clave es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.CreateKeyExchange(System.Byte[],System.Type)">
      <summary>Crea los datos de intercambio de claves cifradas a partir de los datos de entrada especificados.</summary>
      <param name="rgbData">Información secreta que se pasará en el intercambio de claves.</param>
      <param name="symAlgType">Este parámetro no se usa en la versión actual.</param>
      <returns>Datos de intercambio de claves cifradas que se enviarán al destinatario previsto.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.Parameters">
      <summary>Obtiene los parámetros del intercambio de claves PKCS #1.</summary>
      <returns>Cadena XML que contiene los parámetros de la operación de intercambio de claves PKCS #1.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.Rng">
      <summary>Obtiene o establece el algoritmo de generación de números aleatorios que se usa en la creación del intercambio de claves.</summary>
      <returns>Instancia del algoritmo de generación de números aleatorios que se va a usar.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Establece la clave pública que se usa para cifrar los datos del intercambio de claves.</summary>
      <param name="key">Instancia del algoritmo <see cref="T:System.Security.Cryptography.RSA" /> que contiene la clave pública.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> es <see langword="null" />.</exception>
    </member>
    <member name="T:System.Security.Cryptography.RSAPKCS1SignatureDeformatter">
      <summary>Comprueba una firma PKCS #1 versión 1.5 de <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureDeformatter.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.RSAPKCS1SignatureDeformatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureDeformatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.RSAPKCS1SignatureDeformatter" /> con la clave especificada.</summary>
      <param name="key">Instancia de <see cref="T:System.Security.Cryptography.RSA" /> que contiene la clave pública.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureDeformatter.SetHashAlgorithm(System.String)">
      <summary>Establece el algoritmo hash que se usa para comprobar la firma.</summary>
      <param name="strName">Nombre del algoritmo hash que se utiliza para comprobar la firma.</param>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Establece la clave pública que se usa para comprobar la firma.</summary>
      <param name="key">Instancia de <see cref="T:System.Security.Cryptography.RSA" /> que contiene la clave pública.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureDeformatter.VerifySignature(System.Byte[],System.Byte[])">
      <summary>Comprueba la firma PKCS#1 de <see cref="T:System.Security.Cryptography.RSA" /> para los datos especificados.</summary>
      <param name="rgbHash">Datos firmados con <paramref name="rgbSignature" />.</param>
      <param name="rgbSignature">Firma que se va a comprobar para <paramref name="rgbHash" />.</param>
      <returns>
        <see langword="true" />, si <paramref name="rgbSignature" /> coincide con la firma calculada utilizando el algoritmo hash y la clave especificados en <paramref name="rgbHash" />; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">La clave es <see langword="null" />.  
O bien 
El algoritmo hash es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="rgbHash" /> es <see langword="null" />.  
O bien 
El parámetro <paramref name="rgbSignature" /> es <see langword="null" />.</exception>
    </member>
    <member name="T:System.Security.Cryptography.RSAPKCS1SignatureFormatter">
      <summary>Crea una firma PKCS #1 versión 1.5 de <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureFormatter.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.RSAPKCS1SignatureFormatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureFormatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.RSAPKCS1SignatureFormatter" /> con la clave especificada.</summary>
      <param name="key">Instancia del algoritmo <see cref="T:System.Security.Cryptography.RSA" /> que contiene la clave privada.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureFormatter.CreateSignature(System.Byte[])">
      <summary>Crea la signatura PKCS #1 <see cref="T:System.Security.Cryptography.RSA" /> de los datos especificados.</summary>
      <param name="rgbHash">Datos que van a firmar.</param>
      <returns>Firma digital para <paramref name="rgbHash" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">La clave es <see langword="null" />.  
O bien 
El algoritmo hash es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="rgbHash" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureFormatter.SetHashAlgorithm(System.String)">
      <summary>Establece el algoritmo hash que se usa para crear la firma.</summary>
      <param name="strName">Nombre del algoritmo hash que se utiliza para crear la firma.</param>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Establece la clave privada que se usa para crear la firma.</summary>
      <param name="key">Instancia del algoritmo <see cref="T:System.Security.Cryptography.RSA" /> que contiene la clave privada.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> es <see langword="null" />.</exception>
    </member>
    <member name="T:System.Security.Cryptography.RSASignaturePadding">
      <summary>Especifica el modo de relleno y los parámetros que se van a usar con operaciones de comprobación o creación de firmas RSA.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSASignaturePadding.Equals(System.Object)">
      <summary>Devuelve un valor que indica si esta instancia es igual que un objeto especificado.</summary>
      <param name="obj">Objeto que se va a comparar con la instancia actual.</param>
      <returns>
        <see langword="true" /> si el objeto especificado es igual al objeto actual; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSASignaturePadding.Equals(System.Security.Cryptography.RSASignaturePadding)">
      <summary>Devuelve un valor que indica si esta instancia equivale a un objeto <see cref="T:System.Security.Cryptography.RSASignaturePadding" /> especificado.</summary>
      <param name="other">Objeto que se va a comparar con la instancia actual.</param>
      <returns>
        <see langword="true" /> si el objeto especificado es igual al objeto actual; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSASignaturePadding.GetHashCode">
      <summary>Devuelve el código hash de esta instancia de <see cref="T:System.Security.Cryptography.RSASignaturePadding" />.</summary>
      <returns>Código hash de esta instancia <see cref="T:System.Security.Cryptography.RSASignaturePadding" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSASignaturePadding.Mode">
      <summary>Obtiene el modo de relleno de esta instancia de <see cref="T:System.Security.Cryptography.RSASignaturePadding" />.</summary>
      <returns>El modo de relleno (<see cref="F:System.Security.Cryptography.RSASignaturePaddingMode.Pkcs1" /> o <see cref="F:System.Security.Cryptography.RSASignaturePaddingMode.Pss" />) de esta instancia.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSASignaturePadding.op_Equality(System.Security.Cryptography.RSASignaturePadding,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Indica si dos objetos <see cref="T:System.Security.Cryptography.RSASignaturePadding" /> especificados son iguales.</summary>
      <param name="left">Primer objeto que se va a comparar.</param>
      <param name="right">Segundo objeto que se va a comparar.</param>
      <returns>
        <see langword="true" /> si <see langword="left" /> y <see langword="right" /> son iguales; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSASignaturePadding.op_Inequality(System.Security.Cryptography.RSASignaturePadding,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Indica si dos objetos <see cref="T:System.Security.Cryptography.RSASignaturePadding" /> especificados no son iguales.</summary>
      <param name="left">Primer objeto que se va a comparar.</param>
      <param name="right">Segundo objeto que se va a comparar.</param>
      <returns>
        <see langword="true" /> si <see langword="left" /> y <see langword="right" /> no son iguales; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSASignaturePadding.Pkcs1">
      <summary>Obtiene un objeto que usa el modo de relleno PKCS #1 v1.5.</summary>
      <returns>Objeto que usa el modo de relleno <see cref="F:System.Security.Cryptography.RSASignaturePaddingMode.Pkcs1" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSASignaturePadding.Pss">
      <summary>Obtiene un objeto que usa el modo de relleno PSS.</summary>
      <returns>Objeto que usa el modo de relleno <see cref="F:System.Security.Cryptography.RSASignaturePaddingMode.Pss" /> con el número de bytes de sal igual al tamaño del valor hash.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSASignaturePadding.ToString">
      <summary>Devuelve la representación de cadena de la instancia <see cref="T:System.Security.Cryptography.RSASignaturePadding" /> actual.</summary>
      <returns>Representación en forma de cadena del objeto actual.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RSASignaturePaddingMode">
      <summary>Especifica el modo de relleno que se va a usar con operaciones de comprobación o creación de firmas RSA.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSASignaturePaddingMode.Pkcs1">
      <summary>PKCS #1 v1.5</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSASignaturePaddingMode.Pss">
      <summary>Esquema de firma probabilística</summary>
    </member>
    <member name="T:System.Security.Cryptography.SHA1">
      <summary>Calcula el valor hash de <see cref="T:System.Security.Cryptography.SHA1" /> para los datos de entrada.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA1.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.SHA1" />.</summary>
      <exception cref="T:System.InvalidOperationException">La directiva de este objeto no es compatible con el algoritmo FIPS.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SHA1.Create">
      <summary>Crea una instancia de la implementación predeterminada de <see cref="T:System.Security.Cryptography.SHA1" />.</summary>
      <returns>Nueva instancia de <see cref="T:System.Security.Cryptography.SHA1" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA1.Create(System.String)">
      <summary>Crea una instancia de la implementación de <see cref="T:System.Security.Cryptography.SHA1" /> especificada.</summary>
      <param name="hashName">Nombre de la implementación específica de <see cref="T:System.Security.Cryptography.SHA1" /> que se va a utilizar.</param>
      <returns>Nueva instancia de <see cref="T:System.Security.Cryptography.SHA1" /> con la implementación especificada.</returns>
    </member>
    <member name="T:System.Security.Cryptography.SHA1Managed">
      <summary>Calcula el valor hash de <see cref="T:System.Security.Cryptography.SHA1" /> de los datos de entrada utilizando la biblioteca administrada.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA1Managed.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.SHA1Managed" />.</summary>
      <exception cref="T:System.InvalidOperationException">Esta clase no es compatible con el algoritmo FIPS.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SHA1Managed.Dispose(System.Boolean)">
      <summary>Libera los recursos no administrados que usa el objeto <see cref="T:System.Security.Cryptography.SHA1Managed" /> y, opcionalmente, los recursos administrados.</summary>
      <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
    </member>
    <member name="M:System.Security.Cryptography.SHA1Managed.HashCore(System.Byte[],System.Int32,System.Int32)">
      <summary>Envía los datos escritos en el objeto al algoritmo hash <see cref="T:System.Security.Cryptography.SHA1Managed" /> para el cálculo del valor hash.</summary>
      <param name="array">Datos de entrada.</param>
      <param name="ibStart">Desplazamiento en la matriz de bytes a partir del cual se empezarán a usar los datos.</param>
      <param name="cbSize">Número de bytes de la matriz que se van a usar como datos.</param>
    </member>
    <member name="M:System.Security.Cryptography.SHA1Managed.HashCore(System.ReadOnlySpan{System.Byte})">
      <param name="source" />
    </member>
    <member name="M:System.Security.Cryptography.SHA1Managed.HashFinal">
      <summary>Devuelve el valor hash de <see cref="T:System.Security.Cryptography.SHA1" /> calculado una vez escritos todos los datos en el objeto.</summary>
      <returns>Código hash calculado.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA1Managed.Initialize">
      <summary>Inicializa una instancia de <see cref="T:System.Security.Cryptography.SHA1Managed" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA1Managed.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <param name="destination" />
      <param name="bytesWritten" />
    </member>
    <member name="T:System.Security.Cryptography.SHA256">
      <summary>Calcula el valor hash de <see cref="T:System.Security.Cryptography.SHA256" /> para los datos de entrada.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA256.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.SHA256" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA256.Create">
      <summary>Crea una instancia de la implementación predeterminada de <see cref="T:System.Security.Cryptography.SHA256" />.</summary>
      <returns>Nueva instancia de <see cref="T:System.Security.Cryptography.SHA256" />. En .NET Framework, este método crea una instancia de la clase <see cref="T:System.Security.Cryptography.SHA256Managed" /> si el modo FIPS no está activo; si el modo FIPS está activo, crea una instancia de la clase <see cref="T:System.Security.Cryptography.SHA256Cng" />. En .NET Core, devuelve una instancia de una clase privada derivada de <see cref="T:System.Security.Cryptography.SHA256" />.</returns>
      <exception cref="T:System.Reflection.TargetInvocationException">Solo en .NET Framework 4.6.1 y versiones anteriores: El algoritmo se usó con el modo FIPS (Estándar federal de procesamiento de información) habilitado, pero no es compatible con FIPS.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SHA256.Create(System.String)">
      <summary>Crea una instancia de la implementación de <see cref="T:System.Security.Cryptography.SHA256" /> especificada.</summary>
      <param name="hashName">Nombre de la implementación específica de <see cref="T:System.Security.Cryptography.SHA256" /> que se va a utilizar.</param>
      <returns>Nueva instancia de <see cref="T:System.Security.Cryptography.SHA256" /> con la implementación especificada.</returns>
      <exception cref="T:System.Reflection.TargetInvocationException">Solo en .NET Framework: El modo FIPS está habilitado, pero <paramref name="hashName" /> pide <see cref="T:System.Security.Cryptography.SHA256Managed" />, que no es compatible con FIPS.</exception>
    </member>
    <member name="T:System.Security.Cryptography.SHA256Managed">
      <summary>Calcula el valor hash de <see cref="T:System.Security.Cryptography.SHA256" /> de los datos de entrada utilizando la biblioteca administrada.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA256Managed.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.SHA256Managed" /> utilizando la biblioteca administrada.</summary>
      <exception cref="T:System.InvalidOperationException">Se habilita la configuración de seguridad del Estándar federal de procesamiento de información (FIPS). Esta implementación no forma parte de los algoritmos criptográficos validados por FIPS de la plataforma Windows.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SHA256Managed.Dispose(System.Boolean)">
      <summary>Libera los recursos no administrados que usa el objeto <see cref="T:System.Security.Cryptography.SHA256Managed" /> y, opcionalmente, los recursos administrados.</summary>
      <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
    </member>
    <member name="M:System.Security.Cryptography.SHA256Managed.HashCore(System.Byte[],System.Int32,System.Int32)">
      <summary>Cuando se invalida en una clase derivada, enruta los datos escritos en el objeto al algoritmo hash <see cref="T:System.Security.Cryptography.SHA256" /> para el cálculo del valor hash.</summary>
      <param name="array">Datos de entrada.</param>
      <param name="ibStart">Desplazamiento en la matriz de bytes a partir del cual se empezarán a usar los datos.</param>
      <param name="cbSize">Número de bytes de la matriz que se van a usar como datos.</param>
    </member>
    <member name="M:System.Security.Cryptography.SHA256Managed.HashCore(System.ReadOnlySpan{System.Byte})">
      <param name="source" />
    </member>
    <member name="M:System.Security.Cryptography.SHA256Managed.HashFinal">
      <summary>Cuando se invalida en una clase derivada, finaliza el cálculo hash una vez que el objeto de secuencia criptográfico termina de procesar los últimos datos.</summary>
      <returns>Código hash calculado.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA256Managed.Initialize">
      <summary>Inicializa una instancia de <see cref="T:System.Security.Cryptography.SHA256Managed" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA256Managed.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <param name="destination" />
      <param name="bytesWritten" />
    </member>
    <member name="T:System.Security.Cryptography.SHA384">
      <summary>Calcula el valor hash de <see cref="T:System.Security.Cryptography.SHA384" /> para los datos de entrada.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA384.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.SHA384" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA384.Create">
      <summary>Crea una instancia de la implementación predeterminada de <see cref="T:System.Security.Cryptography.SHA384" />.</summary>
      <returns>Nueva instancia de <see cref="T:System.Security.Cryptography.SHA384" />.</returns>
      <exception cref="T:System.Reflection.TargetInvocationException">El algoritmo se usó con el modo FIPS (Estándar federal de procesamiento de información) habilitado, pero no es compatible con FIPS.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SHA384.Create(System.String)">
      <summary>Crea una instancia de la implementación de <see cref="T:System.Security.Cryptography.SHA384" /> especificada.</summary>
      <param name="hashName">Nombre de la implementación específica de <see cref="T:System.Security.Cryptography.SHA384" /> que se va a utilizar.</param>
      <returns>Nueva instancia de <see cref="T:System.Security.Cryptography.SHA384" /> con la implementación especificada.</returns>
      <exception cref="T:System.Reflection.TargetInvocationException">Se utilizó el algoritmo descrito por el parámetro <paramref name="hashName" /> con el modo FIPS (Estándar federal de procesamiento de información) habilitado, pero no es compatible con FIPS.</exception>
    </member>
    <member name="T:System.Security.Cryptography.SHA384Managed">
      <summary>Calcula el valor hash de <see cref="T:System.Security.Cryptography.SHA384" /> de los datos de entrada utilizando la biblioteca administrada.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA384Managed.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.SHA384Managed" />.</summary>
      <exception cref="T:System.InvalidOperationException">Se habilita la configuración de seguridad del Estándar federal de procesamiento de información (FIPS). Esta implementación no forma parte de los algoritmos criptográficos validados por FIPS de la plataforma Windows.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SHA384Managed.Dispose(System.Boolean)">
      <summary>Libera los recursos no administrados que usa el objeto <see cref="T:System.Security.Cryptography.SHA384Managed" /> y, opcionalmente, los recursos administrados.</summary>
      <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
    </member>
    <member name="M:System.Security.Cryptography.SHA384Managed.HashCore(System.Byte[],System.Int32,System.Int32)">
      <summary>Cuando se invalida en una clase derivada, enruta los datos escritos en el objeto al algoritmo hash <see cref="T:System.Security.Cryptography.SHA384Managed" /> para el cálculo del valor hash.</summary>
      <param name="array">Datos de entrada.</param>
      <param name="ibStart">Desplazamiento en la matriz de bytes a partir del cual se empezarán a usar los datos.</param>
      <param name="cbSize">Número de bytes de la matriz que se van a usar como datos.</param>
    </member>
    <member name="M:System.Security.Cryptography.SHA384Managed.HashCore(System.ReadOnlySpan{System.Byte})">
      <param name="source" />
    </member>
    <member name="M:System.Security.Cryptography.SHA384Managed.HashFinal">
      <summary>Cuando se invalida en una clase derivada, finaliza el cálculo hash una vez que el objeto de secuencia criptográfico termina de procesar los últimos datos.</summary>
      <returns>Código hash calculado.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA384Managed.Initialize">
      <summary>Inicializa una instancia de <see cref="T:System.Security.Cryptography.SHA384Managed" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA384Managed.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <param name="destination" />
      <param name="bytesWritten" />
    </member>
    <member name="T:System.Security.Cryptography.SHA512">
      <summary>Calcula el valor hash de <see cref="T:System.Security.Cryptography.SHA512" /> para los datos de entrada.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA512.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.SHA512" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA512.Create">
      <summary>Crea una instancia de la implementación predeterminada de <see cref="T:System.Security.Cryptography.SHA512" />.</summary>
      <returns>Nueva instancia de <see cref="T:System.Security.Cryptography.SHA512" />.</returns>
      <exception cref="T:System.Reflection.TargetInvocationException">El algoritmo se usó con el modo FIPS (Estándar federal de procesamiento de información) habilitado, pero no es compatible con FIPS.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SHA512.Create(System.String)">
      <summary>Crea una instancia de la implementación de <see cref="T:System.Security.Cryptography.SHA512" /> especificada.</summary>
      <param name="hashName">Nombre de la implementación específica de <see cref="T:System.Security.Cryptography.SHA512" /> que se va a utilizar.</param>
      <returns>Nueva instancia de <see cref="T:System.Security.Cryptography.SHA512" /> con la implementación especificada.</returns>
      <exception cref="T:System.Reflection.TargetInvocationException">Se utilizó el algoritmo descrito por el parámetro <paramref name="hashName" /> con el modo FIPS (Estándar federal de procesamiento de información) habilitado, pero no es compatible con FIPS.</exception>
    </member>
    <member name="T:System.Security.Cryptography.SHA512Managed">
      <summary>Calcula el algoritmo hash <see cref="T:System.Security.Cryptography.SHA512" /> de los datos de entrada utilizando la biblioteca administrada.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA512Managed.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.SHA512Managed" />.</summary>
      <exception cref="T:System.InvalidOperationException">Se habilita la configuración de seguridad del Estándar federal de procesamiento de información (FIPS). Esta implementación no forma parte de los algoritmos criptográficos validados por FIPS de la plataforma Windows.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SHA512Managed.Dispose(System.Boolean)">
      <summary>Libera los recursos no administrados que usa el objeto <see cref="T:System.Security.Cryptography.SHA512Managed" /> y, opcionalmente, los recursos administrados.</summary>
      <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
    </member>
    <member name="M:System.Security.Cryptography.SHA512Managed.HashCore(System.Byte[],System.Int32,System.Int32)">
      <summary>Cuando se invalida en una clase derivada, enruta los datos escritos en el objeto al algoritmo hash <see cref="T:System.Security.Cryptography.SHA512Managed" /> para el cálculo del valor hash.</summary>
      <param name="array">Datos de entrada.</param>
      <param name="ibStart">Desplazamiento en la matriz de bytes a partir del cual se empezarán a usar los datos.</param>
      <param name="cbSize">Número de bytes de la matriz que se van a usar como datos.</param>
    </member>
    <member name="M:System.Security.Cryptography.SHA512Managed.HashCore(System.ReadOnlySpan{System.Byte})">
      <param name="source" />
    </member>
    <member name="M:System.Security.Cryptography.SHA512Managed.HashFinal">
      <summary>Cuando se invalida en una clase derivada, finaliza el cálculo hash una vez que el objeto de secuencia criptográfico termina de procesar los últimos datos.</summary>
      <returns>Código hash calculado.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA512Managed.Initialize">
      <summary>Inicializa una instancia de la clase <see cref="T:System.Security.Cryptography.SHA512Managed" /> utilizando la biblioteca administrada.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA512Managed.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <param name="destination" />
      <param name="bytesWritten" />
    </member>
    <member name="T:System.Security.Cryptography.SignatureDescription">
      <summary>Contiene información sobre las propiedades de una firma digital.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SignatureDescription.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.SignatureDescription" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SignatureDescription.#ctor(System.Security.SecurityElement)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.SignatureDescription" /> a partir del <see cref="T:System.Security.SecurityElement" /> especificado.</summary>
      <param name="el">
        <see cref="T:System.Security.SecurityElement" /> del que se va a obtener los algoritmos para la descripción de la firma.</param>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="el" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SignatureDescription.CreateDeformatter(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Crea una instancia de <see cref="T:System.Security.Cryptography.AsymmetricSignatureDeformatter" /> con la clave especificada utilizando la propiedad <see cref="P:System.Security.Cryptography.SignatureDescription.DeformatterAlgorithm" />.</summary>
      <param name="key">Clave que se va a utilizar en <see cref="T:System.Security.Cryptography.AsymmetricSignatureDeformatter" />.</param>
      <returns>Instancia de <see cref="T:System.Security.Cryptography.AsymmetricSignatureDeformatter" /> recién creada.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SignatureDescription.CreateDigest">
      <summary>Crea una instancia de <see cref="T:System.Security.Cryptography.HashAlgorithm" /> mediante la propiedad <see cref="P:System.Security.Cryptography.SignatureDescription.DigestAlgorithm" />.</summary>
      <returns>Instancia de <see cref="T:System.Security.Cryptography.HashAlgorithm" /> recién creada.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SignatureDescription.CreateFormatter(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Crea una instancia de <see cref="T:System.Security.Cryptography.AsymmetricSignatureFormatter" /> con la clave especificada utilizando la propiedad <see cref="P:System.Security.Cryptography.SignatureDescription.FormatterAlgorithm" />.</summary>
      <param name="key">Clave que se va a utilizar en <see cref="T:System.Security.Cryptography.AsymmetricSignatureFormatter" />.</param>
      <returns>Instancia de <see cref="T:System.Security.Cryptography.AsymmetricSignatureFormatter" /> recién creada.</returns>
    </member>
    <member name="P:System.Security.Cryptography.SignatureDescription.DeformatterAlgorithm">
      <summary>Obtiene o establece el algoritmo desformateador para la descripción de la firma.</summary>
      <returns>Algoritmo desformateador para la descripción de la firma.</returns>
    </member>
    <member name="P:System.Security.Cryptography.SignatureDescription.DigestAlgorithm">
      <summary>Obtiene o establece el algoritmo de síntesis para la descripción de la firma.</summary>
      <returns>Algoritmo de síntesis para la descripción de firma.</returns>
    </member>
    <member name="P:System.Security.Cryptography.SignatureDescription.FormatterAlgorithm">
      <summary>Obtiene o establece el algoritmo formateador para la descripción de la firma.</summary>
      <returns>Algoritmo formateador para la descripción de la firma.</returns>
    </member>
    <member name="P:System.Security.Cryptography.SignatureDescription.KeyAlgorithm">
      <summary>Obtiene o establece el algoritmo de clave para la descripción de la firma.</summary>
      <returns>Algoritmo de clave para la descripción de la firma.</returns>
    </member>
    <member name="T:System.Security.Cryptography.TripleDES">
      <summary>Representa la clase base de los algoritmos Estándar de cifrado triple de datos de la que se deben derivar todas las implementaciones de <see cref="T:System.Security.Cryptography.TripleDES" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.TripleDES.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.TripleDES" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.TripleDES.Create">
      <summary>Crea una instancia de un objeto criptográfico para realizar el algoritmo <see cref="T:System.Security.Cryptography.TripleDES" />.</summary>
      <returns>Una instancia de un objeto criptográfico.</returns>
    </member>
    <member name="M:System.Security.Cryptography.TripleDES.Create(System.String)">
      <summary>Crea una instancia de un objeto criptográfico para ejecutar la implementación especificada del algoritmo <see cref="T:System.Security.Cryptography.TripleDES" />.</summary>
      <param name="str">Nombre de la implementación específica de <see cref="T:System.Security.Cryptography.TripleDES" /> que se va a utilizar.</param>
      <returns>Una instancia de un objeto criptográfico.</returns>
    </member>
    <member name="M:System.Security.Cryptography.TripleDES.IsWeakKey(System.Byte[])">
      <summary>Determina si la clave especificada es débil.</summary>
      <param name="rgbKey">Clave secreta que se va a comprobar para determinar la debilidad de la misma.</param>
      <returns>
        <see langword="true" /> si la clave es débil; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Security.Cryptography.CryptographicException">El tamaño del parámetro <paramref name="rgbKey" /> no es válido.</exception>
    </member>
    <member name="P:System.Security.Cryptography.TripleDES.Key">
      <summary>Obtiene o establece la clave secreta del algoritmo <see cref="T:System.Security.Cryptography.TripleDES" />.</summary>
      <returns>Clave secreta del algoritmo <see cref="T:System.Security.Cryptography.TripleDES" />.</returns>
      <exception cref="T:System.ArgumentNullException">Se ha intentado establecer la clave en <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Se ha intentado establecer una clave cuya longitud no es válida.  
O bien 
Se ha intentado establecer una clave débil (vea <see cref="M:System.Security.Cryptography.TripleDES.IsWeakKey(System.Byte[])" />).</exception>
    </member>
  </members>
</doc>