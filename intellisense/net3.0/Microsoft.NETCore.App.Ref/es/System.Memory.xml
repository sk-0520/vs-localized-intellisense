<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Memory</name>
  </assembly>
  <members>
    <member name="T:System.Buffers.ArrayBufferWriter`1">
      <summary>Representa un receptor de salida respaldado por matriz y basado en el montón en el que <typeparam name="T" /> se pueden escribir datos.</summary>
      <typeparam name="T">Tipo de los elementos de esta <see cref="T:System.Buffers.ArrayBufferWriter`1" /> instancia.</typeparam>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.#ctor">
      <summary>Crea una instancia de un elemento <see cref="T:System.Buffers.ArrayBufferWriter`1" /> en la que se pueden escribir datos, con la capacidad inicial predeterminada.</summary>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.#ctor(System.Int32)">
      <summary>Crea una instancia de un elemento <see cref="T:System.Buffers.ArrayBufferWriter`1" /> en la que se pueden escribir datos, con la capacidad inicial especificada.</summary>
      <param name="initialCapacity">Capacidad mínima con la que se va a inicializar el búfer subyacente.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="initialCapacity" /> es menor o igual que 0.</exception>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.Advance(System.Int32)">
      <summary>Notifica a <see cref="T:System.Buffers.IBufferWriter`1" /> que los elementos de <paramref name="count" /> se han escrito en la salida <see cref="T:System.Span`1" />/<see cref="T:System.Memory`1" /></summary>
      <param name="count">Número de elementos escritos.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="count" /> es negativo.</exception>
      <exception cref="T:System.InvalidOperationException">La llamada al método intenta avanzar más allá del final del búfer subyacente.</exception>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.Capacity">
      <summary>Obtiene la cantidad total de espacio en el búfer subyacente.</summary>
      <returns>Capacidad total del búfer subyacente.</returns>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.Clear">
      <summary>Borra los datos escritos en el búfer subyacente.</summary>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.FreeCapacity">
      <summary>Obtiene la cantidad de espacio disponible que se puede escribir sin forzar el búfer subyacente para crecer.</summary>
      <returns>Espacio disponible para escritura sin forzar el crecimiento del búfer subyacente.</returns>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.GetMemory(System.Int32)">
      <summary>Devuelve un objeto <see cref="T:System.Memory`1" /> en el que escribir, que tiene al menos la longitud especificada por <paramref name="sizeHint" />.</summary>
      <param name="sizeHint">La longitud mínima solicitada del elemento <see cref="T:System.Memory`1" />.</param>
      <returns>Elemento <see cref="T:System.Memory`1" /> cuya longitud es al menos de <paramref name="sizeHint" />.  Si <paramref name="sizeHint" /> no se proporciona o es igual a 0, se devuelve un búfer no vacío.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="sizeHint" /> es negativo.</exception>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.GetSpan(System.Int32)">
      <summary>Devuelve un objeto <see cref="T:System.Span`1" /> en el que escribir, que tiene al menos una longitud especificada.</summary>
      <param name="sizeHint">La longitud mínima solicitada del elemento <see cref="T:System.Span`1" />.</param>
      <returns>Intervalo cuya longitud es de al menos <paramref name="sizeHint" />. Si <paramref name="sizeHint" /> no se proporciona o es igual a 0, se devuelve un búfer no vacío.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="sizeHint" /> es negativo.</exception>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenCount">
      <summary>Obtiene la cantidad de datos escrita en el búfer subyacente.</summary>
      <returns>La cantidad de datos que se escriben en el búfer subyacente.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenMemory">
      <summary>Obtiene un elemento <see cref="T:System.ReadOnlyMemory`1" /> que contiene los datos que se han escrito en el búfer subyacente.</summary>
      <returns>Datos escritos en el búfer subyacente.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenSpan">
      <summary>Obtiene un elemento <see cref="T:System.ReadOnlySpan`1" /> que contiene los datos que se han escrito en el búfer subyacente.</summary>
      <returns>Datos escritos en el búfer subyacente.</returns>
    </member>
    <member name="T:System.Buffers.Binary.BinaryPrimitives">
      <summary>Lee bytes como primitivos con endian específicos.</summary>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lee un valor <see cref="T:System.Int16" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source">Intervalo de solo lectura que se leerá.</param>
      <returns>Valor de big endian.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.Int16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lee un valor <see cref="T:System.Int16" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source">Intervalo de solo lectura que se leerá.</param>
      <returns>Valor de little endian.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.Int16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lee un valor <see cref="T:System.Int32" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source">Intervalo de solo lectura que se leerá.</param>
      <returns>Valor de big endian.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lee un valor <see cref="T:System.Int32" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source">Intervalo de solo lectura que se leerá.</param>
      <returns>Valor de little endian.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lee un valor <see cref="T:System.Int64" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source">Intervalo de solo lectura que se leerá.</param>
      <returns>Valor de big endian.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.Int64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lee un valor <see cref="T:System.Int64" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source">Intervalo de solo lectura que se leerá.</param>
      <returns>Valor de little endian.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.Int64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lee un valor <see cref="T:System.UInt16" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source">Intervalo de solo lectura que se leerá.</param>
      <returns>Valor de big endian.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.UInt16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lee un valor <see cref="T:System.UInt16" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source">Intervalo de solo lectura que se leerá.</param>
      <returns>Valor de little endian.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.UInt16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lee un valor <see cref="T:System.UInt32" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source">Intervalo de solo lectura que se leerá.</param>
      <returns>Valor de big endian.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.UInt32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lee un valor <see cref="T:System.UInt32" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source">Intervalo de bytes de solo lectura que se leerá.</param>
      <returns>Valor de little endian.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.UInt32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lee un valor <see cref="T:System.UInt64" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source">Intervalo de bytes de solo lectura que se leerá.</param>
      <returns>Valor de big endian.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.UInt64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lee un valor <see cref="T:System.UInt64" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source">Intervalo de bytes de solo lectura que se leerá.</param>
      <returns>Valor de little endian.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.UInt64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Byte)">
      <summary>Invierte un valor primitivo al realizar un intercambio endian del valor <see cref="T:System.Byte" /> especificado, lo que en la práctica no tiene ningún efecto en un valor <see cref="T:System.Byte" />.</summary>
      <param name="value">Valor que se invertirá.</param>
      <returns>Valor pasado, sin modificar.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int16)">
      <summary>Invierte un valor primitivo al realizar un intercambio endian del valor <see cref="T:System.Int16" /> especificado.</summary>
      <param name="value">Valor que se invertirá.</param>
      <returns>Valor invertido.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int32)">
      <summary>Invierte un valor primitivo al realizar un intercambio endian del valor <see cref="T:System.Int32" /> especificado.</summary>
      <param name="value">Valor que se invertirá.</param>
      <returns>Valor invertido.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int64)">
      <summary>Invierte un valor primitivo al realizar un intercambio endian del valor <see cref="T:System.Int64" /> especificado.</summary>
      <param name="value">Valor que se invertirá.</param>
      <returns>Valor invertido.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.SByte)">
      <summary>Invierte un valor primitivo al realizar un intercambio endian del valor <see cref="T:System.SByte" /> especificado, lo que en la práctica no tiene ningún efecto en un valor <see cref="T:System.SByte" />.</summary>
      <param name="value">Valor que se invertirá.</param>
      <returns>Valor pasado, sin modificar.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt16)">
      <summary>Invierte un valor primitivo al realizar un intercambio endian del valor <see cref="T:System.UInt16" /> especificado.</summary>
      <param name="value">Valor que se invertirá.</param>
      <returns>Valor invertido.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt32)">
      <summary>Invierte un valor primitivo al realizar un intercambio endian del valor <see cref="T:System.UInt32" /> especificado.</summary>
      <param name="value">Valor que se invertirá.</param>
      <returns>Valor invertido.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt64)">
      <summary>Invierte un valor primitivo al realizar un intercambio endian del valor <see cref="T:System.UInt64" /> especificado.</summary>
      <param name="value">Valor que se invertirá.</param>
      <returns>Valor invertido.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16BigEndian(System.ReadOnlySpan{System.Byte},System.Int16@)">
      <summary>Lee un valor <see cref="T:System.Int16" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value">Cuando finaliza este método, el valor se lee fuera del intervalo de bytes de solo lectura, como big endian.</param>
      <returns>
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un valor <see cref="T:System.Int16" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.Int16@)">
      <summary>Lee un valor <see cref="T:System.Int16" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value">Cuando finaliza este método, el valor se lee fuera del intervalo de bytes de solo lectura, como little endian.</param>
      <returns>
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un valor <see cref="T:System.Int16" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32BigEndian(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Lee un valor <see cref="T:System.Int32" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value">Cuando finaliza este método, el valor se lee fuera del intervalo de bytes de solo lectura, como big endian.</param>
      <returns>
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un valor <see cref="T:System.Int32" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Lee un valor <see cref="T:System.Int32" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value">Cuando finaliza este método, el valor se lee fuera del intervalo de bytes de solo lectura, como little endian.</param>
      <returns>
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un valor <see cref="T:System.Int32" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64BigEndian(System.ReadOnlySpan{System.Byte},System.Int64@)">
      <summary>Lee un valor <see cref="T:System.Int64" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value">Cuando finaliza este método, el valor se lee fuera del intervalo de bytes de solo lectura, como big endian.</param>
      <returns>
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un valor <see cref="T:System.Int64" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.Int64@)">
      <summary>Lee un valor <see cref="T:System.Int64" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value">Cuando finaliza este método, el valor se lee fuera del intervalo de bytes de solo lectura, como little endian.</param>
      <returns>
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un valor <see cref="T:System.Int64" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16BigEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)">
      <summary>Lee un valor <see cref="T:System.UInt16" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value">Cuando finaliza este método, el valor se lee fuera del intervalo de bytes de solo lectura, como big endian.</param>
      <returns>
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.UInt16" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)">
      <summary>Lee un valor <see cref="T:System.UInt16" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value">Cuando finaliza este método, el valor se lee fuera del intervalo de bytes de solo lectura, como little endian.</param>
      <returns>
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.UInt16" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32BigEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)">
      <summary>Lee un valor <see cref="T:System.UInt32" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value">Cuando finaliza este método, el valor se lee fuera del intervalo de bytes de solo lectura, como big endian.</param>
      <returns>
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.UInt32" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)">
      <summary>Lee un valor <see cref="T:System.UInt32" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value">Cuando finaliza este método, el valor se lee fuera del intervalo de bytes de solo lectura, como little endian.</param>
      <returns>
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.UInt32" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64BigEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)">
      <summary>Lee un valor <see cref="T:System.UInt64" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value">Cuando finaliza este método, el valor se lee fuera del intervalo de bytes de solo lectura, como big endian.</param>
      <returns>
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.UInt64" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)">
      <summary>Lee un valor <see cref="T:System.UInt64" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value">Cuando finaliza este método, el valor se lee fuera del intervalo de bytes de solo lectura, como little endian.</param>
      <returns>
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.UInt64" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16BigEndian(System.Span{System.Byte},System.Int16)">
      <summary>Escribe un valor <see cref="T:System.Int16" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value">Valor que se escribirá en el intervalo de bytes.</param>
      <returns>
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un valor <see cref="T:System.Int16" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16LittleEndian(System.Span{System.Byte},System.Int16)">
      <summary>Escribe un valor <see cref="T:System.Int16" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value">Valor que se escribirá en el intervalo de bytes.</param>
      <returns>
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un valor <see cref="T:System.Int16" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32BigEndian(System.Span{System.Byte},System.Int32)">
      <summary>Escribe un valor <see cref="T:System.Int32" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value">Valor que se escribirá en el intervalo de bytes.</param>
      <returns>
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un valor <see cref="T:System.Int32" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32LittleEndian(System.Span{System.Byte},System.Int32)">
      <summary>Escribe un valor <see cref="T:System.Int32" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value">Valor que se escribirá en el intervalo de bytes.</param>
      <returns>
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un valor <see cref="T:System.Int32" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64BigEndian(System.Span{System.Byte},System.Int64)">
      <summary>Escribe un valor <see cref="T:System.Int64" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value">Valor que se escribirá en el intervalo de bytes.</param>
      <returns>
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un valor <see cref="T:System.Int64" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64LittleEndian(System.Span{System.Byte},System.Int64)">
      <summary>Escribe un valor <see cref="T:System.Int64" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value">Valor que se escribirá en el intervalo de bytes.</param>
      <returns>
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un valor <see cref="T:System.Int64" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)">
      <summary>Escribe un valor <see cref="T:System.UInt16" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value">Valor que se escribirá en el intervalo de bytes.</param>
      <returns>
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.UInt16" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)">
      <summary>Escribe un valor <see cref="T:System.UInt16" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value">Valor que se escribirá en el intervalo de bytes.</param>
      <returns>
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.UInt16" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)">
      <summary>Escribe un valor <see cref="T:System.UInt32" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value">Valor que se escribirá en el intervalo de bytes.</param>
      <returns>
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.UInt32" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)">
      <summary>Escribe un valor <see cref="T:System.UInt32" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value">Valor que se escribirá en el intervalo de bytes.</param>
      <returns>
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.UInt32" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)">
      <summary>Escribe un valor <see cref="T:System.UInt64" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value">Valor que se escribirá en el intervalo de bytes.</param>
      <returns>
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.UInt64" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)">
      <summary>Escribe un valor <see cref="T:System.UInt64" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value">Valor que se escribirá en el intervalo de bytes.</param>
      <returns>
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.UInt64" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16BigEndian(System.Span{System.Byte},System.Int16)">
      <summary>Escribe un valor <see cref="T:System.Int16" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.Int16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16LittleEndian(System.Span{System.Byte},System.Int16)">
      <summary>Escribe un valor <see cref="T:System.Int16" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.Int16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32BigEndian(System.Span{System.Byte},System.Int32)">
      <summary>Escribe un valor <see cref="T:System.Int32" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32LittleEndian(System.Span{System.Byte},System.Int32)">
      <summary>Escribe un valor <see cref="T:System.Int32" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64BigEndian(System.Span{System.Byte},System.Int64)">
      <summary>Escribe un valor <see cref="T:System.Int64" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.Int64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64LittleEndian(System.Span{System.Byte},System.Int64)">
      <summary>Escribe un valor <see cref="T:System.Int64" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.Int64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)">
      <summary>Escribe un valor <see cref="T:System.UInt16" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.UInt16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)">
      <summary>Escribe un valor <see cref="T:System.UInt16" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.UInt16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)">
      <summary>Escribe un valor <see cref="T:System.UInt32" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.UInt32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)">
      <summary>Escribe un valor <see cref="T:System.UInt32" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.UInt32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)">
      <summary>Escribe un valor <see cref="T:System.UInt64" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.UInt64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)">
      <summary>Escribe un valor <see cref="T:System.UInt64" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.UInt64" />.</exception>
    </member>
    <member name="T:System.Buffers.BuffersExtensions">
      <summary>Proporciona métodos de extensión para <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.CopyTo``1(System.Buffers.ReadOnlySequence{``0},System.Span{``0})">
      <summary>Copia el <see cref="T:System.Buffers.ReadOnlySequence`1" /> al <see cref="T:System.Span`1" /> especificado.</summary>
      <param name="source">
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> de origen.</param>
      <param name="destination">
        <see cref="T:System.Span`1" /> de destino.</param>
      <typeparam name="T">Tipo de los elementos de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</typeparam>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.PositionOf``1(System.Buffers.ReadOnlySequence{``0},``0)">
      <summary>Devuelve la posición de la primera repetición de <paramref name="item" /> en <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <param name="source">
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> de origen.</param>
      <param name="value">Elemento para buscar en el <see cref="T:System.Buffers.ReadOnlySequence`1" />.</param>
      <typeparam name="T">Tipo de los elementos de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</typeparam>
      <returns>Un objeto cuyo método <see cref="M:System.SequencePosition.GetInteger" /> devuelve la posición de la primera repetición de <paramref name="item" />, o un objeto cuya propiedad <see langword="Nullable&lt;SequencePosition&gt;.HasValue" /> es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.ToArray``1(System.Buffers.ReadOnlySequence{``0})">
      <summary>Convierte <see cref="T:System.Buffers.ReadOnlySequence`1" /> en una matriz.</summary>
      <param name="sequence">La secuencia de solo lectura para convertir en una matriz.</param>
      <typeparam name="T">Tipo de los elementos de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</typeparam>
      <returns>Matriz que contiene los datos de la secuencia de solo lectura.</returns>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.Write``1(System.Buffers.IBufferWriter{``0},System.ReadOnlySpan{``0})">
      <summary>Escribe el contenido de <paramref name="value" /> en <paramref name="writer" />.</summary>
      <param name="writer">El escritor de búfer donde se va a escribir <paramref name="value" />.</param>
      <param name="value">El intervalo de solo lectura que se escribirá en <paramref name="writer" />.</param>
      <typeparam name="T">Tipo de los elementos de <see cref="T:System.ReadOnlySpan`1" />.</typeparam>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="writer" /> es más corto que <paramref name="value" />.</exception>
    </member>
    <member name="T:System.Buffers.IBufferWriter`1">
      <summary>Representa un receptor de salida en el que se pueden escribir datos de <typeparamref name="T" />.</summary>
      <typeparam name="T">Tipo de los elementos de <see cref="T:System.Buffers.IBufferWriter`1" />.</typeparam>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.Advance(System.Int32)">
      <summary>Notifica a <see cref="T:System.Buffers.IBufferWriter`1" /> que los elementos de datos <paramref name="count" /> se han escrito en la salida <see cref="T:System.Span`1" /> o <see cref="T:System.Memory`1" />.</summary>
      <param name="count">El número de elementos de datos que se escriben en <see cref="T:System.Span`1" /> o <see cref="T:System.Memory`1" />.</param>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.GetMemory(System.Int32)">
      <summary>Devuelve un objeto <see cref="T:System.Memory`1" /> en el que escribir, que tiene al menos el tamaño solicitado (especificado por <paramref name="sizeHint" />).</summary>
      <param name="sizeHint">Longitud mínima del objeto <see cref="T:System.Memory`1" /> devuelto. Si es 0, se devuelve un búfer no vacío.</param>
      <returns>Un objeto <see cref="T:System.Memory`1" /> con al menos el tamaño <paramref name="sizeHint" />. Si <paramref name="sizeHint" /> es 0, se devuelve un búfer no vacío.</returns>
      <exception cref="T:System.OutOfMemoryException">El tamaño de búfer solicitado no está disponible.</exception>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)">
      <summary>Devuelve un objeto <see cref="T:System.Span`1" /> en el que escribir, que tiene al menos el tamaño solicitado (especificado por <paramref name="sizeHint" />).</summary>
      <param name="sizeHint">Longitud mínima del objeto <see cref="T:System.Span`1" /> devuelto. Si es 0, se devuelve un búfer no vacío.</param>
      <returns>Un objeto <see cref="T:System.Span`1" /> con al menos el tamaño <paramref name="sizeHint" />. Si <paramref name="sizeHint" /> es 0, se devuelve un búfer no vacío.</returns>
    </member>
    <member name="T:System.Buffers.MemoryPool`1">
      <summary>Representa un grupo de bloques de memoria.</summary>
      <typeparam name="T">Tipo de los elementos del bloque de memoria.</typeparam>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.#ctor">
      <summary>Construye una nueva instancia de un grupo de memoria.</summary>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Dispose">
      <summary>Libera todos los recursos que usa el grupo de memoria.</summary>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Dispose(System.Boolean)">
      <summary>Libera los recursos no administrados utilizados por el grupo de memoria y, de forma opcional, libera los recursos administrados.</summary>
      <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es  para liberar únicamente recursos no administrados.</param>
    </member>
    <member name="P:System.Buffers.MemoryPool`1.MaxBufferSize">
      <summary>Obtiene el tamaño máximo del búfer admitido por este grupo.</summary>
      <returns>Tamaño máximo de búfer admitido por este grupo.</returns>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Rent(System.Int32)">
      <summary>Devuelve un bloque de memoria capaz de contener al menos <paramref name="minBufferSize" /> elementos de T.</summary>
      <param name="minBufferSize">El número mínimo de elementos de <typeparamref name="T" /> que puede contener el grupo de memoria. Un valor de -1 devuelve un grupo de memoria establecido en el tamaño predeterminado para el grupo.</param>
      <returns>Un bloque de memoria capaz de contener al menos <paramref name="minBufferSize" /> elementos de T.</returns>
    </member>
    <member name="P:System.Buffers.MemoryPool`1.Shared">
      <summary>Obtiene una instancia singleton de un grupo de memoria basado en matrices.</summary>
      <returns>Instancia singleton de un bloque de memoria.</returns>
    </member>
    <member name="T:System.Buffers.OperationStatus">
      <summary>Define los valores que pueden devolverse desde operaciones basadas en el intervalo que admiten el procesamiento de entrada contenida en varios búferes no contiguos.</summary>
    </member>
    <member name="F:System.Buffers.OperationStatus.DestinationTooSmall">
      <summary>La entrada se procesa parcialmente, hasta lo que podría caber en el búfer de destino. El autor de llamada puede ampliar el búfer de destino, segmentar los búferes de forma adecuada y volver a intentarlo.</summary>
    </member>
    <member name="F:System.Buffers.OperationStatus.Done">
      <summary>Todo el búfer de entrada se ha procesado y la operación está completa.</summary>
    </member>
    <member name="F:System.Buffers.OperationStatus.InvalidData">
      <summary>La entrada contenía bytes no válidos que no se pudieron procesar. Si la entrada se procesa parcialmente, el destino contiene el resultado parcial. Esto garantiza que ningún dato adicional anexado a la entrada convierta la secuencia en válida.</summary>
    </member>
    <member name="F:System.Buffers.OperationStatus.NeedMoreData">
      <summary>La entrada se procesa parcialmente, hasta el último fragmento válido de la entrada que podría utilizarse. El autor de llamada puede unir las entradas restantes sin procesar con más datos, segmentar los búferes de forma adecuada y volver a intentarlo.</summary>
    </member>
    <member name="T:System.Buffers.ReadOnlySequence`1">
      <summary>Representa una secuencia que puede leer una serie secuencial de <typeparamref name="T" />.</summary>
      <typeparam name="T" />
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[])">
      <summary>Crea una instancia de <see cref="T:System.Buffers.ReadOnlySequence`1" /> a partir de <paramref name="array" />.</summary>
      <param name="array">Matriz desde la que se va a crear una secuencia de solo lectura.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[],System.Int32,System.Int32)">
      <summary>Crea una instancia de un <see cref="T:System.Buffers.ReadOnlySequence`1" /> a partir de una sección de una matriz.</summary>
      <param name="array">Matriz desde la que se va a crear la secuencia de solo lectura.</param>
      <param name="start">Índice basado en cero del primer elemento de la matriz que se va a incluir en la secuencia de solo lectura.</param>
      <param name="length">Número de elementos que se va a incluir en la secuencia de solo lectura.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.Buffers.ReadOnlySequenceSegment{`0},System.Int32,System.Buffers.ReadOnlySequenceSegment{`0},System.Int32)">
      <summary>Crea una instancia de un <see cref="T:System.Buffers.ReadOnlySequence`1" /> a partir de una lista vinculada de memoria representada por segmentos de inicio y finalización y los índices correspondientes en ellos.</summary>
      <param name="startSegment" />
      <param name="startIndex" />
      <param name="endSegment" />
      <param name="endIndex" />
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.ReadOnlyMemory{`0})">
      <summary>Crea una instancia de <see cref="T:System.Buffers.ReadOnlySequence`1" /> a partir de <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <param name="memory" />
    </member>
    <member name="F:System.Buffers.ReadOnlySequence`1.Empty">
      <summary>Devuelve una <see cref="T:System.Buffers.ReadOnlySequence`1" /> vacía</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.End">
      <summary>Obtiene la posición del final de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="T:System.Buffers.ReadOnlySequence`1.Enumerator">
      <summary>Representa un enumerador a través de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <typeparam name="T" />
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.#ctor(System.Buffers.ReadOnlySequence{`0}@)">
      <summary>Inicializa el enumerador.</summary>
      <param name="sequence">
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> que se van a enumerar.</param>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Enumerator.Current">
      <summary>Obtiene la estructura <see cref="T:System.ReadOnlyMemory`1" /> actual.</summary>
      <returns>Objeto <see cref="T:System.ReadOnlyMemory`1" /> actual.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.MoveNext">
      <summary>Se desplaza hasta el siguiente <see cref="T:System.ReadOnlyMemory`1" /> en el <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <returns>
        <see langword="true" /> si el enumerador se ha desplazado correctamente al elemento siguiente; <see langword="false" /> si se ha alcanzado el final de la secuencia.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.First">
      <summary>Obtiene el <see cref="T:System.ReadOnlyMemory`1" /> del primer segmento.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.FirstSpan">
      <summary>Obtiene el <see cref="T:System.ReadOnlySpan`1" /> del primer segmento.</summary>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetEnumerator">
      <summary>Devuelve un enumerador sobre el <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <returns>Devuelve un enumerador sobre el <see cref="T:System.Buffers.ReadOnlySequence`1" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64)">
      <summary>Devuelve un nuevo <see cref="T:System.SequencePosition" /> en un <paramref name="offset" /> desde el principio de la secuencia.</summary>
      <param name="offset" />
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64,System.SequencePosition)">
      <summary>Devuelve un nuevo <see cref="T:System.SequencePosition" /> en un <paramref name="offset" /> desde el <paramref name="origin" />.</summary>
      <param name="offset" />
      <param name="origin" />
      <returns>Un objeto nuevo que comienza en la posición <paramref name="offset" /> del objeto original.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.IsEmpty">
      <summary>Obtiene un valor que indica si la colección <see cref="T:System.Buffers.ReadOnlySequence`1" /> está vacía.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.IsSingleSegment">
      <summary>Obtiene un valor que indica si el <see cref="T:System.Buffers.ReadOnlySequence`1" /> contiene un único segmento <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <returns>
        <see langword="true" />Si la secuencia de solo lectura está vacía; en caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Length">
      <summary>Obtiene la longitud de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <returns>Longitud de la secuencia de solo lectura.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.Int32)">
      <summary>Forma un segmento del elemento actual <see cref="T:System.Buffers.ReadOnlySequence`1" /> que comienza en <paramref name="start" />, con elementos <paramref name="length" />.</summary>
      <param name="start">Índice en el que va a comenzar este segmento.</param>
      <param name="length">La longitud del segmento.</param>
      <returns>Un segmento que consta de <paramref name="length" /> elementos desde la instancia actual que empieza en el índice <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.SequencePosition)">
      <summary>Forma un segmento del elemento actual <see cref="T:System.Buffers.ReadOnlySequence`1" /> que comienza en <paramref name="start" /> y finaliza en <paramref name="end" /> (exclusivo).</summary>
      <param name="start">Índice en el que va a comenzar este segmento.</param>
      <param name="end">Final (exclusivo) <see cref="T:System.SequencePosition" /> del segmento.</param>
      <returns>Segmento que consta de elementos desde el índice <paramref name="start" /> hasta, pero sin incluir, la posición de secuencia <paramref name="end" /> de la secuencia actual de solo lectura.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64)">
      <summary>Forma un segmento del elemento <see cref="T:System.Buffers.ReadOnlySequence`1" /> actual que comienza en un índice especificado y continúa hasta el final de la secuencia de solo lectura.</summary>
      <param name="start">El índice de inicio en el que va a comenzar este segmento.</param>
      <returns>Segmento que comienza en el índice <paramref name="start" /> y continúa hasta el final de la secuencia actual de solo lectura.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.Int64)">
      <summary>Forma un segmento del <see cref="T:System.Buffers.ReadOnlySequence`1" /> proporcionado, comenzando en <paramref name="start" />, con <paramref name="length" /> elementos.</summary>
      <param name="start">Índice en el que va a comenzar este segmento.</param>
      <param name="length">La longitud del segmento.</param>
      <returns>Un segmento que consta de <paramref name="length" /> elementos desde la instancia actual que empieza en el índice <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.SequencePosition)">
      <summary>Forma un segmento del elemento actual <see cref="T:System.Buffers.ReadOnlySequence`1" /> que comienza en <paramref name="start" /> y finaliza en <paramref name="end" /> (exclusivo).</summary>
      <param name="start">Índice en el que va a comenzar este segmento.</param>
      <param name="end">Final (exclusivo) del segmento.</param>
      <returns>Segmento que consta de elementos desde el índice <paramref name="start" /> hasta, pero sin incluir, la posición de secuencia <paramref name="end" /> de la secuencia actual de solo lectura.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition)">
      <summary>Forma un segmento del elemento <see cref="T:System.Buffers.ReadOnlySequence`1" /> actual que comienza en una posición de secuencia especificada y continúa hasta el final de la secuencia de solo lectura.</summary>
      <param name="start">El <see cref="T:System.SequencePosition" /> inicial (inclusive) en el que va a comenzar este segmento.</param>
      <returns>Segmento que comienza en la posición de secuencia <paramref name="start" /> y continúa hasta el final de la secuencia actual de solo lectura.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int32)">
      <summary>Forma un segmento del elemento actual <see cref="T:System.Buffers.ReadOnlySequence`1" /> que comienza en <paramref name="start" />, con elementos <paramref name="length" />.</summary>
      <param name="start">El <see cref="T:System.SequencePosition" /> inicial (inclusive) en el que va a comenzar este segmento.</param>
      <param name="length">La longitud del segmento.</param>
      <returns>Segmento que consta de elementos <paramref name="length" /> desde la instancia actual que empieza en la posición de secuencia <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int64)">
      <summary>Forma un segmento del elemento actual <see cref="T:System.Buffers.ReadOnlySequence`1" /> que comienza en <paramref name="start" />, con elementos <paramref name="length" />.</summary>
      <param name="start">El <see cref="T:System.SequencePosition" /> inicial (inclusive) en el que va a comenzar este segmento.</param>
      <param name="length">La longitud del segmento.</param>
      <returns>Segmento que consta de elementos <paramref name="length" /> desde la instancia actual que empieza en la posición de secuencia <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.SequencePosition)">
      <summary>Forma un segmento del elemento actual <see cref="T:System.Buffers.ReadOnlySequence`1" /> que comienza en <paramref name="start" /> y finaliza en <paramref name="end" /> (exclusivo).</summary>
      <param name="start">El <see cref="T:System.SequencePosition" /> inicial (inclusive) en el que va a comenzar este segmento.</param>
      <param name="end">Final (exclusivo) <see cref="T:System.SequencePosition" /> del segmento.</param>
      <returns>Segmento que consta de elementos desde la posición de secuencia <paramref name="start" /> hasta, pero sin incluir, la posición de secuencia <paramref name="end" /> de la secuencia actual de solo lectura.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Start">
      <summary>Obtiene la posición al inicio de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.ToString" />
    <member name="M:System.Buffers.ReadOnlySequence`1.TryGet(System.SequencePosition@,System.ReadOnlyMemory{`0}@,System.Boolean)">
      <summary>Intenta recuperar el siguiente segmento después de <paramref name="position" /> y devuelve un valor que indica si la operación se realizó correctamente.</summary>
      <param name="position">La posición de la secuencia actual.</param>
      <param name="memory">Un intervalo de memoria de solo lectura que contiene el siguiente segmento después de <paramref name="position" />.</param>
      <param name="advance">
        <see langword="true" /> si <paramref name="position" /> debe estar al principio del siguiente segmento; de lo contrario, <see langword="false" />.</param>
      <returns>Devuelve <see langword="true" /> si el método devuelve el siguiente segmento, o <see langword="false" /> si se alcanzó el final de la secuencia de solo lectura.</returns>
    </member>
    <member name="T:System.Buffers.ReadOnlySequenceSegment`1">
      <summary>Representa una lista vinculada de <see cref="T:System.ReadOnlyMemory`1" /> nodos.</summary>
      <typeparam name="T" />
    </member>
    <member name="M:System.Buffers.ReadOnlySequenceSegment`1.#ctor" />
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Memory">
      <summary>Obtiene o establece un valor <see cref="T:System.ReadOnlyMemory`1" /> para el nodo actual.</summary>
      <returns>
        <see cref="T:System.ReadOnlyMemory`1" /> Valor del nodo actual.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Next">
      <summary>Obtiene o establece el siguiente nodo.</summary>
      <returns>Siguiente nodo.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.RunningIndex">
      <summary>Obtiene o establece la suma de las longitudes de nodo antes del nodo actual.</summary>
      <returns>La suma de las longitudes de nodo antes del nodo actual.</returns>
    </member>
    <member name="T:System.Buffers.SequenceReader`1">
      <summary>Proporciona métodos para leer datos binarios y de texto de <see cref="T:System.Buffers.ReadOnlySequence`1" /> con un enfoque en asignaciones de montón mínimas o nulas y en el rendimiento.</summary>
      <typeparam name="T">Tipo de la secuencia de solo lectura.</typeparam>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.#ctor(System.Buffers.ReadOnlySequence{`0})">
      <summary>Crea un objeto <see cref="T:System.Buffers.SequenceReader`1" /> sobre una interfaz <see cref="T:System.Buffers.ReadOnlySequence`1" /> especificada.</summary>
      <param name="sequence">Secuencia de solo lectura sobre la que se creará el elemento <see cref="T:System.Buffers.SequenceReader`1" />.</param>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.Advance(System.Int64)">
      <summary>Avanza el lector en un número especificado de elementos.</summary>
      <param name="count">Número de elementos que se va a avanzar.</param>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePast(`0)">
      <summary>Avanza más allá de las instancias consecutivas del elemento <paramref name="value" /> especificado.</summary>
      <param name="value">Valor más allá del cual el lector va a avanzar.</param>
      <returns>Número de posiciones que el lector ha avanzado.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0)">
      <summary>Avanza más allá de instancias consecutivas de cualquiera de los dos valores especificados.</summary>
      <param name="value0">Primer valor que se va a omitir.</param>
      <param name="value1">Segundo valor que se va a omitir.</param>
      <returns>Número de posiciones que el lector ha avanzado.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0)">
      <summary>Avanza más allá de instancias consecutivas de cualquiera de los tres valores especificados.</summary>
      <param name="value0">Primer valor que se va a omitir.</param>
      <param name="value1">Segundo valor que se va a omitir.</param>
      <param name="value2">Tercer valor que se va a omitir.</param>
      <returns>Número de posiciones que el lector ha avanzado.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0,`0)">
      <summary>Avanza más allá de instancias consecutivas de cualquiera de los cuatro valores especificados.</summary>
      <param name="value0">Primer valor que se va a omitir.</param>
      <param name="value1">Segundo valor que se va a omitir.</param>
      <param name="value2">Tercer valor que se va a omitir.</param>
      <param name="value3">Cuarto valor que se va a omitir.</param>
      <returns>Número de posiciones que el lector ha avanzado.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(System.ReadOnlySpan{`0})">
      <summary>Omite instancias consecutivas de cualquiera de los elementos <paramref name="values" /> especificados.</summary>
      <param name="values">Valores que se van a omitir.</param>
      <returns>Número de posiciones que el lector ha avanzado.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Consumed">
      <summary>Obtiene el número total de valores <typeparamref name="T" /> procesados por el lector.</summary>
      <returns>Número total de valores procesados por el lector.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.CurrentSpan">
      <summary>Obtiene un elemento <see cref="T:System.Span`1" /> que contiene el segmento actual en el elemento <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns>Intervalo que contiene el segmento actual de la secuencia.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.CurrentSpanIndex">
      <summary>Obtiene el índice en el elemento <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />.</summary>
      <returns>Índice de <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.End">
      <summary>Obtiene un valor que indica si ya no hay más datos en <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns>
        <see langword="true" />cuando no hay más datos en <see cref="P:System.Buffers.SequenceReader`1.Sequence" />; en caso contrario,. <see langword="false" /></returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.IsNext(`0,System.Boolean)">
      <summary>Comprueba si un valor especificado está en el siguiente lugar en la secuencia.</summary>
      <param name="next">Valor con el que se compararán los siguientes elementos.</param>
      <param name="advancePast">
        <see langword="true" /> para avanzar más allá de los valores de <paramref name="next" />, si se encuentran; en caso contrario, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> si los valores son los siguientes en la secuencia; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.IsNext(System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Comprueba si los valores especificados en un intervalo de solo lectura están en el siguiente lugar en la secuencia.</summary>
      <param name="next">Intervalo en el que se compararán los siguientes elementos.</param>
      <param name="advancePast">
        <see langword="true" /> para avanzar más allá de los valores de <paramref name="next" />, si se encuentran; en caso contrario, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> si los valores son los siguientes en la secuencia; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Length">
      <summary>Obtiene el número de elementos en el elemento <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> del lector.</summary>
      <returns>Recuento de elementos de la del <see cref="P:System.Buffers.SequenceReader`1.Sequence" />lector.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Position">
      <summary>Obtiene la posición actual en el elemento <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns>La posición actual en <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Remaining">
      <summary>Obtiene los elementos restantes en el elemento <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> del lector.</summary>
      <returns>Los elementos restantes de la<see cref="P:System.Buffers.SequenceReader`1.Sequence" /></returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.Rewind(System.Int64)">
      <summary>Retrocede el lector en un número especificado de elementos.</summary>
      <param name="count">Número de elementos.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> es negativo o mayor que <see cref="P:System.Buffers.SequenceReader`1.Consumed" />.</exception>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Sequence">
      <summary>Obtiene el elemento <see cref="T:System.Buffers.ReadOnlySequence`1" /> subyacente para el lector.</summary>
      <returns>Secuencia subyacente de solo lectura para el lector.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryAdvanceTo(`0,System.Boolean)">
      <summary>Busca un delimitador especificado y, opcionalmente, avanza más allá, si se encuentra.</summary>
      <param name="delimiter">Delimitador que se buscará.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> para avanzar más allá de <paramref name="delimiter" /> si se encuentra; en caso contrario, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> si se encuentra el elemento <paramref name="delimiter" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryAdvanceToAny(System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Busca cualquier número de delimitadores especificados y, opcionalmente, avanza más allá del primero que se encuentre.</summary>
      <param name="delimiters">Delimitadores que se buscarán.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> para avanzar más allá de la primera instancia de cualquier <paramref name="delimiters" /> especificado;  para no avanzar más allá del delimitador.</param>
      <returns>
        <see langword="true" /> si se ha encontrado cualquier <paramref name="delimiters" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryCopyTo(System.Span{`0})">
      <summary>Copia los datos desde la posición actual en el intervalo de destino especificado si hay suficientes datos para rellenar.</summary>
      <param name="destination">Intervalo de destino para realizar la copia.</param>
      <returns>
        <see langword="true" /> si no hay suficientes datos para rellenar completamente el intervalo <paramref name="destination" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryPeek(`0@)">
      <summary>Inspecciona el valor siguiente sin avanzar el lector.</summary>
      <param name="value">Siguiente valor, o valor predeterminado, si está al final del lector.</param>
      <returns>
        <see langword="true" /> si el lector no está al final y la operación de inspección es correcta; <see langword="false" /> si está al final del lector.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryRead(`0@)">
      <summary>Lee el siguiente valor y avanza el lector.</summary>
      <param name="value">Siguiente valor, o valor predeterminado, si está al final del lector.</param>
      <returns>
        <see langword="true" /> si el lector no está al final y la operación de lectura es correcta; <see langword="false" /> si está al final del lector.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,`0,System.Boolean)">
      <summary>Intenta leer todo hasta el elemento <paramref name="delimiter" /> especificado, omitiendo los delimitadores que van precedidos de <paramref name="delimiterEscape" />.</summary>
      <param name="sequence">El resultado que devuelve este método contiene la lectura de los datos, si los hay.</param>
      <param name="delimiter">Delimitador que se buscará.</param>
      <param name="delimiterEscape">Valor que indica que se omitirá un elemento <paramref name="delimiter" /> inmediatamente después.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> para avanzar más allá de <paramref name="delimiter" /> si se encuentra; en caso contrario, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> si se encuentra <paramref name="delimiter" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,System.Boolean)">
      <summary>Intenta leer todo hasta el elemento <paramref name="delimiter" /> especificado.</summary>
      <param name="sequence">El resultado que devuelve este método contiene la lectura de los datos, si los hay.</param>
      <param name="delimiter">Delimitador que se buscará.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> para avanzar más allá de <paramref name="delimiter" /> si se encuentra; en caso contrario, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> si se encuentra <paramref name="delimiter" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Intenta leer los datos hasta que coincide con el delimitador entero especificado como intervalo de solo lectura.</summary>
      <param name="sequence">El resultado que devuelve este método contiene la lectura de los datos, si los hay.</param>
      <param name="delimiter">Intervalo de solo lectura que contiene uno o varios delimitadores.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> para avanzar más allá de <paramref name="delimiter" /> si se encuentra; en caso contrario, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> si se encuentra <paramref name="delimiter" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,`0,System.Boolean)">
      <summary>Intenta leer todo hasta el elemento <paramref name="delimiter" /> especificado, omitiendo los delimitadores que van precedidos de <paramref name="delimiterEscape" />.</summary>
      <param name="span">El resultado que devuelve este método contiene la lectura de los datos, si los hay.</param>
      <param name="delimiter">Delimitador que se buscará.</param>
      <param name="delimiterEscape">Valor que indica que se omitirá un elemento <paramref name="delimiter" /> inmediatamente después.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> para avanzar más allá de <paramref name="delimiter" /> si se encuentra; en caso contrario, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> si se encuentra <paramref name="delimiter" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,System.Boolean)">
      <summary>Intenta leer todo hasta el elemento <paramref name="delimiter" /> especificado.</summary>
      <param name="span">El resultado que devuelve este método contiene la lectura de los datos, si los hay.</param>
      <param name="delimiter">Delimitador que se buscará.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> para avanzar más allá de <paramref name="delimiter" /> si se encuentra; en caso contrario, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> si se encuentra <paramref name="delimiter" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadToAny(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Intenta leer todo hasta cualquiera de los elementos <paramref name="delimiters" /> especificados.</summary>
      <param name="sequence">El resultado que devuelve este método contiene la lectura de los datos, si los hay.</param>
      <param name="delimiters">Delimitadores que se buscarán.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> para avanzar más allá de la primera instancia encontrada de cualquier <paramref name="delimiters" /> especificado; en caso contrario, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> si se encuentra alguno de los elementos <paramref name="delimiters" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadToAny(System.ReadOnlySpan{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Intenta leer todo hasta cualquiera de los elementos <paramref name="delimiters" /> especificados.</summary>
      <param name="span">El resultado que devuelve este método contiene la lectura de los datos, si los hay.</param>
      <param name="delimiters">Delimitadores que se buscarán.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> para avanzar más allá de la primera instancia encontrada de cualquier <paramref name="delimiters" /> especificado; en caso contrario, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> si se encuentra alguno de los elementos <paramref name="delimiters" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.UnreadSpan">
      <summary>Obtiene la parte no leída del elemento <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />.</summary>
      <returns>Parte no leída de <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />.</returns>
    </member>
    <member name="T:System.Buffers.SequenceReaderExtensions">
      <summary>Proporciona funcionalidad extendida para la clase <see cref="T:System.Buffers.SequenceReader`1" /> que permite la lectura de valores numéricos específicos endian desde los datos binarios.</summary>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int16@)">
      <summary>Intenta leer un <see cref="T:System.Int16" /> como big endian.</summary>
      <param name="reader">La instancia del lector de la secuencia de bytes desde donde se va a leer el valor.</param>
      <param name="value">Cuando el método se devuelve, el valor leído del lector de la secuencia de bytes, como big endian.</param>
      <returns>
        <see langword="true" /> si la operación de lectura se realiza correctamente; <see langword="false" /> si no hay suficientes datos para un elemento <see cref="T:System.Int16" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int32@)">
      <summary>Intenta leer un <see cref="T:System.Int32" /> como big endian.</summary>
      <param name="reader">El lector de la secuencia de bytes desde donde se leerá el valor.</param>
      <param name="value">Cuando el método se devuelve, el valor leído del lector de la secuencia de bytes, como big endian.</param>
      <returns>
        <see langword="true" /> si la operación de lectura se realiza correctamente; <see langword="false" /> si no hay suficientes datos para un elemento <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int64@)">
      <summary>Intenta leer un <see cref="T:System.Int64" /> como big endian.</summary>
      <param name="reader">La instancia del lector de la secuencia de bytes desde donde se va a leer el valor.</param>
      <param name="value">Cuando el método se devuelve, el valor leído del lector de la secuencia de bytes, como big endian.</param>
      <returns>
        <see langword="true" /> si la operación de lectura se realiza correctamente; <see langword="false" /> si no hay suficientes datos para un elemento <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int16@)">
      <summary>Intenta leer un <see cref="T:System.Int16" /> como little endian.</summary>
      <param name="reader">La instancia del lector de la secuencia de bytes desde donde se va a leer el valor.</param>
      <param name="value">Cuando el método se devuelve, el valor leído del lector de la secuencia de bytes, como little endian.</param>
      <returns>
        <see langword="true" /> si la operación de lectura se realiza correctamente; <see langword="false" /> si no hay suficientes datos para un elemento <see cref="T:System.Int16" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int32@)">
      <summary>Intenta leer un <see cref="T:System.Int32" /> como little endian.</summary>
      <param name="reader">La instancia del lector de la secuencia de bytes desde donde se va a leer el valor.</param>
      <param name="value">Cuando el método se devuelve, el valor leído del lector de la secuencia de bytes, como little endian.</param>
      <returns>
        <see langword="true" /> si la operación de lectura se realiza correctamente; <see langword="false" /> si no hay suficientes datos para un elemento <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int64@)">
      <summary>Intenta leer un <see cref="T:System.Int64" /> como little endian.</summary>
      <param name="reader">La instancia del lector de la secuencia de bytes desde donde se va a leer el valor.</param>
      <param name="value">Cuando el método se devuelve, el valor leído del lector de la secuencia de bytes, como little endian.</param>
      <returns>
        <see langword="true" /> si la operación de lectura se realiza correctamente; <see langword="false" /> si no hay suficientes datos para un elemento <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="T:System.Buffers.StandardFormat">
      <summary>Representa una cadena de formato estándar sin utilizar una cadena real.</summary>
    </member>
    <member name="M:System.Buffers.StandardFormat.#ctor(System.Char,System.Byte)">
      <summary>Inicializa una nueva instancia de la estructura <see cref="T:System.Buffers.StandardFormat" />.</summary>
      <param name="symbol">Un especificador de formato específico de tipo, como "G","D" o "X".</param>
      <param name="precision">Una precisión opcional comprendida entre 0 y 99, o bien el valor especial <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> (predeterminado).</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="symbol" /> no es <see cref="F:System.Buffers.StandardFormat.NoPrecision" />, y su valor es mayor que <see cref="F:System.Buffers.StandardFormat.MaxPrecision" />.
O bien
<paramref name="symbol" /> no se puede convertir en <see cref="T:System.Byte" />.</exception>
    </member>
    <member name="M:System.Buffers.StandardFormat.Equals(System.Buffers.StandardFormat)">
      <summary>Devuelve un valor que indica si el objeto <see cref="T:System.Buffers.StandardFormat" /> especificado es igual a la instancia actual.</summary>
      <param name="other">El formato que se va a comparar con la instancia actual.</param>
      <returns>Es <see langword="true" /> si las dos instancias son iguales; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Equals(System.Object)">
      <summary>Devuelve un valor que indica si el objeto especificado es un objeto <see cref="T:System.Buffers.StandardFormat" /> que equivale a la instancia actual.</summary>
      <param name="obj">Objeto que se va a comparar con la instancia actual.</param>
      <returns>Es <see langword="true" /> si las dos instancias son iguales; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.GetHashCode">
      <summary>Devuelve el código hash de esta instancia.</summary>
      <returns>Código hash de esta instancia.</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.HasPrecision">
      <summary>Obtiene un valor que indica si un formato tiene una precisión definida.</summary>
      <returns>
        <see langword="true" />Si el formato tiene una precisión distinta de <see cref="F:System.Buffers.StandardFormat.NoPrecision" />; en caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.IsDefault">
      <summary>Obtiene un valor que indica si la instancia actual tiene un formato predeterminado.</summary>
      <returns>
        <see langword="true" />Si la instancia actual es un formato predeterminado; en caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="F:System.Buffers.StandardFormat.MaxPrecision">
      <summary>Define el valor máximo de precisión válido.</summary>
    </member>
    <member name="F:System.Buffers.StandardFormat.NoPrecision">
      <summary>Indica que un formato no utiliza una precisión o que no se especifica la precisión.</summary>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Equality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
      <summary>Devuelve un valor que indica si dos instancias de <see cref="T:System.Buffers.StandardFormat" /> son iguales.</summary>
      <param name="left">El primer formato que se va a comparar.</param>
      <param name="right">El segundo formato que se va a comparar.</param>
      <returns>Es <see langword="true" /> si las dos instancias son iguales; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Implicit(System.Char)~System.Buffers.StandardFormat">
      <summary>Convierte un carácter en una instancia <see cref="T:System.Buffers.StandardFormat" /> mediante la precisión <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</summary>
      <param name="symbol">EL carácter que se va a convertir en un valor <see cref="T:System.Buffers.StandardFormat" />.</param>
      <returns>Un formato con una propiedad <see cref="P:System.Buffers.StandardFormat.Symbol" /> igual a <paramref name="symbol" /> y una propiedad <see cref="P:System.Buffers.StandardFormat.Precision" /> igual a <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Inequality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
      <summary>Determina si dos instancias de <see cref="T:System.Buffers.StandardFormat" /> no son iguales.</summary>
      <param name="left">El primer formato que se va a comparar.</param>
      <param name="right">El segundo formato que se va a comparar.</param>
      <returns>Es <see langword="true" /> si los dos formatos son distintos; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Parse(System.ReadOnlySpan{System.Char})">
      <summary>Convierte un carácter <see langword="ReadOnlySpan&lt;System.Char&gt;" /> en una instancia <see cref="T:System.Buffers.StandardFormat" /> mediante la precisión <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</summary>
      <param name="format">Un intervalo de solo lectura que contiene el carácter que se va a analizar.</param>
      <returns>Un valor cuyo valor de propiedad <see cref="P:System.Buffers.StandardFormat.Symbol" /> es el carácter de <paramref name="format" /> y cuyo valor de propiedad <see cref="P:System.Buffers.StandardFormat.Precision" /> es <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Parse(System.String)">
      <summary>Convierte una cadena de formato estándar de .NET clásica en una instancia <see cref="T:System.Buffers.StandardFormat" />.</summary>
      <param name="format">Una cadena de formato estándar de .NET clásica.</param>
      <returns>Un formato.</returns>
      <exception cref="T:System.FormatException">
        <paramref name="format" /> no es una cadena de formato estándar válido.</exception>
    </member>
    <member name="P:System.Buffers.StandardFormat.Precision">
      <summary>Obtiene el componente de precisión del formato.</summary>
      <returns>El componente de precisión, que puede <see cref="F:System.Buffers.StandardFormat.NoPrecision" />ser o puede oscilar entre 0 y 9.</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.Symbol">
      <summary>Obtiene el componente de carácter del formato.</summary>
      <returns>Componente de carácter del formato.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.ToString">
      <summary>Devuelve la representación en forma de cadena de este formato.</summary>
      <returns>La representación en forma de cadena de este formato.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.TryParse(System.ReadOnlySpan{System.Char},System.Buffers.StandardFormat@)">
      <summary>Intenta analizar un carácter <see langword="ReadOnlySpan&lt;Char&gt;" /> en una instancia <see cref="T:System.Buffers.StandardFormat" /> y devuelve un valor que indica si la operación de análisis se realizó correctamente.</summary>
      <param name="format">Un intervalo de solo lectura que contiene el carácter que se va a convertir.</param>
      <param name="result">Cuando este método devuelve un valor, contiene la instancia <see cref="T:System.Buffers.StandardFormat" /> analizada si la operación se realizó correctamente.</param>
      <returns>Es <see langword="true" /> si la operación de análisis se realizó correctamente; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="T:System.Buffers.Text.Base64">
      <summary>Convierte entre los datos binarios y texto codificado UTF-8 que se representa en base 64.</summary>
    </member>
    <member name="M:System.Buffers.Text.Base64.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean)">
      <summary>Descodifica el intervalo de texto codificado UTF-8 representado como base 64 en datos binarios. Si la entrada no es un múltiplo de 4, descodificará tanto como sea posible, al múltiplo más cercano de 4.</summary>
      <param name="utf8">El intervalo de entrada que contiene texto codificado UTF-8 en base 64 que tiene que descodificar.</param>
      <param name="bytes">El intervalo de salida que contiene el resultado de la operación, es decir, los datos binarios descodificados.</param>
      <param name="bytesConsumed">El número de bytes de entrada utilizados durante la operación. Esto puede usarse para segmentar la entrada en llamadas posteriores, si es necesario.</param>
      <param name="bytesWritten">El número de bytes escritos en el intervalo de salida. Esto puede usarse para segmentar la salida en llamadas posteriores, si es necesario.</param>
      <param name="isFinalBlock">
        <see langword="true" /> (predeterminado) si el intervalo de entrada contiene todos los datos para descodificar. <see langword="false" /> si el intervalo de entrada contiene datos parciales con más datos para seguir.</param>
      <returns>Uno de los valores de enumeración que indica el estado de la operación de descodificación.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.DecodeFromUtf8InPlace(System.Span{System.Byte},System.Int32@)">
      <summary>Descodifica el intervalo de texto codificado UTF-8 en base 64 (en contexto) en datos binarios. La salida binaria descodificada es menor que los datos de texto contenidos en la entrada (la operación comprime los datos). Si la entrada no es un múltiplo de 4, el método no descodificará los datos.</summary>
      <param name="buffer">El intervalo de entrada que contiene los datos de texto en base 64 que se deben descodificar.</param>
      <param name="bytesWritten">El número de bytes escritos en el búfer.</param>
      <returns>Uno de los valores de enumeración que indica el estado de la operación de descodificación.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.EncodeToUtf8(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean)">
      <summary>Codifica el intervalo de datos binarios en texto codificado UTF-8 representado como base 64.</summary>
      <param name="bytes">El intervalo de entrada que contiene los datos binarios que se deben codificar.</param>
      <param name="utf8">El intervalo de salida que contiene el resultado de la operación, es decir, el texto codificado UTF-8 en base 64.</param>
      <param name="bytesConsumed">El número de bytes de entrada utilizados durante la operación. Esto puede usarse para segmentar la entrada en llamadas posteriores, si es necesario.</param>
      <param name="bytesWritten">El número de bytes escritos en el intervalo de salida. Esto puede usarse para segmentar la salida en llamadas posteriores, si es necesario.</param>
      <param name="isFinalBlock">
        <see langword="true" /> (predeterminado) si el intervalo de entrada contiene todos los datos para codificar. <see langword="false" /> si el intervalo de entrada contiene datos parciales con más datos para seguir.</param>
      <returns>Uno de los valores de enumeración que indica el estado de la operación de codificación.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.EncodeToUtf8InPlace(System.Span{System.Byte},System.Int32,System.Int32@)">
      <summary>Codifica el intervalo de datos binarios (en contexto) en texto codificado UTF-8 representado como base 64. La salida de texto codificado es mayor que los datos binarios contenidos en la entrada (la operación expande los datos).</summary>
      <param name="buffer">El intervalo de entrada que contiene los datos binarios que se deben codificar. Dado que el método realiza una conversión en contexto, debe ser lo suficientemente grande como para almacenar el resultado de la operación.</param>
      <param name="dataLength">El número de bytes de datos binarios contenidos en el búfer que debe codificarse. Este valor debe ser menor que el tamaño del búfer.</param>
      <param name="bytesWritten">El número de bytes escritos en el búfer.</param>
      <returns>Uno de los valores de enumeración que indica el estado de la operación de codificación.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.GetMaxDecodedFromUtf8Length(System.Int32)">
      <summary>Devuelve la longitud máxima (en bytes) del resultado si fuera a descodificar el texto codificado en base 64 en un intervalo de bytes con la longitud especificada.</summary>
      <param name="length">Tamaño del intervalo de bytes.</param>
      <returns>Longitud máxima (en bytes) del resultado.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> es menor que 0.</exception>
    </member>
    <member name="M:System.Buffers.Text.Base64.GetMaxEncodedToUtf8Length(System.Int32)">
      <summary>Devuelve la longitud máxima (en bytes) del resultado si fuera a codificar datos binarios en un intervalo de bytes con la longitud especificada.</summary>
      <param name="length">Tamaño del intervalo de bytes.</param>
      <returns>Longitud máxima (en bytes) del resultado.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> es menor que 0 o mayor que 1610612733 (ya que la codificación expande los datos en 4/3).</exception>
    </member>
    <member name="T:System.Buffers.Text.Utf8Formatter">
      <summary>Proporciona métodos estáticos para dar formato a tipos de datos comunes como cadenas Utf8.</summary>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Boolean,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Da formato a un elemento <see cref="T:System.Boolean" /> como una cadena UTF8.</summary>
      <param name="value">Valor al que se va a aplicar formato.</param>
      <param name="destination">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format">Formato estándar que se usará.</param>
      <returns>
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Byte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Da formato a un elemento <see cref="T:System.Byte" /> como una cadena UTF8.</summary>
      <param name="value">Valor al que se va a aplicar formato.</param>
      <param name="destination">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format">Formato estándar que se usará.</param>
      <returns>
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTime,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Da formato a un elemento <see cref="T:System.DateTime" /> como una cadena UTF8.</summary>
      <param name="value">Valor al que se va a aplicar formato.</param>
      <param name="destination">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format">Formato estándar que se usará.</param>
      <returns>
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTimeOffset,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Da formato a un elemento <see cref="T:System.DateTimeOffset" /> como una cadena UTF8.</summary>
      <param name="value">Valor al que se va a aplicar formato.</param>
      <param name="destination">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format">Formato estándar que se usará.</param>
      <returns>
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Decimal,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Da formato a un elemento <see cref="T:System.Decimal" /> como una cadena UTF8.</summary>
      <param name="value">Valor al que se va a aplicar formato.</param>
      <param name="destination">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format">Formato estándar que se usará.</param>
      <returns>
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Double,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Da formato a un elemento <see cref="T:System.Double" /> como una cadena UTF8.</summary>
      <param name="value">Valor al que se va a aplicar formato.</param>
      <param name="destination">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format">Formato estándar que se usará.</param>
      <returns>
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Guid,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Da formato a un elemento <see cref="T:System.Guid" /> como una cadena UTF8.</summary>
      <param name="value">Valor al que se va a aplicar formato.</param>
      <param name="destination">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format">Formato estándar que se usará.</param>
      <returns>
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Da formato a un elemento <see cref="T:System.Int16" /> como una cadena UTF8.</summary>
      <param name="value">Valor al que se va a aplicar formato.</param>
      <param name="destination">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format">Formato estándar que se usará.</param>
      <returns>
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Da formato a un elemento <see cref="T:System.Int32" /> como una cadena UTF8.</summary>
      <param name="value">Valor al que se va a aplicar formato.</param>
      <param name="destination">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format">Formato estándar que se usará.</param>
      <returns>
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Da formato a un elemento <see cref="T:System.Int64" /> como una cadena UTF8.</summary>
      <param name="value">Valor al que se va a aplicar formato.</param>
      <param name="destination">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format">Formato estándar que se usará.</param>
      <returns>
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.SByte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Da formato a un elemento <see cref="T:System.SByte" /> como una cadena UTF8.</summary>
      <param name="value">Valor al que se va a aplicar formato.</param>
      <param name="destination">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format">Formato estándar que se usará.</param>
      <returns>
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Single,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Da formato a un elemento <see cref="T:System.Single" /> como una cadena UTF8.</summary>
      <param name="value">Valor al que se va a aplicar formato.</param>
      <param name="destination">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format">Formato estándar que se usará.</param>
      <returns>
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.TimeSpan,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Da formato a un elemento <see cref="T:System.TimeSpan" /> como una cadena UTF8.</summary>
      <param name="value">Valor al que se va a aplicar formato.</param>
      <param name="destination">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format">Formato estándar que se usará.</param>
      <returns>
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Da formato a un elemento <see cref="T:System.UInt16" /> como una cadena UTF8.</summary>
      <param name="value">Valor al que se va a aplicar formato.</param>
      <param name="destination">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format">Formato estándar que se usará.</param>
      <returns>
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Da formato a un elemento <see cref="T:System.UInt32" /> como una cadena UTF8.</summary>
      <param name="value">Valor al que se va a aplicar formato.</param>
      <param name="destination">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format">Formato estándar que se usará.</param>
      <returns>
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Da formato a un elemento <see cref="T:System.UInt64" /> como una cadena UTF8.</summary>
      <param name="value">Valor al que se va a aplicar formato.</param>
      <param name="destination">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format">Formato estándar que se usará.</param>
      <returns>
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="T:System.Buffers.Text.Utf8Parser">
      <summary>Proporciona métodos estáticos para analizar cadenas Utf8 para tipos de datos comunes.</summary>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Boolean@,System.Int32@,System.Char)">
      <summary>Analiza un elemento <see cref="T:System.Boolean" /> al principio de una cadena Utf8.</summary>
      <param name="source">Cadena Utf8 que se va a analizar.</param>
      <param name="value">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat">Formato esperado de la cadena Utf8.</param>
      <returns>
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Byte@,System.Int32@,System.Char)">
      <summary>Analiza un elemento <see cref="T:System.Byte" /> al principio de una cadena Utf8.</summary>
      <param name="source">Cadena Utf8 que se va a analizar.</param>
      <param name="value">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat">Formato esperado de la cadena Utf8.</param>
      <returns>
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.DateTime@,System.Int32@,System.Char)">
      <summary>Analiza un elemento <see cref="T:System.DateTime" /> al principio de una cadena Utf8.</summary>
      <param name="source">Cadena Utf8 que se va a analizar.</param>
      <param name="value">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat">Formato esperado de la cadena Utf8.</param>
      <returns>
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.DateTimeOffset@,System.Int32@,System.Char)">
      <summary>Analiza un elemento <see cref="T:System.DateTimeOffset" /> al principio de una cadena Utf8.</summary>
      <param name="source">Cadena Utf8 que se va a analizar.</param>
      <param name="value">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat">Formato esperado de la cadena Utf8.</param>
      <returns>
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Decimal@,System.Int32@,System.Char)">
      <summary>Analiza un elemento <see cref="T:System.Decimal" /> al principio de una cadena Utf8.</summary>
      <param name="source">Cadena Utf8 que se va a analizar.</param>
      <param name="value">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat">Formato esperado de la cadena Utf8.</param>
      <returns>
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Double@,System.Int32@,System.Char)">
      <summary>Analiza un elemento <see cref="T:System.Double" /> al principio de una cadena Utf8.</summary>
      <param name="source">Cadena Utf8 que se va a analizar.</param>
      <param name="value">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat">Formato esperado de la cadena Utf8.</param>
      <returns>
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Guid@,System.Int32@,System.Char)">
      <summary>Analiza un elemento <see cref="T:System.Guid" /> al principio de una cadena Utf8.</summary>
      <param name="source">Cadena Utf8 que se va a analizar.</param>
      <param name="value">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat">Formato esperado de la cadena Utf8.</param>
      <returns>
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int16@,System.Int32@,System.Char)">
      <summary>Analiza un elemento <see cref="T:System.Int16" /> al principio de una cadena Utf8.</summary>
      <param name="source">Cadena Utf8 que se va a analizar.</param>
      <param name="value">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat">Formato esperado de la cadena Utf8.</param>
      <returns>
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int32@,System.Int32@,System.Char)">
      <summary>Analiza un elemento <see cref="T:System.Int32" /> al principio de una cadena Utf8.</summary>
      <param name="source">Cadena Utf8 que se va a analizar.</param>
      <param name="value">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat">Formato esperado de la cadena Utf8.</param>
      <returns>
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int64@,System.Int32@,System.Char)">
      <summary>Analiza un elemento <see cref="T:System.Int64" /> al principio de una cadena Utf8.</summary>
      <param name="source">Cadena Utf8 que se va a analizar.</param>
      <param name="value">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat">Formato esperado de la cadena Utf8.</param>
      <returns>
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.SByte@,System.Int32@,System.Char)">
      <summary>Analiza un elemento <see cref="T:System.SByte" /> al principio de una cadena Utf8.</summary>
      <param name="source">Cadena Utf8 que se va a analizar.</param>
      <param name="value">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat">Formato esperado de la cadena Utf8.</param>
      <returns>
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Single@,System.Int32@,System.Char)">
      <summary>Analiza un elemento <see cref="T:System.Single" /> al principio de una cadena Utf8.</summary>
      <param name="source">Cadena Utf8 que se va a analizar.</param>
      <param name="value">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat">Formato esperado de la cadena Utf8.</param>
      <returns>
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.TimeSpan@,System.Int32@,System.Char)">
      <summary>Analiza un elemento <see cref="T:System.TimeSpan" /> al principio de una cadena Utf8.</summary>
      <param name="source">Cadena Utf8 que se va a analizar.</param>
      <param name="value">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat">Formato esperado de la cadena Utf8.</param>
      <returns>
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt16@,System.Int32@,System.Char)">
      <summary>Analiza un elemento <see cref="T:System.UInt16" /> al principio de una cadena Utf8.</summary>
      <param name="source">Cadena Utf8 que se va a analizar.</param>
      <param name="value">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat">Formato esperado de la cadena Utf8.</param>
      <returns>
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt32@,System.Int32@,System.Char)">
      <summary>Analiza un elemento <see cref="T:System.UInt32" /> al principio de una cadena Utf8.</summary>
      <param name="source">Cadena Utf8 que se va a analizar.</param>
      <param name="value">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat">Formato esperado de la cadena Utf8.</param>
      <returns>
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt64@,System.Int32@,System.Char)">
      <summary>Analiza un elemento <see cref="T:System.UInt64" /> al principio de una cadena Utf8.</summary>
      <param name="source">Cadena Utf8 que se va a analizar.</param>
      <param name="value">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat">Formato esperado de la cadena Utf8.</param>
      <returns>
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="T:System.MemoryExtensions">
      <summary>Proporciona métodos de extensión para los tipos relativos a la memoria y el intervalo, como <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />, <see cref="T:System.Span`1" /> y <see cref="T:System.ReadOnlySpan`1" />.</summary>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String)">
      <summary>Crea un objeto <see langword="ReadOnlyMemory&lt;Char&gt;" /> en la parte de la cadena de destino.</summary>
      <param name="text">Cadena de destino.</param>
      <returns>Representación de memoria de caracteres de solo lectura de la cadena, o <see langword="default" /> si <paramref name="text" /> es <see langword="null" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Index)">
      <summary>Crea un objeto <see langword="ReadOnlyMemory&lt;Char&gt;" /> en una parte de la cadena de destino a partir de un índice especificado.</summary>
      <param name="text">Cadena de destino.</param>
      <param name="startIndex">Índice en el que va a comenzar este segmento.</param>
      <returns>Representación de memoria de caracteres de solo lectura de la cadena.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32)">
      <summary>Crea un objeto <see langword="ReadOnlyMemory&lt;Char&gt;" /> en una parte de la cadena de destino a partir de una posición de caracteres especificada.</summary>
      <param name="text">Cadena de destino.</param>
      <param name="start">Índice en el que va a comenzar este segmento.</param>
      <returns>Representación de memoria de caracteres de solo lectura de la cadena, o <see langword="default" /> si <paramref name="text" /> es <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> no está en el intervalo de <paramref name="text" /> (<paramref name="start" /> es &lt; 0 o &gt; <c>text.Length</c>).</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32,System.Int32)">
      <summary>Crea un objeto <see langword="ReadOnlyMemory&lt;Char&gt;" /> en una parte de la cadena de destino a partir de una posición especificada con una longitud.</summary>
      <param name="text">Cadena de destino.</param>
      <param name="start">Índice en el que va a comenzar este segmento.</param>
      <param name="length">Longitud deseada del segmento.</param>
      <returns>Representación de memoria de caracteres de solo lectura de la cadena, o <see langword="default" /> si <paramref name="text" /> es <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> o <paramref name="start" /> + <paramref name="length" /> no están en el intervalo de <paramref name="text" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Range)">
      <summary>Crea un objeto <see langword="ReadOnlyMemory&lt;Char&gt;" /> en un intervalo especificado de la cadena de destino.</summary>
      <param name="text">Cadena de destino.</param>
      <param name="range">Intervalo que indica el inicio y la longitud de la cadena segmentada.</param>
      <returns>Representación de memoria de caracteres de solo lectura de la cadena.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[])">
      <summary>Crea una región de memoria en la matriz de destino.</summary>
      <param name="array">Matriz que se va a convertir.</param>
      <typeparam name="T">Tipo de matriz.</typeparam>
      <returns>Representación de memoria de la totalidad o parte de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Index)">
      <summary>Crea una región de memoria en la parte de la matriz de destino a partir de un índice especificado y hasta el final de la matriz.</summary>
      <param name="array">Matriz que se va a convertir.</param>
      <param name="startIndex">Primera posición de la matriz.</param>
      <typeparam name="T">Tipo de matriz.</typeparam>
      <returns>Representación de memoria de la totalidad o parte de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32)">
      <summary>Crea una región de memoria en la parte de la matriz de destino a partir de una posición especificada y hasta el final de la matriz.</summary>
      <param name="array">Matriz de destino.</param>
      <param name="start">Índice en el que va a comenzar la memoria.</param>
      <typeparam name="T">Tipo de matriz.</typeparam>
      <returns>Representación de memoria de la totalidad o parte de la matriz.</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="array" /> es covariante, y el tipo de matriz no es exactamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">El índice <paramref name="start" /> es menor que 0 o mayor que <see langword="array.Length" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32,System.Int32)">
      <summary>Crea una región de memoria en la parte de la matriz de destino a partir de una posición especificada y con una longitud especificada.</summary>
      <param name="array">Matriz de destino.</param>
      <param name="start">Índice donde comienza la región de memoria.</param>
      <param name="length">Número de elementos de la región de memoria.</param>
      <typeparam name="T">Tipo de matriz.</typeparam>
      <returns>Representación de memoria de la totalidad o parte de la matriz.</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="array" /> es covariante, y el tipo de matriz no es exactamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> o <paramref name="start" /> + <paramref name="length" /> no están en el intervalo de <paramref name="array" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Range)">
      <summary>Crea una región de memoria en la parte de la matriz de destino que comienza en el índice de inicio inclusivo del intervalo y termina en el índice de finalización exclusivo del intervalo.</summary>
      <param name="array">Matriz que se va a convertir.</param>
      <param name="range">Intervalo que se va a convertir de la matriz.</param>
      <typeparam name="T">Tipo de matriz.</typeparam>
      <returns>Representación de memoria de la totalidad o parte de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0})">
      <summary>Crea una región de memoria en la parte del segmento de matriz de destino.</summary>
      <param name="segment">Segmento que se va a convertir.</param>
      <typeparam name="T">Tipo del segmento.</typeparam>
      <returns>Representación de memoria del segmento.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32)">
      <summary>Crea una región de memoria en la parte del segmento de la matriz de destino a partir de una posición especificada hasta el final del segmento.</summary>
      <param name="segment">Segmento de la matriz de destino.</param>
      <param name="start">Índice en el que va a comenzar la memoria.</param>
      <typeparam name="T">Tipo de matriz.</typeparam>
      <returns>Representación de memoria de la totalidad o parte de la matriz.</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="segment" /> es covariante y el tipo de <paramref name="segment" /> no es exactamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> es menor que 0 o mayor que <see langword="segment.Count" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32,System.Int32)">
      <summary>Crea una región de memoria en la parte del segmento de la matriz de destino a partir de una posición especificada y con una longitud especificada.</summary>
      <param name="segment">Segmento de la matriz de destino.</param>
      <param name="start">Índice en el que va a comenzar la memoria.</param>
      <param name="length">Número de elementos de la memoria.</param>
      <typeparam name="T">Tipo de matriz.</typeparam>
      <returns>Representación de memoria de la totalidad o parte de la matriz.</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="segment" /> es covariante, y el tipo de matriz no es exactamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> o <paramref name="start" /> + <paramref name="length" /> no están en el intervalo de <paramref name="segment" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String)">
      <summary>Crea un intervalo de solo lectura en una parte de la cadena de destino a partir de una posición especificada y con un número de caracteres especificado.</summary>
      <param name="text">Cadena de destino.</param>
      <returns>Representación de intervalo de solo lectura de la cadena.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32)">
      <summary>Crea un intervalo de solo lectura en una parte de la cadena de destino desde una posición especificada hasta el final de la cadena.</summary>
      <param name="text">Cadena de destino.</param>
      <param name="start">Índice en el que va a comenzar este segmento.</param>
      <returns>Representación de intervalo de solo lectura de la cadena.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="text" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> es menor que 0 o mayor que <see langword="text.Length" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32,System.Int32)">
      <summary>Crea un intervalo de solo lectura en una cadena.</summary>
      <param name="text">Cadena de destino.</param>
      <param name="start">Índice en el que va a comenzar este segmento.</param>
      <param name="length">Longitud deseada del segmento.</param>
      <returns>Representación de intervalo de solo lectura de la cadena.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> o <paramref name="start" /> + <paramref name="length" /> no están en el intervalo de <paramref name="text" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[])">
      <summary>Crea un intervalo en una matriz de destino.</summary>
      <param name="array">Matriz que se va a convertir.</param>
      <typeparam name="T">Tipo de matriz.</typeparam>
      <returns>Representación de intervalo de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Index)">
      <summary>Crea un intervalo en la parte de la matriz de destino definida por un valor de <see cref="T:System.Index" />.</summary>
      <param name="array">Matriz que se va a convertir.</param>
      <param name="startIndex">Índice de inicio.</param>
      <typeparam name="T">Tipo de matriz.</typeparam>
      <returns>Representación de intervalo de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32)">
      <summary>Crea un intervalo en una parte de la matriz de destino a partir de una posición especificada y hasta el final de la matriz.</summary>
      <param name="array">Matriz que se va a convertir.</param>
      <param name="start">Índice inicial desde el que se convertirá la matriz.</param>
      <typeparam name="T">Tipo de matriz.</typeparam>
      <returns>Representación de intervalo de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32,System.Int32)">
      <summary>Crea un intervalo en la parte de la matriz de destino a partir de una posición especificada y con una longitud especificada.</summary>
      <param name="array">Matriz de destino.</param>
      <param name="start">Índice en el que va a comenzar el intervalo.</param>
      <param name="length">Número de elementos del intervalo.</param>
      <typeparam name="T">Tipo de matriz.</typeparam>
      <returns>Representación de intervalo de la matriz.</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="array" /> es covariante, y el tipo de matriz no es exactamente <see langword="T[]" />".</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> o <paramref name="start" /> + <paramref name="length" /> no están en el intervalo de <paramref name="text" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Range)">
      <summary>Crea un intervalo en una parte de una matriz de destino definida por un valor de <see cref="T:System.Range" />.</summary>
      <param name="array">Matriz que se va a convertir.</param>
      <param name="range">Intervalo de la matriz que se va a convertir.</param>
      <typeparam name="T">Tipo de matriz.</typeparam>
      <returns>Representación de intervalo de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0})">
      <summary>Crea un intervalo en un segmento de la matriz de destino.</summary>
      <param name="segment">Segmento de la matriz que se va a convertir.</param>
      <typeparam name="T">Tipo del segmento de la matriz.</typeparam>
      <returns>Representación de intervalo del segmento de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Index)">
      <summary>Crea un intervalo en una parte del segmento de la matriz de destino a partir de un índice especificado y hasta el final del segmento.</summary>
      <param name="segment">Segmento de la matriz de destino.</param>
      <param name="startIndex">Índice en el que va a comenzar el intervalo.</param>
      <typeparam name="T">Tipo del segmento de la matriz.</typeparam>
      <returns>Representación de intervalo del segmento de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32)">
      <summary>Crea un intervalo en una parte de un segmento de la matriz de destino a partir de una posición especificada hasta el final del segmento.</summary>
      <param name="segment">Segmento de la matriz de destino.</param>
      <param name="start">Índice en el que va a comenzar el intervalo.</param>
      <typeparam name="T">Tipo del segmento de la matriz.</typeparam>
      <returns>Representación de intervalo del segmento de la matriz.</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="segment" /> es covariante, y el tipo de matriz no es exactamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> es menor que 0 o mayor que <see langword="segment.Count" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32,System.Int32)">
      <summary>Crea un intervalo en una parte de un segmento de una matriz de destino a partir de una posición especificada y con una longitud especificada.</summary>
      <param name="segment">Segmento de la matriz de destino.</param>
      <param name="start">Índice en el que va a comenzar el intervalo.</param>
      <param name="length">Número de elementos del intervalo.</param>
      <typeparam name="T">Tipo del segmento de la matriz.</typeparam>
      <returns>Representación de intervalo de la matriz.</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="segment" /> es covariante, y el tipo de matriz no es exactamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> o <paramref name="start" /> + <paramref name="length" /> no están en el intervalo de <paramref name="segment" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Range)">
      <summary>Crea un intervalo en una parte de un segmento de la matriz de destino usando los índices inicial y final del intervalo.</summary>
      <param name="segment">Segmento de la matriz de destino.</param>
      <param name="range">Intervalo que tiene los índices inicial y final que se van a usar para segmentar la matriz.</param>
      <typeparam name="T">Tipo del segmento de la matriz.</typeparam>
      <returns>Representación de intervalo del segmento de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``1(System.ReadOnlySpan{``0},System.IComparable{``0})">
      <summary>Busca un valor en un objeto <see cref="T:System.ReadOnlySpan`1" /> ordenado completo, utilizando la interfaz genérica <see cref="T:System.IComparable`1" /> especificada.</summary>
      <param name="span">Objeto <see cref="T:System.ReadOnlySpan`1" /> ordenado que se va a buscar.</param>
      <param name="comparable">Objeto <see cref="T:System.IComparable`1" /> que se va a utilizar en la comparación.</param>
      <typeparam name="T">Tipo de elemento del intervalo.</typeparam>
      <returns>Índice de base cero de <paramref name="comparable" /> en la <paramref name="span" /> ordenada, si es que se encuentra <paramref name="comparable" />; en caso contrario, número negativo que es el complemento bit a bit del índice del siguiente elemento mayor que <paramref name="comparable" /> o, si no hay ningún elemento mayor, el complemento bit a bit de <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``1(System.Span{``0},System.IComparable{``0})">
      <summary>Busca un valor en un objeto <see cref="T:System.Span`1" /> ordenado completo, utilizando la interfaz genérica <see cref="T:System.IComparable`1" /> especificada.</summary>
      <param name="span">Objeto <see cref="T:System.Span`1" /> ordenado que se va a buscar.</param>
      <param name="comparable">Objeto <see cref="T:System.IComparable`1" /> que se va a utilizar en la comparación.</param>
      <typeparam name="T">Tipo de elemento del intervalo.</typeparam>
      <returns>Índice de base cero de <paramref name="comparable" /> en la <paramref name="span" /> ordenada, si es que se encuentra <paramref name="comparable" />; en caso contrario, número negativo que es el complemento bit a bit del índice del siguiente elemento mayor que <paramref name="comparable" /> o, si no hay ningún elemento mayor, el complemento bit a bit de <see cref="P:System.Span`1.Length" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``0,``1)">
      <summary>Busca un valor especificado en un objeto <see cref="T:System.ReadOnlySpan`1" /> ordenado completo, utilizando el tipo genérico <typeparamref name="TComparer" /> especificada.</summary>
      <param name="span">Objeto <see cref="T:System.ReadOnlySpan`1" /> ordenado que se va a buscar.</param>
      <param name="value">Objeto que se va a buscar. El valor puede ser <see langword="null" /> para los tipos de referencia.</param>
      <param name="comparer">Objeto <typeparamref name="TComparer" /> que se va a utilizar en la comparación.</param>
      <typeparam name="T">Tipo de elemento del intervalo.</typeparam>
      <typeparam name="TComparer">Tipo específico de <see cref="T:System.Collections.Generic.IComparer`1" />.</typeparam>
      <returns>Índice de base cero de <paramref name="value" /> en la <paramref name="span" /> ordenada, si es que se encuentra <paramref name="value" />; en caso contrario, número negativo que es el complemento bit a bit del índice del siguiente elemento mayor que <paramref name="value" /> o, si no hay ningún elemento mayor, el complemento bit a bit de <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparer" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``1)">
      <summary>Busca un valor en un objeto <see cref="T:System.ReadOnlySpan`1" /> ordenado completo, utilizando el tipo genérico <typeparamref name="TComparable" /> especificada.</summary>
      <param name="span">Objeto <see cref="T:System.ReadOnlySpan`1" /> ordenado que se va a buscar.</param>
      <param name="comparable">Objeto <typeparamref name="TComparable" /> que se va a utilizar en la comparación.</param>
      <typeparam name="T">Tipo de elemento del intervalo.</typeparam>
      <typeparam name="TComparable">Tipo específico de <see cref="T:System.IComparable`1" />.</typeparam>
      <returns>Índice de base cero de <paramref name="comparable" /> en la <paramref name="span" /> ordenada, si es que se encuentra <paramref name="comparable" />; en caso contrario, número negativo que es el complemento bit a bit del índice del siguiente elemento mayor que <paramref name="comparable" /> o, si no hay ningún elemento mayor, el complemento bit a bit de <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``0,``1)">
      <summary>Busca un valor especificado en un objeto <see cref="T:System.Span`1" /> ordenado completo, utilizando el tipo genérico <typeparamref name="TComparer" /> especificada.</summary>
      <param name="span">Objeto <see cref="T:System.Span`1" /> ordenado que se va a buscar.</param>
      <param name="value">Objeto que se va a buscar. El valor puede ser <see langword="null" /> para los tipos de referencia.</param>
      <param name="comparer">Objeto <typeparamref name="TComparer" /> que se va a utilizar en la comparación.</param>
      <typeparam name="T">Tipo de elemento del intervalo.</typeparam>
      <typeparam name="TComparer">Tipo específico de <see cref="T:System.Collections.Generic.IComparer`1" />.</typeparam>
      <returns>Índice de base cero de <paramref name="value" /> en la <paramref name="span" /> ordenada, si es que se encuentra <paramref name="value" />; en caso contrario, número negativo que es el complemento bit a bit del índice del siguiente elemento mayor que <paramref name="value" /> o, si no hay ningún elemento mayor, el complemento bit a bit de <see cref="P:System.Span`1.Length" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparer" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``1)">
      <summary>Busca un valor en un objeto <see cref="T:System.Span`1" /> ordenado completo, utilizando el tipo genérico <typeparamref name="TComparable" /> especificada.</summary>
      <param name="span">Objeto <see cref="T:System.Span`1" /> ordenado que se va a buscar.</param>
      <param name="comparable">Objeto <typeparamref name="TComparable" /> que se va a utilizar en la comparación.</param>
      <typeparam name="T">Tipo de elemento del intervalo.</typeparam>
      <typeparam name="TComparable">Tipo específico de <see cref="T:System.IComparable`1" />.</typeparam>
      <returns>Índice de base cero de <paramref name="comparable" /> en la <paramref name="span" /> ordenada, si es que se encuentra <paramref name="comparable" />; en caso contrario, número negativo que es el complemento bit a bit del índice del siguiente elemento mayor que <paramref name="comparable" /> o, si no hay ningún elemento mayor, el complemento bit a bit de <see cref="P:System.Span`1.Length" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.CompareTo(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Compara un intervalo de caracteres con otro utilizando una comparación de cadenas especificada, y devuelve un entero que indica su posición relativa en el criterio de ordenación.</summary>
      <param name="span">Intervalo de origen.</param>
      <param name="other">Valor que se va a comparar con el intervalo de origen.</param>
      <param name="comparisonType">Valor de enumeración que determina cómo se comparan <paramref name="span" /> y <paramref name="other" />.</param>
      <returns>Entero con signo que indica el orden relativo de <paramref name="span" /> y <paramref name="other" />:   - Si es menor que 0, <paramref name="span" /> va delante de <paramref name="other" />.   - Si es 0, <paramref name="span" /> es igual que <paramref name="other" />.   - Si es mayor que 0, <paramref name="span" /> va detrás de <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Indica si un valor especificado aparece dentro de un intervalo de caracteres de solo lectura.</summary>
      <param name="span">Intervalo de origen.</param>
      <param name="value">Valor que se va a buscar dentro del intervalo de origen.</param>
      <param name="comparisonType">Valor de enumeración que determina cómo se comparan los caracteres en <paramref name="span" /> y <paramref name="value" />.</param>
      <returns>
        <see langword="true" /> si <paramref name="value" /> aparece en el intervalo; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains``1(System.ReadOnlySpan{``0},``0)">
      <summary>Indica si un valor especificado se encuentra en un intervalo de solo lectura. Los valores se comparan mediante IEquatable{T}.Equals(T).</summary>
      <param name="span">Intervalo que se va a buscar.</param>
      <param name="value">Valor que se va a buscar.</param>
      <typeparam name="T">Tipo del intervalo.</typeparam>
      <returns>
        <see langword="true" /> si se encuentra; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains``1(System.Span{``0},``0)">
      <summary>Indica si un valor especificado se encuentra en un intervalo. Los valores se comparan mediante IEquatable{T}.Equals(T).</summary>
      <param name="span">Intervalo que se va a buscar.</param>
      <param name="value">Valor que se va a buscar.</param>
      <typeparam name="T">Tipo de los elementos del intervalo.</typeparam>
      <returns>
        <see langword="true" /> si se encuentra; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Memory{``0})">
      <summary>Copia el contenido de la matriz en una región de memoria.</summary>
      <param name="source">Matriz de la que copiar elementos.</param>
      <param name="destination">Matriz en la que copiar elementos.</param>
      <typeparam name="T">Tipo de matriz.</typeparam>
      <exception cref="T:System.ArgumentException">El destino es más corto que la matriz de origen.</exception>
    </member>
    <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Span{``0})">
      <summary>Copia el contenido de la matriz en el intervalo.</summary>
      <param name="source">Matriz de la que copiar elementos.</param>
      <param name="destination">El intervalo en el que copiar los elementos.</param>
      <typeparam name="T">Tipo de matriz.</typeparam>
      <exception cref="T:System.ArgumentException">El intervalo de destino es más corto que la matriz de origen.</exception>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Determina si el final de <paramref name="span" /> coincide con el objeto <paramref name="value" /> especificado cuando se comparan usando la opción <paramref name="comparisonType" /> especificada.</summary>
      <param name="span">Intervalo de origen.</param>
      <param name="value">Secuencia que se va a comparar con el final del intervalo de origen.</param>
      <param name="comparisonType">Valor de enumeración que determina cómo se comparan <paramref name="span" /> y <paramref name="value" />.</param>
      <returns>
        <see langword="true" /> si <paramref name="value" /> coincide con la propiedad <paramref name="span" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Determina si la secuencia especificada aparece al final de un intervalo de solo lectura.</summary>
      <param name="span">Intervalo de origen.</param>
      <param name="value">Secuencia que se va a comparar con el final del intervalo de origen.</param>
      <typeparam name="T">Tipo del intervalo.</typeparam>
      <returns>
        <see langword="true" /> si <paramref name="value" /> coincide con la propiedad <paramref name="span" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Determina si la secuencia especificada aparece al final de un intervalo.</summary>
      <param name="span">Intervalo de origen.</param>
      <param name="value">Secuencia que se va a comparar con el final del intervalo de origen.</param>
      <typeparam name="T">Tipo del intervalo.</typeparam>
      <returns>
        <see langword="true" /> si <paramref name="value" /> coincide con la propiedad <paramref name="span" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EnumerateRunes(System.ReadOnlySpan{System.Char})">
      <summary>Devuelve una enumeración de <see cref="T:System.Text.Rune" /> a partir del intervalo de solo lectura proporcionado.</summary>
      <param name="span">Intervalo de origen.</param>
      <returns>Enumerador Rune.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EnumerateRunes(System.Span{System.Char})">
      <summary>Devuelve una enumeración de <see cref="T:System.Text.Rune" /> a partir del intervalo proporcionado.</summary>
      <param name="span">Intervalo de origen.</param>
      <returns>Enumerador Rune.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Equals(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Determina si este objeto <paramref name="span" /> y el intervalo <paramref name="other" /> especificado tienen los mismos caracteres cuando se comparan usando la opción <paramref name="comparisonType" /> especificada.</summary>
      <param name="span">Intervalo de origen.</param>
      <param name="other">Valor que se va a comparar con el intervalo de origen.</param>
      <param name="comparisonType">Valor de enumeración que determina cómo se comparan <paramref name="span" /> y <paramref name="other" />.</param>
      <returns>
        <see langword="true" /> si son iguales; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Devuelve el índice de base cero de la primera aparición del objeto <paramref name="value" /> especificado en el objeto <paramref name="span" /> actual.</summary>
      <param name="span">Intervalo de origen.</param>
      <param name="value">Valor que se va a buscar dentro del intervalo de origen.</param>
      <param name="comparisonType">Valor de enumeración que determina cómo se comparan <paramref name="span" /> y <paramref name="value" />.</param>
      <returns>Índice de la aparición del valor en el intervalo.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},``0)">
      <summary>Busca el valor especificado y devuelve el índice de su primera aparición. Los valores se comparan mediante IEquatable{T}.Equals(T).</summary>
      <param name="span">Intervalo que se va a buscar.</param>
      <param name="value">Valor que se va a buscar.</param>
      <typeparam name="T">Tipo del intervalo y del valor.</typeparam>
      <returns>Índice de la aparición del valor en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Busca la secuencia especificada y devuelve el índice de su primera aparición. Los valores se comparan mediante IEquatable{T}.Equals(T).</summary>
      <param name="span">Intervalo que se va a buscar.</param>
      <param name="value">Secuencia que se va a buscar.</param>
      <typeparam name="T">Tipo del intervalo y del valor.</typeparam>
      <returns>Índice de la aparición del valor en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},``0)">
      <summary>Busca el valor especificado y devuelve el índice de su primera aparición. Los valores se comparan mediante IEquatable{T}.Equals(T).</summary>
      <param name="span">Intervalo que se va a buscar.</param>
      <param name="value">Valor que se va a buscar.</param>
      <typeparam name="T">Tipo del intervalo y del valor.</typeparam>
      <returns>Índice de la aparición del valor en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Busca la secuencia especificada y devuelve el índice de su primera aparición. Los valores se comparan mediante IEquatable{T}.Equals(T).</summary>
      <param name="span">Intervalo que se va a buscar.</param>
      <param name="value">Secuencia que se va a buscar.</param>
      <typeparam name="T">Tipo del intervalo y del valor.</typeparam>
      <returns>Índice de la aparición del valor en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
      <summary>Busca el primer índice de cualquiera de los valores especificados, similar a llamar a IndexOf varias veces con el operador lógico OR.</summary>
      <param name="span">Intervalo que se va a buscar.</param>
      <param name="value0">Uno de los valores de que se va a buscar.</param>
      <param name="value1">Uno de los valores de que se va a buscar.</param>
      <typeparam name="T">Tipo del intervalo y de los valores.</typeparam>
      <returns>Primer índice de la aparición de cualquiera de los valores del intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
      <summary>Busca el primer índice de cualquiera de los valores especificados, similar a llamar a IndexOf varias veces con el operador lógico OR.</summary>
      <param name="span">Intervalo que se va a buscar.</param>
      <param name="value0">Uno de los valores de que se va a buscar.</param>
      <param name="value1">Uno de los valores de que se va a buscar.</param>
      <param name="value2">Uno de los valores de que se va a buscar.</param>
      <typeparam name="T">Tipo del intervalo y de los valores.</typeparam>
      <returns>Primer índice de la aparición de cualquiera de los valores del intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Busca el primer índice de cualquiera de los valores especificados, similar a llamar a IndexOf varias veces con el operador lógico OR.</summary>
      <param name="span">Intervalo que se va a buscar.</param>
      <param name="values">Conjunto de valores que se va a buscar.</param>
      <typeparam name="T">Tipo del intervalo y de los valores.</typeparam>
      <returns>Primer índice de la aparición de cualquiera de los valores del intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0)">
      <summary>Busca el primer índice de cualquiera de los valores especificados, similar a llamar a IndexOf varias veces con el operador lógico OR.</summary>
      <param name="span">Intervalo que se va a buscar.</param>
      <param name="value0">Uno de los valores de que se va a buscar.</param>
      <param name="value1">Uno de los valores de que se va a buscar.</param>
      <typeparam name="T">Tipo del intervalo y de los valores.</typeparam>
      <returns>Primer índice de la aparición de cualquiera de los valores del intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0,``0)">
      <summary>Busca el primer índice de cualquiera de los valores especificados, similar a llamar a IndexOf varias veces con el operador lógico OR.</summary>
      <param name="span">Intervalo que se va a buscar.</param>
      <param name="value0">Uno de los valores de que se va a buscar.</param>
      <param name="value1">Uno de los valores de que se va a buscar.</param>
      <param name="value2">Uno de los valores de que se va a buscar.</param>
      <typeparam name="T">Tipo del intervalo y de los valores.</typeparam>
      <returns>Primer índice de la aparición de cualquiera de los valores del intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Busca el primer índice de cualquiera de los valores especificados, similar a llamar a IndexOf varias veces con el operador lógico OR.</summary>
      <param name="span">Intervalo que se va a buscar.</param>
      <param name="values">Conjunto de valores que se va a buscar.</param>
      <typeparam name="T">Tipo del intervalo y de los valores.</typeparam>
      <returns>Primer índice de la aparición de cualquiera de los valores del intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IsWhiteSpace(System.ReadOnlySpan{System.Char})">
      <summary>Indica si el intervalo especificado contiene solo caracteres de espacio en blanco.</summary>
      <param name="span">Intervalo de origen.</param>
      <returns>
        <see langword="true" /> si el intervalo solo contiene caracteres de espacio en blanco; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Devuelve el índice de base cero de la última aparición del objeto <paramref name="value" /> especificado en el objeto <paramref name="span" /> actual.</summary>
      <param name="span">Intervalo de origen.</param>
      <param name="value">Valor que se va a buscar dentro del intervalo de origen.</param>
      <param name="comparisonType">Valor de enumeración que determina cómo se comparan <paramref name="span" /> y <paramref name="value" />.</param>
      <returns>Índice de la última aparición del valor en el intervalo.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},``0)">
      <summary>Busca el valor especificado y devuelve el índice de su última aparición. Los valores se comparan mediante IEquatable{T}.Equals(T).</summary>
      <param name="span">Intervalo que se va a buscar.</param>
      <param name="value">Valor que se va a buscar.</param>
      <typeparam name="T">Tipo del intervalo y del valor.</typeparam>
      <returns>Índice de la última aparición del valor en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Busca la secuencia especificada y devuelve el índice de su última aparición. Los valores se comparan mediante IEquatable{T}.Equals(T).</summary>
      <param name="span">Intervalo que se va a buscar.</param>
      <param name="value">Secuencia que se va a buscar.</param>
      <typeparam name="T">Tipo del intervalo y del valor.</typeparam>
      <returns>Índice de la última aparición del valor en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},``0)">
      <summary>Busca el valor especificado y devuelve el índice de su última aparición. Los valores se comparan mediante IEquatable{T}.Equals(T).</summary>
      <param name="span">Intervalo que se va a buscar.</param>
      <param name="value">Valor que se va a buscar.</param>
      <typeparam name="T">Tipo del intervalo y del valor.</typeparam>
      <returns>Índice de la última aparición del valor en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Busca la secuencia especificada y devuelve el índice de su última aparición. Los valores se comparan mediante IEquatable{T}.Equals(T).</summary>
      <param name="span">Intervalo que se va a buscar.</param>
      <param name="value">Secuencia que se va a buscar.</param>
      <typeparam name="T">Tipo del intervalo y del valor.</typeparam>
      <returns>Índice de la última aparición del valor en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
      <summary>Busca el último índice de cualquiera de los valores especificados, similar a llamar a LastIndexOf varias veces con el operador lógico OR.</summary>
      <param name="span">Intervalo que se va a buscar.</param>
      <param name="value0">Uno de los valores de que se va a buscar.</param>
      <param name="value1">Uno de los valores de que se va a buscar.</param>
      <typeparam name="T">Tipo del intervalo y de los valores.</typeparam>
      <returns>Índice de la última aparición de cualquiera de los valores en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
      <summary>Busca el último índice de cualquiera de los valores especificados, similar a llamar a LastIndexOf varias veces con el operador lógico OR.</summary>
      <param name="span">Intervalo que se va a buscar.</param>
      <param name="value0">Uno de los valores de que se va a buscar.</param>
      <param name="value1">Uno de los valores de que se va a buscar.</param>
      <param name="value2">Uno de los valores de que se va a buscar.</param>
      <typeparam name="T">Tipo del intervalo y de los valores.</typeparam>
      <returns>Índice de la última aparición de cualquiera de los valores en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Busca el último índice de cualquiera de los valores especificados, similar a llamar a LastIndexOf varias veces con el operador lógico OR.</summary>
      <param name="span">Intervalo que se va a buscar.</param>
      <param name="values">Conjunto de valores que se va a buscar.</param>
      <typeparam name="T">Tipo del intervalo y de los valores.</typeparam>
      <returns>Índice de la última aparición de cualquiera de los valores en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0)">
      <summary>Busca el último índice de cualquiera de los valores especificados, similar a llamar a LastIndexOf varias veces con el operador lógico OR.</summary>
      <param name="span">Intervalo que se va a buscar.</param>
      <param name="value0">Uno de los valores de que se va a buscar.</param>
      <param name="value1">Uno de los valores de que se va a buscar.</param>
      <typeparam name="T">Tipo del intervalo y de los valores.</typeparam>
      <returns>Índice de la última aparición de cualquiera de los valores en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0,``0)">
      <summary>Busca el último índice de cualquiera de los valores especificados, similar a llamar a LastIndexOf varias veces con el operador lógico OR.</summary>
      <param name="span">Intervalo que se va a buscar.</param>
      <param name="value0">Uno de los valores de que se va a buscar.</param>
      <param name="value1">Uno de los valores de que se va a buscar.</param>
      <param name="value2">Uno de los valores de que se va a buscar.</param>
      <typeparam name="T">Tipo del intervalo y de los valores.</typeparam>
      <returns>Índice de la última aparición de cualquiera de los valores en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Busca el último índice de cualquiera de los valores especificados, similar a llamar a LastIndexOf varias veces con el operador lógico OR.</summary>
      <param name="span">Intervalo que se va a buscar.</param>
      <param name="values">Conjunto de valores que se va a buscar.</param>
      <typeparam name="T">Tipo del intervalo y de los valores.</typeparam>
      <returns>Índice de la última aparición de cualquiera de los valores en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Determina si dos secuencias de solo lectura se superponen en la memoria.</summary>
      <param name="span">Primera secuencia.</param>
      <param name="other">Segunda secuencia.</param>
      <typeparam name="T">Tipo de elementos en la secuencia de solo lectura.</typeparam>
      <returns>
        <see langword="true" /> si las dos secuencias se superponen; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Int32@)">
      <summary>Determina si dos secuencias de solo lectura se superponen en la memoria y genera el desplazamiento del elemento.</summary>
      <param name="span">Primera secuencia.</param>
      <param name="other">Segunda secuencia.</param>
      <param name="elementOffset" />
      <typeparam name="T">Tipo de elementos del intervalo.</typeparam>
      <returns>
        <see langword="true" /> si las dos secuencias se superponen; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Determina si un intervalo y un intervalo de solo lectura se superponen en la memoria.</summary>
      <param name="span">Intervalo que se va a comparar.</param>
      <param name="other">Intervalo de solo lectura que se va a comparar.</param>
      <typeparam name="T">Tipo de elementos del intervalo.</typeparam>
      <returns>
        <see langword="true" /> si las dos secuencias se superponen; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0},System.Int32@)">
      <summary>Determina si un intervalo y un intervalo de solo lectura se superponen en la memoria y genera el desplazamiento del elemento.</summary>
      <param name="span">Primera secuencia que se va a comparar.</param>
      <param name="other">Segunda secuencia que se va a comparar.</param>
      <param name="elementOffset">Cuando el método finaliza, contiene el desplazamiento entre <paramref name="span" /> y <paramref name="other" />.</param>
      <typeparam name="T">Tipo de elementos del intervalo.</typeparam>
      <returns>
        <see langword="true" /> si las dos secuencias se superponen; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Reverse``1(System.Span{``0})">
      <summary>Invierte la secuencia de los elementos de todo el intervalo.</summary>
      <param name="span">Intervalo que se va a invertir.</param>
      <typeparam name="T">Tipo de elementos del intervalo.</typeparam>
    </member>
    <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Determina el orden relativo de dos secuencias de solo lectura, comparando sus elementos mediante IComparable{T}.CompareTo(T).</summary>
      <param name="span">Primera secuencia que se va a comparar.</param>
      <param name="other">Segunda secuencia que se va a comparar.</param>
      <typeparam name="T">Tipo de los elementos de la secuencia.</typeparam>
      <returns>Entero con signo que indica el orden relativo de <paramref name="span" /> y <paramref name="other" />:   - Si es menor que 0, <paramref name="span" /> va delante de <paramref name="other" />.   - Si es 0, <paramref name="span" /> es igual que <paramref name="other" />.   - Si es mayor que 0, <paramref name="span" /> va detrás de <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Determina el orden relativo de dos secuencias de solo lectura, comparando sus elementos mediante IComparable{T}.CompareTo(T).</summary>
      <param name="span">Intervalo que se va a comparar.</param>
      <param name="other">Intervalo de solo lectura que se va a comparar.</param>
      <typeparam name="T">Tipo de elementos del intervalo.</typeparam>
      <returns>Entero con signo que indica el orden relativo de <paramref name="span" /> y <paramref name="other" />:   - Si es menor que 0, <paramref name="span" /> va delante de <paramref name="other" />.   - Si es 0, <paramref name="span" /> es igual que <paramref name="other" />.   - Si es mayor que 0, <paramref name="span" /> va detrás de <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceEqual``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Determina si dos secuencias de solo lectura son iguales comparando los elementos mediante IEquatable{T}.Equals(T).</summary>
      <param name="span">Primera secuencia que se va a comparar.</param>
      <param name="other">Segunda secuencia que se va a comparar.</param>
      <typeparam name="T">Tipo de los elementos de la secuencia.</typeparam>
      <returns>
        <see langword="true" /> si las dos secuencias son iguales; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceEqual``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Determina si un intervalo y un intervalo de solo lectura son iguales comparando los elementos mediante IEquatable{T}.Equals(T).</summary>
      <param name="span">Intervalo que se va a comparar.</param>
      <param name="other">Intervalo de solo lectura que se va a comparar.</param>
      <typeparam name="T">Tipo de los elementos de la secuencia.</typeparam>
      <returns>
        <see langword="true" /> si las dos secuencias son iguales; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Determina si un intervalo de caracteres de solo lectura comienza por un valor especificado cuando se comparan utilizando un valor <see cref="T:System.StringComparison" /> especificado.</summary>
      <param name="span">Intervalo de origen.</param>
      <param name="value">Secuencia que se va a comparar con el inicio del intervalo de origen.</param>
      <param name="comparisonType">Valor de enumeración que determina cómo se comparan <paramref name="span" /> y <paramref name="value" />.</param>
      <returns>
        <see langword="true" /> si <paramref name="value" /> coincide con el principio de <paramref name="span" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Determina si una secuencia especificada aparece al inicio de un intervalo de solo lectura.</summary>
      <param name="span">Intervalo de caracteres de solo lectura que se va a buscar.</param>
      <param name="value">Secuencia que se va a buscar al inicio de <paramref name="span" />.</param>
      <typeparam name="T">Tipo de elementos del intervalo.</typeparam>
      <returns>
        <see langword="true" /> si <paramref name="value" /> coincide con el principio de <paramref name="span" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Determina si una secuencia especificada aparece al inicio de un intervalo.</summary>
      <param name="span">Intervalo que se va a buscar.</param>
      <param name="value">Secuencia que se va a buscar al inicio de <paramref name="span" />.</param>
      <typeparam name="T">Tipo de los elementos del intervalo.</typeparam>
      <returns>
        <see langword="true" /> si <paramref name="value" /> coincide con el principio de <paramref name="span" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToLower(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
      <summary>Copia los caracteres del intervalo de origen en el destino, convirtiendo cada carácter en minúsculas mediante las reglas de mayúsculas y minúsculas de la referencia cultural especificada.</summary>
      <param name="source">Intervalo de origen.</param>
      <param name="destination">Intervalo de destino que contiene los caracteres transformados.</param>
      <param name="culture">Objeto que proporciona reglas de mayúsculas y minúsculas específicas de la referencia cultural.</param>
      <returns>Número de caracteres escritos en el intervalo de destino. Si el destino es demasiado pequeño, devuelve -1.</returns>
      <exception cref="T:System.InvalidOperationException">Los búferes de origen y destino se superponen.</exception>
    </member>
    <member name="M:System.MemoryExtensions.ToLowerInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
      <summary>Copia los caracteres del intervalo de origen en el destino, convirtiendo cada carácter en minúsculas mediante las reglas de mayúsculas y minúsculas de la referencia cultural invariable.</summary>
      <param name="source">Intervalo de origen.</param>
      <param name="destination">Intervalo de destino que contiene los caracteres transformados.</param>
      <returns>Número de caracteres escritos en el intervalo de destino. Si el destino es demasiado pequeño, devuelve -1.</returns>
      <exception cref="T:System.InvalidOperationException">Los búferes de origen y destino se superponen.</exception>
    </member>
    <member name="M:System.MemoryExtensions.ToUpper(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
      <summary>Copia los caracteres del intervalo de origen en el destino, convirtiendo cada carácter en mayúsculas mediante las reglas de mayúsculas y minúsculas de la referencia cultural especificada.</summary>
      <param name="source">Intervalo de origen.</param>
      <param name="destination">Intervalo de destino que contiene los caracteres transformados.</param>
      <param name="culture">Objeto que proporciona reglas de mayúsculas y minúsculas específicas de la referencia cultural.</param>
      <returns>Número de caracteres escritos en el intervalo de destino. Si el destino es demasiado pequeño, devuelve -1.</returns>
      <exception cref="T:System.InvalidOperationException">Los búferes de origen y destino se superponen.</exception>
    </member>
    <member name="M:System.MemoryExtensions.ToUpperInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
      <summary>Copia los caracteres del intervalo de origen en el destino, convirtiendo cada carácter en mayúsculas mediante las reglas de mayúsculas y minúsculas de la referencia cultural invariable.</summary>
      <param name="source">Intervalo de origen.</param>
      <param name="destination">Intervalo de destino que contiene los caracteres transformados.</param>
      <returns>Número de caracteres escritos en el intervalo de destino. Si el destino es demasiado pequeño, devuelve -1.</returns>
      <exception cref="T:System.InvalidOperationException">Los búferes de origen y destino se superponen.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.Memory{System.Char})">
      <summary>Quita todos los caracteres de espacio en blanco iniciales y finales de una región de memoria de caracteres.</summary>
      <param name="memory">Memoria de origen de la que se quitan los caracteres.</param>
      <returns>Región de memoria de caracteres recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlyMemory{System.Char})">
      <summary>Quita todos los caracteres de espacio en blanco iniciales y finales de una región de memoria de caracteres de solo lectura.</summary>
      <param name="memory">Memoria de origen de la que se quitan los caracteres.</param>
      <returns>Región de memoria de caracteres recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char})">
      <summary>Quita todos los caracteres de espacio en blanco iniciales y finales de un intervalo de caracteres de solo lectura.</summary>
      <param name="span">Intervalo de origen del que se quitan los caracteres.</param>
      <returns>Intervalo de caracteres de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.Char)">
      <summary>Quita todas las apariciones iniciales y finales de un carácter especificado de un intervalo de caracteres de solo lectura.</summary>
      <param name="span">Intervalo de origen del que se quita el carácter.</param>
      <param name="trimChar">Carácter especificado que se va a buscar y quitar.</param>
      <returns>Intervalo de caracteres de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>Quita de un intervalo de caracteres de solo lectura todas las apariciones iniciales y finales de un conjunto de caracteres especificados en un intervalo de solo lectura.</summary>
      <param name="span">Intervalo de origen del que se quitan los caracteres.</param>
      <param name="trimChars">Intervalo que contiene el conjunto de caracteres que se va a quitar.</param>
      <returns>Intervalo de caracteres de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.Span{System.Char})">
      <summary>Quita todos los caracteres de espacio en blanco iniciales y finales de un intervalo de caracteres.</summary>
      <param name="span">Intervalo de origen del que se quitan los caracteres.</param>
      <returns>Intervalo de caracteres recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Memory{``0},``0)">
      <summary>Quita todas las apariciones iniciales y finales de un elemento especificado de una región de memoria.</summary>
      <param name="memory">Memoria de origen de la que se quita el elemento.</param>
      <param name="trimElement">Elemento especificado que se va a buscar y quitar.</param>
      <typeparam name="T">Tipo de los elementos de la región de memoria.</typeparam>
      <returns>Región de memoria recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary>Quita de una región de memoria todas las apariciones iniciales y finales de un conjunto de elementos especificados en un intervalo de solo lectura.</summary>
      <param name="memory">Memoria de origen de la que se quitan los elementos.</param>
      <param name="trimElements">Intervalo que contiene el conjunto de elementos que se va a quitar.</param>
      <typeparam name="T">Tipo de los elementos de la región de memoria.</typeparam>
      <returns>Región de memoria recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},``0)">
      <summary>Quita todas las apariciones iniciales y finales de un elemento especificado de una región de memoria de solo lectura.</summary>
      <param name="memory">Memoria de origen de la que se quita el elemento.</param>
      <param name="trimElement">Elemento especificado que se va a buscar y quitar.</param>
      <typeparam name="T">Tipo de los elementos de la región de memoria de solo lectura.</typeparam>
      <returns>Región de memoria de solo lectura recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary>Quita de una región de memoria de solo lectura todas las apariciones iniciales y finales de un conjunto de elementos especificados en un intervalo de solo lectura.</summary>
      <param name="memory">Memoria de origen de la que se quitan los elementos.</param>
      <param name="trimElements">Intervalo que contiene el conjunto de elementos que se va a quitar.</param>
      <typeparam name="T">Tipo de los elementos de la región de memoria de solo lectura.</typeparam>
      <returns>Región de memoria de solo lectura recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},``0)">
      <summary>Quita todas las apariciones iniciales y finales de un elemento especificado de un intervalo de solo lectura.</summary>
      <param name="span">Intervalo de origen del que se quita el elemento.</param>
      <param name="trimElement">Elemento especificado que se va a buscar y quitar.</param>
      <typeparam name="T">Tipo de los elementos del intervalo de solo lectura.</typeparam>
      <returns>Intervalo de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Quita de un intervalo de solo lectura todas las apariciones iniciales y finales de un conjunto de elementos especificados en un intervalo de solo lectura.</summary>
      <param name="span">Intervalo de origen del que se quitan los elementos.</param>
      <param name="trimElements">Intervalo que contiene el conjunto de elementos que se va a quitar.</param>
      <typeparam name="T">Tipo de los elementos del intervalo de solo lectura.</typeparam>
      <returns>Intervalo de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Span{``0},``0)">
      <summary>Quita todas las apariciones iniciales y finales de un elemento especificado de un intervalo.</summary>
      <param name="span">Intervalo de origen del que se quita el elemento.</param>
      <param name="trimElement">Elemento especificado que se va a buscar y quitar.</param>
      <typeparam name="T">Tipo de los elementos del intervalo.</typeparam>
      <returns>Intervalo recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Quita de un intervalo todas las apariciones iniciales y finales de un conjunto de elementos especificados en un intervalo de solo lectura.</summary>
      <param name="span">Intervalo de origen del que se quitan los elementos.</param>
      <param name="trimElements">Intervalo que contiene el conjunto de elementos que se va a quitar.</param>
      <typeparam name="T">Tipo de los elementos del intervalo.</typeparam>
      <returns>Intervalo recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.Memory{System.Char})">
      <summary>Quita todos los caracteres de espacio en blanco finales de una región de memoria de caracteres.</summary>
      <param name="memory">Memoria de origen de la que se quitan los caracteres.</param>
      <returns>Región de memoria de caracteres recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlyMemory{System.Char})">
      <summary>Quita todos los caracteres de espacio en blanco finales de una región de memoria de caracteres de solo lectura.</summary>
      <param name="memory">Memoria de origen de la que se quitan los caracteres.</param>
      <returns>Intervalo de caracteres de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char})">
      <summary>Quita todos los caracteres de espacio en blanco finales de un intervalo de caracteres de solo lectura.</summary>
      <param name="span">Intervalo de origen del que se quitan los caracteres.</param>
      <returns>Intervalo de caracteres de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.Char)">
      <summary>Quita todas las apariciones finales de un carácter especificado de un intervalo de solo lectura.</summary>
      <param name="span">Intervalo de origen del que se quita el carácter.</param>
      <param name="trimChar">Carácter especificado que se va a buscar y quitar.</param>
      <returns>Intervalo de caracteres de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>Quita de un intervalo de caracteres de solo lectura todas las apariciones finales de un conjunto de caracteres especificados en un intervalo de solo lectura.</summary>
      <param name="span">Intervalo de origen del que se quitan los caracteres.</param>
      <param name="trimChars">Intervalo que contiene el conjunto de caracteres que se va a quitar.</param>
      <returns>Intervalo de caracteres de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.Span{System.Char})">
      <summary>Quita todos los caracteres de espacio en blanco finales de un intervalo de caracteres.</summary>
      <param name="span">Intervalo de origen del que se quitan los caracteres.</param>
      <returns>Intervalo de caracteres recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},``0)">
      <summary>Quita todas las apariciones finales de un elemento especificado de una región de memoria de caracteres.</summary>
      <param name="memory">Memoria de origen de la que se quita el elemento.</param>
      <param name="trimElement">Elemento especificado que se va a buscar y quitar.</param>
      <typeparam name="T">Tipo de los elementos de la región de memoria.</typeparam>
      <returns>Región de memoria recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary>Quita de una región de memoria todas las apariciones finales de un conjunto de elementos especificados en un intervalo de solo lectura.</summary>
      <param name="memory">Memoria de origen de la que se quitan los elementos.</param>
      <param name="trimElements">Intervalo que contiene el conjunto de elementos que se va a quitar.</param>
      <typeparam name="T">Tipo de los elementos de la región de memoria.</typeparam>
      <returns>Región de memoria recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},``0)">
      <summary>Quita todas las apariciones finales de un elemento especificado de una región de memoria de solo lectura.</summary>
      <param name="memory">Memoria de origen de la que se quita el elemento.</param>
      <param name="trimElement">Elemento especificado que se va a buscar y quitar.</param>
      <typeparam name="T">Tipo de los elementos de la región de memoria de solo lectura.</typeparam>
      <returns>Región de memoria de solo lectura recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary>Quita de una región de memoria de solo lectura todas las apariciones finales de un conjunto de elementos especificados en un intervalo de solo lectura.</summary>
      <param name="memory">Memoria de origen de la que se quitan los elementos.</param>
      <param name="trimElements">Intervalo que contiene el conjunto de elementos que se va a quitar.</param>
      <typeparam name="T">Tipo de los elementos de la región de memoria de solo lectura.</typeparam>
      <returns>Región de memoria de solo lectura recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},``0)">
      <summary>Quita todas las apariciones finales de un elemento especificado de un intervalo de solo lectura.</summary>
      <param name="span">Intervalo de origen del que se quita el elemento.</param>
      <param name="trimElement">Elemento especificado que se va a buscar y quitar.</param>
      <typeparam name="T">Tipo de los elementos del intervalo de solo lectura.</typeparam>
      <returns>Intervalo de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Quita de un intervalo de solo lectura todas las apariciones finales de un conjunto de elementos especificados en un intervalo de solo lectura.</summary>
      <param name="span">Intervalo de origen del que se quitan los elementos.</param>
      <param name="trimElements">Intervalo que contiene el conjunto de elementos que se va a quitar.</param>
      <typeparam name="T">Tipo de los elementos del intervalo de solo lectura.</typeparam>
      <returns>Intervalo de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},``0)">
      <summary>Quita todas las apariciones finales de un elemento especificado de un intervalo.</summary>
      <param name="span">Intervalo de origen del que se quita el elemento.</param>
      <param name="trimElement">Elemento especificado que se va a buscar y quitar.</param>
      <typeparam name="T">Tipo de los elementos del intervalo.</typeparam>
      <returns>Intervalo recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Quita de un intervalo todas las apariciones finales de un conjunto de elementos especificados en un intervalo de solo lectura.</summary>
      <param name="span">Intervalo de origen del que se quitan los elementos.</param>
      <param name="trimElements">Intervalo que contiene el conjunto de elementos que se va a quitar.</param>
      <typeparam name="T">Tipo de los elementos del intervalo.</typeparam>
      <returns>Intervalo recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.Memory{System.Char})">
      <summary>Quita todos los caracteres de espacio en blanco iniciales de una región de memoria.</summary>
      <param name="memory">Memoria de origen de la que se quitan los caracteres.</param>
      <returns>Región de memoria de caracteres recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlyMemory{System.Char})">
      <summary>Quita todos los caracteres de espacio en blanco iniciales de una región de memoria de solo lectura.</summary>
      <param name="memory">Memoria de origen de la que se quitan los caracteres.</param>
      <returns>Región de memoria de caracteres de solo lectura recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char})">
      <summary>Quita todos los caracteres de espacio en blanco iniciales de un intervalo de solo lectura.</summary>
      <param name="span">Intervalo de origen del que se quitan los caracteres.</param>
      <returns>Intervalo de caracteres de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.Char)">
      <summary>Quita todas las apariciones iniciales de un carácter especificado de un intervalo.</summary>
      <param name="span">Intervalo de origen del que se quita el carácter.</param>
      <param name="trimChar">Carácter especificado que se va a buscar y quitar.</param>
      <returns>Intervalo de caracteres de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>Quita del intervalo todas las apariciones iniciales de un conjunto de caracteres especificados en un intervalo de solo lectura.</summary>
      <param name="span">Intervalo de origen del que se quitan los caracteres.</param>
      <param name="trimChars">Intervalo que contiene el conjunto de caracteres que se va a quitar.</param>
      <returns>Intervalo de caracteres de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.Span{System.Char})">
      <summary>Quita todos los caracteres de espacio en blanco iniciales de un intervalo.</summary>
      <param name="span">Intervalo de origen del que se quitan los caracteres.</param>
      <returns>Intervalo de caracteres recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},``0)">
      <summary>Quita todas las apariciones iniciales de un elemento especificado de una región de memoria.</summary>
      <param name="memory">Región de memoria de origen de la que se quita el elemento.</param>
      <param name="trimElement">Elemento especificado que se va a buscar y quitar.</param>
      <typeparam name="T">Tipo de los elementos de la región de memoria.</typeparam>
      <returns>Región de memoria recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary>Quita de una región de memoria todas las apariciones iniciales de un conjunto de elementos especificados en un intervalo de solo lectura.</summary>
      <param name="memory">Memoria de origen de la que se quitan los elementos.</param>
      <param name="trimElements">Intervalo que contiene el conjunto de elementos que se va a quitar.</param>
      <typeparam name="T">Tipo de los elementos de la región de memoria.</typeparam>
      <returns>Región de memoria recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},``0)">
      <summary>Quita todas las apariciones iniciales de un elemento especificado de una región de memoria.</summary>
      <param name="memory">Memoria de origen de la que se quita el elemento.</param>
      <param name="trimElement">Elemento especificado que se va a buscar y quitar.</param>
      <typeparam name="T">Tipo de los elementos de la región de memoria de solo lectura.</typeparam>
      <returns>Región de memoria de solo lectura recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary>Quita de una región de memoria todas las apariciones iniciales de un conjunto de elementos especificados en un intervalo de solo lectura.</summary>
      <param name="memory">Memoria de origen de la que se quitan los elementos.</param>
      <param name="trimElements">Intervalo que contiene el conjunto de elementos que se va a quitar.</param>
      <typeparam name="T">Tipo de los elementos de la región de memoria de solo lectura.</typeparam>
      <returns>Región de memoria de solo lectura recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},``0)">
      <summary>Quita todas las apariciones iniciales de un elemento especificado del intervalo.</summary>
      <param name="span">Intervalo de origen del que se quita el elemento.</param>
      <param name="trimElement">Elemento especificado que se va a buscar y quitar.</param>
      <typeparam name="T">Tipo de los elementos del intervalo de solo lectura.</typeparam>
      <returns>Intervalo de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Quita del intervalo todas las apariciones iniciales de un conjunto de elementos especificados en un intervalo de solo lectura.</summary>
      <param name="span">Intervalo de origen del que se quitan los elementos.</param>
      <param name="trimElements">Intervalo que contiene el conjunto de elementos que se va a quitar.</param>
      <typeparam name="T">Tipo de los elementos del intervalo de solo lectura.</typeparam>
      <returns>Intervalo de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},``0)">
      <summary>Quita todas las apariciones iniciales de un elemento especificado del intervalo.</summary>
      <param name="span">Intervalo de origen del que se quita el elemento.</param>
      <param name="trimElement">Elemento especificado que se va a buscar y quitar.</param>
      <typeparam name="T">Tipo de los elementos del intervalo.</typeparam>
      <returns>Intervalo recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Quita del intervalo todas las apariciones iniciales de un conjunto de elementos especificados en un intervalo de solo lectura.</summary>
      <param name="span">Intervalo de origen del que se quitan los elementos.</param>
      <param name="trimElements">Intervalo que contiene el conjunto de elementos que se va a quitar.</param>
      <typeparam name="T">Tipo de los elementos del intervalo.</typeparam>
      <returns>Intervalo recortado.</returns>
    </member>
    <member name="T:System.Runtime.InteropServices.MemoryMarshal">
      <summary>Proporciona métodos para interoperar con <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />, <see cref="T:System.Span`1" />, y <see cref="T:System.ReadOnlySpan`1" />.</summary>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.ReadOnlySpan{``0})">
      <summary>Convierte un <see cref="T:System.ReadOnlySpan`1" /> de un tipo primitivo, <paramref name="T" />, a un <see langword="ReadOnlySpan&lt;Byte&gt;" />.</summary>
      <param name="span">El segmento de origen para convertir.</param>
      <typeparam name="T">Tipo de elementos del intervalo de solo lectura.</typeparam>
      <returns>Un intervalo de solo lectura de tipo <see cref="T:System.Byte" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> contiene referencias o punteros.</exception>
      <exception cref="T:System.OverflowException">La propiedad <see cref="P:System.ReadOnlySpan`1.Length" /> del nuevo <see cref="T:System.ReadOnlySpan`1" /> superaría <see cref="F:System.Int32.MaxValue" /></exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.Span{``0})">
      <summary>Convierte un <see cref="T:System.Span`1" /> de un tipo primitivo, <paramref name="T" />, a un <see langword="Span&lt;Byte&gt;" />.</summary>
      <param name="span">El segmento de origen para convertir.</param>
      <typeparam name="T">Tipo de elementos del intervalo.</typeparam>
      <returns>Un intervalo de tipo <see cref="T:System.Byte" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> contiene referencias o punteros.</exception>
      <exception cref="T:System.OverflowException">La propiedad <see cref="P:System.Span`1.Length" /> del nuevo <see cref="T:System.Span`1" /> superaría <see cref="F:System.Int32.MaxValue" /></exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsMemory``1(System.ReadOnlyMemory{``0})">
      <summary>Crea una instancia de <see cref="T:System.Memory`1" /> a partir de un <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <param name="memory">El búfer de memoria de solo lectura.</param>
      <typeparam name="T">Tipo de elementos del búfer de memoria de solo lectura.</typeparam>
      <returns>Bloque de memoria que representa la misma memoria que <see cref="T:System.ReadOnlyMemory`1" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.ReadOnlySpan{System.Byte})">
      <summary>Reinterpreta un intervalo de bytes de solo lectura como una referencia de solo lectura a la estructura de tipo <paramref name="T" />.</summary>
      <param name="span">Intervalo de solo lectura que se va a reinterpretar.</param>
      <typeparam name="T">Tipo de la referencia devuelta.</typeparam>
      <returns>Referencia de solo lectura a la estructura de tipo <paramref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.Span{System.Byte})">
      <summary>Reinterpreta un intervalo de bytes como una referencia a la estructura de tipo <paramref name="T" />.</summary>
      <param name="span">Intervalo que se va a reinterpretar.</param>
      <typeparam name="T">Tipo de la referencia devuelta.</typeparam>
      <returns>Referencia a la estructura de tipo <paramref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.ReadOnlySpan{``0})">
      <summary>Convierte un intervalo de solo lectura de un tipo primitivo a un intervalo de solo lectura de otro tipo primitivo.</summary>
      <param name="span">El segmento de origen para convertir.</param>
      <typeparam name="TFrom">Tipo del intervalo de origen.</typeparam>
      <typeparam name="TTo">Tipo del intervalo de destino.</typeparam>
      <returns>El intervalo de solo lectura convertido.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="TFrom" /> o <paramref name="TTo" /> contiene referencias o punteros.</exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.Span{``0})">
      <summary>Convierte un intervalo de un tipo primitivo a un intervalo de otro tipo primitivo.</summary>
      <param name="span">El segmento de origen para convertir.</param>
      <typeparam name="TFrom">Tipo del intervalo de origen.</typeparam>
      <typeparam name="TTo">Tipo del intervalo de destino.</typeparam>
      <returns>El intervalo convertido.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="TFrom" /> o <paramref name="TTo" /> contiene referencias o punteros.</exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateFromPinnedArray``1(``0[],System.Int32,System.Int32)">
      <summary>Crea un nuevo búfer de memoria sobre la parte de la matriz de destino anclada previamente que empieza en el índice <paramref name="start" /> y contiene <paramref name="length" /> elementos.</summary>
      <param name="array">La matriz de origen previamente anclada.</param>
      <param name="start">El índice de <paramref name="array" /> donde comienza el bloque de memoria.</param>
      <param name="length">El número de elementos para incluir en el bloque de memoria.</param>
      <typeparam name="T">Tipo de matriz.</typeparam>
      <returns>Un bloque de memoria sobre los elementos especificados de <paramref name="array" />. Si <paramref name="array" /> es <see langword="null" />, o si <paramref name="start" /> y <paramref name="length" /> son 0, el método devuelve una instancia <see cref="T:System.Memory`1" /> de <see cref="P:System.Memory`1.Length" /> cero.</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="array" /> es covariante y el tipo de <paramref name="array" /> no es exactamente <paramref name="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">El <paramref name="start" /> o el índice final no está en el intervalo de 0 a <see cref="P:System.Array.Length" />.</exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan``1(``0@,System.Int32)">
      <summary>Crea un intervalo de solo lectura sobre una parte de un objeto administrado normal.</summary>
      <param name="reference">Una referencia a los datos.</param>
      <param name="length">Número de elementos de <paramref name="T" /> que contiene <paramref name="reference" />.</param>
      <typeparam name="T">Tipo de los elementos de datos.</typeparam>
      <returns>Un intervalo de solo lectura.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateSpan``1(``0@,System.Int32)">
      <summary>Crea un nuevo intervalo sobre una parte de un objeto administrado normal.</summary>
      <param name="reference">Una referencia a los datos.</param>
      <param name="length">Número de elementos de <paramref name="T" /> que contiene <paramref name="reference" />.</param>
      <typeparam name="T">Tipo de los elementos de datos.</typeparam>
      <returns>Un intervalo.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.ReadOnlySpan{``0})">
      <summary>Devuelve una referencia al elemento del intervalo de solo lectura en el índice cero.</summary>
      <param name="span">El intervalo de solo lectura desde el que se recupera la referencia.</param>
      <typeparam name="T">Tipo de elementos del intervalo.</typeparam>
      <returns>Una referencia al elemento en el índice 0.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.Span{``0})">
      <summary>Devuelve una referencia al elemento del intervalo en el índice 0.</summary>
      <param name="span">El intervalo desde el que se recupera la referencia.</param>
      <typeparam name="T">Tipo de elementos del intervalo.</typeparam>
      <returns>Una referencia al elemento en el índice 0.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Read``1(System.ReadOnlySpan{System.Byte})">
      <summary>Lee una estructura de tipo <param name="T" /> fuera de un intervalo de solo lectura de bytes.</summary>
      <param name="source">Un intervalo de solo lectura.</param>
      <typeparam name="T">Tipo del elemento que se va a recuperar del intervalo de solo lectura.</typeparam>
      <returns>La estructura recuperada del intervalo de solo lectura.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> contiene referencias o punteros.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> es menor que <paramref name="T" />.</exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.ToEnumerable``1(System.ReadOnlyMemory{``0})">
      <summary>Crea una vista <see cref="T:System.Collections.Generic.IEnumerable`1" /> del búfer de memoria de solo lectura especificado.</summary>
      <param name="memory">Un búfer de memoria de solo lectura.</param>
      <typeparam name="T">Tipo de los elementos en el búfer de memoria de solo lectura.</typeparam>
      <returns>Vista enumerable de <paramref name="memory" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetArray``1(System.ReadOnlyMemory{``0},System.ArraySegment{``0}@)">
      <summary>Intenta obtener un segmento de matriz desde el búfer de memoria subyacente. El valor devuelto indica si la operación se completó correctamente.</summary>
      <param name="memory">Un búfer de memoria de solo lectura.</param>
      <param name="segment">Cuando se devuelve este método, contiene el segmento de matrices recuperado del búfer de memoria de solo lectura subyacente. Si se produce un error en el método, el método devuelve un segmento de matriz predeterminado.</param>
      <typeparam name="T">Tipo de elementos del búfer de memoria de solo lectura.</typeparam>
      <returns>
        <see langword="true" /> si la llamada al método se realiza correctamente; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@)">
      <summary>Intenta recuperar un <see cref="T:System.Buffers.MemoryManager`1" /> desde el búfer de memoria de solo lectura subyacente.</summary>
      <param name="memory">El búfer de memoria de solo lectura para el que se va a obtener el administrador de memoria.</param>
      <param name="manager">Cuando el método finaliza, administrador de <paramref name="memory" />.</param>
      <typeparam name="T">Tipo de los elementos en el búfer de memoria de solo lectura.</typeparam>
      <typeparam name="TManager">Tipo del <see cref="T:System.Buffers.MemoryManager`1" /> que se va a recuperar.</typeparam>
      <returns>
        <see langword="true" /> si el método recuperó el administrador de memoria; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@,System.Int32@,System.Int32@)">
      <summary>Intenta recuperar un <see cref="T:System.Buffers.MemoryManager`1" />, iniciar un índice y una longitud desde el búfer de memoria de solo lectura subyacente.</summary>
      <param name="memory">El búfer de memoria de solo lectura para el que se va a obtener el administrador de memoria.</param>
      <param name="manager">Cuando el método finaliza, administrador de <paramref name="memory" />.</param>
      <param name="start">Cuando el método finaliza, desplazamiento desde el principio de <paramref name="manager" /> que representa <paramref name="memory" />.</param>
      <param name="length">Cuando el método finaliza, longitud de <paramref name="manager" /> que representa <paramref name="memory" />.</param>
      <typeparam name="T">Tipo de los elementos en el búfer de memoria de solo lectura.</typeparam>
      <typeparam name="TManager">Tipo del <see cref="T:System.Buffers.MemoryManager`1" /> que se va a recuperar.</typeparam>
      <returns>Es <see langword="true" /> si el método se ha ejecutado correctamente; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetString(System.ReadOnlyMemory{System.Char},System.String@,System.Int32@,System.Int32@)">
      <summary>Intenta obtener la cadena subyacente de un <see langword="System.ReadOnlyMemory&lt;Char&gt;" />.</summary>
      <param name="memory">Memoria de solo lectura que contiene un bloque de caracteres.</param>
      <param name="text">Cuando el método lo devuelve, la cadena contenida en el búfer de memoria.</param>
      <param name="start">La ubicación de inicio de <paramref name="text" />.</param>
      <param name="length">Número de caracteres de <paramref name="text" />.</param>
      <returns>
        <see langword="true" /> Si el método recupera correctamente la cadena subyacente; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryRead``1(System.ReadOnlySpan{System.Byte},``0@)">
      <summary>Intenta leer una estructura de tipo <paramref name="T" /> desde un intervalo de bytes de solo lectura.</summary>
      <param name="source">Un intervalo de bytes de solo lectura.</param>
      <param name="value">Cuando el método finaliza, instancia de <paramref name="T" />.</param>
      <typeparam name="T">Tipo de la estructura que se va a recuperar.</typeparam>
      <returns>
        <see langword="true" /> si el método recupera correctamente una instancia de la estructura; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> contiene referencias o punteros.</exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryWrite``1(System.Span{System.Byte},``0@)">
      <summary>Intenta escribir una estructura de tipo <paramref name="T" /> en un intervalo de bytes.</summary>
      <param name="destination">El intervalo de bytes que contiene la estructura.</param>
      <param name="value">La estructura que se escribirá en el intervalo.</param>
      <typeparam name="T">Tipo de la estructura.</typeparam>
      <returns>
        <see langword="true" /> si la operación se realiza correctamente; de lo contrario, <see langword="false" />. El método devuelve <see langword="false" /> si el intervalo es demasiado pequeño para incluir <paramref name="T" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> contiene referencias o punteros.</exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Write``1(System.Span{System.Byte},``0@)">
      <summary>Escribe una estructura de tipo <paramref name="T" /> en un intervalo de bytes.</summary>
      <param name="destination">El intervalo de bytes que contiene la estructura.</param>
      <param name="value">La estructura que se escribirá en el intervalo.</param>
      <typeparam name="T">Tipo de la estructura.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> contiene referencias o punteros.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> es demasiado pequeño para contener <paramref name="value" />.</exception>
    </member>
    <member name="T:System.Runtime.InteropServices.SequenceMarshal">
      <summary>Proporciona una colección de métodos para interoperar con <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetArray``1(System.Buffers.ReadOnlySequence{``0},System.ArraySegment{``0}@)">
      <summary>Obtiene un segmento de la matriz de la secuencia de solo lectura subyacente.</summary>
      <param name="sequence">Secuencia de solo lectura a partir de la cual se recuperará el segmento de la matriz.</param>
      <param name="segment">Segmento de la matriz devuelto.</param>
      <typeparam name="T">Tipo de la secuencia de solo lectura.</typeparam>
      <returns>
        <see langword="true" /> si es posible recuperar el segmento de la matriz; de lo contrario, <see langword="false" />, se devuelve un segmento de matriz predeterminado.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlyMemory``1(System.Buffers.ReadOnlySequence{``0},System.ReadOnlyMemory{``0}@)">
      <summary>Intenta recuperar una memoria de solo lectura de la secuencia de solo lectura especificada.</summary>
      <param name="sequence">Secuencia de solo lectura a partir de la cual se recuperará la memoria.</param>
      <param name="memory">Memoria de solo lectura de tipo T devuelta.</param>
      <typeparam name="T">Tipo de la secuencia de solo lectura.</typeparam>
      <returns>
        <see langword="true" /> si se puede recuperar la memoria de solo lectura; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlySequenceSegment``1(System.Buffers.ReadOnlySequence{``0},System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@,System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@)">
      <summary>Intenta recuperar un segmento de secuencia de solo lectura a partir de la secuencia de solo lectura especificada.</summary>
      <param name="sequence">Secuencia de solo lectura a partir de la cual se recuperará el segmento de la secuencia de solo lectura.</param>
      <param name="startSegment">Segmento de la secuencia de solo lectura inicial.</param>
      <param name="startIndex">Posición inicial.</param>
      <param name="endSegment">Segmento de la secuencia de solo lectura final.</param>
      <param name="endIndex">Posición final.</param>
      <typeparam name="T">Tipo de la secuencia de solo lectura.</typeparam>
      <returns>
        <see langword="true" /> si se puede recuperar el segmento de secuencia de solo lectura; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryRead``1(System.Buffers.SequenceReader{System.Byte}@,``0@)">
      <summary>Intenta leer el tipo especificado del búfer. Usar este método con structs arbitrarios es peligroso; vea los comentarios para más información.</summary>
      <param name="reader">Referencia al lector de secuencias.</param>
      <param name="value">Valor devuelto si la lectura se realizó correctamente. <paramref name="value" /> será <see langword="default" /> si se produce un error (debido a la falta de espacio).</param>
      <typeparam name="T">Tipo del valor.</typeparam>
      <returns>
        <see langword="true" /> si el intento de lectura se realizó correctamente; de lo contrario <see langword="false" />.</returns>
    </member>
    <member name="T:System.SequencePosition">
      <summary>Representa una posición en un conjunto de memoria no contiguo. Las propiedades de este tipo no deben interpretarse mediante ningún elemento que no sea el tipo que las creó.</summary>
    </member>
    <member name="M:System.SequencePosition.#ctor(System.Object,System.Int32)">
      <summary>Inicializa una nueva instancia del struct <see cref="T:System.SequencePosition" />.</summary>
      <param name="object">Conjunto de memoria no contiguo.</param>
      <param name="integer">Posición en <paramref name="object" />.</param>
    </member>
    <member name="M:System.SequencePosition.Equals(System.Object)">
      <summary>Devuelve un valor que indica si la instancia actual es igual que otro objeto.</summary>
      <param name="obj">Objeto que se va a comparar con la instancia actual.</param>
      <returns>
        <see langword="true" /> si <paramref name="obj" /> es del tipo <see cref="T:System.SequencePosition" /> y es igual a la instancia actual; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.SequencePosition.Equals(System.SequencePosition)">
      <summary>Indica si la instancia actual es igual que otro <see cref="T:System.SequencePosition" />.</summary>
      <param name="other">Posición de la secuencia que se va a comparar con la instancia actual.</param>
      <returns>
        <see langword="true" /> si las dos instancias son iguales; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.SequencePosition.GetHashCode">
      <summary>Devuelve el código hash de esta instancia.</summary>
      <returns>Código hash de esta instancia.</returns>
    </member>
    <member name="M:System.SequencePosition.GetInteger">
      <summary>Devuelve la parte de entero de este objeto <see cref="T:System.SequencePosition" />.</summary>
      <returns>Parte entera de la posición de esta secuencia.</returns>
    </member>
    <member name="M:System.SequencePosition.GetObject">
      <summary>Devuelve la parte de objeto de este objeto <see cref="T:System.SequencePosition" />.</summary>
      <returns>Parte de objeto de esta posición de la secuencia.</returns>
    </member>
    <member name="T:System.Text.SpanRuneEnumerator">
      <summary>Proporciona un enumerador para los valores <see cref="T:System.Text.Rune" /> representado por un intervalo que contiene texto UTF-16.</summary>
    </member>
    <member name="P:System.Text.SpanRuneEnumerator.Current">
      <summary>Obtiene <see cref="T:System.Text.Rune" /> en la posición actual del enumerador.</summary>
      <returns>Obtiene <see cref="T:System.Text.Rune" /> en la posición actual del enumerador.</returns>
    </member>
    <member name="M:System.Text.SpanRuneEnumerator.GetEnumerator">
      <summary>Devuelve la instancia de enumerador actual.</summary>
      <returns>La instancia de enumerador actual.</returns>
    </member>
    <member name="M:System.Text.SpanRuneEnumerator.MoveNext">
      <summary>Desplaza el enumerador al <see cref="T:System.Text.Rune" /> siguiente del intervalo.</summary>
      <returns>
        <see langword="true" /> si el enumerador se ha desplazado correctamente al elemento siguiente; <see langword="false" /> si se ha llegado al final del intervalo.</returns>
    </member>
  </members>
</doc>