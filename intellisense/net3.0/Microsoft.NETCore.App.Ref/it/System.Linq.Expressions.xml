<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Linq.Expressions</name>
  </assembly>
  <members>
    <member name="T:System.Dynamic.BinaryOperationBinder">
      <summary>Rappresenta l'operazione binaria dinamica nel sito di chiamata, fornendo la semantica di associazione e i dettagli sull'operazione.</summary>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.#ctor(System.Linq.Expressions.ExpressionType)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Dynamic.BinaryOperationBinder" />.</summary>
      <param name="operation">Tipo di operazione binaria.</param>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Esegue l'associazione dell'operazione binaria dinamica.</summary>
      <param name="target">Destinazione dell'operazione dinamica.</param>
      <param name="args">Matrice di argomenti dell'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.FallbackBinaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Esegue l'associazione dell'operazione binaria dinamica se l'oggetto dinamico di destinazione non può eseguire l'associazione.</summary>
      <param name="target">Destinazione dell'operazione binaria dinamica.</param>
      <param name="arg">Operando destro dell'operazione binaria dinamica.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.FallbackBinaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Se sottoposto a override nella classe derivata, esegue l'associazione dell'operazione binaria dinamica se l'oggetto dinamico di destinazione non può eseguire l'associazione.</summary>
      <param name="target">Destinazione dell'operazione binaria dinamica.</param>
      <param name="arg">Operando destro dell'operazione binaria dinamica.</param>
      <param name="errorSuggestion">Risultato dell'associazione se l'associazione non riesce, oppure null.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="P:System.Dynamic.BinaryOperationBinder.Operation">
      <summary>Tipo di operazione binaria.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta il tipo di operazione binaria.</returns>
    </member>
    <member name="P:System.Dynamic.BinaryOperationBinder.ReturnType">
      <summary>Tipo di risultato dell'operazione.</summary>
      <returns>Tipo di risultato dell'operazione.</returns>
    </member>
    <member name="T:System.Dynamic.BindingRestrictions">
      <summary>Rappresenta un set di restrizioni relative all'associazione per l'oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che determinano la validità dell'associazione dinamica.</summary>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.Combine(System.Collections.Generic.IList{System.Dynamic.DynamicMetaObject})">
      <summary>Combina le restrizioni relative all'associazione dall'elenco di istanze di <see cref="T:System.Dynamic.DynamicMetaObject" /> in un unico set di restrizioni.</summary>
      <param name="contributingObjects">Elenco di istanze di <see cref="T:System.Dynamic.DynamicMetaObject" /> da cui combinare le restrizioni.</param>
      <returns>Nuovo set di restrizioni relative all'associazione.</returns>
    </member>
    <member name="F:System.Dynamic.BindingRestrictions.Empty">
      <summary>Rappresenta un set vuoto di restrizioni relative all'associazione. Questo campo è di sola lettura.</summary>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetExpressionRestriction(System.Linq.Expressions.Expression)">
      <summary>Crea la restrizione relativa all'associazione che controlla l'eventuale presenza di proprietà non modificabili arbitrarie nell'espressione.</summary>
      <param name="expression">Espressione che rappresenta le restrizioni.</param>
      <returns>Nuove restrizioni relative all'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetInstanceRestriction(System.Linq.Expressions.Expression,System.Object)">
      <summary>Crea la restrizione relativa all'associazione che controlla l'identità dell'istanza dell'oggetto nell'espressione.</summary>
      <param name="expression">Espressione da verificare.</param>
      <param name="instance">Istanza esatta dell'oggetto da testare.</param>
      <returns>Nuove restrizioni relative all'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetTypeRestriction(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea la restrizione relativa all'associazione che controlla l'identità del tipo di runtime nell'espressione.</summary>
      <param name="expression">Espressione da verificare.</param>
      <param name="type">Tipo esatto da testare.</param>
      <returns>Nuove restrizioni relative all'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.Merge(System.Dynamic.BindingRestrictions)">
      <summary>Unisce il set di restrizioni relative all'associazione alle restrizioni correnti.</summary>
      <param name="restrictions">Set di restrizioni a cui unire le restrizioni relative all'associazione correnti.</param>
      <returns>Nuovo set di restrizioni relative all'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.ToExpression">
      <summary>Crea l'oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta le restrizioni relative all'associazione.</summary>
      <returns>Struttura ad albero dell'espressione che rappresenta le restrizioni.</returns>
    </member>
    <member name="T:System.Dynamic.CallInfo">
      <summary>Descrive gli argomenti nel processo di associazione dinamica.</summary>
    </member>
    <member name="M:System.Dynamic.CallInfo.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.String})">
      <summary>Crea un nuovo CallInfo che rappresenta gli argomenti nel processo di associazione dinamico.</summary>
      <param name="argCount">Numero di argomenti.</param>
      <param name="argNames">Nomi degli argomenti.</param>
    </member>
    <member name="M:System.Dynamic.CallInfo.#ctor(System.Int32,System.String[])">
      <summary>Crea un nuovo <c>PositionalArgumentInfo</c>.</summary>
      <param name="argCount">Numero di argomenti.</param>
      <param name="argNames">Nomi degli argomenti.</param>
    </member>
    <member name="P:System.Dynamic.CallInfo.ArgumentCount">
      <summary>Numero di argomenti.</summary>
      <returns>Numero di argomenti.</returns>
    </member>
    <member name="P:System.Dynamic.CallInfo.ArgumentNames">
      <summary>Nomi degli argomenti.</summary>
      <returns>Raccolta di sola lettura di nomi degli argomenti.</returns>
    </member>
    <member name="M:System.Dynamic.CallInfo.Equals(System.Object)">
      <summary>Determina se l'istanza di CallInfo specificata è considerata uguale a quella corrente.</summary>
      <param name="obj">Istanza di <see cref="T:System.Dynamic.CallInfo" /> da confrontare con l'istanza corrente.</param>
      <returns>Restituisce true se l'istanza specificata è uguale a quella corrente; in caso contrario, false.</returns>
    </member>
    <member name="M:System.Dynamic.CallInfo.GetHashCode">
      <summary>Funge da funzione hash per l'oggetto <see cref="T:System.Dynamic.CallInfo" /> corrente.</summary>
      <returns>Codice hash per l'oggetto <see cref="T:System.Dynamic.CallInfo" /> corrente.</returns>
    </member>
    <member name="T:System.Dynamic.ConvertBinder">
      <summary>Rappresenta l'operazione di conversione dinamica nel sito di chiamata, fornendo la semantica di associazione e i dettagli sull'operazione.</summary>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.#ctor(System.Type,System.Boolean)">
      <summary>Inizializza una nuova istanza dell'oggetto <see cref="T:System.Dynamic.ConvertBinder" />.</summary>
      <param name="type">Tipo in cui eseguire la conversione.</param>
      <param name="explicit">Restituisce true se la conversione deve considerare le conversioni esplicite; in caso contrario, false.</param>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Esegue l'associazione dell'operazione di conversione dinamica.</summary>
      <param name="target">Destinazione dell'operazione di conversione dinamica.</param>
      <param name="args">Matrice di argomenti dell'operazione di conversione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.Explicit">
      <summary>Ottiene il valore che indica se la conversione deve considerare le conversioni esplicite.</summary>
      <returns>
        <see langword="true" />Se è presente una conversione esplicita; in caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.FallbackConvert(System.Dynamic.DynamicMetaObject)">
      <summary>Esegue l'associazione dell'operazione di conversione dinamica se l'oggetto dinamico di destinazione non può eseguire l'associazione.</summary>
      <param name="target">Destinazione dell'operazione di conversione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.FallbackConvert(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Se sottoposto a override nella classe derivata, esegue l'associazione dell'operazione di conversione dinamica se l'oggetto dinamico di destinazione non può eseguire l'associazione.</summary>
      <param name="target">Destinazione dell'operazione di conversione dinamica.</param>
      <param name="errorSuggestion">Risultato dell'associazione da utilizzare se l'associazione non riesce, oppure null.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.ReturnType">
      <summary>Tipo di risultato dell'operazione.</summary>
      <returns>Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di risultato dell'operazione.</returns>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.Type">
      <summary>Tipo in cui eseguire la conversione.</summary>
      <returns>Oggetto <see cref="T:System.Type" /> che rappresenta il tipo in cui eseguire la conversione.</returns>
    </member>
    <member name="T:System.Dynamic.CreateInstanceBinder">
      <summary>Rappresenta l'operazione di creazione dinamica nel sito di chiamata, fornendo la semantica di associazione e i dettagli sull'operazione.</summary>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Inizializza una nuova istanza dell'oggetto <see cref="T:System.Dynamic.CreateInstanceBinder" />.</summary>
      <param name="callInfo">Firma degli argomenti nel sito di chiamata.</param>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Esegue l'associazione dell'operazione di creazione dinamica.</summary>
      <param name="target">Destinazione dell'operazione di creazione dinamica.</param>
      <param name="args">Matrice di argomenti dell'operazione di creazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="P:System.Dynamic.CreateInstanceBinder.CallInfo">
      <summary>Ottiene la firma degli argomenti nel sito di chiamata.</summary>
      <returns>Firma degli argomenti nel sito di chiamata.</returns>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.FallbackCreateInstance(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Esegue l'associazione dell'operazione di creazione dinamica se l'oggetto dinamico di destinazione non può eseguire l'associazione.</summary>
      <param name="target">Destinazione dell'operazione di creazione dinamica.</param>
      <param name="args">Argomenti dell'operazione di creazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.FallbackCreateInstance(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Se sottoposto a override nella classe derivata, esegue l'associazione dell'operazione di creazione dinamica se l'oggetto dinamico di destinazione non può eseguire l'associazione.</summary>
      <param name="target">Destinazione dell'operazione di creazione dinamica.</param>
      <param name="args">Argomenti dell'operazione di creazione dinamica.</param>
      <param name="errorSuggestion">Risultato dell'associazione da utilizzare se l'associazione non riesce, oppure null.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="P:System.Dynamic.CreateInstanceBinder.ReturnType">
      <summary>Tipo di risultato dell'operazione.</summary>
      <returns>Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di risultato dell'operazione.</returns>
    </member>
    <member name="T:System.Dynamic.DeleteIndexBinder">
      <summary>Rappresenta l'operazione dinamica di eliminazione dell'indice nel sito di chiamata, fornendo la semantica di associazione e i dettagli sull'operazione.</summary>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Inizializza una nuova istanza dell'oggetto <see cref="T:System.Dynamic.DeleteIndexBinder" />.</summary>
      <param name="callInfo">Firma degli argomenti nel sito di chiamata.</param>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Esegue l'associazione dell'operazione dinamica di eliminazione dell'indice.</summary>
      <param name="target">Destinazione dell'operazione dinamica di eliminazione dell'indice.</param>
      <param name="args">Matrice di argomenti dell'operazione dinamica di eliminazione dell'indice.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteIndexBinder.CallInfo">
      <summary>Ottiene la firma degli argomenti nel sito di chiamata.</summary>
      <returns>Firma degli argomenti nel sito di chiamata.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.FallbackDeleteIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Esegue l'associazione dell'operazione dinamica di eliminazione dell'indice se l'oggetto dinamico di destinazione non può eseguire l'associazione.</summary>
      <param name="target">Destinazione dell'operazione dinamica di eliminazione dell'indice.</param>
      <param name="indexes">Argomenti dell'operazione dinamica di eliminazione dell'indice.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.FallbackDeleteIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Se sottoposto a override nella classe derivata, esegue l'associazione dell'operazione dinamica di eliminazione dell'indice se l'oggetto dinamico di destinazione non può eseguire l'associazione.</summary>
      <param name="target">Destinazione dell'operazione dinamica di eliminazione dell'indice.</param>
      <param name="indexes">Argomenti dell'operazione dinamica di eliminazione dell'indice.</param>
      <param name="errorSuggestion">Risultato dell'associazione da utilizzare se l'associazione non riesce, oppure null.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteIndexBinder.ReturnType">
      <summary>Tipo di risultato dell'operazione.</summary>
      <returns>Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di risultato dell'operazione.</returns>
    </member>
    <member name="T:System.Dynamic.DeleteMemberBinder">
      <summary>Rappresenta l'operazione dinamica di eliminazione del membro nel sito di chiamata, fornendo la semantica di associazione e i dettagli sull'operazione.</summary>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.#ctor(System.String,System.Boolean)">
      <summary>Inizializza una nuova istanza dell'oggetto <see cref="T:System.Dynamic.DeleteIndexBinder" />.</summary>
      <param name="name">Nome del membro da eliminare.</param>
      <param name="ignoreCase">Restituisce true se nella corrispondenza del nome deve essere ignorata la distinzione tra maiuscole e minuscole; in caso contrario, false.</param>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Esegue l'associazione dell'operazione dinamica di eliminazione del membro.</summary>
      <param name="target">Destinazione dell'operazione dinamica di eliminazione del membro.</param>
      <param name="args">Matrice di argomenti dell'operazione dinamica di eliminazione del membro.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.FallbackDeleteMember(System.Dynamic.DynamicMetaObject)">
      <summary>Esegue l'associazione dell'operazione dinamica di eliminazione del membro se l'oggetto dinamico di destinazione non può eseguire l'associazione.</summary>
      <param name="target">Destinazione dell'operazione dinamica di eliminazione del membro.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.FallbackDeleteMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Se sottoposto a override nella classe derivata, esegue l'associazione dell'operazione dinamica di eliminazione del membro se l'oggetto dinamico di destinazione non può eseguire l'associazione.</summary>
      <param name="target">Destinazione dell'operazione dinamica di eliminazione del membro.</param>
      <param name="errorSuggestion">Risultato dell'associazione da utilizzare se l'associazione non riesce, oppure null.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.IgnoreCase">
      <summary>Ottiene il valore che indica se nel confronto tra stringhe deve essere ignorata la distinzione tra maiuscole e minuscole per il nome del membro.</summary>
      <returns>
        <see langword="true" />Se il confronto tra stringhe deve ignorare case; in caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.Name">
      <summary>Ottiene il nome del membro da eliminare.</summary>
      <returns>Nome del membro da eliminare.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.ReturnType">
      <summary>Tipo di risultato dell'operazione.</summary>
      <returns>Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di risultato dell'operazione.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicMetaObject">
      <summary>Rappresenta l'associazione dinamica e un'associazione logica di un oggetto che partecipa all'associazione dinamica.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.#ctor(System.Linq.Expressions.Expression,System.Dynamic.BindingRestrictions)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <param name="expression">Espressione che rappresenta <see cref="T:System.Dynamic.DynamicMetaObject" /> durante il processo di associazione dinamica.</param>
      <param name="restrictions">Set di restrizioni relative all'associazione che determinano la validità dell'associazione.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.#ctor(System.Linq.Expressions.Expression,System.Dynamic.BindingRestrictions,System.Object)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <param name="expression">Espressione che rappresenta <see cref="T:System.Dynamic.DynamicMetaObject" /> durante il processo di associazione dinamica.</param>
      <param name="restrictions">Set di restrizioni relative all'associazione che determinano la validità dell'associazione.</param>
      <param name="value">Valore di runtime rappresentato da <see cref="T:System.Dynamic.DynamicMetaObject" />.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Dynamic.DynamicMetaObject)">
      <summary>Esegue l'associazione dell'operazione binaria dinamica.</summary>
      <param name="binder">Istanza di <see cref="T:System.Dynamic.BinaryOperationBinder" /> che rappresenta i dettagli dell'operazione dinamica.</param>
      <param name="arg">Istanza di <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il lato destro dell'operazione binaria.</param>
      <returns>Nuovo oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindConvert(System.Dynamic.ConvertBinder)">
      <summary>Esegue l'associazione dell'operazione di conversione dinamica.</summary>
      <param name="binder">Istanza di <see cref="T:System.Dynamic.ConvertBinder" /> che rappresenta i dettagli dell'operazione dinamica.</param>
      <returns>Nuovo oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindCreateInstance(System.Dynamic.CreateInstanceBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Esegue l'associazione dell'operazione dinamica di creazione dell'istanza.</summary>
      <param name="binder">Istanza di <see cref="T:System.Dynamic.CreateInstanceBinder" /> che rappresenta i dettagli dell'operazione dinamica.</param>
      <param name="args">Matrice di istanze o argomenti di <see cref="T:System.Dynamic.DynamicMetaObject" /> per l'operazione di creazione istanza.</param>
      <returns>Nuovo oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Esegue l'associazione dell'operazione dinamica di eliminazione dell'indice.</summary>
      <param name="binder">Istanza di <see cref="T:System.Dynamic.DeleteIndexBinder" /> che rappresenta i dettagli dell'operazione dinamica.</param>
      <param name="indexes">Una matrice di istanze o indici di <see cref="T:System.Dynamic.DynamicMetaObject" /> per l'operazione di eliminazione dell'indice.</param>
      <returns>Nuovo oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindDeleteMember(System.Dynamic.DeleteMemberBinder)">
      <summary>Esegue l'associazione dell'operazione dinamica di eliminazione del membro.</summary>
      <param name="binder">Istanza di <see cref="T:System.Dynamic.DeleteMemberBinder" /> che rappresenta i dettagli dell'operazione dinamica.</param>
      <returns>Nuovo oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindGetIndex(System.Dynamic.GetIndexBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Esegue l'associazione dell'operazione get dinamica sull'indice.</summary>
      <param name="binder">Istanza di <see cref="T:System.Dynamic.GetIndexBinder" /> che rappresenta i dettagli dell'operazione dinamica.</param>
      <param name="indexes">Matrice di istanze o indici di <see cref="T:System.Dynamic.DynamicMetaObject" /> per l'operazione get sull'indice.</param>
      <returns>Nuovo oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindGetMember(System.Dynamic.GetMemberBinder)">
      <summary>Esegue l'associazione dell'operazione get dinamica sul membro.</summary>
      <param name="binder">Istanza di <see cref="T:System.Dynamic.GetMemberBinder" /> che rappresenta i dettagli dell'operazione dinamica.</param>
      <returns>Nuovo oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindInvoke(System.Dynamic.InvokeBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Esegue l'associazione dell'operazione invoke dinamica.</summary>
      <param name="binder">Istanza di <see cref="T:System.Dynamic.InvokeBinder" /> che rappresenta i dettagli dell'operazione dinamica.</param>
      <param name="args">Matrice di istanze o argomenti di <see cref="T:System.Dynamic.DynamicMetaObject" /> per l'operazione invoke.</param>
      <returns>Nuovo oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindInvokeMember(System.Dynamic.InvokeMemberBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Esegue l'associazione dell'operazione invoke dinamica sul membro.</summary>
      <param name="binder">Istanza di <see cref="T:System.Dynamic.InvokeMemberBinder" /> che rappresenta i dettagli dell'operazione dinamica.</param>
      <param name="args">Matrice di istanze o argomenti di <see cref="T:System.Dynamic.DynamicMetaObject" /> per l'operazione invoke sul membro.</param>
      <returns>Nuovo oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindSetIndex(System.Dynamic.SetIndexBinder,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Esegue l'associazione dell'operazione dinamica di impostazione dell'indice.</summary>
      <param name="binder">Istanza di <see cref="T:System.Dynamic.SetIndexBinder" /> che rappresenta i dettagli dell'operazione dinamica.</param>
      <param name="indexes">Matrice di istanze o indici di <see cref="T:System.Dynamic.DynamicMetaObject" /> per l'operazione di impostazione dell'indice.</param>
      <param name="value">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il valore per l'operazione di impostazione dell'indice.</param>
      <returns>Nuovo oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindSetMember(System.Dynamic.SetMemberBinder,System.Dynamic.DynamicMetaObject)">
      <summary>Esegue l'associazione dell'operazione dinamica di impostazione del membro.</summary>
      <param name="binder">Istanza di <see cref="T:System.Dynamic.SetMemberBinder" /> che rappresenta i dettagli dell'operazione dinamica.</param>
      <param name="value">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il valore per l'operazione di impostazione del membro.</param>
      <returns>Nuovo oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindUnaryOperation(System.Dynamic.UnaryOperationBinder)">
      <summary>Esegue l'associazione dell'operazione unaria dinamica.</summary>
      <param name="binder">Istanza di <see cref="T:System.Dynamic.UnaryOperationBinder" /> che rappresenta i dettagli dell'operazione dinamica.</param>
      <returns>Nuovo oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.Create(System.Object,System.Linq.Expressions.Expression)">
      <summary>Crea un metaoggetto per l'oggetto specificato.</summary>
      <param name="value">Oggetto per cui ottenere un metaoggetto.</param>
      <param name="expression">Espressione che rappresenta <see cref="T:System.Dynamic.DynamicMetaObject" /> durante il processo di associazione dinamica.</param>
      <returns>Se l'oggetto specificato implementa <see cref="T:System.Dynamic.IDynamicMetaObjectProvider" /> e non è un oggetto remoto esterno all'AppDomain corrente, restituisce il metaoggetto specifico dell'oggetto restituito da <see cref="M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)" />. In caso contrario, viene creato e restituito un nuovo metaoggetto semplice senza restrizioni.</returns>
    </member>
    <member name="F:System.Dynamic.DynamicMetaObject.EmptyMetaObjects">
      <summary>Rappresenta una matrice vuota di tipo <see cref="T:System.Dynamic.DynamicMetaObject" />. Questo campo è di sola lettura.</summary>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Expression">
      <summary>Espressione che rappresenta <see cref="T:System.Dynamic.DynamicMetaObject" /> durante il processo di associazione dinamica.</summary>
      <returns>Espressione che rappresenta <see cref="T:System.Dynamic.DynamicMetaObject" /> durante il processo di associazione dinamica.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.GetDynamicMemberNames">
      <summary>Restituisce l'enumerazione di tutti i nomi di membro dinamici.</summary>
      <returns>Elenco dei nomi di membro dinamici.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.HasValue">
      <summary>Ottiene un valore che indica se <see cref="T:System.Dynamic.DynamicMetaObject" /> include il valore di runtime.</summary>
      <returns>
        <see langword="true" />Se ha il valore di runtime; in caso <see langword="false" />contrario,. <see cref="T:System.Dynamic.DynamicMetaObject" /></returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.LimitType">
      <summary>Ottiene il tipo di limite di <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <returns>
        <see cref="P:System.Dynamic.DynamicMetaObject.RuntimeType" /> se il valore di runtime è disponibile; in caso contrario, un tipo di <see cref="P:System.Dynamic.DynamicMetaObject.Expression" />.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Restrictions">
      <summary>Set di restrizioni relative all'associazione che determinano la validità dell'associazione.</summary>
      <returns>Set di restrizioni relative all'associazione.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.RuntimeType">
      <summary>Ottiene il tipo (<see cref="T:System.Type" />) del valore di runtime oppure restituisce Null se a <see cref="T:System.Dynamic.DynamicMetaObject" /> non è associato alcun valore.</summary>
      <returns>Tipo (<see cref="T:System.Type" />) del valore di runtime oppure Null.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Value">
      <summary>Valore di runtime rappresentato da <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <returns>Valore di runtime rappresentato da <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicMetaObjectBinder">
      <summary>Gestore di associazione del sito di chiamata dinamico che fa parte del protocollo di associazione di <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.#ctor">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Dynamic.DynamicMetaObjectBinder" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Se sottoposto a override nella classe derivata, esegue l'associazione dell'operazione dinamica.</summary>
      <param name="target">Destinazione dell'operazione dinamica.</param>
      <param name="args">Matrice di argomenti dell'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Bind(System.Object[],System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.LabelTarget)">
      <summary>Esegue l'associazione di runtime dell'operazione dinamica su un set di argomenti.</summary>
      <param name="args">Matrice di argomenti per l'operazione dinamica.</param>
      <param name="parameters">Matrice di istanze <see cref="T:System.Linq.Expressions.ParameterExpression" /> che rappresentano i parametri del sito di chiamata nel processo di associazione.</param>
      <param name="returnLabel">LabelTarget utilizzato per restituire il risultato dell'associazione dinamica.</param>
      <returns>Espressione che esegue test sugli argomenti dell'operazione dinamica ed esegue l'operazione dinamica se i test sono validi. Se i test non riescono su occorrenze successive dell'operazione dinamica, Bind sarà chiamato nuovamente per produrre un nuovo <see cref="T:System.Linq.Expressions.Expression" /> per i nuovi tipi di argomento.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Defer(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Rinvia l'associazione dell'operazione a un momento successivo, al calcolo dei valori di runtime di tutti gli argomenti dell'operazione dinamica.</summary>
      <param name="target">Destinazione dell'operazione dinamica.</param>
      <param name="args">Matrice di argomenti dell'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Defer(System.Dynamic.DynamicMetaObject[])">
      <summary>Rinvia l'associazione dell'operazione a un momento successivo, al calcolo dei valori di runtime di tutti gli argomenti dell'operazione dinamica.</summary>
      <param name="args">Matrice di argomenti dell'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.GetUpdateExpression(System.Type)">
      <summary>Ottiene un'espressione che provocherà l'aggiornamento dell'associazione. Indica che l'associazione dell'espressione non è più valida. Viene in genere utilizzato quando la "versione" di un oggetto dinamico è stata modificata.</summary>
      <param name="type">Proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> dell'espressione risultante. È consentito qualsiasi tipo.</param>
      <returns>Espressione di aggiornamento.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObjectBinder.ReturnType">
      <summary>Tipo di risultato dell'operazione.</summary>
      <returns>Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di risultato dell'operazione.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicObject">
      <summary>Fornisce una classe di base per specificare il comportamento dinamico in runtime. La classe deve essere ereditata e non è possibile crearne direttamente un'istanza.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicObject.#ctor">
      <summary>Consente ai tipi derivati di creare una nuova istanza del tipo <see cref="T:System.Dynamic.DynamicObject" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicObject.GetDynamicMemberNames">
      <summary>Restituisce l'enumerazione di tutti i nomi di membro dinamici.</summary>
      <returns>Sequenza che contiene nomi dei membri dinamici.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>Fornisce un oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che invia ai metodi virtuali dinamici. L'oggetto può essere incapsulato all'interno di un altro oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> per fornire il comportamento personalizzato per singole azioni. Questo metodo supporta l'infrastruttura DLR (Dynamic Language Runtime) per gli implementatori del linguaggio e non è destinato all'utilizzo direttamente dal codice.</summary>
      <param name="parameter">Espressione che rappresenta l'oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> da inviare ai metodi virtuali dinamici.</param>
      <returns>Oggetto di tipo <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
      <summary>Fornisce l'implementazione per le operazioni binarie. Le classi derivate dalla classe <see cref="T:System.Dynamic.DynamicObject" /> possono eseguire l'override di questo metodo per specificare il comportamento dinamico per operazioni quali l'aggiunta e la moltiplicazione.</summary>
      <param name="binder">Fornisce informazioni sull'operazione binaria. La proprietà <c>binder.Operation</c> restituisce un oggetto <see cref="T:System.Linq.Expressions.ExpressionType" />. Ad esempio, per l'istruzione <c>sum = first + second</c>,dove <c>first</c> e <c>second</c> sono derivati dalla classe <see langword="DynamicObject" />,<c>binder.Operation</c> restituisce <c>ExpressionType.Add</c>.</param>
      <param name="arg">Operando destro per l'operazione binaria. Ad esempio, per l'istruzione <c>sum = first + second</c>, dove <c>first</c> e <c>second</c> sono derivati dalla classe <see langword="DynamicObject" />,<paramref name="arg" /> è uguale a <c>second</c>.</param>
      <param name="result">Risultato dell'operazione binaria.</param>
      <returns>
        <see langword="true" /> se l'operazione riesce; in caso contrario, <see langword="false" />. Se questo metodo restituisce <see langword="false" />, il comportamento viene determinato dal gestore di associazione di runtime del linguaggio. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
      <summary>Fornisce l'implementazione per le operazioni di conversione dei tipi. Le classi derivate dalla classe <see cref="T:System.Dynamic.DynamicObject" /> possono eseguire l'override di questo metodo per specificare il comportamento dinamico per operazioni che eseguono la conversione di un oggetto da un tipo a un altro.</summary>
      <param name="binder">Fornisce informazioni sull'operazione di conversione. La proprietà <c>binder.Type</c> specifica il tipo in cui deve essere convertito l'oggetto. Ad esempio, per l'istruzione <c>(String)sampleObject</c> in C# (<c>CType(sampleObject, Type)</c> in Visual Basic), dove <c>sampleObject</c> è un'istanza della classe derivata dalla classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Type</c> restituisce il tipo <see cref="T:System.String" />. La proprietà <c>binder.Explicit</c> specifica informazioni sul tipo di conversione effettuato. Restituisce <see langword="true" /> per la conversione esplicita e <see langword="false" /> per la conversione implicita.</param>
      <param name="result">Tipo di risultato dell'operazione di conversione dei tipi.</param>
      <returns>
        <see langword="true" /> se l'operazione riesce; in caso contrario, <see langword="false" />. Se questo metodo restituisce <see langword="false" />, il comportamento viene determinato dal gestore di associazione di runtime del linguaggio. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
      <summary>Fornisce l'implementazione per le operazioni che creano una nuova istanza di un oggetto dinamico. Questo metodo non può essere utilizzato in C# o in Visual Basic.</summary>
      <param name="binder">Fornisce informazioni sull'operazione di inizializzazione.</param>
      <param name="args">Argomenti passati all'oggetto durante l'inizializzazione. Ad esempio, per l'operazione <c>new SampleType(100)</c>, dove <c>SampleType</c> è il tipo derivato dalla classe <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> è uguale a 100.</param>
      <param name="result">Risultato dell'inizializzazione.</param>
      <returns>
        <see langword="true" /> se l'operazione riesce; in caso contrario, <see langword="false" />. Se questo metodo restituisce <see langword="false" />, il comportamento viene determinato dal gestore di associazione di runtime del linguaggio. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
      <summary>Fornisce l'implementazione per operazioni che eliminano un oggetto in base all'indice. Questo metodo non può essere utilizzato in C# o in Visual Basic.</summary>
      <param name="binder">Fornisce informazioni sull'operazione di eliminazione.</param>
      <param name="indexes">Indici da eliminare.</param>
      <returns>
        <see langword="true" /> se l'operazione riesce; in caso contrario, <see langword="false" />. Se questo metodo restituisce <see langword="false" />, il comportamento viene determinato dal gestore di associazione di runtime del linguaggio. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
      <summary>Fornisce l'implementazione per operazioni che eliminano un membro di un oggetto. Questo metodo non può essere utilizzato in C# o in Visual Basic.</summary>
      <param name="binder">Fornisce informazioni sull'operazione di eliminazione.</param>
      <returns>
        <see langword="true" /> se l'operazione riesce; in caso contrario, <see langword="false" />. Se questo metodo restituisce <see langword="false" />, il comportamento viene determinato dal gestore di associazione di runtime del linguaggio. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
      <summary>Fornisce l'implementazione per operazioni che ottengono un valore in base all'indice. Le classi derivate dalla classe <see cref="T:System.Dynamic.DynamicObject" /> possono eseguire l'override di questo metodo per specificare il comportamento dinamico per operazioni di indicizzazione.</summary>
      <param name="binder">Fornisce informazioni sull'operazione.</param>
      <param name="indexes">Indici utilizzati nell'operazione. Ad esempio, per l'operazione <c>sampleObject[3]</c> in C# (<c>sampleObject(3)</c> in Visual Basic), dove <c>sampleObject</c> è derivato dalla classe <see langword="DynamicObject" />, <c>indexes[0]</c> è uguale a 3.</param>
      <param name="result">Risultato dell'operazione di indicizzazione.</param>
      <returns>
        <see langword="true" /> se l'operazione riesce; in caso contrario, <see langword="false" />. Se questo metodo restituisce <see langword="false" />, il comportamento viene determinato dal gestore di associazione di runtime del linguaggio. Nella maggior parte dei casi viene generata eccezione di runtime.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
      <summary>Fornisce l'implementazione per operazioni che ottengono valori dei membri. Le classi derivate dalla classe <see cref="T:System.Dynamic.DynamicObject" /> possono eseguire l'override di questo metodo per specificare il comportamento dinamico per operazioni quale l'acquisizione di un valore per una proprietà.</summary>
      <param name="binder">Fornisce informazioni sull'oggetto che ha chiamato l'operazione dinamica. La proprietà <c>binder.Name</c> specifica il nome del membro su cui viene eseguita l'operazione dinamica. Ad esempio, per l'istruzione <c>Console.WriteLine(sampleObject.SampleProperty)</c>, dove <c>sampleObject</c> è un'istanza della classe derivata dalla classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> restituisce "SampleProperty". La proprietà <c>binder.IgnoreCase</c> specifica se per il nome del membro viene applicata la distinzione tra maiuscole e minuscole.</param>
      <param name="result">Risultato dell'operazione get. Ad esempio, se il metodo viene chiamato per una proprietà, è possibile assegnare il valore della proprietà a <paramref name="result" />.</param>
      <returns>
        <see langword="true" /> se l'operazione riesce; in caso contrario, <see langword="false" />. Se questo metodo restituisce <see langword="false" />, il comportamento viene determinato dal gestore di associazione di runtime del linguaggio. Nella maggior parte dei casi viene generata eccezione di runtime.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
      <summary>Fornisce l'implementazione per operazioni che richiamano un oggetto. Le classi derivate dalla classe <see cref="T:System.Dynamic.DynamicObject" /> possono eseguire l'override di questo metodo per specificare il comportamento dinamico per operazioni quale il richiamo di un oggetto o un delegato.</summary>
      <param name="binder">Fornisce informazioni sull'operazione invoke.</param>
      <param name="args">Argomenti passati all'oggetto durante l'operazione invoke. Ad esempio, per l'operazione <c>sampleObject(100)</c>, dove <c>sampleObject</c> è derivato dalla classe <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> è uguale a 100.</param>
      <param name="result">Risultato della chiamata all'oggetto.</param>
      <returns>
        <see langword="true" /> se l'operazione riesce; in caso contrario, <see langword="false" />. Se questo metodo restituisce <see langword="false" />, il comportamento viene determinato dal gestore di associazione di runtime del linguaggio. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
      <summary>Fornisce l'implementazione per operazioni che richiamano un membro. Le classi derivate dalla classe <see cref="T:System.Dynamic.DynamicObject" /> possono eseguire l'override di questo metodo per specificare il comportamento dinamico per operazioni quale la chiamata a un metodo.</summary>
      <param name="binder">Fornisce informazioni sull'operazione dinamica. La proprietà <c>binder.Name</c> specifica il nome del membro su cui viene eseguita l'operazione dinamica. Ad esempio, per l'istruzione <c>sampleObject.SampleMethod(100)</c>, dove <c>sampleObject</c> è un'istanza della classe derivata dalla classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> restituisce "SampleMethod". La proprietà <c>binder.IgnoreCase</c> specifica se per il nome del membro viene applicata la distinzione tra maiuscole e minuscole.</param>
      <param name="args">Argomenti passati al membro dell'oggetto durante l'operazione invoke. Ad esempio, per l'istruzione <c>sampleObject.SampleMethod(100)</c>, dove <c>sampleObject</c> è derivato dalla classe <see cref="T:System.Dynamic.DynamicObject" />, <c>args [0]</c> è uguale a 100.</param>
      <param name="result">Risultato della chiamata al membro.</param>
      <returns>
        <see langword="true" /> se l'operazione riesce; in caso contrario, <see langword="false" />. Se questo metodo restituisce <see langword="false" />, il comportamento viene determinato dal gestore di associazione di runtime del linguaggio. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
      <summary>Fornisce l'implementazione per operazioni che impostano un valore in base all'indice. Le classi derivate dalla classe <see cref="T:System.Dynamic.DynamicObject" /> possono eseguire l'override di questo metodo per specificare il comportamento dinamico per operazioni che accedono a oggetti in base a un indice specificato.</summary>
      <param name="binder">Fornisce informazioni sull'operazione.</param>
      <param name="indexes">Indici utilizzati nell'operazione. Ad esempio, per l'operazione <c>sampleObject[3] = 10</c> in C# (<c>sampleObject(3) = 10</c> in Visual Basic), dove <c>sampleObject</c> è derivato dalla classe <see cref="T:System.Dynamic.DynamicObject" />, <c>indexes[0]</c> è uguale a 3.</param>
      <param name="value">Valore da impostare per l'oggetto con l'indice specificato. Ad esempio, per l'operazione <c>sampleObject[3] = 10</c> in C# (<c>sampleObject(3) = 10</c> in Visual Basic), dove <c>sampleObject</c> è derivato dalla classe <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="value" /> è uguale a 10.</param>
      <returns>
        <see langword="true" /> se l'operazione riesce; in caso contrario, <see langword="false" />. Se questo metodo restituisce <see langword="false" />, il comportamento viene determinato dal gestore di associazione di runtime del linguaggio. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
      <summary>Fornisce l'implementazione per operazioni che impostano valori dei membri. Le classi derivate dalla classe <see cref="T:System.Dynamic.DynamicObject" /> possono eseguire l'override di questo metodo per specificare il comportamento dinamico per operazioni quale l'impostazione di un valore per una proprietà.</summary>
      <param name="binder">Fornisce informazioni sull'oggetto che ha chiamato l'operazione dinamica. La proprietà <c>binder.Name</c> specifica il nome del membro a cui viene assegnato il valore. Ad esempio, per l'istruzione <c>sampleObject.SampleProperty = "Test"</c>, dove <c>sampleObject</c> è un'istanza della classe derivata dalla classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> restituisce "SampleProperty". La proprietà <c>binder.IgnoreCase</c> specifica se per il nome del membro viene applicata la distinzione tra maiuscole e minuscole.</param>
      <param name="value">Valore su cui impostare il membro. Ad esempio, per l'istruzione <c>sampleObject.SampleProperty = "Test"</c>, dove <c>sampleObject</c> è un'istanza della classe derivata dalla classe <see cref="T:System.Dynamic.DynamicObject" />, l'elemento <paramref name="value" /> è "Test".</param>
      <returns>
        <see langword="true" /> se l'operazione riesce; in caso contrario, <see langword="false" />. Se questo metodo restituisce <see langword="false" />, il comportamento viene determinato dal gestore di associazione di runtime del linguaggio. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
      <summary>Fornisce l'implementazione per le operazioni unarie. Le classi derivate dalla classe <see cref="T:System.Dynamic.DynamicObject" /> possono eseguire l'override di questo metodo per specificare il comportamento dinamico per operazioni quale negazione, incremento o decremento.</summary>
      <param name="binder">Fornisce informazioni sull'operazione unaria. La proprietà <c>binder.Operation</c> restituisce un oggetto <see cref="T:System.Linq.Expressions.ExpressionType" />. Ad esempio, per l'istruzione <c>negativeNumber = -number</c>, dove <c>number</c> è derivato dalla classe <see langword="DynamicObject" />, <c>binder.Operation</c> restituisce "Negate".</param>
      <param name="result">Risultato dell'operazione unaria.</param>
      <returns>
        <see langword="true" /> se l'operazione riesce; in caso contrario, <see langword="false" />. Se questo metodo restituisce <see langword="false" />, il comportamento viene determinato dal gestore di associazione di runtime del linguaggio. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.</returns>
    </member>
    <member name="T:System.Dynamic.ExpandoObject">
      <summary>Rappresenta un oggetto i cui membri possono essere aggiunti e rimossi in modo dinamico in fase di esecuzione.</summary>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.#ctor">
      <summary>Crea un nuovo oggetto <see langword="ExpandoObject" /> che non ha membri.</summary>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="E:System.Dynamic.ExpandoObject.System#ComponentModel#INotifyPropertyChanged#PropertyChanged">
      <summary>Generato quando il valore di una proprietà cambia.</summary>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Dynamic#IDynamicMetaObjectProvider#GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>Il MetaObject fornito verrà inviato ai metodi virtuali dinamici. L'oggetto può essere incapsulato all'interno di un altro MetaObject per fornire comportamento personalizzato per singole azioni.</summary>
      <param name="parameter">Espressione che rappresenta il MetaObject da inviare ai metodi virtuali dinamici.</param>
      <returns>Oggetto del tipo <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
    </member>
    <member name="T:System.Dynamic.GetIndexBinder">
      <summary>Rappresenta l'operazione get dinamica sull'indice nel sito di chiamata, fornendo la semantica di associazione e i dettagli sull'operazione.</summary>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Inizializza una nuova istanza dell'oggetto <see cref="T:System.Dynamic.GetIndexBinder" />.</summary>
      <param name="callInfo">Firma degli argomenti nel sito di chiamata.</param>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Esegue l'associazione dell'operazione get dinamica sull'indice.</summary>
      <param name="target">Destinazione dell'operazione get dinamica sull'indice.</param>
      <param name="args">Matrice di argomenti dell'operazione get dinamica sull'indice.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="P:System.Dynamic.GetIndexBinder.CallInfo">
      <summary>Ottiene la firma degli argomenti nel sito di chiamata.</summary>
      <returns>Firma degli argomenti nel sito di chiamata.</returns>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.FallbackGetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Esegue l'associazione dell'operazione get dinamica sull'indice se l'oggetto dinamico di destinazione non può eseguire l'associazione.</summary>
      <param name="target">Destinazione dell'operazione get dinamica sull'indice.</param>
      <param name="indexes">Argomenti dell'operazione get dinamica sull'indice.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.FallbackGetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Se sottoposto a override nella classe derivata, esegue l'associazione dell'operazione get dinamica sull'indice se l'oggetto dinamico di destinazione non può eseguire l'associazione.</summary>
      <param name="target">Destinazione dell'operazione get dinamica sull'indice.</param>
      <param name="indexes">Argomenti dell'operazione get dinamica sull'indice.</param>
      <param name="errorSuggestion">Risultato dell'associazione da utilizzare se l'associazione non riesce, oppure null.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="P:System.Dynamic.GetIndexBinder.ReturnType">
      <summary>Tipo di risultato dell'operazione.</summary>
      <returns>Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di risultato dell'operazione.</returns>
    </member>
    <member name="T:System.Dynamic.GetMemberBinder">
      <summary>Rappresenta l'operazione get dinamica sul membro nel sito di chiamata, fornendo la semantica di associazione e i dettagli sull'operazione.</summary>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.#ctor(System.String,System.Boolean)">
      <summary>Inizializza una nuova istanza dell'oggetto <see cref="T:System.Dynamic.GetMemberBinder" />.</summary>
      <param name="name">Nome del membro da ottenere.</param>
      <param name="ignoreCase">Restituisce true se nella corrispondenza del nome deve essere ignorata la distinzione tra maiuscole e minuscole; in caso contrario, false.</param>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Esegue l'associazione dell'operazione get dinamica sul membro.</summary>
      <param name="target">Destinazione dell'operazione get dinamica sul membro.</param>
      <param name="args">Matrice di argomenti dell'operazione get dinamica sul membro.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.FallbackGetMember(System.Dynamic.DynamicMetaObject)">
      <summary>Esegue l'associazione dell'operazione get dinamica sul membro se l'oggetto dinamico di destinazione non può eseguire l'associazione.</summary>
      <param name="target">Destinazione dell'operazione get dinamica sul membro.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.FallbackGetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Se sottoposto a override nella classe derivata, esegue l'associazione dell'operazione get dinamica sul membro se l'oggetto dinamico di destinazione non può eseguire l'associazione.</summary>
      <param name="target">Destinazione dell'operazione get dinamica sul membro.</param>
      <param name="errorSuggestion">Risultato dell'associazione da utilizzare se l'associazione non riesce, oppure null.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.IgnoreCase">
      <summary>Ottiene il valore che indica se nel confronto tra stringhe deve essere ignorata la distinzione tra maiuscole e minuscole per il nome del membro.</summary>
      <returns>
        <see langword="true" />Se case viene ignorato; in caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.Name">
      <summary>Ottiene il nome del membro da ottenere.</summary>
      <returns>Nome del membro da ottenere.</returns>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.ReturnType">
      <summary>Tipo di risultato dell'operazione.</summary>
      <returns>Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di risultato dell'operazione.</returns>
    </member>
    <member name="T:System.Dynamic.IDynamicMetaObjectProvider">
      <summary>Rappresenta un oggetto dinamico le cui operazioni possono essere associate in fase di esecuzione.</summary>
    </member>
    <member name="M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>Restituisce l'oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> responsabile delle operazioni di associazione eseguite sull'oggetto corrente.</summary>
      <param name="parameter">Rappresentazione della struttura ad albero dell'espressione del valore di runtime.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> da associare all'oggetto corrente.</returns>
    </member>
    <member name="T:System.Dynamic.IInvokeOnGetBinder">
      <summary>Rappresenta le informazioni su un'operazione get dinamica sul membro che indica se devono essere richiamate le proprietà quando si esegue l'operazione get.</summary>
    </member>
    <member name="P:System.Dynamic.IInvokeOnGetBinder.InvokeOnGet">
      <summary>Ottiene il valore che indica se l'operazione get sul membro deve richiamare le proprietà quando eseguono l'operazione get. Il valore predefinito quando l'interfaccia non è presente è true.</summary>
      <returns>
        <see langword="true" />Se l'operazione Get Member deve richiamare le proprietà quando eseguono l'operazione get. in caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="T:System.Dynamic.InvokeBinder">
      <summary>Rappresenta l'operazione invoke dinamica nel sito di chiamata, fornendo la semantica di associazione e i dettagli sull'operazione.</summary>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Inizializza una nuova istanza dell'oggetto <see cref="T:System.Dynamic.InvokeBinder" />.</summary>
      <param name="callInfo">Firma degli argomenti nel sito di chiamata.</param>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Esegue l'associazione dell'operazione invoke dinamica.</summary>
      <param name="target">Destinazione dell'operazione invoke dinamica.</param>
      <param name="args">Matrice di argomenti dell'operazione invoke dinamica.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeBinder.CallInfo">
      <summary>Ottiene la firma degli argomenti nel sito di chiamata.</summary>
      <returns>Firma degli argomenti nel sito di chiamata.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Esegue l'associazione dell'operazione invoke dinamica se l'oggetto dinamico di destinazione non può eseguire l'associazione.</summary>
      <param name="target">Destinazione dell'operazione invoke dinamica.</param>
      <param name="args">Argomenti dell'operazione invoke dinamica.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Esegue l'associazione dell'operazione invoke dinamica se l'oggetto dinamico di destinazione non può eseguire l'associazione.</summary>
      <param name="target">Destinazione dell'operazione invoke dinamica.</param>
      <param name="args">Argomenti dell'operazione invoke dinamica.</param>
      <param name="errorSuggestion">Risultato dell'associazione da utilizzare se l'associazione non riesce, oppure null.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeBinder.ReturnType">
      <summary>Tipo di risultato dell'operazione.</summary>
      <returns>Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di risultato dell'operazione.</returns>
    </member>
    <member name="T:System.Dynamic.InvokeMemberBinder">
      <summary>Rappresenta l'operazione invoke dinamica sul membro nel sito di chiamata, fornendo la semantica di associazione e i dettagli sull'operazione.</summary>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.#ctor(System.String,System.Boolean,System.Dynamic.CallInfo)">
      <summary>Inizializza una nuova istanza dell'oggetto <see cref="T:System.Dynamic.InvokeMemberBinder" />.</summary>
      <param name="name">Nome del membro da richiamare.</param>
      <param name="ignoreCase">Restituisce true se nella corrispondenza del nome deve essere ignorata la distinzione tra maiuscole e minuscole; in caso contrario, false.</param>
      <param name="callInfo">Firma degli argomenti nel sito di chiamata.</param>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Esegue l'associazione dell'operazione invoke dinamica sul membro.</summary>
      <param name="target">Destinazione dell'operazione invoke dinamica sul membro.</param>
      <param name="args">Matrice di argomenti dell'operazione invoke dinamica sul membro.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.CallInfo">
      <summary>Ottiene la firma degli argomenti nel sito di chiamata.</summary>
      <returns>Firma degli argomenti nel sito di chiamata.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Se sottoposto a override nella classe derivata, esegue l'associazione dell'operazione invoke dinamica se l'oggetto dinamico di destinazione non può eseguire l'associazione.</summary>
      <param name="target">Destinazione dell'operazione invoke dinamica.</param>
      <param name="args">Argomenti dell'operazione invoke dinamica.</param>
      <param name="errorSuggestion">Risultato dell'associazione da utilizzare se l'associazione non riesce, oppure null.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvokeMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Esegue l'associazione dell'operazione invoke dinamica sul membro se l'oggetto dinamico di destinazione non può eseguire l'associazione.</summary>
      <param name="target">Destinazione dell'operazione invoke dinamica sul membro.</param>
      <param name="args">Argomenti dell'operazione invoke dinamica sul membro.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvokeMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Se sottoposto a override nella classe derivata, esegue l'associazione dell'operazione invoke dinamica sul membro se l'oggetto dinamico di destinazione non può eseguire l'associazione.</summary>
      <param name="target">Destinazione dell'operazione invoke dinamica sul membro.</param>
      <param name="args">Argomenti dell'operazione invoke dinamica sul membro.</param>
      <param name="errorSuggestion">Risultato dell'associazione da utilizzare se l'associazione non riesce, oppure null.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.IgnoreCase">
      <summary>Ottiene il valore che indica se nel confronto tra stringhe deve essere ignorata la distinzione tra maiuscole e minuscole per il nome del membro.</summary>
      <returns>
        <see langword="true" />Se case viene ignorato; in caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.Name">
      <summary>Ottiene il nome del membro da richiamare.</summary>
      <returns>Nome del membro da richiamare.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.ReturnType">
      <summary>Tipo di risultato dell'operazione.</summary>
      <returns>Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di risultato dell'operazione.</returns>
    </member>
    <member name="T:System.Dynamic.SetIndexBinder">
      <summary>Rappresenta l'operazione dinamica di impostazione dell'indice nel sito di chiamata, fornendo la semantica di associazione e i dettagli sull'operazione.</summary>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Inizializza una nuova istanza dell'oggetto <see cref="T:System.Dynamic.SetIndexBinder" />.</summary>
      <param name="callInfo">Firma degli argomenti nel sito di chiamata.</param>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Esegue l'associazione dell'operazione dinamica di impostazione dell'indice.</summary>
      <param name="target">Destinazione dell'operazione dinamica di impostazione dell'indice.</param>
      <param name="args">Matrice di argomenti dell'operazione dinamica di impostazione dell'indice.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="P:System.Dynamic.SetIndexBinder.CallInfo">
      <summary>Ottiene la firma degli argomenti nel sito di chiamata.</summary>
      <returns>Firma degli argomenti nel sito di chiamata.</returns>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.FallbackSetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Esegue l'associazione dell'operazione dinamica di impostazione dell'indice se l'oggetto dinamico di destinazione non può eseguire l'associazione.</summary>
      <param name="target">Destinazione dell'operazione dinamica di impostazione dell'indice.</param>
      <param name="indexes">Argomenti dell'operazione dinamica di impostazione dell'indice.</param>
      <param name="value">Valore su cui impostare la raccolta.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.FallbackSetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Se sottoposto a override nella classe derivata, esegue l'associazione dell'operazione dinamica di impostazione dell'indice se l'oggetto dinamico di destinazione non può eseguire l'associazione.</summary>
      <param name="target">Destinazione dell'operazione dinamica di impostazione dell'indice.</param>
      <param name="indexes">Argomenti dell'operazione dinamica di impostazione dell'indice.</param>
      <param name="value">Valore su cui impostare la raccolta.</param>
      <param name="errorSuggestion">Risultato dell'associazione da utilizzare se l'associazione non riesce, oppure null.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="P:System.Dynamic.SetIndexBinder.ReturnType">
      <summary>Tipo di risultato dell'operazione.</summary>
      <returns>Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di risultato dell'operazione.</returns>
    </member>
    <member name="T:System.Dynamic.SetMemberBinder">
      <summary>Rappresenta l'operazione dinamica di impostazione del membro nel sito di chiamata, fornendo la semantica di associazione e i dettagli sull'operazione.</summary>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.#ctor(System.String,System.Boolean)">
      <summary>Inizializza una nuova istanza dell'oggetto <see cref="T:System.Dynamic.SetMemberBinder" />.</summary>
      <param name="name">Nome del membro da ottenere.</param>
      <param name="ignoreCase">Restituisce true se nella corrispondenza del nome deve essere ignorata la distinzione tra maiuscole e minuscole; in caso contrario, false.</param>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Esegue l'associazione dell'operazione dinamica di impostazione del membro.</summary>
      <param name="target">Destinazione dell'operazione dinamica di impostazione del membro.</param>
      <param name="args">Matrice di argomenti dell'operazione dinamica di impostazione del membro.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.FallbackSetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Esegue l'associazione dell'operazione dinamica di impostazione del membro se l'oggetto dinamico di destinazione non può eseguire l'associazione.</summary>
      <param name="target">Destinazione dell'operazione dinamica di impostazione del membro.</param>
      <param name="value">Valore su cui impostare il membro.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.FallbackSetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Esegue l'associazione dell'operazione dinamica di impostazione del membro se l'oggetto dinamico di destinazione non può eseguire l'associazione.</summary>
      <param name="target">Destinazione dell'operazione dinamica di impostazione del membro.</param>
      <param name="value">Valore su cui impostare il membro.</param>
      <param name="errorSuggestion">Risultato dell'associazione da usare se l'associazione non riesce, o null.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.IgnoreCase">
      <summary>Ottiene il valore che indica se nel confronto tra stringhe deve essere ignorata la distinzione tra maiuscole e minuscole per il nome del membro.</summary>
      <returns>
        <see langword="true" />Se case viene ignorato; in caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.Name">
      <summary>Ottiene il nome del membro da ottenere.</summary>
      <returns>Nome del membro da ottenere.</returns>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.ReturnType">
      <summary>Tipo di risultato dell'operazione.</summary>
      <returns>Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di risultato dell'operazione.</returns>
    </member>
    <member name="T:System.Dynamic.UnaryOperationBinder">
      <summary>Rappresenta l'operazione dinamica unaria nel sito di chiamata, fornendo la semantica di associazione e i dettagli sull'operazione.</summary>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.#ctor(System.Linq.Expressions.ExpressionType)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Dynamic.BinaryOperationBinder" />.</summary>
      <param name="operation">Tipo di operazione unaria.</param>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Esegue l'associazione dell'operazione unaria dinamica.</summary>
      <param name="target">Destinazione dell'operazione dinamica.</param>
      <param name="args">Matrice di argomenti dell'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.FallbackUnaryOperation(System.Dynamic.DynamicMetaObject)">
      <summary>Esegue l'associazione dell'operazione unaria dinamica se l'oggetto dinamico di destinazione non può eseguire l'associazione.</summary>
      <param name="target">Destinazione dell'operazione unaria dinamica.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.FallbackUnaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Esegue l'associazione dell'operazione unaria dinamica se l'oggetto dinamico di destinazione non può eseguire l'associazione.</summary>
      <param name="target">Destinazione dell'operazione unaria dinamica.</param>
      <param name="errorSuggestion">Risultato dell'associazione se l'associazione non riesce, oppure null.</param>
      <returns>Oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che rappresenta il risultato dell'associazione.</returns>
    </member>
    <member name="P:System.Dynamic.UnaryOperationBinder.Operation">
      <summary>Tipo di operazione unaria.</summary>
      <returns>Oggetto di <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta il tipo di operazione unaria.</returns>
    </member>
    <member name="P:System.Dynamic.UnaryOperationBinder.ReturnType">
      <summary>Tipo di risultato dell'operazione.</summary>
      <returns>Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di risultato dell'operazione.</returns>
    </member>
    <member name="T:System.Linq.Expressions.BinaryExpression">
      <summary>Rappresenta un'espressione che ha un operatore binario.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo. Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
      <returns>Risultato della visita di questo nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.CanReduce">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione può essere ridotto.</summary>
      <returns>
        <see langword="true" />Se il nodo dell'albero delle espressioni può essere ridotto; in caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Conversion">
      <summary>Ottiene la funzione di conversione del tipo utilizzata da un'operazione di assegnazione coalescing o composta.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> che rappresenta una funzione di conversione di tipi.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLifted">
      <summary>Ottiene un valore che indica se il nodo dell'albero delle espressioni rappresenta una chiamata elevata a un operatore.</summary>
      <returns>
        <see langword="true" /> se il nodo rappresenta una chiamata elevata; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull">
      <summary>Ottiene un valore che indica se il nodo dell'albero delle espressioni rappresenta una chiamata elevata a un operatore il cui tipo restituito è elevato a un tipo nullable.</summary>
      <returns>
        <see langword="true" /> se il tipo restituito dell'operatore è elevato a un tipo nullable; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Left">
      <summary>Ottiene l'operando sinistro dell'operazione binaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando sinistro dell'operazione binaria.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Method">
      <summary>Ottiene il metodo di implementazione per l'operazione binaria.</summary>
      <returns>Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Reduce">
      <summary>Riduce il nodo dell'espressione binaria a un'espressione più semplice.</summary>
      <returns>Espressione ridotta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Right">
      <summary>Ottiene l'operando destro dell'operazione binaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando destro dell'operazione binaria.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati. Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <param name="left">Proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> del risultato.</param>
      <param name="conversion">Proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> del risultato.</param>
      <param name="right">Proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="T:System.Linq.Expressions.BlockExpression">
      <summary>Rappresenta un blocco che contiene una sequenza di espressioni dove possono essere definite le variabili.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo. Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
      <returns>Risultato della visita di questo nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Expressions">
      <summary>Ottiene le espressioni in questo blocco.</summary>
      <returns>La raccolta di sola lettura che contiene tutte le espressioni in questo blocco.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questa espressione. I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Result">
      <summary>Ottiene l'ultima espressione in questo blocco.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'ultima espressione in questo blocco.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.BlockExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati. Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <param name="variables">Proprietà <see cref="P:System.Linq.Expressions.BlockExpression.Variables" /> del risultato.</param>
      <param name="expressions">Proprietà <see cref="P:System.Linq.Expressions.BlockExpression.Expressions" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Variables">
      <summary>Ottiene le variabili definite in questo blocco.</summary>
      <returns>La raccolta di sola lettura che contiene tutte le variabili definite in questo blocco.</returns>
    </member>
    <member name="T:System.Linq.Expressions.CatchBlock">
      <summary>Rappresenta un'istruzione catch in un blocco try.</summary>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Body">
      <summary>Ottiene il corpo di questo blocco catch.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il corpo catch.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Filter">
      <summary>Ottiene il corpo del filtro <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>L'oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il corpo del filtro <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Test">
      <summary>Ottiene il tipo <see cref="T:System.Exception" /> che questo handler cattura.</summary>
      <returns>L'oggetto <see cref="T:System.Type" /> che rappresenta il tipo di <see cref="T:System.Exception" /> che questo handler cattura.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.ToString">
      <summary>Restituisce un oggetto <see cref="T:System.String" /> che rappresenta l'elemento <see cref="T:System.Object" /> corrente.</summary>
      <returns>Oggetto <see cref="T:System.String" /> che rappresenta l'oggetto <see cref="T:System.Object" /> corrente.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.Update(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati. Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <param name="variable">Proprietà <see cref="P:System.Linq.Expressions.CatchBlock.Variable" /> del risultato.</param>
      <param name="filter">Proprietà <see cref="P:System.Linq.Expressions.CatchBlock.Filter" /> del risultato.</param>
      <param name="body">Proprietà <see cref="P:System.Linq.Expressions.CatchBlock.Body" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Variable">
      <summary>Ottiene un riferimento all'oggetto <see cref="T:System.Exception" /> catturato da questo handler.</summary>
      <returns>L'oggetto <see cref="T:System.Linq.Expressions.ParameterExpression" /> che rappresenta un riferimento all'oggetto <see cref="T:System.Exception" /> catturato da questo handler.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConditionalExpression">
      <summary>Rappresenta un'espressione con un operatore condizionale.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo. Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
      <returns>Risultato della visita di questo nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfFalse">
      <summary>Ottiene l'espressione da eseguire se il test restituisce <see langword="false" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'espressione da eseguire se il test è <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfTrue">
      <summary>Ottiene l'espressione da eseguire se il test restituisce <see langword="true" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'espressione da eseguire se il test è <see langword="true" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questa espressione. I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Test">
      <summary>Ottiene il test dell'operazione condizionale.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il test dell'operazione condizionale.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConditionalExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati. Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <param name="test">Proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> del risultato.</param>
      <param name="ifTrue">Proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> del risultato.</param>
      <param name="ifFalse">Proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConstantExpression">
      <summary>Rappresenta un'espressione con un valore costante.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConstantExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo. Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
      <returns>Risultato della visita di questo nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questo oggetto Expression. I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConstantExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Value">
      <summary>Ottiene il valore dell'espressione costante.</summary>
      <returns>
        <see cref="T:System.Object" /> uguale al valore dell'espressione rappresentata.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DebugInfoExpression">
      <summary>Crea o cancella un punto di sequenza per le informazioni di debug, consentendo al debugger di evidenziare il codice sorgente corretto durante l'esecuzione del debug.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DebugInfoExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo. Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
      <returns>Risultato della visita di questo nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Document">
      <summary>Ottiene <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> che rappresenta il file di origine.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> che rappresenta il file di origine.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndColumn">
      <summary>Ottiene la colonna finale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numero della colonna finale del codice utilizzato per generare l'espressione di cui è stato eseguito il wrapping.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndLine">
      <summary>Ottiene la riga finale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numero della riga finale del codice utilizzato per generare l'espressione di cui è stato eseguito il wrapping.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.IsClear">
      <summary>Ottiene il valore per indicare se <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> è per la cancellazione di un punto di sequenza.</summary>
      <returns>
        <see langword="true" />Se è <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> per la cancellazione di un punto di sequenza; <see langword="false" />in caso contrario,.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartColumn">
      <summary>Ottiene la colonna iniziale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numero della colonna iniziale del codice utilizzato per generare l'espressione di cui è stato eseguito il wrapping.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartLine">
      <summary>Ottiene la riga iniziale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numero della riga iniziale del codice utilizzato per generare l'espressione di cui è stato eseguito il wrapping.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DebugInfoExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DefaultExpression">
      <summary>Rappresenta il valore predefinito di un tipo o un'espressione vuota.</summary>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questa espressione. I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DefaultExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DynamicExpression">
      <summary>Rappresenta un'operazione dinamica.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo. Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
      <returns>Risultato della visita di questo nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Arguments">
      <summary>Porta gli argomenti all'operazione dinamica.</summary>
      <returns>Le raccolte di sola lettura che contengono gli argomenti all'operazione dinamica.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Binder">
      <summary>Ottiene <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> che determina il comportamento in fase di esecuzione del sito dinamico.</summary>
      <returns>
        <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />che determina il comportamento di runtime del sito dinamico.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.DelegateType">
      <summary>Ottiene il tipo di delegato usato dal <see cref="T:System.Runtime.CompilerServices.CallSite" />.</summary>
      <returns>Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di delegato usato dal  <see cref="T:System.Runtime.CompilerServices.CallSite" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> che rappresenta un'operazione dinamica associata dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> specificato.</summary>
      <param name="binder">Binder di runtime per l'operazione dinamica.</param>
      <param name="returnType">Tipo di risultato dell'espressione dinamica.</param>
      <param name="arguments">Argomenti per l'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e le cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> che rappresenta un'operazione dinamica associata dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> specificato.</summary>
      <param name="binder">Binder di runtime per l'operazione dinamica.</param>
      <param name="returnType">Tipo di risultato dell'espressione dinamica.</param>
      <param name="arg0">Primo argomento per l'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e le cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> che rappresenta un'operazione dinamica associata dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> specificato.</summary>
      <param name="binder">Binder di runtime per l'operazione dinamica.</param>
      <param name="returnType">Tipo di risultato dell'espressione dinamica.</param>
      <param name="arg0">Primo argomento per l'operazione dinamica.</param>
      <param name="arg1">Secondo argomento per l'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e le cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> che rappresenta un'operazione dinamica associata dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> specificato.</summary>
      <param name="binder">Binder di runtime per l'operazione dinamica.</param>
      <param name="returnType">Tipo di risultato dell'espressione dinamica.</param>
      <param name="arg0">Primo argomento per l'operazione dinamica.</param>
      <param name="arg1">Secondo argomento per l'operazione dinamica.</param>
      <param name="arg2">Terzo argomento per l'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e le cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> che rappresenta un'operazione dinamica associata dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> specificato.</summary>
      <param name="binder">Binder di runtime per l'operazione dinamica.</param>
      <param name="returnType">Tipo di risultato dell'espressione dinamica.</param>
      <param name="arg0">Primo argomento per l'operazione dinamica.</param>
      <param name="arg1">Secondo argomento per l'operazione dinamica.</param>
      <param name="arg2">Terzo argomento per l'operazione dinamica.</param>
      <param name="arg3">Quarto argomento per l'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e le cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> che rappresenta un'operazione dinamica associata dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> specificato.</summary>
      <param name="binder">Binder di runtime per l'operazione dinamica.</param>
      <param name="returnType">Tipo di risultato dell'espressione dinamica.</param>
      <param name="arguments">Argomenti per l'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e le cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> che rappresenta un'operazione dinamica associata dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> specificato.</summary>
      <param name="delegateType">Tipo del delegato usato dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Binder di runtime per l'operazione dinamica.</param>
      <param name="arguments">Argomenti per l'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e le cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> che rappresenta un'operazione dinamica associata dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> specificato e da un argomento.</summary>
      <param name="delegateType">Tipo del delegato usato dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Binder di runtime per l'operazione dinamica.</param>
      <param name="arg0">Argomento per l'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e le cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> che rappresenta un'operazione dinamica associata dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> specificato e da due argomenti.</summary>
      <param name="delegateType">Tipo del delegato usato dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Binder di runtime per l'operazione dinamica.</param>
      <param name="arg0">Primo argomento per l'operazione dinamica.</param>
      <param name="arg1">Secondo argomento per l'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e le cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> che rappresenta un'operazione dinamica associata dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> specificato e da tre argomenti.</summary>
      <param name="delegateType">Tipo del delegato usato dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Binder di runtime per l'operazione dinamica.</param>
      <param name="arg0">Primo argomento per l'operazione dinamica.</param>
      <param name="arg1">Secondo argomento per l'operazione dinamica.</param>
      <param name="arg2">Terzo argomento per l'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e le cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> che rappresenta un'operazione dinamica associata dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> specificato e da quattro argomenti.</summary>
      <param name="delegateType">Tipo del delegato usato dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Binder di runtime per l'operazione dinamica.</param>
      <param name="arg0">Primo argomento per l'operazione dinamica.</param>
      <param name="arg1">Secondo argomento per l'operazione dinamica.</param>
      <param name="arg2">Terzo argomento per l'operazione dinamica.</param>
      <param name="arg3">Quarto argomento per l'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e le cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> che rappresenta un'operazione dinamica associata dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> specificato.</summary>
      <param name="delegateType">Tipo del delegato usato dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Binder di runtime per l'operazione dinamica.</param>
      <param name="arguments">Argomenti per l'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e le cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questa espressione. I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary>Restituisce il numero di argomenti per il nodo dell'albero delle espressioni. Non usare questo membro. Essendo solo di tipo pubblico a causa del refactoring di assembly si usa internamente per le ottimizzazioni delle prestazioni.</summary>
      <returns>Restituisca il valore <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary>Restituisce l'argomento in corrispondenza dell'indice, generando un'eccezione se l'indice non è compreso nell'intervallo. Non usare questo membro. Essendo solo di tipo pubblico a causa del refactoring di assembly si usa internamente per le ottimizzazioni delle prestazioni.</summary>
      <param name="index">Indice dell’argomento.</param>
      <returns>Restituisca il valore <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IDynamicExpression#CreateCallSite">
      <summary>Crea facoltativamente il sito di chiamata e lo restituisce per la cache inline polimorfica di DynamicExpression. Non usare questo membro. Essendo solo di tipo pubblico a causa del refactoring di assembly si usa internamente per le ottimizzazioni delle prestazioni.</summary>
      <returns>Restituisca il valore <see cref="T:System.Object" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IDynamicExpression#Rewrite(System.Linq.Expressions.Expression[])">
      <summary>Riscrivere questo nodo sostituendo gli argomenti dell'espressione dinamica con i valori specificati. Il numero di <paramref name="args" /> deve corrispondere al numero dell'espressione corrente. Non usare questo tipo. Essendo solo di tipo pubblico a causa del refactoring di assembly si usa internamente per le ottimizzazioni delle prestazioni. Questo metodo di supporto consente la riscrittura dei nodi in modo che siano indipendenti dalla classe di implementazione specifica che deriva da DynamicExpression, usata nel sito di chiamata.</summary>
      <param name="args">Argomenti.</param>
      <returns>Restituisce <see cref="T:System.Linq.Expressions.Expression" />, l'espressione riscritta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DynamicExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Confronta il valore inviato al parametro <paramref name="arguments" />, alla proprietà <see langword="Arguments" /> dell'istanza corrente di <see langword="DynamicExpression" />. Se i valori di parametro e della proprietà sono uguali, viene restituita l'istanza corrente. Se non sono uguali, viene restituita una nuova istanza di <see langword="DynamicExpression" /> identica all'istanza corrente con la differenza che la proprietà <see langword="Arguments" /> è impostata sul valore del parametro <paramref name="arguments" />.</summary>
      <param name="arguments">Proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DynamicExpressionVisitor">
      <summary>Rappresenta un visitatore o un rewriter per gli alberi delle espressioni dinamici.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpressionVisitor.#ctor">
      <summary>Inizializza una nuova istanza di <see cref="T:System.Linq.Expressions.DynamicExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpressionVisitor.VisitDynamic(System.Linq.Expressions.DynamicExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.DynamicExpression" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Restituisce <see cref="T:System.Linq.Expressions.Expression" />, l'espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ElementInit">
      <summary>Rappresenta un inizializzatore per un singolo elemento di una raccolta <see cref="T:System.Collections.IEnumerable" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.AddMethod">
      <summary>Ottiene il metodo di istanza utilizzato per aggiungere un elemento a una raccolta <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo di istanza che aggiunge un elemento a una raccolta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.Arguments">
      <summary>Ottiene la raccolta di argomenti passati a un metodo che aggiunge un elemento a una raccolta <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano gli argomenti di un metodo che aggiunge un elemento a una raccolta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary>Restituisce il numero di argomenti per il nodo dell'albero delle espressioni.  Non usare questo membro.  Essendo solo di tipo pubblico a causa del refactoring di assembly si usa internamente per le ottimizzazioni delle prestazioni.</summary>
      <returns>Restituisca il valore <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary>Restituisce l'argomento in corrispondenza dell'indice, generando un'eccezione se l'indice non è compreso nell'intervallo.  Non usare questo membro.  Essendo solo di tipo pubblico a causa del refactoring di assembly si usa internamente per le ottimizzazioni delle prestazioni.</summary>
      <param name="index">Indice dell’argomento.</param>
      <returns>Restituisca il valore <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.ToString">
      <summary>Restituisce una rappresentazione testuale di un oggetto <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Rappresentazione testuale dell'oggetto <see cref="T:System.Linq.Expressions.ElementInit" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati. Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <param name="arguments">Proprietà <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="T:System.Linq.Expressions.Expression">
      <summary>Fornisce la classe di base dalla quale derivano le classi che rappresentano i nodi della struttura ad albero delle espressioni. Contiene anche metodi factory <see langword="static" /> (<see langword="Shared" /> in Visual Basic) per creare i vari di tipi di nodo. Si tratta di una classe <see langword="abstract" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor">
      <summary>Costruisce una nuova istanza di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor(System.Linq.Expressions.ExpressionType,System.Type)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <param name="nodeType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> da impostare come tipo di nodo.</param>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> dell'oggetto <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo. Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
      <returns>Risultato della visita di questo nodo.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di addizione aritmetica che non ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di addizione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di addizione aritmetica che non ha il controllo dell'overflow. Il metodo di implementazione può essere specificato.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oppure non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è <see langword="null" /> e l'operatore di addizione non è definito per i tipi <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di addizione che non ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di addizione che non ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di addizione che non ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di addizione che ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di addizione che ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di addizione che ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di addizione aritmetica che ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di addizione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di addizione aritmetica che ha il controllo dell'overflow. Il metodo di implementazione può essere specificato.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oppure non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è <see langword="null" /> e l'operatore di addizione non è definito per i tipi <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione <see langword="AND" /> bit per bit.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.And" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore <see langword="AND" /> bit per bit non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione <see langword="AND" /> bit per bit. Il metodo di implementazione può essere specificato.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.And" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oppure non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è <see langword="null" /> e l'operatore bit per bit <see langword="AND" /> non è definito per i tipi <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione <see langword="AND" /> condizionale che valuta il secondo operando solo se il primo operando restituisce <see langword="true" />.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore <see langword="AND" /> bit per bit non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.  
In alternativa 
 <paramref name="left" />.Type e <paramref name="right" />.Type non sono dello stesso tipo Boolean.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione <see langword="AND" /> condizionale che valuta il secondo operando solo se il primo operando viene risolto in true. Il metodo di implementazione può essere specificato.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oppure non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è <see langword="null" /> e l'operatore bit per bit <see langword="AND" /> non è definito per i tipi <paramref name="left" />.Type e <paramref name="right" />.Type.  
-oppure- 
 <paramref name="method" /> è <see langword="null" /> e <paramref name="left" />.Type e <paramref name="right" />.Type non sono dello stesso tipo Boolean.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione AND bit per bit.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione AND bit per bit.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione AND bit per bit.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> per accedere a una matrice multidimensionale.</summary>
      <param name="array">Espressione che rappresenta la matrice multidimensionale.</param>
      <param name="indexes">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente le espressioni usate per indicizzare la matrice.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> per accedere a una matrice.</summary>
      <param name="array">Espressione che rappresenta la matrice da indicizzare.</param>
      <param name="indexes">Matrice contenente le espressioni usate per indicizzare la matrice.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" />che rappresenta l'applicazione di un operatore di indice di matrice a una matrice con numero di dimensioni maggiore di 1.</summary>
      <param name="array">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />.</param>
      <param name="indexes">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> o <paramref name="indexes" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type non rappresenta un tipo matrice.  
In alternativa 
Il numero di dimensioni di <paramref name="array" />.Type non corrisponde al numero di elementi in <paramref name="indexes" />.  
In alternativa 
La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di uno o più elementi di <paramref name="indexes" /> non rappresenta il tipo <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta l'applicazione di un operatore di indice di matrice a una matrice con numero di dimensioni pari a 1.</summary>
      <param name="array">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="index">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> o <paramref name="index" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type non rappresenta un tipo matrice.  
-oppure- 
 <paramref name="array" />.Type rappresenta un tipo matrice il cui numero di dimensioni non è pari a 1.  
In alternativa 
 <paramref name="index" />.Type non rappresenta il tipo <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta l'applicazione di un operatore di indice di matrice a una matrice multidimensionale.</summary>
      <param name="array">Matrice di istanze o indici di <see cref="T:System.Linq.Expressions.Expression" /> per l'operazione di indicizzazione delle matrici.</param>
      <param name="indexes">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> o <paramref name="indexes" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type non rappresenta un tipo matrice.  
In alternativa 
Il numero di dimensioni di <paramref name="array" />.Type non corrisponde al numero di elementi in <paramref name="indexes" />.  
-oppure- 
La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di uno o più elementi di <paramref name="indexes" /> non rappresenta il tipo <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'espressione per ottenere la lunghezza di una matrice unidimensionale.</summary>
      <param name="array">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> e la cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> è uguale a <paramref name="array" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type non rappresenta un tipo matrice.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberAssignment" /> che rappresenta l'inizializzazione di un campo o di una proprietà.</summary>
      <param name="member">Oggetto <see cref="T:System.Reflection.MemberInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberAssignment" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> o <paramref name="expression" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> non rappresenta un campo o una proprietà.  
-oppure- 
La proprietà rappresentata da <paramref name="member" /> non dispone di una funzione di accesso <see langword="set" />.  
In alternativa 
 <paramref name="expression" />.Type non è assegnabile al tipo del campo o della proprietà rappresentato da <paramref name="member" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberAssignment" /> che rappresenta l'inizializzazione di un membro usando un metodo della funzione di accesso alle proprietà.</summary>
      <param name="propertyAccessor">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo della funzione di accesso della proprietà.</param>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberAssignment" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> è impostata sull'oggetto <see cref="T:System.Reflection.PropertyInfo" /> che rappresenta la proprietà a cui si accede in <paramref name="propertyAccessor" /> e la cui proprietà <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> è impostata su <paramref name="expression" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> o <paramref name="expression" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> non rappresenta un metodo della funzione di accesso della proprietà.  
-oppure- 
La proprietà a cui accede <paramref name="propertyAccessor" /> non dispone di una funzione di accesso <see langword="set" />.  
-oppure- 
 <paramref name="expression" />.Type non è assegnabile al tipo del campo o della proprietà rappresentato da <paramref name="member" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene le espressioni specificate e non ha variabili.</summary>
      <param name="expressions">Espressioni nel blocco.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene le espressioni e le variabili specificate.</summary>
      <param name="variables">Variabili nel blocco.</param>
      <param name="expressions">Espressioni nel blocco.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene le espressioni e le variabili specificate.</summary>
      <param name="variables">Variabili nel blocco.</param>
      <param name="expressions">Espressioni nel blocco.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene due espressioni e non dispone di variabili.</summary>
      <param name="arg0">Prima espressione nel blocco.</param>
      <param name="arg1">Seconda espressione nel blocco.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene tre espressioni e non dispone di variabili.</summary>
      <param name="arg0">Prima espressione nel blocco.</param>
      <param name="arg1">Seconda espressione nel blocco.</param>
      <param name="arg2">Terza espressione nel blocco.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene quattro espressioni e non dispone di variabili.</summary>
      <param name="arg0">Prima espressione nel blocco.</param>
      <param name="arg1">Seconda espressione nel blocco.</param>
      <param name="arg2">Terza espressione nel blocco.</param>
      <param name="arg3">Quarta espressione nel blocco.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene cinque espressioni e non dispone di variabili.</summary>
      <param name="arg0">Prima espressione nel blocco.</param>
      <param name="arg1">Seconda espressione nel blocco.</param>
      <param name="arg2">Terza espressione nel blocco.</param>
      <param name="arg3">Quarta espressione nel blocco.</param>
      <param name="arg4">Quinta espressione nel blocco.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene le espressioni specificate e non ha variabili.</summary>
      <param name="expressions">Espressioni nel blocco.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene le espressioni specificate, non dispone di variabili e dispone del tipo di risultato specifico.</summary>
      <param name="type">Tipo di risultato del blocco.</param>
      <param name="expressions">Espressioni nel blocco.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene le espressioni e le variabili specificate.</summary>
      <param name="type">Tipo di risultato del blocco.</param>
      <param name="variables">Variabili nel blocco.</param>
      <param name="expressions">Espressioni nel blocco.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene le espressioni e le variabili specificate.</summary>
      <param name="type">Tipo di risultato del blocco.</param>
      <param name="variables">Variabili nel blocco.</param>
      <param name="expressions">Espressioni nel blocco.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene le espressioni specificate, non dispone di variabili e dispone del tipo di risultato specifico.</summary>
      <param name="type">Tipo di risultato del blocco.</param>
      <param name="expressions">Espressioni nel blocco.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione break.</summary>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Break, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" /> e un valore Null da passare all'etichetta di destinazione al momento del passaggio.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione break. Il valore passato all'etichetta al momento del passaggio può essere specificato.</summary>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valore che al momento del passaggio verrà passato all'etichetta associata.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Break, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" /> e <paramref name="value" /> da passare all'etichetta di destinazione al momento del passaggio.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione break con il tipo specificato. Il valore passato all'etichetta al momento del passaggio può essere specificato.</summary>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valore che al momento del passaggio verrà passato all'etichetta associata.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Break, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" />, la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" /> e <paramref name="value" /> da passare all'etichetta di destinazione al momento del passaggio.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione break con il tipo specificato.</summary>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Break, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" /> e la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo che non accetta argomenti.</summary>
      <param name="instance">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che specifica l'istanza per una chiamata a un metodo di istanza. Passare <see langword="null" /> per un metodo <see langword="static" /> (<see langword="Shared" /> in Visual Basic).</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è <see langword="null" />.  
-oppure- 
 <paramref name="instance" /> è <see langword="null" /> e <paramref name="method" /> rappresenta un metodo di istanza.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type non è assegnabile al tipo dichiarante del metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo che accetta argomenti.</summary>
      <param name="instance">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />. Passare <see langword="null" /> per un metodo <see langword="static" /> (<see langword="Shared" /> in Visual Basic).</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è <see langword="null" />.  
-oppure- 
 <paramref name="instance" /> è <see langword="null" /> e <paramref name="method" /> rappresenta un metodo di istanza.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type non è assegnabile al tipo dichiarante del metodo rappresentato da <paramref name="method" />.  
-oppure- 
Il numero di elementi in <paramref name="arguments" /> è diverso dal numero dei parametri per il metodo rappresentato da <paramref name="method" />.  
-oppure- 
Uno o più elementi di <paramref name="arguments" /> non sono assegnabili al parametro corrispondente per il metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo che accetta due argomenti.</summary>
      <param name="instance">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che specifica l'istanza per una chiamata all'istanza. Passare Null per un metodo statico (Shared in Visual Basic).</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di destinazione.</param>
      <param name="arg0">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il primo argomento.</param>
      <param name="arg1">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il secondo argomento.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo che accetta tre argomenti.</summary>
      <param name="instance">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che specifica l'istanza per una chiamata all'istanza. Passare Null per un metodo statico (Shared in Visual Basic).</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di destinazione.</param>
      <param name="arg0">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il primo argomento.</param>
      <param name="arg1">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il secondo argomento.</param>
      <param name="arg2">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il terzo argomento.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo che accetta argomenti.</summary>
      <param name="instance">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che specifica l'istanza per una chiamata a un metodo di istanza. Passare <see langword="null" /> per un metodo <see langword="static" /> (<see langword="Shared" /> in Visual Basic).</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è <see langword="null" />.  
-oppure- 
 <paramref name="instance" /> è <see langword="null" /> e <paramref name="method" /> rappresenta un metodo di istanza.  
-oppure- 
 <paramref name="arguments" /> non è <see langword="null" /> e almeno uno dei relativi elementi è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type non è assegnabile al tipo dichiarante del metodo rappresentato da <paramref name="method" />.  
In alternativa 
Il numero di elementi in <paramref name="arguments" /> è diverso dal numero dei parametri per il metodo rappresentato da <paramref name="method" />.  
-oppure- 
Uno o più elementi di <paramref name="arguments" /> non sono assegnabili al parametro corrispondente per il metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo tramite la chiamata al metodo factory appropriato.</summary>
      <param name="instance">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> nel cui valore della proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> verrà cercato un metodo specificato.</param>
      <param name="methodName">Nome del metodo.</param>
      <param name="typeArguments">Matrice di oggetti <see cref="T:System.Type" /> che specificano i parametri di tipo del metodo generico. Questo argomento deve essere Null quando methodName specifica un metodo non generico.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta gli argomenti del metodo.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, la cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> è uguale a <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> è impostata sull'oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di istanza specificato e il cui oggetto <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> è impostato sugli argomenti specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instance" /> o <paramref name="methodName" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun metodo il cui nome è <paramref name="methodName" />, i cui parametri di tipo corrispondono a <paramref name="typeArguments" />e i cui tipi di parametro corrispondono a <paramref name="arguments" /> viene trovato in <paramref name="instance" />.Type o nei relativi tipi di base.  
In alternativa 
Più di un metodo il cui nome è <paramref name="methodName" />, i cui parametri di tipo corrispondono a <paramref name="typeArguments" />e i cui tipi di parametro corrispondono a <paramref name="arguments" /> viene trovato in <paramref name="instance" />.Type o nei relativi tipi di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo statico (Shared in Visual Basic).</summary>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di destinazione.</param>
      <param name="arguments">Raccolta di <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta gli argomenti della chiamata.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata al metodo <see langword="static" /> (<see langword="Shared" /> in Visual Basic) che accetta un argomento.</summary>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il primo argomento.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo statico che accetta due argomenti.</summary>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il primo argomento.</param>
      <param name="arg1">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il secondo argomento.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo statico che accetta tre argomenti.</summary>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il primo argomento.</param>
      <param name="arg1">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il secondo argomento.</param>
      <param name="arg2">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il terzo argomento.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo statico che accetta quattro argomenti.</summary>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il primo argomento.</param>
      <param name="arg1">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il secondo argomento.</param>
      <param name="arg2">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il terzo argomento.</param>
      <param name="arg3">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il quarto argomento.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo statico che accetta cinque argomenti.</summary>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il primo argomento.</param>
      <param name="arg1">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il secondo argomento.</param>
      <param name="arg2">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il terzo argomento.</param>
      <param name="arg3">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il quarto argomento.</param>
      <param name="arg4">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il quinto argomento.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo <see langword="static" /> (<see langword="Shared" /> in Visual Basic) con argomenti.</summary>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo <see langword="static" /> (<see langword="Shared" /> in Visual Basic) su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Il numero di elementi in <paramref name="arguments" /> è diverso dal numero dei parametri per il metodo rappresentato da <paramref name="method" />.  
-oppure- 
Uno o più elementi di <paramref name="arguments" /> non sono assegnabili al parametro corrispondente per il metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo <see langword="static" /> (<see langword="Shared" /> in Visual Basic) tramite la chiamata al metodo factory appropriato.</summary>
      <param name="type">Tipo contenente il metodo <see langword="static" /> (<see langword="Shared" /> in Visual Basic) specificato.</param>
      <param name="methodName">Nome del metodo.</param>
      <param name="typeArguments">Matrice di oggetti <see cref="T:System.Type" /> che specificano i parametri di tipo del metodo generico. Questo argomento deve essere Null quando methodName specifica un metodo non generico.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano gli argomenti del metodo.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, la cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> è impostata sull'oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo <see langword="static" /> (<see langword="Shared" /> in Visual Basic) specificato e la cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> è impostata sugli argomenti specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="methodName" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun metodo il cui nome è <paramref name="methodName" />, i cui parametri di tipo corrispondono a <paramref name="typeArguments" />e i cui tipi di parametro corrispondono a <paramref name="arguments" /> viene trovato in <paramref name="type" /> o nei relativi tipi di base.  
-oppure- 
Più di un metodo il cui nome è <paramref name="methodName" />, i cui parametri di tipo corrispondono a <paramref name="typeArguments" />e i cui tipi di parametro corrispondono a <paramref name="arguments" /> viene trovato in <paramref name="type" /> o nei relativi tipi di base.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.CanReduce">
      <summary>Indica che il nodo può essere ridotto a un nodo più semplice. Se restituisce true, è possibile chiamare Reduce() per generare la forma ridotta.</summary>
      <returns>
        <see langword="true" />Se il nodo può essere ridotto; in caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresenta un'istruzione catch con un riferimento all'oggetto <see cref="T:System.Exception" /> intercettato per l'uso nel corpo del gestore.</summary>
      <param name="variable">Oggetto <see cref="T:System.Linq.Expressions.ParameterExpression" /> che rappresenta un riferimento all'oggetto <see cref="T:System.Exception" /> intercettato da questo gestore.</param>
      <param name="body">Corpo dell'istruzione catch.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresenta un'istruzione catch con un filtro <see cref="T:System.Exception" /> e un riferimento all'oggetto <see cref="T:System.Exception" /> intercettato.</summary>
      <param name="variable">Oggetto <see cref="T:System.Linq.Expressions.ParameterExpression" /> che rappresenta un riferimento all'oggetto <see cref="T:System.Exception" /> intercettato da questo gestore.</param>
      <param name="body">Corpo dell'istruzione catch.</param>
      <param name="filter">Corpo del filtro <see cref="T:System.Exception" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresenta un'istruzione catch.</summary>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> di <see cref="T:System.Exception" /> che verrà gestito da questo oggetto <see cref="T:System.Linq.Expressions.CatchBlock" />.</param>
      <param name="body">Corpo dell'istruzione catch.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresenta un'istruzione catch con un filtro <see cref="T:System.Exception" /> ma nessun riferimento all'oggetto <see cref="T:System.Exception" /> intercettato.</summary>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> di <see cref="T:System.Exception" /> che verrà gestito da questo oggetto <see cref="T:System.Linq.Expressions.CatchBlock" />.</param>
      <param name="body">Corpo dell'istruzione catch.</param>
      <param name="filter">Corpo del filtro <see cref="T:System.Exception" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> per la cancellazione di un punto di sequenza.</summary>
      <param name="document">Oggetto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> che rappresenta il file di origine.</param>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> per la cancellazione di un punto di sequenza.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione coalescing.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di <paramref name="left" /> non rappresenta un tipo di riferimento o un tipo valore nullable.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type e <paramref name="right" />.Type non sono convertibili l'uno nell'altro.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione coalescing, data una funzione di conversione.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type e <paramref name="right" />.Type non sono convertibili l'uno nell'altro.  
In alternativa 
 <paramref name="conversion" /> non è <see langword="null" /> e <paramref name="conversion" />.Type è un tipo delegato che non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di <paramref name="left" /> non rappresenta un tipo di riferimento o un tipo valore nullable.  
-oppure- 
La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di <paramref name="left" /> rappresenta un tipo non assegnabile al tipo di parametro del tipo delegato <paramref name="conversion" />.Type.  
In alternativa 
La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di <paramref name="right" /> è diversa dal tipo restituito del tipo delegato <paramref name="conversion" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> che rappresenta un'istruzione condizionale.</summary>
      <param name="test">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e le cui proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="test" />, il parametro <paramref name="ifTrue" /> o il parametro <paramref name="ifFalse" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="test" />.Type non è <see cref="T:System.Boolean" />.  
-oppure- 
 <paramref name="ifTrue" />.Type è diverso da <paramref name="ifFalse" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> che rappresenta un'istruzione condizionale.</summary>
      <param name="test">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e le cui proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ConstantExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> è impostata sul valore specificato.</summary>
      <param name="value">Oggetto <see cref="T:System.Object" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ConstantExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> e la cui proprietà <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> è impostata sul valore specificato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ConstantExpression" /> le cui proprietà <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> sono impostate sui valori specificati.</summary>
      <param name="value">Oggetto <see cref="T:System.Object" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ConstantExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> e le cui proprietà <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> non è <see langword="null" /> e <paramref name="type" /> non è assegnabile dal tipo dinamico di <paramref name="value" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione continue.</summary>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Continue, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" /> e un valore Null da passare all'etichetta di destinazione al momento del passaggio.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione continue con il tipo specificato.</summary>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Continue, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" />, la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" /> e un valore Null da passare all'etichetta di destinazione al momento del passaggio.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di conversione di tipo.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun operatore di conversione è definito tra <paramref name="expression" />.Type e <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di conversione per la quale è specificato il metodo di implementazione.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) o non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun operatore di conversione è definito tra <paramref name="expression" />.Type e <paramref name="type" />.  
In alternativa 
 <paramref name="expression" />.Type non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="method" />.  
-oppure- 
Il tipo restituito del metodo rappresentato da <paramref name="method" /> non è assegnabile a <paramref name="type" />.  
-oppure- 
 <paramref name="expression" />.Type o <paramref name="type" /> è un tipo valore nullable e il tipo valore non nullable corrispondente è diverso dal tipo di argomento o dal tipo restituito, rispettivamente, del metodo rappresentato da <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">È stato trovato più di un metodo che corrisponde alla descrizione di <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di conversione che genera un'eccezione in caso di overflow del tipo di destinazione.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun operatore di conversione è definito tra <paramref name="expression" />.Type e <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di conversione che genera un'eccezione in caso di overflow del tipo di destinazione e per la quale è specificato il metodo di implementazione.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) o non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun operatore di conversione è definito tra <paramref name="expression" />.Type e <paramref name="type" />.  
-oppure- 
 <paramref name="expression" />.Type non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="method" />.  
-oppure- 
Il tipo restituito del metodo rappresentato da <paramref name="method" /> non è assegnabile a <paramref name="type" />.  
In alternativa 
 <paramref name="expression" />.Type o <paramref name="type" /> è un tipo valore nullable e il tipo valore non nullable corrispondente è diverso dal tipo di argomento o dal tipo restituito, rispettivamente, del metodo rappresentato da <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">È stato trovato più di un metodo che corrisponde alla descrizione di <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> con l'intervallo specificato.</summary>
      <param name="document">Oggetto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> che rappresenta il file di origine.</param>
      <param name="startLine">Riga iniziale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Deve essere maggiore di 0.</param>
      <param name="startColumn">Colonna iniziale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Deve essere maggiore di 0.</param>
      <param name="endLine">Riga finale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Deve essere maggiore di o uguale alla riga iniziale.</param>
      <param name="endColumn">Colonna finale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Se la riga finale corrisponde alla riga iniziale, deve essere maggiore di o uguale alla colonna iniziale. In qualsiasi caso, deve essere maggiore di 0.</param>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta il decremento dell'espressione di 1.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> da decrementare.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione decrementata.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta il decremento dell'espressione di 1.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> da decrementare.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione decrementata.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Default(System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DefaultExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> è impostata sul tipo specificato.</summary>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DefaultExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> e la cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> è impostata sul tipo specificato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di divisione aritmetica.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di divisione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di divisione aritmetica. Il metodo di implementazione può essere specificato.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oppure non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è <see langword="null" /> e l'operatore di divisione non è definito per i tipi <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di divisione che non ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di divisione che non ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di divisione che non ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> che rappresenta un'operazione dinamica associata dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> specificato.</summary>
      <param name="binder">Binder di runtime per l'operazione dinamica.</param>
      <param name="returnType">Tipo di risultato dell'espressione dinamica.</param>
      <param name="arguments">Argomenti per l'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e le cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> che rappresenta un'operazione dinamica associata dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> specificato.</summary>
      <param name="binder">Binder di runtime per l'operazione dinamica.</param>
      <param name="returnType">Tipo di risultato dell'espressione dinamica.</param>
      <param name="arg0">Primo argomento per l'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e le cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> che rappresenta un'operazione dinamica associata dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> specificato.</summary>
      <param name="binder">Binder di runtime per l'operazione dinamica.</param>
      <param name="returnType">Tipo di risultato dell'espressione dinamica.</param>
      <param name="arg0">Primo argomento per l'operazione dinamica.</param>
      <param name="arg1">Secondo argomento per l'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e le cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> che rappresenta un'operazione dinamica associata dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> specificato.</summary>
      <param name="binder">Binder di runtime per l'operazione dinamica.</param>
      <param name="returnType">Tipo di risultato dell'espressione dinamica.</param>
      <param name="arg0">Primo argomento per l'operazione dinamica.</param>
      <param name="arg1">Secondo argomento per l'operazione dinamica.</param>
      <param name="arg2">Terzo argomento per l'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e le cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> che rappresenta un'operazione dinamica associata dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> specificato.</summary>
      <param name="binder">Binder di runtime per l'operazione dinamica.</param>
      <param name="returnType">Tipo di risultato dell'espressione dinamica.</param>
      <param name="arg0">Primo argomento per l'operazione dinamica.</param>
      <param name="arg1">Secondo argomento per l'operazione dinamica.</param>
      <param name="arg2">Terzo argomento per l'operazione dinamica.</param>
      <param name="arg3">Quarto argomento per l'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e le cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> che rappresenta un'operazione dinamica associata dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> specificato.</summary>
      <param name="binder">Binder di runtime per l'operazione dinamica.</param>
      <param name="returnType">Tipo di risultato dell'espressione dinamica.</param>
      <param name="arguments">Argomenti per l'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e le cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ElementInit" />, dato <see cref="T:System.Collections.Generic.IEnumerable`1" /> come secondo argomento.</summary>
      <param name="addMethod">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />.</param>
      <param name="arguments">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> che contiene gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ElementInit" /> le cui proprietà <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> e <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> o <paramref name="arguments" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Il metodo rappresentato da <paramref name="addMethod" /> non è denominato "Add" (senza distinzione tra maiuscole e minuscole).  
-oppure- 
Il metodo rappresentato da <paramref name="addMethod" /> non è un metodo di istanza.  
-oppure- 
 <paramref name="arguments" /> non contiene lo stesso numero di elementi dei parametri del metodo rappresentato da <paramref name="addMethod" />.  
-oppure- 
La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di uno o più elementi di <paramref name="arguments" /> non può essere assegnata al tipo del parametro corrispondente del metodo rappresentato da <paramref name="addMethod" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ElementInit" />, data una matrice di valori come secondo argomento.</summary>
      <param name="addMethod">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ElementInit" /> le cui proprietà <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> e <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> o <paramref name="arguments" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Il metodo che addMethod rappresenta non è denominato "Add" (senza distinzione tra maiuscole e minuscole).  
-oppure- 
Il metodo che addMethod rappresenta non è un metodo di istanza.  
In alternativa 
Il numero di elementi in arguments è diverso dal numero di parametri del metodo rappresentato da addMethod.  
-oppure- 
La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di uno o più elementi di <paramref name="arguments" /> non può essere assegnata al tipo del parametro corrispondente del metodo rappresentato da <paramref name="addMethod" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Empty">
      <summary>Crea un'espressione vuota di tipo <see cref="T:System.Void" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DefaultExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> e la cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> è impostata su <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto di uguaglianza.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di uguaglianza non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto di uguaglianza. Il metodo di implementazione può essere specificato.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">
        <see langword="true" /> per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su <see langword="true" />; <see langword="false" /> per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su <see langword="false" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oppure non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è <see langword="null" /> e l'operatore di uguaglianza non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione <see langword="XOR" /> bit per bit, usando <c>op_ExclusiveOr</c> per i tipi definiti dall'utente.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore <see langword="XOR" /> non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione <see langword="XOR" /> bit per bit, usando <c>op_ExclusiveOr</c> per i tipi definiti dall'utente. Il metodo di implementazione può essere specificato.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oppure non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è <see langword="null" /> e l'operatore <see langword="XOR" /> non è definito per i tipi <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione XOR bit per bit, usando <c>op_ExclusiveOr</c> per i tipi definiti dall'utente.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione XOR bit per bit, usando <c>op_ExclusiveOr</c> per i tipi definiti dall'utente.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione XOR bit per bit, usando <c>op_ExclusiveOr</c> per i tipi definiti dall'utente.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a un campo.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />. Per <see langword="static" /> (<see langword="Shared" /> in Visual Basic), <paramref name="expression" /> deve essere <see langword="null" />.</param>
      <param name="field">Oggetto <see cref="T:System.Reflection.FieldInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Member" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> e <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="field" /> è <see langword="null" />.  
-oppure- 
Il campo rappresentato da <paramref name="field" /> non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) e <paramref name="expression" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type non è assegnabile al tipo dichiarante del campo rappresentato da <paramref name="field" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a un campo, dato il nome del campo.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene un campo denominato <paramref name="fieldName" />. Può essere Null per i campi statici.</param>
      <param name="fieldName">Nome di un campo a cui accedere.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> è impostata su <paramref name="expression" /> e la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> è impostata sull'oggetto <see cref="T:System.Reflection.FieldInfo" /> che rappresenta il campo identificato da <paramref name="fieldName" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="fieldName" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Nessun campo denominato <paramref name="fieldName" /> è definito in <paramref name="expression" />.Type o nei relativi tipi di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a un campo.</summary>
      <param name="expression">Oggetto contenitore del campo. Può essere Null per i campi statici.</param>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che contiene il campo.</param>
      <param name="fieldName">Campo al quale accedere.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])">
      <summary>Crea un oggetto <see cref="T:System.Type" /> che rappresenta un tipo delegato <c>System.Action</c> generico con argomenti tipo specifici.</summary>
      <param name="typeArgs">Matrice costituita da zero a sedici oggetti <see cref="T:System.Type" /> che specificano gli argomenti di tipo per il tipo delegato <see langword="System.Action" />.</param>
      <returns>Tipo di un delegato <c>System.Action</c> con argomenti di tipo specificati.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contiene più di sedici elementi.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArgs" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])">
      <summary>Ottiene un oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che rappresenta un tipo delegato <c>System.Func</c> o <c>System.Action</c> generico con argomenti tipo specifici.</summary>
      <param name="typeArgs">Argomenti di tipo del delegato.</param>
      <returns>Tipo di delegato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])">
      <summary>Crea un oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che rappresenta un tipo delegato <c>System.Func</c> generico con argomenti tipo specifici. L'ultimo argomento di tipo specifica il tipo restituito del delegato creato.</summary>
      <param name="typeArgs">Matrice costituita da zero a diciassette oggetti <see cref="T:System.Type" /> che specificano gli argomenti di tipo per il tipo delegato <see langword="System.Func" />.</param>
      <returns>Tipo di un delegato <c>System.Func</c> con gli argomenti tipo specificati.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contiene meno di uno o più di diciassette elementi.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArgs" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione "go to".</summary>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Goto, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata sul valore specificato e un valore Null da passare all'etichetta di destinazione al momento del passaggio.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione "go to". Il valore passato all'etichetta al momento del passaggio può essere specificato.</summary>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valore che al momento del passaggio verrà passato all'etichetta associata.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Goto, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" /> e <paramref name="value" /> da passare all'etichetta di destinazione al momento del passaggio.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione "go to" con il tipo specificato. Il valore passato all'etichetta al momento del passaggio può essere specificato.</summary>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valore che al momento del passaggio verrà passato all'etichetta associata.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Goto, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" />, la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" /> e <paramref name="value" /> da passare all'etichetta di destinazione al momento del passaggio.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione "go to" con il tipo specificato.</summary>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Goto, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata sul valore specificato, la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" /> e un valore Null da passare all'etichetta di destinazione al momento del passaggio.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "maggiore di".</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore "maggiore di" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "maggiore di". Il metodo di implementazione può essere specificato.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">
        <see langword="true" /> per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su <see langword="true" />; <see langword="false" /> per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su <see langword="false" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oppure non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è <see langword="null" /> e l'operatore "maggiore di" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "maggiore o uguale a".</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore "maggiore o uguale a" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "maggiore o uguale a".</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">
        <see langword="true" /> per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su <see langword="true" />; <see langword="false" /> per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su <see langword="false" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oppure non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è <see langword="null" /> e l'operatore "maggiore o uguale a" non è definito per i tipi <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> che rappresenta un blocco condizionale con un'istruzione <see langword="if" />.</summary>
      <param name="test">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e le cui proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> sono impostate sui valori specificati. La proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> è impostata sull'espressione predefinita e il tipo dell'oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> risultante restituito da questo metodo è <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> che rappresenta un blocco condizionale con le istruzioni <see langword="if" /> e <see langword="else" />.</summary>
      <param name="test">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e le cui proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> sono impostate sui valori specificati. Il tipo dell'oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> risultante restituito da questo metodo è <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'incremento del valore dell'espressione di 1.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> da incrementare.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione incrementata.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'incremento dell'espressione di 1.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> da incrementare.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione incrementata.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.InvocationExpression" /> che applica un delegato o un'espressione lambda a un elenco di espressioni di argomento.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il delegato o l'espressione lambda da applicare.</param>
      <param name="arguments">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano gli argomenti ai quali viene applicato il delegato o l'espressione lambda.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.InvocationExpression" /> che applica il delegato o l'espressione lambda specificata agli argomenti forniti.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type non rappresenta un tipo delegato o <see cref="T:System.Linq.Expressions.Expression`1" />.  
-oppure- 
La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="arguments" /> non è assegnabile al tipo del parametro corrispondente del delegato rappresentato da <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">Il numero di elementi in <paramref name="arguments" /> è diverso dal numero di parametri elencato per il delegato rappresentato da <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.InvocationExpression" /> che applica un delegato o un'espressione lambda a un elenco di espressioni di argomento.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il delegato o l'espressione lambda da applicare.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano gli argomenti ai quali viene applicato il delegato o l'espressione lambda.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.InvocationExpression" /> che applica il delegato o l'espressione lambda specificata agli argomenti forniti.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type non rappresenta un tipo delegato o <see cref="T:System.Linq.Expressions.Expression`1" />.  
-oppure- 
La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="arguments" /> non è assegnabile al tipo del parametro corrispondente del delegato rappresentato da <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">Il numero di elementi in <paramref name="arguments" /> è diverso dal numero di parametri elencato per il delegato rappresentato da <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)">
      <summary>Restituisce un valore che indica se l'espressione restituisce false.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> da valutare.</param>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Restituisce un valore che indica se l'espressione restituisce false.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> da valutare.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)">
      <summary>Restituisce un valore che indica se l'espressione restituisce true.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> da valutare.</param>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Restituisce un valore che indica se l'espressione restituisce true.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> da valutare.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> che rappresenta un'etichetta con tipo void e nessun nome.</summary>
      <returns>Nuovo oggetto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LabelExpression" /> che rappresenta un'etichetta senza un valore predefinito.</summary>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> al quale verrà associato questo oggetto <see cref="T:System.Linq.Expressions.LabelExpression" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LabelExpression" /> senza un valore predefinito.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LabelExpression" /> che rappresenta un'etichetta con il valore predefinito specificato.</summary>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> al quale verrà associato questo oggetto <see cref="T:System.Linq.Expressions.LabelExpression" />.</param>
      <param name="defaultValue">Valore di questo oggetto <see cref="T:System.Linq.Expressions.LabelExpression" /> quando l'etichetta viene raggiunta tramite il normale flusso di controllo.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LabelExpression" /> con il valore predefinito specificato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.String)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> che rappresenta un'etichetta con tipo void e il nome specificato.</summary>
      <param name="name">Nome dell'etichetta.</param>
      <returns>Nuovo oggetto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> che rappresenta un'etichetta con il tipo specificato.</summary>
      <param name="type">Tipo di valore passato durante il passaggio all'etichetta.</param>
      <returns>Nuovo oggetto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> che rappresenta un'etichetta con il tipo e il nome specificati.</summary>
      <param name="type">Tipo di valore passato durante il passaggio all'etichetta.</param>
      <param name="name">Nome dell'etichetta.</param>
      <returns>Nuovo oggetto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un <see cref="T:System.Linq.Expressions.LambdaExpression" /> costruendo prima un tipo delegato dal corpo dell'espressione, un parametro che indica se l'ottimizzazione della chiamata tail verrà applicata, e una raccolta enumerabile di espressioni per i parametri. Può essere usato quando il tipo delegato non è noto in fase di compilazione.</summary>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">Oggetto <see cref="T:System.Boolean" /> che indica se l'ottimizzazione della chiamata tail verrà applicata durante la compilazione dell'espressione creata.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a Lambda e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un <see cref="T:System.Linq.Expressions.LambdaExpression" /> costruendo prima un tipo delegato dal corpo dell'espressione, un parametro che indica se l'ottimizzazione della chiamata tail verrà applicata, e una matrice di espressioni per i parametri. Può essere usato quando il tipo delegato non è noto in fase di compilazione.</summary>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">Oggetto <see cref="T:System.Boolean" /> che indica se l'ottimizzazione della chiamata tail verrà applicata durante la compilazione dell'espressione creata.</param>
      <param name="parameters">Matrice contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a Lambda e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un <see cref="T:System.Linq.Expressions.LambdaExpression" /> costruendo prima un tipo delegato dal corpo dell'espressione e una raccolta enumerabile di espressioni per i parametri. Può essere usato quando il tipo delegato non è noto in fase di compilazione.</summary>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a Lambda e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un <see cref="T:System.Linq.Expressions.LambdaExpression" /> costruendo prima un tipo delegato dal corpo dell'espressione e una matrice di espressioni per i parametri. Può essere usato quando il tipo delegato non è noto in fase di compilazione.</summary>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matrice di oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> è <see langword="null" />.  
In alternativa 
Uno o più elementi di <paramref name="parameters" /> sono <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="parameters" /> contiene più di sedici elementi.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un <see cref="T:System.Linq.Expressions.LambdaExpression" /> costruendo prima un tipo delegato dal corpo dell'espressione, il nome per l'espressione lambda, un parametro che indica se l'ottimizzazione della chiamata tail verrà applicata e una raccolta enumerabile di espressioni per i parametri. Può essere usato quando il tipo delegato non è noto in fase di compilazione.</summary>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nome dell'espressione lambda. Usato per la creazione di informazioni di debug.</param>
      <param name="tailCall">Oggetto <see cref="T:System.Boolean" /> che indica se l'ottimizzazione della chiamata tail verrà applicata durante la compilazione dell'espressione creata.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a Lambda e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un <see cref="T:System.Linq.Expressions.LambdaExpression" /> costruendo prima un tipo delegato dal corpo dell'espressione, il nome dell'espressione lambda, e una raccolta enumerabile di espressioni per i parametri. Può essere usato quando il tipo delegato non è noto in fase di compilazione.</summary>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nome dell'espressione lambda. Usato per la creazione di informazioni di debug.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a Lambda e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un <see cref="T:System.Linq.Expressions.LambdaExpression" /> in cui il tipo delegato è noto in fase di compilazione, con un parametro che indica se l'ottimizzazione della chiamata tail verrà applicata e una raccolta enumerabile di espressioni per i parametri.</summary>
      <param name="delegateType">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che rappresenta la firma del delegato per l'espressione lambda.</param>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">Oggetto <see cref="T:System.Boolean" /> che indica se l'ottimizzazione della chiamata tail verrà applicata durante la compilazione dell'espressione creata.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a Lambda e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un <see cref="T:System.Linq.Expressions.LambdaExpression" /> in cui il tipo delegato è noto in fase di compilazione, con un parametro che indica se l'ottimizzazione della chiamata tail verrà applicata e una matrice di espressioni per i parametri.</summary>
      <param name="delegateType">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che rappresenta la firma del delegato per l'espressione lambda.</param>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">Oggetto <see cref="T:System.Boolean" /> che indica se l'ottimizzazione della chiamata tail verrà applicata durante la compilazione dell'espressione creata.</param>
      <param name="parameters">Matrice contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a Lambda e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un <see cref="T:System.Linq.Expressions.LambdaExpression" /> in cui il tipo delegato è noto in fase di compilazione, con una raccolta enumerabile di espressioni per i parametri.</summary>
      <param name="delegateType">Oggetto <see cref="T:System.Type" /> che rappresenta una firma di delegato per l'espressione lambda.</param>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>Oggetto che rappresenta un'espressione lambda la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="delegateType" /> o <paramref name="body" /> è <see langword="null" />.  
-oppure- 
Uno o più elementi in <paramref name="parameters" /> sono <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> non rappresenta un tipo delegato.  
-oppure- 
 <paramref name="body" />.Type rappresenta un tipo non assegnabile al tipo restituito del tipo delegato rappresentato da <paramref name="delegateType" />.  
-oppure- 
 Il numero di elementi in <paramref name="parameters" /> è diverso dal numero di parametri elencato per il tipo delegato rappresentato da <paramref name="delegateType" />.  
-oppure- 
La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="parameters" /> non è assegnabile dal tipo del parametro corrispondente del tipo di delegato rappresentato da <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un <see cref="T:System.Linq.Expressions.LambdaExpression" /> in cui il tipo delegato è noto in fase di compilazione, con una matrice di espressioni per i parametri.</summary>
      <param name="delegateType">Oggetto <see cref="T:System.Type" /> che rappresenta una firma di delegato per l'espressione lambda.</param>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matrice di oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>Oggetto che rappresenta un'espressione lambda la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="delegateType" /> o <paramref name="body" /> è <see langword="null" />.  
In alternativa 
Uno o più elementi in <paramref name="parameters" /> sono <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> non rappresenta un tipo delegato.  
In alternativa 
 <paramref name="body" />.Type rappresenta un tipo non assegnabile al tipo restituito del tipo delegato rappresentato da <paramref name="delegateType" />.  
-oppure- 
 Il numero di elementi in <paramref name="parameters" /> è diverso dal numero di parametri elencato per il tipo delegato rappresentato da <paramref name="delegateType" />.  
In alternativa 
La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="parameters" /> non è assegnabile dal tipo del parametro corrispondente del tipo di delegato rappresentato da <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un <see cref="T:System.Linq.Expressions.LambdaExpression" /> in cui il tipo delegato è noto in fase di compilazione, con il nome per l'espressione lambda, un parametro che indica se l'ottimizzazione della chiamata tail verrà applicata e una raccolta enumerabile di espressioni per i parametri.</summary>
      <param name="delegateType">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che rappresenta la firma del delegato per l'espressione lambda.</param>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nome dell'espressione lambda. Usato per la creazione di informazioni di debug.</param>
      <param name="tailCall">Oggetto <see cref="T:System.Boolean" /> che indica se l'ottimizzazione della chiamata tail verrà applicata durante la compilazione dell'espressione creata.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a Lambda e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un <see cref="T:System.Linq.Expressions.LambdaExpression" /> in cui il tipo delegato è noto in fase di compilazione, con il nome dell'espressione lambda e una raccolta enumerabile di espressioni per i parametri.</summary>
      <param name="delegateType">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che rappresenta la firma del delegato per l'espressione lambda.</param>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nome dell'espressione lambda. Usato per la creazione di informazioni di debug.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a Lambda e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un <see cref="T:System.Linq.Expressions.Expression`1" /> in cui il tipo delegato è noto in fase di compilazione, con un parametro che indica se l'ottimizzazione della chiamata tail verrà applicata e una raccolta enumerabile di espressioni per i parametri.</summary>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">Oggetto <see cref="T:System.Boolean" /> che indica se l'ottimizzazione della chiamata tail verrà applicata durante la compilazione dell'espressione creata.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo di delegato.</typeparam>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un <see cref="T:System.Linq.Expressions.Expression`1" /> in cui il tipo delegato è noto in fase di compilazione, con un parametro che indica se l'ottimizzazione della chiamata tail verrà applicata e una matrice di espressioni per i parametri.</summary>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">Oggetto <see cref="T:System.Boolean" /> che indica se l'ottimizzazione della chiamata tail verrà applicata durante la compilazione dell'espressione creata.</param>
      <param name="parameters">Matrice contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo di delegato.</typeparam>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un <see cref="T:System.Linq.Expressions.Expression`1" /> in cui il tipo di delegato è noto in fase di compilazione, con una raccolta enumerabile di espressioni per i parametri.</summary>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo delegato.</typeparam>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> è <see langword="null" />.  
-oppure- 
Uno o più elementi in <paramref name="parameters" /> sono <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> non è un tipo delegato.  
In alternativa 
 <paramref name="body" />.Type rappresenta un tipo non assegnabile al tipo restituito di <paramref name="TDelegate" />.  
In alternativa 
 Il numero di elementi in <paramref name="parameters" /> è diverso dal numero di parametri elencato per <paramref name="TDelegate" />.  
In alternativa 
La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="parameters" /> non è assegnabile dal tipo del parametro corrispondente di <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un <see cref="T:System.Linq.Expressions.Expression`1" /> in cui il tipo delegato è noto in fase di compilazione, con una matrice di espressioni per i parametri.</summary>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matrice di oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo delegato.</typeparam>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> è <see langword="null" />.  
-oppure- 
Uno o più elementi in <paramref name="parameters" /> sono <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> non è un tipo delegato.  
-oppure- 
 <paramref name="body" />.Type rappresenta un tipo non assegnabile al tipo restituito di <paramref name="TDelegate" />.  
In alternativa 
 Il numero di elementi in <paramref name="parameters" /> è diverso dal numero di parametri elencato per <paramref name="TDelegate" />.  
-oppure- 
La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="parameters" /> non è assegnabile dal tipo del parametro corrispondente di <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un <see cref="T:System.Linq.Expressions.Expression`1" /> in cui il tipo delegato è noto in fase di compilazione, con il nome per l'espressione lambda, un parametro che indica se l'ottimizzazione della chiamata tail verrà applicata e una raccolta enumerabile di espressioni per i parametri.</summary>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nome dell'espressione lambda. Usato per la generazione di informazioni di debug.</param>
      <param name="tailCall">Oggetto <see cref="T:System.Boolean" /> che indica se l'ottimizzazione della chiamata tail verrà applicata durante la compilazione dell'espressione creata.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo di delegato.</typeparam>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un <see cref="T:System.Linq.Expressions.Expression`1" /> in cui il tipo delegato è noto in fase di compilazione, con il nome dell'espressione lambda e una raccolta enumerabile di espressioni per i parametri.</summary>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nome dell'espressione lambda. Usato per la generazione di informazioni di debug.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo di delegato.</typeparam>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di spostamento a sinistra bit per bit.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di spostamento a sinistra non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di spostamento a sinistra bit per bit.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oppure non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è <see langword="null" /> e l'operatore di spostamento a sinistra non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di spostamento a sinistra bit per bit.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di spostamento a sinistra bit per bit.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di spostamento a sinistra bit per bit.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "minore di".</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore "minore di" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "minore di".</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">
        <see langword="true" /> per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su <see langword="true" />; <see langword="false" /> per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su <see langword="false" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oppure non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è <see langword="null" /> e l'operatore "minore di" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "minore o uguale a".</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore "minore o uguale a" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "minore o uguale a".</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">
        <see langword="true" /> per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su <see langword="true" />; <see langword="false" /> per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su <see langword="false" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oppure non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è <see langword="null" /> e l'operatore "minore o uguale a" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> dove il membro è un campo o una proprietà.</summary>
      <param name="member">Oggetto <see cref="T:System.Reflection.MemberInfo" /> che rappresenta un campo o una proprietà su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="initializers">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> è <see langword="null" />.  
In alternativa 
Uno o più elementi di <paramref name="initializers" /> sono <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> non rappresenta un campo o una proprietà.  
-oppure- 
<see cref="P:System.Reflection.FieldInfo.FieldType" /> o <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> del campo o della proprietà che <paramref name="member" /> rappresenta non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> dove il membro è un campo o una proprietà.</summary>
      <param name="member">Oggetto <see cref="T:System.Reflection.MemberInfo" /> che rappresenta un campo o una proprietà su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="initializers">Matrice di oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> è <see langword="null" />.  
-oppure- 
Uno o più elementi di <paramref name="initializers" /> sono <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> non rappresenta un campo o una proprietà.  
-oppure- 
<see cref="P:System.Reflection.FieldInfo.FieldType" /> o <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> del campo o della proprietà che <paramref name="member" /> rappresenta non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> basato su un metodo della funzione di accesso alle proprietà specificato.</summary>
      <param name="propertyAccessor">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo della funzione di accesso della proprietà.</param>
      <param name="initializers">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> è impostata sull'oggetto <see cref="T:System.Reflection.MemberInfo" /> che rappresenta la proprietà a cui si accede in <paramref name="propertyAccessor" /> e il cui oggetto <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> è popolato con gli elementi di <paramref name="initializers" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> è <see langword="null" />.  
In alternativa 
Uno o più elementi di <paramref name="initializers" /> sono <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> non rappresenta un metodo della funzione di accesso della proprietà.  
In alternativa 
<see cref="P:System.Reflection.PropertyInfo.PropertyType" /> della proprietà a cui accede il metodo rappresentato da <paramref name="propertyAccessor" /> non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> basato su un metodo della funzione di accesso alle proprietà specificato.</summary>
      <param name="propertyAccessor">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo della funzione di accesso della proprietà.</param>
      <param name="initializers">Matrice di oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> è impostata sull'oggetto <see cref="T:System.Reflection.MemberInfo" /> che rappresenta la proprietà a cui si accede in <paramref name="propertyAccessor" /> e il cui oggetto <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> è popolato con gli elementi di <paramref name="initializers" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> è <see langword="null" />.  
-oppure- 
Uno o più elementi di <paramref name="initializers" /> sono <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> non rappresenta un metodo della funzione di accesso della proprietà.  
In alternativa 
<see cref="P:System.Reflection.PropertyInfo.PropertyType" /> della proprietà a cui accede il metodo rappresentato da <paramref name="propertyAccessor" /> non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> che usa gli oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> specificati per inizializzare una raccolta.</summary>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e le cui proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> è <see langword="null" />.  
In alternativa 
Uno o più elementi di <paramref name="initializers" /> sono <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> che usa un metodo denominato "Add" per aggiungere elementi a una raccolta.</summary>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e la cui proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> è impostata sul valore specificato.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> è <see langword="null" />.  
-oppure- 
Uno o più elementi di <paramref name="initializers" /> sono <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">Non esiste alcun metodo di istanza denominato "Add" (senza distinzione tra maiuscole e minuscole) dichiarato in <paramref name="newExpression" />.Type o nel relativo tipo di base.  
In alternativa 
Il metodo Add in <paramref name="newExpression" />.Type o nel relativo tipo di base non accetta esattamente un solo argomento.  
In alternativa 
Il tipo rappresentato dalla proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> del primo elemento di <paramref name="initializers" /> non è assegnabile al tipo di argomento del metodo Add in <paramref name="newExpression" />.Type o nel relativo tipo di base.  
-oppure- 
In <paramref name="newExpression" />.Type e/o nel relativo tipo di base sono presenti più metodi denominati "Add" (senza distinzione tra maiuscole e minuscole) compatibili con un solo argomento.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> che usa gli oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> specificati per inizializzare una raccolta.</summary>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Matrice di oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e le cui proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> è <see langword="null" />.  
-oppure- 
Uno o più elementi di <paramref name="initializers" /> sono <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> che usa un metodo denominato "Add" per aggiungere elementi a una raccolta.</summary>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e la cui proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> è impostata sul valore specificato.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> è <see langword="null" />.  
-oppure- 
Uno o più elementi di <paramref name="initializers" /> sono <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">Non esiste alcun metodo di istanza denominato "Add" (senza distinzione tra maiuscole e minuscole) dichiarato in <paramref name="newExpression" />.Type o nel relativo tipo di base.  
-oppure- 
Il metodo Add in <paramref name="newExpression" />.Type o nel relativo tipo di base non accetta esattamente un solo argomento.  
-oppure- 
Il tipo rappresentato dalla proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> del primo elemento di <paramref name="initializers" /> non è assegnabile al tipo di argomento del metodo Add in <paramref name="newExpression" />.Type o nel relativo tipo di base.  
In alternativa 
In <paramref name="newExpression" />.Type e/o nel relativo tipo di base sono presenti più metodi denominati "Add" (senza distinzione tra maiuscole e minuscole) compatibili con un solo argomento.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> che usa un metodo specificato per aggiungere elementi a una raccolta.</summary>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="addMethod">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo di istanza denominato "Add" (senza distinzione tra maiuscole e minuscole) che aggiunge un elemento a una raccolta.</param>
      <param name="initializers">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e la cui proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> è impostata sul valore specificato.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> è <see langword="null" />.  
-oppure- 
Uno o più elementi di <paramref name="initializers" /> sono <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type non implementa <see cref="T:System.Collections.IEnumerable" />.  
In alternativa 
 <paramref name="addMethod" /> non è <see langword="null" /> e non rappresenta un metodo di istanza denominato "Add" (senza distinzione tra maiuscole e minuscole) che accetta esattamente un argomento.  
-oppure- 
 <paramref name="addMethod" /> non è <see langword="null" /> e il tipo rappresentato dalla proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di uno o più elementi di <paramref name="initializers" /> non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="addMethod" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> è <see langword="null" /> e non esiste alcun metodo di istanza denominato "Add" che accetta un argomento compatibile con il tipo su <paramref name="newExpression" />.Type o sul relativo tipo di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> che usa un metodo specificato per aggiungere elementi a una raccolta.</summary>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="addMethod">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo di istanza che accetta un argomento e aggiunge un elemento a una raccolta.</param>
      <param name="initializers">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e la cui proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> è impostata sul valore specificato.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> è <see langword="null" />.  
In alternativa 
Uno o più elementi di <paramref name="initializers" /> sono <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type non implementa <see cref="T:System.Collections.IEnumerable" />.  
In alternativa 
 <paramref name="addMethod" /> non è <see langword="null" /> e non rappresenta un metodo di istanza denominato "Add" (senza distinzione tra maiuscole e minuscole) che accetta esattamente un argomento.  
In alternativa 
 <paramref name="addMethod" /> non è <see langword="null" /> e il tipo rappresentato dalla proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di uno o più elementi di <paramref name="initializers" /> non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="addMethod" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> è <see langword="null" /> e non esiste alcun metodo di istanza denominato "Add" che accetta un argomento compatibile con il tipo su <paramref name="newExpression" />.Type o sul relativo tipo di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LoopExpression" /> con il corpo specificato.</summary>
      <param name="body">Corpo del ciclo.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LoopExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LoopExpression" /> con il corpo e la destinazione di interruzione specificati.</summary>
      <param name="body">Corpo del ciclo.</param>
      <param name="break">Destinazione di interruzione usata dal corpo del ciclo.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LoopExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LoopExpression" /> con il corpo specificato.</summary>
      <param name="body">Corpo del ciclo.</param>
      <param name="break">Destinazione di interruzione usata dal corpo del ciclo.</param>
      <param name="continue">Destinazione di continuazione usata dal corpo del ciclo.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LoopExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> tramite la chiamata al metodo factory appropriato, dati gli operandi sinistro e destro.</summary>
      <param name="binaryType">Oggetto <see cref="T:System.Linq.Expressions.ExpressionType" /> che specifica il tipo di operazione binaria.</param>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando sinistro.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando destro.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> risultante dalla chiamata al metodo factory appropriato.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> non corrisponde a un nodo di espressione binaria.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> tramite la chiamata al metodo factory appropriato, dati gli operandi sinistro e destro e il metodo di implementazione.</summary>
      <param name="binaryType">Oggetto <see cref="T:System.Linq.Expressions.ExpressionType" /> che specifica il tipo di operazione binaria.</param>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando sinistro.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando destro.</param>
      <param name="liftToNull">
        <see langword="true" /> per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su <see langword="true" />; <see langword="false" /> per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su <see langword="false" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che specifica il metodo di implementazione.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> risultante dalla chiamata al metodo factory appropriato.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> non corrisponde a un nodo di espressione binaria.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> tramite la chiamata al metodo factory appropriato, dati gli operandi sinistro e destro, il metodo di implementazione e la funzione di conversione di tipi.</summary>
      <param name="binaryType">Oggetto <see cref="T:System.Linq.Expressions.ExpressionType" /> che specifica il tipo di operazione binaria.</param>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando sinistro.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando destro.</param>
      <param name="liftToNull">
        <see langword="true" /> per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su <see langword="true" />; <see langword="false" /> per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su <see langword="false" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che specifica il metodo di implementazione.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> che rappresenta una funzione di conversione di tipi. Questo parametro viene usato solo se <paramref name="binaryType" /> è <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> o un'assegnazione composta.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> risultante dalla chiamata al metodo factory appropriato.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> non corrisponde a un nodo di espressione binaria.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresenta un'istruzione catch con gli elementi specificati.</summary>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> di <see cref="T:System.Exception" /> che verrà gestito da questo oggetto <see cref="T:System.Linq.Expressions.CatchBlock" />.</param>
      <param name="variable">Oggetto <see cref="T:System.Linq.Expressions.ParameterExpression" /> che rappresenta un riferimento all'oggetto <see cref="T:System.Exception" /> intercettato da questo gestore.</param>
      <param name="body">Corpo dell'istruzione catch.</param>
      <param name="filter">Corpo del filtro <see cref="T:System.Exception" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> che rappresenta un'operazione dinamica associata dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> specificato.</summary>
      <param name="delegateType">Tipo del delegato usato dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Binder di runtime per l'operazione dinamica.</param>
      <param name="arguments">Argomenti per l'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e le cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> che rappresenta un'operazione dinamica associata dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> specificato e da un argomento.</summary>
      <param name="delegateType">Tipo del delegato usato dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Binder di runtime per l'operazione dinamica.</param>
      <param name="arg0">Argomento per l'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e le cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> che rappresenta un'operazione dinamica associata dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> specificato e da due argomenti.</summary>
      <param name="delegateType">Tipo del delegato usato dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Binder di runtime per l'operazione dinamica.</param>
      <param name="arg0">Primo argomento per l'operazione dinamica.</param>
      <param name="arg1">Secondo argomento per l'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e le cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> che rappresenta un'operazione dinamica associata dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> specificato e da tre argomenti.</summary>
      <param name="delegateType">Tipo del delegato usato dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Binder di runtime per l'operazione dinamica.</param>
      <param name="arg0">Primo argomento per l'operazione dinamica.</param>
      <param name="arg1">Secondo argomento per l'operazione dinamica.</param>
      <param name="arg2">Terzo argomento per l'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e le cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> che rappresenta un'operazione dinamica associata dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> specificato e da quattro argomenti.</summary>
      <param name="delegateType">Tipo del delegato usato dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Binder di runtime per l'operazione dinamica.</param>
      <param name="arg0">Primo argomento per l'operazione dinamica.</param>
      <param name="arg1">Secondo argomento per l'operazione dinamica.</param>
      <param name="arg2">Terzo argomento per l'operazione dinamica.</param>
      <param name="arg3">Quarto argomento per l'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e le cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> che rappresenta un'operazione dinamica associata dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> specificato.</summary>
      <param name="delegateType">Tipo del delegato usato dall'oggetto <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Binder di runtime per l'operazione dinamica.</param>
      <param name="arguments">Argomenti per l'operazione dinamica.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DynamicExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e le cui proprietà <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un passaggio dell'oggetto <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> specificato. Anche il valore passato all'etichetta al momento del passaggio può essere specificato.</summary>
      <param name="kind">Oggetto <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> dell'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valore che al momento del passaggio verrà passato all'etichetta associata.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> impostata su <paramref name="kind" />, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" />, la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" /> e con <paramref name="value" /> da passare all'etichetta di destinazione al momento del passaggio.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> che rappresenta l'accesso a una proprietà indicizzata in un oggetto.</summary>
      <param name="instance">Oggetto a cui appartiene la proprietà. Deve essere Null se la proprietà è <see langword="static" /> (<see langword="shared" /> in Visual Basic).</param>
      <param name="indexer">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta la proprietà da indicizzare.</param>
      <param name="arguments">
        <c>IEnumerable&lt;Expression&gt;</c> (<c>IEnumerable (Of Expression)</c> in Visual Basic) contenente gli argomenti che verranno usati per indicizzare la proprietà.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a un campo o a una proprietà.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'oggetto a cui appartiene il membro. Può essere Null per i membri statici.</param>
      <param name="member">Oggetto <see cref="T:System.Reflection.MemberInfo" /> che descrive il campo o la proprietà a cui accedere.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> risultante dalla chiamata al metodo factory appropriato.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> non rappresenta un campo o una proprietà.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> che rappresenta un blocco try con gli elementi specificati.</summary>
      <param name="type">Tipo di risultato dell'espressione try. Se Null, il corpo e tutti i gestori devono avere lo stesso identico tipo.</param>
      <param name="body">Corpo del blocco try.</param>
      <param name="finally">Corpo del blocco finally. Passare Null se al blocco try non è associato alcun blocco finally.</param>
      <param name="fault">Corpo del blocco fault. Passare Null se al blocco try non è associato alcun blocco fault.</param>
      <param name="handlers">Raccolta di espressioni <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresentano le istruzioni catch da associare al blocco try.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> tramite la chiamata al metodo factory appropriato, dato un operando.</summary>
      <param name="unaryType">Oggetto <see cref="T:System.Linq.Expressions.ExpressionType" /> che specifica il tipo di operazione unaria.</param>
      <param name="operand">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> che specifica il tipo in cui convertire (passare <see langword="null" /> se non applicabile).</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> risultante dalla chiamata al metodo factory appropriato.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> non corrisponde a un nodo di espressione unaria.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> tramite la chiamata al metodo factory appropriato, dato un operando e il metodo di implementazione.</summary>
      <param name="unaryType">Oggetto <see cref="T:System.Linq.Expressions.ExpressionType" /> che specifica il tipo di operazione unaria.</param>
      <param name="operand">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> che specifica il tipo in cui convertire (passare <see langword="null" /> se non applicabile).</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> risultante dalla chiamata al metodo factory appropriato.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> non corrisponde a un nodo di espressione unaria.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> che rappresenta l'inizializzazione ricorsiva di membri di un campo o una proprietà.</summary>
      <param name="member">Oggetto <see cref="T:System.Reflection.MemberInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="bindings">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> o <paramref name="bindings" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> non rappresenta un campo o una proprietà.  
-oppure- 
La proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> di un elemento di <paramref name="bindings" /> non rappresenta un membro del tipo del campo o della proprietà che <paramref name="member" /> rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> che rappresenta l'inizializzazione ricorsiva di membri di un campo o una proprietà.</summary>
      <param name="member">Oggetto <see cref="T:System.Reflection.MemberInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="bindings">Matrice di oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> o <paramref name="bindings" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> non rappresenta un campo o una proprietà.  
-oppure- 
La proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> di un elemento di <paramref name="bindings" /> non rappresenta un membro del tipo del campo o della proprietà che <paramref name="member" /> rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> che rappresenta l'inizializzazione ricorsiva di membri di un membro a cui si accede usando un metodo della funzione di accesso della proprietà.</summary>
      <param name="propertyAccessor">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo della funzione di accesso della proprietà.</param>
      <param name="bindings">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> è impostata sull'oggetto <see cref="T:System.Reflection.PropertyInfo" /> che rappresenta la proprietà a cui si accede in <paramref name="propertyAccessor" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> o <paramref name="bindings" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> non rappresenta un metodo della funzione di accesso della proprietà.  
-oppure- 
La proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> di un elemento di <paramref name="bindings" /> non rappresenta un membro del tipo della proprietà a cui si accede con il metodo che <paramref name="propertyAccessor" /> rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> che rappresenta l'inizializzazione ricorsiva di membri di un membro a cui si accede usando un metodo della funzione di accesso della proprietà.</summary>
      <param name="propertyAccessor">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo della funzione di accesso della proprietà.</param>
      <param name="bindings">Matrice di oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> è impostata sull'oggetto <see cref="T:System.Reflection.PropertyInfo" /> che rappresenta la proprietà a cui si accede in <paramref name="propertyAccessor" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> o <paramref name="bindings" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> non rappresenta un metodo della funzione di accesso della proprietà.  
-oppure- 
La proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> di un elemento di <paramref name="bindings" /> non rappresenta un membro del tipo della proprietà a cui si accede con il metodo che <paramref name="propertyAccessor" /> rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Rappresenta un'espressione che crea un nuovo oggetto e inizializza una proprietà dell'oggetto.</summary>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />.</param>
      <param name="bindings">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="bindings" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> di un elemento di <paramref name="bindings" /> non rappresenta un membro del tipo che <paramref name="newExpression" />.Type rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />.</param>
      <param name="bindings">Matrice di oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="bindings" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> di un elemento di <paramref name="bindings" /> non rappresenta un membro del tipo che <paramref name="newExpression" />.Type rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di resto aritmetico.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore modulo non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di resto aritmetico.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oppure non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è <see langword="null" /> e l'operatore modulo non è definito per i tipi <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di resto.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di resto.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di resto.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di moltiplicazione aritmetica che non ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di moltiplicazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di moltiplicazione aritmetica che non ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oppure non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è <see langword="null" /> e l'operatore di moltiplicazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di moltiplicazione che non ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di moltiplicazione che non ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di moltiplicazione che non ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di moltiplicazione che ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di moltiplicazione che ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di moltiplicazione che ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di moltiplicazione aritmetica che ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di moltiplicazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di moltiplicazione aritmetica che ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oppure non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è <see langword="null" /> e l'operatore di moltiplicazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di negazione aritmetica.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> e la cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> è impostata sul valore specificato.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore meno unario non è definito per <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di negazione aritmetica.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) o non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è <see langword="null" /> e l'operatore meno unario non è definito per <paramref name="expression" />.Type.  
In alternativa 
 <paramref name="expression" />.Type , o il tipo non nullable corrispondente se si tratta di un tipo nullable, non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di negazione aritmetica che ha il controllo dell'overflow.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> e la cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> è impostata sul valore specificato.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore meno unario non è definito per <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di negazione aritmetica che ha il controllo dell'overflow. Il metodo di implementazione può essere specificato.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) o non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è <see langword="null" /> e l'operatore meno unario non è definito per <paramref name="expression" />.Type.  
In alternativa 
 <paramref name="expression" />.Type , o il tipo non nullable corrispondente se si tratta di un tipo nullable, non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore specificato che non accetta argomenti.</summary>
      <param name="constructor">Oggetto <see cref="T:System.Reflection.ConstructorInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e la cui proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> è impostata sul valore specificato.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Il costruttore che <paramref name="constructor" /> rappresenta ha almeno un parametro.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore specificato con gli argomenti specificati.</summary>
      <param name="constructor">Oggetto <see cref="T:System.Reflection.ConstructorInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e le cui proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> e <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> è <see langword="null" />.  
-oppure- 
Un elemento di <paramref name="arguments" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Il numero di elementi in <paramref name="arguments" /> è diverso dal numero di parametri per il costruttore rappresentato da <paramref name="constructor" />.  
In alternativa 
La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="arguments" /> non può essere assegnata al tipo del parametro corrispondente del costruttore rappresentato da <paramref name="constructor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore specificato con gli argomenti specificati. I membri che accedono ai campi inizializzati del costruttore sono specificati.</summary>
      <param name="constructor">Oggetto <see cref="T:System.Reflection.ConstructorInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Reflection.MemberInfo" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e le cui proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> e <see cref="P:System.Linq.Expressions.NewExpression.Members" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> è <see langword="null" />.  
-oppure- 
Un elemento di <paramref name="arguments" /> è <see langword="null" />.  
-oppure- 
Un elemento di <paramref name="members" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Il numero di elementi in <paramref name="arguments" /> è diverso dal numero di parametri per il costruttore rappresentato da <paramref name="constructor" />.  
-oppure- 
La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="arguments" /> non può essere assegnata al tipo del parametro corrispondente del costruttore rappresentato da <paramref name="constructor" />.  
-oppure- 
Il numero di elementi nel parametro <paramref name="members" /> è diverso da quello in <paramref name="arguments" />.  
-oppure- 
La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="arguments" /> rappresenta un tipo non assegnabile al tipo del membro rappresentato dall'elemento corrispondente di <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore specificato con gli argomenti specificati. I membri che accedono ai campi inizializzati del costruttore sono specificati come matrice.</summary>
      <param name="constructor">Oggetto <see cref="T:System.Reflection.ConstructorInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">Matrice di oggetti <see cref="T:System.Reflection.MemberInfo" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e le cui proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> e <see cref="P:System.Linq.Expressions.NewExpression.Members" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> è <see langword="null" />.  
-oppure- 
Un elemento di <paramref name="arguments" /> è <see langword="null" />.  
-oppure- 
Un elemento di <paramref name="members" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Il numero di elementi in <paramref name="arguments" /> è diverso dal numero di parametri per il costruttore rappresentato da <paramref name="constructor" />.  
-oppure- 
La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="arguments" /> non può essere assegnata al tipo del parametro corrispondente del costruttore rappresentato da <paramref name="constructor" />.  
In alternativa 
Il numero di elementi nel parametro <paramref name="members" /> è diverso da quello in <paramref name="arguments" />.  
-oppure- 
La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="arguments" /> rappresenta un tipo non assegnabile al tipo del membro rappresentato dall'elemento corrispondente di <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore specificato con gli argomenti specificati.</summary>
      <param name="constructor">Oggetto <see cref="T:System.Reflection.ConstructorInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e le cui proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> e <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> è <see langword="null" />.  
-oppure- 
Un elemento di <paramref name="arguments" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La lunghezza di <paramref name="arguments" /> corrisponde al numero di parametri per il costruttore rappresentato da <paramref name="constructor" />.  
-oppure- 
La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="arguments" /> non può essere assegnata al tipo del parametro corrispondente del costruttore rappresentato da <paramref name="constructor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore senza parametri del tipo specificato.</summary>
      <param name="type">Oggetto <see cref="T:System.Type" /> con un costruttore che non accetta argomenti.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e la cui proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> è impostata su <see cref="T:System.Reflection.ConstructorInfo" />, che rappresenta il costruttore senza parametri per il tipo specificato.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Il tipo rappresentato da <paramref name="type" /> non dispone di un costruttore senza parametri.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> che rappresenta la creazione di una matrice con una classificazione specificata.</summary>
      <param name="type">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di elemento della matrice.</param>
      <param name="bounds">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> e la cui proprietà <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> è impostata sul valore specificato.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="bounds" /> è <see langword="null" />.  
-oppure- 
Un elemento di <paramref name="bounds" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="bounds" /> non rappresenta un tipo integrale.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> che rappresenta la creazione di una matrice con una classificazione specificata.</summary>
      <param name="type">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di elemento della matrice.</param>
      <param name="bounds">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> e la cui proprietà <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> è impostata sul valore specificato.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="bounds" /> è <see langword="null" />.  
-oppure- 
Un elemento di <paramref name="bounds" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="bounds" /> non rappresenta un tipo integrale.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> che rappresenta la creazione di una matrice unidimensionale e la relativa inizializzazione da un elenco di elementi.</summary>
      <param name="type">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di elemento della matrice.</param>
      <param name="initializers">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> e la cui proprietà <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> è impostata sul valore specificato.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="initializers" /> è <see langword="null" />.  
-oppure- 
Un elemento di <paramref name="initializers" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="initializers" /> rappresenta un tipo non assegnabile al tipo rappresentato da <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> che rappresenta la creazione di una matrice unidimensionale e la relativa inizializzazione da un elenco di elementi.</summary>
      <param name="type">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di elemento della matrice.</param>
      <param name="initializers">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> e la cui proprietà <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> è impostata sul valore specificato.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="initializers" /> è <see langword="null" />.  
-oppure- 
Un elemento di <paramref name="initializers" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="initializers" /> rappresenta un tipo non assegnabile al tipo <paramref name="type" />.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.NodeType">
      <summary>Ottiene il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Uno dei valori di <see cref="T:System.Linq.Expressions.ExpressionType" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di complemento bit per bit.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> e la cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> è impostata sul valore specificato.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore Not unario non è definito per <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di complemento bit per bit. Il metodo di implementazione può essere specificato.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) o non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è <see langword="null" /> e l'operatore Not unario non è definito per <paramref name="expression" />.Type.  
-oppure- 
 <paramref name="expression" />.Type , o il tipo non nullable corrispondente se si tratta di un tipo nullable, non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto di disuguaglianza.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di disuguaglianza non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto di disuguaglianza.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">
        <see langword="true" /> per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su <see langword="true" />; <see langword="false" /> per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su <see langword="false" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oppure non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è <see langword="null" /> e l'operatore di disuguaglianza non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)">
      <summary>Restituisce l'espressione che rappresenta il complemento a uno.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Restituisce l'espressione che rappresenta il complemento a uno.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione <see langword="OR" /> bit per bit.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore <see langword="OR" /> bit per bit non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione <see langword="OR" /> bit per bit.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oppure non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è <see langword="null" /> e l'operatore bit per bit <see langword="OR" /> non è definito per i tipi <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione OR bit per bit.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione OR bit per bit.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione OR bit per bit.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione <see langword="OR" /> condizionale che valuta il secondo operando solo se il primo operando restituisce <see langword="false" />.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore <see langword="OR" /> bit per bit non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.  
-oppure- 
 <paramref name="left" />.Type e <paramref name="right" />.Type non sono dello stesso tipo Boolean.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione <see langword="OR" /> condizionale che valuta il secondo operando solo se il primo operando restituisce <see langword="false" />.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oppure non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è <see langword="null" /> e l'operatore bit per bit <see langword="OR" /> non è definito per i tipi <paramref name="left" />.Type e <paramref name="right" />.Type.  
-oppure- 
 <paramref name="method" /> è <see langword="null" /> e <paramref name="left" />.Type e <paramref name="right" />.Type non sono dello stesso tipo Boolean.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> che può essere usato per identificare un parametro o una variabile in un albero delle espressioni.</summary>
      <param name="type">Tipo di parametro o di variabile.</param>
      <returns>Nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con il nome e il tipo specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> che può essere usato per identificare un parametro o una variabile in un albero delle espressioni.</summary>
      <param name="type">Tipo di parametro o di variabile.</param>
      <param name="name">Nome del parametro o della variabile, usato solo a scopo di debug o di stampa.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ParameterExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> e le cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'assegnazione dell'espressione seguita da un successivo decremento di 1 dell'espressione originale.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'assegnazione dell'espressione seguita da un successivo decremento di 1 dell'espressione originale.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'assegnazione dell'espressione seguita da un successivo incremento di 1 dell'espressione originale.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'assegnazione dell'espressione seguita da un successivo incremento di 1 dell'espressione originale.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta l'elevamento di un numero a una potenza.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di elevamento a potenza non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.  
-oppure- 
 <paramref name="left" />.Type e/o <paramref name="right" />.Type non sono <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta l'elevamento di un numero a una potenza.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oppure non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è <see langword="null" /> e l'operatore di elevamento a potenza non è definito per i tipi <paramref name="left" />.Type e <paramref name="right" />.Type.  
In alternativa 
 <paramref name="method" /> è <see langword="null" /> e <paramref name="left" />.Type e/o <paramref name="right" />.Type non sono <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta l'elevamento di un'espressione a una potenza e l'assegnazione del risultato all'espressione.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta l'elevamento di un'espressione a una potenza e l'assegnazione del risultato all'espressione.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta l'elevamento di un'espressione a una potenza e l'assegnazione del risultato all'espressione.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che decrementa l'espressione di 1 e assegna di nuovo il risultato all'espressione.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che decrementa l'espressione di 1 e assegna di nuovo il risultato all'espressione.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che incrementa l'espressione di 1 e assegna di nuovo il risultato all'espressione.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che incrementa l'espressione di 1 e assegna di nuovo il risultato all'espressione.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a una proprietà tramite un metodo della funzione di accesso alle proprietà.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />. Può essere Null per le proprietà statiche.</param>
      <param name="propertyAccessor">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo della funzione di accesso della proprietà.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> è impostata su <paramref name="expression" /> e la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> è impostata su <see cref="T:System.Reflection.PropertyInfo" />, che rappresenta la proprietà a cui si accede in <paramref name="propertyAccessor" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> è <see langword="null" />.  
-oppure- 
Il metodo rappresentato da <paramref name="propertyAccessor" /> non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) e <paramref name="expression" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type non è assegnabile al tipo dichiarante del metodo rappresentato da <paramref name="propertyAccessor" />.  
-oppure- 
Il metodo rappresentato da <paramref name="propertyAccessor" /> non è un metodo della funzione di accesso alle proprietà.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a una proprietà.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />. Può essere Null per le proprietà statiche.</param>
      <param name="property">Oggetto <see cref="T:System.Reflection.PropertyInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Member" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> e <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="property" /> è <see langword="null" />.  
In alternativa 
La proprietà rappresentata da <paramref name="property" /> non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) e <paramref name="expression" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type non è assegnabile al tipo dichiarante della proprietà che <paramref name="property" /> rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> che rappresenta l'accesso a una proprietà indicizzata.</summary>
      <param name="instance">Oggetto a cui appartiene la proprietà. Se la proprietà è statica/condivisa, deve essere Null.</param>
      <param name="indexer">Oggetto <see cref="T:System.Reflection.PropertyInfo" /> che rappresenta la proprietà da indicizzare.</param>
      <param name="arguments">Raccolta <see cref="T:System.Collections.Generic.IEnumerable`1" /> di oggetti <see cref="T:System.Linq.Expressions.Expression" /> usati per indicizzare la proprietà.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> che rappresenta l'accesso a una proprietà indicizzata.</summary>
      <param name="instance">Oggetto a cui appartiene la proprietà. Se la proprietà è statica/condivisa, deve essere Null.</param>
      <param name="indexer">Oggetto <see cref="T:System.Reflection.PropertyInfo" /> che rappresenta la proprietà da indicizzare.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> usati per indicizzare la proprietà.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a una proprietà.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene una proprietà denominata <paramref name="propertyName" />. Può essere <see langword="null" /> per le proprietà statiche.</param>
      <param name="propertyName">Nome di una proprietà a cui accedere.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> è impostata su <paramref name="expression" /> e la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> è impostata su <see cref="T:System.Reflection.PropertyInfo" />, che rappresenta la proprietà identificata da <paramref name="propertyName" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="propertyName" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Nessuna proprietà denominata <paramref name="propertyName" /> è definita in <paramref name="expression" />.Type o nei relativi tipi di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> che rappresenta l'accesso a una proprietà indicizzata.</summary>
      <param name="instance">Oggetto a cui appartiene la proprietà. Se la proprietà è statica/condivisa, deve essere Null.</param>
      <param name="propertyName">Nome dell'indicizzatore.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> usati per indicizzare la proprietà.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che accede a una proprietà.</summary>
      <param name="expression">Oggetto contenitore della proprietà. Può essere Null per le proprietà statiche.</param>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che contiene la proprietà.</param>
      <param name="propertyName">Proprietà a cui accedere.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a una proprietà o un campo.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene una proprietà o un campo denominato <paramref name="propertyOrFieldName" />. Può essere Null per i membri statici.</param>
      <param name="propertyOrFieldName">Nome di una proprietà o di un campo a cui accedere.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> è impostata su <paramref name="expression" /> e la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> è impostata su <see cref="T:System.Reflection.PropertyInfo" /> o su <see cref="T:System.Reflection.FieldInfo" />, che rappresenta la proprietà o il campo identificato da <paramref name="propertyOrFieldName" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="propertyOrFieldName" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Nessuna proprietà o campo denominato <paramref name="propertyOrFieldName" /> è definito in <paramref name="expression" />.Type o nei relativi tipi di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'espressione che ha un valore costante di tipo <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> e la cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> è impostata sul valore specificato.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Reduce">
      <summary>Riduce questo nodo a un'espressione più semplice. Se CanReduce restituisce true, deve essere restituita un'espressione valida. Questo metodo può restituire un altro nodo che deve essere a sua volta ridotto.</summary>
      <returns>Espressione ridotta.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceAndCheck">
      <summary>Riduce questo nodo a un'espressione più semplice. Se CanReduce restituisce true, deve essere restituita un'espressione valida. Questo metodo può restituire un altro nodo che deve essere a sua volta ridotto.</summary>
      <returns>Espressione ridotta.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceExtensions">
      <summary>Riduce l'espressione a un tipo di nodo noto (diverso da un nodo di estensione) o restituisce solo l'espressione se è già un tipo noto.</summary>
      <returns>Espressione ridotta.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto di uguaglianze di riferimento.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto di disuguaglianze di riferimento.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta la rigenerazione di un'eccezione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta la rigenerazione di un'eccezione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow(System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta la rigenerazione di un'eccezione con un tipo specificato.</summary>
      <param name="type">Nuovo oggetto <see cref="T:System.Type" /> dell'espressione.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta la rigenerazione di un'eccezione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione return.</summary>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Return, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" /> e un valore Null da passare all'etichetta di destinazione al momento del passaggio.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione return. Il valore passato all'etichetta al momento del passaggio può essere specificato.</summary>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valore che al momento del passaggio verrà passato all'etichetta associata.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Continue, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" /> e <paramref name="value" /> da passare all'etichetta di destinazione al momento del passaggio.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione return con il tipo specificato. Il valore passato all'etichetta al momento del passaggio può essere specificato.</summary>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valore che al momento del passaggio verrà passato all'etichetta associata.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Continue, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" />, la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" /> e <paramref name="value" /> da passare all'etichetta di destinazione al momento del passaggio.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione return con il tipo specificato.</summary>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Return, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" />, la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" /> e un valore Null da passare all'etichetta al momento del passaggio.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di spostamento a destra bit per bit.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di spostamento a destra non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di spostamento a destra bit per bit.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oppure non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è <see langword="null" /> e l'operatore di spostamento a destra non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di spostamento a destra bit per bit.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di spostamento a destra bit per bit.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di spostamento a destra bit per bit.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un'istanza di <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <param name="variables">Raccolta di oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> e la cui proprietà <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> è impostata sul valore specificato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un'istanza di <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <param name="variables">Matrice di oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> e la cui proprietà <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> è impostata sul valore specificato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di sottrazione aritmetica che non ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di sottrazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di sottrazione aritmetica che non ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oppure non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è <see langword="null" /> e l'operatore di sottrazione non è definito per i tipi <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di sottrazione che non ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di sottrazione che non ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di sottrazione che non ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di sottrazione che ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di sottrazione che ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di sottrazione che ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di sottrazione aritmetica che ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di sottrazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di sottrazione aritmetica che ha il controllo dell'overflow.</summary>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oppure non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è <see langword="null" /> e l'operatore di sottrazione non è definito per i tipi <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea <see cref="T:System.Linq.Expressions.SwitchExpression" /> che rappresenta un'istruzione <see langword="switch" /> con un caso predefinito.</summary>
      <param name="switchValue">Valore da testare a fronte di ogni case.</param>
      <param name="defaultBody">Risultato dell'opzione se <paramref name="switchValue" /> non corrisponde ad alcun caso.</param>
      <param name="cases">Set di case per questa espressione switch.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crea <see cref="T:System.Linq.Expressions.SwitchExpression" /> che rappresenta un'istruzione <see langword="switch" /> con un caso predefinito.</summary>
      <param name="switchValue">Valore da testare a fronte di ogni case.</param>
      <param name="defaultBody">Risultato dell'opzione se <paramref name="switchValue" /> non corrisponde ad alcun caso.</param>
      <param name="comparison">Metodo di confronto di uguaglianze da usare.</param>
      <param name="cases">Set di case per questa espressione switch.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea <see cref="T:System.Linq.Expressions.SwitchExpression" /> che rappresenta un'istruzione <see langword="switch" /> con un caso predefinito.</summary>
      <param name="switchValue">Valore da testare a fronte di ogni case.</param>
      <param name="defaultBody">Risultato dell'opzione se <paramref name="switchValue" /> non corrisponde ad alcun caso.</param>
      <param name="comparison">Metodo di confronto di uguaglianze da usare.</param>
      <param name="cases">Set di case per questa espressione switch.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea un oggetto a <see cref="T:System.Linq.Expressions.SwitchExpression" /> che rappresenta un'istruzione<see langword="switch" /> senza un case predefinito.</summary>
      <param name="switchValue">Valore da testare a fronte di ogni case.</param>
      <param name="cases">Set di case per questa espressione switch.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crea <see cref="T:System.Linq.Expressions.SwitchExpression" /> che rappresenta un'istruzione <see langword="switch" /> con un caso predefinito.</summary>
      <param name="type">Tipo di risultato dell'opzione.</param>
      <param name="switchValue">Valore da testare a fronte di ogni case.</param>
      <param name="defaultBody">Risultato dell'opzione se <paramref name="switchValue" /> non corrisponde ad alcun caso.</param>
      <param name="comparison">Metodo di confronto di uguaglianze da usare.</param>
      <param name="cases">Set di case per questa espressione switch.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea <see cref="T:System.Linq.Expressions.SwitchExpression" /> che rappresenta un'istruzione <see langword="switch" /> con un caso predefinito.</summary>
      <param name="type">Tipo di risultato dell'opzione.</param>
      <param name="switchValue">Valore da testare a fronte di ogni case.</param>
      <param name="defaultBody">Risultato dell'opzione se <paramref name="switchValue" /> non corrisponde ad alcun caso.</param>
      <param name="comparison">Metodo di confronto di uguaglianze da usare.</param>
      <param name="cases">Set di case per questa espressione switch.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.SwitchCase" /> da usare in un oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <param name="body">Corpo del case.</param>
      <param name="testValues">Valori di test del case.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchCase" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.SwitchCase" /> da usare in un oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <param name="body">Corpo del case.</param>
      <param name="testValues">Valori di test del case.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchCase" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)">
      <summary>Crea un'istanza di <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName">Oggetto <see cref="T:System.String" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> la cui proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> è impostata sul valore specificato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)">
      <summary>Crea un'istanza di <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName">Oggetto <see cref="T:System.String" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">Oggetto <see cref="T:System.Guid" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> con le proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> impostate sul valore specificato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)">
      <summary>Crea un'istanza di <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName">Oggetto <see cref="T:System.String" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">Oggetto <see cref="T:System.Guid" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <param name="languageVendor">Oggetto <see cref="T:System.Guid" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> le cui proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> sono impostate sul valore specificato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)">
      <summary>Crea un'istanza di <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName">Oggetto <see cref="T:System.String" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">Oggetto <see cref="T:System.Guid" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <param name="languageVendor">Oggetto <see cref="T:System.Guid" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</param>
      <param name="documentType">Oggetto <see cref="T:System.Guid" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> con le proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> impostate sul valore specificato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta la generazione di un'eccezione.</summary>
      <param name="value">Oggetto <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'eccezione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta la generazione di un'eccezione con un tipo specificato.</summary>
      <param name="value">Oggetto <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">Nuovo oggetto <see cref="T:System.Type" /> dell'espressione.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'eccezione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ToString">
      <summary>Restituisce una rappresentazione testuale di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Rappresentazione testuale di <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> che rappresenta un blocco try con qualsiasi numero di istruzioni catch e nessun blocco fault o finally.</summary>
      <param name="body">Corpo del blocco try.</param>
      <param name="handlers">Matrice di zero o più espressioni <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresentano le istruzioni catch da associare al blocco try.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> che rappresenta un blocco try con qualsiasi numero di istruzioni catch e un blocco finally.</summary>
      <param name="body">Corpo del blocco try.</param>
      <param name="finally">Corpo del blocco finally.</param>
      <param name="handlers">Matrice di zero o più espressioni <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresentano le istruzioni catch da associare al blocco try.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto a <see cref="T:System.Linq.Expressions.TryExpression" /> che rappresenta un blocco try con un blocco fault e nessuna istruzione catch.</summary>
      <param name="body">Corpo del blocco try.</param>
      <param name="fault">Corpo del blocco fault.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> che rappresenta un blocco try con un blocco finally e nessuna istruzione catch.</summary>
      <param name="body">Corpo del blocco try.</param>
      <param name="finally">Corpo del blocco finally.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> creato.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)">
      <summary>Crea un oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che rappresenta un tipo delegato System.Action generico con argomenti di tipo specifici.</summary>
      <param name="typeArgs">Matrice di oggetti Type che specificano gli argomenti tipo per il tipo delegato System.Action.</param>
      <param name="actionType">Quando questo metodo viene restituito, contiene il tipo delegato System.Action generico che dispone di argomenti di tipo specifici. Contiene Null se nessun delegato System.Action generico corrisponde all'oggetto <paramref name="typeArgs" />. Questo parametro viene passato non inizializzato.</param>
      <returns>
        <see langword="true" /> se il tipo delegato System.Action generico è stato creato per <paramref name="typeArgs" /> specifico. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)">
      <summary>Crea un oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che rappresenta un tipo delegato System.Func generico con argomenti di tipo specifici. L'ultimo argomento di tipo specifica il tipo restituito del delegato creato.</summary>
      <param name="typeArgs">Matrice di oggetti Type che specificano gli argomenti di tipo per il tipo delegato System.Func.</param>
      <param name="funcType">Quando questo metodo viene restituito, contiene il tipo delegato System.Func generico con argomenti di tipo specifici. Contiene Null se nessun delegato System.Func generico corrisponde all'oggetto <paramref name="typeArgs" />. Questo parametro viene passato non inizializzato.</param>
      <returns>
        <see langword="true" /> se il tipo delegato System.Func generico è stato creato per <paramref name="typeArgs" /> specifico. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.Expression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un riferimento esplicito o una conversione boxing in cui viene fornito <see langword="null" /> se la conversione non riesce.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> che confronta l'identità del tipo in fase di esecuzione.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> per il quale la proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> e per il quale le proprietà <see cref="T:System.Linq.Expressions.Expression" /> e <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> sono impostate sui valori specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />.</param>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> per il quale la proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> e per il quale le proprietà <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> e <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione con il più unario.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> e la cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> è impostata sul valore specificato.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore più unario non è definito per <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione con il più unario.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è <see langword="null" /> e il metodo che rappresenta restituisce <see langword="void" />, non è <see langword="static" /> (<see langword="Shared" /> in Visual Basic) o non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è <see langword="null" /> e l'operatore più unario non è definito per <paramref name="expression" />.Type.  
-oppure- 
 <paramref name="expression" />.Type , o il tipo non nullable corrispondente se si tratta di un tipo nullable, non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta una conversione unboxing esplicita.</summary>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> di cui eseguire la conversione unboxing.</param>
      <param name="type">Nuovo oggetto <see cref="T:System.Type" /> dell'espressione.</param>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> che può essere usato per identificare un parametro o una variabile in un albero delle espressioni.</summary>
      <param name="type">Tipo di parametro o di variabile.</param>
      <returns>Nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con il nome e il tipo specificati</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> che può essere usato per identificare un parametro o una variabile in un albero delle espressioni.</summary>
      <param name="type">Tipo di parametro o di variabile.</param>
      <param name="name">Nome del parametro o della variabile. Questo nome viene usato solo a scopo di debug o di stampa.</param>
      <returns>Nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con il nome e il tipo specificati.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Riduce il nodo, quindi chiama il delegato del visitatore sull'espressione ridotta. Se il nodo non è riducibile, il metodo genera un'eccezione.</summary>
      <param name="visitor">Istanza di <see cref="T:System.Func`2" />.</param>
      <returns>Espressione visitata o espressione che deve sostituirla nell'albero.</returns>
    </member>
    <member name="T:System.Linq.Expressions.Expression`1">
      <summary>Rappresenta un'espressione lambda fortemente tipizzata come struttura dei dati sotto forma di una struttura ad albero dell'espressione. Questa classe non può essere ereditata.</summary>
      <typeparam name="TDelegate">Tipo del delegato rappresentato dall'oggetto <see cref="T:System.Linq.Expressions.Expression`1" />.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile">
      <summary>Compila l'espressione lambda descritta dalla struttura ad albero dell'espressione in codice eseguibile e produce un delegato che rappresenta l'espressione lambda.</summary>
      <returns>Delegato di tipo <paramref name="TDelegate" /> che rappresenta l'espressione lambda compilata descritta dall'oggetto <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile(System.Boolean)">
      <summary>Compila l'espressione lambda descritta dall'albero delle espressioni nel codice interpretato o compilato e produce un delegato che rappresenta l'espressione lambda.</summary>
      <param name="preferInterpretation">
        <see langword="true" /> per indicare che l'espressione deve essere compilata in un formato interpretato, se disponibile; in caso contrario, <see langword="false" />.</param>
      <returns>Un delegato che rappresenta l'espressione lambda compilata descritta da <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile(System.Runtime.CompilerServices.DebugInfoGenerator)">
      <summary>Produce un delegato che rappresenta l'espressione lambda.</summary>
      <param name="debugInfoGenerator">Generatore delle informazioni di debug utilizzato dal compilatore per contrassegnare i punti della sequenza e annotare le variabili locali.</param>
      <returns>Un delegato che contiene la versione compilata del lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati. Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <param name="body">Proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> del risultato.</param>
      <param name="parameters">Proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionType">
      <summary>Descrive i tipi dei nodi di una struttura ad albero dell'espressione.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Add">
      <summary>Operazione di addizione, ad esempio <c>a + b</c>, senza controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssign">
      <summary>Operazione di assegnazione composta di addizione, ad esempio <c>(a += b)</c>, senza controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssignChecked">
      <summary>Operazione di assegnazione composta di addizione, ad esempio <c>(a += b)</c>, con controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddChecked">
      <summary>Operazione di addizione, ad esempio <c>(a + b)</c>, con controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.And">
      <summary>Operazione <see langword="AND" /> bit per bit o logica, ad esempio <c>(a &amp; b)</c> in C# e <c>(a And b)</c> in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAlso">
      <summary>Operazione <see langword="AND" /> condizionale che valuta il secondo operando solo se il primo operando restituisce <see langword="true" />. Corrisponde a un'operazione <c>(a &amp;&amp; b)</c> in C# e <c>(AndAlso b)</c> in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAssign">
      <summary>Operazione di assegnazione composta <see langword="AND" /> bit per bit o logica, ad esempio <c>(a &amp;= b)</c> in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayIndex">
      <summary>Operazione di indicizzazione in una matrice unidimensionale, ad esempio <c>array[index]</c> in C# o <c>array(index)</c> in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayLength">
      <summary>Operazione che ottiene la lunghezza di una matrice unidimensionale, ad esempio <c>array.Length</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Assign">
      <summary>Operazione di assegnazione, ad esempio <c>(a = b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Block">
      <summary>Blocco di espressioni.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Call">
      <summary>Chiamata a un metodo, ad esempio nell'espressione <c>obj.sampleMethod()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Coalesce">
      <summary>Nodo che rappresenta un'operazione di unione Null, ad esempio <c>(a ?? b)</c> in C# o <c>If(a, b)</c> in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Conditional">
      <summary>Operazione condizionale, ad esempio <c>a &gt; b ? a : b</c> in C# o <c>If(a &gt; b, a, b)</c> in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Constant">
      <summary>Valore costante.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Convert">
      <summary>Operazione di casting o conversione, ad esempio <c>(SampleType)obj</c> in C# o <c>CType(obj, SampleType)</c> in Visual Basic. Nel caso di una conversione numerica, se il valore convertito è troppo lungo per il tipo di destinazione non viene generata alcuna eccezione.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ConvertChecked">
      <summary>Operazione di casting o conversione, ad esempio <c>(SampleType)obj</c> in C# o <c>CType(obj, SampleType)</c> in Visual Basic. Nel caso di una conversione numerica, se il valore convertito è troppo lungo per il tipo di destinazione viene generata un'eccezione.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DebugInfo">
      <summary>Informazioni sul debug.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Decrement">
      <summary>Operazione di decremento unaria, ad esempio <c>(a - 1)</c> in C# e Visual Basic. È necessario che l'oggetto <c>a</c> non venga modificato sul posto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Default">
      <summary>Valore predefinito.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Divide">
      <summary>Operazione di divisione, ad esempio <c>(a / b)</c>, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DivideAssign">
      <summary>Operazione di assegnazione composta di divisione, ad esempio <c>(a /= b)</c>, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Dynamic">
      <summary>Operazione dinamica.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Equal">
      <summary>Nodo che rappresenta un confronto delle uguaglianze, ad esempio <c>(a == b)</c> in C# o <c>(a = b)</c> in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOr">
      <summary>Operazione <see langword="XOR" /> bit per bit o logica, ad esempio <c>(a ^ b)</c> in C# o <c>(a Xor b)</c> in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign">
      <summary>Operazione di assegnazione composta <see langword="XOR" /> bit per bit o logica, ad esempio <c>(a ^= b)</c> in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Extension">
      <summary>Espressione di estensione.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Goto">
      <summary>Espressione "go to", ad esempio <c>goto Label</c> in C# o <c>GoTo Label</c> in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThan">
      <summary>Confronto "maggiore di", ad esempio <c>(a &gt; b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual">
      <summary>Confronto "maggiore o uguale a", ad esempio <c>(a &gt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Increment">
      <summary>Operazione di incremento unaria, ad esempio <c>(a + 1)</c> in C# e Visual Basic. È necessario che l'oggetto <c>a</c> non venga modificato sul posto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Index">
      <summary>Operazione di indicizzazione o operazione che accede a una proprietà che accetta argomenti.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Invoke">
      <summary>Operazione che richiama un delegato o un'espressione lambda, ad esempio <c>sampleDelegate.Invoke()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsFalse">
      <summary>Valore condizionale <see langword="false" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsTrue">
      <summary>Valore condizionale <see langword="true" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Label">
      <summary>Etichetta.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Lambda">
      <summary>Espressione lambda, ad esempio <c>a =&gt; a + a</c> in C# o <c>Function(a) a + a</c> in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShift">
      <summary>Operazione di scorrimento a sinistra bit per bit, ad esempio <c>(a &lt;&lt; b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign">
      <summary>Assegnazione composta di scorrimento a sinistra bit per bit, ad esempio <c>(a &lt;&lt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThan">
      <summary>Confronto "minore di", ad esempio <c>(a &lt; b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual">
      <summary>Confronto "minore o uguale a", ad esempio <c>(a &lt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ListInit">
      <summary>Operazione che crea un nuovo oggetto <see cref="T:System.Collections.IEnumerable" /> e lo inizializza da un elenco di elementi, ad esempio <c>new List&lt;SampleType&gt;(){ a, b, c }</c> in C# o <c>Dim sampleList = { a, b, c }</c> in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Loop">
      <summary>Ciclo, ad esempio <c>for</c> o <c>while</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberAccess">
      <summary>Operazione che legge da un campo o una proprietà, ad esempio <c>obj.SampleProperty</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberInit">
      <summary>Operazione che crea un nuovo oggetto e ne inizializza uno o più membri, ad esempio <c>new Point { X = 1, Y = 2 }</c> in C# o <c>New Point With {.X = 1, .Y = 2}</c> in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Modulo">
      <summary>Operazione di resto aritmetica, ad esempio <c>(a % b)</c> in C# o <c>(a Mod b)</c> in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ModuloAssign">
      <summary>Operazione di assegnazione composta di resto aritmetica, ad esempio <c>(a %= b)</c> in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Multiply">
      <summary>Operazione di moltiplicazione, ad esempio <c>(a * b)</c>, senza controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssign">
      <summary>Operazione di assegnazione composta di moltiplicazione, ad esempio <c>(a *= b)</c>, senza controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked">
      <summary>Operazione di assegnazione composta di moltiplicazione, ad esempio <c>(a *= b)</c>, con controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyChecked">
      <summary>Operazione di moltiplicazione, ad esempio <c>(a * b)</c>, con controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Negate">
      <summary>Operazione di negazione aritmetica, ad esempio <c>(-a)</c>. È necessario che l'oggetto <c>a</c> non venga modificato sul posto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NegateChecked">
      <summary>Operazione di negazione aritmetica, ad esempio <c>(-a)</c>, con controllo dell'overflow. È necessario che l'oggetto <c>a</c> non venga modificato sul posto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.New">
      <summary>Operazione che chiama un costruttore per creare un nuovo oggetto, ad esempio <c>new SampleType()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayBounds">
      <summary>Operazione che crea una nuova matrice in cui sono specificati i limiti per ogni dimensione, ad esempio <c>new SampleType[dim1, dim2]</c> in C# o <c>New SampleType(dim1, dim2)</c> in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayInit">
      <summary>Operazione che crea una nuova matrice unidimensionale e la inizializza da un elenco di elementi, ad esempio <c>new SampleType[]{a, b, c}</c> in C# o <c>New SampleType(){a, b, c}</c> in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Not">
      <summary>Operazione di negazione logica o di complemento bit per bit. In C# è equivalente a <c>(~a)</c> per i tipi integrali e a <c>(!a)</c> per i valori booleani. In Visual Basic è equivalente a <c>(Not a)</c>. È necessario che l'oggetto <c>a</c> non venga modificato sul posto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NotEqual">
      <summary>Confronto di disuguaglianza, ad esempio <c>(a != b)</c> in C# o <c>(a &lt;&gt; b)</c> in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OnesComplement">
      <summary>Operazione di complemento a uno, ad esempio <c>(~a)</c> in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Or">
      <summary>Operazione <see langword="OR" /> bit per bit o logica, ad esempio <c>(a | b)</c> in C# o <c>(a Or b)</c> in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrAssign">
      <summary>Assegnazione composta <see langword="OR" /> bit per bit o logica, ad esempio <c>(a |= b)</c> in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrElse">
      <summary>Operazione <see langword="OR" /> condizionale di corto circuito, ad esempio <c>(a || b)</c> in C# o <c>(a OrElse b)</c> in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Parameter">
      <summary>Riferimento a un parametro o una variabile definiti nel contesto dell'espressione. Per ulteriori informazioni, vedere <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostDecrementAssign">
      <summary>Decremento suffisso unario, ad esempio <c>(a--)</c>. È necessario che l'oggetto <c>a</c> venga modificato sul posto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostIncrementAssign">
      <summary>Incremento suffisso unario, ad esempio <c>(a++)</c>. È necessario che l'oggetto <c>a</c> venga modificato sul posto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Power">
      <summary>Operazione matematica che eleva un numero a potenza, ad esempio <c>(a ^ b)</c> in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PowerAssign">
      <summary>Operazione di assegnazione composta che eleva un numero a potenza, ad esempio <c>(a ^= b)</c> in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreDecrementAssign">
      <summary>Decremento prefisso unario, ad esempio <c>(--a)</c>. È necessario che l'oggetto <c>a</c> venga modificato sul posto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreIncrementAssign">
      <summary>Incremento prefisso unario, ad esempio <c>(++a)</c>. È necessario che l'oggetto <c>a</c> venga modificato sul posto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Quote">
      <summary>Espressione che ha un valore costante di tipo <see cref="T:System.Linq.Expressions.Expression" />. Un nodo <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> può contenere riferimenti ai parametri definiti nel contesto dell'espressione che rappresenta.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShift">
      <summary>Operazione di scorrimento a destra bit per bit, ad esempio <c>(a &gt;&gt; b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShiftAssign">
      <summary>Operazione di assegnazione composta di scorrimento a destra bit per bit, ad esempio <c>(a &gt;&gt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RuntimeVariables">
      <summary>Elenco di variabili di run-time. Per ulteriori informazioni, vedere <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Subtract">
      <summary>Operazione di sottrazione, ad esempio <c>(a - b)</c>, senza controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssign">
      <summary>Operazione di assegnazione composta di sottrazione, ad esempio <c>(a -= b)</c>, senza controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked">
      <summary>Operazione di assegnazione composta di sottrazione, ad esempio <c>(a -= b)</c>, con controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractChecked">
      <summary>Operazione di sottrazione aritmetica, ad esempio <c>(a - b)</c>, con controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Switch">
      <summary>Operazione di switch, ad esempio <see langword="switch" /> in C# o <see langword="Select Case" /> in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Throw">
      <summary>Operazione che genera un'eccezione, ad esempio <c>throw new Exception()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Try">
      <summary>Espressione <see langword="try-catch" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeAs">
      <summary>Riferimento esplicito o conversione boxing in cui viene specificato <see langword="null" /> se la conversione non riesce, ad esempio <c>(obj as SampleType)</c> in C# o <c>TryCast(obj, SampleType)</c> in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeEqual">
      <summary>Test di tipo esatto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeIs">
      <summary>Tipo di test, ad esempio <c>obj is SampleType</c> in C# o <c>TypeOf obj is SampleType</c> in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.UnaryPlus">
      <summary>Operazione con più unario, ad esempio <c>(+a)</c>. Il risultato di un'operazione con il più unario predefinita è il valore dell'operando, ma le implementazioni definite dall'utente possono dare risultati insoliti.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Unbox">
      <summary>Operazione di unboxing del tipo di valore, ad esempio le istruzioni <see langword="unbox" /> e <see langword="unbox.any" /> in MSIL.</summary>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionVisitor">
      <summary>Rappresenta un visitatore o un rewriter per le strutture ad albero dell'espressione.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.#ctor">
      <summary>Inizializza una nuova istanza di <see cref="T:System.Linq.Expressions.ExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.Expression})">
      <summary>Invia l'elenco di espressioni a uno dei metodi di visita più specializzati in questa classe.</summary>
      <param name="nodes">Espressioni da visitare.</param>
      <returns>L'elenco modificato delle espressioni, se è stato modificato uno degli elementi; in caso contrario, restituisce l'elenco originale delle espressioni.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Linq.Expressions.Expression)">
      <summary>Invia l'espressione a uno dei metodi di visita più specializzati in questa classe.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Func{``0,``0})">
      <summary>Visita tutti i nodi nella raccolta utilizzando un visitatore dell'elemento specificato.</summary>
      <param name="nodes">I nodi da visitare.</param>
      <param name="elementVisitor">Un delegato che visita un solo elemento, sostituendolo facoltativamente con un nuovo elemento.</param>
      <typeparam name="T">Il tipo di tutti i nodi.</typeparam>
      <returns>Elenco modificato dei nodi, se è stato modificato uno degli elementi. In caso contrario, restituisce l'elenco originale dei nodi.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(``0,System.String)">
      <summary>Visita un'espressione, eseguendo il cast del risultato sul tipo di espressione originale.</summary>
      <param name="node">Espressione da visitare.</param>
      <param name="callerName">Nome del metodo chiamante. Utilizzato per segnalare un messaggio di errore migliore.</param>
      <typeparam name="T">Tipo dell'espressione.</typeparam>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <exception cref="T:System.InvalidOperationException">Il metodo di visita per questo nodo ha restituito un tipo diverso.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.String)">
      <summary>Visita tutte le espressioni nella raccolta, eseguendo il cast dei risultati sul tipo di espressione originale.</summary>
      <param name="nodes">Espressioni da visitare.</param>
      <param name="callerName">Nome del metodo chiamante. Usato per segnalare un messaggio di errore migliore.</param>
      <typeparam name="T">Tipo delle espressioni.</typeparam>
      <returns>Raccolta di espressioni modificate, se una delle espressioni è stata modificata; in caso contrario, restituisce la raccolta di espressioni originali.</returns>
      <exception cref="T:System.InvalidOperationException">Il metodo di visita per una delle espressioni ha restituito un tipo diverso.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.BinaryExpression" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.BlockExpression" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitCatchBlock(System.Linq.Expressions.CatchBlock)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.ConditionalExpression" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.ConstantExpression" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDebugInfo(System.Linq.Expressions.DebugInfoExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDefault(System.Linq.Expressions.DefaultExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.DefaultExpression" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDynamic(System.Linq.Expressions.DynamicExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.DynamicExpression" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitElementInit(System.Linq.Expressions.ElementInit)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitExtension(System.Linq.Expressions.Expression)">
      <summary>Visita i figli dell'espressione di estensione.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitGoto(System.Linq.Expressions.GotoExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitIndex(System.Linq.Expressions.IndexExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.IndexExpression" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.InvocationExpression" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabel(System.Linq.Expressions.LabelExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.LabelExpression" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabelTarget(System.Linq.Expressions.LabelTarget)">
      <summary>Visita <see cref="T:System.Linq.Expressions.LabelTarget" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.Expression`1" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <typeparam name="T">Tipo del delegato.</typeparam>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.ListInitExpression" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLoop(System.Linq.Expressions.LoopExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.LoopExpression" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMember(System.Linq.Expressions.MemberExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.MemberExpression" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.MemberAssignment" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberBinding(System.Linq.Expressions.MemberBinding)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.MemberListBinding" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.MemberMemberBinding" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.NewExpression" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.NewArrayExpression" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitRuntimeVariables(System.Linq.Expressions.RuntimeVariablesExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitch(System.Linq.Expressions.SwitchExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitchCase(System.Linq.Expressions.SwitchCase)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTry(System.Linq.Expressions.TryExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.TryExpression" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTypeBinary(System.Linq.Expressions.TypeBinaryExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.UnaryExpression" />.</summary>
      <param name="node">Espressione da visitare.</param>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpression">
      <summary>Rappresenta un salto incondizionato. Include istruzioni di ritorno, interruzione e continuazione, e altri salti.</summary>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Kind">
      <summary>Il tipo di espressione "go to". Ha solo scopi di informazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> che rappresenta il tipo dell'espressione "go to".</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Target">
      <summary>L'etichetta della destinazione a cui salta questo nodo.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> che rappresenta l'etichetta destinazione per questo nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.GotoExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.GotoExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati. Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <param name="target">Proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> del risultato.</param>
      <param name="value">Proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Value" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Value">
      <summary>Il valore passato alla destinazione, oppure Null se la destinazione è di tipo System.Void.</summary>
      <returns>L'oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il valore passato alla destinazione, oppure Null.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpressionKind">
      <summary>Specifica che tipo di salto che questo <see cref="T:System.Linq.Expressions.GotoExpression" /> rappresenta.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Break">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione di interruzione.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Continue">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione di continuazione.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Goto">
      <summary>Un <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un salto a una determinata posizione.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Return">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione di ritorno.</summary>
    </member>
    <member name="T:System.Linq.Expressions.IArgumentProvider">
      <summary>Offre un'interfaccia interna per l'accesso agli argomenti di più nodi dell'albero (DynamicExpression, ElementInit, MethodCallExpression, InvocationExpression, NewExpression e IndexExpression).  Questa API è solo per uso interno.</summary>
    </member>
    <member name="P:System.Linq.Expressions.IArgumentProvider.ArgumentCount">
      <summary>Restituisce il numero di argomenti per il nodo dell'albero delle espressioni. Questa API è solo per uso interno.</summary>
      <returns>Numero di argomenti per il nodo dell'albero delle espressioni pari a <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IArgumentProvider.GetArgument(System.Int32)">
      <summary>Restituisce l'argomento in corrispondenza di <paramref name="index" />, generando un'eccezione se <paramref name="index" /> non è compreso nell'intervallo. Questa API è solo per uso interno.</summary>
      <param name="index">Indice dell’argomento.</param>
      <returns>Argomento in corrispondenza dell'indice.</returns>
    </member>
    <member name="T:System.Linq.Expressions.IDynamicExpression">
      <summary>Offre un'interfaccia interna per l'accesso agli argomenti dei nodi dell'albero DynamicExpression nonché alle funzionalità di sito di chiamata e riscrittura.  Non usare questa API.  È pubblica solo per via del refactoring DLL ed esiste solo per le ottimizzazioni delle prestazioni interne.</summary>
    </member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.CreateCallSite">
      <summary>Crea facoltativamente il sito di chiamata e lo restituisce per la cache inline polimorfica di DynamicExpression.  Non usare questo tipo.  Essendo solo di tipo pubblico a causa del refactoring di assembly si usa internamente per le ottimizzazioni delle prestazioni.</summary>
      <returns>Sito di chiamata per la cache inline polimorfica di DynamicExpression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IDynamicExpression.DelegateType">
      <summary>Ottiene il tipo delegato usato dal sito di chiamata, ovvero il tipo delle regole usate nella cache inline polimorfica dell'espressione dinamica.</summary>
      <returns>Tipo delegato usato dal sito di chiamata.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.Rewrite(System.Linq.Expressions.Expression[])">
      <summary>Riscrive questo nodo sostituendo gli argomenti dell'espressione dinamica con i valori specificati.  Il numero di <paramref name="args" /> deve corrispondere al numero dell'espressione corrente.  Non usare questo tipo.  Essendo solo di tipo pubblico a causa del refactoring di assembly si usa internamente per le ottimizzazioni delle prestazioni.  Questo metodo di supporto consente la riscrittura dei nodi in modo che siano indipendenti dalla classe di implementazione specifica che deriva da DynamicExpression, usata nel sito di chiamata.</summary>
      <param name="args">Argomenti usati per sostituire questo nodo.</param>
      <returns>Nodo riscritto; se non sono state apportate modifiche, restituisce lo stesso nodo.</returns>
    </member>
    <member name="T:System.Linq.Expressions.IndexExpression">
      <summary>Rappresenta l'indicizzazione di una proprietà o di una matrice.</summary>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Arguments">
      <summary>Ottiene gli argomenti che verranno utilizzati per indicizzare la proprietà o la matrice.</summary>
      <returns>Raccolta di sola lettura contenente gli argomenti che verranno utilizzati per indicizzare la proprietà o la matrice.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Indexer">
      <summary>Ottiene <see cref="T:System.Reflection.PropertyInfo" /> per la proprietà se l'espressione rappresenta una proprietà indicizzata, restituisce Null in caso contrario.</summary>
      <returns>
        <see cref="T:System.Reflection.PropertyInfo" /> per la proprietà se l'espressione rappresenta una proprietà indicizzata; in caso contrario Null.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Object">
      <summary>Un oggetto da indicizzare.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'oggetto da indicizzare.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary>Restituisce il numero di argomenti per il nodo dell'albero delle espressioni.  Non usare questo membro.  Essendo solo di tipo pubblico a causa del refactoring di assembly si usa internamente per le ottimizzazioni delle prestazioni.</summary>
      <returns>Restituisca il valore <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary>Restituisce l'argomento in corrispondenza dell'indice, generando un'eccezione se l'indice non è compreso nell'intervallo.  Non usare questo membro.  Essendo solo di tipo pubblico a causa del refactoring di assembly si usa internamente per le ottimizzazioni delle prestazioni.</summary>
      <param name="index">Indice dell’argomento.</param>
      <returns>Restituisca il valore <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.IndexExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IndexExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati. Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <param name="object">Proprietà <see cref="P:System.Linq.Expressions.IndexExpression.Object" /> del risultato.</param>
      <param name="arguments">Proprietà <see cref="P:System.Linq.Expressions.IndexExpression.Arguments" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="T:System.Linq.Expressions.InvocationExpression">
      <summary>Rappresenta un'espressione che applica un delegato o un'espressione lambda a un elenco di espressioni argomento.</summary>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Arguments">
      <summary>Ottiene gli argomenti a cui viene applicato il delegato o l'espressione lambda.</summary>
      <returns>Oggetto <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano gli argomenti ai quali viene applicato il delegato.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Expression">
      <summary>Ottiene il delegato o l'espressione lambda da applicare.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il delegato da applicare.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questa espressione. I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary>Restituisce il numero di argomenti per il nodo dell'albero delle espressioni.  Non usare questo membro.  Essendo solo di tipo pubblico a causa del refactoring di assembly si usa internamente per le ottimizzazioni delle prestazioni.</summary>
      <returns>Numero di argomenti per il nodo dell'albero delle espressioni pari a <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary>Restituisce l'argomento in corrispondenza dell'indice, generando un'eccezione se l'indice non è compreso nell'intervallo.  Non usare questo membro.  Essendo solo di tipo pubblico a causa del refactoring di assembly si usa internamente per le ottimizzazioni delle prestazioni.</summary>
      <param name="index">Indice dell’argomento.</param>
      <returns>Argomento in corrispondenza dell'indice, che genera un'eccezione se l'indice non è compreso nell'intervallo <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.InvocationExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati. Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <param name="expression">Proprietà <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> del risultato.</param>
      <param name="arguments">Proprietà <see cref="P:System.Linq.Expressions.InvocationExpression.Arguments" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LabelExpression">
      <summary>Rappresenta un'etichetta che può essere inserita in qualsiasi contesto <see cref="T:System.Linq.Expressions.Expression" />. Se viene raggiunto, otterrà il valore fornito dal corrispondente <see cref="T:System.Linq.Expressions.GotoExpression" />. In caso contrario, riceve il valore in <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" />. Se <see cref="T:System.Type" /> è uguale a System.Void, non deve essere fornito alcun valore.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.DefaultValue">
      <summary>Il valore di <see cref="T:System.Linq.Expressions.LabelExpression" /> quando l'etichetta viene raggiunta tramite flusso di controllo normale (ad esempio, non ci si è arrivati tramite un salto).</summary>
      <returns>Oggetto Expression che rappresenta il valore dell'oggetto <see cref="T:System.Linq.Expressions.LabelExpression" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Target">
      <summary>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al quale è associata questa etichetta.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al quale è associata questa etichetta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LabelExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati. Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <param name="target">Proprietà <see cref="P:System.Linq.Expressions.LabelExpression.Target" /> del risultato.</param>
      <param name="defaultValue">Proprietà <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LabelTarget">
      <summary>Utilizzato per rappresentare la destinazione di un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Name">
      <summary>Ottiene il nome dell'etichetta.</summary>
      <returns>Nome dell'etichetta.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelTarget.ToString">
      <summary>Restituisce un oggetto <see cref="T:System.String" /> che rappresenta l'elemento <see cref="T:System.Object" /> corrente.</summary>
      <returns>Oggetto <see cref="T:System.String" /> che rappresenta l'oggetto <see cref="T:System.Object" /> corrente.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Type">
      <summary>Il tipo di valore passato saltando all'etichetta (o <see cref="T:System.Void" /> se non deve essere passato alcun valore).</summary>
      <returns>L'oggetto <see cref="T:System.Type" /> che rappresenta il tipo di valore passato saltando all'etichetta, oppure <see cref="T:System.Void" /> se non deve essere passato alcun valore</returns>
    </member>
    <member name="T:System.Linq.Expressions.LambdaExpression">
      <summary>Descrive un'espressione lambda. Acquisisce un blocco di codice analogo a un corpo di metodo .NET.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Body">
      <summary>Ottiene il corpo dell'espressione lambda.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il corpo dell'espressione lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile">
      <summary>Produce un delegato che rappresenta l'espressione lambda.</summary>
      <returns>Oggetto <see cref="T:System.Delegate" /> contenente la versione compilata dell'espressione lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile(System.Boolean)">
      <summary>Produce un delegato interpretato o compilato che rappresenta l'espressione lambda.</summary>
      <param name="preferInterpretation">
        <see langword="true" /> per indicare che l'espressione deve essere compilata in un formato interpretato, se disponibile. In caso contrario, <see langword="false" />.</param>
      <returns>Un delegato che rappresenta l'espressione lambda compilata descritta dall'oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile(System.Runtime.CompilerServices.DebugInfoGenerator)">
      <summary>Produce un delegato che rappresenta l'espressione lambda.</summary>
      <param name="debugInfoGenerator">Generatore delle informazioni di debug utilizzato dal compilatore per contrassegnare i punti della sequenza e annotare le variabili locali.</param>
      <returns>Un delegato che contiene la versione compilata del lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Name">
      <summary>Ottiene il nome dell'espressione lambda.</summary>
      <returns>Nome dell'espressione lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Parameters">
      <summary>Ottiene i parametri dell'espressione lambda.</summary>
      <returns>Oggetto <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> che rappresentano i parametri dell'espressione lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.ReturnType">
      <summary>Ottiene il tipo di ritorno dell'espressione lambda.</summary>
      <returns>Oggetto <see cref="T:System.Type" /> che rappresenta il tipo dell'espressione lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.TailCall">
      <summary>Ottiene il valore che indica se l'espressione lambda sarà compilata con l'ottimizzazione della chiamata tail.</summary>
      <returns>
        <see langword="true" />Se l'espressione lambda verrà compilata con l'ottimizzazione della chiamata tail; in caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LambdaExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ListInitExpression">
      <summary>Rappresenta una chiamata al costruttore con un inizializzatore di raccolta.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.CanReduce">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione può essere ridotto.</summary>
      <returns>
        <see langword="true" />Se il nodo può essere ridotto; in caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Initializers">
      <summary>Ottiene gli inizializzatori di elementi utilizzati per inizializzare una raccolta.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> che rappresentano gli elementi utilizzati per inizializzare la raccolta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NewExpression">
      <summary>Ottiene l'espressione che contiene una chiamata al costruttore di un tipo di raccolta.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore di un tipo di raccolta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Reduce">
      <summary>Riduce il nodo dell'espressione binaria a un'espressione più semplice.</summary>
      <returns>Espressione ridotta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ListInitExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati. Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <param name="newExpression">Proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> del risultato.</param>
      <param name="initializers">Proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LoopExpression">
      <summary>Rappresenta un ciclo infinito. È possibile uscire con "interruzione."</summary>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Body">
      <summary>Ottiene l'oggetto <see cref="T:System.Linq.Expressions.Expression" /> che costituisce il corpo del ciclo.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che costituisce il corpo del ciclo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.BreakLabel">
      <summary>Ottiene <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizzato dal corpo di ciclo come  destinazione dell'istruzione di interruzione.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizzato dal corpo di ciclo come destinazione dell'istruzione di interruzione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.ContinueLabel">
      <summary>Ottiene <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizzato dal corpo di ciclo come  destinazione dell'istruzione di continuazione.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizzato dal corpo di ciclo come  destinazione dell'istruzione di continuazione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questa espressione. I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LoopExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LoopExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati. Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <param name="breakLabel">Proprietà <see cref="P:System.Linq.Expressions.LoopExpression.BreakLabel" /> del risultato.</param>
      <param name="continueLabel">Proprietà <see cref="P:System.Linq.Expressions.LoopExpression.ContinueLabel" /> del risultato.</param>
      <param name="body">Proprietà <see cref="P:System.Linq.Expressions.LoopExpression.Body" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberAssignment">
      <summary>Rappresenta l'operazione di assegnazione per un campo o una proprietà di un oggetto.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberAssignment.Expression">
      <summary>Ottiene l'espressione da assegnare al campo o alla proprietà.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il valore da assegnare al campo o alla proprietà.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberAssignment.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati. Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <param name="expression">Proprietà <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBinding">
      <summary>Fornisce la classe di base dalla quale derivano le classi che rappresentano le associazioni utilizzate per inizializzare i membri di un oggetto appena creato.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.#ctor(System.Linq.Expressions.MemberBindingType,System.Reflection.MemberInfo)">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <param name="type">
        <see cref="T:System.Linq.Expressions.MemberBindingType" /> che discrimina il tipo di associazione rappresentato.</param>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> che rappresenta un campo o una proprietà da inizializzare.</param>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.BindingType">
      <summary>Ottiene il tipo di associazione rappresentato.</summary>
      <returns>Uno dei valori di <see cref="T:System.Linq.Expressions.MemberBindingType" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.Member">
      <summary>Ottiene il campo o la proprietà da inizializzare.</summary>
      <returns>
        <see cref="T:System.Reflection.MemberInfo" /> che rappresenta il campo o la proprietà da inizializzare.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.ToString">
      <summary>Restituisce una rappresentazione testuale di <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Rappresentazione testuale di <see cref="T:System.Linq.Expressions.MemberBinding" />.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBindingType">
      <summary>Descrive i tipi di associazione utilizzati negli oggetti <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.Assignment">
      <summary>Associazione che rappresenta l'inizializzazione di un membro con il valore di un'espressione.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.ListBinding">
      <summary>Associazione che rappresenta l'inizializzazione di un membro di tipo <see cref="T:System.Collections.IList" /> o <see cref="T:System.Collections.Generic.ICollection`1" /> da un elenco di elementi.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.MemberBinding">
      <summary>Associazione che rappresenta l'inizializzazione ricorsiva dei membri di un membro.</summary>
    </member>
    <member name="T:System.Linq.Expressions.MemberExpression">
      <summary>Rappresenta l'accesso a un campo o a una proprietà.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo. Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
      <returns>Risultato della visita di questo nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Expression">
      <summary>Ottiene l'oggetto contenitore del campo o della proprietà.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'oggetto contenitore del campo o della proprietà.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Member">
      <summary>Ottiene il campo o la proprietà a cui accedere.</summary>
      <returns>
        <see cref="T:System.Reflection.MemberInfo" /> che rappresenta il campo o la proprietà a cu accedere.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati. Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <param name="expression">Proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberInitExpression">
      <summary>Rappresenta la chiamata a un costruttore e l'inizializzazione di uno o più membri del nuovo oggetto.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Bindings">
      <summary>Ottiene le associazioni che descrivono come inizializzare i membri dell'oggetto appena creato.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> che descrivono come inizializzare i membri.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.CanReduce">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione può essere ridotto.</summary>
      <returns>
        <see langword="true" />Se il nodo può essere ridotto; in caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NewExpression">
      <summary>Ottiene l'espressione che rappresenta la chiamata al costruttore.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questo oggetto Expression. I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Reduce">
      <summary>Riduce <see cref="T:System.Linq.Expressions.MemberInitExpression" /> a un'espressione più semplice.</summary>
      <returns>Espressione ridotta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MemberInitExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati. Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <param name="newExpression">Proprietà <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> del risultato.</param>
      <param name="bindings">Proprietà <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberListBinding">
      <summary>Rappresenta l'inizializzazione degli elementi di un membro di raccolta di un oggetto appena creato.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberListBinding.Initializers">
      <summary>Ottiene gli inizializzatori di elemento per l'inizializzazione di un membro di raccolta di un oggetto appena creato.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> con cui inizializzare un membro di raccolta.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberListBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati. Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <param name="initializers">Proprietà <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberMemberBinding">
      <summary>Rappresenta l'inizializzazione dei membri di un membro di un oggetto appena creato.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberMemberBinding.Bindings">
      <summary>Ottiene le associazioni che descrivono come inizializzare i membri di un membro.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> che descrivono come inizializzare i membri del membro.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberMemberBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati. Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <param name="bindings">Proprietà <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MethodCallExpression">
      <summary>Rappresenta una chiamata a un metodo statico o di istanza.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo. Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
      <returns>Risultato della visita di questo nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Arguments">
      <summary>Ottiene una raccolta di espressioni che rappresentano gli argomenti del metodo chiamato.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano gli argomenti del metodo chiamato.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Method">
      <summary>Ottiene l'oggetto <see cref="T:System.Reflection.MethodInfo" /> per il metodo da chiamare.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo chiamato.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Object">
      <summary>Ottiene l'oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'istanza per le chiamate ai metodi di istanza oppure null per le chiamate ai metodi statici.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'oggetto ricevente del metodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary>Restituisce il numero di argomenti per il nodo dell'albero delle espressioni.  Non usare questo membro.  Essendo solo di tipo pubblico a causa del refactoring di assembly si usa internamente per le ottimizzazioni delle prestazioni.</summary>
      <returns>Il numero di argomenti del nodo dell'albero delle espressioni <see cref="T:System.Int32" />come.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary>Restituisce l'argomento in corrispondenza dell'indice, generando un'eccezione se l'indice non è compreso nell'intervallo.  Non usare questo membro.  Essendo solo di tipo pubblico a causa del refactoring di assembly si usa internamente per le ottimizzazioni delle prestazioni.</summary>
      <param name="index">Indice dell’argomento.</param>
      <returns>Restituisca il valore <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MethodCallExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati. Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <param name="object">Proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> del risultato.</param>
      <param name="arguments">Proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="T:System.Linq.Expressions.NewArrayExpression">
      <summary>Rappresenta la creazione di una nuova matrice e la possibile inizializzazione degli elementi della nuova matrice.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo. Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
      <returns>Risultato della visita di questo nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Expressions">
      <summary>Ottiene i limiti della matrice se il valore della proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> o i valori per inizializzare gli elementi della nuova matrice se il valore della proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano i limiti della matrice o i valori di inizializzazione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewArrayExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati. Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <param name="expressions">Proprietà <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="T:System.Linq.Expressions.NewExpression">
      <summary>Rappresenta una chiamata a un costruttore.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo. Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
      <returns>Risultato della visita di questo nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Arguments">
      <summary>Ottiene gli argomenti del costruttore.</summary>
      <returns>Raccolta di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano gli argomenti del costruttore.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Constructor">
      <summary>Ottiene il costruttore chiamato.</summary>
      <returns>
        <see cref="T:System.Reflection.ConstructorInfo" /> che rappresenta il costruttore chiamato.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Members">
      <summary>Ottiene i membri che possono recuperare i valori dei campi inizializzati con gli argomenti del costruttore.</summary>
      <returns>Raccolta di oggetti <see cref="T:System.Reflection.MemberInfo" /> che rappresentano i membri che possono recuperare i valori dei campi inizializzati con gli argomenti del costruttore.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary>Ottiene il numero di argomenti per il nodo dell'albero delle espressioni.</summary>
      <returns>Numero di argomenti per il nodo dell'albero delle espressioni.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary>Restituisce l'argomento in corrispondenza dell'indice, generando un'eccezione se l'indice non è compreso nell'intervallo.</summary>
      <param name="index">Indice dell’argomento.</param>
      <returns>Argomento in corrispondenza dell'indice, che genera un'eccezione se l'indice non è compreso nell'intervallo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati. Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <param name="arguments">Proprietà <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ParameterExpression">
      <summary>Rappresenta un'espressione del parametro denominato.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ParameterExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo. Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
      <returns>Risultato della visita di questo nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.IsByRef">
      <summary>Indica che questo elemento <c>ParameterExpression</c> deve essere trattato come un parametro <see langword="ByRef" />.</summary>
      <returns>
        <see langword="true" />Se questo <c>ParameterExpression</c> è un <see langword="ByRef" /> parametro; in caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Name">
      <summary>Ottiene il nome del parametro o della variabile.</summary>
      <returns>
        <see cref="T:System.String" /> che contiene il nome del parametro.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ParameterExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="T:System.Linq.Expressions.RuntimeVariablesExpression">
      <summary>Un'espressione che fornisce autorizzazione di lettura e scrittura per le variabili al runtime.</summary>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questo oggetto Expression. I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.RuntimeVariablesExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati. Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <param name="variables">Proprietà <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables">
      <summary>Le variabili o parametri alle quali fornire accesso al runtime.</summary>
      <returns>La raccolta di sola lettura che contiene i parametri a cui sarà forniti l'accesso al runtime.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchCase">
      <summary>Rappresenta un case di un oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.Body">
      <summary>Ottiene il corpo di questo case.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il corpo di un blocco case.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.TestValues">
      <summary>Ottiene i valori di questo case. Questo case viene selezionato per l'esecuzione quando <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> corrisponde a qualsiasi valore.</summary>
      <returns>La raccolta di sola lettura dei valori per questo blocco case.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.ToString">
      <summary>Restituisce un oggetto <see cref="T:System.String" /> che rappresenta l'elemento <see cref="T:System.Object" /> corrente.</summary>
      <returns>Oggetto <see cref="T:System.String" /> che rappresenta l'oggetto <see cref="T:System.Object" /> corrente.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati. Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <param name="testValues">Proprietà <see cref="P:System.Linq.Expressions.SwitchCase.TestValues" /> del risultato.</param>
      <param name="body">Proprietà <see cref="P:System.Linq.Expressions.SwitchCase.Body" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchExpression">
      <summary>Rappresenta un'espressione di controllo che gestisce più selezioni passando il controllo a <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Cases">
      <summary>Ottiene la raccolta di oggetti <see cref="T:System.Linq.Expressions.SwitchCase" /> per l'opzione.</summary>
      <returns>Raccolta di oggetti <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Comparison">
      <summary>Ottiene il metodo di confronto di uguaglianze, se presente.</summary>
      <returns>Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di confronto di uguaglianze.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.DefaultBody">
      <summary>Ottiene il test per lo switch.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il test per lo switch.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questo oggetto Expression. I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.SwitchValue">
      <summary>Ottiene il test per lo switch.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il test per lo switch.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.SwitchExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase},System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati. Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <param name="switchValue">Proprietà <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> del risultato.</param>
      <param name="cases">Proprietà <see cref="P:System.Linq.Expressions.SwitchExpression.Cases" /> del risultato.</param>
      <param name="defaultBody">Proprietà <see cref="P:System.Linq.Expressions.SwitchExpression.DefaultBody" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SymbolDocumentInfo">
      <summary>Archivia le informazioni necessarie per generare informazioni sui simboli del debug per un file di origine, in particolare il nome file e l'identificatore del linguaggio univoco.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType">
      <summary>Restituisce l'identificatore univoco del tipo di documento, se presente. Imposta come valore predefinito a GUID per un file di testo.</summary>
      <returns>Identificatore univoco del tipo di documento.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.FileName">
      <summary>Nome del file di origine.</summary>
      <returns>Stringa che rappresenta il nome del file di origine.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.Language">
      <summary>Restituisce l'identificatore univoco del linguaggio, se presente.</summary>
      <returns>Identificatore univoco del linguaggio</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor">
      <summary>Restituisce l'identificatore univoco del fornitore del linguaggio, se presente.</summary>
      <returns>Identificatore univoco del fornitore del linguaggio.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TryExpression">
      <summary>Rappresenta un blocco try/catch/finally/fault.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Body">
      <summary>Ottiene l'oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il corpo del blocco try.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il corpo del blocco try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Fault">
      <summary>Ottiene <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il blocco fault.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il blocco fault.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Finally">
      <summary>Ottiene <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il blocco finally.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il blocco finally.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Handlers">
      <summary>Ottiene la raccolta di espressioni <see cref="T:System.Linq.Expressions.CatchBlock" /> associate al blocco try.</summary>
      <returns>Raccolta di espressioni <see cref="T:System.Linq.Expressions.CatchBlock" /> associate al blocco try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TryExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TryExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati. Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <param name="body">Proprietà <see cref="P:System.Linq.Expressions.TryExpression.Body" /> del risultato.</param>
      <param name="handlers">Proprietà <see cref="P:System.Linq.Expressions.TryExpression.Handlers" /> del risultato.</param>
      <param name="finally">Proprietà <see cref="P:System.Linq.Expressions.TryExpression.Finally" /> del risultato.</param>
      <param name="fault">Proprietà <see cref="P:System.Linq.Expressions.TryExpression.Fault" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TypeBinaryExpression">
      <summary>Rappresenta un'operazione tra un'espressione e un tipo.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Expression">
      <summary>Ottiene l'operando dell'espressione di un'operazione di test del tipo.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando dell'espressione di un'operazione di test del tipo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questo oggetto Expression. I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand">
      <summary>Ottiene l'operando del tipo di un'operazione di test del tipo.</summary>
      <returns>
        <see cref="T:System.Type" /> che rappresenta l'operando del tipo di un'operazione di test del tipo.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TypeBinaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati. Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <param name="expression">Proprietà <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="T:System.Linq.Expressions.UnaryExpression">
      <summary>Rappresenta un'espressione che ha un operatore unario.</summary>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.CanReduce">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione può essere ridotto.</summary>
      <returns>
        <see langword="true" />Se un nodo può essere ridotto; in caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLifted">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione rappresenta una chiamata elevata a un operatore.</summary>
      <returns>
        <see langword="true" /> se il nodo rappresenta una chiamata elevata; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLiftedToNull">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione rappresenta una chiamata elevata a un operatore il cui tipo restituito è elevato a un tipo nullable.</summary>
      <returns>
        <see langword="true" /> se il tipo restituito dell'operatore è elevato a un tipo nullable; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Method">
      <summary>Ottiene il metodo di implementazione per l'operazione unaria.</summary>
      <returns>Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Operand">
      <summary>Ottiene l'operando dell'operazione unaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando dell'operazione unaria.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Reduce">
      <summary>Riduce il nodo dell'espressione a un'espressione più semplice.</summary>
      <returns>Espressione ridotta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.UnaryExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati. Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <param name="operand">Proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> del risultato.</param>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
    </member>
    <member name="T:System.Linq.IOrderedQueryable">
      <summary>Rappresenta il risultato di un'operazione di ordinamento.</summary>
    </member>
    <member name="T:System.Linq.IOrderedQueryable`1">
      <summary>Rappresenta il risultato di un'operazione di ordinamento.</summary>
      <typeparam name="T">Tipo di contenuto dell'origine dati.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryable">
      <summary>Fornisce funzionalità per valutare query in relazione a un'origine dati specifica in cui il tipo dei dati non è specificato.</summary>
    </member>
    <member name="P:System.Linq.IQueryable.ElementType">
      <summary>Ottiene il tipo dell'elemento o degli elementi che sono restituiti quando la struttura ad albero dell'espressione associata a questa istanza di <see cref="T:System.Linq.IQueryable" /> è eseguita.</summary>
      <returns>Un <see cref="T:System.Type" /> che rappresenta il tipo dell’elemento o degli elementi che sono restituiti quando la struttura ad albero dell'espressione associata a questo oggetto è eseguita.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Expression">
      <summary>Ottiene la struttura ad albero dell'espressione associata all'istanza di <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> associato a questa istanza di <see cref="T:System.Linq.IQueryable" />.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Provider">
      <summary>Ottiene il provider della query associato all’origine dati.</summary>
      <returns>L'oggetto <see cref="T:System.Linq.IQueryProvider" /> associato con l’origine dati.</returns>
    </member>
    <member name="T:System.Linq.IQueryable`1">
      <summary>Fornisce funzionalità per valutare query in relazione a un'origine dati specifica in cui il tipo dei dati è conosciuto.</summary>
      <typeparam name="T">Tipo di dati nell’origine dati.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryProvider">
      <summary>Definisce metodi per creare ed eseguire query descritte da un oggetto <see cref="T:System.Linq.IQueryable" />.</summary>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery(System.Linq.Expressions.Expression)">
      <summary>Costruisce un oggetto <see cref="T:System.Linq.IQueryable" /> per valutare la query rappresentata da una struttura ad albero dell'espressione specificata.</summary>
      <param name="expression">Una struttura ad albero dell'espressione che rappresenta la query LINQ.</param>
      <returns>
        <see cref="T:System.Linq.IQueryable" /> in grado di valutare la query rappresentata dall'albero delle espressioni specificato.</returns>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery``1(System.Linq.Expressions.Expression)">
      <summary>Costruisce un oggetto <see cref="T:System.Linq.IQueryable`1" /> per valutare la query rappresentata da una struttura ad albero dell'espressione specificata.</summary>
      <param name="expression">Una struttura ad albero dell'espressione che rappresenta la query LINQ.</param>
      <typeparam name="TElement">Tipo degli elementi dell’oggetto restituito <see cref="T:System.Linq.IQueryable`1" />.</typeparam>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> in grado di valutare la query rappresentata dall'albero delle espressioni specificato.</returns>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute(System.Linq.Expressions.Expression)">
      <summary>Esegue la query rappresentata da una struttura ad albero dell'espressione specificata.</summary>
      <param name="expression">Una struttura ad albero dell'espressione che rappresenta la query LINQ.</param>
      <returns>Il valore che è il risultato dell'esecuzione della query specificata.</returns>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute``1(System.Linq.Expressions.Expression)">
      <summary>Esegue la query fortemente tipizzata rappresentata da una struttura ad albero dell'espressione specificata.</summary>
      <param name="expression">Una struttura ad albero dell'espressione che rappresenta la query LINQ.</param>
      <typeparam name="TResult">Il tipo di valore che è il risultato dell'esecuzione della query.</typeparam>
      <returns>Il valore che è il risultato dell'esecuzione della query specificata.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSite">
      <summary>Una classe di base del sito di chiamata dinamica. Questo tipo viene utilizzato come tipo di parametro ai siti dinamici di destinazione.</summary>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSite.Binder">
      <summary>Classe responsabile per l'associazione di operazioni dinamiche sul sito dinamico.</summary>
      <returns>Oggetto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> responsabile per l'associazione di operazioni dinamiche.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSite.Create(System.Type,System.Runtime.CompilerServices.CallSiteBinder)">
      <summary>Crea un sito di chiamata con il tipo delegato specificato e il gestore di associazione.</summary>
      <param name="delegateType">Tipo delegato del sito di chiamata.</param>
      <param name="binder">Gestore di associazione del sito di chiamata.</param>
      <returns>Nuovo sito di chiamata.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSite`1">
      <summary>Tipo di sito dinamico.</summary>
      <typeparam name="T">Tipo di delegato.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSite`1.Create(System.Runtime.CompilerServices.CallSiteBinder)">
      <summary>Crea un'istanza del sito di chiamata dinamico, inizializzata con il gestore di associazione responsabile per l'associazione di runtime delle operazioni dinamiche in questo sito di chiamata.</summary>
      <param name="binder">Gestore di associazione responsabile per l'associazione di runtime delle operazioni dinamiche in questo sito di chiamata.</param>
      <returns>Nuova istanza del sito di chiamata dinamico.</returns>
    </member>
    <member name="F:System.Runtime.CompilerServices.CallSite`1.Target">
      <summary>Cache di livello 0 - delegato specializzato basato sulla cronologia del sito.</summary>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSite`1.Update">
      <summary>Delegato dell'aggiornamento. Chiamato quando il sito dinamico sperimenta una riga di accesso alla cache non eseguita.</summary>
      <returns>Delegato dell'aggiornamento.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSiteBinder">
      <summary>Classe responsabile per l'associazione di runtime delle operazioni dinamiche sul sito dinamico di chiamata.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.#ctor">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.Bind(System.Object[],System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.LabelTarget)">
      <summary>Esegue l'associazione di runtime dell'operazione dinamica su un set di argomenti.</summary>
      <param name="args">Matrice di argomenti per l'operazione dinamica.</param>
      <param name="parameters">Matrice di istanze <see cref="T:System.Linq.Expressions.ParameterExpression" /> che rappresentano i parametri del sito di chiamata nel processo di associazione.</param>
      <param name="returnLabel">LabelTarget utilizzato per restituire il risultato dell'associazione dinamica.</param>
      <returns>Espressione che esegue test sugli argomenti dell'operazione dinamica ed esegue l'operazione dinamica se i test sono validi. Se i test non riescono su occorrenze successive dell'operazione dinamica, Bind sarà chiamato nuovamente per produrre un nuovo <see cref="T:System.Linq.Expressions.Expression" /> per i nuovi tipi di argomento.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.BindDelegate``1(System.Runtime.CompilerServices.CallSite{``0},System.Object[])">
      <summary>Fornisce supporto dell'associazione di runtime di basso livello. Le classi possono eseguire l'override di questo e fornire un delegato diretto per l'implementazione di regola. Può attivare regole del salvataggio su disco, disponendo di regole specializzate in fase di esecuzione o fornendo diversi criteri di memorizzazione nella cache.</summary>
      <param name="site">CallSite per il quale viene eseguita l'associazione.</param>
      <param name="args">Argomenti per il gestore di associazione.</param>
      <typeparam name="T">Tipo destinazione di CallSite.</typeparam>
      <returns>Nuovo delegato che sostituisce la destinazione di CallSite.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.CacheTarget``1(``0)">
      <summary>Aggiunge una destinazione alla cache di destinazioni note. Le destinazioni memorizzate nella cache saranno analizzate prima di chiamare BindDelegate per produrre la nuova regola.</summary>
      <param name="target">Delegato destinazione da aggiungere alla cache.</param>
      <typeparam name="T">Tipo di destinazione da aggiungere.</typeparam>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSiteBinder.UpdateLabel">
      <summary>Ottiene un'etichetta che può essere utilizzata per determinare l'aggiornamento dell'associazione. Indica che l'associazione dell'espressione non è più valida. Viene in genere utilizzato quando la "versione" di un oggetto dinamico è stata modificata.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> che rappresenta un'etichetta che può essere utilizzata per lanciare l'aggiornamento dell'associazione.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSiteHelpers">
      <summary>Classe che contiene metodi di supporto per DLR CallSites.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteHelpers.IsInternalFrame(System.Reflection.MethodBase)">
      <summary>Controlla se un oggetto <see cref="T:System.Reflection.MethodBase" /> è utilizzato internamente da DLR e non deve essere visualizzato sullo stack del codice del linguaggio.</summary>
      <param name="mb">
        <see cref="T:System.Reflection.MethodBase" /> di input</param>
      <returns>True se un oggetto <see cref="T:System.Reflection.MethodBase" /> di input è utilizzato internamente da DLR e non deve essere visualizzato sullo stack del codice del linguaggio. In caso contrario, false.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.DebugInfoGenerator">
      <summary>Genera informazioni di debug per le espressioni lambda in una struttura a albero dell'espressione.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DebugInfoGenerator.#ctor">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Runtime.CompilerServices.DebugInfoGenerator" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DebugInfoGenerator.CreatePdbGenerator">
      <summary>Crea un generatore di simboli di database (PDB) di programma.</summary>
      <returns>Generatore di simboli PDB.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.DebugInfoGenerator.MarkSequencePoint(System.Linq.Expressions.LambdaExpression,System.Int32,System.Linq.Expressions.DebugInfoExpression)">
      <summary>Contrassegna un punto di sequenza nel codice MSIL (Microsoft Intermediate Language).</summary>
      <param name="method">Espressione lambda generata.</param>
      <param name="ilOffset">Offset all'interno di codice MSIL a livello del quale contrassegnare il punto di sequenza.</param>
      <param name="sequencePoint">Informazioni di debug che corrispondono al punto di sequenza.</param>
    </member>
    <member name="T:System.Runtime.CompilerServices.DynamicAttribute">
      <summary>Indica che è l'utilizzo di <see cref="T:System.Object" /> su un membro va trattato come tipo inviato dinamicamente.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DynamicAttribute.#ctor">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Runtime.CompilerServices.DynamicAttribute" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DynamicAttribute.#ctor(System.Boolean[])">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Runtime.CompilerServices.DynamicAttribute" />.</summary>
      <param name="transformFlags">Specifica, in un prefisso traversal della costruzione di un tipo, quali occorrenze <see cref="T:System.Object" /> vanno trattate come tipo dinamicamente inviato.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.DynamicAttribute.TransformFlags">
      <summary>Specifica, in un prefisso traversal della costruzione di un tipo, quali occorrenze <see cref="T:System.Object" /> vanno trattate come tipo dinamicamente inviato.</summary>
      <returns>Elenco di occorrenze di <see cref="T:System.Object" /> da trattare come tipo inviato dinamicamente.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.IRuntimeVariables">
      <summary>Rappresenta i valori delle variabili di runtime.</summary>
    </member>
    <member name="P:System.Runtime.CompilerServices.IRuntimeVariables.Count">
      <summary>Ottiene un conteggio delle variabili di runtime.</summary>
      <returns>Numero delle variabili di runtime.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.IRuntimeVariables.Item(System.Int32)">
      <summary>Ottiene il valore della variabile di runtime all'indice specificato.</summary>
      <param name="index">Indice in base zero della variabile di runtime il cui valore deve essere restituito.</param>
      <returns>Valore della variabile di runtime.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1">
      <summary>Generatore per raccolta di sola lettura.</summary>
      <typeparam name="T">Tipo dell'elemento della raccolta.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.#ctor">
      <summary>Costruisce un oggetto <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>Costruisce un oggetto <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />, copiando il contenuto della raccolta specificata.</summary>
      <param name="collection">Raccolta da cui copiare gli elementi.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.#ctor(System.Int32)">
      <summary>Costruisce un oggetto <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> con una capacità iniziale specificata. Il contenuto è vuoto ma il generatore avrà riservato spazio per il numero specificato di elementi prima che siano richieste riassegnazioni.</summary>
      <param name="capacity">Capacità iniziale.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Add(`0)">
      <summary>Aggiunge un elemento a <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <param name="item">Oggetto da aggiungere all'oggetto <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Capacity">
      <summary>Ottiene o imposta la capacità di <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <returns>Capacità di questo <c>ReadOnlyCollectionBuilder.</c></returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Clear">
      <summary>Rimuove tutti gli elementi da <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Contains(`0)">
      <summary>Determina se <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> contiene un valore specifico</summary>
      <param name="item">oggetto da individuare nell'oggetto <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
      <returns>true se l'elemento viene trovato nell'oggetto <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />; in caso contrario false.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.CopyTo(`0[],System.Int32)">
      <summary>Copia gli elementi dell'oggetto <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> in un oggetto <see cref="T:System.Array" />, cominciando da un particolare indice <see cref="T:System.Array" />.</summary>
      <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale che rappresenta la destinazione degli elementi copiati dall'oggetto <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
      <param name="arrayIndex">Indice in base zero nella matrice in corrispondenza del quale ha inizio la copia.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Count">
      <summary>Ottiene il numero di elementi in <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <returns>Numero di elementi in <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Interfaccia <see cref="T:System.Collections.Generic.IEnumerator`1" /> che può essere utilizzata per scorrere la raccolta.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.IndexOf(`0)">
      <summary>Restituisce l'indice della prima occorrenza di un determinato valore nel generatore.</summary>
      <param name="item">Elemento da cercare.</param>
      <returns>Indice della prima occorrenza di un elemento.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Insert(System.Int32,`0)">
      <summary>Inserisce un elemento in <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> in corrispondenza dell'indice specificato.</summary>
      <param name="index">Indice in base zero in corrispondenza del quale deve essere inserito l'elemento.</param>
      <param name="item">Oggetto da inserire in <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Item(System.Int32)">
      <summary>Ottiene o imposta l'elemento in corrispondenza dell'indice specificato.</summary>
      <param name="index">Indice in base zero dell'elemento da ottenere o impostare.</param>
      <returns>Elemento in corrispondenza dell'indice specificato.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Remove(`0)">
      <summary>Rimuove la prima occorrenza di un oggetto specifico da <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <param name="item">Oggetto da rimuovere da <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
      <returns>true se l'elemento è stato rimosso correttamente da <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />. In caso contrario, false. Questo metodo restituisce anche falso se l'elemento non viene nell'oggetto <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> originale.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.RemoveAt(System.Int32)">
      <summary>Rimuove l'elemento <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> in corrispondenza dell'indice specificato.</summary>
      <param name="index">Indice in base zero dell'elemento da rimuovere.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Reverse">
      <summary>Inverte l'ordine degli elementi nell'intero <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Reverse(System.Int32,System.Int32)">
      <summary>Inverte l'ordine degli elementi nell'intervallo specificato.</summary>
      <param name="index">Indice iniziale in base zero dell'intervallo da invertire.</param>
      <param name="count">Numero di elementi nell'intervallo da invertire.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
      <summary>Ottiene un valore che indica se <see cref="T:System.Collections.Generic.ICollection`1" /> è di sola lettura.</summary>
      <returns>
        <see langword="true" /> se <see cref="T:System.Collections.Generic.ICollection`1" /> è di sola lettura; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <summary>Copia gli elementi dell'interfaccia <see cref="T:System.Collections.Generic.ICollection`1" /> in una matrice, iniziando dall'indice di matrice specificato.</summary>
      <param name="array">Matrice unidimensionale che rappresenta la destinazione degli elementi copiati dall'oggetto <see cref="T:System.Collections.Generic.ICollection`1" />. La matrice deve avere un'indicizzazione in base zero.</param>
      <param name="index">Indice in base zero in <paramref name="array" /> in corrispondenza del quale viene avviata la copia.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#ICollection#IsSynchronized">
      <summary>Ottiene un valore che indica se l'accesso a <see cref="T:System.Collections.ICollection" /> è sincronizzato (thread-safe).</summary>
      <returns>
        <see langword="true" /> se l'accesso a <see cref="T:System.Collections.ICollection" /> è sincronizzato (thread-safe); in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#ICollection#SyncRoot">
      <summary>Ottiene un oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Collections.ICollection" />.</summary>
      <returns>Oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Collections.ICollection" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Add(System.Object)">
      <summary>Aggiunge un elemento a <see cref="T:System.Collections.IList" />.</summary>
      <param name="value">Oggetto <see cref="T:System.Object" /> da aggiungere a <see cref="T:System.Collections.IList" />.</param>
      <returns>Posizione in cui è stato inserito il nuovo elemento.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Contains(System.Object)">
      <summary>Stabilisce se <see cref="T:System.Collections.IList" /> contiene un valore specifico.</summary>
      <param name="value">Oggetto <see cref="T:System.Object" /> da individuare in <see cref="T:System.Collections.IList" />.</param>
      <returns>
        <see langword="true" /> se <paramref name="item" /> è presente in <see cref="T:System.Collections.IList" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#IndexOf(System.Object)">
      <summary>Determina l'indice di un elemento specifico in <see cref="T:System.Collections.IList" />.</summary>
      <param name="value">Oggetto da individuare nella raccolta <see cref="T:System.Collections.IList" />.</param>
      <returns>Indice di <paramref name="item" />, se presente nell'elenco; in caso contrario, -1.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Insert(System.Int32,System.Object)">
      <summary>Inserisce un elemento in <see cref="T:System.Collections.IList" /> in corrispondenza dell'indice specificato.</summary>
      <param name="index">Indice in base zero nel quale <paramref name="item" /> deve essere inserito.</param>
      <param name="value">Oggetto da inserire in <see cref="T:System.Collections.IList" />.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#IsFixedSize">
      <summary>Ottiene un valore che indica se <see cref="T:System.Collections.IList" /> ha dimensioni fisse.</summary>
      <returns>
        <see langword="true" /> se <see cref="T:System.Collections.IList" /> è di dimensioni fisse; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#IsReadOnly">
      <summary>Ottiene un valore che indica se <see cref="T:System.Collections.IList" /> è di sola lettura.</summary>
      <returns>
        <see langword="true" /> se <see cref="T:System.Collections.IList" /> è di sola lettura; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Item(System.Int32)">
      <summary>Ottiene o imposta l'elemento in corrispondenza dell'indice specificato.</summary>
      <param name="index">Indice in base zero dell'elemento da ottenere o impostare.</param>
      <returns>Elemento in corrispondenza dell'indice specificato.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Remove(System.Object)">
      <summary>Rimuove la prima occorrenza di un oggetto specifico da <see cref="T:System.Collections.IList" />.</summary>
      <param name="value">Oggetto da rimuovere da <see cref="T:System.Collections.IList" />.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.ToArray">
      <summary>Copia gli elementi di <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> in una nuova matrice.</summary>
      <returns>Matrice contenente le copie degli elementi di <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.ToReadOnlyCollection">
      <summary>Crea un oggetto <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> che contiene tutti gli elementi di <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />, evitando di copiare gli elementi nella nuova matrice, se possibile. Reimposta <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> dopo la creazione di <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</summary>
      <returns>Nuova istanza di <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.RuleCache`1">
      <summary>Rappresenta una cache di regole di associazione di runtime.</summary>
      <typeparam name="T">Tipo di delegato.</typeparam>
    </member>
  </members>
</doc>