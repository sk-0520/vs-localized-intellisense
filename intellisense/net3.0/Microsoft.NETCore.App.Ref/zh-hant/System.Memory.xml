<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Memory</name>
  </assembly>
  <members>
    <member name="T:System.Buffers.ArrayBufferWriter`1">
      <summary>代表堆積型的陣列支援輸出接收， <typeparam name="T" /> 可以寫入資料。</summary>
      <typeparam name="T">這個<see cref="T:System.Buffers.ArrayBufferWriter`1" />實例中的專案類型。</typeparam>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.#ctor">
      <summary>建立可寫入資料的 <see cref="T:System.Buffers.ArrayBufferWriter`1" /> 執行個體，具有預設初始容量。</summary>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.#ctor(System.Int32)">
      <summary>建立可寫入資料的 <see cref="T:System.Buffers.ArrayBufferWriter`1" /> 執行個體，具有指定的初始容量。</summary>
      <param name="initialCapacity">用來初始化基礎緩衝區的最小容量。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="initialCapacity" /> 小於或等於 0。</exception>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.Advance(System.Int32)">
      <summary>通知 <see cref="T:System.Buffers.IBufferWriter`1" />，<paramref name="count" /> 項目已寫入輸出 <see cref="T:System.Span`1" />/<see cref="T:System.Memory`1" /></summary>
      <param name="count">寫入的項目數。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="count" /> 為負。</exception>
      <exception cref="T:System.InvalidOperationException">此方法呼叫會嘗試前進超過基礎緩衝區結尾。</exception>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.Capacity">
      <summary>取得基礎緩衝區內的空間總量。</summary>
      <returns>基礎緩衝區的總容量。</returns>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.Clear">
      <summary>清除寫入基礎緩衝區的資料。</summary>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.FreeCapacity">
      <summary>取得可以寫入的可用空間量，而不強制基礎緩衝區成長。</summary>
      <returns>可以寫入的空間, 而不會強制基礎緩衝區成長。</returns>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.GetMemory(System.Int32)">
      <summary>傳回要寫入的 <see cref="T:System.Memory`1" />，至少為 <paramref name="sizeHint" /> 指定的長度。</summary>
      <param name="sizeHint">
        <see cref="T:System.Memory`1" /> 長度的要求下限。</param>
      <returns>長度至少為 <paramref name="sizeHint" /> 的 <see cref="T:System.Memory`1" />。  如不提供 <paramref name="sizeHint" /> 或它等於 0，則傳回一些非空白的緩衝。</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="sizeHint" /> 為負。</exception>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.GetSpan(System.Int32)">
      <summary>傳回要寫入的 <see cref="T:System.Span`1" />，至少為指定的長度。</summary>
      <param name="sizeHint">
        <see cref="T:System.Span`1" /> 長度的要求下限。</param>
      <returns>至少 <paramref name="sizeHint" /> 長度的範圍。 如不提供 <paramref name="sizeHint" /> 或它等於 0，則傳回一些非空白的緩衝。</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="sizeHint" /> 為負。</exception>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenCount">
      <summary>取得寫入基礎緩衝區的資料量。</summary>
      <returns>寫入基礎緩衝區的資料量。</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenMemory">
      <summary>取得 <see cref="T:System.ReadOnlyMemory`1" />，它包含目前已寫入基礎緩衝區的資料。</summary>
      <returns>寫入基礎緩衝區的資料。</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenSpan">
      <summary>取得 <see cref="T:System.ReadOnlySpan`1" />，它包含目前已寫入基礎緩衝區的資料。</summary>
      <returns>寫入基礎緩衝區的資料。</returns>
    </member>
    <member name="T:System.Buffers.Binary.BinaryPrimitives">
      <summary>將位元組視為原始值並使用特定位元組排列方式來讀取。</summary>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>以位元組由大到小的方式，從唯讀位元組範圍的開頭讀取 <see cref="T:System.Int16" />。</summary>
      <param name="source">要讀取的唯讀範圍。</param>
      <returns>位元組排列是由大到小的值。</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> 太小而無法包含 <see cref="T:System.Int16" />。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>以位元組由小到大的方式，從唯讀位元組範圍的開頭讀取 <see cref="T:System.Int16" />。</summary>
      <param name="source">要讀取的唯讀範圍。</param>
      <returns>位元組排列是由小到大的值。</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> 太小而無法包含 <see cref="T:System.Int16" />。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>以位元組由大到小的方式，從唯讀位元組範圍的開頭讀取 <see cref="T:System.Int32" />。</summary>
      <param name="source">要讀取的唯讀範圍。</param>
      <returns>位元組排列是由大到小的值。</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> 太小而無法包含 <see cref="T:System.Int32" />。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>以位元組由小到大的方式，從唯讀位元組範圍的開頭讀取 <see cref="T:System.Int32" />。</summary>
      <param name="source">要讀取的唯讀範圍。</param>
      <returns>位元組排列是由小到大的值。</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> 太小而無法包含 <see cref="T:System.Int32" />。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>以位元組由大到小的方式，從唯讀位元組範圍的開頭讀取 <see cref="T:System.Int64" />。</summary>
      <param name="source">要讀取的唯讀範圍。</param>
      <returns>位元組排列是由大到小的值。</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> 太小而無法包含 <see cref="T:System.Int64" />。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>以位元組由小到大的方式，從唯讀位元組範圍的開頭讀取 <see cref="T:System.Int64" />。</summary>
      <param name="source">要讀取的唯讀範圍。</param>
      <returns>位元組排列是由小到大的值。</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> 太小而無法包含 <see cref="T:System.Int64" />。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>以位元組由大到小的方式，從唯讀位元組範圍的開頭讀取 <see cref="T:System.UInt16" />。</summary>
      <param name="source">要讀取的唯讀範圍。</param>
      <returns>位元組排列是由大到小的值。</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> 太小而無法包含 <see cref="T:System.UInt16" />。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>以位元組由小到大的方式，從唯讀位元組範圍的開頭讀取 <see cref="T:System.UInt16" />。</summary>
      <param name="source">要讀取的唯讀範圍。</param>
      <returns>位元組排列是由小到大的值。</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> 太小而無法包含 <see cref="T:System.UInt16" />。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>以位元組由大到小的方式，從唯讀位元組範圍的開頭讀取 <see cref="T:System.UInt32" />。</summary>
      <param name="source">要讀取的唯讀範圍。</param>
      <returns>位元組排列是由大到小的值。</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> 太小而無法包含 <see cref="T:System.UInt32" />。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>以位元組由小到大的方式，從唯讀位元組範圍的開頭讀取 <see cref="T:System.UInt32" />。</summary>
      <param name="source">要讀取的唯讀位元組範圍。</param>
      <returns>位元組排列是由小到大的值。</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> 太小而無法包含 <see cref="T:System.UInt32" />。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>以位元組由大到小的方式，從唯讀位元組範圍的開頭讀取 <see cref="T:System.UInt64" />。</summary>
      <param name="source">要讀取的唯讀位元組範圍。</param>
      <returns>位元組排列是由大到小的值。</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> 太小而無法包含 <see cref="T:System.UInt64" />。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>以位元組由小到大的方式，從唯讀位元組範圍的開頭讀取 <see cref="T:System.UInt64" />。</summary>
      <param name="source">要讀取的唯讀位元組範圍。</param>
      <returns>位元組排列是由小到大的值。</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> 太小而無法包含 <see cref="T:System.UInt64" />。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Byte)">
      <summary>藉由對指定的 <see cref="T:System.Byte" /> 值執行位元組排列方式交換，來反轉原始值，這對 <see cref="T:System.Byte" /> 沒有影響。</summary>
      <param name="value">要反轉的值。</param>
      <returns>傳入值 (未修改)。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int16)">
      <summary>藉由對指定的 <see cref="T:System.Int16" /> 值執行位元組排列方式交換，來反轉原始值。</summary>
      <param name="value">要反轉的值。</param>
      <returns>已反轉的值。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int32)">
      <summary>藉由對指定的 <see cref="T:System.Int32" /> 值執行位元組排列方式交換，來反轉原始值。</summary>
      <param name="value">要反轉的值。</param>
      <returns>已反轉的值。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int64)">
      <summary>藉由對指定的 <see cref="T:System.Int64" /> 值執行位元組排列方式交換，來反轉原始值。</summary>
      <param name="value">要反轉的值。</param>
      <returns>已反轉的值。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.SByte)">
      <summary>藉由對指定的 <see cref="T:System.SByte" /> 值執行位元組排列方式交換，來反轉原始值，這對 <see cref="T:System.SByte" /> 沒有影響。</summary>
      <param name="value">要反轉的值。</param>
      <returns>傳入值 (未修改)。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt16)">
      <summary>藉由對指定的 <see cref="T:System.UInt16" /> 值執行位元組排列方式交換，來反轉原始值。</summary>
      <param name="value">要反轉的值。</param>
      <returns>已反轉的值。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt32)">
      <summary>藉由對指定的 <see cref="T:System.UInt32" /> 值執行位元組排列方式交換，來反轉原始值。</summary>
      <param name="value">要反轉的值。</param>
      <returns>已反轉的值。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt64)">
      <summary>藉由對指定的 <see cref="T:System.UInt64" /> 值執行位元組排列方式交換，來反轉原始值。</summary>
      <param name="value">要反轉的值。</param>
      <returns>已反轉的值。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16BigEndian(System.ReadOnlySpan{System.Byte},System.Int16@)">
      <summary>以位元組由大到小的方式，從唯讀位元組範圍的開頭讀取 <see cref="T:System.Int16" />。</summary>
      <param name="source">要讀取的唯讀位元組範圍。</param>
      <param name="value">當此方法傳回時，會以位元組由大到小的方式，從位元組唯讀範圍讀取值。</param>
      <returns>如果範圍夠大而足以包含 <see cref="T:System.Int16" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.Int16@)">
      <summary>以位元組由小到大的方式，從唯讀位元組範圍的開頭讀取 <see cref="T:System.Int16" />。</summary>
      <param name="source">要讀取的唯讀位元組範圍。</param>
      <param name="value">當此方法傳回時，會以位元組由小到大的方式，從位元組唯讀範圍讀取值。</param>
      <returns>如果範圍夠大而足以包含 <see cref="T:System.Int16" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32BigEndian(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>以位元組由大到小的方式，從唯讀位元組範圍的開頭讀取 <see cref="T:System.Int32" />。</summary>
      <param name="source">要讀取的唯讀位元組範圍。</param>
      <param name="value">當此方法傳回時，會以位元組由大到小的方式，從位元組唯讀範圍讀取值。</param>
      <returns>如果範圍夠大而足以包含 <see cref="T:System.Int32" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>以位元組由小到大的方式，從唯讀位元組範圍的開頭讀取 <see cref="T:System.Int32" />。</summary>
      <param name="source">要讀取的唯讀位元組範圍。</param>
      <param name="value">當此方法傳回時，會以位元組由小到大的方式，從位元組唯讀範圍讀取值。</param>
      <returns>如果範圍夠大而足以包含 <see cref="T:System.Int32" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64BigEndian(System.ReadOnlySpan{System.Byte},System.Int64@)">
      <summary>以位元組由大到小的方式，從唯讀位元組範圍的開頭讀取 <see cref="T:System.Int64" />。</summary>
      <param name="source">要讀取的唯讀位元組範圍。</param>
      <param name="value">當此方法傳回時，會以位元組由大到小的方式，從位元組唯讀範圍讀取值。</param>
      <returns>如果範圍夠大而足以包含 <see cref="T:System.Int64" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.Int64@)">
      <summary>以位元組由小到大的方式，從唯讀位元組範圍的開頭讀取 <see cref="T:System.Int64" />。</summary>
      <param name="source">要讀取的唯讀位元組範圍。</param>
      <param name="value">當此方法傳回時，會以位元組由小到大的方式，從位元組唯讀範圍讀取值。</param>
      <returns>如果範圍夠大而足以包含 <see cref="T:System.Int64" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16BigEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)">
      <summary>以位元組由大到小的方式，從唯讀位元組範圍的開頭讀取 <see cref="T:System.UInt16" />。</summary>
      <param name="source">要讀取的唯讀位元組範圍。</param>
      <param name="value">當此方法傳回時，會以位元組由大到小的方式，從位元組唯讀範圍讀取值。</param>
      <returns>如果範圍夠大而足以包含 <see cref="T:System.UInt16" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)">
      <summary>以位元組由小到大的方式，從唯讀位元組範圍的開頭讀取 <see cref="T:System.UInt16" />。</summary>
      <param name="source">要讀取的唯讀位元組範圍。</param>
      <param name="value">當此方法傳回時，會以位元組由小到大的方式，從位元組唯讀範圍讀取值。</param>
      <returns>如果範圍夠大而足以包含 <see cref="T:System.UInt16" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32BigEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)">
      <summary>以位元組由大到小的方式，從唯讀位元組範圍的開頭讀取 <see cref="T:System.UInt32" />。</summary>
      <param name="source">要讀取的唯讀位元組範圍。</param>
      <param name="value">當此方法傳回時，會以位元組由大到小的方式，從位元組唯讀範圍讀取值。</param>
      <returns>如果範圍夠大而足以包含 <see cref="T:System.UInt32" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)">
      <summary>以位元組由小到大的方式，從唯讀位元組範圍的開頭讀取 <see cref="T:System.UInt32" />。</summary>
      <param name="source">要讀取的唯讀位元組範圍。</param>
      <param name="value">當此方法傳回時，會以位元組由小到大的方式，從位元組唯讀範圍讀取值。</param>
      <returns>如果範圍夠大而足以包含 <see cref="T:System.UInt32" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64BigEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)">
      <summary>以位元組由大到小的方式，從唯讀位元組範圍的開頭讀取 <see cref="T:System.UInt64" />。</summary>
      <param name="source">要讀取的唯讀位元組範圍。</param>
      <param name="value">當此方法傳回時，會以位元組由大到小的方式，從位元組唯讀範圍讀取值。</param>
      <returns>如果範圍夠大而足以包含 <see cref="T:System.UInt64" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)">
      <summary>以位元組由小到大的方式，從唯讀位元組範圍的開頭讀取 <see cref="T:System.UInt64" />。</summary>
      <param name="source">要讀取的唯讀位元組範圍。</param>
      <param name="value">當此方法傳回時，會以位元組由小到大的方式，從位元組唯讀範圍讀取值。</param>
      <returns>如果範圍夠大而足以包含 <see cref="T:System.UInt64" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16BigEndian(System.Span{System.Byte},System.Int16)">
      <summary>以位元組由大到小的方式，將 <see cref="T:System.Int16" /> 寫入位元組範圍。</summary>
      <param name="destination">位元組範圍，要以位元組由大到小的方式將值寫入其中。</param>
      <param name="value">要寫入位元組範圍的值。</param>
      <returns>如果範圍夠大而足以包含 <see cref="T:System.Int16" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16LittleEndian(System.Span{System.Byte},System.Int16)">
      <summary>以位元組由小到大的方式，將 <see cref="T:System.Int16" /> 寫入位元組範圍。</summary>
      <param name="destination">位元組範圍，要以位元組由小到大的方式將值寫入其中。</param>
      <param name="value">要寫入位元組範圍的值。</param>
      <returns>如果範圍夠大而足以包含 <see cref="T:System.Int16" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32BigEndian(System.Span{System.Byte},System.Int32)">
      <summary>以位元組由大到小的方式，將 <see cref="T:System.Int32" /> 寫入位元組範圍。</summary>
      <param name="destination">位元組範圍，要以位元組由大到小的方式將值寫入其中。</param>
      <param name="value">要寫入位元組範圍的值。</param>
      <returns>如果範圍夠大而足以包含 <see cref="T:System.Int32" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32LittleEndian(System.Span{System.Byte},System.Int32)">
      <summary>以位元組由小到大的方式，將 <see cref="T:System.Int32" /> 寫入位元組範圍。</summary>
      <param name="destination">位元組範圍，要以位元組由小到大的方式將值寫入其中。</param>
      <param name="value">要寫入位元組範圍的值。</param>
      <returns>如果範圍夠大而足以包含 <see cref="T:System.Int32" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64BigEndian(System.Span{System.Byte},System.Int64)">
      <summary>以位元組由大到小的方式，將 <see cref="T:System.Int64" /> 寫入位元組範圍。</summary>
      <param name="destination">位元組範圍，要以位元組由大到小的方式將值寫入其中。</param>
      <param name="value">要寫入位元組範圍的值。</param>
      <returns>如果範圍夠大而足以包含 <see cref="T:System.Int64" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64LittleEndian(System.Span{System.Byte},System.Int64)">
      <summary>以位元組由小到大的方式，將 <see cref="T:System.Int64" /> 寫入位元組範圍。</summary>
      <param name="destination">位元組範圍，要以位元組由小到大的方式將值寫入其中。</param>
      <param name="value">要寫入位元組範圍的值。</param>
      <returns>如果範圍夠大而足以包含 <see cref="T:System.Int64" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)">
      <summary>以位元組由大到小的方式，將 <see cref="T:System.UInt16" /> 寫入位元組範圍。</summary>
      <param name="destination">位元組範圍，要以位元組由大到小的方式將值寫入其中。</param>
      <param name="value">要寫入位元組範圍的值。</param>
      <returns>如果範圍夠大而足以包含 <see cref="T:System.UInt16" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)">
      <summary>以位元組由小到大的方式，將 <see cref="T:System.UInt16" /> 寫入位元組範圍。</summary>
      <param name="destination">位元組範圍，要以位元組由小到大的方式將值寫入其中。</param>
      <param name="value">要寫入位元組範圍的值。</param>
      <returns>如果範圍夠大而足以包含 <see cref="T:System.UInt16" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)">
      <summary>以位元組由大到小的方式，將 <see cref="T:System.UInt32" /> 寫入位元組範圍。</summary>
      <param name="destination">位元組範圍，要以位元組由大到小的方式將值寫入其中。</param>
      <param name="value">要寫入位元組範圍的值。</param>
      <returns>如果範圍夠大而足以包含 <see cref="T:System.UInt32" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)">
      <summary>以位元組由小到大的方式，將 <see cref="T:System.UInt32" /> 寫入位元組範圍。</summary>
      <param name="destination">位元組範圍，要以位元組由小到大的方式將值寫入其中。</param>
      <param name="value">要寫入位元組範圍的值。</param>
      <returns>如果範圍夠大而足以包含 <see cref="T:System.UInt32" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)">
      <summary>以位元組由大到小的方式，將 <see cref="T:System.UInt64" /> 寫入位元組範圍。</summary>
      <param name="destination">位元組範圍，要以位元組由大到小的方式將值寫入其中。</param>
      <param name="value">要寫入位元組範圍的值。</param>
      <returns>如果範圍夠大而足以包含 <see cref="T:System.UInt64" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)">
      <summary>以位元組由小到大的方式，將 <see cref="T:System.UInt64" /> 寫入位元組範圍。</summary>
      <param name="destination">位元組範圍，要以位元組由小到大的方式將值寫入其中。</param>
      <param name="value">要寫入位元組範圍的值。</param>
      <returns>如果範圍夠大而足以包含 <see cref="T:System.UInt64" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16BigEndian(System.Span{System.Byte},System.Int16)">
      <summary>以位元組由大到小的方式，將 <see cref="T:System.Int16" /> 寫入位元組範圍。</summary>
      <param name="destination">位元組範圍，要以位元組由大到小的方式將值寫入其中。</param>
      <param name="value">要寫入位元組範圍的值。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> 太小而無法包含 <see cref="T:System.Int16" />。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16LittleEndian(System.Span{System.Byte},System.Int16)">
      <summary>以位元組由小到大的方式，將 <see cref="T:System.Int16" /> 寫入位元組範圍。</summary>
      <param name="destination">位元組範圍，要以位元組由小到大的方式將值寫入其中。</param>
      <param name="value">要寫入位元組範圍的值。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> 太小而無法包含 <see cref="T:System.Int16" />。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32BigEndian(System.Span{System.Byte},System.Int32)">
      <summary>以位元組由大到小的方式，將 <see cref="T:System.Int32" /> 寫入位元組範圍。</summary>
      <param name="destination">位元組範圍，要以位元組由大到小的方式將值寫入其中。</param>
      <param name="value">要寫入位元組範圍的值。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> 太小而無法包含 <see cref="T:System.Int32" />。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32LittleEndian(System.Span{System.Byte},System.Int32)">
      <summary>以位元組由小到大的方式，將 <see cref="T:System.Int32" /> 寫入位元組範圍。</summary>
      <param name="destination">位元組範圍，要以位元組由小到大的方式將值寫入其中。</param>
      <param name="value">要寫入位元組範圍的值。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> 太小而無法包含 <see cref="T:System.Int32" />。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64BigEndian(System.Span{System.Byte},System.Int64)">
      <summary>以位元組由大到小的方式，將 <see cref="T:System.Int64" /> 寫入位元組範圍。</summary>
      <param name="destination">位元組範圍，要以位元組由大到小的方式將值寫入其中。</param>
      <param name="value">要寫入位元組範圍的值。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> 太小而無法包含 <see cref="T:System.Int64" />。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64LittleEndian(System.Span{System.Byte},System.Int64)">
      <summary>以位元組由小到大的方式，將 <see cref="T:System.Int64" /> 寫入位元組範圍。</summary>
      <param name="destination">位元組範圍，要以位元組由小到大的方式將值寫入其中。</param>
      <param name="value">要寫入位元組範圍的值。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> 太小而無法包含 <see cref="T:System.Int64" />。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)">
      <summary>以位元組由大到小的方式，將 <see cref="T:System.UInt16" /> 寫入位元組範圍。</summary>
      <param name="destination">位元組範圍，要以位元組由大到小的方式將值寫入其中。</param>
      <param name="value">要寫入位元組範圍的值。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> 太小而無法包含 <see cref="T:System.UInt16" />。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)">
      <summary>以位元組由小到大的方式，將 <see cref="T:System.UInt16" /> 寫入位元組範圍。</summary>
      <param name="destination">位元組範圍，要以位元組由小到大的方式將值寫入其中。</param>
      <param name="value">要寫入位元組範圍的值。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> 太小而無法包含 <see cref="T:System.UInt16" />。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)">
      <summary>以位元組由大到小的方式，將 <see cref="T:System.UInt32" /> 寫入位元組範圍。</summary>
      <param name="destination">位元組範圍，要以位元組由大到小的方式將值寫入其中。</param>
      <param name="value">要寫入位元組範圍的值。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> 太小而無法包含 <see cref="T:System.UInt32" />。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)">
      <summary>以位元組由小到大的方式，將 <see cref="T:System.UInt32" /> 寫入位元組範圍。</summary>
      <param name="destination">位元組範圍，要以位元組由小到大的方式將值寫入其中。</param>
      <param name="value">要寫入位元組範圍的值。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> 太小而無法包含 <see cref="T:System.UInt32" />。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)">
      <summary>以位元組由大到小的方式，將 <see cref="T:System.UInt64" /> 寫入位元組範圍。</summary>
      <param name="destination">位元組範圍，要以位元組由大到小的方式將值寫入其中。</param>
      <param name="value">要寫入位元組範圍的值。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> 太小而無法包含 <see cref="T:System.UInt64" />。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)">
      <summary>以位元組由小到大的方式，將 <see cref="T:System.UInt64" /> 寫入位元組範圍。</summary>
      <param name="destination">位元組範圍，要以位元組由小到大的方式將值寫入其中。</param>
      <param name="value">要寫入位元組範圍的值。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> 太小而無法包含 <see cref="T:System.UInt64" />。</exception>
    </member>
    <member name="T:System.Buffers.BuffersExtensions">
      <summary>提供 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 的擴充方法。</summary>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.CopyTo``1(System.Buffers.ReadOnlySequence{``0},System.Span{``0})">
      <summary>將 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 複製到指定的 <see cref="T:System.Span`1" />。</summary>
      <param name="source">來源 <see cref="T:System.Buffers.ReadOnlySequence`1" />。</param>
      <param name="destination">目的 <see cref="T:System.Span`1" />。</param>
      <typeparam name="T">中的專案類型<see cref="T:System.Buffers.ReadOnlySequence`1" />。</typeparam>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.PositionOf``1(System.Buffers.ReadOnlySequence{``0},``0)">
      <summary>傳回 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 中出現第一個 <paramref name="item" /> 的位置。</summary>
      <param name="source">來源 <see cref="T:System.Buffers.ReadOnlySequence`1" />。</param>
      <param name="value">用來在 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 中尋找的項目。</param>
      <typeparam name="T">中的專案類型<see cref="T:System.Buffers.ReadOnlySequence`1" />。</typeparam>
      <returns>其 <see cref="M:System.SequencePosition.GetInteger" /> 方法會傳回 <paramref name="item" /> 第一個出現位置的物件，或其 <see langword="Nullable&lt;SequencePosition&gt;.HasValue" /> 屬性為 <see langword="false" /> 的物件。</returns>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.ToArray``1(System.Buffers.ReadOnlySequence{``0})">
      <summary>將 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 轉換成陣列。</summary>
      <param name="sequence">要轉換為陣列的唯讀序列。</param>
      <typeparam name="T">中的專案類型<see cref="T:System.Buffers.ReadOnlySequence`1" />。</typeparam>
      <returns>陣列，其中包含目前唯讀序列中的資料。</returns>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.Write``1(System.Buffers.IBufferWriter{``0},System.ReadOnlySpan{``0})">
      <summary>將 <paramref name="value" /> 的內容寫入至 <paramref name="writer" />。</summary>
      <param name="writer">要將 <paramref name="value" /> 寫入至其中的緩衝區寫入器。</param>
      <param name="value">要寫入至 <paramref name="writer" /> 的唯讀範圍。</param>
      <typeparam name="T">中的專案類型<see cref="T:System.ReadOnlySpan`1" />。</typeparam>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="writer" /> 短於 <paramref name="value" />。</exception>
    </member>
    <member name="T:System.Buffers.IBufferWriter`1">
      <summary>代表可在其中寫入 <typeparamref name="T" /> 資料的輸出接收。</summary>
      <typeparam name="T">中的專案類型<see cref="T:System.Buffers.IBufferWriter`1" />。</typeparam>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.Advance(System.Int32)">
      <summary>通知 <see cref="T:System.Buffers.IBufferWriter`1" />，<paramref name="count" /> 資料項目已寫入到輸出 <see cref="T:System.Span`1" /> 或 <see cref="T:System.Memory`1" />。</summary>
      <param name="count">寫入 <see cref="T:System.Span`1" /> 或 <see cref="T:System.Memory`1" /> 的資料項目數。</param>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.GetMemory(System.Int32)">
      <summary>傳回 <see cref="T:System.Memory`1" /> 以寫入到至少為要求大小 (由 <paramref name="sizeHint" />指定) 的資料。</summary>
      <param name="sizeHint">所傳回 <see cref="T:System.Memory`1" /> 的長度下限。 若為 0，則會傳回非空的緩衝區。</param>
      <returns>大小至少為 <paramref name="sizeHint" /> 的 <see cref="T:System.Memory`1" />。 若 <paramref name="sizeHint" /> 為 0，則會傳回非空緩衝區。</returns>
      <exception cref="T:System.OutOfMemoryException">要求的緩衝區大小無法使用。</exception>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)">
      <summary>傳回 <see cref="T:System.Span`1" /> 以寫入到至少為要求大小 (由 <paramref name="sizeHint" />指定) 的資料。</summary>
      <param name="sizeHint">所傳回 <see cref="T:System.Span`1" /> 的長度下限。 若為 0，則會傳回非空的緩衝區。</param>
      <returns>大小至少為 <paramref name="sizeHint" /> 的 <see cref="T:System.Span`1" />。 若 <paramref name="sizeHint" /> 為 0，則會傳回非空緩衝區。</returns>
    </member>
    <member name="T:System.Buffers.MemoryPool`1">
      <summary>表示記憶體區塊的集區。</summary>
      <typeparam name="T">記憶體集區中的專案類型。</typeparam>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.#ctor">
      <summary>建構記憶體集區的新執行個體。</summary>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Dispose">
      <summary>釋出記憶體集區所使用的全部資源。</summary>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Dispose(System.Boolean)">
      <summary>釋出記憶體集區所使用的 Unmanaged 資源，並選擇性釋放 Managed 資源。</summary>
      <param name="disposing">
        <see langword="true" /> 表示釋放 Managed 和 Unmanaged 資源， 則表示只釋放 Unmanaged 資源。</param>
    </member>
    <member name="P:System.Buffers.MemoryPool`1.MaxBufferSize">
      <summary>取得此集區所支援的最大緩衝區大小。</summary>
      <returns>此集區所支援的緩衝區大小上限。</returns>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Rent(System.Int32)">
      <summary>傳回可以保留至少 <paramref name="minBufferSize" /> 個 T 元素的記憶體區塊。</summary>
      <param name="minBufferSize">記憶體集區可以保存的 <typeparamref name="T" /> 元素數目下限。 值 -1 會傳回設為集區預設大小的記憶體集區。</param>
      <returns>可以保留至少 <paramref name="minBufferSize" /> 個 T 元素的記憶體區塊。</returns>
    </member>
    <member name="P:System.Buffers.MemoryPool`1.Shared">
      <summary>根據陣列，取得記憶體集區的單一執行個體。</summary>
      <returns>記憶體集區的單一實例。</returns>
    </member>
    <member name="T:System.Buffers.OperationStatus">
      <summary>定義可以從範圍型作業傳回的值，這些作業支援處理多個不連續緩衝區中包含的輸入。</summary>
    </member>
    <member name="F:System.Buffers.OperationStatus.DestinationTooSmall">
      <summary>輸入會經過部分處理，最多到可納入目的地緩衝區的程度。 呼叫者可以放大目的地緩衝區、適當地分割緩衝區，然後重試。</summary>
    </member>
    <member name="F:System.Buffers.OperationStatus.Done">
      <summary>整個輸入緩衝區已經過處理，而且此作業已完成。</summary>
    </member>
    <member name="F:System.Buffers.OperationStatus.InvalidData">
      <summary>輸入包含無法處理的無效位元組。 如果輸入已經過部分處理，目的地會包含部分結果。 如此可保證，附加至輸入的其他任何資料都不會使無效的序列變成有效。</summary>
    </member>
    <member name="F:System.Buffers.OperationStatus.NeedMoreData">
      <summary>輸入經過部分處理，最多到可使用之輸入的最後一個有效區塊。 呼叫者可以將剩餘未處理的輸入與其他資料拼接在一起、適當地分割緩衝區，然後重試。</summary>
    </member>
    <member name="T:System.Buffers.ReadOnlySequence`1">
      <summary>代表可讀取 <typeparamref name="T" /> 循序序列的序列。</summary>
      <typeparam name="T" />
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[])">
      <summary>從 <paramref name="array" /> 建立 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 的執行個體。</summary>
      <param name="array">要從中建立唯讀序列的陣列。</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[],System.Int32,System.Int32)">
      <summary>從陣列區段建立 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 的執行個體。</summary>
      <param name="array">要從中建立唯讀序列的陣列。</param>
      <param name="start">要包含在唯讀序列中之陣列第一個元素以零為起始的索引。</param>
      <param name="length">要包含在唯讀序列中元素的數目。</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.Buffers.ReadOnlySequenceSegment{`0},System.Int32,System.Buffers.ReadOnlySequenceSegment{`0},System.Int32)">
      <summary>從開始和結束區段及其中對應索引所表示的連結記憶體清單，建立 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 的執行個體。</summary>
      <param name="startSegment" />
      <param name="startIndex" />
      <param name="endSegment" />
      <param name="endIndex" />
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.ReadOnlyMemory{`0})">
      <summary>從 <see cref="T:System.ReadOnlyMemory`1" /> 建立 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 的執行個體。</summary>
      <param name="memory" />
    </member>
    <member name="F:System.Buffers.ReadOnlySequence`1.Empty">
      <summary>傳回空的 <see cref="T:System.Buffers.ReadOnlySequence`1" /></summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.End">
      <summary>取得 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 結尾的位置。</summary>
    </member>
    <member name="T:System.Buffers.ReadOnlySequence`1.Enumerator">
      <summary>透過 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 表示列舉程式。</summary>
      <typeparam name="T" />
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.#ctor(System.Buffers.ReadOnlySequence{`0}@)">
      <summary>初始化列舉程式。</summary>
      <param name="sequence">要列舉的 <see cref="T:System.Buffers.ReadOnlySequence`1" />。</param>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Enumerator.Current">
      <summary>取得目前的 <see cref="T:System.ReadOnlyMemory`1" />。</summary>
      <returns>目前的 <see cref="T:System.ReadOnlyMemory`1" />。</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.MoveNext">
      <summary>移至 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 中的下一個 <see cref="T:System.ReadOnlyMemory`1" />。</summary>
      <returns>如果列舉值成功前移至下一個項目，則為 <see langword="true" />；如果已到達序列結尾，則為 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.First">
      <summary>從第一個區段取得 <see cref="T:System.ReadOnlyMemory`1" />。</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.FirstSpan">
      <summary>從第一個區段取得 <see cref="T:System.ReadOnlySpan`1" />。</summary>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetEnumerator">
      <summary>透過 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 傳回列舉值。</summary>
      <returns>透過 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 傳回列舉值。</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64)">
      <summary>從序列開頭傳回 <paramref name="offset" /> 的新 <see cref="T:System.SequencePosition" />。</summary>
      <param name="offset" />
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64,System.SequencePosition)">
      <summary>從 <paramref name="origin" /> 傳回 <paramref name="offset" /> 的新 <see cref="T:System.SequencePosition" />。</summary>
      <param name="offset" />
      <param name="origin" />
      <returns>從原始物件 <paramref name="offset" /> 位置開始的新物件。</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.IsEmpty">
      <summary>取得值，這個值指出 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 是否是空的。</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.IsSingleSegment">
      <summary>取得值，指出 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 是否包含單一 <see cref="T:System.ReadOnlyMemory`1" /> 區段。</summary>
      <returns>
        <see langword="true" />如果唯讀順序是空的, 則為,否則為<see langword="false" />。</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Length">
      <summary>取得 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 的長度。</summary>
      <returns>唯讀序列的長度。</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.Int32)">
      <summary>從目前的 <see cref="T:System.Buffers.ReadOnlySequence`1" /> (從 <paramref name="start" /> 開始，包含 <paramref name="length" /> 個項目) 形成配量。</summary>
      <param name="start">要開始此配量的索引。</param>
      <param name="length">配量的長度。</param>
      <returns>由 <paramref name="length" /> 元素組成的配量 (從索引 <paramref name="start" /> 開始的目前執行個體)。</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.SequencePosition)">
      <summary>從目前的 <see cref="T:System.Buffers.ReadOnlySequence`1" /> (從 <paramref name="start" /> 開始，到 <paramref name="end" /> (不含) 結束) 形成配量。</summary>
      <param name="start">要開始此配量的索引。</param>
      <param name="end">配量的結尾 (不含) <see cref="T:System.SequencePosition" />。</param>
      <returns>配量組成項目從 <paramref name="start" /> 索引到目前唯讀序列中的 <paramref name="end" /> (不含) 序列位置。</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64)">
      <summary>從目前的 <see cref="T:System.Buffers.ReadOnlySequence`1" /> (從指定的索引開始，一直到唯讀序列的結尾) 形成配量。</summary>
      <param name="start">要開始此配量的起始索引。</param>
      <returns>配量從索引 <paramref name="start" /> 開始，且一直到目前唯讀序列的結尾。</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.Int64)">
      <summary>從給定的 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 形成配量 (從 <paramref name="start" /> 開始，包含 <paramref name="length" /> 個項目)。</summary>
      <param name="start">要開始此配量的索引。</param>
      <param name="length">配量的長度。</param>
      <returns>由 <paramref name="length" /> 元素組成的配量 (從索引 <paramref name="start" /> 開始的目前執行個體)。</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.SequencePosition)">
      <summary>從目前的 <see cref="T:System.Buffers.ReadOnlySequence`1" /> (從 <paramref name="start" /> 開始，到 <paramref name="end" /> (不含) 結束) 形成配量。</summary>
      <param name="start">要開始此配量的索引。</param>
      <param name="end">配量的結尾 (不含)。</param>
      <returns>配量組成項目從 <paramref name="start" /> 索引到目前唯讀序列中的 <paramref name="end" /> (不含) 序列位置。</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition)">
      <summary>從目前的 <see cref="T:System.Buffers.ReadOnlySequence`1" /> (從指定的序列位置開始，一直到唯讀序列的結尾) 形成配量。</summary>
      <param name="start">要開始此配量的起始 (含) <see cref="T:System.SequencePosition" />。</param>
      <returns>配量從序列位置 <paramref name="start" /> 開始，且一直到目前唯讀序列的結尾。</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int32)">
      <summary>從目前的 <see cref="T:System.Buffers.ReadOnlySequence`1" /> (從 <paramref name="start" /> 開始，包含 <paramref name="length" /> 個項目) 形成配量。</summary>
      <param name="start">要開始此配量的起始 (含) <see cref="T:System.SequencePosition" />。</param>
      <param name="length">配量的長度。</param>
      <returns>由目前執行個體的 <paramref name="length" /> 個項目組成的配量，從序列位置 <paramref name="start" /> 開始。</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int64)">
      <summary>從目前的 <see cref="T:System.Buffers.ReadOnlySequence`1" /> (從 <paramref name="start" /> 開始，包含 <paramref name="length" /> 個項目) 形成配量。</summary>
      <param name="start">要開始此配量的起始 (含) <see cref="T:System.SequencePosition" />。</param>
      <param name="length">配量的長度。</param>
      <returns>由目前執行個體的 <paramref name="length" /> 個項目組成的配量，從序列位置 <paramref name="start" /> 開始。</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.SequencePosition)">
      <summary>從目前的 <see cref="T:System.Buffers.ReadOnlySequence`1" /> (從 <paramref name="start" /> 開始，到 <paramref name="end" /> (不含) 結束) 形成配量。</summary>
      <param name="start">要開始此配量的起始 (含) <see cref="T:System.SequencePosition" />。</param>
      <param name="end">配量的結尾 (不含) <see cref="T:System.SequencePosition" />。</param>
      <returns>由項目組成的配量，從 <paramref name="start" /> 序列位置到目前唯讀序列中的 <paramref name="end" /> (不含) 序列位置。</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Start">
      <summary>取得 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 開頭的位置。</summary>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.ToString" />
    <member name="M:System.Buffers.ReadOnlySequence`1.TryGet(System.SequencePosition@,System.ReadOnlyMemory{`0}@,System.Boolean)">
      <summary>嘗試擷取 <paramref name="position" /> 之後的下一個區段，並傳回指出作業是否成功的值。</summary>
      <param name="position">目前的序列位置。</param>
      <param name="memory">包含 <paramref name="position" /> 之後的下一個區段的唯讀記憶體範圍。</param>
      <param name="advance">如果 <paramref name="position" /> 應該到下一個區段的開頭，則為 <see langword="true" />，否則為 <see langword="false" />。</param>
      <returns>如果方法傳回下一個區段，傳回 <see langword="true" />；如果已到達唯讀序列的結尾，則為 <see langword="false" />。</returns>
    </member>
    <member name="T:System.Buffers.ReadOnlySequenceSegment`1">
      <summary>代表 <see cref="T:System.ReadOnlyMemory`1" /> 節點的連結清單。</summary>
      <typeparam name="T" />
    </member>
    <member name="M:System.Buffers.ReadOnlySequenceSegment`1.#ctor" />
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Memory">
      <summary>取得或設定目前節點的 <see cref="T:System.ReadOnlyMemory`1" /> 值。</summary>
      <returns>目前節點的值。 <see cref="T:System.ReadOnlyMemory`1" /></returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Next">
      <summary>取得或設定下一個節點。</summary>
      <returns>下一個節點。</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.RunningIndex">
      <summary>取得或設定目前節點之前的節點長度總和。</summary>
      <returns>節點長度與目前節點的總和。</returns>
    </member>
    <member name="T:System.Buffers.SequenceReader`1">
      <summary>提供用來從 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 讀取二進位資料和文字資料的方法，並著重於效能以及為最小或零的堆積配置。</summary>
      <typeparam name="T">唯讀序列的類型。</typeparam>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.#ctor(System.Buffers.ReadOnlySequence{`0})">
      <summary>在指定的 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 上建立 <see cref="T:System.Buffers.SequenceReader`1" />。</summary>
      <param name="sequence">要建立 <see cref="T:System.Buffers.SequenceReader`1" /> 的唯讀序列。</param>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.Advance(System.Int64)">
      <summary>依指定的項目數將讀取器向前移。</summary>
      <param name="count">要前進的項目數量。</param>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePast(`0)">
      <summary>前進超過指定的 <paramref name="value" /> 個連續執行個體。</summary>
      <param name="value">超過此值，讀取器就會前進。</param>
      <returns>讀取器已前進的位置數。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0)">
      <summary>前進超過兩個指定值之一的連續執行個體。</summary>
      <param name="value0">要跳過的第一個值。</param>
      <param name="value1">要跳過的第二個值。</param>
      <returns>讀取器已前進的位置數。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0)">
      <summary>前進超過三個指定值之一的連續執行個體。</summary>
      <param name="value0">要跳過的第一個值。</param>
      <param name="value1">要跳過的第二個值。</param>
      <param name="value2">要跳過的第三個值。</param>
      <returns>讀取器已前進的位置數。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0,`0)">
      <summary>前進超過四個指定值之一的連續執行個體。</summary>
      <param name="value0">要跳過的第一個值。</param>
      <param name="value1">要跳過的第二個值。</param>
      <param name="value2">要跳過的第三個值。</param>
      <param name="value3">要跳過的第四個值。</param>
      <returns>讀取器已前進的位置數。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(System.ReadOnlySpan{`0})">
      <summary>跳過任何指定的 <paramref name="values" /> 個連續執行個體。</summary>
      <param name="values">要跳過的值。</param>
      <returns>讀取器已前進的位置數。</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Consumed">
      <summary>取得讀取器所處理的 <typeparamref name="T" /> 值總數。</summary>
      <returns>讀取器處理的值總數。</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.CurrentSpan">
      <summary>取得 <see cref="T:System.Span`1" />，其在 <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> 中包含目前的區段。</summary>
      <returns>包含序列中目前區段的範圍。</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.CurrentSpanIndex">
      <summary>取得 <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> 中的索引。</summary>
      <returns>中的索引<see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />。</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.End">
      <summary>取得值，指出 <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> 是否不再有任何資料。</summary>
      <returns>
        <see langword="true" />當中<see cref="P:System.Buffers.SequenceReader`1.Sequence" />沒有其他資料時, 則為, <see langword="false" />否則為。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.IsNext(`0,System.Boolean)">
      <summary>檢查所指定值是否為序列中的下一個。</summary>
      <param name="next">和下個項目比較的值。</param>
      <param name="advancePast">
        <see langword="true" /> 表示移動超過 <paramref name="next" /> 值 (如果找到)；否則為 <see langword="false" />。</param>
      <returns>若是序列中的下一組值，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.IsNext(System.ReadOnlySpan{`0},System.Boolean)">
      <summary>檢查在唯讀範圍中所指定值是否為序列中的下一個。</summary>
      <param name="next">和下個項目比較的範圍。</param>
      <param name="advancePast">
        <see langword="true" /> 表示移動超過 <paramref name="next" /> 值 (如果找到)；否則為 <see langword="false" />。</param>
      <returns>若是序列中的下一組值，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Length">
      <summary>取得讀取器 <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> 中的項目計數。</summary>
      <returns>讀取器<see cref="P:System.Buffers.SequenceReader`1.Sequence" />中的專案計數。</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Position">
      <summary>取得目前在 <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> 中的位置。</summary>
      <returns>中的目前位置<see cref="P:System.Buffers.SequenceReader`1.Sequence" />。</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Remaining">
      <summary>取得讀取器 <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> 中的剩餘項目。</summary>
      <returns>讀取器中的其餘專案<see cref="P:System.Buffers.SequenceReader`1.Sequence" /></returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.Rewind(System.Int64)">
      <summary>依指定的項目數將讀取器向後移。</summary>
      <param name="count">項目的數目。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> 是負值或大於 <see cref="P:System.Buffers.SequenceReader`1.Consumed" />。</exception>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Sequence">
      <summary>取得讀取器的基礎 <see cref="T:System.Buffers.ReadOnlySequence`1" />。</summary>
      <returns>讀取器的基礎唯讀順序。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryAdvanceTo(`0,System.Boolean)">
      <summary>搜尋指定的分隔符號，並選擇性前進超過它 (如果找到)。</summary>
      <param name="delimiter">要搜尋的分隔符號。</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> 則移動超過 <paramref name="delimiter" /> (如果找到)，否則 <see langword="false" />。</param>
      <returns>如果找到指定的 <paramref name="delimiter" /> 則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryAdvanceToAny(System.ReadOnlySpan{`0},System.Boolean)">
      <summary>搜尋任何數量的指定分隔符號，並選擇性前進超過找到的第一個分隔符號。</summary>
      <param name="delimiters">要搜尋的分隔符號。</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> 表示移動超過任何指定 <paramref name="delimiters" /> 的第一個執行個體； 表示不移動超過分隔符號。</param>
      <returns>若找到任何指定的 <paramref name="delimiters" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryCopyTo(System.Span{`0})">
      <summary>如果沒有足夠的資料填入，請將資料從目前位置複製到指定的目的地範圍。</summary>
      <param name="destination">作為複製目標位置的目的地範圍。</param>
      <returns>如有足夠資料可完全填滿 <paramref name="destination" /> 範圍則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryPeek(`0@)">
      <summary>查看下一個值，但不使讀取器前進。</summary>
      <param name="value">如在讀取器結尾，則為下個值或預設值。</param>
      <returns>如果讀取器不在其結尾且查看作業成功，則為 <see langword="true" />；如在讀取器結尾，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryRead(`0@)">
      <summary>讀取下一個值，並使讀取器前進。</summary>
      <param name="value">如在讀取器結尾，則為下個值或預設值。</param>
      <returns>如果讀取器不在其結尾且讀取作業成功，則為 <see langword="true" />；如在讀取器結尾，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,`0,System.Boolean)">
      <summary>嘗試讀取所有項目，最多為指定的 <paramref name="delimiter" />，忽略前有 <paramref name="delimiterEscape" /> 的分隔符號。</summary>
      <param name="sequence">方法傳回時，包含讀取的資料 (如有)。</param>
      <param name="delimiter">要搜尋的分隔符號。</param>
      <param name="delimiterEscape">值，指出要跳過的下一個 <paramref name="delimiter" />。</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> 表示移動超過 <paramref name="delimiter" /> (如果找到)；否則為 <see langword="false" />。</param>
      <returns>如果找到 <paramref name="delimiter" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,System.Boolean)">
      <summary>嘗試讀取所有項目，最多為指定的 <paramref name="delimiter" />。</summary>
      <param name="sequence">方法傳回時，包含讀取的資料 (如有)。</param>
      <param name="delimiter">要搜尋的分隔符號。</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> 表示移動超過 <paramref name="delimiter" /> (如果找到)；否則為 <see langword="false" />。</param>
      <returns>如果找到 <paramref name="delimiter" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary>嘗試讀取資料，直到指定為唯寫範圍的整個分隔符號符合。</summary>
      <param name="sequence">方法傳回時，包含讀取的資料 (如有)。</param>
      <param name="delimiter">包含一或多個分隔符號的唯讀範圍。</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> 表示移動超過 <paramref name="delimiter" /> (如果找到)；否則為 <see langword="false" />。</param>
      <returns>如果找到 <paramref name="delimiter" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,`0,System.Boolean)">
      <summary>嘗試讀取所有項目，最多為指定的 <paramref name="delimiter" />，忽略前有 <paramref name="delimiterEscape" /> 的分隔符號。</summary>
      <param name="span">方法傳回時，包含讀取的資料 (如有)。</param>
      <param name="delimiter">要搜尋的分隔符號。</param>
      <param name="delimiterEscape">值，指出要跳過的下一個 <paramref name="delimiter" />。</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> 表示移動超過 <paramref name="delimiter" /> (如果找到)；否則為 <see langword="false" />。</param>
      <returns>如果找到 <paramref name="delimiter" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,System.Boolean)">
      <summary>嘗試讀取所有項目，最多為指定的 <paramref name="delimiter" />。</summary>
      <param name="span">方法傳回時，包含讀取的資料 (如有)。</param>
      <param name="delimiter">要搜尋的分隔符號。</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> 表示移動超過 <paramref name="delimiter" /> (如果找到)；否則為 <see langword="false" />。</param>
      <returns>如果找到 <paramref name="delimiter" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadToAny(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary>嘗試讀取所有項目，最多為任何指定的 <paramref name="delimiters" />。</summary>
      <param name="sequence">方法傳回時，包含讀取的資料 (如有)。</param>
      <param name="delimiters">要搜尋的分隔符號。</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> 表示移動超過任何指定 <paramref name="delimiters" /> 中找到的第一個執行個體；否則為 <see langword="false" />。</param>
      <returns>如果找到任何 <paramref name="delimiters" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadToAny(System.ReadOnlySpan{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary>嘗試讀取所有項目，最多為任何指定的 <paramref name="delimiters" />。</summary>
      <param name="span">方法傳回時，包含讀取的資料 (如有)。</param>
      <param name="delimiters">要搜尋的分隔符號。</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> 表示移動超過任何指定 <paramref name="delimiters" /> 中找到的第一個執行個體；否則為 <see langword="false" />。</param>
      <returns>如果找到任何 <paramref name="delimiters" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.UnreadSpan">
      <summary>取得 <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> 的未讀取部分。</summary>
      <returns>的未讀取部分<see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />。</returns>
    </member>
    <member name="T:System.Buffers.SequenceReaderExtensions">
      <summary>提供 <see cref="T:System.Buffers.SequenceReader`1" /> 類別的擴充功能，可允許從二進位資料讀取位元組排列法特定數值。</summary>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int16@)">
      <summary>嘗試以位元組由大到小的方式讀取 <see cref="T:System.Int16" />。</summary>
      <param name="reader">要從中讀取值的位元組序列讀取器執行個體。</param>
      <param name="value">當此方法傳回時，會以位元組由大到小的方式，從位元組序列讀取器讀取值。</param>
      <returns>如果讀取作業成功，則為 <see langword="true" />；如果 <see cref="T:System.Int16" /> 沒有足夠的資料，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int32@)">
      <summary>嘗試以位元組由大到小的方式讀取 <see cref="T:System.Int32" />。</summary>
      <param name="reader">要從中讀取值的位元組序列讀取器。</param>
      <param name="value">當此方法傳回時，會以位元組由大到小的方式，從位元組序列讀取器讀取值。</param>
      <returns>如果讀取作業成功，則為 <see langword="true" />；如果 <see cref="T:System.Int32" /> 沒有足夠的資料，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int64@)">
      <summary>嘗試以位元組由大到小的方式讀取 <see cref="T:System.Int64" />。</summary>
      <param name="reader">要從中讀取值的位元組序列讀取器執行個體。</param>
      <param name="value">當此方法傳回時，會以位元組由大到小的方式，從位元組序列讀取器讀取值。</param>
      <returns>如果讀取作業成功，則為 <see langword="true" />；如果 <see cref="T:System.Int64" /> 沒有足夠的資料，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int16@)">
      <summary>嘗試以位元組由小到大的方式讀取 <see cref="T:System.Int16" />。</summary>
      <param name="reader">要從中讀取值的位元組序列讀取器執行個體。</param>
      <param name="value">當此方法傳回時，會以位元組由小到大的方式，從位元組序列讀取器讀取值。</param>
      <returns>如果讀取作業成功，則為 <see langword="true" />；如果 <see cref="T:System.Int16" /> 沒有足夠的資料，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int32@)">
      <summary>嘗試以位元組由小到大的方式讀取 <see cref="T:System.Int32" />。</summary>
      <param name="reader">要從中讀取值的位元組序列讀取器執行個體。</param>
      <param name="value">當此方法傳回時，會以位元組由小到大的方式，從位元組序列讀取器讀取值。</param>
      <returns>如果讀取作業成功，則為 <see langword="true" />；如果 <see cref="T:System.Int32" /> 沒有足夠的資料，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int64@)">
      <summary>嘗試以位元組由小到大的方式讀取 <see cref="T:System.Int64" />。</summary>
      <param name="reader">要從中讀取值的位元組序列讀取器執行個體。</param>
      <param name="value">當此方法傳回時，會以位元組由小到大的方式，從位元組序列讀取器讀取值。</param>
      <returns>如果讀取作業成功，則為 <see langword="true" />；如果 <see cref="T:System.Int64" /> 沒有足夠的資料，則為 <see langword="false" />。</returns>
    </member>
    <member name="T:System.Buffers.StandardFormat">
      <summary>代表不使用實際字串的標準格式字串。</summary>
    </member>
    <member name="M:System.Buffers.StandardFormat.#ctor(System.Char,System.Byte)">
      <summary>初始化 <see cref="T:System.Buffers.StandardFormat" /> 結構的新執行個體。</summary>
      <param name="symbol">具有特定類型的格式指定名稱，例如 'G'、'D' 或 'X'。</param>
      <param name="precision">選擇性的有效位數範圍為 0 到 99，或特殊值 <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> (預設值)。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="symbol" /> 不是 <see cref="F:System.Buffers.StandardFormat.NoPrecision" />，且其值大於 <see cref="F:System.Buffers.StandardFormat.MaxPrecision" />。
-或-
<paramref name="symbol" />無法轉換成 <see cref="T:System.Byte" />。</exception>
    </member>
    <member name="M:System.Buffers.StandardFormat.Equals(System.Buffers.StandardFormat)">
      <summary>傳回值，這個值指出指定的 <see cref="T:System.Buffers.StandardFormat" /> 是否等於目前的執行個體。</summary>
      <param name="other">要與目前執行個體相比較的格式。</param>
      <returns>如果兩個執行個體相等，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Equals(System.Object)">
      <summary>傳回值，這個值指出指定的物件是否為等於目前執行個體的 <see cref="T:System.Buffers.StandardFormat" /> 物件。</summary>
      <param name="obj">要與目前執行個體比較的物件。</param>
      <returns>如果兩個執行個體相等，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.GetHashCode">
      <summary>傳回這個執行個體的雜湊碼。</summary>
      <returns>這個執行個體的雜湊碼。</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.HasPrecision">
      <summary>取得值，這個值指出格式是否具有已定義的有效位數。</summary>
      <returns>
        <see langword="true" />如果格式具有以外的有效位數<see cref="F:System.Buffers.StandardFormat.NoPrecision" />, 則為, <see langword="false" />否則為。</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.IsDefault">
      <summary>取得值，這個值指出目前的執行個體是否為預設格式。</summary>
      <returns>
        <see langword="true" />如果目前的實例是預設格式, 則為,否則為<see langword="false" />。</returns>
    </member>
    <member name="F:System.Buffers.StandardFormat.MaxPrecision">
      <summary>定義最大有效位數值。</summary>
    </member>
    <member name="F:System.Buffers.StandardFormat.NoPrecision">
      <summary>指出格式不會使用有效位數，或未指定有效位數。</summary>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Equality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
      <summary>傳回值，這個值表示兩個 <see cref="T:System.Buffers.StandardFormat" /> 執行個體是否相等。</summary>
      <param name="left">要比較的第一個格式。</param>
      <param name="right">要比較的第二個格式。</param>
      <returns>如果兩個執行個體相等，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Implicit(System.Char)~System.Buffers.StandardFormat">
      <summary>使用 <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> 有效位數將字元轉換為 <see cref="T:System.Buffers.StandardFormat" /> 執行個體。</summary>
      <param name="symbol">要轉換為 <see cref="T:System.Buffers.StandardFormat" /> 值的字元。</param>
      <returns>
        <see cref="P:System.Buffers.StandardFormat.Symbol" /> 屬性等於 <paramref name="symbol" /> 且 <see cref="P:System.Buffers.StandardFormat.Precision" /> 屬性等於 <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> 的格式。</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Inequality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
      <summary>判斷兩個 <see cref="T:System.Buffers.StandardFormat" /> 執行個體是否不相等。</summary>
      <param name="left">要比較的第一個格式。</param>
      <param name="right">要比較的第二個格式。</param>
      <returns>如果兩個格式不相等，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Parse(System.ReadOnlySpan{System.Char})">
      <summary>使用 <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> 有效位數將 <see langword="ReadOnlySpan&lt;System.Char&gt;" /> 轉換為 <see cref="T:System.Buffers.StandardFormat" /> 執行個體。</summary>
      <param name="format">唯讀範圍，其中包含要剖析的字元。</param>
      <returns>
        <see cref="P:System.Buffers.StandardFormat.Symbol" /> 屬性值為 <paramref name="format" /> 中的字元，且其 <see cref="P:System.Buffers.StandardFormat.Precision" /> 屬性值為 <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> 的值。</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Parse(System.String)">
      <summary>將傳統 .NET 標準格式字串轉換為 <see cref="T:System.Buffers.StandardFormat" /> 執行個體。</summary>
      <param name="format">傳統 .NET 標準格式字串。</param>
      <returns>格式。</returns>
      <exception cref="T:System.FormatException">
        <paramref name="format" /> 不是有效的標準格式字串。</exception>
    </member>
    <member name="P:System.Buffers.StandardFormat.Precision">
      <summary>取得格式的有效位數元件。</summary>
      <returns>精確度元件可以是<see cref="F:System.Buffers.StandardFormat.NoPrecision" />, 或的範圍可以從0到9。</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.Symbol">
      <summary>取得格式的字元元件。</summary>
      <returns>格式的字元元件。</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.ToString">
      <summary>傳回此格式的字串表示。</summary>
      <returns>此格式的字串表示。</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.TryParse(System.ReadOnlySpan{System.Char},System.Buffers.StandardFormat@)">
      <summary>嘗試將 <see langword="ReadOnlySpan&lt;Char&gt;" /> 轉換為 <see cref="T:System.Buffers.StandardFormat" /> 執行個體並傳回一個值，該值指出剖析作業是否成功。</summary>
      <param name="format">唯讀範圍，其中包含要轉換的字元。</param>
      <param name="result">當方法傳回時，如果作業成功，則會包含已剖析的 <see cref="T:System.Buffers.StandardFormat" /> 執行個體。</param>
      <returns>如果剖析作業成功則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
    </member>
    <member name="T:System.Buffers.Text.Base64">
      <summary>在二進位資料與以 base 64 表示的 UTF-8 編碼文字之間轉換。</summary>
    </member>
    <member name="M:System.Buffers.Text.Base64.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean)">
      <summary>將以 base 64 表示的 UTF-8 編碼文字範圍解碼為二進位資料。 如果輸入不是 4 的倍數，就會盡可能地解碼為最接近 4 的倍數。</summary>
      <param name="utf8">輸入範圍，包含需要解碼的 base 64 格式 UTF-8 編碼文字。</param>
      <param name="bytes">輸出範圍，包含作業的結果，亦即，解碼的二進位資料。</param>
      <param name="bytesConsumed">作業期間使用的輸入位元組數。 如有必要，這可以用來分割後續呼叫的輸入。</param>
      <param name="bytesWritten">寫入至輸出範圍的位元組數。 如有必要，這可以用來分割後續呼叫的輸出。</param>
      <param name="isFinalBlock">
        <see langword="true" /> (預設) 如果輸入範圍包含要解碼的整個資料。 <see langword="false" /> 如果輸入範圍包含後續還有更多資料的部分資料。</param>
      <returns>指出解碼作業狀態的其中一個列舉值。</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.DecodeFromUtf8InPlace(System.Span{System.Byte},System.Int32@)">
      <summary>將 base 64 (就地) 格式 UTF-8 編碼文字的範圍解碼為二進位資料。 解碼的二進位輸出小於輸入中包含的文字資料 (此作業會壓縮資料)。 如果輸入不是 4 的倍數，此方法將不會解碼任何資料。</summary>
      <param name="buffer">輸入範圍，包含需要解碼的 base-64 文字資料。</param>
      <param name="bytesWritten">寫入緩衝區的位元組數目。</param>
      <returns>指出解碼作業狀態的其中一個列舉值。</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.EncodeToUtf8(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean)">
      <summary>將二進位資料的範圍編碼為以 base 64 表示的 UTF-8 編碼文字。</summary>
      <param name="bytes">輸入範圍，包含需要編碼的二進位資料。</param>
      <param name="utf8">輸出範圍，包含作業的結果，亦即，base 64 格式的 UTF-8 編碼文字。</param>
      <param name="bytesConsumed">作業期間使用的輸入位元組數。 如有必要，這可以用來分割後續呼叫的輸入。</param>
      <param name="bytesWritten">寫入至輸出範圍的位元組數。 如有必要，這可以用來分割後續呼叫的輸出。</param>
      <param name="isFinalBlock">
        <see langword="true" /> (預設) 如果輸入範圍包含要編碼的整個資料。 <see langword="false" /> 如果輸入範圍包含後續還有更多資料的部分資料。</param>
      <returns>指出編碼作業狀態的其中一個列舉值。</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.EncodeToUtf8InPlace(System.Span{System.Byte},System.Int32,System.Int32@)">
      <summary>將二進位資料 (就地) 的範圍編碼為以 base 64 表示的 UTF-8 編碼文字。 編碼的文字輸出大於輸入中包含的二進位資料 (此作業會擴大資料)。</summary>
      <param name="buffer">輸入範圍，包含需要編碼的二進位資料。 此方法會執行就地轉換，因此必須要夠大，才能儲存作業的結果。</param>
      <param name="dataLength">包含在需要編碼的緩衝區中的二進位資料位元組數。 這個值必須小於緩衝區長度。</param>
      <param name="bytesWritten">寫入緩衝區的位元組數目。</param>
      <returns>指出編碼作業狀態的其中一個列舉值。</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.GetMaxDecodedFromUtf8Length(System.Int32)">
      <summary>如果您要以指定的長度解碼位元組範圍內的 base-64 編碼文字，則傳回結果的長度上限 (位元組)。</summary>
      <param name="length">位元組範圍的大小。</param>
      <returns>結果的長度上限 (位元組)。</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> 小於 0。</exception>
    </member>
    <member name="M:System.Buffers.Text.Base64.GetMaxEncodedToUtf8Length(System.Int32)">
      <summary>如果您要以指定的長度編碼位元組範圍內的二進位資料編碼文字，則傳回結果的長度上限 (位元組)。</summary>
      <param name="length">位元組範圍的大小。</param>
      <returns>結果的長度上限 (位元組)。</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> 小於 0 或大於 1610612733 (因為編碼會將資料擴大 4/3)。</exception>
    </member>
    <member name="T:System.Buffers.Text.Utf8Formatter">
      <summary>提供將一般資料型別格式化成 UTF8 字串的靜態方法。</summary>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Boolean,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>將 <see cref="T:System.Boolean" /> 格式化成 UTF8 字串。</summary>
      <param name="value">要格式化的值。</param>
      <param name="destination">要寫入 UTF8 格式值的緩衝。</param>
      <param name="bytesWritten">方法傳回時，會包含經過格式化文字的位元組長度。</param>
      <param name="format">要使用的標準格式。</param>
      <returns>若格式化作業成功，則為 <see langword="true" />；若 <paramref name="buffer" /> 過小，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Byte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>將 <see cref="T:System.Byte" /> 格式化成 UTF8 字串。</summary>
      <param name="value">要格式化的值。</param>
      <param name="destination">要寫入 UTF8 格式值的緩衝。</param>
      <param name="bytesWritten">方法傳回時，會包含經過格式化文字的位元組長度。</param>
      <param name="format">要使用的標準格式。</param>
      <returns>若格式化作業成功，則為 <see langword="true" />；若 <paramref name="buffer" /> 過小，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTime,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>將 <see cref="T:System.DateTime" /> 格式化成 UTF8 字串。</summary>
      <param name="value">要格式化的值。</param>
      <param name="destination">要寫入 UTF8 格式值的緩衝。</param>
      <param name="bytesWritten">方法傳回時，會包含經過格式化文字的位元組長度。</param>
      <param name="format">要使用的標準格式。</param>
      <returns>若格式化作業成功，則為 <see langword="true" />；若 <paramref name="buffer" /> 過小，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTimeOffset,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>將 <see cref="T:System.DateTimeOffset" /> 格式化成 UTF8 字串。</summary>
      <param name="value">要格式化的值。</param>
      <param name="destination">要寫入 UTF8 格式值的緩衝。</param>
      <param name="bytesWritten">方法傳回時，會包含經過格式化文字的位元組長度。</param>
      <param name="format">要使用的標準格式。</param>
      <returns>若格式化作業成功，則為 <see langword="true" />；若 <paramref name="buffer" /> 過小，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Decimal,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>將 <see cref="T:System.Decimal" /> 格式化成 UTF8 字串。</summary>
      <param name="value">要格式化的值。</param>
      <param name="destination">要寫入 UTF8 格式值的緩衝。</param>
      <param name="bytesWritten">方法傳回時，會包含經過格式化文字的位元組長度。</param>
      <param name="format">要使用的標準格式。</param>
      <returns>若格式化作業成功，則為 <see langword="true" />；若 <paramref name="buffer" /> 過小，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Double,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>將 <see cref="T:System.Double" /> 格式化成 UTF8 字串。</summary>
      <param name="value">要格式化的值。</param>
      <param name="destination">要寫入 UTF8 格式值的緩衝。</param>
      <param name="bytesWritten">方法傳回時，會包含經過格式化文字的位元組長度。</param>
      <param name="format">要使用的標準格式。</param>
      <returns>若格式化作業成功，則為 <see langword="true" />；若 <paramref name="buffer" /> 過小，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Guid,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>將 <see cref="T:System.Guid" /> 格式化成 UTF8 字串。</summary>
      <param name="value">要格式化的值。</param>
      <param name="destination">要寫入 UTF8 格式值的緩衝。</param>
      <param name="bytesWritten">方法傳回時，會包含經過格式化文字的位元組長度。</param>
      <param name="format">要使用的標準格式。</param>
      <returns>若格式化作業成功，則為 <see langword="true" />；若 <paramref name="buffer" /> 過小，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>將 <see cref="T:System.Int16" /> 格式化成 UTF8 字串。</summary>
      <param name="value">要格式化的值。</param>
      <param name="destination">要寫入 UTF8 格式值的緩衝。</param>
      <param name="bytesWritten">方法傳回時，會包含經過格式化文字的位元組長度。</param>
      <param name="format">要使用的標準格式。</param>
      <returns>若格式化作業成功，則為 <see langword="true" />；若 <paramref name="buffer" /> 過小，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>將 <see cref="T:System.Int32" /> 格式化成 UTF8 字串。</summary>
      <param name="value">要格式化的值。</param>
      <param name="destination">要寫入 UTF8 格式值的緩衝。</param>
      <param name="bytesWritten">方法傳回時，會包含經過格式化文字的位元組長度。</param>
      <param name="format">要使用的標準格式。</param>
      <returns>若格式化作業成功，則為 <see langword="true" />；若 <paramref name="buffer" /> 過小，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>將 <see cref="T:System.Int64" /> 格式化成 UTF8 字串。</summary>
      <param name="value">要格式化的值。</param>
      <param name="destination">要寫入 UTF8 格式值的緩衝。</param>
      <param name="bytesWritten">方法傳回時，會包含經過格式化文字的位元組長度。</param>
      <param name="format">要使用的標準格式。</param>
      <returns>若格式化作業成功，則為 <see langword="true" />；若 <paramref name="buffer" /> 過小，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.SByte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>將 <see cref="T:System.SByte" /> 格式化成 UTF8 字串。</summary>
      <param name="value">要格式化的值。</param>
      <param name="destination">要寫入 UTF8 格式值的緩衝。</param>
      <param name="bytesWritten">方法傳回時，會包含經過格式化文字的位元組長度。</param>
      <param name="format">要使用的標準格式。</param>
      <returns>若格式化作業成功，則為 <see langword="true" />；若 <paramref name="buffer" /> 過小，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Single,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>將 <see cref="T:System.Single" /> 格式化成 UTF8 字串。</summary>
      <param name="value">要格式化的值。</param>
      <param name="destination">要寫入 UTF8 格式值的緩衝。</param>
      <param name="bytesWritten">方法傳回時，會包含經過格式化文字的位元組長度。</param>
      <param name="format">要使用的標準格式。</param>
      <returns>若格式化作業成功，則為 <see langword="true" />；若 <paramref name="buffer" /> 過小，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.TimeSpan,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>將 <see cref="T:System.TimeSpan" /> 格式化成 UTF8 字串。</summary>
      <param name="value">要格式化的值。</param>
      <param name="destination">要寫入 UTF8 格式值的緩衝。</param>
      <param name="bytesWritten">方法傳回時，會包含經過格式化文字的位元組長度。</param>
      <param name="format">要使用的標準格式。</param>
      <returns>若格式化作業成功，則為 <see langword="true" />；若 <paramref name="buffer" /> 過小，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>將 <see cref="T:System.UInt16" /> 格式化成 UTF8 字串。</summary>
      <param name="value">要格式化的值。</param>
      <param name="destination">要寫入 UTF8 格式值的緩衝。</param>
      <param name="bytesWritten">方法傳回時，會包含經過格式化文字的位元組長度。</param>
      <param name="format">要使用的標準格式。</param>
      <returns>若格式化作業成功，則為 <see langword="true" />；若 <paramref name="buffer" /> 過小，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>將 <see cref="T:System.UInt32" /> 格式化成 UTF8 字串。</summary>
      <param name="value">要格式化的值。</param>
      <param name="destination">要寫入 UTF8 格式值的緩衝。</param>
      <param name="bytesWritten">方法傳回時，會包含經過格式化文字的位元組長度。</param>
      <param name="format">要使用的標準格式。</param>
      <returns>若格式化作業成功，則為 <see langword="true" />；若 <paramref name="buffer" /> 過小，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>將 <see cref="T:System.UInt64" /> 格式化成 UTF8 字串。</summary>
      <param name="value">要格式化的值。</param>
      <param name="destination">要寫入 UTF8 格式值的緩衝。</param>
      <param name="bytesWritten">方法傳回時，會包含經過格式化文字的位元組長度。</param>
      <param name="format">要使用的標準格式。</param>
      <returns>若格式化作業成功，則為 <see langword="true" />；若 <paramref name="buffer" /> 過小，則為 <see langword="false" />。</returns>
    </member>
    <member name="T:System.Buffers.Text.Utf8Parser">
      <summary>提供將 UTF8 字串剖析成一般資料型別的靜態方法。</summary>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Boolean@,System.Int32@,System.Char)">
      <summary>從 UTF8 字串的開頭剖析 <see cref="T:System.Boolean" />。</summary>
      <param name="source">要剖析的 UTF8 字串。</param>
      <param name="value">方法傳回時，若剖析作業成功，則會包含從 <paramref name="source" /> 剖析的值。</param>
      <param name="bytesConsumed">若剖析作業成功，則在方法傳回時，會包含剖析子字串的位元組長度。 若方法失敗，則 <paramref name="bytesConsumed" /> 會設為 0。</param>
      <param name="standardFormat">UTF8 字串的預期格式。</param>
      <returns>若成功，則為 <see langword="true" />；若字串語法不正確或發生溢位或反向溢位，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Byte@,System.Int32@,System.Char)">
      <summary>從 UTF8 字串的開頭剖析 <see cref="T:System.Byte" />。</summary>
      <param name="source">要剖析的 UTF8 字串。</param>
      <param name="value">方法傳回時，若剖析作業成功，則會包含從 <paramref name="source" /> 剖析的值。</param>
      <param name="bytesConsumed">若剖析作業成功，則在方法傳回時，會包含剖析子字串的位元組長度。 若方法失敗，則 <paramref name="bytesConsumed" /> 會設為 0。</param>
      <param name="standardFormat">UTF8 字串的預期格式。</param>
      <returns>若成功，則為 <see langword="true" />；若字串語法不正確或發生溢位或反向溢位，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.DateTime@,System.Int32@,System.Char)">
      <summary>從 UTF8 字串的開頭剖析 <see cref="T:System.DateTime" />。</summary>
      <param name="source">要剖析的 UTF8 字串。</param>
      <param name="value">方法傳回時，若剖析作業成功，則會包含從 <paramref name="source" /> 剖析的值。</param>
      <param name="bytesConsumed">若剖析作業成功，則在方法傳回時，會包含剖析子字串的位元組長度。 若方法失敗，則 <paramref name="bytesConsumed" /> 會設為 0。</param>
      <param name="standardFormat">UTF8 字串的預期格式。</param>
      <returns>若成功，則為 <see langword="true" />；若字串語法不正確或發生溢位或反向溢位，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.DateTimeOffset@,System.Int32@,System.Char)">
      <summary>從 UTF8 字串的開頭剖析 <see cref="T:System.DateTimeOffset" />。</summary>
      <param name="source">要剖析的 UTF8 字串。</param>
      <param name="value">方法傳回時，若剖析作業成功，則會包含從 <paramref name="source" /> 剖析的值。</param>
      <param name="bytesConsumed">若剖析作業成功，則在方法傳回時，會包含剖析子字串的位元組長度。 若方法失敗，則 <paramref name="bytesConsumed" /> 會設為 0。</param>
      <param name="standardFormat">UTF8 字串的預期格式。</param>
      <returns>若成功，則為 <see langword="true" />；若字串語法不正確或發生溢位或反向溢位，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Decimal@,System.Int32@,System.Char)">
      <summary>從 UTF8 字串的開頭剖析 <see cref="T:System.Decimal" />。</summary>
      <param name="source">要剖析的 UTF8 字串。</param>
      <param name="value">方法傳回時，若剖析作業成功，則會包含從 <paramref name="source" /> 剖析的值。</param>
      <param name="bytesConsumed">若剖析作業成功，則在方法傳回時，會包含剖析子字串的位元組長度。 若方法失敗，則 <paramref name="bytesConsumed" /> 會設為 0。</param>
      <param name="standardFormat">UTF8 字串的預期格式。</param>
      <returns>若成功，則為 <see langword="true" />；若字串語法不正確或發生溢位或反向溢位，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Double@,System.Int32@,System.Char)">
      <summary>從 UTF8 字串的開頭剖析 <see cref="T:System.Double" />。</summary>
      <param name="source">要剖析的 UTF8 字串。</param>
      <param name="value">方法傳回時，若剖析作業成功，則會包含從 <paramref name="source" /> 剖析的值。</param>
      <param name="bytesConsumed">若剖析作業成功，則在方法傳回時，會包含剖析子字串的位元組長度。 若方法失敗，則 <paramref name="bytesConsumed" /> 會設為 0。</param>
      <param name="standardFormat">UTF8 字串的預期格式。</param>
      <returns>若成功，則為 <see langword="true" />；若字串語法不正確或發生溢位或反向溢位，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Guid@,System.Int32@,System.Char)">
      <summary>從 UTF8 字串的開頭剖析 <see cref="T:System.Guid" />。</summary>
      <param name="source">要剖析的 UTF8 字串。</param>
      <param name="value">方法傳回時，若剖析作業成功，則會包含從 <paramref name="source" /> 剖析的值。</param>
      <param name="bytesConsumed">若剖析作業成功，則在方法傳回時，會包含剖析子字串的位元組長度。 若方法失敗，則 <paramref name="bytesConsumed" /> 會設為 0。</param>
      <param name="standardFormat">UTF8 字串的預期格式。</param>
      <returns>若成功，則為 <see langword="true" />；若字串語法不正確或發生溢位或反向溢位，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int16@,System.Int32@,System.Char)">
      <summary>從 UTF8 字串的開頭剖析 <see cref="T:System.Int16" />。</summary>
      <param name="source">要剖析的 UTF8 字串。</param>
      <param name="value">方法傳回時，若剖析作業成功，則會包含從 <paramref name="source" /> 剖析的值。</param>
      <param name="bytesConsumed">若剖析作業成功，則在方法傳回時，會包含剖析子字串的位元組長度。 若方法失敗，則 <paramref name="bytesConsumed" /> 會設為 0。</param>
      <param name="standardFormat">UTF8 字串的預期格式。</param>
      <returns>若成功，則為 <see langword="true" />；若字串語法不正確或發生溢位或反向溢位，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int32@,System.Int32@,System.Char)">
      <summary>從 UTF8 字串的開頭剖析 <see cref="T:System.Int32" />。</summary>
      <param name="source">要剖析的 UTF8 字串。</param>
      <param name="value">方法傳回時，若剖析作業成功，則會包含從 <paramref name="source" /> 剖析的值。</param>
      <param name="bytesConsumed">若剖析作業成功，則在方法傳回時，會包含剖析子字串的位元組長度。 若方法失敗，則 <paramref name="bytesConsumed" /> 會設為 0。</param>
      <param name="standardFormat">UTF8 字串的預期格式。</param>
      <returns>若成功，則為 <see langword="true" />；若字串語法不正確或發生溢位或反向溢位，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int64@,System.Int32@,System.Char)">
      <summary>從 UTF8 字串的開頭剖析 <see cref="T:System.Int64" />。</summary>
      <param name="source">要剖析的 UTF8 字串。</param>
      <param name="value">方法傳回時，若剖析作業成功，則會包含從 <paramref name="source" /> 剖析的值。</param>
      <param name="bytesConsumed">若剖析作業成功，則在方法傳回時，會包含剖析子字串的位元組長度。 若方法失敗，則 <paramref name="bytesConsumed" /> 會設為 0。</param>
      <param name="standardFormat">UTF8 字串的預期格式。</param>
      <returns>若成功，則為 <see langword="true" />；若字串語法不正確或發生溢位或反向溢位，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.SByte@,System.Int32@,System.Char)">
      <summary>從 UTF8 字串的開頭剖析 <see cref="T:System.SByte" />。</summary>
      <param name="source">要剖析的 UTF8 字串。</param>
      <param name="value">方法傳回時，若剖析作業成功，則會包含從 <paramref name="source" /> 剖析的值。</param>
      <param name="bytesConsumed">若剖析作業成功，則在方法傳回時，會包含剖析子字串的位元組長度。 若方法失敗，則 <paramref name="bytesConsumed" /> 會設為 0。</param>
      <param name="standardFormat">UTF8 字串的預期格式。</param>
      <returns>若成功，則為 <see langword="true" />；若字串語法不正確或發生溢位或反向溢位，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Single@,System.Int32@,System.Char)">
      <summary>從 UTF8 字串的開頭剖析 <see cref="T:System.Single" />。</summary>
      <param name="source">要剖析的 UTF8 字串。</param>
      <param name="value">方法傳回時，若剖析作業成功，則會包含從 <paramref name="source" /> 剖析的值。</param>
      <param name="bytesConsumed">若剖析作業成功，則在方法傳回時，會包含剖析子字串的位元組長度。 若方法失敗，則 <paramref name="bytesConsumed" /> 會設為 0。</param>
      <param name="standardFormat">UTF8 字串的預期格式。</param>
      <returns>若成功，則為 <see langword="true" />；若字串語法不正確或發生溢位或反向溢位，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.TimeSpan@,System.Int32@,System.Char)">
      <summary>從 UTF8 字串的開頭剖析 <see cref="T:System.TimeSpan" />。</summary>
      <param name="source">要剖析的 UTF8 字串。</param>
      <param name="value">方法傳回時，若剖析作業成功，則會包含從 <paramref name="source" /> 剖析的值。</param>
      <param name="bytesConsumed">若剖析作業成功，則在方法傳回時，會包含剖析子字串的位元組長度。 若方法失敗，則 <paramref name="bytesConsumed" /> 會設為 0。</param>
      <param name="standardFormat">UTF8 字串的預期格式。</param>
      <returns>若成功，則為 <see langword="true" />；若字串語法不正確或發生溢位或反向溢位，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt16@,System.Int32@,System.Char)">
      <summary>從 UTF8 字串的開頭剖析 <see cref="T:System.UInt16" />。</summary>
      <param name="source">要剖析的 UTF8 字串。</param>
      <param name="value">方法傳回時，若剖析作業成功，則會包含從 <paramref name="source" /> 剖析的值。</param>
      <param name="bytesConsumed">若剖析作業成功，則在方法傳回時，會包含剖析子字串的位元組長度。 若方法失敗，則 <paramref name="bytesConsumed" /> 會設為 0。</param>
      <param name="standardFormat">UTF8 字串的預期格式。</param>
      <returns>若成功，則為 <see langword="true" />；若字串語法不正確或發生溢位或反向溢位，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt32@,System.Int32@,System.Char)">
      <summary>從 UTF8 字串的開頭剖析 <see cref="T:System.UInt32" />。</summary>
      <param name="source">要剖析的 UTF8 字串。</param>
      <param name="value">方法傳回時，若剖析作業成功，則會包含從 <paramref name="source" /> 剖析的值。</param>
      <param name="bytesConsumed">若剖析作業成功，則在方法傳回時，會包含剖析子字串的位元組長度。 若方法失敗，則 <paramref name="bytesConsumed" /> 會設為 0。</param>
      <param name="standardFormat">UTF8 字串的預期格式。</param>
      <returns>若成功，則為 <see langword="true" />；若字串語法不正確或發生溢位或反向溢位，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt64@,System.Int32@,System.Char)">
      <summary>從 UTF8 字串的開頭剖析 <see cref="T:System.UInt64" />。</summary>
      <param name="source">要剖析的 UTF8 字串。</param>
      <param name="value">方法傳回時，若剖析作業成功，則會包含從 <paramref name="source" /> 剖析的值。</param>
      <param name="bytesConsumed">若剖析作業成功，則在方法傳回時，會包含剖析子字串的位元組長度。 若方法失敗，則 <paramref name="bytesConsumed" /> 會設為 0。</param>
      <param name="standardFormat">UTF8 字串的預期格式。</param>
      <returns>若成功，則為 <see langword="true" />；若字串語法不正確或發生溢位或反向溢位，則為 <see langword="false" />。</returns>
    </member>
    <member name="T:System.MemoryExtensions">
      <summary>提供記憶體和範圍相關類型的擴充方法，例如 <see cref="T:System.Memory`1" />、<see cref="T:System.ReadOnlyMemory`1" />、<see cref="T:System.Span`1" /> 和 <see cref="T:System.ReadOnlySpan`1" />。</summary>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String)">
      <summary>在目標字串部分上建立新 <see langword="ReadOnlyMemory&lt;Char&gt;" />。</summary>
      <param name="text">目標字串。</param>
      <returns>字串的唯讀字元記憶體表示；如果 <paramref name="text" /> 為 <see langword="null" />，則為 <see langword="default" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Index)">
      <summary>在起始於指定索引的目標字串部分上建立新 <see langword="ReadOnlyMemory&lt;Char&gt;" />。</summary>
      <param name="text">目標字串。</param>
      <param name="startIndex">要開始此配量的索引。</param>
      <returns>字串的唯讀字元記憶體表示。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32)">
      <summary>在起始於指定字元位置的目標字串部分上建立新 <see langword="ReadOnlyMemory&lt;Char&gt;" />。</summary>
      <param name="text">目標字串。</param>
      <param name="start">要開始此配量的索引。</param>
      <returns>字串的唯讀字元記憶體表示；如果 <paramref name="text" /> 為 <see langword="null" />，則為 <see langword="default" />。</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 不在 <paramref name="text" /> 的範圍內 (<paramref name="start" /> 為 &lt; 0 或 &gt; <c>text.Length</c>)。</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32,System.Int32)">
      <summary>在起始於指定位置且具有一個長度的目標字串部分上建立新 <see langword="ReadOnlyMemory&lt;Char&gt;" />。</summary>
      <param name="text">目標字串。</param>
      <param name="start">要開始此配量的索引。</param>
      <param name="length">配量所需的長度。</param>
      <returns>字串的唯讀字元記憶體表示；如果 <paramref name="text" /> 為 <see langword="null" />，則為 <see langword="default" />。</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />、<paramref name="length" /> 或 <paramref name="start" /> + <paramref name="length" /> 不在 <paramref name="text" /> 的範圍內。</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Range)">
      <summary>在指定的目標字串範圍上建立新 <see langword="ReadOnlyMemory&lt;Char&gt;" />。</summary>
      <param name="text">目標字串。</param>
      <param name="range">表示已切割字串開頭和長度的範圍。</param>
      <returns>字串的唯讀字元記憶體表示。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[])">
      <summary>在目標陣列上建立新記憶體區域。</summary>
      <param name="array">要轉換的陣列。</param>
      <typeparam name="T">陣列的類型。</typeparam>
      <returns>完整或部分陣列的記憶體表示。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Index)">
      <summary>在起始於指定索引到陣列結尾的目標陣列部分上建立新記憶體區域。</summary>
      <param name="array">要轉換的陣列。</param>
      <param name="startIndex">陣列的第一個位置。</param>
      <typeparam name="T">陣列的類型。</typeparam>
      <returns>完整或部分陣列的記憶體表示。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32)">
      <summary>在起始於指定位置到陣列結尾的目標陣列部分上建立新記憶體區域。</summary>
      <param name="array">目標陣列。</param>
      <param name="start">要開始記憶體的索引。</param>
      <typeparam name="T">陣列的類型。</typeparam>
      <returns>完整或部分陣列的記憶體表示。</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="array" /> 是 Covariant，且陣列的類型不完全是 <see langword="T[]" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 索引小於 0 或大於 <see langword="array.Length" />。</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32,System.Int32)">
      <summary>在起始於指定位置且具有指定長度的目標陣列部分上建立新記憶體區域。</summary>
      <param name="array">目標陣列。</param>
      <param name="start">要開始記憶體區域的索引。</param>
      <param name="length">記憶體區域中的項目數。</param>
      <typeparam name="T">陣列的類型。</typeparam>
      <returns>完整或部分陣列的記憶體表示。</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="array" /> 是 Covariant，且陣列的類型不完全是 <see langword="T[]" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />、<paramref name="length" /> 或 <paramref name="start" /> + <paramref name="length" /> 不在 <paramref name="array" /> 的範圍內。</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Range)">
      <summary>在起始於範圍開始索引 (含) 且結束於範圍結束索引 (不含) 的目標陣列部分上建立新記憶體區域。</summary>
      <param name="array">要轉換的陣列。</param>
      <param name="range">要從陣列轉換的範圍。</param>
      <typeparam name="T">陣列的類型。</typeparam>
      <returns>完整或部分陣列的記憶體表示。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0})">
      <summary>在目標陣列區段部分上建立新記憶體區域。</summary>
      <param name="segment">要轉換的區段。</param>
      <typeparam name="T">區段的類型。</typeparam>
      <returns>區段的記憶體表示。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32)">
      <summary>在起始於指定位置到區段結尾的目標陣列區段部分上建立新記憶體區域。</summary>
      <param name="segment">目標陣列區段。</param>
      <param name="start">要開始記憶體的索引。</param>
      <typeparam name="T">陣列的類型。</typeparam>
      <returns>完整或部分陣列的記憶體表示。</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="segment" /> 是 Covariant，且 <paramref name="segment" /> 的型別不完全是 <see langword="T[]" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 小於 0 或大於 <see langword="segment.Count" />。</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32,System.Int32)">
      <summary>在起始於指定位置且具有指定長度的目標陣列區段部分上建立新記憶體區域。</summary>
      <param name="segment">目標陣列區段。</param>
      <param name="start">要開始記憶體的索引。</param>
      <param name="length">記憶體中的項目數。</param>
      <typeparam name="T">陣列的類型。</typeparam>
      <returns>完整或部分陣列的記憶體表示。</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="segment" /> 是 Covariant，且陣列的類型不完全是 <see langword="T[]" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />、<paramref name="length" /> 或 <paramref name="start" /> + <paramref name="length" /> 不在 <paramref name="segment" /> 的範圍內。</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String)">
      <summary>在起始於指定位置且具有指定字元數的目標字串部分上建立新唯讀範圍。</summary>
      <param name="text">目標字串。</param>
      <returns>字串的唯讀範圍表示。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32)">
      <summary>在起始於指定位置到字串結尾的目標字串部分上建立新唯讀範圍。</summary>
      <param name="text">目標字串。</param>
      <param name="start">要開始此配量的索引。</param>
      <returns>字串的唯讀範圍表示。</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="text" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 小於 0 或大於 <see langword="text.Length" />。</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32,System.Int32)">
      <summary>在字串上建立新唯讀範圍。</summary>
      <param name="text">目標字串。</param>
      <param name="start">要開始此配量的索引。</param>
      <param name="length">配量所需的長度。</param>
      <returns>字串的唯讀範圍表示。</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />、<paramref name="length" /> 或 <paramref name="start" /> + <paramref name="length" /> 不在 <paramref name="text" /> 的範圍內。</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[])">
      <summary>在目標陣列上建立新範圍。</summary>
      <param name="array">要轉換的陣列。</param>
      <typeparam name="T">陣列的類型。</typeparam>
      <returns>陣列的範圍表示。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Index)">
      <summary>在由 <see cref="T:System.Index" /> 值定義的目標陣列部分上建立新範圍。</summary>
      <param name="array">要轉換的陣列。</param>
      <param name="startIndex">起始索引。</param>
      <typeparam name="T">陣列類型。</typeparam>
      <returns>陣列的範圍表示。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32)">
      <summary>在起始於指定位置到陣列結尾的目標陣列部分上建立新範圍。</summary>
      <param name="array">要轉換的陣列。</param>
      <param name="start">要從中轉換陣列的初始索引。</param>
      <typeparam name="T">陣列的類型。</typeparam>
      <returns>陣列的範圍表示。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32,System.Int32)">
      <summary>在起始於指定位置且具有指定長度的目標陣列部分上建立新範圍。</summary>
      <param name="array">目標陣列。</param>
      <param name="start">要開始範圍的索引。</param>
      <param name="length">範圍中的項目數。</param>
      <typeparam name="T">陣列的類型。</typeparam>
      <returns>陣列的範圍表示。</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="array" /> 是 Covariant，且陣列的類型不完全是 <see langword="T[]" />"。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />、<paramref name="length" /> 或 <paramref name="start" /> + <paramref name="length" /> 不在 <paramref name="text" /> 的範圍內。</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Range)">
      <summary>在由 <see cref="T:System.Range" /> 值定義的目標陣列部分上建立新範圍。</summary>
      <param name="array">要轉換的陣列。</param>
      <param name="range">要轉換的陣列範圍。</param>
      <typeparam name="T">陣列的類型。</typeparam>
      <returns>陣列的範圍表示。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0})">
      <summary>在目標陣列區段上建立新範圍。</summary>
      <param name="segment">要轉換的陣列區段。</param>
      <typeparam name="T">陣列區段的類型。</typeparam>
      <returns>陣列區段的範圍表示。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Index)">
      <summary>在起始於指定索引且結束於區段結尾的目標陣列區段部分上建立新範圍。</summary>
      <param name="segment">目標陣列區段。</param>
      <param name="startIndex">要開始範圍的索引。</param>
      <typeparam name="T">陣列區段的類型。</typeparam>
      <returns>陣列區段的範圍表示。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32)">
      <summary>在起始於指定位置到區段結尾的目標陣列區段部分上建立新範圍。</summary>
      <param name="segment">目標陣列區段。</param>
      <param name="start">要開始範圍的索引。</param>
      <typeparam name="T">陣列區段的類型。</typeparam>
      <returns>陣列區段的範圍表示。</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="segment" /> 是 Covariant，且陣列的類型不完全是 <see langword="T[]" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 小於 0 或大於 <see langword="segment.Count" />。</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32,System.Int32)">
      <summary>在起始於指定位置且具有指定長度的目標陣列區段部分上建立新範圍。</summary>
      <param name="segment">目標陣列區段。</param>
      <param name="start">要開始範圍的索引。</param>
      <param name="length">範圍中的項目數。</param>
      <typeparam name="T">陣列區段的類型。</typeparam>
      <returns>陣列的範圍表示。</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="segment" /> 是 Covariant，且陣列的類型不完全是 <see langword="T[]" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />、<paramref name="length" /> 或 <paramref name="start" /> + <paramref name="length" /> 不在 <paramref name="segment" /> 的範圍內。</exception>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Range)">
      <summary>在使用範圍開始和結束索引的目標陣列區段部分上建立新範圍</summary>
      <param name="segment">目標陣列區段。</param>
      <param name="range">具有開始和結束索引以用於切割陣列的範圍。</param>
      <typeparam name="T">陣列區段的類型。</typeparam>
      <returns>陣列區段的範圍表示。</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``1(System.ReadOnlySpan{``0},System.IComparable{``0})">
      <summary>使用指定的 <see cref="T:System.IComparable`1" /> 泛型介面，在整個已排序的 <see cref="T:System.ReadOnlySpan`1" /> 中搜尋值。</summary>
      <param name="span">要搜尋的已排序 <see cref="T:System.ReadOnlySpan`1" />。</param>
      <param name="comparable">比較時所要使用的 <see cref="T:System.IComparable`1" />。</param>
      <typeparam name="T">範圍的元素類型。</typeparam>
      <returns>如果有找到 <paramref name="comparable" />，則為已排序的 <paramref name="span" /> 中 <paramref name="comparable" /> 之以零為起始的索引，否則便為負數，此負數為大於 <paramref name="comparable" /> 的下一個項目索引之位元補數，或者，如果沒有更大的項目，則為 <see cref="P:System.ReadOnlySpan`1.Length" /> 的位元補數。</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``1(System.Span{``0},System.IComparable{``0})">
      <summary>使用指定的 <see cref="T:System.IComparable`1" /> 泛型介面，在整個已排序的 <see cref="T:System.Span`1" /> 中搜尋值。</summary>
      <param name="span">要搜尋的已排序 <see cref="T:System.Span`1" />。</param>
      <param name="comparable">比較時所要使用的 <see cref="T:System.IComparable`1" />。</param>
      <typeparam name="T">範圍的元素類型。</typeparam>
      <returns>如果有找到 <paramref name="comparable" />，則為已排序的 <paramref name="span" /> 中 <paramref name="comparable" /> 之以零為起始的索引，否則便為負數，此負數為大於 <paramref name="comparable" /> 的下一個項目索引之位元補數，或者，如果沒有更大的項目，則為 <see cref="P:System.Span`1.Length" /> 的位元補數。</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``0,``1)">
      <summary>使用指定的 <typeparamref name="TComparer" /> 泛型型別，在整個已排序的 <see cref="T:System.ReadOnlySpan`1" /> 中搜尋指定的值。</summary>
      <param name="span">要搜尋的已排序 <see cref="T:System.ReadOnlySpan`1" />。</param>
      <param name="value">要尋找的物件。 參考類型的值可以是 <see langword="null" />。</param>
      <param name="comparer">比較時所要使用的 <typeparamref name="TComparer" />。</param>
      <typeparam name="T">範圍的元素類型。</typeparam>
      <typeparam name="TComparer">的特定類型<see cref="T:System.Collections.Generic.IComparer`1" />。</typeparam>
      <returns>如果有找到 <paramref name="value" />，則為已排序的 <paramref name="span" /> 中 <paramref name="value" /> 之以零為起始的索引，否則便為負數，此負數為大於 <paramref name="value" /> 的下一個項目索引之位元補數，或者，如果沒有更大的項目，則為 <see cref="P:System.ReadOnlySpan`1.Length" /> 的位元補數。</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparer" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``1)">
      <summary>使用指定的 <typeparamref name="TComparable" /> 泛型型別，在整個已排序的 <see cref="T:System.ReadOnlySpan`1" /> 中搜尋值。</summary>
      <param name="span">要搜尋的已排序 <see cref="T:System.ReadOnlySpan`1" />。</param>
      <param name="comparable">比較時所要使用的 <typeparamref name="TComparable" />。</param>
      <typeparam name="T">範圍的元素類型。</typeparam>
      <typeparam name="TComparable">的特定類型<see cref="T:System.IComparable`1" />。</typeparam>
      <returns>如果有找到 <paramref name="comparable" />，則為已排序的 <paramref name="span" /> 中 <paramref name="comparable" /> 之以零為起始的索引，否則便為負數，此負數為大於 <paramref name="comparable" /> 的下一個項目索引之位元補數，或者，如果沒有更大的項目，則為 <see cref="P:System.ReadOnlySpan`1.Length" /> 的位元補數。</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``0,``1)">
      <summary>使用指定的 <typeparamref name="TComparer" /> 泛型型別，在整個已排序的 <see cref="T:System.Span`1" /> 中搜尋指定的值。</summary>
      <param name="span">要搜尋的已排序 <see cref="T:System.Span`1" />。</param>
      <param name="value">要尋找的物件。 參考類型的值可以是 <see langword="null" />。</param>
      <param name="comparer">比較時所要使用的 <typeparamref name="TComparer" />。</param>
      <typeparam name="T">範圍的元素類型。</typeparam>
      <typeparam name="TComparer">的特定類型<see cref="T:System.Collections.Generic.IComparer`1" />。</typeparam>
      <returns>如果有找到 <paramref name="value" />，則為已排序的 <paramref name="span" /> 中 <paramref name="value" /> 之以零為起始的索引，否則便為負數，此負數為大於 <paramref name="value" /> 的下一個項目索引之位元補數，或者，如果沒有更大的項目，則為 <see cref="P:System.Span`1.Length" /> 的位元補數。</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparer" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``1)">
      <summary>使用指定的 <typeparamref name="TComparable" /> 泛型型別，在整個已排序的 <see cref="T:System.Span`1" /> 中搜尋值。</summary>
      <param name="span">要搜尋的已排序 <see cref="T:System.Span`1" />。</param>
      <param name="comparable">比較時所要使用的 <typeparamref name="TComparable" />。</param>
      <typeparam name="T">範圍的元素類型。</typeparam>
      <typeparam name="TComparable">的特定類型<see cref="T:System.IComparable`1" />。</typeparam>
      <returns>如果有找到 <paramref name="comparable" />，則為已排序的 <paramref name="span" /> 中 <paramref name="comparable" /> 之以零為起始的索引，否則便為負數，此負數為大於 <paramref name="comparable" /> 的下一個項目索引之位元補數，或者，如果沒有更大的項目，則為 <see cref="P:System.Span`1.Length" /> 的位元補數。</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="M:System.MemoryExtensions.CompareTo(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>使用指定的字串比較來比較一個字元範圍與另一個字元範圍，並傳回一個整數，表示兩者在排序次序中的相對位置。</summary>
      <param name="span">來源範圍。</param>
      <param name="other">要與來源範圍比較的值。</param>
      <param name="comparisonType">決定如何比較 <paramref name="span" /> 和 <paramref name="other" /> 的列舉值。</param>
      <returns>帶正負號的整數，表示 <paramref name="span" /> 和 <paramref name="other" /> 的相對順序：   - 如果小於 0，則 <paramref name="span" /> 在 <paramref name="other" /> 之前。   - 如果為 0，<paramref name="span" /> 等於 <paramref name="other" />。   - 如果大於 0，則 <paramref name="span" /> 在 <paramref name="other" /> 之後。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>指出指定的值是否出現在唯讀字元範圍內。</summary>
      <param name="span">來源範圍。</param>
      <param name="value">要在來源範圍內搜尋的值。</param>
      <param name="comparisonType">決定如何比較 <paramref name="span" /> 中字元和 <paramref name="value" /> 的列舉值。</param>
      <returns>若 <paramref name="value" /> 出現在範圍內，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains``1(System.ReadOnlySpan{``0},``0)">
      <summary>指出是否在唯讀範圍中找到指定的值。 值是使用 IEquatable{T}.Equals(T) 來進行比較。</summary>
      <param name="span">要搜尋的範圍。</param>
      <param name="value">要搜尋的值。</param>
      <typeparam name="T">範圍的類型。</typeparam>
      <returns>若找到，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains``1(System.Span{``0},``0)">
      <summary>指出是否在範圍中找到指定的值。 值是使用 IEquatable{T}.Equals(T) 來進行比較。</summary>
      <param name="span">要搜尋的範圍。</param>
      <param name="value">要搜尋的值。</param>
      <typeparam name="T">範圍中元素的類型。</typeparam>
      <returns>若找到，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Memory{``0})">
      <summary>將陣列的內容複製到記憶體區域。</summary>
      <param name="source">要從中複製項目的陣列。</param>
      <param name="destination">要將項目複製到其中的記憶體。</param>
      <typeparam name="T">陣列的類型。</typeparam>
      <exception cref="T:System.ArgumentException">目的地比來源陣列短。</exception>
    </member>
    <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Span{``0})">
      <summary>將陣列的內容複製到範圍。</summary>
      <param name="source">要從中複製項目的陣列。</param>
      <param name="destination">要將項目複製到其中的範圍。</param>
      <typeparam name="T">陣列的類型。</typeparam>
      <exception cref="T:System.ArgumentException">目的地範圍比來源陣列短。</exception>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>判斷當使用指定的 <paramref name="comparisonType" /> 選項進行比較時，<paramref name="span" /> 結尾是否符合指定的 <paramref name="value" />。</summary>
      <param name="span">來源範圍。</param>
      <param name="value">要和來源範圍結尾比較的序列。</param>
      <param name="comparisonType">決定如何比較 <paramref name="span" /> 和 <paramref name="value" /> 的列舉值。</param>
      <returns>若 <paramref name="value" /> 符合 <paramref name="span" /> 的結尾．則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>判斷所指定序列是否出現在唯讀範圍的結尾。</summary>
      <param name="span">來源範圍。</param>
      <param name="value">要和來源範圍結尾比較的序列。</param>
      <typeparam name="T">範圍的類型。</typeparam>
      <returns>若 <paramref name="value" /> 符合 <paramref name="span" /> 的結尾，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>判斷所指定序列是否出現在範圍的結尾。</summary>
      <param name="span">來源範圍。</param>
      <param name="value">要和來源範圍結尾比較的序列。</param>
      <typeparam name="T">範圍的類型。</typeparam>
      <returns>若 <paramref name="value" /> 符合 <paramref name="span" /> 的結尾，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.EnumerateRunes(System.ReadOnlySpan{System.Char})">
      <summary>從所提供唯讀範圍傳回 <see cref="T:System.Text.Rune" /> 的列舉。</summary>
      <param name="span">來源範圍。</param>
      <returns>Rune 列舉值。</returns>
    </member>
    <member name="M:System.MemoryExtensions.EnumerateRunes(System.Span{System.Char})">
      <summary>從所提供範圍傳回 <see cref="T:System.Text.Rune" /> 的列舉。</summary>
      <param name="span">來源範圍。</param>
      <returns>Rune 列舉值。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Equals(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>判斷當使用指定的 <paramref name="comparisonType" /> 選項進行比較時，這個 <paramref name="span" /> 和指定的 <paramref name="other" /> 範圍是否具有相同字元。</summary>
      <param name="span">來源範圍。</param>
      <param name="other">要與來源範圍比較的值。</param>
      <param name="comparisonType">決定如何比較 <paramref name="span" /> 和 <paramref name="other" /> 的列舉值。</param>
      <returns>若相等，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>報告目前 <paramref name="span" /> 中指定 <paramref name="value" /> 第一個出現位置的以零起始索引。</summary>
      <param name="span">來源範圍。</param>
      <param name="value">要在來源範圍內搜尋的值。</param>
      <param name="comparisonType">決定如何比較 <paramref name="span" /> 和 <paramref name="value" /> 的列舉值。</param>
      <returns>範圍中值出現位置的索引。</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},``0)">
      <summary>搜尋指定的值，並傳回第一個出現位置的索引。 值是使用 IEquatable{T}.Equals(T) 來進行比較。</summary>
      <param name="span">要搜尋的範圍。</param>
      <param name="value">要搜尋的值。</param>
      <typeparam name="T">範圍和值的類型。</typeparam>
      <returns>範圍中值出現位置的索引。 如果找不到，則傳回 -1。</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>搜尋指定的序列，並傳回第一個出現位置的索引。 值是使用 IEquatable{T}.Equals(T) 來進行比較。</summary>
      <param name="span">要搜尋的範圍。</param>
      <param name="value">要搜尋的序列。</param>
      <typeparam name="T">範圍和值的類型。</typeparam>
      <returns>範圍中值出現位置的索引。 如果找不到，則傳回 -1。</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},``0)">
      <summary>搜尋指定的值，並傳回第一個出現位置的索引。 值是使用 IEquatable{T}.Equals(T) 來進行比較。</summary>
      <param name="span">要搜尋的範圍。</param>
      <param name="value">要搜尋的值。</param>
      <typeparam name="T">範圍和值的類型。</typeparam>
      <returns>範圍中值出現位置的索引。 如果找不到，則傳回 -1。</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>搜尋指定的序列，並傳回第一個出現位置的索引。 值是使用 IEquatable{T}.Equals(T) 來進行比較。</summary>
      <param name="span">要搜尋的範圍。</param>
      <param name="value">要搜尋的序列。</param>
      <typeparam name="T">範圍和值的類型。</typeparam>
      <returns>範圍中值出現位置的索引。 如果找不到，則傳回 -1。</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
      <summary>搜尋任何指定值的第一個索引，類似於使用邏輯 OR 運算子呼叫 IndexOf 多次。</summary>
      <param name="span">要搜尋的範圍。</param>
      <param name="value0">要搜尋的其中一個值。</param>
      <param name="value1">要搜尋的其中一個值。</param>
      <typeparam name="T">範圍和值的類型。</typeparam>
      <returns>範圍中任何值出現位置的第一個索引。 如果找不到，則傳回 -1。</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
      <summary>搜尋任何指定值的第一個索引，類似於使用邏輯 OR 運算子呼叫 IndexOf 多次。</summary>
      <param name="span">要搜尋的範圍。</param>
      <param name="value0">要搜尋的其中一個值。</param>
      <param name="value1">要搜尋的其中一個值。</param>
      <param name="value2">要搜尋的其中一個值。</param>
      <typeparam name="T">範圍和值的類型。</typeparam>
      <returns>範圍中任何值出現位置的第一個索引。 如果找不到，則傳回 -1。</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>搜尋任何指定值的第一個索引，類似於使用邏輯 OR 運算子呼叫 IndexOf 多次。</summary>
      <param name="span">要搜尋的範圍。</param>
      <param name="values">要搜尋的值集合。</param>
      <typeparam name="T">範圍和值的類型。</typeparam>
      <returns>範圍中任何值出現位置的第一個索引。 如果找不到，則傳回 -1。</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0)">
      <summary>搜尋任何指定值的第一個索引，類似於使用邏輯 OR 運算子呼叫 IndexOf 多次。</summary>
      <param name="span">要搜尋的範圍。</param>
      <param name="value0">要搜尋的其中一個值。</param>
      <param name="value1">要搜尋的其中一個值。</param>
      <typeparam name="T">範圍和值的類型。</typeparam>
      <returns>範圍中任何值出現位置的第一個索引。 如果找不到，則傳回 -1。</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0,``0)">
      <summary>搜尋任何指定值的第一個索引，類似於使用邏輯 OR 運算子呼叫 IndexOf 多次。</summary>
      <param name="span">要搜尋的範圍。</param>
      <param name="value0">要搜尋的其中一個值。</param>
      <param name="value1">要搜尋的其中一個值。</param>
      <param name="value2">要搜尋的其中一個值。</param>
      <typeparam name="T">範圍和值的類型。</typeparam>
      <returns>範圍中任何值出現位置的第一個索引。 如果找不到，則傳回 -1。</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>搜尋任何指定值的第一個索引，類似於使用邏輯 OR 運算子呼叫 IndexOf 多次。</summary>
      <param name="span">要搜尋的範圍。</param>
      <param name="values">要搜尋的值集合。</param>
      <typeparam name="T">範圍和值的類型。</typeparam>
      <returns>範圍中任何值出現位置的第一個索引。 如果找不到，則傳回 -1。</returns>
    </member>
    <member name="M:System.MemoryExtensions.IsWhiteSpace(System.ReadOnlySpan{System.Char})">
      <summary>指出指定的範圍是否只包含空白字元。</summary>
      <param name="span">來源範圍。</param>
      <returns>若範圍只包含空白字元，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>報告目前 <paramref name="span" /> 中指定 <paramref name="value" /> 最後一個出現位置的以零起始索引。</summary>
      <param name="span">來源範圍。</param>
      <param name="value">要在來源範圍內搜尋的值。</param>
      <param name="comparisonType">決定如何比較 <paramref name="span" /> 和 <paramref name="value" /> 的列舉值。</param>
      <returns>範圍中值最後一個出現位置的索引。</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},``0)">
      <summary>搜尋指定的值，並傳回最後一個出現位置的索引。 值是使用 IEquatable{T}.Equals(T) 來進行比較。</summary>
      <param name="span">要搜尋的範圍。</param>
      <param name="value">要搜尋的值。</param>
      <typeparam name="T">範圍和值的類型。</typeparam>
      <returns>範圍中值最後一個出現位置的索引。 如果找不到，則傳回 -1。</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>搜尋指定的序列，並傳回最後一個出現位置的索引。 值是使用 IEquatable{T}.Equals(T) 來進行比較。</summary>
      <param name="span">要搜尋的範圍。</param>
      <param name="value">要搜尋的序列。</param>
      <typeparam name="T">範圍和值的類型。</typeparam>
      <returns>範圍中值最後一個出現位置的索引。 如果找不到，則傳回 -1。</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},``0)">
      <summary>搜尋指定的值，並傳回最後一個出現位置的索引。 值是使用 IEquatable{T}.Equals(T) 來進行比較。</summary>
      <param name="span">要搜尋的範圍。</param>
      <param name="value">要搜尋的值。</param>
      <typeparam name="T">範圍和值的類型。</typeparam>
      <returns>範圍中值最後一個出現位置的索引。 如果找不到，則傳回 -1。</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>搜尋指定的序列，並傳回最後一個出現位置的索引。 值是使用 IEquatable{T}.Equals(T) 來進行比較。</summary>
      <param name="span">要搜尋的範圍。</param>
      <param name="value">要搜尋的序列。</param>
      <typeparam name="T">範圍和值的類型。</typeparam>
      <returns>範圍中值最後一個出現位置的索引。 如果找不到，則傳回 -1。</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
      <summary>搜尋任何指定值的最後一個索引，類似於使用邏輯 OR 運算子呼叫 LastIndexOf 多次。</summary>
      <param name="span">要搜尋的範圍。</param>
      <param name="value0">要搜尋的其中一個值。</param>
      <param name="value1">要搜尋的其中一個值。</param>
      <typeparam name="T">範圍和值的類型。</typeparam>
      <returns>範圍中任何值最後一個出現位置的索引。 如果找不到，則傳回 -1。</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
      <summary>搜尋任何指定值的最後一個索引，類似於使用邏輯 OR 運算子呼叫 LastIndexOf 多次。</summary>
      <param name="span">要搜尋的範圍。</param>
      <param name="value0">要搜尋的其中一個值。</param>
      <param name="value1">要搜尋的其中一個值。</param>
      <param name="value2">要搜尋的其中一個值。</param>
      <typeparam name="T">範圍和值的類型。</typeparam>
      <returns>範圍中任何值最後一個出現位置的索引。 如果找不到，則傳回 -1。</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>搜尋任何指定值的最後一個索引，類似於使用邏輯 OR 運算子呼叫 LastIndexOf 多次。</summary>
      <param name="span">要搜尋的範圍。</param>
      <param name="values">要搜尋的值集合。</param>
      <typeparam name="T">範圍和值的類型。</typeparam>
      <returns>範圍中任何值最後一個出現位置的索引。 如果找不到，則傳回 -1。</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0)">
      <summary>搜尋任何指定值的最後一個索引，類似於使用邏輯 OR 運算子呼叫 LastIndexOf 多次。</summary>
      <param name="span">要搜尋的範圍。</param>
      <param name="value0">要搜尋的其中一個值。</param>
      <param name="value1">要搜尋的其中一個值。</param>
      <typeparam name="T">範圍和值的類型。</typeparam>
      <returns>範圍中任何值最後一個出現位置的索引。 如果找不到，則傳回 -1。</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0,``0)">
      <summary>搜尋任何指定值的最後一個索引，類似於使用邏輯 OR 運算子呼叫 LastIndexOf 多次。</summary>
      <param name="span">要搜尋的範圍。</param>
      <param name="value0">要搜尋的其中一個值。</param>
      <param name="value1">要搜尋的其中一個值。</param>
      <param name="value2">要搜尋的其中一個值。</param>
      <typeparam name="T">範圍和值的類型。</typeparam>
      <returns>範圍中任何值最後一個出現位置的索引。 如果找不到，則傳回 -1。</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>搜尋任何指定值的最後一個索引，類似於使用邏輯 OR 運算子呼叫 LastIndexOf 多次。</summary>
      <param name="span">要搜尋的範圍。</param>
      <param name="values">要搜尋的值集合。</param>
      <typeparam name="T">範圍和值的類型。</typeparam>
      <returns>範圍中任何值最後一個出現位置的索引。 如果找不到，則傳回 -1。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>判斷兩個唯讀序列在記憶體中是否重疊。</summary>
      <param name="span">第一個序列。</param>
      <param name="other">第二個序列。</param>
      <typeparam name="T">唯讀順序中的欲類型。</typeparam>
      <returns>若兩個序列重疊，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Int32@)">
      <summary>判斷兩個唯讀序列在記憶體中是否重疊，並輸出元素位移。</summary>
      <param name="span">第一個序列。</param>
      <param name="other">第二個序列。</param>
      <param name="elementOffset" />
      <typeparam name="T">範圍中元素的類型。</typeparam>
      <returns>若兩個序列重疊，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>判斷一個範圍和一個唯讀範圍在記憶體中是否重疊。</summary>
      <param name="span">要比較的範圍。</param>
      <param name="other">要比較的唯讀範圍。</param>
      <typeparam name="T">範圍中元素的類型。</typeparam>
      <returns>若兩個序列重疊，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0},System.Int32@)">
      <summary>判斷一個範圍和一個唯讀範圍在記憶體中是否重疊，並輸出元素位移。</summary>
      <param name="span">要比較的第一個序列。</param>
      <param name="other">要比較的第二個序列。</param>
      <param name="elementOffset">當這個方法傳回時，會包含 <paramref name="span" /> 和 <paramref name="other" /> 之間的位移。</param>
      <typeparam name="T">範圍中元素的類型。</typeparam>
      <returns>若兩個序列重疊，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Reverse``1(System.Span{``0})">
      <summary>反轉整個範圍中的元素順序。</summary>
      <param name="span">要反轉的範圍。</param>
      <typeparam name="T">範圍中元素的類型。</typeparam>
    </member>
    <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>使用 IComparable{T}.CompareTo(T) 來比較其元素，判斷兩個唯讀序列的相對順序。</summary>
      <param name="span">要比較的第一個序列。</param>
      <param name="other">要比較的第二個序列。</param>
      <typeparam name="T">序列中元素的類型。</typeparam>
      <returns>帶正負號的整數，表示 <paramref name="span" /> 和 <paramref name="other" /> 的相對順序：   - 如果小於 0，則 <paramref name="span" /> 在 <paramref name="other" /> 之前。   - 如果為 0，<paramref name="span" /> 等於 <paramref name="other" />。   - 如果大於 0，則 <paramref name="span" /> 在 <paramref name="other" /> 之後。</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>使用 IComparable{T}.CompareTo(T) 來比較元素，判斷一個範圍和一個唯讀範圍的相對順序。</summary>
      <param name="span">要比較的範圍。</param>
      <param name="other">要比較的唯讀範圍。</param>
      <typeparam name="T">範圍中元素的類型。</typeparam>
      <returns>帶正負號的整數，表示 <paramref name="span" /> 和 <paramref name="other" /> 的相對順序：   - 如果小於 0，則 <paramref name="span" /> 在 <paramref name="other" /> 之前。   - 如果為 0，<paramref name="span" /> 等於 <paramref name="other" />。   - 如果大於 0，則 <paramref name="span" /> 在 <paramref name="other" /> 之後。</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceEqual``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>使用 IEquatable{T}.Equals(T) 來比較元素，判斷兩個唯讀序列是否相等。</summary>
      <param name="span">要比較的第一個序列。</param>
      <param name="other">要比較的第二個序列。</param>
      <typeparam name="T">序列中元素的類型。</typeparam>
      <returns>若兩個序列相等，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceEqual``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>使用 IEquatable{T}.Equals(T) 來比較元素，判斷一個範圍和一個唯讀範圍是否相等。</summary>
      <param name="span">要比較的範圍。</param>
      <param name="other">要比較的唯讀範圍。</param>
      <typeparam name="T">序列中元素的類型。</typeparam>
      <returns>若兩個序列相等，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>判斷當使用指定的 <see cref="T:System.StringComparison" /> 值進行比較時，唯讀字元範圍是否以指定的值開始。</summary>
      <param name="span">來源範圍。</param>
      <param name="value">要和來源範圍開頭比較的序列。</param>
      <param name="comparisonType">決定如何比較 <paramref name="span" /> 和 <paramref name="value" /> 的列舉值。</param>
      <returns>若 <paramref name="value" /> 符合 <paramref name="span" /> 的開頭，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>判斷所指定序列是否出現在唯讀範圍的開頭。</summary>
      <param name="span">要搜尋的唯讀字元範圍。</param>
      <param name="value">要在 <paramref name="span" /> 開頭搜尋的序列。</param>
      <typeparam name="T">範圍中元素的類型。</typeparam>
      <returns>若 <paramref name="value" /> 符合 <paramref name="span" /> 的開頭，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>判斷所指定序列是否出現在範圍的開頭。</summary>
      <param name="span">要搜尋的範圍。</param>
      <param name="value">要在 <paramref name="span" /> 開頭搜尋的序列。</param>
      <typeparam name="T">範圍中元素的類型。</typeparam>
      <returns>若 <paramref name="value" /> 符合 <paramref name="span" /> 的開頭，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToLower(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
      <summary>將字元從來源範圍複製到目的地，並使用指定文化特性的大小寫規則將每個字元轉換成小寫。</summary>
      <param name="source">來源範圍。</param>
      <param name="destination">目的地範圍，其中包含已轉換的字元。</param>
      <param name="culture">提供文化特性大小寫規則的物件。</param>
      <returns>寫入目的地範圍的字元數。 如果目的地太小，則傳回 -1。</returns>
      <exception cref="T:System.InvalidOperationException">來源和目的地緩衝區重疊。</exception>
    </member>
    <member name="M:System.MemoryExtensions.ToLowerInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
      <summary>將字元從來源範圍複製到目的地，並使用不因文化特性而異的大小寫規則將每個字元轉換成小寫。</summary>
      <param name="source">來源範圍。</param>
      <param name="destination">目的地範圍，其中包含已轉換的字元。</param>
      <returns>寫入目的地範圍的字元數。 如果目的地太小，則傳回 -1。</returns>
      <exception cref="T:System.InvalidOperationException">來源和目的地緩衝區重疊。</exception>
    </member>
    <member name="M:System.MemoryExtensions.ToUpper(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
      <summary>將字元從來源範圍複製到目的地，並使用指定文化特性的大小寫規則將每個字元轉換成大寫。</summary>
      <param name="source">來源範圍。</param>
      <param name="destination">目的地範圍，其中包含已轉換的字元。</param>
      <param name="culture">提供文化特性大小寫規則的物件。</param>
      <returns>寫入目的地範圍的字元數。 如果目的地太小，則傳回 -1。</returns>
      <exception cref="T:System.InvalidOperationException">來源和目的地緩衝區重疊。</exception>
    </member>
    <member name="M:System.MemoryExtensions.ToUpperInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
      <summary>將字元從來源範圍複製到目的地，並使用不因文化特性而異的大小寫規則將每個字元轉換成大寫。</summary>
      <param name="source">來源範圍。</param>
      <param name="destination">目的地範圍，其中包含已轉換的字元。</param>
      <returns>寫入目的地範圍的字元數。 如果目的地太小，則傳回 -1。</returns>
      <exception cref="T:System.InvalidOperationException">來源和目的地緩衝區重疊。</exception>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.Memory{System.Char})">
      <summary>從字元記憶體區域中移除所有開頭和尾端空白字元。</summary>
      <param name="memory">要從中移除字元的來源記憶體。</param>
      <returns>修剪的字元記憶體區域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlyMemory{System.Char})">
      <summary>從唯讀字元記憶體區域中移除所有開頭和尾端空白字元。</summary>
      <param name="memory">要從中移除字元的來源記憶體。</param>
      <returns>修剪的字元記憶體區域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char})">
      <summary>從唯讀字元範圍中移除所有開頭和尾端空白字元。</summary>
      <param name="span">要從中移除字元的來源範圍。</param>
      <returns>修剪的唯讀字元範圍。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.Char)">
      <summary>從唯讀字元範圍中移除所有開頭和尾端指定字元項目。</summary>
      <param name="span">要從中移除字元的來源範圍。</param>
      <param name="trimChar">要尋找並移除的指定字元。</param>
      <returns>修剪的唯讀字元範圍。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>從唯讀字元範圍中移除唯讀範圍中指定的所有開頭和尾端字元集項目。</summary>
      <param name="span">要從中移除字元的來源範圍。</param>
      <param name="trimChars">範圍，其中包含要移除的字元集。</param>
      <returns>修剪的唯讀字元範圍。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.Span{System.Char})">
      <summary>從字元範圍中移除所有開頭和尾端空白字元。</summary>
      <param name="span">要從中移除字元的來源範圍。</param>
      <returns>修剪的字元範圍。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Memory{``0},``0)">
      <summary>從記憶體區域中移除所有開頭和尾端指定元素項目。</summary>
      <param name="memory">要從中移除元素的來源記憶體。</param>
      <param name="trimElement">要尋找並移除的指定元素。</param>
      <typeparam name="T">記憶體區域中元素的類型。</typeparam>
      <returns>修剪的記憶體區域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary>從記憶體區域中移除唯讀範圍中指定的所有開頭和尾端元素集項目。</summary>
      <param name="memory">要從中移除元素的來源記憶體。</param>
      <param name="trimElements">範圍，其中包含要移除的元素集。</param>
      <typeparam name="T">記憶體區域中元素的類型。</typeparam>
      <returns>修剪的記憶體區域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},``0)">
      <summary>從唯讀記憶體區域中移除所有開頭和尾端指定元素項目。</summary>
      <param name="memory">要從中移除元素的來源記憶體。</param>
      <param name="trimElement">要尋找並移除的指定元素。</param>
      <typeparam name="T">唯讀記憶體區域中元素的類型。</typeparam>
      <returns>修剪的唯讀記憶體區域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary>從唯讀記憶體區域中移除唯讀範圍中指定的所有開頭和尾端元素集項目。</summary>
      <param name="memory">要從中移除元素的來源記憶體。</param>
      <param name="trimElements">範圍，其中包含要移除的元素集。</param>
      <typeparam name="T">唯讀記憶體區域中元素的類型。</typeparam>
      <returns>修剪的唯讀記憶體區域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},``0)">
      <summary>從唯讀範圍中移除所有開頭和尾端指定元素項目。</summary>
      <param name="span">要從中移除元素的來源範圍。</param>
      <param name="trimElement">要尋找並移除的指定元素。</param>
      <typeparam name="T">唯讀範圍中元素的類型。</typeparam>
      <returns>修剪的唯讀範圍。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>從唯讀範圍中移除唯讀範圍中指定的所有開頭和尾端元素集項目。</summary>
      <param name="span">要從中移除元素的來源範圍。</param>
      <param name="trimElements">範圍，其中包含要移除的元素集。</param>
      <typeparam name="T">唯讀範圍中元素的類型。</typeparam>
      <returns>修剪的唯讀範圍。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Span{``0},``0)">
      <summary>從範圍中移除所有開頭和尾端指定元素項目。</summary>
      <param name="span">要從中移除元素的來源範圍。</param>
      <param name="trimElement">要尋找並移除的指定元素。</param>
      <typeparam name="T">範圍中元素的類型。</typeparam>
      <returns>修剪的範圍。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>從範圍中移除唯讀範圍中指定的所有開頭和尾端元素集項目。</summary>
      <param name="span">要從中移除元素的來源範圍。</param>
      <param name="trimElements">範圍，其中包含要移除的元素集。</param>
      <typeparam name="T">範圍中元素的類型。</typeparam>
      <returns>修剪的範圍。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.Memory{System.Char})">
      <summary>從字元記憶體區域中移除所有尾端空白字元。</summary>
      <param name="memory">要從中移除字元的來源記憶體。</param>
      <returns>修剪的字元記憶體區域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlyMemory{System.Char})">
      <summary>從唯讀字元記憶體區域中移除所有尾端空白字元。</summary>
      <param name="memory">要從中移除字元的來源記憶體。</param>
      <returns>修剪的唯讀字元範圍。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char})">
      <summary>從唯讀字元範圍中移除所有尾端空白字元。</summary>
      <param name="span">要從中移除字元的來源範圍。</param>
      <returns>修剪的唯讀字元範圍。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.Char)">
      <summary>從唯讀範圍中移除所有尾端指定字元項目。</summary>
      <param name="span">要從中移除字元的來源範圍。</param>
      <param name="trimChar">要尋找並移除的指定字元。</param>
      <returns>修剪的唯讀字元範圍。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>從唯讀字元範圍中移除唯讀範圍中指定的所有尾端字元集項目。</summary>
      <param name="span">要從中移除字元的來源範圍。</param>
      <param name="trimChars">範圍，其中包含要移除的字元集。</param>
      <returns>修剪的唯讀字元範圍。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.Span{System.Char})">
      <summary>從字元範圍中移除所有尾端空白字元。</summary>
      <param name="span">要從中移除字元的來源範圍。</param>
      <returns>修剪的字元範圍。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},``0)">
      <summary>從字元記憶體區域中移除所有尾端指定元素項目。</summary>
      <param name="memory">要從中移除元素的來源記憶體。</param>
      <param name="trimElement">要尋找並移除的指定元素。</param>
      <typeparam name="T">記憶體區域中元素的類型。</typeparam>
      <returns>修剪的記憶體區域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary>從記憶體區域中移除唯讀範圍中指定的所有尾端元素集項目。</summary>
      <param name="memory">要從中移除元素的來源記憶體。</param>
      <param name="trimElements">範圍，其中包含要移除的元素集。</param>
      <typeparam name="T">記憶體區域中元素的類型。</typeparam>
      <returns>修剪的記憶體區域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},``0)">
      <summary>從唯讀記憶體區域中移除所有尾端指定元素項目。</summary>
      <param name="memory">要從中移除元素的來源記憶體。</param>
      <param name="trimElement">要尋找並移除的指定元素。</param>
      <typeparam name="T">唯讀記憶體區域中元素的類型。</typeparam>
      <returns>修剪的唯讀記憶體區域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary>從唯讀記憶體區域中移除唯讀範圍中指定的所有尾端元素集項目。</summary>
      <param name="memory">要從中移除元素的來源記憶體。</param>
      <param name="trimElements">範圍，其中包含要移除的元素集。</param>
      <typeparam name="T">唯讀記憶體區域中元素的類型。</typeparam>
      <returns>修剪的唯讀記憶體區域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},``0)">
      <summary>從唯讀範圍中移除所有尾端指定元素項目。</summary>
      <param name="span">要從中移除元素的來源範圍。</param>
      <param name="trimElement">要尋找並移除的指定元素。</param>
      <typeparam name="T">唯讀範圍中元素的類型。</typeparam>
      <returns>修剪的唯讀範圍。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>從唯讀範圍中移除唯讀範圍中指定的所有尾端元素集項目。</summary>
      <param name="span">要從中移除元素的來源範圍。</param>
      <param name="trimElements">範圍，其中包含要移除的元素集。</param>
      <typeparam name="T">唯讀範圍中元素的類型。</typeparam>
      <returns>修剪的唯讀範圍。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},``0)">
      <summary>從範圍中移除所有尾端指定元素項目。</summary>
      <param name="span">要從中移除元素的來源範圍。</param>
      <param name="trimElement">要尋找並移除的指定元素。</param>
      <typeparam name="T">範圍中元素的類型。</typeparam>
      <returns>修剪的範圍。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>從範圍中移除唯讀範圍中指定的所有尾端元素集項目。</summary>
      <param name="span">要從中移除元素的來源範圍。</param>
      <param name="trimElements">範圍，其中包含要移除的元素集。</param>
      <typeparam name="T">範圍中元素的類型。</typeparam>
      <returns>修剪的範圍。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.Memory{System.Char})">
      <summary>從記憶體區域中移除所有開頭空白字元。</summary>
      <param name="memory">要從中移除字元的來源記憶體。</param>
      <returns>修剪的字元記憶體區域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlyMemory{System.Char})">
      <summary>從唯讀記憶體區域中移除所有開頭空白字元。</summary>
      <param name="memory">要從中移除字元的來源記憶體。</param>
      <returns>修剪的唯讀字元記憶體區域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char})">
      <summary>從唯讀範圍中移除所有開頭空白字元。</summary>
      <param name="span">要從中移除字元的來源範圍。</param>
      <returns>修剪的唯讀字元範圍。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.Char)">
      <summary>從範圍中移除所有開頭指定字元項目。</summary>
      <param name="span">要從中移除字元的來源範圍。</param>
      <param name="trimChar">要尋找並移除的指定字元。</param>
      <returns>修剪的唯讀字元範圍。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>從範圍中移除唯讀範圍中指定的所有開頭字元集項目。</summary>
      <param name="span">要從中移除字元的來源範圍。</param>
      <param name="trimChars">範圍，其中包含要移除的字元集。</param>
      <returns>修剪的唯讀字元範圍。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.Span{System.Char})">
      <summary>從範圍中移除所有開頭空白字元。</summary>
      <param name="span">要從中移除字元的來源範圍。</param>
      <returns>修剪的字元範圍。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},``0)">
      <summary>從記憶體區域中移除所有開頭指定元素項目。</summary>
      <param name="memory">要從中移除元素的來源記憶體區域。</param>
      <param name="trimElement">要尋找並移除的指定元素。</param>
      <typeparam name="T">記憶體區域中元素的類型。</typeparam>
      <returns>修剪的記憶體區域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary>從記憶體區域中移除唯讀範圍中指定的所有開頭元素集項目。</summary>
      <param name="memory">要從中移除元素的來源記憶體。</param>
      <param name="trimElements">範圍，其中包含要移除的元素集。</param>
      <typeparam name="T">記憶體區域中元素的類型。</typeparam>
      <returns>修剪的記憶體區域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},``0)">
      <summary>從記憶體區域中移除所有開頭指定元素項目。</summary>
      <param name="memory">要從中移除元素的來源記憶體。</param>
      <param name="trimElement">要尋找並移除的指定元素。</param>
      <typeparam name="T">唯讀記憶體區域中元素的類型。</typeparam>
      <returns>修剪的唯讀記憶體區域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary>從記憶體區域中移除唯讀範圍中指定的所有開頭元素集項目。</summary>
      <param name="memory">要從中移除元素的來源記憶體。</param>
      <param name="trimElements">範圍，其中包含要移除的元素集。</param>
      <typeparam name="T">唯讀記憶體區域中元素的類型。</typeparam>
      <returns>修剪的唯讀記憶體區域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},``0)">
      <summary>從範圍中移除所有開頭指定元素項目。</summary>
      <param name="span">要從中移除元素的來源範圍。</param>
      <param name="trimElement">要尋找並移除的指定元素。</param>
      <typeparam name="T">唯讀範圍中元素的類型。</typeparam>
      <returns>修剪的唯讀範圍。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>從範圍中移除唯讀範圍中指定的所有開頭元素集項目。</summary>
      <param name="span">要從中移除元素的來源範圍。</param>
      <param name="trimElements">範圍，其中包含要移除的元素集。</param>
      <typeparam name="T">唯讀範圍中元素的類型。</typeparam>
      <returns>修剪的唯讀範圍。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},``0)">
      <summary>從範圍中移除所有開頭指定元素項目。</summary>
      <param name="span">要從中移除元素的來源範圍。</param>
      <param name="trimElement">要尋找並移除的指定元素。</param>
      <typeparam name="T">範圍中元素的類型。</typeparam>
      <returns>修剪的範圍。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>從範圍中移除唯讀範圍中指定的所有開頭元素集項目。</summary>
      <param name="span">要從中移除元素的來源範圍。</param>
      <param name="trimElements">範圍，其中包含要移除的元素集。</param>
      <typeparam name="T">範圍中元素的類型。</typeparam>
      <returns>修剪的範圍。</returns>
    </member>
    <member name="T:System.Runtime.InteropServices.MemoryMarshal">
      <summary>提供方法來與 <see cref="T:System.Memory`1" />、<see cref="T:System.ReadOnlyMemory`1" />、<see cref="T:System.Span`1" /> 和 <see cref="T:System.ReadOnlySpan`1" /> 交互操作。</summary>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.ReadOnlySpan{``0})">
      <summary>將一個簡單型別 <paramref name="T" /> 的 <see cref="T:System.ReadOnlySpan`1" /> 轉換成 <see langword="ReadOnlySpan&lt;Byte&gt;" />。</summary>
      <param name="span">要轉換的來源配量。</param>
      <typeparam name="T">唯讀範圍中的專案類型。</typeparam>
      <returns>型別 <see cref="T:System.Byte" /> 的唯讀範圍。</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> 包含參考或指標。</exception>
      <exception cref="T:System.OverflowException">新的 <see cref="T:System.ReadOnlySpan`1" /> 的 <see cref="P:System.ReadOnlySpan`1.Length" /> 屬性會超出 <see cref="F:System.Int32.MaxValue" /></exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.Span{``0})">
      <summary>將一個簡單型別 <paramref name="T" /> 的 <see cref="T:System.Span`1" /> 轉換成 <see langword="Span&lt;Byte&gt;" />。</summary>
      <param name="span">要轉換的來源配量。</param>
      <typeparam name="T">範圍中的專案類型。</typeparam>
      <returns>型別 <see cref="T:System.Byte" /> 的範圍。</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> 包含參考或指標。</exception>
      <exception cref="T:System.OverflowException">新的 <see cref="T:System.Span`1" /> 的 <see cref="P:System.Span`1.Length" /> 屬性會超出 <see cref="F:System.Int32.MaxValue" /></exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsMemory``1(System.ReadOnlyMemory{``0})">
      <summary>從 <see cref="T:System.ReadOnlyMemory`1" /> 建立 <see cref="T:System.Memory`1" /> 執行個體。</summary>
      <param name="memory">唯讀記憶體緩衝區。</param>
      <typeparam name="T">唯讀記憶體緩衝區中的專案類型。</typeparam>
      <returns>記憶體區塊，代表與 <see cref="T:System.ReadOnlyMemory`1" /> 相同的記憶體。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.ReadOnlySpan{System.Byte})">
      <summary>將唯讀範圍的位元組重新解譯為 <paramref name="T" /> 類型結構的唯讀參考。</summary>
      <param name="span">要重新解譯的唯讀範圍。</param>
      <typeparam name="T">傳回之參考的型別。</typeparam>
      <returns>
        <paramref name="T" /> 類型結構的唯讀參考。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.Span{System.Byte})">
      <summary>將位元組範圍重新解譯為 <paramref name="T" /> 類型結構的參考。</summary>
      <param name="span">要重新解譯的範圍。</param>
      <typeparam name="T">傳回之參考的型別。</typeparam>
      <returns>
        <paramref name="T" /> 類型結構的參考。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.ReadOnlySpan{``0})">
      <summary>將一個簡單型別的唯讀範圍轉換為另一個簡單型別的唯讀範圍。</summary>
      <param name="span">要轉換的來源配量。</param>
      <typeparam name="TFrom">來源範圍的類型。</typeparam>
      <typeparam name="TTo">目標範圍的類型。</typeparam>
      <returns>已轉換的唯讀範圍。</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="TFrom" /> 或 <paramref name="TTo" /> 包含參考或指標。</exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.Span{``0})">
      <summary>將一個簡單型別的範圍轉換為另一個簡單型別的範圍。</summary>
      <param name="span">要轉換的來源配量。</param>
      <typeparam name="TFrom">來源範圍的類型。</typeparam>
      <typeparam name="TTo">目標範圍的類型。</typeparam>
      <returns>已轉換的範圍。</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="TFrom" /> 或 <paramref name="TTo" /> 包含參考或指標。</exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateFromPinnedArray``1(``0[],System.Int32,System.Int32)">
      <summary>在預先定義的目標陣列上建立新的記憶體緩衝區，從 <paramref name="start" /> 索引開始，並包含 <paramref name="length" /> 個項目。</summary>
      <param name="array">預先固定的來源陣列。</param>
      <param name="start">要開始記憶體區塊的 <paramref name="array" /> 索引。</param>
      <param name="length">要包含在記憶體區塊中的項目數量。</param>
      <typeparam name="T">陣列的類型。</typeparam>
      <returns>在 <paramref name="array" /> 指定之元素上的記憶體區塊。 如果 <paramref name="array" /> 為 <see langword="null" />，或如果 <paramref name="start" /> 和 <paramref name="length" /> 為 0，方法會傳回 <see cref="P:System.Memory`1.Length" /> 為零的 <see cref="T:System.Memory`1" /> 執行個體。</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="array" /> 是 Covariant，且 <paramref name="array" /> 的型別不完全是 <paramref name="T[]" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 或結尾索引不在 0 到 <see cref="P:System.Array.Length" /> 的範圍內。</exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan``1(``0@,System.Int32)">
      <summary>在一般受控物件上建立新的唯讀範圍。</summary>
      <param name="reference">資料的參考。</param>
      <param name="length">
        <paramref name="reference" /> 包含的 <paramref name="T" /> 元素數目。</param>
      <typeparam name="T">資料項目的類型。</typeparam>
      <returns>唯讀的範圍。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateSpan``1(``0@,System.Int32)">
      <summary>在一般受控物件上建立新的範圍。</summary>
      <param name="reference">資料的參考。</param>
      <param name="length">
        <paramref name="reference" /> 包含的 <paramref name="T" /> 元素數目。</param>
      <typeparam name="T">資料項目的類型。</typeparam>
      <returns>範圍。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.ReadOnlySpan{``0})">
      <summary>傳回唯讀範圍索引位置為 0 的元素參考。</summary>
      <param name="span">擷取參考的來源唯讀範圍。</param>
      <typeparam name="T">範圍中的專案類型。</typeparam>
      <returns>索引位置為 0 的元素參考。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.Span{``0})">
      <summary>傳回範圍索引位置為 0 的元素參考。</summary>
      <param name="span">擷取參考的來源範圍。</param>
      <typeparam name="T">範圍中的專案類型。</typeparam>
      <returns>索引位置為 0 的元素參考。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Read``1(System.ReadOnlySpan{System.Byte})">
      <summary>讀取型別結構 <param name="T" /> 超出位元組的唯讀範圍。</summary>
      <param name="source">唯讀的範圍。</param>
      <typeparam name="T">要從唯讀範圍中取出的專案類型。</typeparam>
      <returns>從唯讀範圍擷取的結構。</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> 包含參考或指標。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> 小於 <paramref name="T" />。</exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.ToEnumerable``1(System.ReadOnlyMemory{``0})">
      <summary>建立指定唯讀記憶體緩衝區的 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 檢視。</summary>
      <param name="memory">唯讀記憶體緩衝區。</param>
      <typeparam name="T">唯讀記憶體緩衝區中的專案類型。</typeparam>
      <returns>
        <paramref name="memory" /> 的列舉檢視。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetArray``1(System.ReadOnlyMemory{``0},System.ArraySegment{``0}@)">
      <summary>嘗試從基礎記憶體緩衝區取得陣列區段。 傳回值指出作業是否成功。</summary>
      <param name="memory">唯讀記憶體緩衝區。</param>
      <param name="segment">當方法傳回時，會包含擷取自基礎唯讀記憶體緩衝區的陣列區段。 如果方法失敗，方法會傳回預設的陣列區段。</param>
      <typeparam name="T">唯讀記憶體緩衝區中的專案類型。</typeparam>
      <returns>如果方法呼叫成功，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@)">
      <summary>嘗試從基礎唯讀記憶體緩衝區擷取 <see cref="T:System.Buffers.MemoryManager`1" />。</summary>
      <param name="memory">要取得記憶體管理員的唯讀記憶體緩衝區。</param>
      <param name="manager">當方法傳回時，為 <paramref name="memory" /> 的管理員。</param>
      <typeparam name="T">唯讀記憶體緩衝區中的專案類型。</typeparam>
      <typeparam name="TManager">要取出的<see cref="T:System.Buffers.MemoryManager`1" />類型。</typeparam>
      <returns>如果方法已擷取記憶體管理員，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@,System.Int32@,System.Int32@)">
      <summary>嘗試從基礎唯讀記憶體緩衝區擷取 <see cref="T:System.Buffers.MemoryManager`1" />、開始索引和長度。</summary>
      <param name="memory">要取得記憶體管理員的唯讀記憶體緩衝區。</param>
      <param name="manager">當方法傳回時，為 <paramref name="memory" /> 的管理員。</param>
      <param name="start">當方法傳回時，為 <paramref name="memory" /> 所代表從 <paramref name="manager" /> 開始的位移。</param>
      <param name="length">當方法傳回時，為 <paramref name="memory" /> 所代表 <paramref name="manager" /> 的長度。</param>
      <typeparam name="T">唯讀記憶體緩衝區中的專案類型。</typeparam>
      <typeparam name="TManager">要取出的<see cref="T:System.Buffers.MemoryManager`1" />類型。</typeparam>
      <returns>如果方法成功，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetString(System.ReadOnlyMemory{System.Char},System.String@,System.Int32@,System.Int32@)">
      <summary>嘗試從 <see langword="System.ReadOnlyMemory&lt;Char&gt;" /> 取得基礎字串。</summary>
      <param name="memory">唯讀記憶體包含字元區塊。</param>
      <param name="text">當方法傳回時，記憶體緩衝區中包含的字串。</param>
      <param name="start">
        <paramref name="text" /> 中的開始位置。</param>
      <param name="length">
        <paramref name="text" /> 中的字元數目。</param>
      <returns>如果方法成功擷取基礎字串，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryRead``1(System.ReadOnlySpan{System.Byte},``0@)">
      <summary>嘗試從位元組唯讀範圍中讀取類型 <paramref name="T" /> 的結構。</summary>
      <param name="source">位元組的唯讀範圍。</param>
      <param name="value">當方法傳回時，為 <paramref name="T" /> 的執行個體。</param>
      <typeparam name="T">要取出的結構類型。</typeparam>
      <returns>如果方法成功擷取結構的執行個體則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> 包含參考或指標。</exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryWrite``1(System.Span{System.Byte},``0@)">
      <summary>嘗試將 <paramref name="T" /> 類型的結構寫入位元組範圍。</summary>
      <param name="destination">要包含結構的位元組範圍。</param>
      <param name="value">要寫入至範圍的結構。</param>
      <typeparam name="T">結構的類型。</typeparam>
      <returns>如果作業執行成功，則為 <see langword="true" />，否則為 <see langword="false" />。 如果範圍太小而無法包含 <paramref name="T" />，方法會傳回 <see langword="false" />。</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> 包含參考或指標。</exception>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Write``1(System.Span{System.Byte},``0@)">
      <summary>將類型 <paramref name="T" /> 的結構寫入位元組範圍。</summary>
      <param name="destination">要包含結構的位元組範圍。</param>
      <param name="value">要寫入至範圍的結構。</param>
      <typeparam name="T">結構的類型。</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> 包含參考或指標。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> 太小而無法包含<paramref name="value" />。</exception>
    </member>
    <member name="T:System.Runtime.InteropServices.SequenceMarshal">
      <summary>提供與 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 交互操作的方法集合。</summary>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetArray``1(System.Buffers.ReadOnlySequence{``0},System.ArraySegment{``0}@)">
      <summary>從基礎唯讀序列取得陣列區段。</summary>
      <param name="sequence">要從中擷取陣列區段的唯讀序列。</param>
      <param name="segment">傳回的陣列區段。</param>
      <typeparam name="T">唯讀序列的類型。</typeparam>
      <returns>若可以擷取陣列區段，則為 <see langword="true" />；否則為 <see langword="false" /> 並傳回預設陣列區段。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlyMemory``1(System.Buffers.ReadOnlySequence{``0},System.ReadOnlyMemory{``0}@)">
      <summary>嘗試從指定的唯讀序列擷取唯讀記憶體。</summary>
      <param name="sequence">要從中擷取記憶體的唯讀序列。</param>
      <param name="memory">傳回的 T 類型唯讀記憶體。</param>
      <typeparam name="T">唯讀序列的類型。</typeparam>
      <returns>若可以擷取唯讀記憶體，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlySequenceSegment``1(System.Buffers.ReadOnlySequence{``0},System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@,System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@)">
      <summary>嘗試從指定的唯讀序列擷取唯讀序列區段。</summary>
      <param name="sequence">要從中擷取唯讀序列區段的唯讀序列。</param>
      <param name="startSegment">起始唯讀序列區段。</param>
      <param name="startIndex">初始位置。</param>
      <param name="endSegment">結束唯讀序列區段。</param>
      <param name="endIndex">最終位置。</param>
      <typeparam name="T">唯讀序列的類型。</typeparam>
      <returns>若可以擷取唯讀序列區段，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryRead``1(System.Buffers.SequenceReader{System.Byte}@,``0@)">
      <summary>嘗試從緩衝區讀取指定的類型。 搭配任意結構使用此方法很危險；如需詳細資訊，請參閱備註。</summary>
      <param name="reader">序列讀取器的參考。</param>
      <param name="value">如果讀取成功，則為傳回值。 如果失敗 (由於空間不足)，<paramref name="value" /> 將會是 <see langword="default" />。</param>
      <typeparam name="T">值的類型。</typeparam>
      <returns>若讀取嘗試成功，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="T:System.SequencePosition">
      <summary>表示非連續記憶體集合中的位置。 此類型的屬性，不應由建立該屬性的類型來解譯。</summary>
    </member>
    <member name="M:System.SequencePosition.#ctor(System.Object,System.Int32)">
      <summary>初始化 <see cref="T:System.SequencePosition" /> 結構的新執行個體。</summary>
      <param name="object">非連續的記憶體集。</param>
      <param name="integer">
        <paramref name="object" /> 中的位置。</param>
    </member>
    <member name="M:System.SequencePosition.Equals(System.Object)">
      <summary>傳回值，這個值指出目前的執行個體是否與其他物件相等。</summary>
      <param name="obj">要與目前執行個體比較的物件。</param>
      <returns>若 <paramref name="obj" /> 為 <see cref="T:System.SequencePosition" /> 類型且等於目前的執行個體，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.SequencePosition.Equals(System.SequencePosition)">
      <summary>指出目前的執行個體和其他 <see cref="T:System.SequencePosition" /> 是否相等。</summary>
      <param name="other">要與目前執行個體比較的序列位置。</param>
      <returns>如果兩個執行個體相等，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.SequencePosition.GetHashCode">
      <summary>傳回這個執行個體的雜湊碼。</summary>
      <returns>這個執行個體的雜湊碼。</returns>
    </member>
    <member name="M:System.SequencePosition.GetInteger">
      <summary>傳回這個 <see cref="T:System.SequencePosition" /> 的整數部分。</summary>
      <returns>此序列位置的整數部分。</returns>
    </member>
    <member name="M:System.SequencePosition.GetObject">
      <summary>傳回這個 <see cref="T:System.SequencePosition" /> 的物件部分。</summary>
      <returns>此序列位置的物件部分。</returns>
    </member>
    <member name="T:System.Text.SpanRuneEnumerator">
      <summary>提供由包含 UTF-16 文字之範圍代表的 <see cref="T:System.Text.Rune" /> 值的列舉程式。</summary>
    </member>
    <member name="P:System.Text.SpanRuneEnumerator.Current">
      <summary>取得位於目前列舉程式位置的 <see cref="T:System.Text.Rune" />。</summary>
      <returns>
        <see cref="T:System.Text.Rune" />位於目前列舉值位置的。</returns>
    </member>
    <member name="M:System.Text.SpanRuneEnumerator.GetEnumerator">
      <summary>傳回目前的列舉程式執行個體。</summary>
      <returns>目前的列舉程式執行個體。</returns>
    </member>
    <member name="M:System.Text.SpanRuneEnumerator.MoveNext">
      <summary>將列舉程式前移至範圍的下一個 <see cref="T:System.Text.Rune" />。</summary>
      <returns>若列舉程式成功前移至下一個項目，則為 <see langword="true" />；若已達到範圍結尾，則為 <see langword="false" />。</returns>
    </member>
  </members>
</doc>