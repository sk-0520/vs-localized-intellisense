<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Threading.Tasks.Dataflow</name>
  </assembly>
  <members>
    <member name="T:System.Threading.Tasks.Dataflow.ActionBlock`1">
      <summary>Proporciona un bloque de flujo de datos que invoca un delegado proporcionado de <see cref="T:System.Action`1" /> para cada elemento de datos recibido.</summary>
      <typeparam name="TInput">El tipo de datos en el que este <see cref="T:System.Threading.Tasks.Dataflow.ActionBlock`1" /> funciona.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ActionBlock`1.#ctor(System.Action{`0})">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Tasks.Dataflow.ActionBlock`1" /> con la acción especificada.</summary>
      <param name="action">Acción que se va a invocar con cada elemento de datos recibido.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="action" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ActionBlock`1.#ctor(System.Action{`0},System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Tasks.Dataflow.ActionBlock`1" /> con la acción y opciones de configuración especificadas.</summary>
      <param name="action">Acción que se va a invocar con cada elemento de datos recibido.</param>
      <param name="dataflowBlockOptions">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.ActionBlock`1" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="action" /> es <see langword="null" />.  
  
o bien 
 <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ActionBlock`1.#ctor(System.Func{`0,System.Threading.Tasks.Task})">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Tasks.Dataflow.ActionBlock`1" /> con la acción especificada.</summary>
      <param name="action">Acción que se va a invocar con cada elemento de datos recibido.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="action" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ActionBlock`1.#ctor(System.Func{`0,System.Threading.Tasks.Task},System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Tasks.Dataflow.ActionBlock`1" /> con la acción y opciones de configuración especificadas.</summary>
      <param name="action">Acción que se va a invocar con cada elemento de datos recibido.</param>
      <param name="dataflowBlockOptions">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.ActionBlock`1" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="action" /> es <see langword="null" />.  
  
o bien 
 <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ActionBlock`1.Complete">
      <summary>Indica al bloque de flujo de datos que no debe aceptar o generar más mensajes ni usar más mensajes pospuestos.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ActionBlock`1.Post(`0)">
      <summary>Publica un elemento en el bloque de flujo de datos de destino.</summary>
      <param name="item">Elemento que se va a ofrecer al destino.</param>
      <returns>
        <see langword="true" /> si el elemento se envía al bloque de flujo de datos; si no, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ActionBlock`1.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)">
      <summary>Hace que el bloque de flujo de datos se completar con errores.</summary>
      <param name="exception">Excepción que provocó el error.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="exception" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ActionBlock`1.System#Threading#Tasks#Dataflow#ITargetBlock{TInput}#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)">
      <summary>Proporciona un mensaje para el bloque de flujo de datos y le ofrece la posibilidad de utilizarlo o posponerlo.</summary>
      <param name="messageHeader">Encabezado del mensaje que se va a ofrecer.</param>
      <param name="messageValue">Valor del mensaje que se va a ofrecer.</param>
      <param name="source">Bloque de flujo de datos que ofrece el mensaje. Puede ser <see langword="null" />.</param>
      <param name="consumeToAccept">
        <see langword="true" /> para indicar al destino que llama a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" /> de manera sincrónica durante la llamada a <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />, antes de devolver <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" />, para consumir el mensaje; en caso contrario, <see langword="false" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.  
  
O bien <paramref name="consumeToAccept" /> puede ser <see langword="true" /> solo si se proporciona un valor <paramref name="source" /> que no es NULL.</exception>
      <returns>Estado del mensaje ofrecido.  Si el destino aceptó el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" /> y el origen ya no debe usar más el mensaje ofrecido, ya que ahora es propiedad del destino. Si el destino pospuso el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed" /> como notificación de que el destino puede intentar más adelante consumir o reservar el mensaje; mientras tanto, el origen todavía posee el mensaje y puede ofrecerlo a otros bloques.  
  
Si el destino hubiera pospuesto de otra forma el mensaje, pero el origen fuera <see langword="null" />, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" />.  
  
Si el destino intentó aceptar el mensaje pero no pudo hacerlo porque el origen entrega el mensaje a otro destino o lo descarta simplemente, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable" />.  
  
Si el destino eligió no aceptar el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" />. Si el destino eligió no aceptar el mensaje y nunca aceptará otro mensaje de este origen, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ActionBlock`1.ToString">
      <summary>Devuelve una cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</summary>
      <returns>Cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.ActionBlock`1.Completion">
      <summary>Obtiene un objeto <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica y la finalización del bloque de flujo de datos.</summary>
      <returns>Tarea completada.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.ActionBlock`1.InputCount">
      <summary>Obtiene el número de elementos de entrada en espera de ser procesados por este bloque.</summary>
      <returns>El número de elementos de entrada en espera de ser procesados por este bloque.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.BatchBlock`1">
      <summary>Proporciona un bloque de flujo de datos que procesa por lotes las entradas en las matrices.</summary>
      <typeparam name="T">Especifica el tipo de datos guardados en lotes.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchBlock`1.#ctor(System.Int32)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" /> con el tamaño de lote especificado.</summary>
      <param name="batchSize">Número de elementos que se van a agrupar en un lote.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="batchSize" /> debe ser positivo.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchBlock`1.#ctor(System.Int32,System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions)">
      <summary>Inicializa una nueva <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" /> con el tamaño de lote especificado, la opción de rechazo y las opciones de bloque.</summary>
      <param name="batchSize">Número de elementos que se van a agrupar en un lote.</param>
      <param name="dataflowBlockOptions">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="batchSize" /> debe ser positivo.  
  
o bien 
<paramref name="batchSize" /> debe ser menor que el valor de la opción <see cref="P:System.Threading.Tasks.Dataflow.DataflowBlockOptions.BoundedCapacity" /> si se ha establecido un valor no predeterminado.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchBlock`1.Complete">
      <summary>Señala a <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> que no debe aceptar ni mostrar más mensajes ni usar más mensajes pospuestos.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchBlock`1.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{`0[]},System.Threading.Tasks.Dataflow.DataflowLinkOptions)">
      <summary>Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado.</summary>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> con el que conectar este origen.</param>
      <param name="linkOptions">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" /> que configura el vínculo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="target" /> es NULL (Nothing en Visual Basic) o <paramref name="linkOptions" /> es NULL (Nothing en Visual Basic).</exception>
      <returns>IDisposable que, al llamar a Dispose, desvinculará el origen del destino.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchBlock`1.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)">
      <summary>Hace que <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> se complete en un estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />.</summary>
      <param name="exception">
        <see cref="T:System.Exception" /> que causó el error.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="exception" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock{T[]}#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0[]},System.Boolean@)">
      <summary>Lo llama una <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para aceptar y consumir una <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecida previamente por esta <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está usando.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que consume el mensaje.</param>
      <param name="messageConsumed">
        <see langword="true" /> si se ha consumido correctamente el mensaje; de lo contrario, es <see langword="false" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <returns>Valor del mensaje consumido. Esto puede corresponder a una instancia diferente de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que se ha reservado y pasado previamente como <paramref name="messageHeader" /> a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" />. La interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> de consumo debe usar el valor devuelto en lugar del valor pasado como messageValue mediante <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />.  
  
Si el mensaje solicitado no está disponible, el valor devuelto será <see langword="null" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock{T[]}#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0[]})">
      <summary>Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para liberar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> reservada previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje reservado que se va a liberar.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que libera el mensaje que reservó previamente.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="target" /> no tiene el mensaje reservado.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock{T[]}#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0[]})">
      <summary>Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para reservar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecida previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está reservando.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que reserva el mensaje.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <returns>
        <see langword="true" /> si se ha procesado correctamente el mensaje; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchBlock`1.System#Threading#Tasks#Dataflow#ITargetBlock{T}#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)">
      <summary>Ofrece un mensaje a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, dando al destino la oportunidad de usar o de posponer el mensaje.</summary>
      <param name="messageHeader">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que representa el encabezado del mensaje que se va a ofrecer.</param>
      <param name="messageValue">Valor del mensaje que se va a ofrecer.</param>
      <param name="source">
        <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> que ofrece el mensaje. Puede ser null.</param>
      <param name="consumeToAccept">Establézcalo en <see langword="true" /> para indicar al destino para llamar a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" /> sincrónicamente durante la llamada a <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />, antes de devolver <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" />, para usar el mensaje.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.  
  
O bien, <paramref name="consumeToAccept" /> solo puede ser true si se le proporciona un valor <paramref name="source" /> distinto de NULL.</exception>
      <returns>Estado del mensaje ofrecido. Si el destino aceptó el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" /> y el origen ya no debe usar más el mensaje ofrecido, ya que ahora es propiedad del destino. Si el destino pospuso el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed" /> como notificación de que el destino puede intentar más adelante consumir o reservar el mensaje; mientras tanto, el origen todavía posee el mensaje y puede ofrecerlo a otros bloques.  
  
Si el destino habría pospuesto de otra forma el mensaje, pero <paramref name="source" /> era <see langword="null" />, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" /> en su lugar.  
  
Si el destino intentó aceptar el mensaje pero no pudo hacerlo porque el origen entrega el mensaje a otro destino o lo descarta simplemente, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable" />.  
  
Si el destino eligió no aceptar el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" />. Si el destino eligió no aceptar el mensaje y nunca aceptará otro mensaje de este origen, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchBlock`1.ToString">
      <summary>Devuelve una cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</summary>
      <returns>Cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchBlock`1.TriggerBatch">
      <summary>Desencadena <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" /> para iniciar una operación de procesamiento por lotes incluso si el número de elementos actualmente en cola o pospuestos es menor que <see cref="P:System.Threading.Tasks.Dataflow.BatchBlock`1.BatchSize" />.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchBlock`1.TryReceive(System.Predicate{`0[]},`0[]@)">
      <summary>Intentos de recibir sincrónicamente un elemento de salida disponible de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="filter">Predicado que un valor debe pasar correctamente para que se reciba.  <paramref name="filter" /> puede ser <see langword="null" />, en cuyo caso se pasarán todos los elementos.</param>
      <param name="item">Elemento recibido del origen.</param>
      <returns>Es <see langword="true" /> si se pudo recibir un elemento; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchBlock`1.TryReceiveAll(System.Collections.Generic.IList{`0[]}@)">
      <summary>Intentos de recibir sincrónicamente todos los elementos disponibles de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="items">Elementos recibidos del origen.</param>
      <returns>Es <see langword="true" /> si se podían recibir uno o más elementos; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchBlock`1.BatchSize">
      <summary>Obtiene el tamaño de los lotes generados por <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" />.</summary>
      <returns>Tamaño del lote.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchBlock`1.Completion">
      <summary>Obtiene un objeto <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica y la finalización del bloque de flujo de datos.</summary>
      <returns>Tarea.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchBlock`1.OutputCount">
      <summary>Obtiene el número de elementos de salida disponibles que se pueden recibir de este bloque.</summary>
      <returns>Número de elementos de salida.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2">
      <summary>Proporciona un bloque de flujo de datos que procesa por lotes un número especificado de entradas de tipos potencialmente distintos proporcionados a uno o más de sus destinos.</summary>
      <typeparam name="T1">Especifica el tipo de datos aceptados por el primer destino del bloque.</typeparam>
      <typeparam name="T2">Especifica el tipo de datos aceptados por el segundo destino del bloque.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.#ctor(System.Int32)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2" /> con la configuración especificada.</summary>
      <param name="batchSize">Número de elementos que se van a agrupar en un lote.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="batchSize" /> debe ser positivo.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.#ctor(System.Int32,System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2" /> con la configuración especificada.</summary>
      <param name="batchSize">Número de elementos que se van a agrupar en un lote.</param>
      <param name="dataflowBlockOptions">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="batchSize" /> es menor que uno.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.Complete">
      <summary>Señala a <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> que no debe aceptar ni mostrar más mensajes ni usar más mensajes pospuestos.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1}}},System.Threading.Tasks.Dataflow.DataflowLinkOptions)">
      <summary>Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado.</summary>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> con la que conectar este origen.</param>
      <param name="linkOptions">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" /> que configura el vínculo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="target" /> es <see langword="null" /> (Nothing en Visual Basic) o <paramref name="linkOptions" /> es <see langword="null" /> (Nothing en Visual Basic).</exception>
      <returns>IDisposable que, al llamar a Dispose, desvinculará el origen del destino.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)">
      <summary>Hace que <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> se complete en un estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />.</summary>
      <param name="exception">
        <see cref="T:System.Exception" /> que causó el error.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="exception" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock{System#Tuple{System#Collections#Generic#IList{T1}@System#Collections#Generic#IList{T2}}}#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1}}},System.Boolean@)">
      <summary>Pasa la propiedad del mensaje identificado por <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se va a consumir.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> para el que se va a consumir el mensaje.</param>
      <param name="messageConsumed">
        <see langword="true" /> si se ha consumido correctamente el mensaje. En caso contrario, es <see langword="false" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="target" /> es <see langword="null" /> (Nothing en Visual Basic).</exception>
      <returns>Valor del mensaje consumido. Esto puede corresponder a una instancia diferente de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que se ha reservado y pasado previamente como <paramref name="messageHeader" /> en este método. El elemento <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> de consumo debe usar el valor devuelto en lugar del valor pasado como <paramref name="messageValue" /> en <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />. Si el mensaje solicitado no está disponible, el valor devuelto es <see langword="null" /> (<see langword="Nothing" /> en Visual Basic).</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock{System#Tuple{System#Collections#Generic#IList{T1}@System#Collections#Generic#IList{T2}}}#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1}}})">
      <summary>Libera el derecho para pasar la propiedad del mensaje identificado por <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> de <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje reservado.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que actualmente contiene la reserva.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="target" /> es <see langword="null" /> (Nothing en Visual Basic).</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="target" /> no tiene el mensaje reservado.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock{System#Tuple{System#Collections#Generic#IList{T1}@System#Collections#Generic#IList{T2}}}#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1}}})">
      <summary>Reserva el derecho para pasar la propiedad del mensaje identificado por <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> de <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se va a reservar.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> para el que se va a reservar el mensaje.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="target" /> es <see langword="null" /> (<see langword="Nothing" /> en Visual Basic).</exception>
      <returns>
        <see langword="true" /> si se ha procesado correctamente el mensaje; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.ToString">
      <summary>Devuelve una cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</summary>
      <returns>Cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.TryReceive(System.Predicate{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1}}},System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1}}@)">
      <summary>Intentos de recibir sincrónicamente un elemento de salida disponible de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="filter">Predicado que un valor debe pasar correctamente para que se reciba.  <paramref name="filter" /> puede ser <see langword="null" />, en cuyo caso se pasarán todos los elementos.</param>
      <param name="item">Elemento recibido del origen.</param>
      <returns>Es <see langword="true" /> si se pudo recibir un elemento; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.TryReceiveAll(System.Collections.Generic.IList{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1}}}@)">
      <summary>Intentos de recibir sincrónicamente todos los elementos disponibles de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="items">Elementos recibidos del origen.</param>
      <returns>Es <see langword="true" /> si se podían recibir uno o más elementos; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.BatchSize">
      <summary>Obtiene el tamaño de los lotes generados por <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2" />.</summary>
      <returns>Tamaño del lote.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.Completion">
      <summary>Obtiene un objeto <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica y la finalización del bloque de flujo de datos.</summary>
      <returns>Tarea.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.OutputCount">
      <summary>Obtiene el número de elementos de salida disponibles que se pueden recibir de este bloque.</summary>
      <returns>Número de elementos de salida.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.Target1">
      <summary>Obtiene un destino que se puede usar para ofrecer mensajes del primer tipo.</summary>
      <returns>Destino.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.Target2">
      <summary>Obtiene un destino que se puede usar para ofrecer mensajes del segundo tipo.</summary>
      <returns>Destino.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3">
      <summary>Proporciona un bloque de flujo de datos que procesa por lotes un número especificado de entradas de tipos potencialmente distintos proporcionados a uno o más de sus destinos.</summary>
      <typeparam name="T1">Especifica el tipo de datos aceptados por el primer destino del bloque.</typeparam>
      <typeparam name="T2">Especifica el tipo de datos aceptados por el segundo destino del bloque.</typeparam>
      <typeparam name="T3">Especifica el tipo de datos aceptados por el tercer destino del bloque.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.#ctor(System.Int32)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3" /> con la configuración especificada.</summary>
      <param name="batchSize">Número de elementos que se van a agrupar en un lote.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="batchSize" /> debe ser positivo.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.#ctor(System.Int32,System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3" /> con la configuración especificada.</summary>
      <param name="batchSize">Número de elementos que se van a agrupar en un lote.</param>
      <param name="dataflowBlockOptions">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="batchSize" /> debe ser positivo.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.Complete">
      <summary>Señala a <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> que no debe aceptar ni mostrar más mensajes ni usar más mensajes pospuestos.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}},System.Threading.Tasks.Dataflow.DataflowLinkOptions)">
      <summary>Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado.</summary>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> con el que conectar este origen.</param>
      <param name="linkOptions">
        <see langword="true" /> si el origen debe desvincularse del destino después de propagarse correctamente un único mensaje; <see langword="false" /> para seguir conectado incluso después de que se haya propagado un único mensaje.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="target" /> es <see langword="null" /> (Nothing en Visual Basic) o <paramref name="linkOptions" /> es <see langword="null" /> (Nothing en Visual Basic).</exception>
      <returns>IDisposable que, al llamar a Dispose, desvinculará el origen del destino.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)">
      <summary>Hace que <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> se complete en un estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />.</summary>
      <param name="exception">
        <see cref="T:System.Exception" /> que causó el error.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="exception" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.System#Threading#Tasks#Dataflow#ISourceBlock{System#Tuple{System#Collections#Generic#IList{T1}@System#Collections#Generic#IList{T2}@System#Collections#Generic#IList{T3}}}#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}},System.Boolean@)">
      <summary>Pasa la propiedad del mensaje identificado por <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se va a consumir.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> para el que se va a consumir el mensaje.</param>
      <param name="messageConsumed">
        <see langword="true" /> si se ha consumido correctamente el mensaje. En caso contrario, es <see langword="false" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="target" /> es <see langword="null" /> (Nothing en Visual Basic).</exception>
      <returns>Valor del mensaje consumido. Esto puede corresponder a una instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> diferente de la reservada previamente y que se pasó como <paramref name="messageHeader" /> a este método. El objeto <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> de consumo debe usar el valor devuelto en lugar del valor pasado como <paramref name="messageValue" /> a <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />. Si el mensaje solicitado no está disponible, el valor devuelto es <see langword="null" /> (<see langword="Nothing" /> en Visual Basic).</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.System#Threading#Tasks#Dataflow#ISourceBlock{System#Tuple{System#Collections#Generic#IList{T1}@System#Collections#Generic#IList{T2}@System#Collections#Generic#IList{T3}}}#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}})">
      <summary>Libera el derecho para pasar la propiedad del mensaje identificado por <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> de <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje reservado.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que actualmente contiene la reserva.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="target" /> es <see langword="null" /> (Nothing en Visual Basic).</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="target" /> no tiene el mensaje reservado.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.System#Threading#Tasks#Dataflow#ISourceBlock{System#Tuple{System#Collections#Generic#IList{T1}@System#Collections#Generic#IList{T2}@System#Collections#Generic#IList{T3}}}#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}})">
      <summary>Reserva el derecho para pasar la propiedad del mensaje identificado por <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> de <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se va a reservar.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> para el que se va a reservar el mensaje.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="target" /> es <see langword="null" /> (<see langword="Nothing" /> en Visual Basic).</exception>
      <returns>
        <see langword="true" /> si se ha procesado correctamente el mensaje; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.ToString">
      <summary>Devuelve una cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</summary>
      <returns>Cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.TryReceive(System.Predicate{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}},System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}@)">
      <summary>Intentos de recibir sincrónicamente un elemento de salida disponible de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="filter">Predicado que un valor debe pasar correctamente para que se reciba.  <paramref name="filter" /> puede ser <see langword="null" />, en cuyo caso se pasarán todos los elementos.</param>
      <param name="item">Elemento recibido del origen.</param>
      <returns>Es <see langword="true" /> si se pudo recibir un elemento; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.TryReceiveAll(System.Collections.Generic.IList{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}}@)">
      <summary>Intentos de recibir sincrónicamente todos los elementos disponibles de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="items">Elementos recibidos del origen.</param>
      <returns>Es <see langword="true" /> si se podían recibir uno o más elementos; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.BatchSize">
      <summary>Obtiene el tamaño de los lotes generados por <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3" />.</summary>
      <returns>Tamaño del lote.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.Completion">
      <summary>Obtiene un objeto <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica y la finalización del bloque de flujo de datos.</summary>
      <returns>Tarea.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.OutputCount">
      <summary>Obtiene el número de elementos de salida disponibles que se pueden recibir de este bloque.</summary>
      <returns>Número de elementos de salida.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.Target1">
      <summary>Obtiene un destino que se puede usar para ofrecer mensajes del primer tipo.</summary>
      <returns>Destino.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.Target2">
      <summary>Obtiene un destino que se puede usar para ofrecer mensajes del segundo tipo.</summary>
      <returns>Destino.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.Target3">
      <summary>Obtiene un destino que se puede usar para ofrecer mensajes del tercer tipo.</summary>
      <returns>Destino.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.BroadcastBlock`1">
      <summary>Proporciona un búfer para almacenar a lo sumo un elemento cada vez, sobrescribiendo cada mensaje con el siguiente a medida que llegan.</summary>
      <typeparam name="T">Especifica el tipo de los datos almacenados en el búfer por este bloque de flujo de datos.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BroadcastBlock`1.#ctor(System.Func{`0,`0})">
      <summary>Inicializa la instancia <see cref="T:System.Threading.Tasks.Dataflow.BroadcastBlock`1" /> con la función de clonación especificada.</summary>
      <param name="cloningFunction">Función que se va a usar para clonar los datos cuando se ofrezcan a otros bloques.</param>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BroadcastBlock`1.#ctor(System.Func{`0,`0},System.Threading.Tasks.Dataflow.DataflowBlockOptions)">
      <summary>Inicializa <see cref="T:System.Threading.Tasks.Dataflow.BroadcastBlock`1" /> con la función de clonación y <see cref="T:System.Threading.Tasks.Dataflow.DataflowBlockOptions" /> especificados.</summary>
      <param name="cloningFunction">Función que se va a usar para clonar los datos cuando se ofrezcan a otros bloques.</param>
      <param name="dataflowBlockOptions">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.BroadcastBlock`1" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BroadcastBlock`1.Complete">
      <summary>Señala a <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> que no debe aceptar ni mostrar más mensajes ni usar más mensajes pospuestos.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BroadcastBlock`1.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Threading.Tasks.Dataflow.DataflowLinkOptions)">
      <summary>Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado.</summary>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> con la que conectar este origen.</param>
      <param name="linkOptions">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" /> que configura el vínculo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="target" /> es NULL (Nothing en Visual Basic) o <paramref name="linkOptions" /> es NULL (Nothing en Visual Basic).</exception>
      <returns>IDisposable que, al llamar a Dispose, desvinculará el origen del destino.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BroadcastBlock`1.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)">
      <summary>Hace que la interfaz <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> se complete en un estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> .</summary>
      <param name="exception">
        <see cref="T:System.Exception" /> que causó el error.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="exception" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BroadcastBlock`1.System#Threading#Tasks#Dataflow#IReceivableSourceBlock{T}#TryReceiveAll(System.Collections.Generic.IList{`0}@)">
      <summary>Intentos de recibir sincrónicamente todos los elementos disponibles de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="items">Elementos recibidos del origen.</param>
      <returns>Es <see langword="true" /> si se podían recibir uno o más elementos; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BroadcastBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock{T}#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)">
      <summary>Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para aceptar y usar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecida previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está usando.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que consume el mensaje.</param>
      <param name="messageConsumed">
        <see langword="true" /> si se ha consumido correctamente el mensaje; de lo contrario, es <see langword="false" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <returns>Valor del mensaje consumido. Esto puede corresponder a una instancia diferente de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que se ha reservado y pasado previamente como <paramref name="messageHeader" /> a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" />. La interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> de consumo debe usar el valor devuelto en lugar del valor pasado como <paramref name="messageValue" /> mediante <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />.  
  
Si el mensaje solicitado no está disponible, el valor devuelto será <see langword="null" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BroadcastBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock{T}#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})">
      <summary>Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para liberar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> reservada previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje reservado que se va a liberar.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que libera el mensaje que reservó previamente.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="target" /> no tiene el mensaje reservado.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BroadcastBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock{T}#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})">
      <summary>Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para reservar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecida previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está reservando.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que reserva el mensaje.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <returns>
        <see langword="true" /> si se ha procesado correctamente el mensaje; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BroadcastBlock`1.System#Threading#Tasks#Dataflow#ITargetBlock{T}#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)">
      <summary>Ofrece un mensaje a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, dando al destino la oportunidad de usar o de posponer el mensaje.</summary>
      <param name="messageHeader">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que representa el encabezado del mensaje que se va a ofrecer.</param>
      <param name="messageValue">Valor del mensaje que se va a ofrecer.</param>
      <param name="source">
        <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> que ofrece el mensaje. Puede ser null.</param>
      <param name="consumeToAccept">Establézcalo en <see langword="true" /> para indicar al destino para llamar a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" /> sincrónicamente durante la llamada a <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />, antes de devolver <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" />, para usar el mensaje.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.  
  
O bien, <paramref name="consumeToAccept" /> solo puede ser true si se le proporciona un valor <paramref name="source" /> distinto de NULL.</exception>
      <returns>Estado del mensaje ofrecido. Si el destino aceptó el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" /> y el origen ya no debe usar más el mensaje ofrecido, ya que ahora es propiedad del destino. Si el destino pospuso el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed" /> como notificación de que el destino puede intentar más adelante consumir o reservar el mensaje; mientras tanto, el origen todavía posee el mensaje y puede ofrecerlo a otros bloques.  
  
Si el destino habría pospuesto de otra forma el mensaje, pero <paramref name="source" /> era <see langword="null" />, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" /> en su lugar.  
  
Si el destino intentó aceptar el mensaje pero no pudo hacerlo porque el origen entrega el mensaje a otro destino o lo descarta simplemente, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable" />.  
  
Si el destino eligió no aceptar el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" />. Si el destino eligió no aceptar el mensaje y nunca aceptará otro mensaje de este origen, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BroadcastBlock`1.ToString">
      <summary>Devuelve una cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</summary>
      <returns>Cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BroadcastBlock`1.TryReceive(System.Predicate{`0},`0@)">
      <summary>Intentos de recibir sincrónicamente un elemento de salida disponible de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="filter">Predicado que un valor debe pasar correctamente para que se reciba.  <paramref name="filter" /> puede ser <see langword="null" />, en cuyo caso se pasarán todos los elementos.</param>
      <param name="item">Elemento recibido del origen.</param>
      <returns>Es <see langword="true" /> si se pudo recibir un elemento; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BroadcastBlock`1.Completion">
      <summary>Obtiene un objeto <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica y la finalización del bloque de flujo de datos.</summary>
      <returns>Tarea.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.BufferBlock`1">
      <summary>Proporciona un búfer para almacenar datos de un Dataflow.</summary>
      <typeparam name="T">Especifica el tipo de los datos almacenados en el búfer por este bloque de flujo de datos.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BufferBlock`1.#ctor">
      <summary>Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Dataflow.BufferBlock`1" />.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BufferBlock`1.#ctor(System.Threading.Tasks.Dataflow.DataflowBlockOptions)">
      <summary>Inicializa un <see cref="T:System.Threading.Tasks.Dataflow.BufferBlock`1" /> nuevo con las <see cref="T:System.Threading.Tasks.Dataflow.DataflowBlockOptions" /> especificadas.</summary>
      <param name="dataflowBlockOptions">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.BufferBlock`1" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BufferBlock`1.Complete">
      <summary>Señala a <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> que no debe aceptar ni mostrar más mensajes ni usar más mensajes pospuestos.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BufferBlock`1.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Threading.Tasks.Dataflow.DataflowLinkOptions)">
      <summary>Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado.</summary>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> con la que conectar este origen.</param>
      <param name="linkOptions">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" /> que configura el vínculo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="target" /> es NULL (Nothing en Visual Basic) o <paramref name="linkOptions" /> es NULL (Nothing en Visual Basic).</exception>
      <returns>IDisposable que, al llamar a Dispose, desvinculará el origen del destino.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BufferBlock`1.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)">
      <summary>Hace que <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> se complete en un estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />.</summary>
      <param name="exception">
        <see cref="T:System.Exception" /> que causó el error.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="exception" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BufferBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock{T}#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)">
      <summary>Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para aceptar y usar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecida previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está usando.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que consume el mensaje.</param>
      <param name="messageConsumed">
        <see langword="true" /> si se ha consumido correctamente el mensaje; de lo contrario, es <see langword="false" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <returns>Valor del mensaje consumido. Esto puede corresponder a una instancia diferente de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que se ha reservado y pasado previamente como <paramref name="messageHeader" /> a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" />. La interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> de consumo debe usar el valor devuelto en lugar del valor pasado como <paramref name="messageValue" /> mediante <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />.  
  
Si el mensaje solicitado no está disponible, el valor devuelto será <see langword="null" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BufferBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock{T}#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})">
      <summary>Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para liberar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> reservada previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje reservado que se va a liberar.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que libera el mensaje que reservó previamente.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="target" /> no tiene el mensaje reservado.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BufferBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock{T}#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})">
      <summary>Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para reservar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecida previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está reservando.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que reserva el mensaje.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <returns>
        <see langword="true" /> si se ha procesado correctamente el mensaje; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BufferBlock`1.System#Threading#Tasks#Dataflow#ITargetBlock{T}#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)">
      <summary>Ofrece un mensaje a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, dando al destino la oportunidad de usar o de posponer el mensaje.</summary>
      <param name="messageHeader">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que representa el encabezado del mensaje que se va a ofrecer.</param>
      <param name="messageValue">Valor del mensaje que se va a ofrecer.</param>
      <param name="source">
        <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> que ofrece el mensaje. Puede ser <see langword="null" />.</param>
      <param name="consumeToAccept">Se establece en true para indicar al destino que llame a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" /> de manera sincrónica durante la llamada a <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />, antes de devolver <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" />, para consumir el mensaje.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.  
  
O bien, <paramref name="consumeToAccept" /> solo puede ser true si se le proporciona un valor <paramref name="source" /> distinto de NULL.</exception>
      <returns>Estado del mensaje ofrecido. Si el destino aceptó el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" /> y el origen ya no debe usar más el mensaje ofrecido, ya que ahora es propiedad del destino. Si el destino pospuso el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed" /> como notificación de que el destino puede intentar más adelante consumir o reservar el mensaje; mientras tanto, el origen todavía posee el mensaje y puede ofrecerlo a otros bloques.  
  
Si el destino habría pospuesto de otra forma el mensaje, pero <paramref name="source" /> era <see langword="null" />, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" /> en su lugar.  
  
Si el destino intentó aceptar el mensaje pero no pudo hacerlo porque el origen entrega el mensaje a otro destino o lo descarta simplemente, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable" />.  
  
Si el destino eligió no aceptar el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" />. Si el destino eligió no aceptar el mensaje y nunca aceptará otro mensaje de este origen, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BufferBlock`1.ToString">
      <summary>Devuelve una cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</summary>
      <returns>Cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BufferBlock`1.TryReceive(System.Predicate{`0},`0@)">
      <summary>Intentos de recibir sincrónicamente un elemento de salida disponible de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="filter">El valor del predicado debe pasar correctamente para que se reciba. <paramref name="filter" /> puede ser <see langword="null" />, en cuyo caso se pasarán todos los elementos.</param>
      <param name="item">Elemento recibido del origen.</param>
      <returns>Es <see langword="true" /> si se pudo recibir un elemento; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BufferBlock`1.TryReceiveAll(System.Collections.Generic.IList{`0}@)">
      <summary>Intentos de recibir sincrónicamente todos los elementos disponibles de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="items">Elementos recibidos del origen.</param>
      <returns>Es <see langword="true" /> si se podían recibir uno o más elementos; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BufferBlock`1.Completion">
      <summary>Obtiene un objeto <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica y la finalización del bloque de flujo de datos.</summary>
      <returns>Tarea.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BufferBlock`1.Count">
      <summary>Obtiene el número de elementos actual almacenados en el búfer.</summary>
      <returns>Número de elementos.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.DataflowBlock">
      <summary>Proporciona un conjunto de métodos estáticos (Shared en Visual Basic) para que funcionen con bloques de flujo de datos.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.AsObservable``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0})">
      <summary>Crea una nueva abstracción de la interfaz <see cref="T:System.IObservable`1" /> sobre la interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="source">El origen para ajustar.</param>
      <typeparam name="TOutput">Especifica el tipo de datos contenidos en el origen.</typeparam>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="source" /> es <see langword="null" />.</exception>
      <returns>
        <see cref="T:System.IObservable`1" /> que permite a los observadores que se suscriban al origen.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.AsObserver``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0})">
      <summary>Crea una abstracción de <see cref="T:System.IObserver`1" /> sobre <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</summary>
      <param name="target">Destino que se va a incluir.</param>
      <typeparam name="TInput">Especifica el tipo de entrada aceptado por el bloque de destino.</typeparam>
      <returns>Un observador que contiene el bloque de destino.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.Choose``2(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Action{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1},System.Action{``1})">
      <summary>Supervisa dos orígenes de flujo de datos, invocando el controlador proporcionado para cualquier origen que haga que los datos se encuentren disponibles en primer lugar.</summary>
      <param name="source1">El primer origen.</param>
      <param name="action1">Controlador que se va a ejecutar en datos del primer origen.</param>
      <param name="source2">El segundo origen.</param>
      <param name="action2">Controlador que se va a ejecutar en datos del segundo origen.</param>
      <typeparam name="T1">Especifica el tipo de datos contenidos en el primer origen.</typeparam>
      <typeparam name="T2">Especifica el tipo de datos contenidos en el segundo origen.</typeparam>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="source1" /> es <see langword="null" />.  
  
o bien 
El valor de <paramref name="action1" /> es <see langword="null" />.  
  
o bien 
El valor de <paramref name="source2" /> es <see langword="null" />.  
  
o bien 
El valor de <paramref name="action2" /> es <see langword="null" />.</exception>
      <returns>
        <see cref="T:System.Threading.Tasks.Task`1" /> que representa la elección asincrónica. Si ambos orígenes se completan antes de completar la selección, la tarea resultante se cancelará. Cuando uno de los orígenes tiene datos disponibles y los propaga correctamente a la opción, la tarea resultante se completará cuando se complete el controlador; si el controlador produce una excepción, la tarea finalizará en el estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> y contendrá la excepción no controlada. En caso contrario, la tarea finalizará con la propiedad <see cref="P:System.Threading.Tasks.Task`1.Result" /> establecida en 0 o 1 para representar el primer o el segundo origen, respectivamente.  
  
Este método solo consumirá un elemento de uno de los dos orígenes de datos, nunca de ambos.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.Choose``2(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Action{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1},System.Action{``1},System.Threading.Tasks.Dataflow.DataflowBlockOptions)">
      <summary>Supervisa dos orígenes de flujo de datos, invocando el controlador proporcionado para cualquier origen que haga que los datos se encuentren disponibles en primer lugar.</summary>
      <param name="source1">El primer origen.</param>
      <param name="action1">Controlador que se va a ejecutar en datos del primer origen.</param>
      <param name="source2">El segundo origen.</param>
      <param name="action2">Controlador que se va a ejecutar en datos del segundo origen.</param>
      <param name="dataflowBlockOptions">Las opciones con las que se van a configurar esta opción.</param>
      <typeparam name="T1">Especifica el tipo de datos contenidos en el primer origen.</typeparam>
      <typeparam name="T2">Especifica el tipo de datos contenidos en el segundo origen.</typeparam>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="source1" /> es <see langword="null" />.  
  
o bien 
El valor de <paramref name="action1" /> es <see langword="null" />.  
  
o bien 
El valor de <paramref name="source2" /> es <see langword="null" />.  
  
o bien 
El valor de <paramref name="action2" /> es <see langword="null" />.  
  
o bien 
El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
      <returns>
        <see cref="T:System.Threading.Tasks.Task`1" /> que representa la elección asincrónica. Si ambos orígenes se completan antes de completar la selección o si el <see cref="T:System.Threading.CancellationToken" /> proporcionado como parte de <paramref name="dataflowBlockOptions" /> se cancela antes de completar la selección, la tarea resultante se cancelará. Cuando uno de los orígenes tiene datos disponibles y los propaga correctamente a la opción, la tarea resultante se completará cuando se complete el controlador; si el controlador produce una excepción, la tarea finalizará en el estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> y contendrá la excepción no controlada. En caso contrario, la tarea finalizará con la propiedad <see cref="P:System.Threading.Tasks.Task`1.Result" /> establecida en 0 o 1 para representar el primer o el segundo origen, respectivamente.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.Choose``3(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Action{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1},System.Action{``1},System.Threading.Tasks.Dataflow.ISourceBlock{``2},System.Action{``2})">
      <summary>Supervisa tres orígenes de flujo de datos, invocando el controlador proporcionado para cualquier origen que haga que los datos se encuentren disponibles en primer lugar.</summary>
      <param name="source1">El primer origen.</param>
      <param name="action1">Controlador que se va a ejecutar en datos del primer origen.</param>
      <param name="source2">El segundo origen.</param>
      <param name="action2">Controlador que se va a ejecutar en datos del segundo origen.</param>
      <param name="source3">El tercer origen.</param>
      <param name="action3">Controlador que se va a ejecutar en datos del tercer origen.</param>
      <typeparam name="T1">Especifica el tipo de datos contenidos en el primer origen.</typeparam>
      <typeparam name="T2">Especifica el tipo de datos contenidos en el segundo origen.</typeparam>
      <typeparam name="T3">Especifica el tipo de datos contenidos en el tercer origen.</typeparam>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="source1" /> es <see langword="null" />.  
  
o bien 
El valor de <paramref name="action1" /> es <see langword="null" />.  
  
o bien 
El valor de <paramref name="source2" /> es <see langword="null" />.  
  
o bien 
El valor de <paramref name="action2" /> es <see langword="null" />.  
  
o bien 
El valor de <paramref name="source3" /> es <see langword="null" />.  
  
o bien 
El valor de <paramref name="action3" /> es <see langword="null" />.</exception>
      <returns>
        <see cref="T:System.Threading.Tasks.Task`1" /> que representa la elección asincrónica. Si todos los orígenes se completan antes de completar la selección, la tarea resultante se cancelará. Cuando uno de los orígenes tiene datos disponibles y los propaga correctamente a la opción, la tarea resultante se completará cuando se complete el controlador; si el controlador produce una excepción, la tarea finalizará en el estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> y contendrá la excepción no controlada. En caso contrario, la tarea finalizará con la propiedad <see cref="P:System.Threading.Tasks.Task`1.Result" /> establecida en el índice de base 0 del origen.  
  
Este método solo consumirá un elemento de uno de los orígenes de datos, nunca de más de uno.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.Choose``3(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Action{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1},System.Action{``1},System.Threading.Tasks.Dataflow.ISourceBlock{``2},System.Action{``2},System.Threading.Tasks.Dataflow.DataflowBlockOptions)">
      <summary>Supervisa tres orígenes de flujo de datos, invocando el controlador proporcionado para cualquier origen que haga que los datos se encuentren disponibles en primer lugar.</summary>
      <param name="source1">El primer origen.</param>
      <param name="action1">Controlador que se va a ejecutar en datos del primer origen.</param>
      <param name="source2">El segundo origen.</param>
      <param name="action2">Controlador que se va a ejecutar en datos del segundo origen.</param>
      <param name="source3">El tercer origen.</param>
      <param name="action3">Controlador que se va a ejecutar en datos del tercer origen.</param>
      <param name="dataflowBlockOptions">Las opciones con las que se van a configurar esta opción.</param>
      <typeparam name="T1">Especifica el tipo de datos contenidos en el primer origen.</typeparam>
      <typeparam name="T2">Especifica el tipo de datos contenidos en el segundo origen.</typeparam>
      <typeparam name="T3">Especifica el tipo de datos contenidos en el tercer origen.</typeparam>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="source1" /> es <see langword="null" />.  
  
o bien 
El valor de <paramref name="action1" /> es <see langword="null" />.  
  
o bien 
El valor de <paramref name="source2" /> es <see langword="null" />.  
  
o bien 
El valor de <paramref name="action2" /> es <see langword="null" />.  
  
o bien 
El valor de <paramref name="source3" /> es <see langword="null" />.  
  
o bien 
El valor de <paramref name="action3" /> es <see langword="null" />.  
  
o bien 
El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
      <returns>
        <see cref="T:System.Threading.Tasks.Task`1" /> que representa la elección asincrónica. Si todos los orígenes se completan antes de completar la selección o si el <see cref="T:System.Threading.CancellationToken" /> proporcionado como parte de <paramref name="dataflowBlockOptions" /> se cancela antes de completar la selección, la tarea resultante se cancelará. Cuando uno de los orígenes tiene datos disponibles y los propaga correctamente a la opción, la tarea resultante se completará cuando se complete el controlador; si el controlador produce una excepción, la tarea finalizará en el estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> y contendrá la excepción no controlada. En caso contrario, la tarea finalizará con la propiedad <see cref="P:System.Threading.Tasks.Task`1.Result" /> establecida en el índice de base 0 del origen.  
  
Este método solo consumirá un elemento de uno de los orígenes de datos, nunca de más de uno. Si se solicita la cancelación una vez recibido un elemento, la solicitud de cancelación se omitirá y se permitirá que el controlador pertinente se ejecute.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate``2(System.Threading.Tasks.Dataflow.ITargetBlock{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1})">
      <summary>Encapsula un destino y un origen en un único propagador.</summary>
      <param name="target">Destino que se va a encapsular.</param>
      <param name="source">Origen que se va a encapsular.</param>
      <typeparam name="TInput">Especifica el tipo de entrada que se espera en el destino.</typeparam>
      <typeparam name="TOutput">Especifica el tipo de salida generado por el origen.</typeparam>
      <returns>Destino y origen encapsulados.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.Tasks.Dataflow.ITargetBlock{``0})">
      <summary>Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado.</summary>
      <param name="source">El origen desde el que se va a vincular.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> con la que conectar el origen.</param>
      <typeparam name="TOutput">Especifica el tipo de datos contenidos en el origen.</typeparam>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="source" /> es <see langword="null" />.  
  
o bien 
El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <returns>
        <see cref="T:System.IDisposable" /> que, tras llamar a <see langword="Dispose" />, desvinculará el origen del destino.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.Tasks.Dataflow.ITargetBlock{``0},System.Predicate{``0})">
      <summary>Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado con el filtro especificado.</summary>
      <param name="source">El origen desde el que se va a vincular.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> al que conectar el origen.</param>
      <param name="predicate">Filtro que un mensaje debe pasar para que se propague del origen al destino.</param>
      <typeparam name="TOutput">Especifica el tipo de datos contenidos en el origen.</typeparam>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="source" /> es <see langword="null" />.  
  
o bien 
El valor de <paramref name="target" /> es <see langword="null" />.  
  
o bien 
El valor de <paramref name="predicate" /> es <see langword="null" />.</exception>
      <returns>
        <see cref="T:System.IDisposable" /> que, tras llamar a <see langword="Dispose" />, desvinculará el origen del destino.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.Tasks.Dataflow.ITargetBlock{``0},System.Threading.Tasks.Dataflow.DataflowLinkOptions,System.Predicate{``0})">
      <summary>Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado con el filtro especificado.</summary>
      <param name="source">El origen desde el que se va a vincular.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> al que conectar el origen.</param>
      <param name="linkOptions">Uno de los valores de enumeración que especifica cómo configurar un vínculo entre bloques de flujo de datos.</param>
      <param name="predicate">Filtro que un mensaje debe pasar para que se propague del origen al destino.</param>
      <typeparam name="TOutput">Especifica el tipo de datos contenidos en el origen.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es NULL (Nothing en Visual Basic).  
  
o bien 
<paramref name="target" /> es NULL (Nothing en Visual Basic).  
  
o bien 
<paramref name="linkOptions" /> es NULL (Nothing en Visual Basic).  
  
o bien 
<paramref name="predicate" /> es NULL (Nothing en Visual Basic).</exception>
      <returns>
        <see cref="T:System.IDisposable" /> que, tras llamar a <see langword="Dispose" />, desvinculará el origen del destino.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.NullTarget``1">
      <summary>Obtiene un bloque de destino que acepta sincrónicamente todos los mensajes que se le proporcionan y los coloca.</summary>
      <typeparam name="TInput">El tipo de mensajes que este bloque puede aceptar.</typeparam>
      <returns>
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que acepta y quita posteriormente todos los mensajes proporcionados.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.OutputAvailableAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0})">
      <summary>Proporciona un objeto <see cref="T:System.Threading.Tasks.Task`1" /> que supervisa de forma asincrónica el origen de salida disponible.</summary>
      <param name="source">El origen para supervisar.</param>
      <typeparam name="TOutput">Especifica el tipo de datos contenidos en el origen.</typeparam>
      <returns>
        <see cref="T:System.Threading.Tasks.Task`1" /> que informa si la salida está disponible y cuándo. Si, cuando la tarea se completa, el <see cref="P:System.Threading.Tasks.Task`1.Result" /> es <see langword="true" />, hay más salida disponible en el origen (aunque otro consumidor del origen puede recuperar los datos).  
  
Si devuelve <see langword="false" />, no hay más resultados y nunca estarán disponibles, debido a que el origen se completa antes de que los resultados estén disponibles.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.OutputAvailableAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.CancellationToken)">
      <summary>Proporciona una <see cref="T:System.Threading.Tasks.Task`1" /> que supervisa de manera asincrónica la salida disponible en el origen.</summary>
      <param name="source">El origen para supervisar.</param>
      <param name="cancellationToken">El token de cancelación con el que cancelar la operación asincrónica.</param>
      <typeparam name="TOutput">Especifica el tipo de datos contenidos en el origen.</typeparam>
      <returns>
        <see cref="T:System.Threading.Tasks.Task`1" /> que informa si la salida está disponible y cuándo. Si, cuando la tarea se completa, el <see cref="P:System.Threading.Tasks.Task`1.Result" /> es <see langword="true" />, hay más salida disponible en el origen (aunque otro consumidor del origen puede recuperar los datos). Si devuelve <see langword="false" />, no hay más resultados y nunca estarán disponibles, debido a que el origen se completa antes de que los resultados estén disponibles.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.Post``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0},``0)">
      <summary>Publica un elemento a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</summary>
      <param name="target">Bloque de destino.</param>
      <param name="item">Elemento que se va a ofrecer al destino.</param>
      <typeparam name="TInput">Especifica el tipo de datos aceptados por el bloque de destino.</typeparam>
      <returns>
        <see langword="true" /> si el bloque de destino aceptó el elemento; si no, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.Receive``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0})">
      <summary>Recibe de forma sincrónica un valor de un origen especificado.</summary>
      <param name="source">Origen del que se va a recibir el valor.</param>
      <typeparam name="TOutput">El tipo de los datos contenido del origen de datos.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No se pudo recibir ningún elemento del origen.</exception>
      <returns>El valor recibido.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.Receive``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.CancellationToken)">
      <summary>De forma sincrónica recibe un valor de un origen especificado y proporciona un token para cancelar la operación.</summary>
      <param name="source">Origen del que se va a recibir el valor.</param>
      <param name="cancellationToken">El token que se va a utilizar para cancelar la selección la operación de recepción.</param>
      <typeparam name="TOutput">El tipo de los datos contenido del origen de datos.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No se pudo recibir ningún elemento del origen.</exception>
      <exception cref="T:System.OperationCanceledException">Se canceló la operación antes de que se recibiera un elemento del origen.</exception>
      <returns>El valor recibido.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.Receive``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.TimeSpan)">
      <summary>De forma sincrónica recibe un valor de un origen especificado, observando un tiempo de espera opcional.</summary>
      <param name="source">Origen del que se va a recibir el valor.</param>
      <param name="timeout">El intervalo de tiempo máximo, en milisegundos, para esperar la operación síncrona para completar, o un intervalo que representa -1 milisegundos para esperar indefinidamente.</param>
      <typeparam name="TOutput">El tipo de los datos contenido del origen de datos.</typeparam>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundo que representa un período de espera infinito.  
  
o bien 
 <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No se pudo recibir ningún elemento del origen.</exception>
      <exception cref="T:System.TimeoutException">El tiempo de espera especificado expiró antes de que se recibiera un elemento del origen.</exception>
      <returns>El valor recibido.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.Receive``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.TimeSpan,System.Threading.CancellationToken)">
      <summary>De forma sincrónica recibe un valor de un origen especificado, proporcionando un token para cancelar la operación y observando un intervalo de tiempo de espera opcional.</summary>
      <param name="source">Origen del que se va a recibir el valor.</param>
      <param name="timeout">El intervalo de tiempo máximo, en milisegundos, para esperar la operación síncrona para completar, o un intervalo que representa -1 milisegundos para esperar indefinidamente.</param>
      <param name="cancellationToken">El token que se va a utilizar para cancelar la selección la operación de recepción.</param>
      <typeparam name="TOutput">El tipo de los datos contenido del origen de datos.</typeparam>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="source" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundo que representa un período de espera infinito.  
  
o bien 
 <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException">No se pudo recibir ningún elemento del origen.</exception>
      <exception cref="T:System.TimeoutException">El tiempo de espera especificado expiró antes de que se recibiera un elemento del origen.</exception>
      <exception cref="T:System.OperationCanceledException">Se canceló la operación antes de que se recibiera un elemento del origen.</exception>
      <returns>El valor recibido.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0})">
      <summary>Recibe de forma asincrónica un valor de un origen especificado.</summary>
      <param name="source">Origen del que se va a recibir el valor.</param>
      <typeparam name="TOutput">El tipo de los datos contenido del origen de datos.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es <see langword="null" />.</exception>
      <returns>Tarea que representa la operación de recepción asincrónica. Cuando un valor del elemento se recibe correctamente del origen, la tarea devuelta se completa y su <see cref="P:System.Threading.Tasks.Task`1.Result" /> devuelve el valor del elemento recibido. Si el valor de un elemento no se puede recuperar porque el origen está vacío y completo, se inicia una excepción <see cref="T:System.InvalidOperationException" /> en la tarea devuelta.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.CancellationToken)">
      <summary>De forma asincrónica recibe un valor de un origen especificado y proporciona un token para cancelar la operación.</summary>
      <param name="source">Origen del que se va a recibir el valor.</param>
      <param name="cancellationToken">El token que se va a utilizar para cancelar la selección la operación de recepción.</param>
      <typeparam name="TOutput">Especifica el tipo de datos contenidos en el origen.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es <see langword="null" />.</exception>
      <returns>Tarea que representa la operación de recepción asincrónica. Cuando un valor se recibe correctamente desde el origen, la tarea devuelta se completa y su <see cref="P:System.Threading.Tasks.Task`1.Result" /> devuelve el valor. Si un valor no se puede recuperar porque se solicitó la cancelación, la tarea devuelta se cancelará. Si el valor del elemento no se puede recuperar porque el origen está vacío y completo, se inicia una excepción <see cref="T:System.InvalidOperationException" /> en la tarea devuelta.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.TimeSpan)">
      <summary>De forma asincrónica recibe un valor de un origen especificado, observando un tiempo de espera opcional.</summary>
      <param name="source">Origen del que se va a recibir el valor.</param>
      <param name="timeout">El intervalo de tiempo máximo, en milisegundos, para esperar la operación síncrona para completar, o un intervalo que representa -1 milisegundos para esperar indefinidamente.</param>
      <typeparam name="TOutput">El tipo de los datos contenido del origen de datos.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundo que representa un período de espera infinito.  
  
o bien 
 <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      <returns>Tarea que representa la operación de recepción asincrónica. Cuando un valor se recibe correctamente desde el origen, la tarea devuelta se completa y su <see cref="P:System.Threading.Tasks.Task`1.Result" /> devuelve el valor. Si un valor no se puede recuperar porque el tiempo de espera ha expirado, la tarea devuelta se cancelará. Si el valor del elemento no se puede recuperar porque el origen está vacío y completo, se inicia una excepción <see cref="T:System.InvalidOperationException" /> en la tarea devuelta.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.TimeSpan,System.Threading.CancellationToken)">
      <summary>De forma asincrónica recibe un valor de un origen especificado, proporcionando un símbolo para anular la operación y observando un intervalo de tiempo de espera opcional.</summary>
      <param name="source">Origen del que se va a recibir el valor.</param>
      <param name="timeout">El intervalo de tiempo máximo, en milisegundos, para esperar la operación síncrona para completar, o un intervalo que representa -1 milisegundos para esperar indefinidamente.</param>
      <param name="cancellationToken">El token que se puede usar para cancelar la operación de recepción.</param>
      <typeparam name="TOutput">El tipo de los datos contenido del origen de datos.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundo que representa un período de espera infinito.  
  
o bien 
 <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      <returns>Tarea que representa la operación de recepción asincrónica. Cuando un valor se recibe correctamente desde el origen, la tarea devuelta se completa y su <see cref="P:System.Threading.Tasks.Task`1.Result" /> devuelve el valor. Si un valor no se puede recuperar porque el tiempo de espera expirado o se solicitó cancelación, la tarea devuelta se cancelará. Si el valor del elemento no se puede recuperar porque el origen está vacío y completo, se inicia una excepción <see cref="T:System.InvalidOperationException" /> en la tarea devuelta.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0},``0)">
      <summary>De forma asincrónica proporciona un mensaje al bloque de mensajes de destino, teniendo en cuenta el aplazamiento.</summary>
      <param name="target">El destino en el que se van a exponer los datos.</param>
      <param name="item">Elemento que se va a ofrecer al destino.</param>
      <typeparam name="TInput">Especifica el tipo de los datos que se van a enviar al destino.</typeparam>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <returns>
        <see cref="T:System.Threading.Tasks.Task`1" /> que representa el envío asincrónico. Si el destino acepta y usa el elemento proporcionado durante la llamada a <see cref="M:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0},``0)" />, al volver de la llamada se completará el <see cref="T:System.Threading.Tasks.Task`1" /> resultante y su propiedad <see cref="P:System.Threading.Tasks.Task`1.Result" /> devolverá <see langword="true" />. Si el destino rechaza el elemento proporcionado durante la llamada, al volver de la llamada se completará el <see cref="T:System.Threading.Tasks.Task`1" /> resultante y su propiedad <see cref="P:System.Threading.Tasks.Task`1.Result" /> devolverá <see langword="false" />. Si el destino pospone el elemento proporcionado, el elemento se almacenará en búfer hasta el momento en que el destino lo utilice o lo lance, momento en el que la tarea se completará, con el <see cref="P:System.Threading.Tasks.Task`1.Result" /> que indica si el mensaje se ha utilizado. Si el destino nunca intenta utilizar o lanzar el mensaje, la tarea devuelta nunca se completará.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0},``0,System.Threading.CancellationToken)">
      <summary>De forma asincrónica proporciona un mensaje al bloque de mensajes de destino, teniendo en cuenta el aplazamiento.</summary>
      <param name="target">El destino en el que se van a exponer los datos.</param>
      <param name="item">Elemento que se va a ofrecer al destino.</param>
      <param name="cancellationToken">El token de cancelación con el que solicitar la cancelación de la operación de envío.</param>
      <typeparam name="TInput">Especifica el tipo de los datos que se van a enviar al destino.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="target" /> es NULL (Nothing en Visual Basic).</exception>
      <returns>
        <see cref="T:System.Threading.Tasks.Task`1" /> que representa el envío asincrónico.  Si el destino acepta y usa el elemento proporcionado durante la llamada a SendAsync, al volver de la llamada se completará el <see cref="T:System.Threading.Tasks.Task`1" /> resultante y su propiedad <c>Result</c> devolverá true.  Si el destino rechaza el elemento proporcionado durante la llamada, al volver de la llamada se completará el <see cref="T:System.Threading.Tasks.Task`1" /> resultante y su propiedad <c>Result</c> devolverá false. Si el destino pospone el elemento proporcionado, el elemento se almacenará en búfer hasta que el destino lo consuma o lo libere, momento en el que la tarea se completará, y <c>Result</c> indicará si el mensaje se ha consumido. Si el destino nunca intenta utilizar o lanzar el mensaje, la tarea devuelta nunca se completará.  
  
Si se solicita la cancelación antes de que el destino haya consumido correctamente los datos enviados, la tarea devuelta completará al estado cancelado y datos dejarán de estar disponibles para el destino.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive``1(System.Threading.Tasks.Dataflow.IReceivableSourceBlock{``0},``0@)">
      <summary>Se intenta recibir sincrónicamente un elemento de <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="source">Origen del que se va a recibir.</param>
      <param name="item">Elemento recibido del origen.</param>
      <typeparam name="TOutput">Especifica el tipo de datos contenidos en el origen.</typeparam>
      <returns>Es <see langword="true" /> si se pudo recibir un elemento; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.DataflowBlockOptions">
      <summary>Proporciona las opciones usadas para configurar el procesamiento que realizan los bloques de flujo de datos.</summary>
    </member>
    <member name="F:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded">
      <summary>Constante que se usa para especificar una cantidad ilimitada para los miembros de <see cref="T:System.Threading.Tasks.Dataflow.DataflowBlockOptions" /> que proporcionan un límite superior. Este campo es constante.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlockOptions.#ctor">
      <summary>Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Dataflow.DataflowBlockOptions" />.</summary>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.DataflowBlockOptions.BoundedCapacity">
      <summary>Obtiene o establece el número de mensajes máximo que el bloque puede almacenar en el búfer simultáneamente.</summary>
      <returns>Número máximo de mensajes. El valor predeterminado es -1, que indica un número ilimitado de mensajes.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken">
      <summary>Obtiene o establece <see cref="T:System.Threading.CancellationToken" /> para supervisar las solicitudes de cancelación.</summary>
      <returns>Token.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.DataflowBlockOptions.EnsureOrdered">
      <summary>Obtiene o establece un valor que indica si se debe exigir el procesamiento ordenado en el control de mensajes de un bloque.</summary>
      <returns>
        <see langword="true" /> Si se debe aplicar el procesamiento ordenado; en caso contrario, <see langword="false" /> . El valor predeterminado es <see langword="true" />.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask">
      <summary>Obtiene o establece el número máximo de mensajes que se pueden procesar por tarea.</summary>
      <returns>Número máximo de mensajes. El valor predeterminado es -1, que indica un número ilimitado de mensajes.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.DataflowBlockOptions.NameFormat">
      <summary>Obtiene o establece la cadena de formato que se va a utilizar cuando un bloque se consulta para conocer su nombre.</summary>
      <returns>Cadena de formato que se va a usar cuando se consulte el nombre de un bloque.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler">
      <summary>Obtiene o establece el objeto <see cref="T:System.Threading.Tasks.TaskScheduler" /> que se usará para las tareas de programación.</summary>
      <returns>Programador de tareas.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions">
      <summary>Proporciona las opciones usadas para configurar un vínculo entre bloques de flujo de datos.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowLinkOptions.#ctor">
      <summary>Inicializa el <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" />.</summary>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.DataflowLinkOptions.Append">
      <summary>Obtiene o establece si el vínculo se debe anexar a la lista de vínculos del origen o si debe anteponerse.</summary>
      <returns>Devuelve <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.DataflowLinkOptions.MaxMessages">
      <summary>Obtiene o establece el número máximo de mensajes que se pueden utilizar a través del vínculo.</summary>
      <returns>Devuelve <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.DataflowLinkOptions.PropagateCompletion">
      <summary>Obtiene o establece si la finalización y notificación de desplazamiento se propagarán al destino vinculado automáticamente.</summary>
      <returns>Devuelve <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader">
      <summary>Proporciona un contenedor de atributos de datos para pasarlo entre los bloques de flujo de datos.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowMessageHeader.#ctor(System.Int64)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> con los atributos especificados.</summary>
      <param name="id">Identificador del mensaje. Debe ser único dentro del bloque de origen. No es necesario que sea único globalmente.</param>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowMessageHeader.Equals(System.Object)">
      <summary>Comprueba la igualdad de las instancias de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del cuadro por identificador.</summary>
      <param name="obj">Una instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> a la que se ha aplicado la conversión boxing.</param>
      <returns>
        <see langword="true" /> si las instancias son iguales; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowMessageHeader.Equals(System.Threading.Tasks.Dataflow.DataflowMessageHeader)">
      <summary>Comprueba la igualdad de dos instancias de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> por identificador sin la conversión boxing.</summary>
      <param name="other">Otra instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />.</param>
      <returns>
        <see langword="true" /> si las instancias son iguales; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowMessageHeader.GetHashCode">
      <summary>Genera un código hash para esta instancia <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />.</summary>
      <returns>Código hash.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowMessageHeader.op_Equality(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.DataflowMessageHeader)">
      <summary>Comprueba la igualdad de dos instancias de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> por identificador.</summary>
      <param name="left">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />.</param>
      <param name="right">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />.</param>
      <returns>
        <see langword="true" /> si las instancias son iguales; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowMessageHeader.op_Inequality(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.DataflowMessageHeader)">
      <summary>Comprueba la desigualdad de dos instancias de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> por identificador.</summary>
      <param name="left">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />.</param>
      <param name="right">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />.</param>
      <returns>
        <see langword="true" /> si las instancias no son iguales; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.DataflowMessageHeader.Id">
      <summary>Obtiene el identificador de mensaje dentro del origen.</summary>
      <returns>IDENTIFICADOR contenido en la  <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> instancia de.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.DataflowMessageHeader.IsValid">
      <summary>Obtiene la validez del mensaje.</summary>
      <returns>
        <see langword="true" /> si el identificador del mensaje es distinto de 0. <see langword="false" /> si el identificador del mensaje es 0.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.DataflowMessageStatus">
      <summary>Representa el estado de un elemento <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> cuando se pasa entre bloques de flujo de datos.</summary>
    </member>
    <member name="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted">
      <summary>Indica que <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> aceptó el mensaje. Una vez que un destino ha aceptado un mensaje, se convierte en su propietario.</summary>
    </member>
    <member name="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined">
      <summary>Indica que <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> rechazó el mensaje. <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> todavía posee el mensaje.</summary>
    </member>
    <member name="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently">
      <summary>Indica que <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> rechazó el mensaje. <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> todavía posee el mensaje.  
  
Además, <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> rechazará todos los mensajes futuros enviados por el origen.</summary>
    </member>
    <member name="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable">
      <summary>Indica que <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> intentó aceptar el mensaje de <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />, pero el mensaje ya no estaba disponible.</summary>
    </member>
    <member name="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed">
      <summary>Indica que <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> pospuso el mensaje para el consumo potencial en otro momento.  
  
<see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> todavía posee el mensaje.</summary>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions">
      <summary>Proporciona las opciones usadas para configurar el procesamiento realizado por los bloques de flujo de datos que procesan cada mensaje mediante la invocación de un delegado proporcionado por el usuario. Estos son bloques de flujo de datos como <see cref="T:System.Threading.Tasks.Dataflow.ActionBlock`1" /> y <see cref="T:System.Threading.Tasks.Dataflow.TransformBlock`2" />.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.#ctor">
      <summary>Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions" />.</summary>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism">
      <summary>Obtiene el número de mensajes máximo que el bloque puede procesar simultáneamente.</summary>
      <returns>Número máximo de mensajes.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.SingleProducerConstrained">
      <summary>Obtiene si el código que usa el bloque de flujo de datos está restringido a un productor al mismo tiempo.</summary>
      <returns>Devuelve <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions">
      <summary>Proporciona las opciones usadas para configurar el procesamiento que realizan los bloques de flujo de datos que agrupan varios mensajes. Estos son bloques de flujo de datos como <see cref="T:System.Threading.Tasks.Dataflow.JoinBlock`2" /> y <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" />.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.#ctor">
      <summary>Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions" />.</summary>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy">
      <summary>Obtiene o establece el valor booleano que se va a usar para determinar si se realiza el consumo expansivo de mensajes ofrecidos.</summary>
      <returns>
        <see langword="true" /> para usar de forma expansiva mensajes ofrecidos; si no, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.MaxNumberOfGroups">
      <summary>Obtiene o establece el número máximo de grupos que debe generar el bloque.</summary>
      <returns>Número máximo de grupos.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.IDataflowBlock">
      <summary>Representa un bloque de flujo de datos.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete">
      <summary>Señala a <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> que no debe aceptar ni mostrar más mensajes ni usar más mensajes pospuestos.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(System.Exception)">
      <summary>Hace que <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> se complete en un estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />.</summary>
      <param name="exception">
        <see cref="T:System.Exception" /> que causó el error.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="exception" /> es <see langword="null" />.</exception>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion">
      <summary>Obtiene una <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica y la finalización del bloque de flujo de datos.</summary>
      <returns>Tarea.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.IPropagatorBlock`2">
      <summary>Representa un bloque de flujo de datos que es tanto un destino como un origen de datos.</summary>
      <typeparam name="TInput">Especifica el tipo de datos que acepta  <see cref="T:System.Threading.Tasks.Dataflow.IPropagatorBlock`2" /> .</typeparam>
      <typeparam name="TOutput">Especifica el tipo de datos suministrado por el  <see cref="T:System.Threading.Tasks.Dataflow.IPropagatorBlock`2" /> .</typeparam>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1">
      <summary>Representa un bloque de flujo de datos que admite la recepción de mensajes sin vincular.</summary>
      <typeparam name="TOutput">Especifica el tipo de datos que suministra <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1.TryReceive(System.Predicate{`0},`0@)">
      <summary>Intentos de recibir sincrónicamente un elemento de salida disponible de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="filter">El valor del predicado debe pasar correctamente para que se reciba.  <paramref name="filter" /> puede ser <see langword="null" />, en cuyo caso se pasarán todos los elementos.</param>
      <param name="item">Elemento recibido del origen.</param>
      <returns>Es <see langword="true" /> si se pudo recibir un elemento; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1.TryReceiveAll(System.Collections.Generic.IList{`0}@)">
      <summary>Intentos de recibir sincrónicamente todos los elementos disponibles de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="items">Elementos recibidos del origen.</param>
      <returns>Es <see langword="true" /> si se podían recibir uno o más elementos; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.ISourceBlock`1">
      <summary>Representa un bloque de flujo de datos que es un origen de datos.</summary>
      <typeparam name="TOutput">Especifica el tipo de datos suministrado por el  <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> .</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)">
      <summary>Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para aceptar y usar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecida previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está usando.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que consume el mensaje.</param>
      <param name="messageConsumed">
        <see langword="true" /> si se ha consumido correctamente el mensaje; de lo contrario, es <see langword="false" />.</param>
      <exception cref="T:System.ArgumentException">messageHeader no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">El destino es <see langword="null" />.</exception>
      <returns>Valor del mensaje consumido. Esto puede corresponder a una instancia diferente de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que se ha reservado y pasado previamente como <paramref name="messageHeader" /> a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" />. La interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> de consumo debe usar el valor devuelto en lugar del valor pasado como <paramref name="messageValue" /> mediante <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />.  
  
Si el mensaje solicitado no está disponible, el valor devuelto será NULL.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Threading.Tasks.Dataflow.DataflowLinkOptions)">
      <summary>Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado.</summary>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> con el que conectar este origen.</param>
      <param name="linkOptions">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" /> que configura el vínculo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="target" /> es NULL (Nothing en Visual Basic) o <paramref name="linkOptions" /> es NULL (Nothing en Visual Basic).</exception>
      <returns>IDisposable que, al llamar a Dispose, desvinculará el origen del destino.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})">
      <summary>Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para liberar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> reservada previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje reservado que se va a liberar.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que libera el mensaje que reservó previamente.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="target" /> no tiene el mensaje reservado.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})">
      <summary>Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para reservar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecida previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está reservando.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que reserva el mensaje.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <returns>
        <see langword="true" /> si se ha procesado correctamente el mensaje; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.ITargetBlock`1">
      <summary>Representa un bloque de flujo de datos que es un destino de datos.</summary>
      <typeparam name="TInput">Especifica el tipo de datos que acepta <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)">
      <summary>Ofrece un mensaje a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, dando al destino la oportunidad de usar o de posponer el mensaje.</summary>
      <param name="messageHeader">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que representa el encabezado del mensaje que se va a ofrecer.</param>
      <param name="messageValue">Valor del mensaje que se va a ofrecer.</param>
      <param name="source">
        <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> que ofrece el mensaje. Puede ser null.</param>
      <param name="consumeToAccept">Establézcalo en <see langword="true" /> para indicar al destino para llamar a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" /> sincrónicamente durante la llamada a <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />, antes de devolver <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" />, para usar el mensaje.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.  
  
O bien, <paramref name="consumeToAccept" /> solo puede ser true si se le proporciona un valor <paramref name="source" /> distinto de NULL.</exception>
      <returns>Estado del mensaje ofrecido. Si el destino aceptó el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" /> y el origen ya no debe usar más el mensaje ofrecido, ya que ahora es propiedad del destino. Si el destino pospuso el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed" /> como notificación de que el destino puede intentar más adelante consumir o reservar el mensaje; mientras tanto, el origen todavía posee el mensaje y puede ofrecerlo a otros bloques.  
  
Si el destino hubiera pospuesto de otra forma el mensaje, pero el origen fuera <see langword="null" />, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" /> en su lugar.  
  
Si el destino intentó aceptar el mensaje pero no pudo hacerlo porque el origen entrega el mensaje a otro destino o lo descarta simplemente, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable" />.  
  
Si el destino eligió no aceptar el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" />. Si el destino eligió no aceptar el mensaje y nunca aceptará otro mensaje de este origen, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently" />.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.JoinBlock`2">
      <summary>Proporciona un bloque de flujo de datos que combina varios orígenes de flujo de datos, no necesariamente del mismo tipo, donde se espera a que llegue un elemento de cada tipo antes de que todos se liberen de forma conjunta como una tupla que consta de un elemento por tipo.</summary>
      <typeparam name="T1">Especifica el tipo de datos aceptados por el primer destino del bloque.</typeparam>
      <typeparam name="T2">Especifica el tipo de datos aceptados por el segundo destino del bloque.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`2.#ctor">
      <summary>Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Dataflow.JoinBlock`2" />.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`2.#ctor(System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions)">
      <summary>Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Dataflow.JoinBlock`2" />.</summary>
      <param name="dataflowBlockOptions">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.JoinBlock`2" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`2.Complete">
      <summary>Señala a <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> que no debe aceptar ni mostrar más mensajes ni usar más mensajes pospuestos.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`2.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{`0,`1}},System.Threading.Tasks.Dataflow.DataflowLinkOptions)">
      <summary>Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado.</summary>
      <param name="target">Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado.</param>
      <param name="linkOptions">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" /> que configura el vínculo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="target" /> es <see langword="null" /> (Nothing en Visual Basic) o <paramref name="linkOptions" /> es <see langword="null" /> (Nothing en Visual Basic).</exception>
      <returns>IDisposable que, al llamar a Dispose, desvinculará el origen del destino.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`2.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)">
      <summary>Hace que la interfaz <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> se complete en un estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> .</summary>
      <param name="exception">
        <see cref="T:System.Exception" /> que causó el error.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="exception" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock{System#Tuple{T1@T2}}#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{`0,`1}},System.Boolean@)">
      <summary>Pasa la propiedad del mensaje identificado por <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se va a consumir.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> para el que se va a consumir el mensaje.</param>
      <param name="messageConsumed">
        <see langword="true" /> si se ha consumido correctamente el mensaje. En caso contrario, es <see langword="false" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="target" /> es <see langword="null" /> (Nothing en Visual Basic).</exception>
      <returns>Valor del mensaje consumido. Esto puede corresponder a una instancia diferente de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que se ha reservado y pasado previamente como <paramref name="messageHeader" /> en este método. El elemento <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> de consumo debe usar el valor devuelto en lugar del valor pasado como <paramref name="messageValue" /> en <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />. Si el mensaje solicitado no está disponible, el valor devuelto es <see langword="null" /> (<see langword="Nothing" /> en Visual Basic).</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock{System#Tuple{T1@T2}}#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{`0,`1}})">
      <summary>Libera el derecho para pasar la propiedad del mensaje identificado por <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> de <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje reservado.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que actualmente contiene la reserva.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="target" /> es <see langword="null" /> (Nothing en Visual Basic).</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="target" /> no tiene el mensaje reservado.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock{System#Tuple{T1@T2}}#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{`0,`1}})">
      <summary>Reserva el derecho para pasar la propiedad del mensaje identificado por <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> de <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se va a reservar.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> para el que se va a reservar el mensaje.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="target" /> es <see langword="null" /> (Nothing en Visual Basic).</exception>
      <returns>
        <see langword="true" /> si se ha procesado correctamente el mensaje; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`2.ToString">
      <summary>Devuelve una cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</summary>
      <returns>Cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`2.TryReceive(System.Predicate{System.Tuple{`0,`1}},System.Tuple{`0,`1}@)">
      <summary>Intentos de recibir sincrónicamente un elemento de salida disponible de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="filter">El valor del predicado debe pasar correctamente para que se reciba.  <paramref name="filter" /> puede ser <see langword="null" />, en cuyo caso se pasarán todos los elementos.</param>
      <param name="item">Elemento recibido del origen.</param>
      <returns>Es <see langword="true" /> si se pudo recibir un elemento; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`2.TryReceiveAll(System.Collections.Generic.IList{System.Tuple{`0,`1}}@)">
      <summary>Intentos de recibir sincrónicamente todos los elementos disponibles de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="items">Elementos recibidos del origen.</param>
      <returns>Es <see langword="true" /> si se podían recibir uno o más elementos; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.JoinBlock`2.Completion">
      <summary>Obtiene un objeto <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica y la finalización del bloque de flujo de datos.</summary>
      <returns>Tarea.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.JoinBlock`2.OutputCount">
      <summary>Obtiene el número de elementos de salida disponibles que se pueden recibir de este bloque.</summary>
      <returns>Número de elementos de salida.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.JoinBlock`2.Target1">
      <summary>Obtiene un destino que se puede usar para ofrecer mensajes del primer tipo.</summary>
      <returns>Destino.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.JoinBlock`2.Target2">
      <summary>Obtiene un destino que se puede usar para ofrecer mensajes del segundo tipo.</summary>
      <returns>Destino.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.JoinBlock`3">
      <summary>Proporciona un bloque de flujo de datos que combina varios orígenes de flujo de datos, que no son necesariamente del mismo tipo, donde se espera a que llegue un elemento de cada tipo antes de que todos queden libres de forma conjunta como una tupla que contiene un elemento por tipo.</summary>
      <typeparam name="T1">Especifica el tipo de datos aceptados por el primer destino del bloque.</typeparam>
      <typeparam name="T2">Especifica el tipo de datos aceptados por el segundo destino del bloque.</typeparam>
      <typeparam name="T3">Especifica el tipo de datos aceptados por el tercer destino del bloque.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`3.#ctor">
      <summary>Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Dataflow.JoinBlock`3" />.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`3.#ctor(System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions)">
      <summary>Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Dataflow.JoinBlock`3" />.</summary>
      <param name="dataflowBlockOptions">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.JoinBlock`2" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`3.Complete">
      <summary>Señala a <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> que no debe aceptar ni mostrar más mensajes ni usar más mensajes pospuestos.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`3.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{`0,`1,`2}},System.Threading.Tasks.Dataflow.DataflowLinkOptions)">
      <summary>Vincula el bloque de origen al bloque de destino especificado.</summary>
      <param name="target">El bloque de destino al que se va a conectar este origen.</param>
      <param name="linkOptions">Objeto que configura el vínculo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="target" /> es <see langword="null" />.  
  
o bien 
 <paramref name="linkOptions" /> es <see langword="null" />.</exception>
      <returns>Objeto descartable que desvincula el origen del destino cuando se llama a su método <see cref="M:System.IDisposable.Dispose" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`3.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)">
      <summary>Hace que <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> se complete en un estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />.</summary>
      <param name="exception">
        <see cref="T:System.Exception" /> que causó el error.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="exception" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`3.System#Threading#Tasks#Dataflow#ISourceBlock{System#Tuple{T1@T2@T3}}#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{`0,`1,`2}},System.Boolean@)">
      <summary>Pasa la propiedad del mensaje identificado por <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se va a consumir.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> para el que se va a consumir el mensaje.</param>
      <param name="messageConsumed">
        <see langword="true" /> si se ha consumido correctamente el mensaje. En caso contrario, es <see langword="false" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="target" /> es <see langword="null" /> (Nothing en Visual Basic).</exception>
      <returns>Valor del mensaje consumido. Esto puede corresponder a una instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> diferente de la reservada previamente y que se pasó como <paramref name="messageHeader" /> a este método. El objeto <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> de consumo debe usar el valor devuelto en lugar del valor pasado como <paramref name="messageValue" /> a <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />. Si el mensaje solicitado no está disponible, el valor devuelto es <see langword="null" /> (<see langword="Nothing" /> en Visual Basic).</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`3.System#Threading#Tasks#Dataflow#ISourceBlock{System#Tuple{T1@T2@T3}}#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{`0,`1,`2}})">
      <summary>Libera el derecho para pasar la propiedad del mensaje identificado por <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> de <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje reservado.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que actualmente contiene la reserva.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="target" /> es <see langword="null" /> (Nothing en Visual Basic).</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="target" /> no tiene el mensaje reservado.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`3.System#Threading#Tasks#Dataflow#ISourceBlock{System#Tuple{T1@T2@T3}}#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{`0,`1,`2}})">
      <summary>Reserva el derecho para pasar la propiedad del mensaje identificado por <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> de <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se va a reservar.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> para el que se va a reservar el mensaje.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="target" /> es <see langword="null" /> (Nothing en Visual Basic).</exception>
      <returns>
        <see langword="true" /> si se ha procesado correctamente el mensaje; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`3.ToString">
      <summary>Devuelve una cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</summary>
      <returns>Cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`3.TryReceive(System.Predicate{System.Tuple{`0,`1,`2}},System.Tuple{`0,`1,`2}@)">
      <summary>Intentos de recibir sincrónicamente un elemento de salida disponible de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="filter">El valor del predicado debe pasar correctamente para que se reciba.  <paramref name="filter" /> puede ser <see langword="null" />, en cuyo caso se pasarán todos los elementos.</param>
      <param name="item">Elemento recibido del origen.</param>
      <returns>Es <see langword="true" /> si se pudo recibir un elemento; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`3.TryReceiveAll(System.Collections.Generic.IList{System.Tuple{`0,`1,`2}}@)">
      <summary>Intentos de recibir sincrónicamente todos los elementos disponibles de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="items">Elementos recibidos del origen.</param>
      <returns>Es <see langword="true" /> si se podían recibir uno o más elementos; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.JoinBlock`3.Completion">
      <summary>Obtiene un objeto <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica y la finalización del bloque de flujo de datos.</summary>
      <returns>Tarea.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.JoinBlock`3.OutputCount">
      <summary>Obtiene el número de elementos de salida disponibles que se pueden recibir de este bloque.</summary>
      <returns>Número de elementos de salida.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.JoinBlock`3.Target1">
      <summary>Obtiene un destino que se puede usar para ofrecer mensajes del primer tipo.</summary>
      <returns>Destino.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.JoinBlock`3.Target2">
      <summary>Obtiene un destino que se puede usar para ofrecer mensajes del segundo tipo.</summary>
      <returns>Destino.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.JoinBlock`3.Target3">
      <summary>Obtiene un destino que se puede usar para ofrecer mensajes del tercer tipo.</summary>
      <returns>Destino.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.TransformBlock`2">
      <summary>Proporciona un bloque de flujo de datos que invoca un delegado proporcionado de <see cref="T:System.Func`2" /> para cada elemento de datos recibido.</summary>
      <typeparam name="TInput">Especifica el tipo de datos recibidos y con los que opera <see cref="T:System.Threading.Tasks.Dataflow.TransformBlock`2" />.</typeparam>
      <typeparam name="TOutput">Especifica el tipo de resultado de los datos  <see cref="T:System.Threading.Tasks.Dataflow.TransformBlock`2" /> .</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.#ctor(System.Func{`0,`1})">
      <summary>Inicializa un <see cref="T:System.Threading.Tasks.Dataflow.TransformBlock`2" /> nuevo con las <see cref="T:System.Func`2" /> especificadas.</summary>
      <param name="transform">Función que se va a invocar con cada elemento de datos recibido.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="transform" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.#ctor(System.Func{`0,`1},System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions)">
      <summary>Inicializa un nuevo <see cref="T:System.Threading.Tasks.Dataflow.TransformBlock`2" /> con el <see cref="T:System.Func`2" /> y las <see cref="T:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions" /> especificados.</summary>
      <param name="transform">Función que se va a invocar con cada elemento de datos recibido.</param>
      <param name="dataflowBlockOptions">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.TransformBlock`2" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="transform" /> es <see langword="null" />.  
  
o bien 
El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.#ctor(System.Func{`0,System.Threading.Tasks.Task{`1}})">
      <summary>Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Dataflow.TransformBlock`2" /> con el <see cref="T:System.Func`2" /> especificado.</summary>
      <param name="transform">Función que se va a invocar con cada elemento de datos recibido.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="transform" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.#ctor(System.Func{`0,System.Threading.Tasks.Task{`1}},System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions)">
      <summary>Inicializa un nuevo <see cref="T:System.Threading.Tasks.Dataflow.TransformBlock`2" /> con el <see cref="T:System.Func`2" /> y las <see cref="T:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions" /> especificados.</summary>
      <param name="transform">Función que se va a invocar con cada elemento de datos recibido.</param>
      <param name="dataflowBlockOptions">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.TransformBlock`2" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="transform" /> es <see langword="null" />.  
  
o bien 
El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.Complete">
      <summary>Señala a <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> que no debe aceptar ni mostrar más mensajes ni usar más mensajes pospuestos.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{`1},System.Threading.Tasks.Dataflow.DataflowLinkOptions)">
      <summary>Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado.</summary>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> con el que conectar este origen.</param>
      <param name="linkOptions">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" /> que configura el vínculo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="target" /> es NULL (Nothing en Visual Basic) o <paramref name="linkOptions" /> es NULL (Nothing en Visual Basic).</exception>
      <returns>IDisposable que, al llamar a Dispose, desvinculará el origen del destino.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)">
      <summary>Hace que <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> se complete en un estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />.</summary>
      <param name="exception">
        <see cref="T:System.Exception" /> que causó el error.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="exception" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock{TOutput}#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`1},System.Boolean@)">
      <summary>Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para aceptar y usar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecida previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está usando.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que consume el mensaje.</param>
      <param name="messageConsumed">
        <see langword="true" /> si se ha consumido correctamente el mensaje; de lo contrario, es <see langword="false" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <returns>Valor del mensaje consumido. Esto puede corresponder a una instancia diferente de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que se ha reservado y pasado previamente como <paramref name="messageHeader" /> a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" />. La interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> de consumo debe usar el valor devuelto en lugar del valor pasado como <paramref name="messageValue" /> mediante <see cref="M:System.Threading.Tasks.Dataflow.TransformBlock`2.System#Threading#Tasks#Dataflow#ITargetBlock{TInput}#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />.  
  
Si el mensaje solicitado no está disponible, el valor devuelto será <see langword="null" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock{TOutput}#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`1})">
      <summary>Lo llama un <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculado para liberar un <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> reservado previamente por este <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje reservado que se va a liberar.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que libera el mensaje que reservó previamente.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="target" /> no tiene el mensaje reservado.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock{TOutput}#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`1})">
      <summary>Lo llama un <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculado para reservar un <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecido previamente por este <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está reservando.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que reserva el mensaje.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <returns>
        <see langword="true" /> si se ha procesado correctamente el mensaje; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.System#Threading#Tasks#Dataflow#ITargetBlock{TInput}#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)">
      <summary>Ofrece un mensaje a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, dando al destino la oportunidad de usar o de posponer el mensaje.</summary>
      <param name="messageHeader">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que representa el encabezado del mensaje que se va a ofrecer.</param>
      <param name="messageValue">Valor del mensaje que se va a ofrecer.</param>
      <param name="source">
        <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> que ofrece el mensaje. Puede ser <see langword="null" />.</param>
      <param name="consumeToAccept">
        <see langword="true" /> si el destino debe llamar a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" /> sincrónicamente durante la llamada al <see cref="M:System.Threading.Tasks.Dataflow.TransformBlock`2.System#Threading#Tasks#Dataflow#ITargetBlock{TInput}#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />, antes de devolver <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" />, para usar el mensaje.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.  
  
O bien, <paramref name="consumeToAccept" /> solo puede ser true si se le proporciona un valor <paramref name="source" /> distinto de NULL.</exception>
      <returns>Estado del mensaje ofrecido. Si el destino aceptó el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" /> y el origen ya no debe usar más el mensaje ofrecido, ya que ahora es propiedad del destino. Si el destino pospuso el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed" /> como notificación de que el destino puede intentar más adelante consumir o reservar el mensaje; mientras tanto, el origen todavía posee el mensaje y puede ofrecerlo a otros bloques.  
  
Si el destino se hubiera pospuesto de otra forma, pero el origen era <see langword="null" />, se devolvería <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" /> en su lugar.  
  
Si el destino intentó aceptar el mensaje pero no pudo hacerlo porque el origen entrega el mensaje a otro destino o lo descarta simplemente, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable" />.  
  
Si el destino eligió no aceptar el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" />. Si el destino eligió no aceptar el mensaje y nunca aceptará otro mensaje de este origen, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.ToString">
      <summary>Devuelve una cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</summary>
      <returns>Cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.TryReceive(System.Predicate{`1},`1@)">
      <summary>Intentos de recibir sincrónicamente un elemento de salida disponible de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="filter">El valor del predicado debe pasar correctamente para que se reciba.  <paramref name="filter" /> puede ser <see langword="null" />, en cuyo caso se pasarán todos los elementos.</param>
      <param name="item">Elemento recibido del origen.</param>
      <returns>Es <see langword="true" /> si se pudo recibir un elemento; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.TryReceiveAll(System.Collections.Generic.IList{`1}@)">
      <summary>Intentos de recibir sincrónicamente todos los elementos disponibles de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="items">Elementos recibidos del origen.</param>
      <returns>Es <see langword="true" /> si se podían recibir uno o más elementos; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.TransformBlock`2.Completion">
      <summary>Obtiene un objeto <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica y la finalización del bloque de flujo de datos.</summary>
      <returns>Tarea.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.TransformBlock`2.InputCount">
      <summary>Obtiene el número de elementos de entrada en espera de ser procesados por este bloque.</summary>
      <returns>Número de elementos de entrada.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.TransformBlock`2.OutputCount">
      <summary>Obtiene el número de elementos de salida disponibles que se pueden recibir de este bloque.</summary>
      <returns>Número de elementos de salida.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2">
      <summary>Proporciona un bloque de flujo de datos que invoca un delegado proporcionado de <see cref="T:System.Func`2" /> para cada elemento de datos recibido.</summary>
      <typeparam name="TInput">Especifica el tipo de datos recibidos y con los que opera <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" />.</typeparam>
      <typeparam name="TOutput">Especifica el tipo de salida de datos de <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" />.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.#ctor(System.Func{`0,System.Collections.Generic.IEnumerable{`1}})">
      <summary>Inicializa una nueva <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" /> con la función especificada.</summary>
      <param name="transform">Función que se va a invocar con cada elemento de datos recibido. Todos los datos devueltos en <see cref="T:System.Collections.Generic.IEnumerable`1" /> estarán disponibles como resultado de este <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="transform" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.#ctor(System.Func{`0,System.Collections.Generic.IEnumerable{`1}},System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" /> con la función y el <see cref="T:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions" /> especificados.</summary>
      <param name="transform">Función que se va a invocar con cada elemento de datos recibido. Todos los datos devueltos en <see cref="T:System.Collections.Generic.IEnumerable`1" /> estarán disponibles como resultado de este <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" />.</param>
      <param name="dataflowBlockOptions">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="transform" /> es <see langword="null" />.  
  
o bien 
El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.#ctor(System.Func{`0,System.Threading.Tasks.Task{System.Collections.Generic.IEnumerable{`1}}})">
      <summary>Inicializa una nueva <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" /> con la función especificada.</summary>
      <param name="transform">Función que se va a invocar con cada elemento de datos recibido. Todos los datos devueltos de forma asincrónica en <see cref="T:System.Collections.Generic.IEnumerable`1" /> estarán disponibles como resultado de este <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="transform" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.#ctor(System.Func{`0,System.Threading.Tasks.Task{System.Collections.Generic.IEnumerable{`1}}},System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" /> con la función y el <see cref="T:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions" /> especificados.</summary>
      <param name="transform">Función que se va a invocar con cada elemento de datos recibido. Todos los datos devueltos de forma asincrónica en <see cref="T:System.Collections.Generic.IEnumerable`1" /> estarán disponibles como resultado de este <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" />.</param>
      <param name="dataflowBlockOptions">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="transform" /> es <see langword="null" />.  
  
o bien 
El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.Complete">
      <summary>Señala a <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> que no debe aceptar ni mostrar más mensajes ni usar más mensajes pospuestos.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{`1},System.Threading.Tasks.Dataflow.DataflowLinkOptions)">
      <summary>Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado.</summary>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> con el que conectar este origen.</param>
      <param name="linkOptions">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" /> que configura el vínculo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="target" /> es NULL (Nothing en Visual Basic) o <paramref name="linkOptions" /> es NULL (Nothing en Visual Basic).</exception>
      <returns>IDisposable que, al llamar a Dispose, desvinculará el origen del destino.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)">
      <summary>Hace que <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> se complete en un estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />.</summary>
      <param name="exception">
        <see cref="T:System.Exception" /> que causó el error.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="exception" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock{TOutput}#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`1},System.Boolean@)">
      <summary>Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para aceptar y usar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecida previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está usando.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que consume el mensaje.</param>
      <param name="messageConsumed">
        <see langword="true" /> si se ha consumido correctamente el mensaje; de lo contrario, es <see langword="false" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <returns>Valor del mensaje consumido. Esto puede corresponder a una instancia diferente de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que se ha reservado y pasado previamente como <paramref name="messageHeader" /> a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" />. La interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> de consumo debe usar el valor devuelto en lugar del valor pasado como <paramref name="messageValue" /> mediante <see cref="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.System#Threading#Tasks#Dataflow#ITargetBlock{TInput}#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" /> OfferMessage.  
  
Si el mensaje solicitado no está disponible, el valor devuelto será <see langword="null" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock{TOutput}#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`1})">
      <summary>Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para liberar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> reservada previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje reservado que se va a liberar.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que libera el mensaje que reservó previamente.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="target" /> no tiene el mensaje reservado.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock{TOutput}#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`1})">
      <summary>Lo llama un <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculado para reservar un <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecido previamente por este <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está reservando.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que reserva el mensaje.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <returns>
        <see langword="true" /> si se ha procesado correctamente el mensaje; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.System#Threading#Tasks#Dataflow#ITargetBlock{TInput}#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)">
      <summary>Ofrece un mensaje a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, dando al destino la oportunidad de usar o de posponer el mensaje.</summary>
      <param name="messageHeader">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que representa el encabezado del mensaje que se va a ofrecer.</param>
      <param name="messageValue">Valor del mensaje que se va a ofrecer.</param>
      <param name="source">
        <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> que ofrece el mensaje. Puede ser <see langword="null" />.</param>
      <param name="consumeToAccept">
        <see langword="true" /> si el destino debe llamar a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" /> sincrónicamente durante la llamada al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, antes de devolver <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" />, para usar el mensaje.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.  
  
o bien 
 <paramref name="consumeToAccept" /> solo puede ser true si se le proporciona un valor <paramref name="source" /> distinto de null.</exception>
      <returns>Estado del mensaje ofrecido. Si el destino aceptó el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" /> y el origen ya no debe usar más el mensaje ofrecido, ya que ahora es propiedad del destino. Si el destino pospuso el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed" /> como notificación de que el destino puede intentar más adelante consumir o reservar el mensaje; mientras tanto, el origen todavía posee el mensaje y puede ofrecerlo a otros bloques.  
  
Si el destino se hubiera pospuesto de otra forma, pero el origen era <see langword="null" />, se devolvería <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" /> en su lugar.  
  
Si el destino intentó aceptar el mensaje pero no pudo hacerlo porque el origen entrega el mensaje a otro destino o lo descarta simplemente, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable" />.  
  
Si el destino eligió no aceptar el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" />. Si el destino eligió no aceptar el mensaje y nunca aceptará otro mensaje de este origen, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.ToString">
      <summary>Devuelve una cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</summary>
      <returns>Cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.TryReceive(System.Predicate{`1},`1@)">
      <summary>Intentos de recibir sincrónicamente un elemento de salida disponible de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="filter">El valor del predicado debe pasar correctamente para que se reciba.  <paramref name="filter" /> puede ser <see langword="null" />, en cuyo caso se pasarán todos los elementos.</param>
      <param name="item">Elemento recibido del origen.</param>
      <returns>Es <see langword="true" /> si se pudo recibir un elemento; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.TryReceiveAll(System.Collections.Generic.IList{`1}@)">
      <summary>Intentos de recibir sincrónicamente todos los elementos disponibles de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="items">Elementos recibidos del origen.</param>
      <returns>Es <see langword="true" /> si se podían recibir uno o más elementos; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.TransformManyBlock`2.Completion">
      <summary>Obtiene un objeto <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica y la finalización del bloque de flujo de datos.</summary>
      <returns>Tarea.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.TransformManyBlock`2.InputCount">
      <summary>Obtiene el número de elementos de entrada en espera de ser procesados por este bloque.</summary>
      <returns>Número de elementos de entrada.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.TransformManyBlock`2.OutputCount">
      <summary>Obtiene el número de elementos de salida disponibles que se pueden recibir de este bloque.</summary>
      <returns>Número de elementos de salida.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.WriteOnceBlock`1">
      <summary>Proporciona un búfer para recibir y almacenar a lo sumo un elemento en una red de bloques de flujo de datos.</summary>
      <typeparam name="T">Especifica el tipo de los datos almacenados en el búfer por este bloque de flujo de datos.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.WriteOnceBlock`1.#ctor(System.Func{`0,`0})">
      <summary>Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Dataflow.WriteOnceBlock`1" />.</summary>
      <param name="cloningFunction">Función que se va a usar para clonar los datos cuando se ofrezcan a otros bloques.</param>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.WriteOnceBlock`1.#ctor(System.Func{`0,`0},System.Threading.Tasks.Dataflow.DataflowBlockOptions)">
      <summary>Inicializa un <see cref="T:System.Threading.Tasks.Dataflow.WriteOnceBlock`1" /> nuevo con las <see cref="T:System.Threading.Tasks.Dataflow.DataflowBlockOptions" /> especificadas.</summary>
      <param name="cloningFunction">Función que se va a usar para clonar los datos cuando se ofrezcan a otros bloques.</param>
      <param name="dataflowBlockOptions">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.WriteOnceBlock`1" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.WriteOnceBlock`1.Complete">
      <summary>Señala a <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> que no debe aceptar ni mostrar más mensajes ni usar más mensajes pospuestos.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.WriteOnceBlock`1.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Threading.Tasks.Dataflow.DataflowLinkOptions)">
      <summary>Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado.</summary>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> con el que conectar este origen.</param>
      <param name="linkOptions">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" /> que configura el vínculo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="target" /> es NULL (Nothing en Visual Basic) o <paramref name="linkOptions" /> es NULL (Nothing en Visual Basic).</exception>
      <returns>IDisposable que, al llamar a Dispose, desvinculará el origen del destino.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.WriteOnceBlock`1.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)">
      <summary>Hace que la interfaz <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> se complete en un estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> .</summary>
      <param name="exception">
        <see cref="T:System.Exception" /> que causó el error.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="exception" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.WriteOnceBlock`1.System#Threading#Tasks#Dataflow#IReceivableSourceBlock{T}#TryReceiveAll(System.Collections.Generic.IList{`0}@)">
      <summary>Intentos de recibir sincrónicamente todos los elementos disponibles de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="items">Elementos recibidos del origen.</param>
      <returns>Es <see langword="true" /> si se podían recibir uno o más elementos; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.WriteOnceBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock{T}#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)">
      <summary>Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para aceptar y usar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecida previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está usando.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que consume el mensaje.</param>
      <param name="messageConsumed">
        <see langword="true" /> si se ha consumido correctamente el mensaje; de lo contrario, es <see langword="false" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <returns>Valor del mensaje consumido. Esto puede corresponder a una instancia diferente de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que se ha reservado y pasado previamente como <paramref name="messageHeader" /> a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" />. La interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> de consumo debe usar el valor devuelto en lugar del valor pasado como <paramref name="messageValue" /> mediante <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />.  
  
Si el mensaje solicitado no está disponible, el valor devuelto será <see langword="null" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.WriteOnceBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock{T}#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})">
      <summary>Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para liberar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> reservada previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje reservado que se va a liberar.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que libera el mensaje que reservó previamente.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="target" /> no tiene el mensaje reservado.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.WriteOnceBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock{T}#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})">
      <summary>Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para reservar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecida previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está reservando.</param>
      <param name="target">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que reserva el mensaje.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <returns>
        <see langword="true" /> si se ha procesado correctamente el mensaje; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.WriteOnceBlock`1.System#Threading#Tasks#Dataflow#ITargetBlock{T}#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)">
      <summary>Ofrece un mensaje a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, dando al destino la oportunidad de usar o de posponer el mensaje.</summary>
      <param name="messageHeader">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que representa el encabezado del mensaje que se va a ofrecer.</param>
      <param name="messageValue">Valor del mensaje que se va a ofrecer.</param>
      <param name="source">
        <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> que ofrece el mensaje. Puede ser <see langword="null" />.</param>
      <param name="consumeToAccept">Establézcalo en <see langword="true" /> para indicar al destino para llamar a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" /> sincrónicamente durante la llamada a <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />, antes de devolver <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" />, para usar el mensaje.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="messageHeader" /> no es válido.  
  
O bien, <paramref name="consumeToAccept" /> solo puede ser true si se le proporciona un valor <paramref name="source" /> distinto de NULL.</exception>
      <returns>Estado del mensaje ofrecido. Si el destino aceptó el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" /> y el origen ya no debe usar más el mensaje ofrecido, ya que ahora es propiedad del destino. Si el destino pospuso el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed" /> como notificación de que el destino puede intentar más adelante consumir o reservar el mensaje; mientras tanto, el origen todavía posee el mensaje y puede ofrecerlo a otros bloques.  
  
Si el destino habría pospuesto de otra forma el mensaje, pero <paramref name="source" /> era <see langword="null" />, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" /> en su lugar.  
  
Si el destino intentó aceptar el mensaje pero no pudo hacerlo porque el origen entrega el mensaje a otro destino o lo descarta simplemente, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable" />.  
  
Si el destino eligió no aceptar el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" />. Si el destino eligió no aceptar el mensaje y nunca aceptará otro mensaje de este origen, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.WriteOnceBlock`1.ToString">
      <summary>Devuelve una cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</summary>
      <returns>Cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.WriteOnceBlock`1.TryReceive(System.Predicate{`0},`0@)">
      <summary>Intentos de recibir sincrónicamente un elemento de salida disponible de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="filter">El valor del predicado debe pasar correctamente para que se reciba.  <paramref name="filter" /> puede ser <see langword="null" />, en cuyo caso se pasarán todos los elementos.</param>
      <param name="item">Elemento recibido del origen.</param>
      <returns>Es <see langword="true" /> si se pudo recibir un elemento; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.WriteOnceBlock`1.Completion">
      <summary>Obtiene un objeto <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica y la finalización del bloque de flujo de datos.</summary>
      <returns>Tarea.</returns>
    </member>
  </members>
</doc>