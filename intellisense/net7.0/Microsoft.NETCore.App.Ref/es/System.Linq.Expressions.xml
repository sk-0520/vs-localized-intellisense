<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Linq.Expressions</name>
  </assembly>
  <members>
    <member name="T:System.Dynamic.BinaryOperationBinder">
      <summary>Representa la operación binaria dinámica en el sitio de la llamada, que proporciona la semántica de los enlaces y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.#ctor(System.Linq.Expressions.ExpressionType)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Dynamic.BinaryOperationBinder" />.</summary>
      <param name="operation">Tipo de operación binaria.</param>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación binaria dinámica.</summary>
      <param name="target">Destino de la operación dinámica.</param>
      <param name="args">Matriz de argumentos de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.FallbackBinaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Realiza el enlace de la operación binaria dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <param name="target">Destino de la operación binaria dinámica.</param>
      <param name="arg">Operando del lado derecho de la operación binaria dinámica.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.FallbackBinaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Cuando se reemplaza en la clase derivada, realiza el enlace de la operación binaria dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target">Destino de la operación binaria dinámica.</param>
      <param name="arg">Operando del lado derecho de la operación binaria dinámica.</param>
      <param name="errorSuggestion">Resultado cuando el enlace produce un error, o NULL.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.BinaryOperationBinder.Operation">
      <summary>Tipo de operación binaria.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa el tipo de operación binaria.</returns>
    </member>
    <member name="P:System.Dynamic.BinaryOperationBinder.ReturnType">
      <summary>Tipo de resultado de la operación.</summary>
      <returns>Tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.BindingRestrictions">
      <summary>Representa un conjunto de restricciones de enlace en la clase <see cref="T:System.Dynamic.DynamicMetaObject" /> bajo la que el enlace dinámico es válido.</summary>
    </member>
    <member name="F:System.Dynamic.BindingRestrictions.Empty">
      <summary>Representa un conjunto vacío de restricciones de enlace. Este campo es de solo lectura.</summary>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.Combine(System.Collections.Generic.IList{System.Dynamic.DynamicMetaObject})">
      <summary>Combina las restricciones de enlace de la lista de instancias de <see cref="T:System.Dynamic.DynamicMetaObject" /> en un conjunto de restricciones.</summary>
      <param name="contributingObjects">Lista de instancias de <see cref="T:System.Dynamic.DynamicMetaObject" /> a partir de la que se combinan las restricciones.</param>
      <returns>Nuevo conjunto de restricciones de enlace.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetExpressionRestriction(System.Linq.Expressions.Expression)">
      <summary>Crea la restricción obligatoria que comprueba la expresión en busca de propiedades inmutables arbitrarias.</summary>
      <param name="expression">Expresión que representa las restricciones.</param>
      <returns>Nuevas restricciones de enlace.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetInstanceRestriction(System.Linq.Expressions.Expression,System.Object)">
      <summary>Crea la restricción de enlace que comprueba la expresión en busca de la identidad de instancias de objeto.</summary>
      <param name="expression">Expresión que se va a comprobar.</param>
      <param name="instance">Instancia de objeto exacta que se va a comprobar.</param>
      <returns>Nuevas restricciones de enlace.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetTypeRestriction(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea la restricción de enlace que comprueba la expresión en busca de la identidad de tipos en tiempo de ejecución.</summary>
      <param name="expression">Expresión que se va a comprobar.</param>
      <param name="type">Tipo exacto que se va a comprobar.</param>
      <returns>Nuevas restricciones de enlace.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.Merge(System.Dynamic.BindingRestrictions)">
      <summary>Combina el conjunto de restricciones de enlace con las restricciones de enlace actuales.</summary>
      <param name="restrictions">Conjunto de restricciones de enlace con el que se combinan las restricciones de enlace actuales.</param>
      <returns>Nuevo conjunto de restricciones de enlace.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.ToExpression">
      <summary>Crea el objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa las restricciones de enlace.</summary>
      <returns>Árbol de expresión que representa las restricciones.</returns>
    </member>
    <member name="T:System.Dynamic.CallInfo">
      <summary>Describe los argumentos del proceso de enlace dinámico.</summary>
    </member>
    <member name="M:System.Dynamic.CallInfo.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.String})">
      <summary>Crea una nueva clase CallInfo que representa los argumentos del proceso de enlace dinámico.</summary>
      <param name="argCount">Número de argumentos.</param>
      <param name="argNames">Nombres de argumento.</param>
    </member>
    <member name="M:System.Dynamic.CallInfo.#ctor(System.Int32,System.String[])">
      <summary>Crea un nuevo elemento <c>PositionalArgumentInfo</c>.</summary>
      <param name="argCount">Número de argumentos.</param>
      <param name="argNames">Nombres de argumento.</param>
    </member>
    <member name="M:System.Dynamic.CallInfo.Equals(System.Object)">
      <summary>Determina si la instancia de CallInfo especificada se considera igual que la actual.</summary>
      <param name="obj">Instancia de <see cref="T:System.Dynamic.CallInfo" /> que se va a comparar con la instancia actual.</param>
      <returns>
        <see langword="true" /> si la instancia especificada es igual que la actual; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Dynamic.CallInfo.GetHashCode">
      <summary>Sirve como función hash para el objeto <see cref="T:System.Dynamic.CallInfo" /> actual.</summary>
      <returns>Código hash para el objeto <see cref="T:System.Dynamic.CallInfo" /> actual.</returns>
    </member>
    <member name="P:System.Dynamic.CallInfo.ArgumentCount">
      <summary>Número de argumentos.</summary>
      <returns>Número de argumentos.</returns>
    </member>
    <member name="P:System.Dynamic.CallInfo.ArgumentNames">
      <summary>Nombres de argumento.</summary>
      <returns>Colección de solo lectura de nombres de argumento.</returns>
    </member>
    <member name="T:System.Dynamic.ConvertBinder">
      <summary>Representa la operación de conversión dinámica en el sitio de la llamada, que proporciona la semántica de los enlaces y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.#ctor(System.Type,System.Boolean)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Dynamic.ConvertBinder" />.</summary>
      <param name="type">Tipo al que se va a convertir.</param>
      <param name="explicit">Es true si la conversión debe considerar las conversiones explícitas; de lo contrario, es false.</param>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de conversión dinámica.</summary>
      <param name="target">Destino de la operación de conversión dinámica.</param>
      <param name="args">Matriz de argumentos de la operación de conversión dinámica.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.FallbackConvert(System.Dynamic.DynamicMetaObject)">
      <summary>Realiza el enlace de la operación de conversión dinámica si no se puede enlazar el objeto dinámico de destino.</summary>
      <param name="target">Destino de la operación de conversión dinámica.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.FallbackConvert(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de conversión dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target">Destino de la operación de conversión dinámica.</param>
      <param name="errorSuggestion">Resultado de enlace que se usa si se produce un error de enlace, o null.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.Explicit">
      <summary>Obtiene el valor que indica si la conversión debe considerar las conversiones explícitas.</summary>
      <returns>
        <see langword="true" /> Si hay una conversión explícita; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.ReturnType">
      <summary>Tipo de resultado de la operación.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.Type">
      <summary>Tipo al que se va a convertir.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo en el que se va a convertir.</returns>
    </member>
    <member name="T:System.Dynamic.CreateInstanceBinder">
      <summary>Representa la operación de creación dinámica en el sitio de la llamada, que proporciona la semántica de los enlaces y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Dynamic.CreateInstanceBinder" />.</summary>
      <param name="callInfo">Firma de los argumentos en el sitio de llamada.</param>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de creación dinámica.</summary>
      <param name="target">Destino de la operación de creación dinámica.</param>
      <param name="args">Matriz de argumentos de la operación de creación dinámica.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.FallbackCreateInstance(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de creación dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target">Destino de la operación de creación dinámica.</param>
      <param name="args">Argumentos de la operación de creación dinámica.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.FallbackCreateInstance(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de creación dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target">Destino de la operación de creación dinámica.</param>
      <param name="args">Argumentos de la operación de creación dinámica.</param>
      <param name="errorSuggestion">Resultado de enlace que se usa si se produce un error de enlace, o null.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.CreateInstanceBinder.CallInfo">
      <summary>Obtiene la firma de los argumentos en el sitio de llamada.</summary>
      <returns>Firma de los argumentos en el sitio de llamada.</returns>
    </member>
    <member name="P:System.Dynamic.CreateInstanceBinder.ReturnType">
      <summary>Tipo de resultado de la operación.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.DeleteIndexBinder">
      <summary>Representa la operación de eliminación dinámica en el sitio de la llamada, que proporciona la semántica de los enlaces y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Dynamic.DeleteIndexBinder" />.</summary>
      <param name="callInfo">Firma de los argumentos en el sitio de llamada.</param>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de eliminación de índice dinámica.</summary>
      <param name="target">Destino de la operación de eliminación de índice dinámica.</param>
      <param name="args">Matriz de argumentos de la operación de eliminación de índice dinámica.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.FallbackDeleteIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de eliminación de índice dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target">Destino de la operación de eliminación de índice dinámica.</param>
      <param name="indexes">Argumentos de la operación de eliminación de índice dinámica.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.FallbackDeleteIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de eliminación de índice dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target">Destino de la operación de eliminación de índice dinámica.</param>
      <param name="indexes">Argumentos de la operación de eliminación de índice dinámica.</param>
      <param name="errorSuggestion">Resultado de enlace que se usa si se produce un error de enlace, o null.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteIndexBinder.CallInfo">
      <summary>Obtiene la firma de los argumentos en el sitio de llamada.</summary>
      <returns>Firma de los argumentos en el sitio de llamada.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteIndexBinder.ReturnType">
      <summary>Tipo de resultado de la operación.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.DeleteMemberBinder">
      <summary>Representa la operación de eliminación dinámica de miembros en el sitio de la llamada, que proporciona la semántica de los enlaces y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.#ctor(System.String,System.Boolean)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Dynamic.DeleteIndexBinder" />.</summary>
      <param name="name">Nombre del miembro que se va a eliminar.</param>
      <param name="ignoreCase">Es true si no se debe distinguir entre mayúsculas y minúsculas en la comparación; de lo contrario, es false.</param>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de eliminación de miembros dinámica.</summary>
      <param name="target">Destino de la operación de eliminación de miembros dinámica.</param>
      <param name="args">Una matriz de argumentos de la operación de eliminación de miembros dinámica.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.FallbackDeleteMember(System.Dynamic.DynamicMetaObject)">
      <summary>Realiza el enlace de la operación de eliminación de miembros dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <param name="target">Destino de la operación de eliminación de miembros dinámica.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.FallbackDeleteMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de eliminación de miembros dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target">Destino de la operación de eliminación de miembros dinámica.</param>
      <param name="errorSuggestion">Resultado de enlace que se usa si se produce un error de enlace, o null.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.IgnoreCase">
      <summary>Obtiene el valor que indica si la comparación de cadena no debe distinguir entre mayúsculas y minúsculas en el nombre del miembro.</summary>
      <returns>
        <see langword="true" /> Si la comparación de cadenas debe omitir mayúsculas y minúsculas; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.Name">
      <summary>Obtiene el nombre del miembro que se va a eliminar.</summary>
      <returns>Nombre del miembro que se va a eliminar.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.ReturnType">
      <summary>Tipo de resultado de la operación.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicMetaObject">
      <summary>Representa el enlace dinámico y una lógica de enlace de un objeto que participa en el enlace dinámico.</summary>
    </member>
    <member name="F:System.Dynamic.DynamicMetaObject.EmptyMetaObjects">
      <summary>Representa una matriz vacía de tipo <see cref="T:System.Dynamic.DynamicMetaObject" />. Este campo es de solo lectura.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.#ctor(System.Linq.Expressions.Expression,System.Dynamic.BindingRestrictions)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <param name="expression">Expresión que representa este objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> durante el proceso de enlace dinámico.</param>
      <param name="restrictions">Conjunto de restricciones de enlace en las que el enlace es válido.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.#ctor(System.Linq.Expressions.Expression,System.Dynamic.BindingRestrictions,System.Object)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <param name="expression">Expresión que representa este objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> durante el proceso de enlace dinámico.</param>
      <param name="restrictions">Conjunto de restricciones de enlace en las que el enlace es válido.</param>
      <param name="value">Valor en tiempo de ejecución representado por el parámetro <see cref="T:System.Dynamic.DynamicMetaObject" />.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Dynamic.DynamicMetaObject)">
      <summary>Realiza el enlace de la operación binaria dinámica.</summary>
      <param name="binder">Instancia de la clase <see cref="T:System.Dynamic.BinaryOperationBinder" /> que representa los detalles de la operación dinámica.</param>
      <param name="arg">Una instancia de <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el lado derecho de la operación binaria.</param>
      <returns>Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindConvert(System.Dynamic.ConvertBinder)">
      <summary>Realiza el enlace de la operación de conversión dinámica.</summary>
      <param name="binder">Instancia de la clase <see cref="T:System.Dynamic.ConvertBinder" /> que representa los detalles de la operación dinámica.</param>
      <returns>Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindCreateInstance(System.Dynamic.CreateInstanceBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de creación de instancias dinámica.</summary>
      <param name="binder">Instancia de la clase <see cref="T:System.Dynamic.CreateInstanceBinder" /> que representa los detalles de la operación dinámica.</param>
      <param name="args">Una matriz de instancias de <see cref="T:System.Dynamic.DynamicMetaObject" />: argumentos para crear la operación de creación de instancias.</param>
      <returns>Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de eliminación de índice dinámica.</summary>
      <param name="binder">Instancia de la clase <see cref="T:System.Dynamic.DeleteIndexBinder" /> que representa los detalles de la operación dinámica.</param>
      <param name="indexes">Una matriz de instancias de <see cref="T:System.Dynamic.DynamicMetaObject" />: índices para la operación de eliminación de índice.</param>
      <returns>Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindDeleteMember(System.Dynamic.DeleteMemberBinder)">
      <summary>Realiza el enlace de la operación de eliminación de miembros dinámica.</summary>
      <param name="binder">Instancia de la clase <see cref="T:System.Dynamic.DeleteMemberBinder" /> que representa los detalles de la operación dinámica.</param>
      <returns>Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindGetIndex(System.Dynamic.GetIndexBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de obtención de índice dinámica.</summary>
      <param name="binder">Instancia de la clase <see cref="T:System.Dynamic.GetIndexBinder" /> que representa los detalles de la operación dinámica.</param>
      <param name="indexes">Una matriz de instancias de <see cref="T:System.Dynamic.DynamicMetaObject" />: índices para la operación de obtención de índice.</param>
      <returns>Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindGetMember(System.Dynamic.GetMemberBinder)">
      <summary>Realiza el enlace de la operación de obtención de miembros dinámica.</summary>
      <param name="binder">Instancia de la clase <see cref="T:System.Dynamic.GetMemberBinder" /> que representa los detalles de la operación dinámica.</param>
      <returns>Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindInvoke(System.Dynamic.InvokeBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de invocación dinámica.</summary>
      <param name="binder">Instancia de la clase <see cref="T:System.Dynamic.InvokeBinder" /> que representa los detalles de la operación dinámica.</param>
      <param name="args">Matriz de instancias de <see cref="T:System.Dynamic.DynamicMetaObject" />: argumentos para la operación de invocación.</param>
      <returns>Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindInvokeMember(System.Dynamic.InvokeMemberBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de invocación de miembros dinámica.</summary>
      <param name="binder">Instancia de la clase <see cref="T:System.Dynamic.InvokeMemberBinder" /> que representa los detalles de la operación dinámica.</param>
      <param name="args">Matriz de instancias de <see cref="T:System.Dynamic.DynamicMetaObject" />: argumentos para la operación de invocación de miembros.</param>
      <returns>Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindSetIndex(System.Dynamic.SetIndexBinder,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Realiza el enlace de la operación de establecimiento de índice dinámica.</summary>
      <param name="binder">Instancia de la clase <see cref="T:System.Dynamic.SetIndexBinder" /> que representa los detalles de la operación dinámica.</param>
      <param name="indexes">Una matriz de instancias de <see cref="T:System.Dynamic.DynamicMetaObject" />: índices para la operación de establecimiento de índice.</param>
      <param name="value">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el valor para la operación de establecimiento de índice.</param>
      <returns>Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindSetMember(System.Dynamic.SetMemberBinder,System.Dynamic.DynamicMetaObject)">
      <summary>Realiza el enlace de la operación de establecimiento de miembros dinámica.</summary>
      <param name="binder">Instancia de la clase <see cref="T:System.Dynamic.SetMemberBinder" /> que representa los detalles de la operación dinámica.</param>
      <param name="value">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el valor para la operación de establecimiento de miembros.</param>
      <returns>Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindUnaryOperation(System.Dynamic.UnaryOperationBinder)">
      <summary>Realiza el enlace de la operación unaria dinámica.</summary>
      <param name="binder">Instancia de la clase <see cref="T:System.Dynamic.UnaryOperationBinder" /> que representa los detalles de la operación dinámica.</param>
      <returns>Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.Create(System.Object,System.Linq.Expressions.Expression)">
      <summary>Crea un metaobjeto para el objeto especificado.</summary>
      <param name="value">Objeto para el que se va a obtener un metaobjeto.</param>
      <param name="expression">Expresión que representa este objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> durante el proceso de enlace dinámico.</param>
      <returns>Si el objeto especificado implementa <see cref="T:System.Dynamic.IDynamicMetaObjectProvider" /> y no es un objeto remoto de fuera del AppDomain actual, devuelve el metaobjeto específico del objeto devuelto por el método <see cref="M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)" />. De lo contrario, se crea y se devuelve un nuevo metaobjeto sin formato y sin restricciones.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.GetDynamicMemberNames">
      <summary>Devuelve la enumeración de todos los nombres de miembro dinámicos.</summary>
      <returns>Lista de nombres de miembro dinámicos.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Expression">
      <summary>Expresión que representa el objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> durante el proceso de enlace dinámico.</summary>
      <returns>Expresión que representa el objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> durante el proceso de enlace dinámico.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.HasValue">
      <summary>Obtiene un valor que indica si <see cref="T:System.Dynamic.DynamicMetaObject" /> tiene el valor en tiempo de ejecución.</summary>
      <returns>
        <see langword="true" /> Si <see cref="T:System.Dynamic.DynamicMetaObject" /> tiene el valor en tiempo de ejecución; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.LimitType">
      <summary>Obtiene el tipo de límite del objeto <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <returns>
        <see cref="P:System.Dynamic.DynamicMetaObject.RuntimeType" /> si el valor en tiempo de ejecución está disponible; de lo contrario, un tipo de la propiedad <see cref="P:System.Dynamic.DynamicMetaObject.Expression" />.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Restrictions">
      <summary>Conjunto de restricciones de enlace en las que el enlace es válido.</summary>
      <returns>Conjunto de restricciones de enlace.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.RuntimeType">
      <summary>Obtiene el objeto <see cref="T:System.Type" /> del valor en tiempo de ejecución, o NULL si <see cref="T:System.Dynamic.DynamicMetaObject" /> no tiene ningún valor asociado.</summary>
      <returns>
        <see cref="T:System.Type" /> del valor en tiempo de ejecución o NULL.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Value">
      <summary>Valor en tiempo de ejecución representado por el objeto <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <returns>Valor en tiempo de ejecución representado por el objeto <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicMetaObjectBinder">
      <summary>Enlazador de sitio de llamada dinámico que participa en el protocolo de enlace <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Dynamic.DynamicMetaObjectBinder" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Cuando se reemplaza en la clase derivada, realiza el enlace de la operación dinámica.</summary>
      <param name="target">Destino de la operación dinámica.</param>
      <param name="args">Matriz de argumentos de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Bind(System.Object[],System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.LabelTarget)">
      <summary>Realiza el enlace en tiempo de ejecución de la operación dinámica sobre un conjunto de argumentos.</summary>
      <param name="args">Matriz de argumentos de la operación dinámica.</param>
      <param name="parameters">Matriz de instancias de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representan los parámetros del sitio de llamada en el proceso de enlace.</param>
      <param name="returnLabel">Objeto LabelTarget utilizado para devolver el resultado del enlace dinámico.</param>
      <returns>Expresión que realiza pruebas sobre los argumentos de la operación dinámica y realiza la operación dinámica si las pruebas son válidas. Si se produce un error en las pruebas en las repeticiones subsiguientes de la operación dinámica, se llamará de nuevo a Bind para generar una nueva clase <see cref="T:System.Linq.Expressions.Expression" /> para los nuevos tipos de argumento.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Defer(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Aplaza el enlace de la operación hasta más tarde, cuando se hayan calculado los valores en tiempo de ejecución de todos los argumentos de la operación dinámica.</summary>
      <param name="target">Destino de la operación dinámica.</param>
      <param name="args">Matriz de argumentos de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Defer(System.Dynamic.DynamicMetaObject[])">
      <summary>Aplaza el enlace de la operación hasta más tarde, cuando se hayan calculado los valores en tiempo de ejecución de todos los argumentos de la operación dinámica.</summary>
      <param name="args">Matriz de argumentos de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.GetUpdateExpression(System.Type)">
      <summary>Obtiene una expresión que provocará la actualización del enlace. Indica que el enlace de la expresión ya no es válido. Normalmente se utiliza cuando la "versión" de un objeto dinámico ha cambiado.</summary>
      <param name="type">Propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de la expresión resultante; se permite cualquier tipo.</param>
      <returns>Expresión de actualización.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObjectBinder.ReturnType">
      <summary>Tipo de resultado de la operación.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicObject">
      <summary>Proporciona una clase base para especificar el comportamiento dinámico en tiempo de ejecución. Esta clase se debe heredar; no se puede crear una instancia de la clase directamente.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicObject.#ctor">
      <summary>Permite a los tipos derivados inicializar una nueva instancia del tipo <see cref="T:System.Dynamic.DynamicObject" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicObject.GetDynamicMemberNames">
      <summary>Devuelve la enumeración de todos los nombres de miembro dinámicos.</summary>
      <returns>Secuencia que contiene nombres de miembros dinámicos.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>Proporciona un objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que envía a los métodos virtuales dinámicos. El objeto se puede encapsular dentro de otro objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> para proporcionar un comportamiento personalizado para acciones individuales. Este método admite la infraestructura de Dynamic Language Runtime para los implementadores de lenguaje y no está pensado para que se use directamente en el código.</summary>
      <param name="parameter">Expresión que representa el objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que se va a enviar a los métodos virtuales dinámicos.</param>
      <returns>Objeto de tipo <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
      <summary>Proporciona la implementación de operaciones binarias. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar un comportamiento dinámico para operaciones como la suma o la multiplicación.</summary>
      <param name="binder">Proporciona información sobre la operación binaria. La propiedad <c>binder.Operation</c> devuelve un objeto <see cref="T:System.Linq.Expressions.ExpressionType" />. Por ejemplo, para la instrucción <c>sum = first + second</c>, donde <c>first</c> y <c>second</c> se derivan de la clase <see langword="DynamicObject" />, <c>binder.Operation</c> devuelve <c>ExpressionType.Add</c>.</param>
      <param name="arg">Operando derecho de la operación binaria. Por ejemplo, para la instrucción <c>sum = first + second</c>, donde <c>first</c> y <c>second</c> se derivan de la clase <see langword="DynamicObject" />, <paramref name="arg" /> es igual a <c>second</c>.</param>
      <param name="result">Resultado de la operación binaria.</param>
      <returns>
        <see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
      <summary>Proporciona la implementación de las operaciones de conversión de tipos. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar el comportamiento dinámico de las operaciones que convierten un objeto de un tipo a otro.</summary>
      <param name="binder">Proporciona información sobre la operación de conversión. La propiedad <c>binder.Type</c> proporciona el tipo en el que se debe convertir el objeto. Por ejemplo, para la instrucción <c>(String)sampleObject</c> en C# (<c>CType(sampleObject, Type)</c> en Visual Basic), donde <c>sampleObject</c> es una instancia de la clase derivada de la clase <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Type</c> devuelve el tipo <see cref="T:System.String" />. La propiedad <c>binder.Explicit</c> proporciona información sobre el tipo de conversión que se produce. Devuelve <see langword="true" /> para la conversión explícita y <see langword="false" /> para la conversión implícita.</param>
      <param name="result">Resultado de la operación de conversión de tipos.</param>
      <returns>
        <see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
      <summary>Proporciona la implementación de las operaciones que inicializan una nueva instancia de un objeto dinámico. Este método no está pensado para su uso en C# o Visual Basic.</summary>
      <param name="binder">Proporciona información sobre la operación de inicialización.</param>
      <param name="args">Argumentos que se pasan al objeto durante la inicialización. Por ejemplo, para la operación <c>new SampleType(100)</c>, donde <c>SampleType</c> es el tipo derivado de la clase <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> es igual que 100.</param>
      <param name="result">Resultado de la inicialización.</param>
      <returns>
        <see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
      <summary>Proporciona la implementación de las operaciones que eliminan un objeto por índice. Este método no está pensado para su uso en C# o Visual Basic.</summary>
      <param name="binder">Proporciona información sobre la eliminación.</param>
      <param name="indexes">Índices que se van a eliminar.</param>
      <returns>
        <see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
      <summary>Proporciona la implementación de las operaciones que eliminan un miembro de objeto. Este método no está pensado para su uso en C# o Visual Basic.</summary>
      <param name="binder">Proporciona información sobre la eliminación.</param>
      <returns>
        <see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
      <summary>Proporciona la implementación de las operaciones que obtienen un valor por índice. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar un comportamiento dinámico para las operaciones de indización.</summary>
      <param name="binder">Proporciona información sobre la operación.</param>
      <param name="indexes">Índices que se usan en la operación. Por ejemplo, para la operación <c>sampleObject[3]</c> en C# (<c>sampleObject(3)</c> en Visual Basic), donde <c>sampleObject</c> se deriva de la clase <see langword="DynamicObject" />, <c>indexes[0]</c> es igual que 3.</param>
      <param name="result">Resultado de la operación de índice.</param>
      <returns>
        <see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción en tiempo de ejecución).</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
      <summary>Proporciona la implementación de las operaciones que obtienen valores de miembro. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar un comportamiento dinámico para operaciones como obtener el valor de una propiedad.</summary>
      <param name="binder">Proporciona información sobre el objeto que llamó a la operación dinámica. La propiedad <c>binder.Name</c> proporciona el nombre del miembro en el que se realiza la operación dinámica. Por ejemplo, para la instrucción <c>Console.WriteLine(sampleObject.SampleProperty)</c>, donde <c>sampleObject</c> es una instancia de la clase derivada de la clase <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> devuelve "SampleProperty". La propiedad <c>binder.IgnoreCase</c> especifica si el nombre de miembro distingue mayúsculas de minúsculas.</param>
      <param name="result">Resultado de la operación Get. Por ejemplo, si se llama al método para una propiedad, se puede asignar el valor de la propiedad a <paramref name="result" />.</param>
      <returns>
        <see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción en tiempo de ejecución).</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
      <summary>Proporciona la implementación para las operaciones que invocan un objeto. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar un comportamiento dinámico para operaciones como invocar un objeto o un delegado.</summary>
      <param name="binder">Proporciona información sobre la operación de invocación.</param>
      <param name="args">Argumentos que se pasan al objeto durante la operación de invocación. Por ejemplo, para la operación <c>sampleObject(100)</c>, donde <c>sampleObject</c> se deriva de la clase <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> es igual que 100.</param>
      <param name="result">Resultado de la invocación de objeto.</param>
      <returns>
        <see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
      <summary>Proporciona la implementación de las operaciones que invocan un miembro. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar un comportamiento dinámico para operaciones como llamar a un método.</summary>
      <param name="binder">Proporciona información sobre la operación dinámica. La propiedad <c>binder.Name</c> proporciona el nombre del miembro en el que se realiza la operación dinámica. Por ejemplo, para la instrucción <c>sampleObject.SampleMethod(100)</c>, donde <c>sampleObject</c> es una instancia de la clase derivada de la clase <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> devuelve "SampleMethod". La propiedad <c>binder.IgnoreCase</c> especifica si el nombre de miembro distingue mayúsculas de minúsculas.</param>
      <param name="args">Argumentos que se pasan al miembro de objeto durante la operación de invocación. Por ejemplo, para la instrucción <c>sampleObject.SampleMethod(100)</c>, donde <c>sampleObject</c> se deriva de la clase <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> es igual que 100.</param>
      <param name="result">Resultado de la invocación del miembro.</param>
      <returns>
        <see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
      <summary>Proporciona la implementación de las operaciones que establecen un valor por índice. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar el comportamiento dinámico de las operaciones que tienen acceso a los objetos por un índice especificado.</summary>
      <param name="binder">Proporciona información sobre la operación.</param>
      <param name="indexes">Índices que se usan en la operación. Por ejemplo, para la operación <c>sampleObject[3] = 10</c> en C# (<c>sampleObject(3) = 10</c> en Visual Basic), donde <c>sampleObject</c> se deriva de la clase <see cref="T:System.Dynamic.DynamicObject" />, <c>indexes[0]</c> es igual que 3.</param>
      <param name="value">Valor que se establece en el objeto que tiene el índice especificado. Por ejemplo, para la operación <c>sampleObject[3] = 10</c> en C# (<c>sampleObject(3) = 10</c> en Visual Basic), donde <c>sampleObject</c> se deriva de la clase <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="value" /> es igual a 10.</param>
      <returns>
        <see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
      <summary>Proporciona la implementación de las operaciones que establecen valores de miembro. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar un comportamiento dinámico para operaciones como establecer el valor de una propiedad.</summary>
      <param name="binder">Proporciona información sobre el objeto que llamó a la operación dinámica. La propiedad <c>binder.Name</c> proporciona el nombre del miembro al que se asigna el valor. Por ejemplo, para la instrucción <c>sampleObject.SampleProperty = "Test"</c>, donde <c>sampleObject</c> es una instancia de la clase derivada de la clase <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> devuelve "SampleProperty". La propiedad <c>binder.IgnoreCase</c> especifica si el nombre de miembro distingue mayúsculas de minúsculas.</param>
      <param name="value">Valor que se va a establecer para el miembro. Por ejemplo, para <c>sampleObject.SampleProperty = "Test"</c>, donde <c>sampleObject</c> es una instancia de la clase derivada de la clase <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="value" /> es "Test".</param>
      <returns>
        <see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
      <summary>Proporciona la implementación de operaciones unarias. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar el comportamiento dinámico de operaciones como negación, incremento o decremento.</summary>
      <param name="binder">Proporciona información sobre la operación unaria. La propiedad <c>binder.Operation</c> devuelve un objeto <see cref="T:System.Linq.Expressions.ExpressionType" />. Por ejemplo, para la instrucción <c>negativeNumber = -number</c>, donde <c>number</c> se deriva de la clase <see langword="DynamicObject" />, <c>binder.Operation</c> devuelve "Negate".</param>
      <param name="result">Resultado de la operación unaria.</param>
      <returns>
        <see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
    </member>
    <member name="T:System.Dynamic.ExpandoObject">
      <summary>Representa un objeto cuyos miembros se pueden agregar y quitar de forma dinámica en tiempo de ejecución.</summary>
    </member>
    <member name="E:System.Dynamic.ExpandoObject.System#ComponentModel#INotifyPropertyChanged#PropertyChanged">
      <summary>Tiene lugar cuando cambia un valor de propiedad.</summary>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.#ctor">
      <summary>Inicializa un nuevo <see langword="ExpandoObject" /> que no tiene miembros.</summary>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>
        <see cref="T:System.Collections.IEnumerator" /> que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Dynamic#IDynamicMetaObjectProvider#GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>El MetaObject proporcionado se enviará a los métodos virtuales dinámicos. El objeto se puede encapsular dentro de otro MetaObject para proporcionar el comportamiento personalizado para acciones individuales.</summary>
      <param name="parameter">Expresión que representa el MetaObject que se va a enviar a los métodos virtuales dinámicos.</param>
      <returns>Objeto del tipo <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
    </member>
    <member name="T:System.Dynamic.GetIndexBinder">
      <summary>Representa la operación de obtención dinámica de índices en el sitio de la llamada, que proporciona la semántica de los enlaces y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Dynamic.GetIndexBinder" />.</summary>
      <param name="callInfo">Firma de los argumentos en el sitio de llamada.</param>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de obtención de índice dinámica.</summary>
      <param name="target">Destino de la operación de obtención de índice dinámica.</param>
      <param name="args">Una matriz de argumentos de la operación de obtención de índice dinámica.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.FallbackGetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de obtención de índice dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <param name="target">Destino de la operación de obtención de índice dinámica.</param>
      <param name="indexes">Argumentos de la operación de obtención de índice dinámica.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.FallbackGetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de obtención de índice dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target">Destino de la operación de obtención de índice dinámica.</param>
      <param name="indexes">Argumentos de la operación de obtención de índice dinámica.</param>
      <param name="errorSuggestion">Resultado de enlace que se usa si se produce un error de enlace, o null.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.GetIndexBinder.CallInfo">
      <summary>Obtiene la firma de los argumentos en el sitio de llamada.</summary>
      <returns>Firma de los argumentos en el sitio de llamada.</returns>
    </member>
    <member name="P:System.Dynamic.GetIndexBinder.ReturnType">
      <summary>Tipo de resultado de la operación.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.GetMemberBinder">
      <summary>Representa la operación de de obtención dinámica de miembros en el sitio de la llamada, que proporciona la semántica de los enlaces y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.#ctor(System.String,System.Boolean)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Dynamic.GetMemberBinder" />.</summary>
      <param name="name">Nombre del miembro que se va a obtener.</param>
      <param name="ignoreCase">Es true si no se debe distinguir entre mayúsculas y minúsculas en la comparación; de lo contrario, es false.</param>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de obtención de miembros dinámica.</summary>
      <param name="target">Destino de la operación de obtención de miembros dinámica.</param>
      <param name="args">Una matriz de argumentos de la operación de obtención de miembros dinámica.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.FallbackGetMember(System.Dynamic.DynamicMetaObject)">
      <summary>Realiza el enlace de la operación de obtención de miembros dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <param name="target">Destino de la operación de obtención de miembros dinámica.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.FallbackGetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de obtención de miembros dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target">Destino de la operación de obtención de miembros dinámica.</param>
      <param name="errorSuggestion">Resultado de enlace que se usa si se produce un error de enlace, o null.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.IgnoreCase">
      <summary>Obtiene el valor que indica si la comparación de cadena no debe distinguir entre mayúsculas y minúsculas en el nombre del miembro.</summary>
      <returns>
        <see langword="true" /> Si se omite el uso de mayúsculas y minúsculas; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.Name">
      <summary>Obtiene el nombre del miembro que se va a obtener.</summary>
      <returns>Nombre del miembro que se va a obtener.</returns>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.ReturnType">
      <summary>Tipo de resultado de la operación.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.IDynamicMetaObjectProvider">
      <summary>Representa un objeto dinámico, que puede tener sus operaciones enlazadas en tiempo de ejecución.</summary>
    </member>
    <member name="M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>Devuelve la clase <see cref="T:System.Dynamic.DynamicMetaObject" /> responsable de las operaciones de enlace realizadas en este objeto.</summary>
      <param name="parameter">Representación de árbol de expresión del valor en tiempo de ejecución.</param>
      <returns>Clase <see cref="T:System.Dynamic.DynamicMetaObject" /> que se va a enlazar al objeto.</returns>
    </member>
    <member name="T:System.Dynamic.IInvokeOnGetBinder">
      <summary>Representa información sobre una operación de obtención de miembros dinámica que indica si la obtención de miembros debe invocar propiedades cuando se realiza la operación Get.</summary>
    </member>
    <member name="P:System.Dynamic.IInvokeOnGetBinder.InvokeOnGet">
      <summary>Obtiene el valor que indica si esta operación de obtención de miembros debe invocar propiedades cuando se realiza la operación Get. El valor predeterminado cuando esta interfaz no está presente es true.</summary>
      <returns>
        <see langword="true" /> Si esta operación de obtención de miembros debe invocar propiedades al realizar la operación Get; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="T:System.Dynamic.InvokeBinder">
      <summary>Representa la operación de invocación dinámica en el sitio de la llamada, que proporciona la semántica de los enlaces y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Dynamic.InvokeBinder" />.</summary>
      <param name="callInfo">Firma de los argumentos en el sitio de llamada.</param>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de invocación dinámica.</summary>
      <param name="target">Destino de la operación de invocación dinámica.</param>
      <param name="args">Matriz de argumentos de la operación de invocación dinámica.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de invocación dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target">Destino de la operación de invocación dinámica.</param>
      <param name="args">Argumentos de la operación de invocación dinámica.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Realiza el enlace de la operación de invocación dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target">Destino de la operación de invocación dinámica.</param>
      <param name="args">Argumentos de la operación de invocación dinámica.</param>
      <param name="errorSuggestion">Resultado de enlace que se usa si se produce un error de enlace, o null.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeBinder.CallInfo">
      <summary>Obtiene la firma de los argumentos en el sitio de llamada.</summary>
      <returns>Firma de los argumentos en el sitio de llamada.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeBinder.ReturnType">
      <summary>Tipo de resultado de la operación.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.InvokeMemberBinder">
      <summary>Representa la operación de invocación dinámica de miembros en el sitio de la llamada, que proporciona la semántica de los enlaces y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.#ctor(System.String,System.Boolean,System.Dynamic.CallInfo)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Dynamic.InvokeMemberBinder" />.</summary>
      <param name="name">Nombre del miembro que se va a invocar.</param>
      <param name="ignoreCase">true si no se debe distinguir entre mayúsculas y minúsculas en la comparación; de lo contrario, false.</param>
      <param name="callInfo">Firma de los argumentos en el sitio de llamada.</param>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de invocación de miembros dinámica.</summary>
      <param name="target">Destino de la operación de invocación de miembros dinámica.</param>
      <param name="args">Una matriz de argumentos de la operación de invocación de miembros dinámica.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de invocación dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target">Destino de la operación de invocación dinámica.</param>
      <param name="args">Argumentos de la operación de invocación dinámica.</param>
      <param name="errorSuggestion">Resultado de enlace que se usa si se produce un error de enlace, o null.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvokeMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de invocación de miembros dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <param name="target">Destino de la operación de invocación de miembros dinámica.</param>
      <param name="args">Argumentos de la operación de invocación de miembros dinámica.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvokeMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de invocación de miembros dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target">Destino de la operación de invocación de miembros dinámica.</param>
      <param name="args">Argumentos de la operación de invocación de miembros dinámica.</param>
      <param name="errorSuggestion">Resultado de enlace que se usa si se produce un error de enlace, o null.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.CallInfo">
      <summary>Obtiene la firma de los argumentos en el sitio de llamada.</summary>
      <returns>Firma de los argumentos en el sitio de llamada.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.IgnoreCase">
      <summary>Obtiene el valor que indica si la comparación de cadena no debe distinguir entre mayúsculas y minúsculas en el nombre del miembro.</summary>
      <returns>
        <see langword="true" /> Si se omite el uso de mayúsculas y minúsculas; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.Name">
      <summary>Obtiene el nombre del miembro que se va a invocar.</summary>
      <returns>Nombre del miembro que se va a invocar.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.ReturnType">
      <summary>Tipo de resultado de la operación.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.SetIndexBinder">
      <summary>Representa la operación de de configuración dinámica de índices en el sitio de la llamada, que proporciona la semántica de los enlaces y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Dynamic.SetIndexBinder" />.</summary>
      <param name="callInfo">Firma de los argumentos en el sitio de llamada.</param>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de establecimiento de índice dinámica.</summary>
      <param name="target">Destino de la operación de establecimiento de índice dinámica.</param>
      <param name="args">Matriz de argumentos de la operación de establecimiento de índice dinámica.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.FallbackSetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Realiza el enlace de la operación de establecimiento de índice dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target">Destino de la operación de establecimiento de índice dinámica.</param>
      <param name="indexes">Argumentos de la operación de establecimiento de índice dinámica.</param>
      <param name="value">Valor que se va a establecer para la colección.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.FallbackSetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de establecimiento de índice dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <param name="target">Destino de la operación de establecimiento de índice dinámica.</param>
      <param name="indexes">Argumentos de la operación de establecimiento de índice dinámica.</param>
      <param name="value">Valor que se va a establecer para la colección.</param>
      <param name="errorSuggestion">Resultado de enlace que se usa si se produce un error de enlace, o null.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.SetIndexBinder.CallInfo">
      <summary>Obtiene la firma de los argumentos en el sitio de llamada.</summary>
      <returns>Firma de los argumentos en el sitio de llamada.</returns>
    </member>
    <member name="P:System.Dynamic.SetIndexBinder.ReturnType">
      <summary>Tipo de resultado de la operación.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.SetMemberBinder">
      <summary>Representa la operación de configuración dinámica de miembros en el sitio de la llamada, que proporciona la semántica de los enlaces y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.#ctor(System.String,System.Boolean)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Dynamic.SetMemberBinder" />.</summary>
      <param name="name">Nombre del miembro que se va a obtener.</param>
      <param name="ignoreCase">Es true si no se debe distinguir entre mayúsculas y minúsculas en la comparación; de lo contrario, es false.</param>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de establecimiento de miembros dinámica.</summary>
      <param name="target">Destino de la operación de establecimiento de miembros dinámica.</param>
      <param name="args">Una matriz de argumentos de la operación de establecimiento de miembros dinámica.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.FallbackSetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Realiza el enlace de la operación de establecimiento de miembros dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <param name="target">Destino de la operación de establecimiento de miembros dinámica.</param>
      <param name="value">Valor que se va a establecer para el miembro.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.FallbackSetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Realiza el enlace de la operación de establecimiento de miembros dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <param name="target">Destino de la operación de establecimiento de miembros dinámica.</param>
      <param name="value">Valor que se va a establecer para el miembro.</param>
      <param name="errorSuggestion">Resultado de enlace que se usa si se produce un error de enlace, o null.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.IgnoreCase">
      <summary>Obtiene el valor que indica si la comparación de cadena no debe distinguir entre mayúsculas y minúsculas en el nombre del miembro.</summary>
      <returns>
        <see langword="true" /> Si se omite el uso de mayúsculas y minúsculas; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.Name">
      <summary>Obtiene el nombre del miembro que se va a obtener.</summary>
      <returns>Nombre del miembro que se va a obtener.</returns>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.ReturnType">
      <summary>Tipo de resultado de la operación.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.UnaryOperationBinder">
      <summary>Representa la operación unaria dinámica en el sitio de la llamada, que proporciona la semántica de los enlaces y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.#ctor(System.Linq.Expressions.ExpressionType)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Dynamic.BinaryOperationBinder" />.</summary>
      <param name="operation">Tipo de operación unaria.</param>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación unaria dinámica.</summary>
      <param name="target">Destino de la operación dinámica.</param>
      <param name="args">Matriz de argumentos de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.FallbackUnaryOperation(System.Dynamic.DynamicMetaObject)">
      <summary>Realiza el enlace de la operación unaria dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <param name="target">Destino de la operación unaria dinámica.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.FallbackUnaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Realiza el enlace de la operación unaria dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <param name="target">Destino de la operación unaria dinámica.</param>
      <param name="errorSuggestion">Resultado en caso de que el enlace produzca un error, o NULL.</param>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
    </member>
    <member name="P:System.Dynamic.UnaryOperationBinder.Operation">
      <summary>Tipo de operación unaria.</summary>
      <returns>Objeto de la clase <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa el tipo de operación unaria.</returns>
    </member>
    <member name="P:System.Dynamic.UnaryOperationBinder.ReturnType">
      <summary>Tipo de resultado de la operación.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Linq.Expressions.BinaryExpression">
      <summary>Representa una expresión que tiene un operador binario.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo. Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
      <returns>Resultado de visitar este nodo.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Reduce">
      <summary>Reduce el nodo de expresión binario a una expresión más sencilla.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="left">Propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> del resultado.</param>
      <param name="conversion">Propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> del resultado.</param>
      <param name="right">Propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> del resultado.</param>
      <returns>Esta expresión si no se cambió ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.CanReduce">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión se puede reducir.</summary>
      <returns>
        <see langword="true" /> es si se puede reducir el nodo de árbol de expresión; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Conversion">
      <summary>Obtiene la función de conversión de tipos utilizada por una operación de uso combinado o una operación de asignación compuesta.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> que representa una función de conversión de tipos.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLifted">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión representa una llamada elevada a un operador.</summary>
      <returns>Es <see langword="true" /> si el nodo representa una llamada elevada; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión representa una llamada elevada a un operador cuyo tipo de valor devuelto se eleva a un tipo que acepta valores null.</summary>
      <returns>Es <see langword="true" /> si el tipo de valor devuelto del operador se eleva a un tipo que acepta valores null; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Left">
      <summary>Obtiene el operando izquierdo de la operación binaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo de la operación binaria.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Method">
      <summary>Obtiene el método de implementación para la operación binaria.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Right">
      <summary>Obtiene el operando derecho de la operación binaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho de la operación binaria.</returns>
    </member>
    <member name="T:System.Linq.Expressions.BlockExpression">
      <summary>Representa un bloque que contiene una secuencia de expresiones en la que se pueden definir variables.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo. Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
      <returns>Resultado de visitar este nodo.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="variables">Propiedad <see cref="P:System.Linq.Expressions.BlockExpression.Variables" /> del resultado.</param>
      <param name="expressions">Propiedad <see cref="P:System.Linq.Expressions.BlockExpression.Expressions" /> del resultado.</param>
      <returns>Esta expresión, si no se ha cambiado ningún elemento secundario, o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Expressions">
      <summary>Obtiene las expresiones de este bloque.</summary>
      <returns>Colección de solo lectura que contiene todas las expresiones de este bloque.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión. Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Result">
      <summary>Obtiene la última expresión de este bloque.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa la última expresión de este bloque.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.BlockExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Variables">
      <summary>Obtiene las variables definidas en este bloque.</summary>
      <returns>Colección de solo lectura que contiene todas las variables definidas en este bloque.</returns>
    </member>
    <member name="T:System.Linq.Expressions.CatchBlock">
      <summary>Representa una instrucción catch de un bloque try.</summary>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.ToString">
      <summary>Devuelve un valor de tipo <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</summary>
      <returns>Una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.Update(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="variable">Propiedad <see cref="P:System.Linq.Expressions.CatchBlock.Variable" /> del resultado.</param>
      <param name="filter">Propiedad <see cref="P:System.Linq.Expressions.CatchBlock.Filter" /> del resultado.</param>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.CatchBlock.Body" /> del resultado.</param>
      <returns>Esta expresión si no se cambió ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Body">
      <summary>Obtiene el cuerpo del bloque catch.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo de catch.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Filter">
      <summary>Obtiene el cuerpo del filtro <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del filtro <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Test">
      <summary>Obtiene el tipo de <see cref="T:System.Exception" /> que este controlador captura.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de <see cref="T:System.Exception" /> que este controlador captura.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Variable">
      <summary>Obtiene una referencia al objeto <see cref="T:System.Exception" /> capturado por este controlador.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> capturado por este controlador.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConditionalExpression">
      <summary>Representa una expresión que tiene un operador condicional.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo. Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
      <returns>Resultado de visitar este nodo.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="test">Propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> del resultado.</param>
      <param name="ifTrue">Propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> del resultado.</param>
      <param name="ifFalse">Propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> del resultado.</param>
      <returns>Esta expresión, si no se ha cambiado ningún elemento secundario, o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfFalse">
      <summary>Obtiene la expresión que se va a ejecutar si la prueba se evalúa como <see langword="false" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la expresión que se va a ejecutar si la prueba se evalúa como <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfTrue">
      <summary>Obtiene la expresión que se va a ejecutar si la prueba se evalúa como <see langword="true" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la expresión que se va a ejecutar si la prueba se evalúa como <see langword="true" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión. Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Test">
      <summary>Obtiene la prueba de la operación condicional.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la prueba de la operación condicional.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConditionalExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConstantExpression">
      <summary>Representa una expresión que tiene un valor constante.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConstantExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo. Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
      <returns>Resultado de visitar este nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión. Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConstantExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Value">
      <summary>Obtiene el valor de la expresión constante.</summary>
      <returns>
        <see cref="T:System.Object" /> igual al valor de la expresión representada.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DebugInfoExpression">
      <summary>Emite o borra un punto de secuencia para obtener información de depuración. Esto permite que el depurador resalte el código fuente correcto al depurar.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DebugInfoExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo. Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
      <returns>Resultado de visitar este nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Document">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de código fuente.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de origen.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndColumn">
      <summary>Obtiene la columna final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Número de la columna final del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndLine">
      <summary>Obtiene la línea final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Número de la línea final del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.IsClear">
      <summary>Obtiene el valor para indicar si <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> se utiliza para borrar un punto de secuencia.</summary>
      <returns>
        <see langword="true" /> es si <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> se va a borrar un punto de secuencia; en caso contrario, es <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.NodeType">
      <summary>Devuelve el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartColumn">
      <summary>Obtiene la columna inicial de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Número de la columna inicial del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartLine">
      <summary>Obtiene la línea inicial de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Número de la línea inicial del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DebugInfoExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DefaultExpression">
      <summary>Representa el valor predeterminado de un tipo o una expresión vacía.</summary>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión. Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DefaultExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DynamicExpression">
      <summary>Representa una operación dinámica.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo. Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
      <returns>Resultado de visitar este nodo.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType">Tipo de resultado de la expresión dinámica.</param>
      <param name="arguments">Argumentos de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType">Tipo de resultado de la expresión dinámica.</param>
      <param name="arg0">Primer argumento de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType">Tipo de resultado de la expresión dinámica.</param>
      <param name="arg0">Primer argumento de la operación dinámica.</param>
      <param name="arg1">Segundo argumento de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType">Tipo de resultado de la expresión dinámica.</param>
      <param name="arg0">Primer argumento de la operación dinámica.</param>
      <param name="arg1">Segundo argumento de la operación dinámica.</param>
      <param name="arg2">Tercer argumento de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType">Tipo de resultado de la expresión dinámica.</param>
      <param name="arg0">Primer argumento de la operación dinámica.</param>
      <param name="arg1">Segundo argumento de la operación dinámica.</param>
      <param name="arg2">Tercer argumento de la operación dinámica.</param>
      <param name="arg3">Cuarto argumento de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType">Tipo de resultado de la expresión dinámica.</param>
      <param name="arguments">Argumentos de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="delegateType">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arguments">Argumentos de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado y un argumento.</summary>
      <param name="delegateType">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arg0">Argumento de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado y dos argumentos.</summary>
      <param name="delegateType">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arg0">Primer argumento de la operación dinámica.</param>
      <param name="arg1">Segundo argumento de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado y tres argumentos.</summary>
      <param name="delegateType">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arg0">Primer argumento de la operación dinámica.</param>
      <param name="arg1">Segundo argumento de la operación dinámica.</param>
      <param name="arg2">Tercer argumento de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado y cuatro argumentos.</summary>
      <param name="delegateType">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arg0">Primer argumento de la operación dinámica.</param>
      <param name="arg1">Segundo argumento de la operación dinámica.</param>
      <param name="arg2">Tercer argumento de la operación dinámica.</param>
      <param name="arg3">Cuarto argumento de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="delegateType">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arguments">Argumentos de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary>Devuelve el argumento en el índice, indicando si el índice está fuera de los límites. No debe usar este miembro. Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.</summary>
      <param name="index">Índice del argumento.</param>
      <returns>Devuelve <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IDynamicExpression#CreateCallSite">
      <summary>Opcionalmente, crea el elemento CallSite y devuelve el de la caché insertada polimórfica de DynamicExpression. No debe usar este miembro. Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.</summary>
      <returns>Devuelve <see cref="T:System.Object" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IDynamicExpression#Rewrite(System.Linq.Expressions.Expression[])">
      <summary>Vuelva a escribir este nodo y reemplace los argumentos de la expresión dinámica por los valores proporcionados. El número de <paramref name="args" /> debe coincidir con el número de la expresión actual. No se debe usar este tipo. Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento. Este método del asistente permite volver a escribir los nodos de modo que sean independientes de la clase de implementación específica que deriva de la DynamicExpression que se usa en el sitio de llamada.</summary>
      <param name="args">Los argumentos.</param>
      <returns>Devuelve <see cref="T:System.Linq.Expressions.Expression" />, la expresión reescrita.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Compara el valor enviado al parámetro, <paramref name="arguments" />, con la propiedad <see langword="Arguments" /> de la instancia actual de <see langword="DynamicExpression" />. Si los valores del parámetro y la propiedad son iguales, se devuelve la instancia actual. Si no son iguales, se devuelve una instancia de <see langword="DynamicExpression" /> nueva que es idéntica a la instancia actual, excepto en que la propiedad <see langword="Arguments" /> se establece en el valor del parámetro <paramref name="arguments" />.</summary>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> del resultado.</param>
      <returns>Esta expresión si no se cambió ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Arguments">
      <summary>Obtiene los argumentos de la operación dinámica.</summary>
      <returns>Colecciones de solo lectura que contienen los argumentos de la operación dinámica.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Binder">
      <summary>Obtiene el <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />, que determina el comportamiento en tiempo de ejecución del sitio dinámico.</summary>
      <returns>
        <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />, que determina el comportamiento en tiempo de ejecución del sitio dinámico.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.DelegateType">
      <summary>Obtiene el tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión. Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary>Devuelve el número de argumentos al nodo de árbol de expresión. No debe usar este miembro. Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.</summary>
      <returns>Devuelve <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DynamicExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DynamicExpressionVisitor">
      <summary>Representa un visitante o un sistema de reescritura para los árboles de expresión dinámica.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpressionVisitor.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Linq.Expressions.DynamicExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpressionVisitor.VisitDynamic(System.Linq.Expressions.DynamicExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.DynamicExpression" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Devuelve <see cref="T:System.Linq.Expressions.Expression" />, la expresión modificada si se modifica esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ElementInit">
      <summary>Representa un inicializador para un solo elemento de una colección <see cref="T:System.Collections.IEnumerable" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary>Devuelve el argumento en el índice, indicando si el índice está fuera de los límites.  No debe usar este miembro.  Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.</summary>
      <param name="index">Índice del argumento.</param>
      <returns>Devuelve <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.ToString">
      <summary>Devuelve una representación textual de un objeto <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Representación textual del objeto <see cref="T:System.Linq.Expressions.ElementInit" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> del resultado.</param>
      <returns>Esta expresión si no se cambió ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.AddMethod">
      <summary>Obtiene el método de instancia que se usa para agregar un elemento a una colección <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de instancia que agrega un elemento a una colección.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.Arguments">
      <summary>Obtiene la colección de argumentos que se pasan a un método que agrega un elemento a una colección <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos de un método que agrega un elemento a una colección.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary>Devuelve el número de argumentos al nodo de árbol de expresión.  No debe usar este miembro.  Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.</summary>
      <returns>Devuelve <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:System.Linq.Expressions.Expression">
      <summary>Proporciona la clase base de la que se derivan las clases que representan los nodos de árbol de expresión. También contiene métodos de generador <see langword="static" /> (<see langword="Shared" /> en Visual Basic) para crear los diversos tipos de nodo. Esta es una clase <see langword="abstract" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor">
      <summary>Crea una nueva instancia de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor(System.Linq.Expressions.ExpressionType,System.Type)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <param name="nodeType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que se va a establecer como tipo de nodo.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> de este <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo. Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
      <returns>Resultado de visitar este nodo.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética sin comprobación de desbordamiento.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador de suma definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética sin comprobación de desbordamiento. Se puede especificar el método de implementación.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es <see langword="null" /> y el operador de adición no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación y suma sin comprobación de desbordamiento.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación y suma sin comprobación de desbordamiento.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación y suma sin comprobación de desbordamiento.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que tiene comprobación de desbordamiento.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que tiene comprobación de desbordamiento.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que tiene comprobación de desbordamiento.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética con comprobación de desbordamiento.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador de suma definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética con comprobación de desbordamiento. Se puede especificar el método de implementación.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es <see langword="null" /> y el operador de adición no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="AND" /> bit a bit.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador <see langword="AND" /> bit a bit definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.And" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="AND" /> bit a bit. Se puede especificar el método de implementación.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es <see langword="null" /> y el operador <see langword="AND" /> bit a bit no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.And" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="AND" /> condicional que evalúa el segundo operando únicamente si el primer operando se evalúa como <see langword="true" />.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador <see langword="AND" /> bit a bit definido para <paramref name="left" />.Type y <paramref name="right" />.Type.  
  
o bien 
 <paramref name="left" />.Type y <paramref name="right" />.Type no son del mismo tipo booleano.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="AND" /> condicional que evalúa el segundo operando solo si el primer operando se resuelve como true. Se puede especificar el método de implementación.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es <see langword="null" /> y el operador <see langword="AND" /> bit a bit no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.  
  
o bien 
 <paramref name="method" /> es <see langword="null" /> y <paramref name="left" />.Type y <paramref name="right" />.Type no son del mismo tipo booleano.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación AND bit a bit.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación AND bit a bit.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación AND bit a bit.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> para obtener acceso a una matriz multidimensional.</summary>
      <param name="array">Expresión que representa la matriz multidimensional.</param>
      <param name="indexes">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene expresiones usadas para indexar la matriz.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> para obtener acceso a una matriz.</summary>
      <param name="array">Expresión que representa la matriz para indizar.</param>
      <param name="indexes">Matriz que contiene expresiones usadas para indizar la matriz.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa la aplicación de un operador de índice de matriz a una matriz cuyo rango es mayor que uno.</summary>
      <param name="array">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />.</param>
      <param name="indexes">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> o <paramref name="indexes" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type no representa un tipo de matriz.  
  
o bien 
El rango de <paramref name="array" />.Type no coincide con el número de elementos en <paramref name="indexes" />.  
  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de uno o varios elementos de <paramref name="indexes" /> no representa el tipo <see cref="T:System.Int32" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la aplicación de un operador de índice de matriz a una matriz de rango uno.</summary>
      <param name="array">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="index">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> o <paramref name="index" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type no representa un tipo de matriz.  
  
o bien 
 <paramref name="array" />.Type representa un tipo de matriz cuyo rango no es 1.  
  
o bien 
 <paramref name="index" />.Type no representa el tipo <see cref="T:System.Int32" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa la aplicación de un operador de índice de matriz a una matriz multidimensional.</summary>
      <param name="array">Matriz de instancias o índices <see cref="T:System.Linq.Expressions.Expression" /> para la operación de índice de matriz.</param>
      <param name="indexes">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> o <paramref name="indexes" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type no representa un tipo de matriz.  
  
o bien 
El rango de <paramref name="array" />.Type no coincide con el número de elementos en <paramref name="indexes" />.  
  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de uno o varios elementos de <paramref name="indexes" /> no representa el tipo <see cref="T:System.Int32" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una expresión para obtener la longitud de una matriz unidimensional.</summary>
      <param name="array">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type no representa un tipo de matriz.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> es <paramref name="array" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa la inicialización de un campo o una propiedad.</summary>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> o <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa ningún campo ni ninguna propiedad.  
  
o bien 
La propiedad representada por <paramref name="member" /> no tiene un descriptor de acceso <see langword="set" />.  
  
o bien 
 <paramref name="expression" />.Type no se puede asignar al tipo del campo o propiedad que representa <paramref name="member" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberAssignment" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa la inicialización de un miembro mediante un método de descriptor de acceso de propiedad.</summary>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> o <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa ningún método de descriptor de acceso de propiedad.  
  
o bien 
La propiedad a la que accede <paramref name="propertyAccessor" /> no tiene un descriptor de acceso <see langword="set" />.  
  
o bien 
 <paramref name="expression" />.Type no se puede asignar al tipo del campo o propiedad que representa <paramref name="member" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberAssignment" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />, y cuya propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> se establece en <paramref name="expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones dadas y que no tiene variables.</summary>
      <param name="expressions">Expresiones del bloque.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones dadas.</summary>
      <param name="variables">Variables del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones dadas.</summary>
      <param name="variables">Variables del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene dos expresiones y que no tiene variables.</summary>
      <param name="arg0">Primera expresión del bloque.</param>
      <param name="arg1">Segunda expresión del bloque.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene tres expresiones y que no tiene variables.</summary>
      <param name="arg0">Primera expresión del bloque.</param>
      <param name="arg1">Segunda expresión del bloque.</param>
      <param name="arg2">Tercera expresión del bloque.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene cuatro expresiones y que no tiene variables.</summary>
      <param name="arg0">Primera expresión del bloque.</param>
      <param name="arg1">Segunda expresión del bloque.</param>
      <param name="arg2">Tercera expresión del bloque.</param>
      <param name="arg3">Cuarta expresión del bloque.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene cinco expresiones y que no tiene variables.</summary>
      <param name="arg0">Primera expresión del bloque.</param>
      <param name="arg1">Segunda expresión del bloque.</param>
      <param name="arg2">Tercera expresión del bloque.</param>
      <param name="arg3">Cuarta expresión del bloque.</param>
      <param name="arg4">Quinta expresión del bloque.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones dadas y que no tiene variables.</summary>
      <param name="expressions">Expresiones del bloque.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones dadas, no tiene variables y tiene el tipo de resultado específico.</summary>
      <param name="type">Tipo de resultado del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones dadas.</summary>
      <param name="type">Tipo de resultado del bloque.</param>
      <param name="variables">Variables del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones dadas.</summary>
      <param name="type">Tipo de resultado del bloque.</param>
      <param name="variables">Variables del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones dadas, no tiene variables y tiene el tipo de resultado específico.</summary>
      <param name="type">Tipo de resultado del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break. Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break con el tipo especificado. Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break con el tipo especificado.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que no toma ningún argumento.</summary>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia para una llamada al método de instancia (pasa <see langword="null" /> para un método <see langword="static" />, <see langword="Shared" /> en Visual Basic).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es <see langword="null" />.  
  
o bien 
 <paramref name="instance" /> es <see langword="null" /> y <paramref name="method" /> representa un método de instancia.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type no se puede asignar al tipo declarativo del método representado por <paramref name="method" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que toma argumentos.</summary>
      <param name="instance">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> (pase <see langword="null" /> para un método <see langword="static" />, <see langword="Shared" /> en Visual Basic).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es <see langword="null" />.  
  
o bien 
 <paramref name="instance" /> es <see langword="null" /> y <paramref name="method" /> representa un método de instancia.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type no se puede asignar al tipo declarativo del método representado por <paramref name="method" />.  
  
o bien 
El número de elementos de <paramref name="arguments" /> no es igual al número de parámetros del método representado por <paramref name="method" />.  
  
o bien 
Uno o varios elementos de <paramref name="arguments" /> no se pueden asignar al parámetro correspondiente del método representado por <paramref name="method" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que toma dos argumentos.</summary>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia de una llamada de instancia. (Pasa null para un método estático, que en Visual Basic es compartido).</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de destino.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que toma tres argumentos.</summary>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia de una llamada de instancia. (Pasa null para un método estático, que en Visual Basic es compartido).</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de destino.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que toma argumentos.</summary>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia para una llamada al método de instancia (pasa <see langword="null" /> para un método <see langword="static" />, <see langword="Shared" /> en Visual Basic).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es <see langword="null" />.  
  
o bien 
 <paramref name="instance" /> es <see langword="null" /> y <paramref name="method" /> representa un método de instancia.  
  
o bien 
 <paramref name="arguments" /> no es <see langword="null" /> y uno o varios de sus elementos son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type no se puede asignar al tipo declarativo del método representado por <paramref name="method" />.  
  
o bien 
El número de elementos de <paramref name="arguments" /> no es igual al número de parámetros del método representado por <paramref name="method" />.  
  
o bien 
Uno o varios elementos de <paramref name="arguments" /> no se pueden asignar al parámetro correspondiente del método representado por <paramref name="method" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método llamando al método del generador apropiado.</summary>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> en cuyo valor de propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> se buscará un método específico.</param>
      <param name="methodName">Nombre del método.</param>
      <param name="typeArguments">Matriz de objetos <see cref="T:System.Type" /> que especifican los parámetros de tipo del método genérico. Este argumento debería ser null cuando methodName especifica un método no genérico.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representa los argumentos del método.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instance" /> o <paramref name="methodName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No se encuentra en <paramref name="instance" />.Type o sus tipos base ningún método cuyo nombre sea <paramref name="methodName" />, cuyos parámetros de tipo coincidan con <paramref name="typeArguments" /> y cuyos tipos de parámetro se correspondan con <paramref name="arguments" />.  
  
o bien 
Se han encontrado en <paramref name="instance" />.Type o sus tipos base varios métodos cuyo nombre es <paramref name="methodName" />, cuyos parámetros de tipo coinciden con <paramref name="typeArguments" /> y cuyos tipos de parámetro se corresponden con <paramref name="arguments" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, cuya propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> es <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establece en el objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de instancia especificado y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establece en los argumentos especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático (Shared en Visual Basic).</summary>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de destino.</param>
      <param name="arguments">Colección de <see cref="T:System.Linq.Expressions.Expression" /> que representa los argumentos de la llamada.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método <see langword="static" /> (<see langword="Shared" /> en Visual Basic) que toma un argumento.</summary>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma dos argumentos.</summary>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma tres argumentos.</summary>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma cuatro argumentos.</summary>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</param>
      <param name="arg3">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuarto argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma cinco argumentos.</summary>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</param>
      <param name="arg3">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuarto argumento.</param>
      <param name="arg4">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el quinto argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método <see langword="static" /> (<see langword="Shared" /> en Visual Basic) con argumentos.</summary>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método <see langword="static" /> (<see langword="Shared" /> en Visual Basic) en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">El número de elementos de <paramref name="arguments" /> no es igual al número de parámetros del método representado por <paramref name="method" />.  
  
o bien 
Uno o varios elementos de <paramref name="arguments" /> no se pueden asignar al parámetro correspondiente del método representado por <paramref name="method" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método <see langword="static" /> (<see langword="Shared" /> en Visual Basic) llamando al método del generador apropiado.</summary>
      <param name="type">Tipo que contiene el método <see langword="static" /> (<see langword="Shared" /> en Visual Basic) especificado.</param>
      <param name="methodName">Nombre del método.</param>
      <param name="typeArguments">Matriz de objetos <see cref="T:System.Type" /> que especifican los parámetros de tipo del método genérico. Este argumento debería ser null cuando methodName especifica un método no genérico.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos del método.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="methodName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No se encuentra en <paramref name="type" /> o sus tipos base ningún método cuyo nombre sea <paramref name="methodName" />, cuyos parámetros de tipo coincidan con <paramref name="typeArguments" /> y cuyos tipos de parámetro se correspondan con <paramref name="arguments" />.  
  
o bien 
Se han encontrado en <paramref name="type" /> o sus tipos base varios métodos cuyo nombre es <paramref name="methodName" />, cuyos parámetros de tipo coinciden con <paramref name="typeArguments" /> y cuyos tipos de parámetro se corresponden con <paramref name="arguments" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, cuya propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establece en el objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método <see langword="static" /> (<see langword="Shared" /> en Visual Basic) especificado, y cuya propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establece en los argumentos especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con una referencia al objeto <see cref="T:System.Exception" /> detectado para su uso en el cuerpo del controlador.</summary>
      <param name="variable">Objeto <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> detectado por este controlador.</param>
      <param name="body">Cuerpo de la instrucción Catch.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con un filtro <see cref="T:System.Exception" /> y una referencia al objeto <see cref="T:System.Exception" /> detectado.</summary>
      <param name="variable">Objeto <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> detectado por este controlador.</param>
      <param name="body">Cuerpo de la instrucción Catch.</param>
      <param name="filter">Cuerpo del filtro <see cref="T:System.Exception" />.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch.</summary>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que este <see cref="T:System.Linq.Expressions.CatchBlock" /> controlará.</param>
      <param name="body">Cuerpo de la instrucción Catch.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con un filtro <see cref="T:System.Exception" /> pero sin ninguna referencia al objeto <see cref="T:System.Exception" /> detectado.</summary>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que este <see cref="T:System.Linq.Expressions.CatchBlock" /> controlará.</param>
      <param name="body">Cuerpo de la instrucción Catch.</param>
      <param name="filter">Cuerpo del filtro <see cref="T:System.Exception" />.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> para borrar un punto de secuencia.</summary>
      <param name="document">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de origen.</param>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> para borrar un punto de secuencia.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de uso combinado.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> no representa un tipo de referencia ni un tipo de valor que acepta valores null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type y <paramref name="right" />.Type no se pueden convertir entre sí.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de fusión, dada una función de conversión.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type y <paramref name="right" />.Type no se pueden convertir entre sí.  
  
o bien 
 <paramref name="conversion" /> no es <see langword="null" /> y <paramref name="conversion" />.Type es un tipo de delegado que no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> no representa un tipo de referencia ni un tipo de valor que acepta valores null.  
  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> representa un tipo que no se puede asignar al tipo de parámetro del tipo de delegado <paramref name="conversion" />.Type.  
  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="right" /> no es igual que el tipo de valor devuelto del tipo de delegado <paramref name="conversion" />.Type.</exception>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa una instrucción condicional.</summary>
      <param name="test">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="test" /> o <paramref name="ifTrue" /> o <paramref name="ifFalse" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="test" />.Type no es <see cref="T:System.Boolean" />.  
  
o bien 
 <paramref name="ifTrue" />.Type no es igual que <paramref name="ifFalse" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa una instrucción condicional.</summary>
      <param name="test">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tiene la propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> establecida en el valor especificado.</summary>
      <param name="value">Objeto <see cref="T:System.Object" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.ConstantExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> se establece en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> establecidas en los valores especificados.</summary>
      <param name="value">Objeto <see cref="T:System.Object" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> no es <see langword="null" /> y <paramref name="type" /> no se puede asignar a partir del tipo dinámico de <paramref name="value" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.ConstantExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Continue.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Continue con el tipo especificado.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión de tipos.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador de conversión definido entre <paramref name="expression" />.Type y <paramref name="type" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la operación de conversión para la que se especifica el método de implementación.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador de conversión definido entre <paramref name="expression" />.Type y <paramref name="type" />.  
  
o bien 
 <paramref name="expression" />.Type no se puede asignar al tipo de argumento del método representado por <paramref name="method" />.  
  
o bien 
El tipo de valor devuelto del método representado por <paramref name="method" /> no se puede asignar a <paramref name="type" />.  
  
o bien 
 <paramref name="expression" />.Type o <paramref name="type" /> es un tipo de valor que acepta valores null y el correspondiente tipo de valor que no acepta valores null no es igual que el tipo de argumento o el tipo de valor devuelto, respectivamente, del método representado por <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Se ha encontrado más de un método que coincide con la descripción de <paramref name="method" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión que produce una excepción si está desbordado el tipo de destino.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador de conversión definido entre <paramref name="expression" />.Type y <paramref name="type" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión que produce una excepción si está desbordado el tipo de destino y para la que se especifica el método de implementación.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador de conversión definido entre <paramref name="expression" />.Type y <paramref name="type" />.  
  
o bien 
 <paramref name="expression" />.Type no se puede asignar al tipo de argumento del método representado por <paramref name="method" />.  
  
o bien 
El tipo de valor devuelto del método representado por <paramref name="method" /> no se puede asignar a <paramref name="type" />.  
  
o bien 
 <paramref name="expression" />.Type o <paramref name="type" /> es un tipo de valor que acepta valores null y el correspondiente tipo de valor que no acepta valores null no es igual que el tipo de argumento o el tipo de valor devuelto, respectivamente, del método representado por <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Se ha encontrado más de un método que coincide con la descripción de <paramref name="method" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> con el intervalo especificado.</summary>
      <param name="document">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de origen.</param>
      <param name="startLine">Línea de inicio de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Debe ser mayor que 0.</param>
      <param name="startColumn">Columna de inicio de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Debe ser mayor que 0.</param>
      <param name="endLine">Línea final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Debe ser mayor o igual que la línea de inicio.</param>
      <param name="endColumn">Columna final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Si la línea de fin es igual que la de inicio, debe ser mayor o igual que la columna de inicio. En cualquier caso, debe ser mayor que 0.</param>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la disminución de la expresión en 1.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a disminuir.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión disminuida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la disminución de la expresión en 1.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a disminuir.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión disminuida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Default(System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DefaultExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> está establecida en el tipo especificado.</summary>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DefaultExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> y cuya propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> se establece en el tipo especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de división aritmética.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador de división definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de división aritmética. Se puede especificar el método de implementación.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es <see langword="null" /> y el operador de división no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de división que no tiene comprobación de desbordamiento.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de división que no tiene comprobación de desbordamiento.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de división que no tiene comprobación de desbordamiento.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType">Tipo de resultado de la expresión dinámica.</param>
      <param name="arguments">Argumentos de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType">Tipo de resultado de la expresión dinámica.</param>
      <param name="arg0">Primer argumento de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType">Tipo de resultado de la expresión dinámica.</param>
      <param name="arg0">Primer argumento de la operación dinámica.</param>
      <param name="arg1">Segundo argumento de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType">Tipo de resultado de la expresión dinámica.</param>
      <param name="arg0">Primer argumento de la operación dinámica.</param>
      <param name="arg1">Segundo argumento de la operación dinámica.</param>
      <param name="arg2">Tercer argumento de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType">Tipo de resultado de la expresión dinámica.</param>
      <param name="arg0">Primer argumento de la operación dinámica.</param>
      <param name="arg1">Segundo argumento de la operación dinámica.</param>
      <param name="arg2">Tercer argumento de la operación dinámica.</param>
      <param name="arg3">Cuarto argumento de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType">Tipo de resultado de la expresión dinámica.</param>
      <param name="arguments">Argumentos de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ElementInit" />, dado un objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> como segundo argumento.</summary>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />.</param>
      <param name="arguments">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene objetos <see cref="T:System.Linq.Expressions.Expression" /> en los que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> o <paramref name="arguments" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">El método que <paramref name="addMethod" /> representa no se denomina "Add" (no distingue mayúsculas de minúsculas).  
  
o bien 
El método que <paramref name="addMethod" /> representa no es un método de instancia.  
  
o bien 
 <paramref name="arguments" /> no contiene el mismo número de elementos que el número de parámetros del método que <paramref name="addMethod" /> representa.  
  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de uno o varios elementos de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del método que <paramref name="addMethod" /> representa.</exception>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ElementInit" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> y <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> establecidas en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ElementInit" />, dada una matriz de valores como segundo argumento.</summary>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> en los que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> o <paramref name="arguments" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">El método que addMethod representa no se denomina "Add" (sin distinción entre mayúsculas y minúsculas).  
  
o bien 
El método que addMethod representa no es un método de instancia.  
  
o bien 
El parámetro arguments no contiene el mismo número de elementos que el número de parámetros del método que addMethod representa.  
  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de uno o varios elementos de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del método que <paramref name="addMethod" /> representa.</exception>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ElementInit" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> y <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> establecidas en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Empty">
      <summary>Crea una expresión vacía que tiene el tipo <see cref="T:System.Void" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.DefaultExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> y cuya propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> está establecida en <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de igualdad.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador de igualdad definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de igualdad. Se puede especificar el método de implementación.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es <see langword="true" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="true" />; es <see langword="false" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="false" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es <see langword="null" /> y no hay ningún operador de igualdad definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="XOR" /> bit a bit, usando <c>op_ExclusiveOr</c> para los tipos definidos por el usuario.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador <see langword="XOR" /> definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="XOR" /> bit a bit, usando <c>op_ExclusiveOr</c> para los tipos definidos por el usuario. Se puede especificar el método de implementación.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es <see langword="null" /> y el operador <see langword="XOR" /> no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit, usando <c>op_ExclusiveOr</c> para los tipos definidos por el usuario.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit, usando <c>op_ExclusiveOr</c> para los tipos definidos por el usuario.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit, usando <c>op_ExclusiveOr</c> para los tipos definidos por el usuario.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />. En modo <see langword="static" /> (<see langword="Shared" /> en Visual Basic), <paramref name="expression" /> debe ser <see langword="null" />.</param>
      <param name="field">Objeto <see cref="T:System.Reflection.FieldInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="field" /> es <see langword="null" />.  
  
o bien 
El campo representado por <paramref name="field" /> no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) y <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type no se puede asignar al tipo declarativo del campo representado por <paramref name="field" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> y <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo, dado el nombre del campo.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> cuyo <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene un campo llamado <paramref name="fieldName" />. Este puede ser null para los campos estáticos.</param>
      <param name="fieldName">Nombre de un campo al que se va a obtener acceso.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="fieldName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">No se ha definido ningún campo denominado <paramref name="fieldName" /> en <paramref name="expression" />.Type o sus tipos base.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en el objeto <see cref="T:System.Reflection.FieldInfo" /> que representa el campo denotado por <paramref name="fieldName" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo.</summary>
      <param name="expression">Objeto contenedor del campo. Este puede ser null para los campos estáticos.</param>
      <param name="type">Propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> que contiene el campo.</param>
      <param name="fieldName">Campo al que se va a obtener acceso.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])">
      <summary>Crea un <see cref="T:System.Type" /> objeto que representa un tipo de delegado <c>System. Action</c> genérico que tiene argumentos de tipo específicos.</summary>
      <param name="typeArgs">Matriz de hasta dieciséis objetos <see cref="T:System.Type" /> que especifican los argumentos de tipo para el tipo de delegado <see langword="System.Action" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contiene más de dieciséis elementos.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArgs" /> es <see langword="null" />.</exception>
      <returns>Tipo de un delegado <c>System.Action</c> que tiene los argumentos de tipo especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])">
      <summary>Obtiene un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado <c>System.Func</c> o <c>System.Action</c> genérico que tiene argumentos de tipo específicos.</summary>
      <param name="typeArgs">Argumentos de tipo del delegado.</param>
      <returns>Tipo de delegado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])">
      <summary>Crea un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado <c>System.Func</c> genérico que tiene argumentos de tipo específicos. El último argumento de tipo especifica el tipo de valor devuelto del delegado creado.</summary>
      <param name="typeArgs">Matriz de entre uno y diecisiete objetos <see cref="T:System.Type" /> que especifican los argumentos de tipo para el tipo de delegado <see langword="System.Func" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contiene menos de un elemento o más de diecisiete elementos.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArgs" /> es <see langword="null" />.</exception>
      <returns>Tipo de un delegado <c>System.Func</c> que tiene los argumentos de tipo especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción GoTo.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en el valor especificado y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción GoTo. Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción "go to" con el tipo especificado. Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un <paramref name="value" /> que se va a pasar a la etiqueta de destino cuando se produzca el salto.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción "go to" con el tipo especificado.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en el valor especificado, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un valor null que se va a pasar a la etiqueta de destino cuando se produzca el salto.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor que".</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador "mayor que" definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor que". Se puede especificar el método de implementación.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es <see langword="true" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="true" />; es <see langword="false" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="false" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es <see langword="null" /> y no hay ningún operador "mayor que" definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor o igual que".</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador "mayor o igual que" definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor o igual que".</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es <see langword="true" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="true" />; es <see langword="false" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="false" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es <see langword="null" /> y el operador "mayor o igual que" no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa un bloque condicional con una instrucción <see langword="if" />.</summary>
      <param name="test">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> se establecen en los valores especificados. La propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> se establece en la expresión predeterminada y el tipo del objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> resultante devuelto por este método es <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa un bloque condicional con instrucciones <see langword="if" /> y <see langword="else" />.</summary>
      <param name="test">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> se establecen en los valores especificados. El tipo del objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> resultante devuelto por este método es <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el aumento del valor de la expresión en 1.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que se va a incrementar.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión incrementada.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el incremento de la expresión en 1.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que se va a incrementar.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión incrementada.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica un delegado o una expresión lambda a una lista de expresiones de argumento.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el delegado o expresión lambda a los que se aplicará.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos a los que se aplican el delegado o expresión lambda.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type no representa un tipo de delegado o <see cref="T:System.Linq.Expressions.Expression`1" />.  
  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del delegado representado por <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> no contiene el mismo número de elementos que la lista de parámetros para el delegado representado por <paramref name="expression" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica el delegado o expresión lambda especificados a los argumentos proporcionados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica un delegado o una expresión lambda a una lista de expresiones de argumento.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el delegado o la expresión lambda que se va a aplicar.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos a los que se aplica el delegado o la expresión lambda.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type no representa un tipo de delegado o <see cref="T:System.Linq.Expressions.Expression`1" />.  
  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del delegado representado por <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> no contiene el mismo número de elementos que la lista de parámetros para el delegado representado por <paramref name="expression" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica el delegado o expresión lambda especificados a los argumentos proporcionados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)">
      <summary>Devuelve si la expresión se evalúa en false.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Devuelve si la expresión se evalúa en false.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)">
      <summary>Devuelve si la expresión se evalúa en true.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Devuelve si la expresión se evalúa en true.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con tipo void y sin nombre.</summary>
      <returns>Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelExpression" /> que representa una etiqueta sin un valor predeterminado.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> con el que se asociará este objeto <see cref="T:System.Linq.Expressions.LabelExpression" />.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LabelExpression" /> sin un valor predeterminado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelExpression" /> que representa una etiqueta con el valor predeterminado especificado.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> con el que se asociará este objeto <see cref="T:System.Linq.Expressions.LabelExpression" />.</param>
      <param name="defaultValue">Valor de este objeto <see cref="T:System.Linq.Expressions.LabelExpression" /> cuando se alcanza la etiqueta mediante el flujo de control regular.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelExpression" /> con el valor predeterminado dado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con un tipo void y con el nombre dado.</summary>
      <param name="name">Nombre de la etiqueta.</param>
      <returns>Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con el tipo dado.</summary>
      <param name="type">Tipo de valor que se pasa cuando se produce el salto a la etiqueta.</param>
      <returns>Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con el tipo y el nombre dados.</summary>
      <param name="type">Tipo de valor que se pasa cuando se produce el salto a la etiqueta.</param>
      <param name="name">Nombre de la etiqueta.</param>
      <returns>Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado a partir del cuerpo de la expresión, un parámetro que indica si se aplicará la optimización de la llamada de cola y una colección enumerable de expresiones de parámetros. Se puede usar cuando no se conoce el tipo de delegado en tiempo de compilación.</summary>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado a partir del cuerpo de la expresión, un parámetro que indica si se aplicará la optimización de la llamada de cola y una matriz de expresiones de parámetros. Se puede usar cuando no se conoce el tipo de delegado en tiempo de compilación.</summary>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">Matriz que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado a partir del cuerpo de la expresión y una colección enumerable de expresiones de parámetros. Se puede usar cuando no se conoce el tipo de delegado en tiempo de compilación.</summary>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado a partir del cuerpo de la expresión y una matriz de expresiones de parámetros. Se puede usar cuando no se conoce el tipo de delegado en tiempo de compilación.</summary>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> es <see langword="null" />.  
  
o bien 
Uno o más elementos de <paramref name="parameters" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="parameters" /> contiene más de dieciséis elementos.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado a partir del cuerpo de la expresión, el nombre de la expresión lambda, un parámetro que indica si se aplicará la optimización de la llamada de cola y una colección enumerable de expresiones de parámetros. Se puede usar cuando no se conoce el tipo de delegado en tiempo de compilación.</summary>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nombre de la expresión lambda. Se usa para emitir información de depuración.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado a partir del cuerpo de la expresión, el nombre de la expresión lambda y una colección enumerable de expresiones de parámetros. Se puede usar cuando no se conoce el tipo de delegado en tiempo de compilación.</summary>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nombre de la expresión lambda. Se usa para emitir información de depuración.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.LambdaExpression" /> en la que el tipo de delegado se conoce en el momento de la compilación, con un parámetro que indica si se aplicará la optimización de la llamada de cola y una colección enumerable de expresiones de parámetros.</summary>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.LambdaExpression" /> en la que el tipo de delegado se conoce en el momento de la compilación, con un parámetro que indica si se aplicará la optimización de la llamada de cola y una matriz de expresiones de parámetros.</summary>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">Matriz que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.LambdaExpression" /> en la que el tipo de delegado se conoce en el momento de la compilación, con una colección enumerable de expresiones de parámetros.</summary>
      <param name="delegateType">Objeto <see cref="T:System.Type" /> que representa una signatura de delegado para la expresión lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="delegateType" /> o <paramref name="body" /> es <see langword="null" />.  
  
o bien 
Uno o más elementos de <paramref name="parameters" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> no representa un tipo de delegado.  
  
o bien 
 <paramref name="body" />.Type representa un tipo que no se puede asignar al tipo de valor devuelto del tipo de delegado representado por <paramref name="delegateType" />.  
  
o bien 
 <paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para el tipo de delegado representado por <paramref name="delegateType" />.  
  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="parameters" /> no se puede asignar desde el tipo del correspondiente tipo de parámetro del tipo de delegado representado por <paramref name="delegateType" />.</exception>
      <returns>Objeto que representa una expresión lambda cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.LambdaExpression" /> en la que el tipo de delegado se conoce en el momento de la compilación, con una colección enumerable de expresiones de parámetros.</summary>
      <param name="delegateType">Objeto <see cref="T:System.Type" /> que representa una signatura de delegado para la expresión lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="delegateType" /> o <paramref name="body" /> es <see langword="null" />.  
  
o bien 
Uno o más elementos de <paramref name="parameters" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> no representa un tipo de delegado.  
  
o bien 
 <paramref name="body" />.Type representa un tipo que no se puede asignar al tipo de valor devuelto del tipo de delegado representado por <paramref name="delegateType" />.  
  
o bien 
 <paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para el tipo de delegado representado por <paramref name="delegateType" />.  
  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="parameters" /> no se puede asignar desde el tipo del correspondiente tipo de parámetro del tipo de delegado representado por <paramref name="delegateType" />.</exception>
      <returns>Objeto que representa una expresión lambda cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.LambdaExpression" /> en la que el tipo de delegado se conoce en el momento de la compilación, con el nombre de la expresión lambda, un parámetro que indica si se aplicará la optimización de la llamada de cola y una colección enumerable de expresiones de parámetros.</summary>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nombre de la expresión lambda. Se usa para emitir información de depuración.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.LambdaExpression" /> en la que el tipo de delegado se conoce en el momento de la compilación, con el nombre de la expresión lambda y una colección enumerable de expresiones de parámetros.</summary>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nombre de la expresión lambda. Se usa para emitir información de depuración.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.Expression`1" /> en la que el tipo de delegado se conoce en el momento de la compilación, con un parámetro que indica si se aplicará la optimización de la llamada de cola y una colección enumerable de expresiones de parámetros.</summary>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado.</typeparam>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.Expression`1" /> en la que el tipo de delegado se conoce en el momento de la compilación, con un parámetro que indica si se aplicará la optimización de la llamada de cola y una matriz de expresiones de parámetros.</summary>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">Matriz que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado.</typeparam>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.Expression`1" /> en la que el tipo de delegado se conoce en el momento de la compilación, con una colección enumerable de expresiones de parámetros.</summary>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> es <see langword="null" />.  
  
o bien 
Uno o más elementos de <paramref name="parameters" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> no es un tipo de delegado.  
  
o bien 
 <paramref name="body" />.Type representa un tipo que no se puede asignar al tipo de valor devuelto de <paramref name="TDelegate" />.  
  
o bien 
 <paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para <paramref name="TDelegate" />.  
  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="parameters" /> no se puede asignar desde el tipo del correspondiente tipo de parámetro de <paramref name="TDelegate" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.Expression`1" /> en la que el tipo de delegado se conoce en el momento de la compilación, con una matriz de expresiones de parámetros.</summary>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> es <see langword="null" />.  
  
o bien 
Uno o más elementos de <paramref name="parameters" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> no es un tipo de delegado.  
  
o bien 
 <paramref name="body" />.Type representa un tipo que no se puede asignar al tipo de valor devuelto de <paramref name="TDelegate" />.  
  
o bien 
 <paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para <paramref name="TDelegate" />.  
  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="parameters" /> no se puede asignar desde el tipo del correspondiente tipo de parámetro de <paramref name="TDelegate" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.Expression`1" /> en la que el tipo de delegado se conoce en el momento de la compilación, con el nombre de la expresión lambda, un parámetro que indica si se aplicará la optimización de la llamada de cola y una colección enumerable de expresiones de parámetros.</summary>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nombre de la expresión lambda. Se usa para emitir información de depuración.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado.</typeparam>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.Expression`1" /> en la que el tipo de delegado se conoce en el momento de la compilación, con el nombre de la expresión lambda y una colección enumerable de expresiones de parámetros.</summary>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nombre de la expresión lambda. Se usa para emitir información de depuración.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado.</typeparam>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación bit a bit de desplazamiento a la izquierda.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador de desplazamiento a la izquierda definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación bit a bit de desplazamiento a la izquierda.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es <see langword="null" /> y no hay ningún operador de desplazamiento a la izquierda definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación y desplazamiento a la izquierda bit a bit.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación y desplazamiento a la izquierda bit a bit.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación y desplazamiento a la izquierda bit a bit.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor que".</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador "menor que" definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor que".</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es <see langword="true" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="true" />; es <see langword="false" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="false" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es <see langword="null" /> y el operador "menor que" no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor o igual que".</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador "menor o igual que" definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor o igual que".</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es <see langword="true" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="true" />; es <see langword="false" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="false" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es <see langword="null" /> y no hay ningún operador "menor o igual que" definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> donde el miembro es un campo o una propiedad.</summary>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> que representa un campo o una propiedad en la que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> es <see langword="null" />.  
  
o bien 
Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa ningún campo ni ninguna propiedad.  
  
o bien 
El objeto <see cref="P:System.Reflection.FieldInfo.FieldType" /> o <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> del campo o de la propiedad que <paramref name="member" /> representa no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> donde el miembro es un campo o una propiedad.</summary>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> que representa un campo o una propiedad en la que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> es <see langword="null" />.  
  
o bien 
Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa ningún campo ni ninguna propiedad.  
  
o bien 
El objeto <see cref="P:System.Reflection.FieldInfo.FieldType" /> o <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> del campo o de la propiedad que <paramref name="member" /> representa no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> basándose en el método de descriptor de acceso de propiedad especificado.</summary>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> es <see langword="null" />.  
  
o bien 
Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa ningún método de descriptor de acceso de propiedad.  
  
o bien 
El objeto <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propiedad a la que obtiene acceso el método representado por <paramref name="propertyAccessor" /> no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.MemberInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />, y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se rellena con los elementos de <paramref name="initializers" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> basándose en el método de descriptor de acceso de propiedad especificado.</summary>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> es <see langword="null" />.  
  
o bien 
Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa ningún método de descriptor de acceso de propiedad.  
  
o bien 
El objeto <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propiedad a la que obtiene acceso el método representado por <paramref name="propertyAccessor" /> no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.MemberInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />, y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se rellena con los elementos de <paramref name="initializers" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> especificados para inicializar una colección.</summary>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> es <see langword="null" />.  
  
o bien 
Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa un método llamado "Add" para agregar elementos a una colección.</summary>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> es <see langword="null" />.  
  
o bien 
Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún método de instancia denominado "Add" (no distingue mayúsculas de minúsculas) declarado en <paramref name="newExpression" />.Type o su tipo base.  
  
o bien 
El método de adición en <paramref name="newExpression" />.Type o su tipo base no toma exactamente un argumento.  
  
o bien 
El tipo representado por la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> del primer elemento de <paramref name="initializers" /> no es asignable al tipo de argumento del método de adición en <paramref name="newExpression" />.Type o su tipo base.  
  
o bien 
Existe más de un método compatible con los argumentos denominado "Add" (no distingue mayúsculas y minúsculas) en <paramref name="newExpression" />.Type o su tipo base.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> especificados para inicializar una colección.</summary>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> es <see langword="null" />.  
  
o bien 
Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa un método llamado "Add" para agregar elementos a una colección.</summary>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> es <see langword="null" />.  
  
o bien 
Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún método de instancia denominado "Add" (no distingue mayúsculas de minúsculas) declarado en <paramref name="newExpression" />.Type o su tipo base.  
  
o bien 
El método de adición en <paramref name="newExpression" />.Type o su tipo base no toma exactamente un argumento.  
  
o bien 
El tipo representado por la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> del primer elemento de <paramref name="initializers" /> no es asignable al tipo de argumento del método de adición en <paramref name="newExpression" />.Type o su tipo base.  
  
o bien 
Existe más de un método compatible con los argumentos denominado "Add" (no distingue mayúsculas y minúsculas) en <paramref name="newExpression" />.Type o su tipo base.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa el método especificado para agregar elementos a una colección.</summary>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de instancia llamado "Add" (no distingue entre mayúsculas y minúsculas) que agrega un elemento a una colección.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> es <see langword="null" />.  
  
o bien 
Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type no implementa <see cref="T:System.Collections.IEnumerable" />.  
  
o bien 
 <paramref name="addMethod" /> no es <see langword="null" /> y no representa ningún método de instancia denominado "Add" (sin distinción entre mayúsculas y minúsculas) que tome exactamente un argumento.  
  
o bien 
 <paramref name="addMethod" /> no es <see langword="null" /> y el tipo representado por la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de uno o varios elementos de <paramref name="initializers" /> no se puede asignar al tipo de argumento del método que <paramref name="addMethod" /> representa.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> es <see langword="null" /> y, en <paramref name="newExpression" />.Type o su tipo base, no hay ningún método de instancia denominado "Add" que tome un argumento compatible con el tipo.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa el método especificado para agregar elementos a una colección.</summary>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de instancia que toma un argumento que agrega un elemento a una colección.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> es <see langword="null" />.  
  
o bien 
Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type no implementa <see cref="T:System.Collections.IEnumerable" />.  
  
o bien 
 <paramref name="addMethod" /> no es <see langword="null" /> y no representa ningún método de instancia denominado "Add" (sin distinción entre mayúsculas y minúsculas) que tome exactamente un argumento.  
  
o bien 
 <paramref name="addMethod" /> no es <see langword="null" /> y el tipo representado por la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de uno o varios elementos de <paramref name="initializers" /> no se puede asignar al tipo de argumento del método que <paramref name="addMethod" /> representa.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> es <see langword="null" /> y, en <paramref name="newExpression" />.Type o su tipo base, no hay ningún método de instancia denominado "Add" que tome un argumento compatible con el tipo.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> con el cuerpo especificado.</summary>
      <param name="body">Cuerpo del bucle.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> con el cuerpo especificado y el destino de Break.</summary>
      <param name="body">Cuerpo del bucle.</param>
      <param name="break">Destino Break empleado por el cuerpo del bucle.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> con el cuerpo especificado.</summary>
      <param name="body">Cuerpo del bucle.</param>
      <param name="break">Destino Break empleado por el cuerpo del bucle.</param>
      <param name="continue">Destino Continue empleado por el cuerpo del bucle.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" />, dados los operandos izquierdo y derecho, llamando al método de generador adecuado.</summary>
      <param name="binaryType">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de la operación binaria.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> no corresponde a ningún nodo de expresión binaria.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de llamar al método de generador adecuado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" />, dados el operando izquierdo, el operando derecho y el método de implementación, llamando al método de generador adecuado.</summary>
      <param name="binaryType">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de la operación binaria.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho.</param>
      <param name="liftToNull">Es <see langword="true" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="true" />; es <see langword="false" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="false" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que especifica el método de implementación.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> no corresponde a ningún nodo de expresión binaria.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de llamar al método de generador adecuado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" />, dados el operando izquierdo, el operando derecho, el método de implementación y la función de conversión de tipos, llamando al método del generador apropiado.</summary>
      <param name="binaryType">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de la operación binaria.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho.</param>
      <param name="liftToNull">Es <see langword="true" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="true" />; es <see langword="false" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="false" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que especifica el método de implementación.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> que representa una función de conversión de tipos. Este parámetro solo se usa si <paramref name="binaryType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> o una asignación compuesta.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> no corresponde a ningún nodo de expresión binaria.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de llamar al método de generador adecuado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con los elementos especificados.</summary>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que este <see cref="T:System.Linq.Expressions.CatchBlock" /> controlará.</param>
      <param name="variable">Objeto <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> detectado por este controlador.</param>
      <param name="body">Cuerpo de la instrucción Catch.</param>
      <param name="filter">Cuerpo del filtro <see cref="T:System.Exception" />.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="delegateType">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arguments">Argumentos de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado y un argumento.</summary>
      <param name="delegateType">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arg0">Argumento de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado y dos argumentos.</summary>
      <param name="delegateType">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arg0">Primer argumento de la operación dinámica.</param>
      <param name="arg1">Segundo argumento de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado y tres argumentos.</summary>
      <param name="delegateType">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arg0">Primer argumento de la operación dinámica.</param>
      <param name="arg1">Segundo argumento de la operación dinámica.</param>
      <param name="arg2">Tercer argumento de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado y cuatro argumentos.</summary>
      <param name="delegateType">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arg0">Primer argumento de la operación dinámica.</param>
      <param name="arg1">Segundo argumento de la operación dinámica.</param>
      <param name="arg2">Tercer argumento de la operación dinámica.</param>
      <param name="arg3">Cuarto argumento de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <param name="delegateType">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arguments">Argumentos de la operación dinámica.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa un salto del objeto <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> especificado. Además se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <param name="kind">
        <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> del objeto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a <paramref name="kind" />, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indizada en un objeto.</summary>
      <param name="instance">Objeto al que pertenece la propiedad. Si la propiedad es <see langword="static" /> (<see langword="shared" /> en Visual Basic), debe ser null.</param>
      <param name="indexer">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la propiedad que se va a indexar.</param>
      <param name="arguments">
        <c>IEnumerable&lt;Expression&gt;</c> (<c>IEnumerable (Of Expression)</c> en Visual Basic) que contiene los argumentos que se van a emplear para indizar la propiedad.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo o a una propiedad.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto al que pertenece el miembro. Puede ser null para los miembros estáticos.</param>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> que describe el campo o la propiedad a los que se va a tener acceso.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa ningún campo ni ninguna propiedad.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> que resulta de llamar al método de generador adecuado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con los elementos especificados.</summary>
      <param name="type">Tipo de resultado de la expresión try. Si es null, el cuerpo y todos los controladores deben tener un tipo idéntico.</param>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="finally">Cuerpo del bloque finally. Pasa null si el bloque try no tiene ningún bloque finally asociado.</param>
      <param name="fault">Cuerpo del bloque fault. Pasa null si el bloque try no tiene ningún bloque fault asociado.</param>
      <param name="handlers">Colección de objetos <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa las instrucciones Catch que se van a asociar al bloque try.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" />, dado un operando, llamando al método del generador apropiado.</summary>
      <param name="unaryType">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de la operación unaria.</param>
      <param name="operand">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando.</param>
      <param name="type">
        <see cref="T:System.Type" /> que especifica el tipo al que se va a convertir (pase <see langword="null" /> si no es aplicable).</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> no corresponde a un nodo de expresión unaria.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que resulta de llamar al método de generador adecuado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" />, dados un operando y un método de implementación, llamando al método del generador apropiado.</summary>
      <param name="unaryType">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de la operación unaria.</param>
      <param name="operand">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando.</param>
      <param name="type">
        <see cref="T:System.Type" /> que especifica el tipo al que se va a convertir (pase <see langword="null" /> si no es aplicable).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> no corresponde a un nodo de expresión unaria.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que resulta de llamar al método de generador adecuado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un campo o una propiedad.</summary>
      <param name="member">Objeto <see cref="T:System.Reflection.MemberInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> o <paramref name="bindings" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa ningún campo ni ninguna propiedad.  
  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de un elemento de <paramref name="bindings" /> no representa ningún miembro del tipo del campo o de la propiedad que <paramref name="member" /> representa.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un campo o una propiedad.</summary>
      <param name="member">Objeto <see cref="T:System.Reflection.MemberInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="bindings">Matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> o <paramref name="bindings" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa ningún campo ni ninguna propiedad.  
  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de un elemento de <paramref name="bindings" /> no representa ningún miembro del tipo del campo o de la propiedad que <paramref name="member" /> representa.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un miembro al que se obtiene acceso mediante un método de descriptor de acceso de propiedad.</summary>
      <param name="propertyAccessor">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> o <paramref name="bindings" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa ningún método de descriptor de acceso de propiedad.  
  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de un elemento de <paramref name="bindings" /> no representa ningún miembro del tipo de la propiedad a la que obtiene acceso el método representado por <paramref name="propertyAccessor" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un miembro al que se obtiene acceso mediante un método de descriptor de acceso de propiedad.</summary>
      <param name="propertyAccessor">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="bindings">Matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> o <paramref name="bindings" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa ningún método de descriptor de acceso de propiedad.  
  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de un elemento de <paramref name="bindings" /> no representa ningún miembro del tipo de la propiedad a la que obtiene acceso el método representado por <paramref name="propertyAccessor" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Representa una expresión que crea un nuevo objeto e inicializa una propiedad del objeto.</summary>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="bindings" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de un elemento de <paramref name="bindings" /> no representa ningún miembro del tipo que <paramref name="newExpression" />.Type representa.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea una interfaz <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />.</param>
      <param name="bindings">Matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="bindings" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de un elemento de <paramref name="bindings" /> no representa ningún miembro del tipo que <paramref name="newExpression" />.Type representa.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de resto aritmética.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador de módulo definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de resto aritmética.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es <see langword="null" /> y el operador modulus no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación y resto.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación y resto.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación y resto.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética sin comprobación de desbordamiento.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador de multiplicación definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética sin comprobación de desbordamiento.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es <see langword="null" /> y no hay ningún operador de multiplicación definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que no tiene comprobación de desbordamiento.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que no tiene comprobación de desbordamiento.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que no tiene comprobación de desbordamiento.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que tiene comprobación de desbordamiento.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que tiene comprobación de desbordamiento.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que tiene comprobación de desbordamiento.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética con comprobación de desbordamiento.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador de multiplicación definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética con comprobación de desbordamiento.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es <see langword="null" /> y no hay ningún operador de multiplicación definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador unario menos definido para <paramref name="expression" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es <see langword="null" /> y no hay ningún operador unario menos definido para <paramref name="expression" />.Type.  
  
o bien 
 <paramref name="expression" />.Type (o su correspondiente tipo que no acepta valores null si se trata de un tipo de valor que acepta valores null) no puede asignarse al tipo de argumento del método representado por <paramref name="method" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética que tiene comprobación de desbordamiento.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador unario menos definido para <paramref name="expression" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética que tiene comprobación de desbordamiento. Se puede especificar el método de implementación.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es <see langword="null" /> y no hay ningún operador unario menos definido para <paramref name="expression" />.Type.  
  
o bien 
 <paramref name="expression" />.Type (o su correspondiente tipo que no acepta valores null si se trata de un tipo de valor que acepta valores null) no puede asignarse al tipo de argumento del método representado por <paramref name="method" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado que no toma ningún argumento.</summary>
      <param name="constructor">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">El constructor que <paramref name="constructor" /> representa tiene por lo menos un parámetro.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> se establece en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado con los argumentos especificados.</summary>
      <param name="constructor">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> es <see langword="null" />.  
  
o bien 
Un elemento de <paramref name="arguments" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">El parámetro <paramref name="arguments" /> no contiene el mismo número de elementos que el número de parámetros del constructor representado por <paramref name="constructor" />.  
  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del constructor que representa <paramref name="constructor" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> y <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado con los argumentos especificados. Se especifican los miembros que obtienen acceso a los campos inicializados por el constructor.</summary>
      <param name="constructor">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Reflection.MemberInfo" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> es <see langword="null" />.  
  
o bien 
Un elemento de <paramref name="arguments" /> es <see langword="null" />.  
  
o bien 
Un elemento de <paramref name="members" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">El parámetro <paramref name="arguments" /> no contiene el mismo número de elementos que el número de parámetros del constructor representado por <paramref name="constructor" />.  
  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del constructor que representa <paramref name="constructor" />.  
  
o bien 
El parámetro <paramref name="members" /> no contiene el mismo número de elementos que <paramref name="arguments" />.  
  
o bien 
Un elemento de <paramref name="arguments" /> tiene una propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo que no se puede asignar al tipo del miembro representado por el elemento correspondiente de <paramref name="members" />.</exception>
      <returns>Objeto <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> y <see cref="P:System.Linq.Expressions.NewExpression.Members" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado con los argumentos especificados. Los miembros que obtienen acceso a los campos inicializados por el constructor se especifican como una matriz.</summary>
      <param name="constructor">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">Matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> es <see langword="null" />.  
  
o bien 
Un elemento de <paramref name="arguments" /> es <see langword="null" />.  
  
o bien 
Un elemento de <paramref name="members" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">El parámetro <paramref name="arguments" /> no contiene el mismo número de elementos que el número de parámetros del constructor representado por <paramref name="constructor" />.  
  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del constructor que representa <paramref name="constructor" />.  
  
o bien 
El parámetro <paramref name="members" /> no contiene el mismo número de elementos que <paramref name="arguments" />.  
  
o bien 
Un elemento de <paramref name="arguments" /> tiene una propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo que no se puede asignar al tipo del miembro representado por el elemento correspondiente de <paramref name="members" />.</exception>
      <returns>Objeto <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> y <see cref="P:System.Linq.Expressions.NewExpression.Members" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado con los argumentos especificados.</summary>
      <param name="constructor">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> es <see langword="null" />.  
  
o bien 
Un elemento de <paramref name="arguments" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La longitud de <paramref name="arguments" /> coincide con el número de parámetros del constructor que <paramref name="constructor" /> representa.  
  
o bien 
La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del constructor que representa <paramref name="constructor" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> y <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor sin parámetros del tipo especificado.</summary>
      <param name="type">
        <see cref="T:System.Type" /> que tiene un constructor que no toma ningún argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">El tipo que <paramref name="type" /> representa no tiene un constructor sin parámetros.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> se establece en el objeto <see cref="T:System.Reflection.ConstructorInfo" /> que representa el constructor sin parámetros del tipo especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz que tiene el rango especificado.</summary>
      <param name="type">
        <see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</param>
      <param name="bounds">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="bounds" /> es <see langword="null" />.  
  
o bien 
Un elemento de <paramref name="bounds" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="bounds" /> no representa un tipo entero.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> se establece en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz que tiene el rango especificado.</summary>
      <param name="type">
        <see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</param>
      <param name="bounds">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="bounds" /> es <see langword="null" />.  
  
o bien 
Un elemento de <paramref name="bounds" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="bounds" /> no representa un tipo entero.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> se establece en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz unidimensional y su inicialización a partir de una lista de elementos.</summary>
      <param name="type">
        <see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="initializers" /> es <see langword="null" />.  
  
o bien 
Un elemento de <paramref name="initializers" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="initializers" /> representa un tipo que no puede asignarse al tipo representado por <paramref name="type" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> se establece en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz unidimensional y su inicialización a partir de una lista de elementos.</summary>
      <param name="type">
        <see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="initializers" /> es <see langword="null" />.  
  
o bien 
Un elemento de <paramref name="initializers" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="initializers" /> representa un tipo que no puede asignarse al tipo <paramref name="type" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> se establece en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de complemento bit a bit.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador unario Not definido para <paramref name="expression" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de complemento bit a bit. Se puede especificar el método de implementación.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es <see langword="null" /> y no hay ningún operador unario Not definido para <paramref name="expression" />.Type.  
  
o bien 
 <paramref name="expression" />.Type (o su correspondiente tipo que no acepta valores null si se trata de un tipo de valor que acepta valores null) no puede asignarse al tipo de argumento del método representado por <paramref name="method" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de desigualdad.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador de desigualdad definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de desigualdad.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es <see langword="true" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="true" />; es <see langword="false" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="false" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es <see langword="null" /> y no hay ningún operador de desigualdad definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)">
      <summary>Devuelve la expresión que representa el complemento a unos.</summary>
      <param name="expression">Una clase <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Devuelve la expresión que representa el complemento a unos.</summary>
      <param name="expression">Una clase <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="OR" /> bit a bit.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador <see langword="OR" /> bit a bit definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="OR" /> bit a bit.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es <see langword="null" /> y el operador <see langword="OR" /> bit a bit no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación OR bit a bit.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación OR bit a bit.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación OR bit a bit.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="OR" /> condicional que evalúa el segundo operando únicamente si el primer operando se evalúa como <see langword="false" />.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador <see langword="OR" /> bit a bit definido para <paramref name="left" />.Type y <paramref name="right" />.Type.  
  
o bien 
 <paramref name="left" />.Type y <paramref name="right" />.Type no son del mismo tipo booleano.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="OR" /> condicional que evalúa el segundo operando únicamente si el primer operando se evalúa como <see langword="false" />.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es <see langword="null" /> y el operador <see langword="OR" /> bit a bit no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.  
  
o bien 
 <paramref name="method" /> es <see langword="null" /> y <paramref name="left" />.Type y <paramref name="right" />.Type no son del mismo tipo booleano.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que puede usarse para identificar un parámetro o una variable en un árbol de expresión.</summary>
      <param name="type">Tipo del parámetro o variable.</param>
      <returns>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con el nombre y el tipo especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que puede usarse para identificar un parámetro o una variable en un árbol de expresión.</summary>
      <param name="type">Tipo del parámetro o variable.</param>
      <param name="name">Nombre del parámetro o variable; se emplea solo para depurar o imprimir.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> es <see langword="null" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.Expression.Type" /> y <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de una disminución subsiguiente de 1 de la expresión original.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de una disminución subsiguiente de 1 de la expresión original.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de un incremento subsiguiente de 1 de la expresión original.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de un incremento subsiguiente de 1 de la expresión original.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de un número a una potencia.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador de exponenciación definido para <paramref name="left" />.Type y <paramref name="right" />.Type.  
  
o bien 
 <paramref name="left" />.Type y/o <paramref name="right" />.Type no son <see cref="T:System.Double" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de un número a una potencia.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es <see langword="null" /> y no hay ningún operador de exponenciación definido para <paramref name="left" />.Type y <paramref name="right" />.Type.  
  
o bien 
 <paramref name="method" /> es <see langword="null" /> y <paramref name="left" />.Type o <paramref name="right" />.Type no son <see cref="T:System.Double" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de una expresión a una potencia y la asignación del resultado a dicha expresión.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de una expresión a una potencia y la asignación del resultado a dicha expresión.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de una expresión a una potencia y la asignación del resultado a dicha expresión.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que disminuye la expresión en 1 y asigna el resultado a la expresión.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que disminuye la expresión en 1 y asigna el resultado a la expresión.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que aumenta la expresión en 1 y asigna el resultado a la expresión.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que aumenta la expresión en 1 y asigna el resultado a la expresión.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad mediante un método de descriptor de acceso de propiedad.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />. Puede ser null para las propiedades estáticas.</param>
      <param name="propertyAccessor">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> es <see langword="null" />.  
  
o bien 
El método que <paramref name="propertyAccessor" /> representa no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) y el valor de <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type no se puede asignar al tipo declarativo del método representado por <paramref name="propertyAccessor" />.  
  
o bien 
El método que <paramref name="propertyAccessor" /> representa no es un método de descriptor de acceso de propiedad.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />. Puede ser null para las propiedades estáticas.</param>
      <param name="property">Objeto <see cref="T:System.Reflection.PropertyInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="property" /> es <see langword="null" />.  
  
o bien 
La propiedad que <paramref name="property" /> representa no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) y el valor de <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type no se puede asignar al tipo declarativo de la propiedad que <paramref name="property" /> representa.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> y <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indizada.</summary>
      <param name="instance">Objeto al que pertenece la propiedad. Si la propiedad es estática o compartida, deberá ser null.</param>
      <param name="indexer">
        <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad que se va a indexar.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se usan para indexar la propiedad.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indizada.</summary>
      <param name="instance">Objeto al que pertenece la propiedad. Si la propiedad es estática o compartida, deberá ser null.</param>
      <param name="indexer">
        <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad que se va a indexar.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se emplean para indizar la propiedad.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene una propiedad denominada <paramref name="propertyName" />. Puede ser <see langword="null" /> para las propiedades estáticas.</param>
      <param name="propertyName">Nombre de una propiedad a la que se va a obtener acceso.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="propertyName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">No se ha definido ninguna propiedad denominada <paramref name="propertyName" /> en <paramref name="expression" />.Type o sus tipos base.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad denotada por <paramref name="propertyName" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indizada.</summary>
      <param name="instance">Objeto al que pertenece la propiedad. Si la propiedad es estática o compartida, deberá ser null.</param>
      <param name="propertyName">El nombre del indizador.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se emplean para indizar la propiedad.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que obtiene acceso a una propiedad.</summary>
      <param name="expression">Objeto contenedor de la propiedad. Puede ser null para las propiedades estáticas.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que contiene la propiedad.</param>
      <param name="propertyName">Propiedad a la que se va a obtener acceso.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad o un campo.</summary>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene una propiedad o un campo denominado <paramref name="propertyOrFieldName" />. Puede ser null para los miembros estáticos.</param>
      <param name="propertyOrFieldName">Nombre de una propiedad o un campo al que se va a obtener acceso.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="propertyOrFieldName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">No se ha definido ninguna propiedad o ningún campo denominado <paramref name="propertyOrFieldName" /> en <paramref name="expression" />.Type o sus tipos base.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> o <see cref="T:System.Reflection.FieldInfo" /> que representa la propiedad o el campo denotados por <paramref name="propertyOrFieldName" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una expresión que tiene un valor constante de tipo <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> es <see langword="null" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Reduce">
      <summary>Reduce este nodo a una expresión más simple. Si CanReduce devuelve true, debería devolver una expresión válida. Este método puede devolver otro nodo que se debe reducir a su vez.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceAndCheck">
      <summary>Reduce este nodo a una expresión más simple. Si CanReduce devuelve true, debería devolver una expresión válida. Este método puede devolver otro nodo que se debe reducir a su vez.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceExtensions">
      <summary>Reduce la expresión a un tipo de nodo conocido (no es un nodo de extensión) o, si ya es un tipo conocido, solo devuelve la expresión.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de igualdad de referencia.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de desigualdad de referencia.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa un reinicio de una excepción.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa un reinicio de una excepción.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow(System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el reinicio de una excepción con un tipo dado.</summary>
      <param name="type">Nuevo objeto <see cref="T:System.Type" /> de la expresión.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa un reinicio de una excepción.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Return, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return. Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un <paramref name="value" /> que se va a pasar a la etiqueta de destino cuando se produzca el salto.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return con el tipo especificado. Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return con el tipo especificado.</summary>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Return, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de desplazamiento a la derecha bit a bit.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador de desplazamiento a la derecha definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de desplazamiento a la derecha bit a bit.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es <see langword="null" /> y no hay ningún operador de desplazamiento a la derecha definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la derecha bit a bit.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la derecha bit a bit.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la derecha bit a bit.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <param name="variables">Colección de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> y cuya propiedad <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> está establecida en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <param name="variables">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> y cuya propiedad <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> está establecida en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que no tiene comprobación de desbordamiento.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador de resta definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que no tiene comprobación de desbordamiento.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es <see langword="null" /> y el operador de resta no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que no tiene comprobación de desbordamiento.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que no tiene comprobación de desbordamiento.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que no tiene comprobación de desbordamiento.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que tiene comprobación de desbordamiento.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que tiene comprobación de desbordamiento.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que tiene comprobación de desbordamiento.</summary>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que tiene comprobación de desbordamiento.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador de resta definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que tiene comprobación de desbordamiento.</summary>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es <see langword="null" /> y el operador de resta no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción <see langword="switch" /> que tiene un caso predeterminado.</summary>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción <see langword="switch" /> que tiene un caso predeterminado.</summary>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción <see langword="switch" /> que tiene un caso predeterminado.</summary>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción <see langword="switch" /> sin un caso predeterminado.</summary>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción <see langword="switch" /> que tiene un caso predeterminado.</summary>
      <param name="type">Tipo de resultado del modificador.</param>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción <see langword="switch" /> que tiene un caso predeterminado.</summary>
      <param name="type">Tipo de resultado del modificador.</param>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> que se va a usar en un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <param name="body">Cuerpo del caso.</param>
      <param name="testValues">Valores de prueba del caso.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> que se va a usar en un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <param name="body">Cuerpo del caso.</param>
      <param name="testValues">Valores de prueba del caso.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName">
        <see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tiene la propiedad <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> establecida en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName">
        <see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> cuyas propiedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> y <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> están establecidas en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName">
        <see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <param name="languageVendor">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> y <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> establecidas en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName">
        <see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <param name="languageVendor">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</param>
      <param name="documentType">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> cuyas propiedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> y <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> están establecidas en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa un inicio de una excepción.</summary>
      <param name="value">Una clase <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la excepción.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa un inicio de una excepción con un tipo especificado.</summary>
      <param name="value">Una clase <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">Nuevo objeto <see cref="T:System.Type" /> de la expresión.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la excepción.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ToString">
      <summary>Devuelve una representación textual de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Representación textual de <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con cualquier número de instrucciones Catch y ningún bloque fault ni finally.</summary>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="handlers">Matriz de cero o más expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa las instrucciones Catch que se van a asociar al bloque try.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con cualquier número de instrucciones Catch y un bloque finally.</summary>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="finally">Cuerpo del bloque finally.</param>
      <param name="handlers">Matriz de cero o más expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa las instrucciones Catch que se van a asociar al bloque try.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con un bloque fault y ninguna instrucción Catch.</summary>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="fault">Cuerpo del bloque fault.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con un bloque finally y ninguna instrucción Catch.</summary>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="finally">Cuerpo del bloque finally.</param>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)">
      <summary>Crea un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado System.Action genérico con argumentos de tipo concretos.</summary>
      <param name="typeArgs">Matriz de objetos Type que especifica los argumentos de tipo para el tipo de delegado System.Action.</param>
      <param name="actionType">Cuando este método devuelve el resultado, contiene el tipo de delegado genérico System.Action con argumentos de tipo concretos. Contiene NULL si no hay ningún delegado System. Action genérico que coincida con <paramref name="typeArgs" /> . Este parámetro se pasa sin inicializar.</param>
      <returns>
        <see langword="true" />, si el tipo de delegado System.Action genérico se ha creado para un elemento <paramref name="typeArgs" /> específico; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)">
      <summary>Crea un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado System.Func genérico que tiene argumentos de tipo específicos. El último argumento de tipo especifica el tipo de valor devuelto del delegado creado.</summary>
      <param name="typeArgs">Matriz de objetos Type que especifica los argumentos de tipo para el tipo de delegado System.Func.</param>
      <param name="funcType">Cuando este método devuelve el resultado, contiene el tipo de delegado genérico System.Func con argumentos de tipo concretos. Contiene NULL si no hay ningún delegado System. Func genérico que coincida con <paramref name="typeArgs" /> . Este parámetro se pasa sin inicializar.</param>
      <returns>
        <see langword="true" />, si el tipo de delegado System.Func genérico se ha creado para un elemento <paramref name="typeArgs" /> específico; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una referencia explícita o conversión boxing donde se suministra <see langword="null" /> si se produce un error de conversión.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> es <see langword="null" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> que compara la identidad de tipo en tiempo de ejecución.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />.</param>
      <returns>
        <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> para la que la propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> y para la que las propiedades <see cref="T:System.Linq.Expressions.Expression" /> y <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> están establecidas en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea una interfaz <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> es <see langword="null" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> para la que la propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> y para la que las propiedades <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> y <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> están establecidas en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación unaria más.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador unario más definido para <paramref name="expression" />.Type.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación unaria más.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es <see langword="null" /> y no hay ningún operador unario más definido para <paramref name="expression" />.Type.  
  
o bien 
 <paramref name="expression" />.Type (o su correspondiente tipo que no acepta valores null si se trata de un tipo de valor que acepta valores null) no puede asignarse al tipo de argumento del método representado por <paramref name="method" />.</exception>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una conversión unboxing explícita.</summary>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> al que se va a aplicar la conversión unboxing.</param>
      <param name="type">Nuevo objeto <see cref="T:System.Type" /> de la expresión.</param>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que puede usarse para identificar un parámetro o una variable en un árbol de expresión.</summary>
      <param name="type">Tipo del parámetro o variable.</param>
      <returns>Nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con el nombre y tipo especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que puede usarse para identificar un parámetro o una variable en un árbol de expresión.</summary>
      <param name="type">Tipo del parámetro o variable.</param>
      <param name="name">Nombre del parámetro o la variable. Este nombre se emplea únicamente para depurar o imprimir.</param>
      <returns>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con el nombre y el tipo especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Reduce el nodo y, a continuación, llama al delegado del visitante en la expresión reducida. El método inicia una excepción si el nodo no es reducible.</summary>
      <param name="visitor">Instancia de <see cref="T:System.Func`2" />.</param>
      <returns>Expresión que se está visitando o una expresión que debería sustituirla en el árbol.</returns>
    </member>
    <member name="P:System.Linq.Expressions.Expression.CanReduce">
      <summary>Indica que el nodo se puede reducir a uno más simple. Si devuelve true, se puede llamar a Reduce() para generar el formulario reducido.</summary>
      <returns>
        <see langword="true" /> es si se puede reducir el nodo; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.Expression.NodeType">
      <summary>Obtiene el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Uno de los valores de <see cref="T:System.Linq.Expressions.ExpressionType" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.Expression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="T:System.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.Expression`1">
      <summary>Representa una expresión lambda fuertemente tipada como una estructura de datos con el formato de un árbol de expresión. Esta clase no puede heredarse.</summary>
      <typeparam name="TDelegate">Tipo de delegado que <see cref="T:System.Linq.Expressions.Expression`1" /> representa.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile">
      <summary>Compila la expresión lambda descrita por el árbol de la expresión en el código ejecutable y genera un delegado que representa la expresión lambda.</summary>
      <returns>Un delegado de tipo <paramref name="TDelegate" /> que representa la expresión lambda compilada descrita por <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile(System.Boolean)">
      <summary>Compila la expresión lambda descrita por el árbol de expresión en el código interpretado o compilado y genera a un delegado que representa la expresión lambda.</summary>
      <param name="preferInterpretation">
        <see langword="true" /> para indicar que la expresión se debe compilar en un formulario interpretado, si está disponible; <see langword="false" /> en caso contrario.</param>
      <returns>Delegado que representa la expresión lambda compilada descrita por el elemento <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile(System.Runtime.CompilerServices.DebugInfoGenerator)">
      <summary>Genera un delegado que representa la expresión lambda.</summary>
      <param name="debugInfoGenerator">Generador de información de depuración usado por el compilador para marcar puntos de secuencia y anotar variables locales.</param>
      <returns>Delegado que contiene la versión compilada del lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> del resultado.</param>
      <param name="parameters">Propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> del resultado.</param>
      <returns>Esta expresión si no se cambió ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionType">
      <summary>Describe los tipos de nodo para los nodos de un árbol de expresión.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Add">
      <summary>Operación de suma, como <c>a + b</c>, sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssign">
      <summary>Operación de asignación compuesta de suma, como <c>(a += b)</c>, sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssignChecked">
      <summary>Operación de asignación compuesta de suma, como <c>(a += b)</c>, con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddChecked">
      <summary>Operación de suma, como <c>(a + b)</c>, con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.And">
      <summary>Operación <see langword="AND" /> bit a bit o lógica, como <c>(a &amp; b)</c> en C# y <c>(a And b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAlso">
      <summary>Representa una operación <see langword="AND" /> condicional que evalúa el segundo operando solo si el primer operando se evalúa como <see langword="true" />. Se corresponde con <c>(a &amp;&amp; b)</c> en C# y <c>(a AndAlso b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAssign">
      <summary>Operación de asignación compuesta bit a bit o lógica <see langword="AND" /> , como <c>(a &amp; = b)</c> en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayIndex">
      <summary>Representa una operación de indización en una matriz unidimensional, como <c>array[index]</c> en C# o <c>array(index)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayLength">
      <summary>Operación que obtiene la longitud de una matriz unidimensional, como <c>array.Length</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Assign">
      <summary>Operación de asignación, como <c>(a = b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Block">
      <summary>Representa un bloque de expresiones.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Call">
      <summary>Una llamada de método, como en la expresión <c>obj.sampleMethod()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Coalesce">
      <summary>Nodo que representa una operación de uso combinado de Null, como <c>(a ?? b)</c> en C# o <c>If(a, b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Conditional">
      <summary>Una operación condicional, como <c>a &gt; b ? a : b</c> en C# o <c>If(a &gt; b, a, b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Constant">
      <summary>Un valor constante.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Convert">
      <summary>Una transmisión u operación de conversión, como <c>(SampleType)obj</c> en C# o <c>CType(obj, SampleType)</c> en Visual Basic. Para una conversión numérica, si el valor convertido es demasiado grande para el tipo de destino, no se produce ninguna excepción.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ConvertChecked">
      <summary>Una transmisión u operación de conversión, como <c>(SampleType)obj</c> en C# o <c>CType(obj, SampleType)</c> en Visual Basic. En el caso de una conversión numérica, se produce una excepción si el valor convertido no se ajusta al tipo de destino.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DebugInfo">
      <summary>Información de depuración.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Decrement">
      <summary>Una operación de decremento unario, como <c>(a - 1)</c> en C# y Visual Basic. El objeto <c>a</c> no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Default">
      <summary>Un valor predeterminado.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Divide">
      <summary>Una operación de división, como <c>(a / b)</c>, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DivideAssign">
      <summary>Una operación de asignación compuesta de división, como <c>(a /= b)</c>, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Dynamic">
      <summary>Una operación dinámica.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Equal">
      <summary>Un nodo que representa una comparación de igualdad, como <c>(a == b)</c> en C# o <c>(a = b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOr">
      <summary>Una operación <see langword="XOR" /> bit a bit o lógica, como <c>(a ^ b)</c> en C# o <c>(a Xor b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign">
      <summary>Operación de asignación compuesta <see langword="XOR" /> bit a bit o lógica, como <c>(a ^= b)</c> en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Extension">
      <summary>Una expresión de extensión.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Goto">
      <summary>Una expresión "ir a", como la <c>goto Label</c> en C# o la <c>GoTo Label</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThan">
      <summary>Una comparación "mayor que", como <c>(a &gt; b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual">
      <summary>Una comparación "mayor o igual que", como <c>(a &gt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Increment">
      <summary>Una operación de incremento unario, como <c>(a + 1)</c> en C# y Visual Basic. El objeto <c>a</c> no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Index">
      <summary>Una operación de índice u operación que tiene acceso a una propiedad que admite argumentos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Invoke">
      <summary>Una operación que invoca un delegado o una expresión lambda, como <c>sampleDelegate.Invoke()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsFalse">
      <summary>Un valor de condición <see langword="false" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsTrue">
      <summary>Un valor de condición <see langword="true" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Label">
      <summary>Una etiqueta.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Lambda">
      <summary>Una expresión lambda, como <c>a =&gt; a + a</c> en C# o <c>Function(a) a + a</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShift">
      <summary>Una operación de desplazamiento a la izquierda bit a bit, como <c>(a &lt;&lt; b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign">
      <summary>Una asignación compuesta y desplazamiento a la izquierda bit a bit, como <c>(a &lt;&lt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThan">
      <summary>Una comparación "menor que", como <c>(a &lt; b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual">
      <summary>Una comparación "menor o igual que", como <c>(a &lt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ListInit">
      <summary>Una operación que crea un nuevo objeto <see cref="T:System.Collections.IEnumerable" /> y lo inicializa desde una lista de elementos, como <c>new List&lt;SampleType&gt;(){ a, b, c }</c> en C# o <c>Dim sampleList = { a, b, c }</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Loop">
      <summary>Un bucle, como <c>for</c> o <c>while</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberAccess">
      <summary>Una operación que realiza la lectura de un campo o una propiedad, como <c>obj.SampleProperty</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberInit">
      <summary>Una operación que crea un nuevo objeto e inicializa uno o más de sus miembros, como <c>new Point { X = 1, Y = 2 }</c> en C# o <c>New Point With {.X = 1, .Y = 2}</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Modulo">
      <summary>Una operación de resto aritmético, como <c>(a % b)</c> en C# o <c>(a Mod b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ModuloAssign">
      <summary>Una operación de asignación compuesta y resto aritmético, como <c>(a %= b)</c> en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Multiply">
      <summary>Una operación de multiplicación, como <c>(a * b)</c>, sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssign">
      <summary>Una operación de asignación compuesta de multiplicación, como <c>(a *= b)</c>, sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked">
      <summary>Una operación de asignación compuesta de multiplicación, como <c>(a *= b)</c>, con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyChecked">
      <summary>Una operación de multiplicación, como <c>(a * b)</c>, con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Negate">
      <summary>Una operación de negación aritmética, como <c>(-a)</c>. El objeto <c>a</c> no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NegateChecked">
      <summary>Una operación de negación aritmética, como <c>(-a)</c>, con comprobación de desbordamiento. El objeto <c>a</c> no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.New">
      <summary>Una operación que llama a un constructor para crear un nuevo objeto, como <c>new SampleType()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayBounds">
      <summary>Una operación que crea una nueva matriz en la que se especifican los límites de cada dimensión, como <c>new SampleType[dim1, dim2]</c> en C# o <c>New SampleType(dim1, dim2)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayInit">
      <summary>Una operación que crea una nueva matriz de tipo unidimensional y la inicializa desde una lista de elementos, como <c>new SampleType[]{a, b, c}</c> en C# o <c>New SampleType(){a, b, c}</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Not">
      <summary>Una operación de complemento bit a bit o de negación lógica. En C#, su equivalente es <c>(~a)</c> para los tipos enteros y <c>(!a)</c> para los valores booleanos. En Visual Basic, su equivalente es <c>(Not a)</c>. El objeto <c>a</c> no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NotEqual">
      <summary>Una comparación de desigualdad, como <c>(a != b)</c> en C# o <c>(a &lt;&gt; b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OnesComplement">
      <summary>Una operación de complemento a unos, como <c>(~a)</c> en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Or">
      <summary>Una operación <see langword="OR" /> bit a bit o lógica, como <c>(a | b)</c> en C# o <c>(a Or b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrAssign">
      <summary>Una asignación compuesta <see langword="OR" /> bit a bit o lógica, como <c>(a |= b)</c> en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrElse">
      <summary>Una operación <see langword="OR" /> condicional de cortocircuito, como <c>(a || b)</c> en C# o <c>(a OrElse b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Parameter">
      <summary>Una referencia a un parámetro o variable que se define en el contexto de la expresión. Para obtener más información, vea <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostDecrementAssign">
      <summary>Un postfijo de decremento unario, como <c>(a--)</c>. El objeto <c>a</c> se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostIncrementAssign">
      <summary>Un postfijo de incremento unario, como <c>(a++)</c>. El objeto <c>a</c> se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Power">
      <summary>Una operación matemática que eleva un número a una potencia, como <c>(a ^ b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PowerAssign">
      <summary>Una operación de asignación compuesta que eleva un número a una potencia, como <c>(a ^= b)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreDecrementAssign">
      <summary>Un prefijo de decremento unario, como <c>(--a)</c>. El objeto <c>a</c> se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreIncrementAssign">
      <summary>Un prefijo de incremento unario, como <c>(++a)</c>. El objeto <c>a</c> se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Quote">
      <summary>Una expresión que tiene un valor constante de tipo <see cref="T:System.Linq.Expressions.Expression" />. Un nodo <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> puede contener referencias a parámetros definidos en el contexto de la expresión que representa.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShift">
      <summary>Una operación de desplazamiento a la derecha bit a bit, como <c>(a &gt;&gt; b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShiftAssign">
      <summary>Una operación de asignación compuesta y desplazamiento a la derecha bit a bit, como <c>(a &gt;&gt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RuntimeVariables">
      <summary>Una lista de variables en tiempo de ejecución. Para obtener más información, vea <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Subtract">
      <summary>Una operación de resta, como <c>(a - b)</c>, sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssign">
      <summary>Una operación de asignación compuesta de resta, como <c>(a -= b)</c>, sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked">
      <summary>Una operación de asignación compuesta de resta, como <c>(a -= b)</c>, con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractChecked">
      <summary>Una operación de resta aritmética, como <c>(a - b)</c>, que tiene comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Switch">
      <summary>Una operación de modificador, como <see langword="switch" /> en C# o <see langword="Select Case" /> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Throw">
      <summary>Una operación que inicia una excepción, como <c>throw new Exception()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Try">
      <summary>Una expresión <see langword="try-catch" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeAs">
      <summary>Una referencia explícita o una conversión boxing en la que se proporciona el valor <see langword="null" /> si se produce un error en la conversión, como <c>(obj as SampleType)</c> en C# o <c>TryCast(obj, SampleType)</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeEqual">
      <summary>Una prueba de tipo exacto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeIs">
      <summary>Un tipo de prueba, como <c>obj is SampleType</c> en C# o <c>TypeOf obj is SampleType</c> en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.UnaryPlus">
      <summary>Una operación de unario más, como <c>(+a)</c>. El resultado de una operación de unario más predefinida es el valor del operando, pero las implementaciones definidas por el usuario podrían tener resultados poco habituales.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Unbox">
      <summary>Una operación de conversión unboxing a un tipo de valor, como las instrucciones <see langword="unbox" /> y <see langword="unbox.any" /> en MSIL.</summary>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionVisitor">
      <summary>Representa un visitante o un sistema de reescritura para los árboles de expresión.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Linq.Expressions.ExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.Expression})">
      <summary>Envía la lista de expresiones a uno de los métodos de visita más especializados de esta clase.</summary>
      <param name="nodes">Expresiones que se van a visitar.</param>
      <returns>Lista de expresiones modificada, si se modificó alguno de los elementos; de lo contrario, devuelve la lista de expresiones original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Linq.Expressions.Expression)">
      <summary>Envía la expresión a uno de los métodos de visita más especializados de esta clase.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Func{``0,``0})">
      <summary>Visita todos los nodos de la colección utilizando un visitante de elementos especificado.</summary>
      <param name="nodes">Nodos que se van a visitar.</param>
      <param name="elementVisitor">Delegado que visita un único elemento, reemplazándolo opcionalmente con un elemento nuevo.</param>
      <typeparam name="T">Tipo de los nodos.</typeparam>
      <returns>Lista de nodos modificados, si se modificó alguno de los elementos; de lo contrario, devuelve la lista de nodos original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(``0,System.String)">
      <summary>Visita una expresión, convirtiendo de nuevo el resultado al tipo de expresión original.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <param name="callerName">Nombre del método de llamada; se utiliza para notificar un mensaje de error mejor.</param>
      <typeparam name="T">Tipo de la expresión.</typeparam>
      <exception cref="T:System.InvalidOperationException">El método Visit para este nodo devolvió un tipo diferente.</exception>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.String)">
      <summary>Visita una expresión, convirtiendo de nuevo el resultado al tipo de expresión original.</summary>
      <param name="nodes">Expresiones que se van a visitar.</param>
      <param name="callerName">Nombre del método de llamada; se utiliza para notificar un mensaje de error mejor.</param>
      <typeparam name="T">Tipo de las expresiones.</typeparam>
      <exception cref="T:System.InvalidOperationException">El método Visit para una de las expresiones devuelve un tipo diferente.</exception>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.BinaryExpression" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.BlockExpression" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitCatchBlock(System.Linq.Expressions.CatchBlock)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.ConditionalExpression" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.ConstantExpression" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDebugInfo(System.Linq.Expressions.DebugInfoExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDefault(System.Linq.Expressions.DefaultExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.DefaultExpression" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDynamic(System.Linq.Expressions.DynamicExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.DynamicExpression" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitElementInit(System.Linq.Expressions.ElementInit)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitExtension(System.Linq.Expressions.Expression)">
      <summary>Visita los elementos secundarios de la expresión de extensión.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitGoto(System.Linq.Expressions.GotoExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitIndex(System.Linq.Expressions.IndexExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.IndexExpression" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.InvocationExpression" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabel(System.Linq.Expressions.LabelExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.LabelExpression" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabelTarget(System.Linq.Expressions.LabelTarget)">
      <summary>Visita <see cref="T:System.Linq.Expressions.LabelTarget" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.Expression`1" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <typeparam name="T">Tipo de delegado.</typeparam>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.ListInitExpression" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLoop(System.Linq.Expressions.LoopExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.LoopExpression" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMember(System.Linq.Expressions.MemberExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberExpression" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberAssignment" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberBinding(System.Linq.Expressions.MemberBinding)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberListBinding" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberMemberBinding" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.NewExpression" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.NewArrayExpression" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitRuntimeVariables(System.Linq.Expressions.RuntimeVariablesExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitch(System.Linq.Expressions.SwitchExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitchCase(System.Linq.Expressions.SwitchCase)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTry(System.Linq.Expressions.TryExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.TryExpression" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTypeBinary(System.Linq.Expressions.TypeBinaryExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</summary>
      <param name="node">Expresión que se va a visitar.</param>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpression">
      <summary>Representa un salto incondicional. Esto incluye instrucciones return, instrucciones break y continue, y otros saltos.</summary>
    </member>
    <member name="M:System.Linq.Expressions.GotoExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="target">Propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> del resultado.</param>
      <param name="value">Propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Value" /> del resultado.</param>
      <returns>Esta expresión si no se cambió ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Kind">
      <summary>Tipo de la expresión "ir a". Solo tiene fines informativos.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> que representa el tipo de la expresión "ir a".</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.NodeType">
      <summary>Devuelve el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Target">
      <summary>Etiqueta de destino a donde salta este nodo.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa la etiqueta de destino para este nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.GotoExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Value">
      <summary>Valor pasado al destino o null si el destino es de tipo System.Void.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el valor pasado al destino o null.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpressionKind">
      <summary>Especifica qué tipo de salto representa esta clase <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Break">
      <summary>Clase <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción break.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Continue">
      <summary>Clase <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción continue.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Goto">
      <summary>Clase <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa un salto a alguna ubicación.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Return">
      <summary>Clase <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción return.</summary>
    </member>
    <member name="T:System.Linq.Expressions.IArgumentProvider">
      <summary>Proporciona una interfaz interna para acceder a los argumentos de varios nodos de árbol (DynamicExpression, ElementInit, MethodCallExpression, InvocationExpression, NewExpression e IndexExpression).  Esta API es solo para uso interno.</summary>
    </member>
    <member name="M:System.Linq.Expressions.IArgumentProvider.GetArgument(System.Int32)">
      <summary>Devuelve el argumento en <paramref name="index" />, y se iniciará una excepción si <paramref name="index" /> está fuera de los límites. Esta API es solo para uso interno.</summary>
      <param name="index">Índice del argumento.</param>
      <returns>El argumento en el índice.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IArgumentProvider.ArgumentCount">
      <summary>Devuelve el número de argumentos al nodo de árbol de expresión. Esta API es solo para uso interno.</summary>
      <returns>Número de argumentos al nodo de árbol de expresión como <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:System.Linq.Expressions.IDynamicExpression">
      <summary>Proporciona una interfaz interna para acceder a los argumentos de los nodos del árbol de DynamicExpression, así como a la funcionalidad de sitio de llamada y reescritura.  Esta API no debe usarse.  Solo es pública debido a la refactorización de la DLL, y existe únicamente para optimizaciones de rendimiento interno.</summary>
    </member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.CreateCallSite">
      <summary>Opcionalmente, crea el elemento CallSite y devuelve el de la caché insertada polimórfica de DynamicExpression.  No se debe usar este tipo.  Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.</summary>
      <returns>CallSite de la caché insertada polimórfica de DynamicExpression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.Rewrite(System.Linq.Expressions.Expression[])">
      <summary>Vuelve a escribir este nodo y reemplaza los argumentos de la expresión dinámica por los valores proporcionados.  El número de <paramref name="args" /> debe coincidir con el número de la expresión actual.  No se debe usar este tipo.  Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.  Este método del asistente permite volver a escribir los nodos de modo que sean independientes de la clase de implementación específica que deriva de la DynamicExpression que se usa en el sitio de llamada.</summary>
      <param name="args">Argumentos que se usan para reemplazar este nodo.</param>
      <returns>Nodo reescrito; si no se realizaron cambios, devuelve el mismo nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IDynamicExpression.DelegateType">
      <summary>Obtiene el tipo de delegado usado por CallSite, que es el tipo de las reglas usadas en la caché insertada polimórfica de la expresión dinámica.</summary>
      <returns>Tipo de delegado usado por el sitio de llamada.</returns>
    </member>
    <member name="T:System.Linq.Expressions.IndexExpression">
      <summary>Representa la indización de una propiedad o una matriz.</summary>
    </member>
    <member name="M:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary>Devuelve el argumento en el índice, indicando si el índice está fuera de los límites.  No debe usar este miembro.  Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.</summary>
      <param name="index">Índice del argumento.</param>
      <returns>Devuelve <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IndexExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="object">Propiedad <see cref="P:System.Linq.Expressions.IndexExpression.Object" /> del resultado.</param>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.IndexExpression.Arguments" /> del resultado.</param>
      <returns>Esta expresión si no se cambió ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Arguments">
      <summary>Obtiene los argumentos que se usarán para indexar la propiedad o matriz.</summary>
      <returns>Colección de solo lectura que contiene los argumentos que se usarán para indexar la propiedad o matriz.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Indexer">
      <summary>Obtiene la <see cref="T:System.Reflection.PropertyInfo" /> de la propiedad si la expresión representa una propiedad indizada; devuelve null en caso contrario.</summary>
      <returns>
        <see cref="T:System.Reflection.PropertyInfo" /> de la propiedad si la expresión representa una propiedad indizada; en caso contrario, null.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.NodeType">
      <summary>Devuelve el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Object">
      <summary>Objeto que se va a indexar.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto que se va a indexar.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary>Devuelve el número de argumentos al nodo de árbol de expresión.  No debe usar este miembro.  Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.</summary>
      <returns>Devuelve <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.IndexExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.InvocationExpression">
      <summary>Representa una expresión que aplica un delegado o una expresión lambda a una lista de expresiones de argumento.</summary>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary>Devuelve el argumento en el índice, indicando si el índice está fuera de los límites.  No debe usar este miembro.  Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.</summary>
      <param name="index">Índice del argumento.</param>
      <returns>El argumento en el índice, indicando si el índice está fuera de los límites, como <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="expression">Propiedad <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> del resultado.</param>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.InvocationExpression.Arguments" /> del resultado.</param>
      <returns>Esta expresión si no se cambió ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Arguments">
      <summary>Obtiene los argumentos a los que se aplican el delegado o expresión lambda.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos a los que se aplica el delegado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Expression">
      <summary>Obtiene el delegado o expresión lambda que se aplicará.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el delegado que se aplicará.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión. Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary>Devuelve el número de argumentos al nodo de árbol de expresión.  No debe usar este miembro.  Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.</summary>
      <returns>Número de argumentos al nodo de árbol de expresión como <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.InvocationExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LabelExpression">
      <summary>Representa una etiqueta, que se puede colocar en cualquier contexto de <see cref="T:System.Linq.Expressions.Expression" />. Si se salta a ella, obtendrá el valor proporcionado por la clase <see cref="T:System.Linq.Expressions.GotoExpression" /> correspondiente. De lo contrario, recibe el valor de <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" />. Si <see cref="T:System.Type" /> es igual a System.Void, no se debe proporcionar ningún valor.</summary>
    </member>
    <member name="M:System.Linq.Expressions.LabelExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="target">Propiedad <see cref="P:System.Linq.Expressions.LabelExpression.Target" /> del resultado.</param>
      <param name="defaultValue">Propiedad <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" /> del resultado.</param>
      <returns>Esta expresión si no se cambió ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.DefaultValue">
      <summary>Valor de <see cref="T:System.Linq.Expressions.LabelExpression" /> cuando se llega a la etiqueta mediante el flujo de control normal (por ejemplo, no se salta a ella).</summary>
      <returns>Objeto Expression que representa el valor de la clase <see cref="T:System.Linq.Expressions.LabelExpression" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.NodeType">
      <summary>Devuelve el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Target">
      <summary>Clase <see cref="T:System.Linq.Expressions.LabelTarget" /> a la que está asociada esta etiqueta.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.LabelTarget" /> a la que está asociada esta etiqueta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LabelExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LabelTarget">
      <summary>Se utiliza para representar el destino de una clase <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.LabelTarget.ToString">
      <summary>Devuelve un valor de tipo <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</summary>
      <returns>Una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Name">
      <summary>Obtiene el nombre de la etiqueta.</summary>
      <returns>Nombre de la etiqueta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Type">
      <summary>Tipo de valor que se pasa al saltar a la etiqueta (o <see cref="T:System.Void" /> si no se debe pasar ningún valor).</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo del valor que se pasa al saltar a la etiqueta o <see cref="T:System.Void" /> si no se debe pasar ningún valor.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LambdaExpression">
      <summary>Describe una expresión lambda. Captura un bloque de código similar a un cuerpo de método. NET.</summary>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile">
      <summary>Genera un delegado que representa la expresión lambda.</summary>
      <returns>
        <see cref="T:System.Delegate" /> que contiene la versión compilada de la expresión lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile(System.Boolean)">
      <summary>Genera a un delegado interpretado o compilado que representa la expresión lambda.</summary>
      <param name="preferInterpretation">
        <see langword="true" /> para indicar que la expresión se debe compilar en un formulario interpretado, si está disponible; en caso contrario, <see langword="false" />.</param>
      <returns>Delegado que representa la expresión lambda compilada descrita por el objeto <see cref="T:System.Linq.Expressions.LambdaExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile(System.Runtime.CompilerServices.DebugInfoGenerator)">
      <summary>Genera un delegado que representa la expresión lambda.</summary>
      <param name="debugInfoGenerator">Generador de información de depuración usado por el compilador para marcar puntos de secuencia y anotar variables locales.</param>
      <returns>Delegado que contiene la versión compilada del lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Body">
      <summary>Obtiene el cuerpo de la expresión lambda.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo de la expresión lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Name">
      <summary>Obtiene el nombre de la expresión lambda.</summary>
      <returns>Nombre de la expresión lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.NodeType">
      <summary>Devuelve el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Parameters">
      <summary>Obtiene los parámetros de la expresión lambda.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa los parámetros de la expresión lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.ReturnType">
      <summary>Obtiene el tipo de valor devuelto de la expresión lambda.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de la expresión lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.TailCall">
      <summary>Obtiene el valor que indica si la expresión lambda se compilará con la optimización de llamada de cola.</summary>
      <returns>
        <see langword="true" /> Si la expresión lambda se compilará con la optimización de llamada de cola; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LambdaExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ListInitExpression">
      <summary>Representa una llamada de constructor que tiene un inicializador de colección.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Reduce">
      <summary>Reduce el nodo de expresión binario a una expresión más sencilla.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="newExpression">Propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> del resultado.</param>
      <param name="initializers">Propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> del resultado.</param>
      <returns>Esta expresión si no se cambió ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.CanReduce">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión se puede reducir.</summary>
      <returns>
        <see langword="true" /> es si se puede reducir el nodo; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Initializers">
      <summary>Obtiene los inicializadores de elementos que se utilizan para inicializar una colección.</summary>
      <returns>Uno de los objetos <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de <see cref="T:System.Linq.Expressions.ElementInit" /> que representan los elementos que se utilizan para inicializar la colección.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NewExpression">
      <summary>Obtiene la expresión que contiene una llamada al constructor de un tipo de colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor de un tipo de colección.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NodeType">
      <summary>Devuelve el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ListInitExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LoopExpression">
      <summary>Representa un bucle infinito. Puede terminar con "break".</summary>
    </member>
    <member name="M:System.Linq.Expressions.LoopExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="breakLabel">Propiedad <see cref="P:System.Linq.Expressions.LoopExpression.BreakLabel" /> del resultado.</param>
      <param name="continueLabel">Propiedad <see cref="P:System.Linq.Expressions.LoopExpression.ContinueLabel" /> del resultado.</param>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.LoopExpression.Body" /> del resultado.</param>
      <returns>Esta expresión si no se cambió ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Body">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.Expression" />, que es el cuerpo del bucle.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.Expression" /> que es el cuerpo del bucle.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.BreakLabel">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizada por el cuerpo del bucle como destino de la instrucción break.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizada por el cuerpo del bucle como destino de la instrucción break.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.ContinueLabel">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizada por el cuerpo del bucle como destino de la instrucción continue.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizada por el cuerpo del bucle como destino de la instrucción continue.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión. Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LoopExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberAssignment">
      <summary>Representa la operación de asignación de un campo o una propiedad de un objeto.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberAssignment.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="expression">Propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> del resultado.</param>
      <returns>Esta expresión si no se cambió ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberAssignment.Expression">
      <summary>Obtiene la expresión que se asigna al campo o propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el valor que se asigna al campo o propiedad.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBinding">
      <summary>Proporciona la clase base de la que se derivan las clases que representan los enlaces usados para inicializar los miembros de un objeto recién creado.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.#ctor(System.Linq.Expressions.MemberBindingType,System.Reflection.MemberInfo)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <param name="type">Objeto <see cref="T:System.Linq.Expressions.MemberBindingType" /> que discrimina el tipo de enlace que se representa.</param>
      <param name="member">Objeto <see cref="T:System.Reflection.MemberInfo" /> que representa un campo o propiedad que va a inicializarse.</param>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.ToString">
      <summary>Devuelve una representación textual de <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Representación textual de <see cref="T:System.Linq.Expressions.MemberBinding" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.BindingType">
      <summary>Obtiene el tipo de enlace que se representa.</summary>
      <returns>Uno de los valores de <see cref="T:System.Linq.Expressions.MemberBindingType" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.Member">
      <summary>Obtiene el campo o la propiedad que se va a inicializar.</summary>
      <returns>Objeto <see cref="T:System.Reflection.MemberInfo" /> que representa el campo o la propiedad que va a inicializarse.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBindingType">
      <summary>Describe los tipos de enlace que se utilizan en objetos <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.Assignment">
      <summary>Un enlace que representa la inicialización de un miembro con el valor de una expresión.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.ListBinding">
      <summary>Un enlace que representa la inicialización de un miembro de tipo <see cref="T:System.Collections.IList" /> o <see cref="T:System.Collections.Generic.ICollection`1" /> de una lista de elementos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.MemberBinding">
      <summary>Un enlace que representa la inicialización de forma recursiva de los miembros de un miembro.</summary>
    </member>
    <member name="T:System.Linq.Expressions.MemberExpression">
      <summary>Representa el acceso a un campo o una propiedad.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo. Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
      <returns>Resultado de visitar este nodo.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="expression">Propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> del resultado.</param>
      <returns>Esta expresión si no se cambió ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Expression">
      <summary>Obtiene el objeto contenedor del campo o propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto contenedor del campo o propiedad.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Member">
      <summary>Obtiene el campo o la propiedad a los que se va a tener acceso.</summary>
      <returns>
        <see cref="T:System.Reflection.MemberInfo" /> que representa el campo o la propiedad a los que se va a tener acceso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.NodeType">
      <summary>Devuelve el tipo de nodo de <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberInitExpression">
      <summary>Representa la llamada a un constructor y la inicialización de uno o más miembros del objeto nuevo.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Reduce">
      <summary>Reduce <see cref="T:System.Linq.Expressions.MemberInitExpression" /> a una expresión más sencilla.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="newExpression">Propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> del resultado.</param>
      <param name="bindings">Propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> del resultado.</param>
      <returns>Esta expresión si no se cambió ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Bindings">
      <summary>Obtiene los enlaces que describen cómo inicializar los miembros del objeto recientemente creado.</summary>
      <returns>Una colección <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que describen cómo inicializar los miembros.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.CanReduce">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión se puede reducir.</summary>
      <returns>
        <see langword="true" /> es si se puede reducir el nodo; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NewExpression">
      <summary>Obtiene la expresión que representa la llamada al constructor.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión. Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MemberInitExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberListBinding">
      <summary>Representa la inicialización de los elementos de un miembro de la colección de un objeto recién creado.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberListBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="initializers">Propiedad <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> del resultado.</param>
      <returns>Esta expresión si no se cambió ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberListBinding.Initializers">
      <summary>Obtiene los inicializadores de elemento para inicializar un miembro de colección de un objeto que se acaba de crear.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> con que se inicializa un miembro de colección.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberMemberBinding">
      <summary>Representa la inicialización de los miembros de un miembro del objeto recién creado.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberMemberBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="bindings">Propiedad <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> del resultado.</param>
      <returns>Esta expresión si no se cambió ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberMemberBinding.Bindings">
      <summary>Obtiene los enlaces que describen cómo inicializar los miembros de un miembro.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que describen cómo inicializar los miembros del miembro.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MethodCallExpression">
      <summary>Representa una llamada a un método estático o de instancia.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo. Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
      <returns>Resultado de visitar este nodo.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary>Devuelve el argumento en el índice, indicando si el índice está fuera de los límites.  No debe usar este miembro.  Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.</summary>
      <param name="index">Índice del argumento.</param>
      <returns>Devuelve <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="object">Propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> del resultado.</param>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> del resultado.</param>
      <returns>Esta expresión si no se cambió ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Arguments">
      <summary>Obtiene una colección de expresiones que representan los argumentos del método al que se llamó.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos del método al que se llamó.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Method">
      <summary>Obtiene la <see cref="T:System.Reflection.MethodInfo" /> del método al que se va a llamar.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método al que se llamó.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.NodeType">
      <summary>Devuelve el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Object">
      <summary>Obtiene la <see cref="T:System.Linq.Expressions.Expression" /> que representa la instancia para las llamadas al método de instancia o null para las llamadas al método estático.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto receptor del método.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary>Devuelve el número de argumentos al nodo de árbol de expresión.  No debe usar este miembro.  Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.</summary>
      <returns>El número de argumentos del nodo de árbol de expresión como  <see cref="T:System.Int32" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MethodCallExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.NewArrayExpression">
      <summary>Representa la creación de una nueva matriz y la posible inicialización de sus elementos.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo. Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
      <returns>Resultado de visitar este nodo.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="expressions">Propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> del resultado.</param>
      <returns>Esta expresión si no se cambió ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Expressions">
      <summary>Obtiene los límites de la matriz si el valor de la propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" />, o los valores para inicializar los elementos de la nueva matriz si el valor de la propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />.</summary>
      <returns>Un objeto <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de los objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los límites de la matriz o los valores de inicialización.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewArrayExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.NewExpression">
      <summary>Representa una llamada al constructor.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo. Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
      <returns>Resultado de visitar este nodo.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary>Devuelve el argumento en el índice, indicando si el índice está fuera de los límites.</summary>
      <param name="index">Índice del argumento.</param>
      <returns>Argumento en el índice, indicando si el índice está fuera de los límites.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> del resultado.</param>
      <returns>Esta expresión si no se cambió ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Arguments">
      <summary>Obtiene los argumentos del constructor.</summary>
      <returns>Colección de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos del constructor.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Constructor">
      <summary>Obtiene el constructor al que se llamó.</summary>
      <returns>
        <see cref="T:System.Reflection.ConstructorInfo" /> que representa el constructor al que se llamó.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Members">
      <summary>Obtiene los miembros que pueden recuperar los valores de los campos que se inicializaron con argumentos de constructor.</summary>
      <returns>Colección de objetos <see cref="T:System.Reflection.MemberInfo" /> que representan los miembros que pueden recuperar los valores de los campos que se inicializaron con argumentos de constructor.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.NodeType">
      <summary>Devuelve el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary>Obtiene el número de argumentos en el nodo de árbol de expresión.</summary>
      <returns>Número de argumentos al nodo de árbol de expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ParameterExpression">
      <summary>Representa una expresión de parámetro con nombre.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ParameterExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo. Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
      <returns>Resultado de visitar este nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.IsByRef">
      <summary>Indica que el parámetro<c>ParameterExpression</c> se va a tratar como un parámetro <see langword="ByRef" />.</summary>
      <returns>
        <see langword="true" /> Si este <c>ParameterExpression</c> es un <see langword="ByRef" /> parámetro; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Name">
      <summary>Obtiene el nombre del parámetro o variable.</summary>
      <returns>
        <see cref="T:System.String" /> que contiene el nombre del parámetro.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.NodeType">
      <summary>Devuelve el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ParameterExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.RuntimeVariablesExpression">
      <summary>Expresión que proporciona permiso de lectura y escritura en tiempo de ejecución para variables.</summary>
    </member>
    <member name="M:System.Linq.Expressions.RuntimeVariablesExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="variables">Propiedad <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> del resultado.</param>
      <returns>Esta expresión si no se cambió ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión. Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables">
      <summary>Las variables o los parámetros para los que se va a proporcionar acceso en tiempo de ejecución.</summary>
      <returns>Colección de solo lectura que contiene parámetros para los que se proporcionará acceso en tiempo de ejecución.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchCase">
      <summary>Representa un caso de una clase <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.ToString">
      <summary>Devuelve un valor de tipo <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</summary>
      <returns>Una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="testValues">Propiedad <see cref="P:System.Linq.Expressions.SwitchCase.TestValues" /> del resultado.</param>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.SwitchCase.Body" /> del resultado.</param>
      <returns>Esta expresión si no se cambió ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.Body">
      <summary>Obtiene el cuerpo de este caso.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del bloque de casos.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.TestValues">
      <summary>Obtiene los valores de este caso. Este caso se selecciona para su ejecución cuando <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> coincide con cualquiera de estos valores.</summary>
      <returns>Colección de solo lectura de los valores para este bloque de casos.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchExpression">
      <summary>Representa una expresión de control que administra varias selecciones pasando el control a <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.SwitchExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase},System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="switchValue">Propiedad <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> del resultado.</param>
      <param name="cases">Propiedad <see cref="P:System.Linq.Expressions.SwitchExpression.Cases" /> del resultado.</param>
      <param name="defaultBody">Propiedad <see cref="P:System.Linq.Expressions.SwitchExpression.DefaultBody" /> del resultado.</param>
      <returns>Esta expresión si no se cambió ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Cases">
      <summary>Obtiene la colección de objetos <see cref="T:System.Linq.Expressions.SwitchCase" /> del modificador.</summary>
      <returns>La colección de objetos <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Comparison">
      <summary>Obtiene el método de comparación de igualdad, si existe.</summary>
      <returns>Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de comparación de igualdad.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.DefaultBody">
      <summary>Obtiene la prueba para el modificador.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa la prueba del modificador.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión. Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.SwitchValue">
      <summary>Obtiene la prueba para el modificador.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa la prueba del modificador.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.SwitchExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SymbolDocumentInfo">
      <summary>Almacena la información necesaria para emitir información de símbolos de depuración para un archivo de origen, en particular, el nombre de archivo y el identificador de idioma único.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType">
      <summary>Devuelve el identificador único del tipo de documento, si existe. Tiene como valor predeterminado el GUID para un archivo de texto.</summary>
      <returns>Identificador único del tipo de documento.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.FileName">
      <summary>Nombre del archivo de código fuente.</summary>
      <returns>Cadena que representa el nombre del archivo de código fuente.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.Language">
      <summary>Devuelve el identificador único del idioma, si existe.</summary>
      <returns>Identificador único del idioma.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor">
      <summary>Devuelve el identificador único del proveedor de idioma, si existe.</summary>
      <returns>Identificador único del proveedor de idioma.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TryExpression">
      <summary>Representa un bloque try/catch/finally/fault.</summary>
    </member>
    <member name="M:System.Linq.Expressions.TryExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.TryExpression.Body" /> del resultado.</param>
      <param name="handlers">Propiedad <see cref="P:System.Linq.Expressions.TryExpression.Handlers" /> del resultado.</param>
      <param name="finally">Propiedad <see cref="P:System.Linq.Expressions.TryExpression.Finally" /> del resultado.</param>
      <param name="fault">Propiedad <see cref="P:System.Linq.Expressions.TryExpression.Fault" /> del resultado.</param>
      <returns>Esta expresión si no se cambió ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Body">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del bloque try.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del bloque try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Fault">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque de errores.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque de errores.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Finally">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque finally.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque finally.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Handlers">
      <summary>Obtiene la colección de expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> asociadas al bloque try.</summary>
      <returns>Colección de expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> asociadas al bloque try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.NodeType">
      <summary>Devuelve el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TryExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TypeBinaryExpression">
      <summary>Representa una operación entre una expresión y un tipo.</summary>
    </member>
    <member name="M:System.Linq.Expressions.TypeBinaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="expression">Propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> del resultado.</param>
      <returns>Esta expresión si no se cambió ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Expression">
      <summary>Obtiene el operando de la expresión de una operación de prueba de un tipo.</summary>
      <returns>Un objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando de la expresión de una operación de prueba de tipo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión. Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand">
      <summary>Obtiene el operando de tipo de una operación de prueba de tipo.</summary>
      <returns>Un <see cref="T:System.Type" /> que representa el operando del tipo de una operación de prueba de tipo.</returns>
    </member>
    <member name="T:System.Linq.Expressions.UnaryExpression">
      <summary>Representa una expresión que tiene un operador unario.</summary>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Reduce">
      <summary>Reduce el nodo de expresión a una expresión más sencilla.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado. Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <param name="operand">Propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> del resultado.</param>
      <returns>Esta expresión si no se cambió ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.CanReduce">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión se puede reducir.</summary>
      <returns>
        <see langword="true" /> es si se puede reducir un nodo; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLifted">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión representa una llamada elevada a un operador.</summary>
      <returns>Es <see langword="true" /> si el nodo representa una llamada elevada; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLiftedToNull">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión representa una llamada elevada a un operador cuyo tipo de valor devuelto se eleva a un tipo que acepta valores null.</summary>
      <returns>Es <see langword="true" /> si el tipo de valor devuelto del operador se eleva a un tipo que acepta valores null; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Method">
      <summary>Obtiene el método de implementación para la operación unaria.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.NodeType">
      <summary>Devuelve el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Operand">
      <summary>Obtiene el operando de la operación unaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando de la operación unaria.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.UnaryExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.IOrderedQueryable">
      <summary>Representa el resultado de una operación de ordenación.</summary>
    </member>
    <member name="T:System.Linq.IOrderedQueryable`1">
      <summary>Representa el resultado de una operación de ordenación.</summary>
      <typeparam name="T">Tipo de contenido del origen de datos.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryable">
      <summary>Proporciona características para evaluar consultas con respecto a un origen de datos concreto en el que el tipo de datos no está especificado.</summary>
    </member>
    <member name="P:System.Linq.IQueryable.ElementType">
      <summary>Obtiene el tipo de los elementos que se devuelven cuando se ejecuta el árbol de expresión asociado a esta instancia de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>Un <see cref="T:System.Type" /> que representa el tipo de los elementos que se devuelven cuando se ejecuta el árbol de expresión asociado a este objeto.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Expression">
      <summary>Obtiene el árbol de expresión que está asociado a la instancia de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que está asociado a esta instancia de <see cref="T:System.Linq.IQueryable" />.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Provider">
      <summary>Obtiene el proveedor de consultas que está asociado a este origen de datos.</summary>
      <returns>El objeto <see cref="T:System.Linq.IQueryProvider" /> que está asociado a este origen de datos.</returns>
    </member>
    <member name="T:System.Linq.IQueryable`1">
      <summary>Proporciona características para evaluar consultas con respecto a un origen de datos concreto en el que se conoce el tipo de datos.</summary>
      <typeparam name="T">El tipo de los datos del origen de datos.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryProvider">
      <summary>Define los métodos para crear y ejecutar las consultas descritas por un objeto <see cref="T:System.Linq.IQueryable" />.</summary>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery(System.Linq.Expressions.Expression)">
      <summary>Construye un objeto <see cref="T:System.Linq.IQueryable" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</summary>
      <param name="expression">Árbol de expresión que representa una consulta de LINQ.</param>
      <returns>
        <see cref="T:System.Linq.IQueryable" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</returns>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery``1(System.Linq.Expressions.Expression)">
      <summary>Construye un objeto <see cref="T:System.Linq.IQueryable`1" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</summary>
      <param name="expression">Árbol de expresión que representa una consulta de LINQ.</param>
      <typeparam name="TElement">Tipo de los elementos del objeto <see cref="T:System.Linq.IQueryable`1" /> que se devuelve.</typeparam>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</returns>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute(System.Linq.Expressions.Expression)">
      <summary>Ejecuta la consulta representada por el árbol de expresión especificado.</summary>
      <param name="expression">Árbol de expresión que representa una consulta de LINQ.</param>
      <returns>Valor que es el resultado de ejecutar la consulta especificada.</returns>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute``1(System.Linq.Expressions.Expression)">
      <summary>Ejecuta la consulta fuertemente tipada representada por el árbol de expresión especificado.</summary>
      <param name="expression">Árbol de expresión que representa una consulta de LINQ.</param>
      <typeparam name="TResult">Tipo del valor que es el resultado de ejecutar la consulta.</typeparam>
      <returns>Valor que es el resultado de ejecutar la consulta especificada.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSite">
      <summary>Clase base de un sitio de llamada dinámico. Este tipo se usa como un tipo de parámetro para los destinos de sitio dinámico.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSite.Create(System.Type,System.Runtime.CompilerServices.CallSiteBinder)">
      <summary>Crea un sitio de llamada con el tipo de delegado y el enlazador dados.</summary>
      <param name="delegateType">Tipo de delegado del sitio de llamada.</param>
      <param name="binder">Enlazador del sitio de llamada.</param>
      <returns>Nuevo sitio de llamada.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSite.Binder">
      <summary>Clase responsable de operaciones dinámicas de enlace en el sitio dinámico.</summary>
      <returns>Objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> responsable de operaciones dinámicas de enlace.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSite`1">
      <summary>Tipo de sitio dinámico.</summary>
      <typeparam name="T">Tipo de delegado.</typeparam>
    </member>
    <member name="F:System.Runtime.CompilerServices.CallSite`1.Target">
      <summary>Caché de nivel 0: un delegado especializado basado en el historial del sitio.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSite`1.Create(System.Runtime.CompilerServices.CallSiteBinder)">
      <summary>Crea una instancia del sitio de llamada dinámico, inicializada con el enlazador responsable del enlace en tiempo de ejecución de las operaciones dinámicas en este sitio de llamada.</summary>
      <param name="binder">Enlazador responsable del enlace en tiempo de ejecución de las operaciones dinámicas en este sitio de llamada.</param>
      <returns>Nueva instancia de sitio de llamada dinámico.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSite`1.Update">
      <summary>Delegado de actualización. Se le llama cuando el sitio dinámico experimenta líneas no ejecutadas de caché.</summary>
      <returns>Delegado de actualización.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSiteBinder">
      <summary>Clase responsable del enlace en tiempo de ejecución de las operaciones dinámicas en el sitio de llamada dinámico.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.Bind(System.Object[],System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.LabelTarget)">
      <summary>Realiza el enlace en tiempo de ejecución de la operación dinámica sobre un conjunto de argumentos.</summary>
      <param name="args">Matriz de argumentos de la operación dinámica.</param>
      <param name="parameters">Matriz de instancias de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representan los parámetros del sitio de llamada en el proceso de enlace.</param>
      <param name="returnLabel">Objeto LabelTarget utilizado para devolver el resultado del enlace dinámico.</param>
      <returns>Expresión que realiza pruebas sobre los argumentos de la operación dinámica y realiza la operación dinámica si las pruebas son válidas. Si se produce un error en las pruebas en las repeticiones subsiguientes de la operación dinámica, se llamará de nuevo a Bind para generar una nueva clase <see cref="T:System.Linq.Expressions.Expression" /> para los nuevos tipos de argumento.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.BindDelegate``1(System.Runtime.CompilerServices.CallSite{``0},System.Object[])">
      <summary>Proporciona compatibilidad con el enlace en tiempo de ejecución de bajo nivel. Las clases pueden reemplazarlo y proporcionar un delegado directo para la implementación de la regla. Esto puede permitir guardar reglas en el disco, tener reglas especializadas disponibles en tiempo de ejecución o proporcionar una directiva de almacenamiento en memoria caché diferente.</summary>
      <param name="site">Sitio de llamada para el que se va a realizar el enlace.</param>
      <param name="args">Argumentos para el enlazador.</param>
      <typeparam name="T">Tipo de destino del sitio de llamada.</typeparam>
      <returns>Nuevo delegado que reemplaza el destino del sitio de llamada.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.CacheTarget``1(``0)">
      <summary>Agrega un destino a la memoria caché de destinos conocidos. Se examinarán los destinos almacenados en memoria caché antes de llamar a BindDelegate para generar la nueva regla.</summary>
      <param name="target">Delegado de destino que se va a agregar a la memoria caché.</param>
      <typeparam name="T">Tipo de destino que se va a agregar.</typeparam>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSiteBinder.UpdateLabel">
      <summary>Obtiene una etiqueta que se puede utilizar para provocar la actualización del enlace. Indica que el enlace de la expresión ya no es válido. Normalmente se utiliza cuando la "versión" de un objeto dinámico ha cambiado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta que se puede utilizar para desencadenar la actualización del enlace.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSiteHelpers">
      <summary>Clase que contiene métodos del asistente para sitios de llamada DLR.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteHelpers.IsInternalFrame(System.Reflection.MethodBase)">
      <summary>Comprueba si DLR utiliza internamente <see cref="T:System.Reflection.MethodBase" /> y no se debe mostrar en la pila del código de idioma.</summary>
      <param name="mb">Clase <see cref="T:System.Reflection.MethodBase" /> de entrada.</param>
      <returns>
        <see langword="true" /> si DLR usa de forma interna la clase <see cref="T:System.Reflection.MethodBase" /> de entrada y no se debe mostrar en la pila del código de idioma. En caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.DebugInfoGenerator">
      <summary>Genera información de depuración para expresiones lambda en un árbol de expresión.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DebugInfoGenerator.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Runtime.CompilerServices.DebugInfoGenerator" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DebugInfoGenerator.CreatePdbGenerator">
      <summary>Crea un generador de símbolos de base de datos de programa (PDB).</summary>
      <returns>Generador de símbolos de PDB.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.DebugInfoGenerator.MarkSequencePoint(System.Linq.Expressions.LambdaExpression,System.Int32,System.Linq.Expressions.DebugInfoExpression)">
      <summary>Marca un punto de secuencia en código Lenguaje intermedio de Microsoft (MSIL).</summary>
      <param name="method">Expresión lambda que se genera.</param>
      <param name="ilOffset">Desplazamiento dentro del código MSIL en el que se va a marcar el punto de secuencia.</param>
      <param name="sequencePoint">Información de depuración correspondiente al punto de secuencia.</param>
    </member>
    <member name="T:System.Runtime.CompilerServices.DynamicAttribute">
      <summary>Indica que el uso de <see cref="T:System.Object" /> en un miembro significa que se tratará como un tipo enviado dinámicamente.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DynamicAttribute.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Runtime.CompilerServices.DynamicAttribute" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DynamicAttribute.#ctor(System.Boolean[])">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Runtime.CompilerServices.DynamicAttribute" />.</summary>
      <param name="transformFlags">Especifica, en un cruce seguro de prefijo de la construcción de un tipo, que las apariciones de <see cref="T:System.Object" /> deben tratarse como un tipo enviado dinámicamente.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.DynamicAttribute.TransformFlags">
      <summary>Especifica, en un cruce seguro de prefijo de la construcción de un tipo, que las apariciones de <see cref="T:System.Object" /> deben tratarse como un tipo enviado dinámicamente.</summary>
      <returns>Lista de apariciones de <see cref="T:System.Object" /> que deben tratarse como un tipo enviado dinámicamente.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.IRuntimeVariables">
      <summary>Representa los valores de variables en tiempo de ejecución.</summary>
    </member>
    <member name="P:System.Runtime.CompilerServices.IRuntimeVariables.Count">
      <summary>Obtiene un recuento de las variables en tiempo de ejecución.</summary>
      <returns>Número de variables en tiempo de ejecución.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.IRuntimeVariables.Item(System.Int32)">
      <summary>Obtiene el valor de la variable en tiempo de ejecución en el índice especificado.</summary>
      <param name="index">Índice de base cero de la variable en tiempo de ejecución cuyo valor se va a devolver.</param>
      <returns>Valor de la variable en tiempo de ejecución.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1">
      <summary>Generador para la colección de solo lectura.</summary>
      <typeparam name="T">Tipo del elemento de colección.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.#ctor">
      <summary>Construye un objeto <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>Crea un elemento <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />; para hacerlo, se copia el contenido de la colección especificada.</summary>
      <param name="collection">Colección de la que se van a copiar elementos.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.#ctor(System.Int32)">
      <summary>Crea un <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> con una capacidad inicial determinada. El contenido está vacío pero el generador habrá reservado sitio para el número dado de elementos antes de que sea necesaria ninguna reasignación.</summary>
      <param name="capacity">Capacidad inicial.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Add(`0)">
      <summary>Agrega un elemento a <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <param name="item">Objeto que se va a agregar a <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Clear">
      <summary>Quita todos los elementos de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Contains(`0)">
      <summary>Determina si <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> contiene un valor específico.</summary>
      <param name="item">Objeto que se va a buscar en <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
      <returns>
        <see langword="true" /> si el elemento se encuentra en la colección <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.CopyTo(`0[],System.Int32)">
      <summary>Copia los elementos de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> a <see cref="T:System.Array" />, empezando en un índice determinado de <see cref="T:System.Array" />.</summary>
      <param name="array">
        <see cref="T:System.Array" /> unidimensional que constituye el destino de los elementos copiados de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
      <param name="arrayIndex">Índice de base cero de la matriz donde comienza la copia.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerator`1" /> que se puede utilizar para ejecutar una iteración en la colección.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.IndexOf(`0)">
      <summary>Devuelve el índice de la primera aparición de un valor dado en el generador.</summary>
      <param name="item">Elemento que se va a buscar.</param>
      <returns>Índice de la primera aparición de un elemento.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Insert(System.Int32,`0)">
      <summary>Inserta un elemento en la interfaz <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />, en el índice especificado.</summary>
      <param name="index">Índice de base cero donde debe insertarse un elemento.</param>
      <param name="item">Objeto que se va a insertar en <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Remove(`0)">
      <summary>Quita la primera aparición de un objeto específico de la interfaz <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <param name="item">Objeto que se va a quitar de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
      <returns>
        <see langword="true" /> si el elemento se ha quitado correctamente de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />; de lo contrario, es false. Este método también devuelve false si el elemento no se encontró en la clase <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> original.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.RemoveAt(System.Int32)">
      <summary>Quita el elemento de la interfaz <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> que se encuentra en el índice especificado.</summary>
      <param name="index">Índice de base cero del elemento que se va a quitar.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Reverse">
      <summary>Invierte el orden de los elementos en la <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> completa.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Reverse(System.Int32,System.Int32)">
      <summary>Invierte el orden de los elementos en el intervalo especificado.</summary>
      <param name="index">Índice inicial de base cero del intervalo que se va a invertir.</param>
      <param name="count">Número de elementos del intervalo que se va a invertir.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <summary>Copia los elementos de la interfaz <see cref="T:System.Collections.Generic.ICollection`1" /> en una matriz, comenzando en el índice especificado de la matriz.</summary>
      <param name="array">Matriz unidimensional que constituye el destino de los elementos copiados desde <see cref="T:System.Collections.Generic.ICollection`1" />. La matriz debe tener una indización de base cero.</param>
      <param name="index">Índice de base cero en la <paramref name="array" /> donde comienza la copia.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
      <returns>
        <see cref="T:System.Collections.IEnumerator" /> que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Add(System.Object)">
      <summary>Agrega un elemento a <see cref="T:System.Collections.IList" />.</summary>
      <param name="value">
        <see cref="T:System.Object" /> que se va a agregar a <see cref="T:System.Collections.IList" />.</param>
      <returns>Posición en la que se insertó el nuevo elemento.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Contains(System.Object)">
      <summary>Determina si <see cref="T:System.Collections.IList" /> contiene un valor específico.</summary>
      <param name="value">Objeto <see cref="T:System.Object" /> que se va a buscar en la interfaz <see cref="T:System.Collections.IList" />.</param>
      <returns>
        <see langword="true" /> si <paramref name="item" /> se encuentra en la matriz <see cref="T:System.Collections.IList" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#IndexOf(System.Object)">
      <summary>Determina el índice de un elemento específico de <see cref="T:System.Collections.IList" />.</summary>
      <param name="value">Objeto que se va a buscar en <see cref="T:System.Collections.IList" />.</param>
      <returns>Devuelve el índice de <paramref name="item" /> si se encuentra en la lista; de lo contrario, devuelve -1.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Insert(System.Int32,System.Object)">
      <summary>Inserta un elemento en la interfaz <see cref="T:System.Collections.IList" />, en el índice especificado.</summary>
      <param name="index">Índice basado en cero en el que debe insertarse <paramref name="item" />.</param>
      <param name="value">Objeto que se va a insertar en <see cref="T:System.Collections.IList" />.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Remove(System.Object)">
      <summary>Quita la primera aparición de un objeto específico de la interfaz <see cref="T:System.Collections.IList" />.</summary>
      <param name="value">Objeto que se va a quitar de <see cref="T:System.Collections.IList" />.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.ToArray">
      <summary>Copia los elementos de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> en una nueva matriz.</summary>
      <returns>Matriz que contiene copias de los elementos de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.ToReadOnlyCollection">
      <summary>Crea una clase <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> que contiene todos los elementos de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />, evitando copiar los elementos a la nueva matriz si es posible. Restablece <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> una vez creado <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</summary>
      <returns>Nueva instancia de <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Capacity">
      <summary>Obtiene o establece la capacidad de un objeto <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <returns>La capacidad de este <c>ReadOnlyCollectionBuilder.</c></returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Count">
      <summary>Obtiene el número de elementos de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <returns>Número de elementos incluidos en <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Item(System.Int32)">
      <summary>Obtiene o establece el elemento en el índice especificado.</summary>
      <param name="index">Índice de base cero del elemento que se va a obtener o establecer.</param>
      <returns>Elemento en el índice especificado.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
      <summary>Obtiene un valor que indica si <see cref="T:System.Collections.Generic.ICollection`1" /> es de solo lectura.</summary>
      <returns>Es <see langword="true" /> si la interfaz <see cref="T:System.Collections.Generic.ICollection`1" /> es de solo lectura; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#ICollection#IsSynchronized">
      <summary>Obtiene un valor que indica si el acceso a la interfaz <see cref="T:System.Collections.ICollection" /> está sincronizado (es seguro para subprocesos).</summary>
      <returns>Es <see langword="true" /> si el acceso a <see cref="T:System.Collections.ICollection" /> está sincronizado (es seguro para subprocesos); de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#ICollection#SyncRoot">
      <summary>Obtiene un objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Collections.ICollection" />.</summary>
      <returns>Un objeto que se puede usar para sincronizar el acceso a la clase <see cref="T:System.Collections.ICollection" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#IsFixedSize">
      <summary>Obtiene un valor que indica si la interfaz <see cref="T:System.Collections.IList" /> tiene un tamaño fijo.</summary>
      <returns>
        <see langword="true" /> si la <see cref="T:System.Collections.IList" /> tiene un tamaño fijo; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#IsReadOnly">
      <summary>Obtiene un valor que indica si <see cref="T:System.Collections.IList" /> es de solo lectura.</summary>
      <returns>Es <see langword="true" /> si la interfaz <see cref="T:System.Collections.IList" /> es de solo lectura; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Item(System.Int32)">
      <summary>Obtiene o establece el elemento en el índice especificado.</summary>
      <param name="index">Índice de base cero del elemento que se va a obtener o establecer.</param>
      <returns>Elemento en el índice especificado.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.RuleCache`1">
      <summary>Representa una memoria caché de reglas de enlace en tiempo de ejecución.</summary>
      <typeparam name="T">Tipo de delegado.</typeparam>
    </member>
  </members>
</doc>