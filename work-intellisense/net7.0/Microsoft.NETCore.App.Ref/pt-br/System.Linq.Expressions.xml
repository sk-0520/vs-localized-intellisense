<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:vsli="https://github.com/sk-0520/vs-localized-intellisense/tree/master/schema/2024">
  <assembly>
    <name>System.Linq.Expressions</name>
  </assembly>
  <members>
    <member name="T:System.Dynamic.BinaryOperationBinder">
      <summary vsli:raw="Represents the binary dynamic operation at the call site, providing the binding semantic and the details about the operation.">Representa a operação dinâmica binária no site de chamada, fornecendo a semântica de associação e os detalhes sobre a operação.</summary>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.#ctor(System.Linq.Expressions.ExpressionType)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.BinaryOperationBinder&quot; /&gt; class.">Inicializa uma nova instância da classe <see cref="T:System.Dynamic.BinaryOperationBinder" />.</summary>
      <param name="operation" vsli:raw="The binary operation kind.">O tipo de operação binária.</param>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic binary operation.">Executa a associação da operação binária dinâmica.</summary>
      <param name="target" vsli:raw="The target of the dynamic operation.">O destino da operação dinâmica.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic operation.">Uma matriz de argumentos da operação dinâmica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.FallbackBinaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the binary dynamic operation if the target dynamic object cannot bind.">Executa a associação da operação binária dinâmica caso o objeto dinâmico de destino não possa ser associado.</summary>
      <param name="target" vsli:raw="The target of the dynamic binary operation.">O destino da operação binária dinâmica.</param>
      <param name="arg" vsli:raw="The right hand side operand of the dynamic binary operation.">O operando do lado direito da operação binária dinâmica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.FallbackBinaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the binary dynamic operation if the target dynamic object cannot bind.">Quando substituído na classe derivada, executa a associação da operação binária dinâmica caso o objeto dinâmico de destino não possa ser associado.</summary>
      <param name="target" vsli:raw="The target of the dynamic binary operation.">O destino da operação binária dinâmica.</param>
      <param name="arg" vsli:raw="The right hand side operand of the dynamic binary operation.">O operando do lado direito da operação binária dinâmica.</param>
      <param name="errorSuggestion" vsli:raw="The binding result if the binding fails, or null.">O resultado da associação caso a associação falhe ou seja nula.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="P:System.Dynamic.BinaryOperationBinder.Operation">
      <summary vsli:raw="The binary operation kind.">O tipo de operação binária.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; object representing the kind of binary operation.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> objeto que representa o tipo de operação binária.</returns>
    </member>
    <member name="P:System.Dynamic.BinaryOperationBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">O tipo de resultado da operação.</summary>
      <returns vsli:raw="The result type of the operation.">O tipo de resultado da operação.</returns>
    </member>
    <member name="T:System.Dynamic.BindingRestrictions">
      <summary vsli:raw="Represents a set of binding restrictions on the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; under which the dynamic binding is valid.">Representa um conjunto de restrições de associação no <see cref="T:System.Dynamic.DynamicMetaObject" /> sob o qual a associação dinâmica é válida.</summary>
    </member>
    <member name="F:System.Dynamic.BindingRestrictions.Empty">
      <summary vsli:raw="Represents an empty set of binding restrictions. This field is read only.">Representa um conjunto vazio de restrições de associação. Este campo é somente leitura.</summary>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.Combine(System.Collections.Generic.IList{System.Dynamic.DynamicMetaObject})">
      <summary vsli:raw="Combines binding restrictions from the list of &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; instances into one set of restrictions.">Combina as restrições de associação da lista de instâncias de <see cref="T:System.Dynamic.DynamicMetaObject" /> em um conjunto de restrições.</summary>
      <param name="contributingObjects" vsli:raw="The list of &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; instances from which to combine restrictions.">A lista de instâncias de <see cref="T:System.Dynamic.DynamicMetaObject" /> das quais as restrições serão combinadas.</param>
      <returns vsli:raw="The new set of binding restrictions.">O novo conjunto de restrições de associação.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetExpressionRestriction(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates the binding restriction that checks the expression for arbitrary immutable properties.">Cria a restrição de associação que verifica a expressão de propriedades imutáveis arbitrárias.</summary>
      <param name="expression" vsli:raw="The expression representing the restrictions.">A expressão que representa as restrições.</param>
      <returns vsli:raw="The new binding restrictions.">As novas restrições de associação.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetInstanceRestriction(System.Linq.Expressions.Expression,System.Object)">
      <summary vsli:raw="Creates the binding restriction that checks the expression for object instance identity.">Cria a restrição de associação que verifica a expressão para a identidade da instância de objeto.</summary>
      <param name="expression" vsli:raw="The expression to test.">A expressão a ser testada.</param>
      <param name="instance" vsli:raw="The exact object instance to test.">A instância de objeto exata a ser testada.</param>
      <returns vsli:raw="The new binding restrictions.">As novas restrições de associação.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetTypeRestriction(System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates the binding restriction that check the expression for runtime type identity.">Cria a restrição de associação que verifica a expressão para a identidade do tipo de runtime.</summary>
      <param name="expression" vsli:raw="The expression to test.">A expressão a ser testada.</param>
      <param name="type" vsli:raw="The exact type to test.">O tipo exato a ser testado.</param>
      <returns vsli:raw="The new binding restrictions.">As novas restrições de associação.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.Merge(System.Dynamic.BindingRestrictions)">
      <summary vsli:raw="Merges the set of binding restrictions with the current binding restrictions.">Mescla o conjunto de restrições de associação com as restrições de associação atuais.</summary>
      <param name="restrictions" vsli:raw="The set of restrictions with which to merge the current binding restrictions.">O conjunto de restrições com o qual mesclar as restrições de associação atuais.</param>
      <returns vsli:raw="The new set of binding restrictions.">O novo conjunto de restrições de associação.</returns>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.ToExpression">
      <summary vsli:raw="Creates the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the binding restrictions.">Cria o <see cref="T:System.Linq.Expressions.Expression" /> que representa as restrições de associação.</summary>
      <returns vsli:raw="The expression tree representing the restrictions.">A árvore de expressão que representa as restrições.</returns>
    </member>
    <member name="T:System.Dynamic.CallInfo">
      <summary vsli:raw="Describes arguments in the dynamic binding process.">Descreve os argumentos do processo de associação dinâmica.</summary>
    </member>
    <member name="M:System.Dynamic.CallInfo.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.String})">
      <summary vsli:raw="Creates a new CallInfo that represents arguments in the dynamic binding process.">Cria um novo CallInfo que representa argumentos do processo de associação dinâmica.</summary>
      <param name="argCount" vsli:raw="The number of arguments.">O número de argumentos.</param>
      <param name="argNames" vsli:raw="The argument names.">Os nomes de argumentos.</param>
    </member>
    <member name="M:System.Dynamic.CallInfo.#ctor(System.Int32,System.String[])">
      <summary vsli:raw="Creates a new &lt;c&gt;PositionalArgumentInfo&lt;/c&gt;.">Cria um novo <c>PositionalArgumentInfo</c>.</summary>
      <param name="argCount" vsli:raw="The number of arguments.">O número de argumentos.</param>
      <param name="argNames" vsli:raw="The argument names.">Os nomes de argumentos.</param>
    </member>
    <member name="M:System.Dynamic.CallInfo.Equals(System.Object)">
      <summary vsli:raw="Determines whether the specified CallInfo instance is considered equal to the current.">Determina se a instância de CallInfo especificada é considerada igual à atual.</summary>
      <param name="obj" vsli:raw="The instance of &lt;see cref=&quot;T:System.Dynamic.CallInfo&quot; /&gt; to compare with the current instance.">A instância de <see cref="T:System.Dynamic.CallInfo" /> a ser comparada à instância atual.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the specified instance is equal to the current one otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a instância especificada for igual à atual; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Dynamic.CallInfo.GetHashCode">
      <summary vsli:raw="Serves as a hash function for the current &lt;see cref=&quot;T:System.Dynamic.CallInfo&quot; /&gt;.">Serve como uma função de hash do <see cref="T:System.Dynamic.CallInfo" /> atual.</summary>
      <returns vsli:raw="A hash code for the current &lt;see cref=&quot;T:System.Dynamic.CallInfo&quot; /&gt;.">Um código hash do <see cref="T:System.Dynamic.CallInfo" /> atual.</returns>
    </member>
    <member name="P:System.Dynamic.CallInfo.ArgumentCount">
      <summary vsli:raw="The number of arguments.">O número de argumentos.</summary>
      <returns vsli:raw="The number of arguments.">O número de argumentos.</returns>
    </member>
    <member name="P:System.Dynamic.CallInfo.ArgumentNames">
      <summary vsli:raw="The argument names.">Os nomes de argumentos.</summary>
      <returns vsli:raw="The read-only collection of argument names.">A coleção somente leitura de nomes de argumentos.</returns>
    </member>
    <member name="T:System.Dynamic.ConvertBinder">
      <summary vsli:raw="Represents the convert dynamic operation at the call site, providing the binding semantic and the details about the operation.">Representa a operação dinâmica de conversão no site de chamada, fornecendo a semântica de associação e os detalhes sobre a operação.</summary>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.#ctor(System.Type,System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.ConvertBinder&quot; /&gt;.">Inicializa uma nova instância do <see cref="T:System.Dynamic.ConvertBinder" />.</summary>
      <param name="type" vsli:raw="The type to convert to.">O tipo para o qual converter.</param>
      <param name="explicit" vsli:raw="Is true if the conversion should consider explicit conversions; otherwise, false.">Será true se a conversão deve considerar conversões explícitas, caso contrário, false.</param>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic convert operation.">Executa a associação da operação de conversão dinâmica.</summary>
      <param name="target" vsli:raw="The target of the dynamic convert operation.">O destino da operação de conversão dinâmica.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic convert operation.">Uma matriz de argumentos da operação de conversão dinâmica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.FallbackConvert(System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic convert operation if the target dynamic object cannot bind.">Executará a associação de uma operação de conversão dinâmica se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target" vsli:raw="The target of the dynamic convert operation.">O destino da operação de conversão dinâmica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.FallbackConvert(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic convert operation if the target dynamic object cannot bind.">Quando substituído na classe derivada, executará a associação de uma operação de conversão dinâmica se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target" vsli:raw="The target of the dynamic convert operation.">O destino da operação de conversão dinâmica.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">O resultado da associação a ser usado se a associação falhar ou nulo.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.Explicit">
      <summary vsli:raw="Gets the value indicating if the conversion should consider explicit conversions.">Obtém o valor que indica se a conversão deve considerar conversões explícitas.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if there is an explicit conversion; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Se houver uma conversão explícita; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">O tipo de resultado da operação.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">O <see cref="T:System.Type" /> objeto que representa o tipo de resultado da operação.</returns>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.Type">
      <summary vsli:raw="The type to convert to.">O tipo para o qual converter.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents the type to convert to.">O <see cref="T:System.Type" /> objeto que representa o tipo para o qual converter.</returns>
    </member>
    <member name="T:System.Dynamic.CreateInstanceBinder">
      <summary vsli:raw="Represents the dynamic create operation at the call site, providing the binding semantic and the details about the operation.">Representa a operação de criação dinâmica no site de chamada, fornecendo a semântica de associação e os detalhes sobre a operação.</summary>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.#ctor(System.Dynamic.CallInfo)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.CreateInstanceBinder&quot; /&gt;.">Inicializa uma nova instância do <see cref="T:System.Dynamic.CreateInstanceBinder" />.</summary>
      <param name="callInfo" vsli:raw="The signature of the arguments at the call site.">A assinatura dos argumentos no site da chamada.</param>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic create operation.">Executa a associação da operação de criação dinâmica.</summary>
      <param name="target" vsli:raw="The target of the dynamic create operation.">O destino da operação de criação dinâmica.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic create operation.">Uma matriz de argumentos da operação de criação dinâmica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.FallbackCreateInstance(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic create operation if the target dynamic object cannot bind.">Executará a associação de uma operação de criação dinâmica se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target" vsli:raw="The target of the dynamic create operation.">O destino da operação de criação dinâmica.</param>
      <param name="args" vsli:raw="The arguments of the dynamic create operation.">Os argumentos da operação de criação dinâmica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.FallbackCreateInstance(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic create operation if the target dynamic object cannot bind.">Quando substituído na classe derivada, executará a associação de uma operação de criação dinâmica se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target" vsli:raw="The target of the dynamic create operation.">O destino da operação de criação dinâmica.</param>
      <param name="args" vsli:raw="The arguments of the dynamic create operation.">Os argumentos da operação de criação dinâmica.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">O resultado da associação a ser usado se a associação falhar ou nulo.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="P:System.Dynamic.CreateInstanceBinder.CallInfo">
      <summary vsli:raw="Gets the signature of the arguments at the call site.">Obtém a assinatura dos argumentos no site da chamada.</summary>
      <returns vsli:raw="The signature of the arguments at the call site.">A assinatura dos argumentos no site da chamada.</returns>
    </member>
    <member name="P:System.Dynamic.CreateInstanceBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">O tipo de resultado da operação.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">O <see cref="T:System.Type" /> objeto que representa o tipo de resultado da operação.</returns>
    </member>
    <member name="T:System.Dynamic.DeleteIndexBinder">
      <summary vsli:raw="Represents the dynamic delete index operation at the call site, providing the binding semantic and the details about the operation.">Representa a operação de índice de exclusão dinâmica no site de chamada, fornecendo a semântica de associação e os detalhes sobre a operação.</summary>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.DeleteIndexBinder&quot; /&gt;.">Inicializa uma nova instância do <see cref="T:System.Dynamic.DeleteIndexBinder" />.</summary>
      <param name="callInfo" vsli:raw="The signature of the arguments at the call site.">A assinatura dos argumentos no site da chamada.</param>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic delete index operation.">Executa a associação da operação dinâmica de exclusão de índice.</summary>
      <param name="target" vsli:raw="The target of the dynamic delete index operation.">O destino da operação dinâmica de exclusão de índice.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic delete index operation.">Uma matriz de argumentos da operação dinâmica de exclusão de índice.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.FallbackDeleteIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic delete index operation if the target dynamic object cannot bind.">Executará a associação de uma operação dinâmica de exclusão de índice se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target" vsli:raw="The target of the dynamic delete index operation.">O destino da operação dinâmica de exclusão de índice.</param>
      <param name="indexes" vsli:raw="The arguments of the dynamic delete index operation.">Os argumentos da operação dinâmica de exclusão de índice.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.FallbackDeleteIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic delete index operation if the target dynamic object cannot bind.">Quando substituído na classe derivada, executará a associação da operação dinâmica de exclusão de índice se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target" vsli:raw="The target of the dynamic delete index operation.">O destino da operação dinâmica de exclusão de índice.</param>
      <param name="indexes" vsli:raw="The arguments of the dynamic delete index operation.">Os argumentos da operação dinâmica de exclusão de índice.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">O resultado da associação a ser usado se a associação falhar ou nulo.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteIndexBinder.CallInfo">
      <summary vsli:raw="Gets the signature of the arguments at the call site.">Obtém a assinatura dos argumentos no site da chamada.</summary>
      <returns vsli:raw="The signature of the arguments at the call site.">A assinatura dos argumentos no site da chamada.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteIndexBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">O tipo de resultado da operação.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">O <see cref="T:System.Type" /> objeto que representa o tipo de resultado da operação.</returns>
    </member>
    <member name="T:System.Dynamic.DeleteMemberBinder">
      <summary vsli:raw="Represents the dynamic delete member operation at the call site, providing the binding semantic and the details about the operation.">Representa a operação de membro de exclusão dinâmica no site de chamada, fornecendo a semântica de associação e os detalhes sobre a operação.</summary>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.#ctor(System.String,System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.DeleteIndexBinder&quot; /&gt;.">Inicializa uma nova instância do <see cref="T:System.Dynamic.DeleteIndexBinder" />.</summary>
      <param name="name" vsli:raw="The name of the member to delete.">O nome do membro a ser excluído.</param>
      <param name="ignoreCase" vsli:raw="Is true if the name should be matched ignoring case; false otherwise.">Será verdadeiro se o nome precisar ser correspondido ignorando maiúsculas e minúsculas; caso contrário, será falso.</param>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic delete member operation.">Executa a associação da operação de membro de exclusão dinâmico.</summary>
      <param name="target" vsli:raw="The target of the dynamic delete member operation.">O destino da operação de exclusão de membro dinâmica.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic delete member operation.">Uma matriz de argumentos da operação de exclusão de membro dinâmica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.FallbackDeleteMember(System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic delete member operation if the target dynamic object cannot bind.">Executará a associação da operação de exclusão de membro dinâmica se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target" vsli:raw="The target of the dynamic delete member operation.">O destino da operação de exclusão de membro dinâmica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.FallbackDeleteMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic delete member operation if the target dynamic object cannot bind.">Quando substituída na classe derivada, executa a associação de uma operação de exclusão de membro dinâmica se o objeto dinâmico de destino não pode ser associado.</summary>
      <param name="target" vsli:raw="The target of the dynamic delete member operation.">O destino da operação de exclusão de membro dinâmica.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">O resultado da associação a ser usado se a associação falhar ou nulo.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.IgnoreCase">
      <summary vsli:raw="Gets the value indicating if the string comparison should ignore the case of the member name.">Obtém o valor que indica se a comparação de cadeias de caracteres deve ignorar as maiúsculas e minúsculas do nome do membro.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the string comparison should ignore case; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a comparação de cadeia de caracteres deve ignorar maiúsculas e minúsculas; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.Name">
      <summary vsli:raw="Gets the name of the member to delete.">Obtém o nome do membro a ser excluído.</summary>
      <returns vsli:raw="The name of the member to delete.">O nome do membro a ser excluído.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">O tipo de resultado da operação.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">O <see cref="T:System.Type" /> objeto que representa o tipo de resultado da operação.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicMetaObject">
      <summary vsli:raw="Represents the dynamic binding and a binding logic of an object participating in the dynamic binding.">Representa a associação dinâmica e uma lógica de associação de um objeto que participa da associação dinâmica.</summary>
    </member>
    <member name="F:System.Dynamic.DynamicMetaObject.EmptyMetaObjects">
      <summary vsli:raw="Represents an empty array of type &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt;. This field is read only.">Representa uma matriz vazia do tipo <see cref="T:System.Dynamic.DynamicMetaObject" />. Este campo é somente leitura.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.#ctor(System.Linq.Expressions.Expression,System.Dynamic.BindingRestrictions)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; class.">Inicializa uma nova instância da classe <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <param name="expression" vsli:raw="The expression representing this &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; during the dynamic binding process.">A expressão que representa este <see cref="T:System.Dynamic.DynamicMetaObject" /> durante o processo de associação dinâmica.</param>
      <param name="restrictions" vsli:raw="The set of binding restrictions under which the binding is valid.">O conjunto de restrições de associação sob o qual a associação é válida.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.#ctor(System.Linq.Expressions.Expression,System.Dynamic.BindingRestrictions,System.Object)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; class.">Inicializa uma nova instância da classe <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <param name="expression" vsli:raw="The expression representing this &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; during the dynamic binding process.">A expressão que representa este <see cref="T:System.Dynamic.DynamicMetaObject" /> durante o processo de associação dinâmica.</param>
      <param name="restrictions" vsli:raw="The set of binding restrictions under which the binding is valid.">O conjunto de restrições de associação sob o qual a associação é válida.</param>
      <param name="value" vsli:raw="The runtime value represented by the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt;.">O valor de runtime representado pelo <see cref="T:System.Dynamic.DynamicMetaObject" />.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic binary operation.">Executa a associação da operação binária dinâmica.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.BinaryOperationBinder&quot; /&gt; that represents the details of the dynamic operation.">Uma instância do <see cref="T:System.Dynamic.BinaryOperationBinder" /> que representa os detalhes da operação dinâmica.</param>
      <param name="arg" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the right hand side of the binary operation.">Uma instância do <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o lado direito da operação binária.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O novo <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindConvert(System.Dynamic.ConvertBinder)">
      <summary vsli:raw="Performs the binding of the dynamic conversion operation.">Executa a associação da operação de conversão dinâmica.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.ConvertBinder&quot; /&gt; that represents the details of the dynamic operation.">Uma instância do <see cref="T:System.Dynamic.ConvertBinder" /> que representa os detalhes da operação dinâmica.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O novo <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindCreateInstance(System.Dynamic.CreateInstanceBinder,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic create instance operation.">Executa a associação da operação da instância de criação dinâmica.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.CreateInstanceBinder&quot; /&gt; that represents the details of the dynamic operation.">Uma instância do <see cref="T:System.Dynamic.CreateInstanceBinder" /> que representa os detalhes da operação dinâmica.</param>
      <param name="args" vsli:raw="An array of &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; instances - arguments to the create instance operation.">Uma matriz de <see cref="T:System.Dynamic.DynamicMetaObject" /> instâncias – argumentos para a operação da instância de criação.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O novo <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic delete index operation.">Executa a associação da operação dinâmica de exclusão de índice.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.DeleteIndexBinder&quot; /&gt; that represents the details of the dynamic operation.">Uma instância do <see cref="T:System.Dynamic.DeleteIndexBinder" /> que representa os detalhes da operação dinâmica.</param>
      <param name="indexes" vsli:raw="An array of &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; instances - indexes for the delete index operation.">Uma matriz de instâncias <see cref="T:System.Dynamic.DynamicMetaObject" /> – índices para a operação de índice de exclusão.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O novo <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindDeleteMember(System.Dynamic.DeleteMemberBinder)">
      <summary vsli:raw="Performs the binding of the dynamic delete member operation.">Executa a associação da operação de membro de exclusão dinâmico.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.DeleteMemberBinder&quot; /&gt; that represents the details of the dynamic operation.">Uma instância do <see cref="T:System.Dynamic.DeleteMemberBinder" /> que representa os detalhes da operação dinâmica.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O novo <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindGetIndex(System.Dynamic.GetIndexBinder,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic get index operation.">Executa a associação da operação dinâmica de obtenção de índice.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.GetIndexBinder&quot; /&gt; that represents the details of the dynamic operation.">Uma instância do <see cref="T:System.Dynamic.GetIndexBinder" /> que representa os detalhes da operação dinâmica.</param>
      <param name="indexes" vsli:raw="An array of &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; instances - indexes for the get index operation.">Uma matriz de instâncias <see cref="T:System.Dynamic.DynamicMetaObject" /> – índices para a operação de índice get.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O novo <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindGetMember(System.Dynamic.GetMemberBinder)">
      <summary vsli:raw="Performs the binding of the dynamic get member operation.">Executa a associação da operação de obtenção de membro dinâmica.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.GetMemberBinder&quot; /&gt; that represents the details of the dynamic operation.">Uma instância do <see cref="T:System.Dynamic.GetMemberBinder" /> que representa os detalhes da operação dinâmica.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O novo <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindInvoke(System.Dynamic.InvokeBinder,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic invoke operation.">Executa a associação da operação de invocação dinâmica.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.InvokeBinder&quot; /&gt; that represents the details of the dynamic operation.">Uma instância do <see cref="T:System.Dynamic.InvokeBinder" /> que representa os detalhes da operação dinâmica.</param>
      <param name="args" vsli:raw="An array of &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; instances - arguments to the invoke operation.">Uma matriz de instâncias <see cref="T:System.Dynamic.DynamicMetaObject" /> – argumentos para a operação de invocação.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O novo <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindInvokeMember(System.Dynamic.InvokeMemberBinder,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic invoke member operation.">Executa a associação da operação de invocação de membro dinâmica.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.InvokeMemberBinder&quot; /&gt; that represents the details of the dynamic operation.">Uma instância do <see cref="T:System.Dynamic.InvokeMemberBinder" /> que representa os detalhes da operação dinâmica.</param>
      <param name="args" vsli:raw="An array of &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; instances - arguments to the invoke member operation.">Uma matriz de instâncias <see cref="T:System.Dynamic.DynamicMetaObject" /> – argumentos para a operação do membro de invocação.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O novo <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindSetIndex(System.Dynamic.SetIndexBinder,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic set index operation.">Executa a associação da operação dinâmica de definição de índice.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.SetIndexBinder&quot; /&gt; that represents the details of the dynamic operation.">Uma instância do <see cref="T:System.Dynamic.SetIndexBinder" /> que representa os detalhes da operação dinâmica.</param>
      <param name="indexes" vsli:raw="An array of &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; instances - indexes for the set index operation.">Uma matriz de instâncias <see cref="T:System.Dynamic.DynamicMetaObject" /> – índices para a operação de índice de definição.</param>
      <param name="value" vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the value for the set index operation.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o valor para a operação de índice de obtenção.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O novo <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindSetMember(System.Dynamic.SetMemberBinder,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic set member operation.">Executa a associação da operação de membro de conjunto dinâmico.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.SetMemberBinder&quot; /&gt; that represents the details of the dynamic operation.">Uma instância do <see cref="T:System.Dynamic.SetMemberBinder" /> que representa os detalhes da operação dinâmica.</param>
      <param name="value" vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the value for the set member operation.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o valor para a operação de membro do conjunto.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O novo <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindUnaryOperation(System.Dynamic.UnaryOperationBinder)">
      <summary vsli:raw="Performs the binding of the dynamic unary operation.">Executa a associação da operação unária dinâmica.</summary>
      <param name="binder" vsli:raw="An instance of the &lt;see cref=&quot;T:System.Dynamic.UnaryOperationBinder&quot; /&gt; that represents the details of the dynamic operation.">Uma instância do <see cref="T:System.Dynamic.UnaryOperationBinder" /> que representa os detalhes da operação dinâmica.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O novo <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.Create(System.Object,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a meta-object for the specified object.">Cria um metaobjeto para o objeto especificado.</summary>
      <param name="value" vsli:raw="The object to get a meta-object for.">O objeto para o qual obter um metaobjeto.</param>
      <param name="expression" vsli:raw="The expression representing this &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; during the dynamic binding process.">A expressão que representa este <see cref="T:System.Dynamic.DynamicMetaObject" /> durante o processo de associação dinâmica.</param>
      <returns vsli:raw="If the given object implements &lt;see cref=&quot;T:System.Dynamic.IDynamicMetaObjectProvider&quot; /&gt; and is not a remote object from outside the current AppDomain, returns the object's specific meta-object returned by &lt;see cref=&quot;M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)&quot; /&gt;. Otherwise a plain new meta-object with no restrictions is created and returned.">Se o objeto fornecido implementa <see cref="T:System.Dynamic.IDynamicMetaObjectProvider" /> e não é um objeto remoto de fora do AppDomain atual, retorna o metaobjeto específico do objeto retornado por <see cref="M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)" />. Caso contrário, um novo metaobjeto simples sem restrições é criado e retornado.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.GetDynamicMemberNames">
      <summary vsli:raw="Returns the enumeration of all dynamic member names.">Retorna a enumeração de todos os nomes de membro dinâmico.</summary>
      <returns vsli:raw="The list of dynamic member names.">A lista de nomes de membro dinâmico.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Expression">
      <summary vsli:raw="The expression representing the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; during the dynamic binding process.">A expressão que representa o <see cref="T:System.Dynamic.DynamicMetaObject" /> durante o processo de associação dinâmica.</summary>
      <returns vsli:raw="The expression representing the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; during the dynamic binding process.">A expressão que representa o <see cref="T:System.Dynamic.DynamicMetaObject" /> durante o processo de associação dinâmica.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.HasValue">
      <summary vsli:raw="Gets a value indicating whether the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; has the runtime value.">Obtém um valor que indica se o <see cref="T:System.Dynamic.DynamicMetaObject" /> tem o valor de runtime.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; has the runtime value; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Se o <see cref="T:System.Dynamic.DynamicMetaObject" /> tiver o valor de tempo de execução; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.LimitType">
      <summary vsli:raw="Gets the limit type of the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt;.">Obtém o tipo de limite do <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <returns vsli:raw="&lt;see cref=&quot;P:System.Dynamic.DynamicMetaObject.RuntimeType&quot; /&gt; if runtime value is available, a type of the &lt;see cref=&quot;P:System.Dynamic.DynamicMetaObject.Expression&quot; /&gt; otherwise.">
        <see cref="P:System.Dynamic.DynamicMetaObject.RuntimeType" /> Se o valor de tempo de execução estiver disponível, um tipo de <see cref="P:System.Dynamic.DynamicMetaObject.Expression" /> caso contrário.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Restrictions">
      <summary vsli:raw="The set of binding restrictions under which the binding is valid.">O conjunto de restrições de associação sob o qual a associação é válida.</summary>
      <returns vsli:raw="The set of binding restrictions.">O conjunto de restrições de associação.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.RuntimeType">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Type&quot; /&gt; of the runtime value or null if the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; has no value associated with it.">Obtém o <see cref="T:System.Type" /> do valor de runtime ou nulo se o <see cref="T:System.Dynamic.DynamicMetaObject" /> não tiver nenhum valor associado a ele.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; of the runtime value or null.">O <see cref="T:System.Type" /> do valor de tempo de execução ou NULL.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Value">
      <summary vsli:raw="The runtime value represented by this &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt;.">O valor de runtime representado por esse <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <returns vsli:raw="The runtime value represented by this &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt;.">O valor de runtime representado por esse <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicMetaObjectBinder">
      <summary vsli:raw="The dynamic call site binder that participates in the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; binding protocol.">Representa o associador de site de chamada dinâmica que participa do protocolo de associação <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObjectBinder&quot; /&gt; class.">Inicializa uma nova instância da classe <see cref="T:System.Dynamic.DynamicMetaObjectBinder" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic operation.">Quando substituído na classe derivada, executa a associação da operação dinâmica.</summary>
      <param name="target" vsli:raw="The target of the dynamic operation.">O destino da operação dinâmica.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic operation.">Uma matriz de argumentos da operação dinâmica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Bind(System.Object[],System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Performs the runtime binding of the dynamic operation on a set of arguments.">Executa a associação em runtime da operação dinâmica em um conjunto de argumentos.</summary>
      <param name="args" vsli:raw="An array of arguments to the dynamic operation.">Uma matriz de argumentos para a operação dinâmica.</param>
      <param name="parameters" vsli:raw="The array of &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; instances that represent the parameters of the call site in the binding process.">A matriz de instâncias de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representam os parâmetros do site de chamada no processo de associação.</param>
      <param name="returnLabel" vsli:raw="A LabelTarget used to return the result of the dynamic binding.">Um LabelTarget usado para retornar o resultado da associação dinâmica.</param>
      <returns vsli:raw="An Expression that performs tests on the dynamic operation arguments, and performs the dynamic operation if the tests are valid. If the tests fail on subsequent occurrences of the dynamic operation, Bind will be called again to produce a new &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; for the new argument types.">Uma expressão que executa testes nos argumentos de operação dinâmica e executa a operação dinâmica se os testes forem válidos. Se os testes falham em ocorrências posteriores da operação dinâmica, Bind será chamado novamente para gerar um novo <see cref="T:System.Linq.Expressions.Expression" /> para os novos tipos de argumento.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Defer(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.">Transfere a associação da operação até um momento posterior quando os valores de runtime de todos os argumentos de operação dinâmica forem computados.</summary>
      <param name="target" vsli:raw="The target of the dynamic operation.">O destino da operação dinâmica.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic operation.">Uma matriz de argumentos da operação dinâmica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Defer(System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.">Transfere a associação da operação até um momento posterior quando os valores de runtime de todos os argumentos de operação dinâmica forem computados.</summary>
      <param name="args" vsli:raw="An array of arguments of the dynamic operation.">Uma matriz de argumentos da operação dinâmica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.GetUpdateExpression(System.Type)">
      <summary vsli:raw="Gets an expression that will cause the binding to be updated. It indicates that the expression's binding is no longer valid. This is typically used when the &quot;version&quot; of a dynamic object has changed.">Obtém uma expressão que fará com que a associação seja atualizada. Indica que a associação da expressão deixou de ser válida. Normalmente, é usado quando a "versão" de um objeto dinâmico foi alterada.</summary>
      <param name="type" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of the resulting expression; any type is allowed.">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> da expressão resultante, qualquer tipo é permitido.</param>
      <returns vsli:raw="The update expression.">A expressão de atualização.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObjectBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">O tipo de resultado da operação.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">O <see cref="T:System.Type" /> objeto que representa o tipo de resultado da operação.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicObject">
      <summary vsli:raw="Provides a base class for specifying dynamic behavior at run time. This class must be inherited from; you cannot instantiate it directly.">Fornece uma classe base para especificar o comportamento dinâmico no tempo de execução. Essa classe deve ser herdada. Não é possível instanciá-la diretamente.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicObject.#ctor">
      <summary vsli:raw="Enables derived types to initialize a new instance of the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; type.">Habilita os tipos derivados para inicializarem uma nova instância do tipo <see cref="T:System.Dynamic.DynamicObject" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicObject.GetDynamicMemberNames">
      <summary vsli:raw="Returns the enumeration of all dynamic member names.">Retorna a enumeração de todos os nomes de membro dinâmico.</summary>
      <returns vsli:raw="A sequence that contains dynamic member names.">Uma sequência que contém os nomes de membro dinâmico.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Provides a &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; that dispatches to the dynamic virtual methods. The object can be encapsulated inside another &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; to provide custom behavior for individual actions. This method supports the Dynamic Language Runtime infrastructure for language implementers and it is not intended to be used directly from your code.">Fornece um <see cref="T:System.Dynamic.DynamicMetaObject" /> que expede para os métodos virtuais dinâmicos. O objeto pode ser encapsulado em outro <see cref="T:System.Dynamic.DynamicMetaObject" /> para fornecer um comportamento personalizado para ações individuais. Esse método dá suporte à infraestrutura do Dynamic Language Runtime para implementadores de linguagem e não se destina a ser usado diretamente do seu código.</summary>
      <param name="parameter" vsli:raw="The expression that represents &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; to dispatch to the dynamic virtual methods.">A expressão que representa o <see cref="T:System.Dynamic.DynamicMetaObject" /> para expedir para os métodos virtuais dinâmicos.</param>
      <returns vsli:raw="An object of the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; type.">Um objeto do tipo <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
      <summary vsli:raw="Provides implementation for binary operations. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for operations such as addition and multiplication.">Fornece implementação para operações binárias. As classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir esse método a fim de especificar o comportamento dinâmico para operações como adição e multiplicação.</summary>
      <param name="binder" vsli:raw="Provides information about the binary operation. The &lt;c&gt;binder.Operation&lt;/c&gt; property returns an &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; object. For example, for the &lt;c&gt;sum = first + second&lt;/c&gt; statement, where &lt;c&gt;first&lt;/c&gt; and &lt;c&gt;second&lt;/c&gt; are derived from the &lt;see langword=&quot;DynamicObject&quot; /&gt; class, &lt;c&gt;binder.Operation&lt;/c&gt; returns &lt;c&gt;ExpressionType.Add&lt;/c&gt;.">Fornece informações sobre a operação binária. A propriedade <c>binder.Operation</c> retorna um objeto <see cref="T:System.Linq.Expressions.ExpressionType" />. Por exemplo, para a instrução <c>sum = first + second</c>, em que <c>first</c> e <c>second</c> são derivados da classe <see langword="DynamicObject" />, <c>binder.Operation</c> retorna <c>ExpressionType.Add</c>.</param>
      <param name="arg" vsli:raw="The right operand for the binary operation. For example, for the &lt;c&gt;sum = first + second&lt;/c&gt; statement, where &lt;c&gt;first&lt;/c&gt; and &lt;c&gt;second&lt;/c&gt; are derived from the &lt;see langword=&quot;DynamicObject&quot; /&gt; class, &lt;paramref name=&quot;arg&quot; /&gt; is equal to &lt;c&gt;second&lt;/c&gt;.">O operando direito da operação binária. Por exemplo, para a instrução <c>sum = first + second</c>, em que <c>first</c> e <c>second</c> são derivados da classe <see langword="DynamicObject" />, <paramref name="arg" /> é igual a <c>second</c>.</param>
      <param name="result" vsli:raw="The result of the binary operation.">O resultado da operação binária.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)">
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
      <summary vsli:raw="Provides implementation for type conversion operations. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for operations that convert an object from one type to another.">Fornece implementação para operações de conversão de tipo. As classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir este método para especificar o comportamento dinâmico para operações que convertem um objeto de um tipo em outro.</summary>
      <param name="binder" vsli:raw="Provides information about the conversion operation. The &lt;c&gt;binder.Type&lt;/c&gt; property provides the type to which the object must be converted. For example, for the statement &lt;c&gt;(String)sampleObject&lt;/c&gt; in C# (&lt;c&gt;CType(sampleObject, Type)&lt;/c&gt; in Visual Basic), where &lt;c&gt;sampleObject&lt;/c&gt; is an instance of the class derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;c&gt;binder.Type&lt;/c&gt; returns the &lt;see cref=&quot;T:System.String&quot; /&gt; type. The &lt;c&gt;binder.Explicit&lt;/c&gt; property provides information about the kind of conversion that occurs. It returns &lt;see langword=&quot;true&quot; /&gt; for explicit conversion and &lt;see langword=&quot;false&quot; /&gt; for implicit conversion.">Fornece informações sobre a operação de conversão. A propriedade <c>binder.Type</c> fornece o tipo para o qual o objeto deve ser convertido. Por exemplo, a instrução <c>(String)sampleObject</c> em C# (<c>CType(sampleObject, Type)</c> em Visual Basic), em que <c>sampleObject</c> é uma instância da classe derivada da classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Type</c> retorna o tipo <see cref="T:System.String" />. A propriedade <c>binder.Explicit</c> fornece informações sobre o tipo de conversão que ocorre. Ela retorna <see langword="true" /> para conversão explícita e <see langword="false" /> para conversão implícita.</param>
      <param name="result" vsli:raw="The result of the type conversion operation.">O resultado da operação de conversão de tipo.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)">
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
      <summary vsli:raw="Provides the implementation for operations that initialize a new instance of a dynamic object. This method is not intended for use in C# or Visual Basic.">Fornece a implementação para operações que inicializam uma nova instância de um objeto dinâmico. Esse método não se destina ao uso em C# ou Visual Basic.</summary>
      <param name="binder" vsli:raw="Provides information about the initialization operation.">Fornece informações sobre a operação de inicialização.</param>
      <param name="args" vsli:raw="The arguments that are passed to the object during initialization. For example, for the &lt;c&gt;new SampleType(100)&lt;/c&gt; operation, where &lt;c&gt;SampleType&lt;/c&gt; is the type derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;c&gt;args[0]&lt;/c&gt; is equal to 100.">Os argumentos que são passados ao objeto durante inicialização. Por exemplo, para a operação <c>new SampleType(100)</c>, em que <c>SampleType</c> é o tipo derivado da classe <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> é igual a 100.</param>
      <param name="result" vsli:raw="The result of the initialization.">O resultado da inicialização.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)">
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
      <summary vsli:raw="Provides the implementation for operations that delete an object by index. This method is not intended for use in C# or Visual Basic.">Fornece a implementação para operações que excluem um objeto pelo índice. Esse método não se destina ao uso em C# ou Visual Basic.</summary>
      <param name="binder" vsli:raw="Provides information about the deletion.">Fornece informações sobre a exclusão.</param>
      <param name="indexes" vsli:raw="The indexes to be deleted.">Os índices a serem excluídos.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)">
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
      <summary vsli:raw="Provides the implementation for operations that delete an object member. This method is not intended for use in C# or Visual Basic.">Fornece a implementação para operações que excluem um membro de objeto. Esse método não se destina ao uso em C# ou Visual Basic.</summary>
      <param name="binder" vsli:raw="Provides information about the deletion.">Fornece informações sobre a exclusão.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)">
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
      <summary vsli:raw="Provides the implementation for operations that get a value by index. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for indexing operations.">Fornece a implementação para operações que obtêm um valor por índice. As classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir esse método para especificar o comportamento dinâmico das operações de indexação.</summary>
      <param name="binder" vsli:raw="Provides information about the operation.">Fornece informações sobre a operação.</param>
      <param name="indexes" vsli:raw="The indexes that are used in the operation. For example, for the &lt;c&gt;sampleObject[3]&lt;/c&gt; operation in C# (&lt;c&gt;sampleObject(3)&lt;/c&gt; in Visual Basic), where &lt;c&gt;sampleObject&lt;/c&gt; is derived from the &lt;see langword=&quot;DynamicObject&quot; /&gt; class, &lt;c&gt;indexes[0]&lt;/c&gt; is equal to 3.">Os índices usados na operação. Por exemplo, para a operação <c>sampleObject[3]</c> em C# (<c>sampleObject(3)</c> em Visual Basic), em que <c>sampleObject</c> é derivado da classe <see langword="DynamicObject" />, <c>indexes[0]</c> é igual a 3.</param>
      <param name="result" vsli:raw="The result of the index operation.">O resultado da operação de índice.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a run-time exception is thrown.)">
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução é gerada.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
      <summary vsli:raw="Provides the implementation for operations that get member values. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for operations such as getting a value for a property.">Fornece a implementação para operações que obtêm valores de membro. As classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir este método para especificar o comportamento dinâmico para operações como obtenção de um valor para uma propriedade.</summary>
      <param name="binder" vsli:raw="Provides information about the object that called the dynamic operation. The &lt;c&gt;binder.Name&lt;/c&gt; property provides the name of the member on which the dynamic operation is performed. For example, for the &lt;c&gt;Console.WriteLine(sampleObject.SampleProperty)&lt;/c&gt; statement, where &lt;c&gt;sampleObject&lt;/c&gt; is an instance of the class derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;c&gt;binder.Name&lt;/c&gt; returns &quot;SampleProperty&quot;. The &lt;c&gt;binder.IgnoreCase&lt;/c&gt; property specifies whether the member name is case-sensitive.">Fornece informações sobre o objeto que chamou a operação dinâmica. A propriedade <c>binder.Name</c> fornece o nome do membro no qual a operação dinâmica é executada. Por exemplo, para a instrução <c>Console.WriteLine(sampleObject.SampleProperty)</c>, em que <c>sampleObject</c> é uma instância da classe derivada da classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> retorna "SampleProperty". A propriedade <c>binder.IgnoreCase</c> especifica se o nome do membro diferencia maiúsculas de minúsculas.</param>
      <param name="result" vsli:raw="The result of the get operation. For example, if the method is called for a property, you can assign the property value to &lt;paramref name=&quot;result&quot; /&gt;.">O resultado da operação get. Por exemplo, se o método é chamado para uma propriedade, atribua <paramref name="result" /> para o valor da propriedade.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a run-time exception is thrown.)">
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução é gerada.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
      <summary vsli:raw="Provides the implementation for operations that invoke an object. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for operations such as invoking an object or a delegate.">Fornece a implementação para operações que invocam um objeto. Classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir este método para especificar o comportamento dinâmico para operações como invocar um objeto ou um delegado.</summary>
      <param name="binder" vsli:raw="Provides information about the invoke operation.">Fornece informações sobre a operação de invocação.</param>
      <param name="args" vsli:raw="The arguments that are passed to the object during the invoke operation. For example, for the &lt;c&gt;sampleObject(100)&lt;/c&gt; operation, where &lt;c&gt;sampleObject&lt;/c&gt; is derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;c&gt;args[0]&lt;/c&gt; is equal to 100.">Os argumentos que são passados ao objeto durante a operação de invocação. Por exemplo, para a operação <c>sampleObject(100)</c>, em que <c>sampleObject</c> é derivado da classe <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> é igual a 100.</param>
      <param name="result" vsli:raw="The result of the object invocation.">O resultado da invocação do objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.">
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
      <summary vsli:raw="Provides the implementation for operations that invoke a member. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for operations such as calling a method.">Fornece a implementação para operações que invocam um membro. As classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir esse método a fim de especificar o comportamento dinâmico para operações como chamar um método.</summary>
      <param name="binder" vsli:raw="Provides information about the dynamic operation. The &lt;c&gt;binder.Name&lt;/c&gt; property provides the name of the member on which the dynamic operation is performed. For example, for the statement &lt;c&gt;sampleObject.SampleMethod(100)&lt;/c&gt;, where &lt;c&gt;sampleObject&lt;/c&gt; is an instance of the class derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;c&gt;binder.Name&lt;/c&gt; returns &quot;SampleMethod&quot;. The &lt;c&gt;binder.IgnoreCase&lt;/c&gt; property specifies whether the member name is case-sensitive.">Fornece informações sobre a operação dinâmica. A propriedade <c>binder.Name</c> fornece o nome do membro no qual a operação dinâmica é executada. Por exemplo, para a instrução <c>sampleObject.SampleMethod(100)</c>, em que <c>sampleObject</c> é uma instância da classe derivada da classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> retorna "SampleMethod". A propriedade <c>binder.IgnoreCase</c> especifica se o nome do membro diferencia maiúsculas de minúsculas.</param>
      <param name="args" vsli:raw="The arguments that are passed to the object member during the invoke operation. For example, for the statement &lt;c&gt;sampleObject.SampleMethod(100)&lt;/c&gt;, where &lt;c&gt;sampleObject&lt;/c&gt; is derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;c&gt;args[0]&lt;/c&gt; is equal to 100.">Os argumentos passados ao membro do objeto durante a operação de invocação. Por exemplo, para a instrução <c>sampleObject.SampleMethod(100)</c>, em que <c>sampleObject</c> é derivado da classe <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> é igual a 100.</param>
      <param name="result" vsli:raw="The result of the member invocation.">O resultado da invocação do membro.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)">
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
      <summary vsli:raw="Provides the implementation for operations that set a value by index. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for operations that access objects by a specified index.">Fornece a implementação para operações que definem um valor por índice. As classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir este método para especificar o comportamento dinâmico para operações que acessam os objetos por um índice especificado.</summary>
      <param name="binder" vsli:raw="Provides information about the operation.">Fornece informações sobre a operação.</param>
      <param name="indexes" vsli:raw="The indexes that are used in the operation. For example, for the &lt;c&gt;sampleObject[3] = 10&lt;/c&gt; operation in C# (&lt;c&gt;sampleObject(3) = 10&lt;/c&gt; in Visual Basic), where &lt;c&gt;sampleObject&lt;/c&gt; is derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;c&gt;indexes[0]&lt;/c&gt; is equal to 3.">Os índices usados na operação. Por exemplo, para a operação <c>sampleObject[3] = 10</c> em C# (<c>sampleObject(3) = 10</c> em Visual Basic), em que <c>sampleObject</c> é derivado da classe <see cref="T:System.Dynamic.DynamicObject" />, <c>indexes[0]</c> é igual a 3.</param>
      <param name="value" vsli:raw="The value to set to the object that has the specified index. For example, for the &lt;c&gt;sampleObject[3] = 10&lt;/c&gt; operation in C# (&lt;c&gt;sampleObject(3) = 10&lt;/c&gt; in Visual Basic), where &lt;c&gt;sampleObject&lt;/c&gt; is derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;paramref name=&quot;value&quot; /&gt; is equal to 10.">O valor a ser definido para o objeto que tem o índice especificado. Por exemplo, para a operação <c>sampleObject[3] = 10</c> em C# (<c>sampleObject(3) = 10</c> em Visual Basic), em que <c>sampleObject</c> é derivado da classe <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="value" /> é igual a 10.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.">
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
      <summary vsli:raw="Provides the implementation for operations that set member values. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for operations such as setting a value for a property.">Fornece a implementação para operações que definem valores de membro. As classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir este método para especificar o comportamento dinâmico para operações como definição de um valor para uma propriedade.</summary>
      <param name="binder" vsli:raw="Provides information about the object that called the dynamic operation. The &lt;c&gt;binder.Name&lt;/c&gt; property provides the name of the member to which the value is being assigned. For example, for the statement &lt;c&gt;sampleObject.SampleProperty = &quot;Test&quot;&lt;/c&gt;, where &lt;c&gt;sampleObject&lt;/c&gt; is an instance of the class derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, &lt;c&gt;binder.Name&lt;/c&gt; returns &quot;SampleProperty&quot;. The &lt;c&gt;binder.IgnoreCase&lt;/c&gt; property specifies whether the member name is case-sensitive.">Fornece informações sobre o objeto que chamou a operação dinâmica. A propriedade <c>binder.Name</c> fornece o nome do membro ao qual o valor está sendo atribuído. Por exemplo, para a instrução <c>sampleObject.SampleProperty = "Test"</c>, em que <c>sampleObject</c> é a instância da classe derivada da classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> retorna "SampleProperty". A propriedade <c>binder.IgnoreCase</c> especifica se o nome do membro diferencia maiúsculas de minúsculas.</param>
      <param name="value" vsli:raw="The value to set to the member. For example, for &lt;c&gt;sampleObject.SampleProperty = &quot;Test&quot;&lt;/c&gt;, where &lt;c&gt;sampleObject&lt;/c&gt; is an instance of the class derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class, the &lt;paramref name=&quot;value&quot; /&gt; is &quot;Test&quot;.">O valor a ser definido para o membro. Por exemplo, para <c>sampleObject.SampleProperty = "Test"</c>, em que <c>sampleObject</c> é a instância da classe derivada da classe <see cref="T:System.Dynamic.DynamicObject" />, o <paramref name="value" /> é "Test".</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)">
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
      <summary vsli:raw="Provides implementation for unary operations. Classes derived from the &lt;see cref=&quot;T:System.Dynamic.DynamicObject&quot; /&gt; class can override this method to specify dynamic behavior for operations such as negation, increment, or decrement.">Fornece implementação para operações unárias. As classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir este método para especificar o comportamento dinâmico para operações como uma negação, incremento ou decremento.</summary>
      <param name="binder" vsli:raw="Provides information about the unary operation. The &lt;c&gt;binder.Operation&lt;/c&gt; property returns an &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; object. For example, for the &lt;c&gt;negativeNumber = -number&lt;/c&gt; statement, where &lt;c&gt;number&lt;/c&gt; is derived from the &lt;see langword=&quot;DynamicObject&quot; /&gt; class, &lt;c&gt;binder.Operation&lt;/c&gt; returns &quot;Negate&quot;.">Fornece informações sobre a operação unária. A propriedade <c>binder.Operation</c> retorna um objeto <see cref="T:System.Linq.Expressions.ExpressionType" />. Por exemplo, para a instrução <c>negativeNumber = -number</c>, em que <c>number</c> é derivado da classe <see langword="DynamicObject" />, <c>binder.Operation</c> retorna "Negate".</param>
      <param name="result" vsli:raw="The result of the unary operation.">O resultado da operação unária.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation is successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If this method returns &lt;see langword=&quot;false&quot; /&gt;, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)">
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)</returns>
    </member>
    <member name="T:System.Dynamic.ExpandoObject">
      <summary vsli:raw="Represents an object whose members can be dynamically added and removed at run time.">Representa um objeto cujos membros podem ser adicionados e removidos no tempo de execução dinamicamente.</summary>
    </member>
    <member name="E:System.Dynamic.ExpandoObject.System#ComponentModel#INotifyPropertyChanged#PropertyChanged">
      <summary vsli:raw="Occurs when a property value changes.">Ocorre quando um valor de propriedade é alterado.</summary>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.#ctor">
      <summary vsli:raw="Initializes a new &lt;see langword=&quot;ExpandoObject&quot; /&gt; that does not have members.">Inicializa um novo <see langword="ExpandoObject" /> que não tem membros.</summary>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; that can be used to iterate through the collection.">Um <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Dynamic#IDynamicMetaObjectProvider#GetMetaObject(System.Linq.Expressions.Expression)">
      <summary vsli:raw="The provided MetaObject will dispatch to the dynamic virtual methods. The object can be encapsulated inside another MetaObject to provide custom behavior for individual actions.">O MetaObject fornecido expedirá para os métodos virtuais dinâmicos. O objeto pode ser encapsulado em outro MetaObject para fornecer um comportamento personalizado para ações individuais.</summary>
      <param name="parameter" vsli:raw="The expression that represents the MetaObject to dispatch to the Dynamic virtual methods.">A expressão que representa o MetaObject para expedir para os métodos virtuais dinâmicos.</param>
      <returns vsli:raw="The object of the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; type.">O objeto do tipo <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
    </member>
    <member name="T:System.Dynamic.GetIndexBinder">
      <summary vsli:raw="Represents the dynamic get index operation at the call site, providing the binding semantic and the details about the operation.">Representa a operação de índice de obtenção dinâmica no site de chamada, fornecendo a semântica de associação e os detalhes sobre a operação.</summary>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.GetIndexBinder&quot; /&gt;.">Inicializa uma nova instância do <see cref="T:System.Dynamic.GetIndexBinder" />.</summary>
      <param name="callInfo" vsli:raw="The signature of the arguments at the call site.">A assinatura dos argumentos no site da chamada.</param>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic get index operation.">Executa a associação da operação dinâmica de obtenção de índice.</summary>
      <param name="target" vsli:raw="The target of the dynamic get index operation.">O destino da operação dinâmica de obtenção de índice.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic get index operation.">Uma matriz de argumentos da operação dinâmica de obtenção de índice.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.FallbackGetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic get index operation if the target dynamic object cannot bind.">Executará a associação de uma operação dinâmica de obtenção de índice se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target" vsli:raw="The target of the dynamic get index operation.">O destino da operação dinâmica de obtenção de índice.</param>
      <param name="indexes" vsli:raw="The arguments of the dynamic get index operation.">Os argumentos da operação dinâmica de obtenção de índice.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.FallbackGetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic get index operation if the target dynamic object cannot bind.">Quando substituída na classe derivada, executará a associação da operação dinâmica de obtenção de índice se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target" vsli:raw="The target of the dynamic get index operation.">O destino da operação dinâmica de obtenção de índice.</param>
      <param name="indexes" vsli:raw="The arguments of the dynamic get index operation.">Os argumentos da operação dinâmica de obtenção de índice.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">O resultado da associação a ser usado se a associação falhar ou nulo.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="P:System.Dynamic.GetIndexBinder.CallInfo">
      <summary vsli:raw="Gets the signature of the arguments at the call site.">Obtém a assinatura dos argumentos no site da chamada.</summary>
      <returns vsli:raw="The signature of the arguments at the call site.">A assinatura dos argumentos no site da chamada.</returns>
    </member>
    <member name="P:System.Dynamic.GetIndexBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">O tipo de resultado da operação.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">O <see cref="T:System.Type" /> objeto que representa o tipo de resultado da operação.</returns>
    </member>
    <member name="T:System.Dynamic.GetMemberBinder">
      <summary vsli:raw="Represents the dynamic get member operation at the call site, providing the binding semantic and the details about the operation.">Representa a operação de membro de obtenção dinâmica no site de chamada, fornecendo a semântica de associação e os detalhes sobre a operação.</summary>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.#ctor(System.String,System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.GetMemberBinder&quot; /&gt;.">Inicializa uma nova instância do <see cref="T:System.Dynamic.GetMemberBinder" />.</summary>
      <param name="name" vsli:raw="The name of the member to obtain.">O nome do membro a ser obtido.</param>
      <param name="ignoreCase" vsli:raw="Is true if the name should be matched ignoring case; false otherwise.">Será verdadeiro se o nome precisar ser correspondido ignorando maiúsculas e minúsculas; caso contrário, será falso.</param>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic get member operation.">Executa a associação da operação de obtenção de membro dinâmica.</summary>
      <param name="target" vsli:raw="The target of the dynamic get member operation.">O destino da operação de obtenção de membro dinâmica.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic get member operation.">Uma matriz de argumentos da operação de obtenção de membro dinâmica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.FallbackGetMember(System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic get member operation if the target dynamic object cannot bind.">Executará a associação da operação de obtenção de membro dinâmica se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target" vsli:raw="The target of the dynamic get member operation.">O destino da operação de obtenção de membro dinâmica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.FallbackGetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic get member operation if the target dynamic object cannot bind.">Quando substituída na classe derivada, executa a associação de uma operação de obtenção de membro dinâmica se o objeto dinâmico de destino não pode ser associado.</summary>
      <param name="target" vsli:raw="The target of the dynamic get member operation.">O destino da operação de obtenção de membro dinâmica.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">O resultado da associação a ser usado se a associação falhar ou nulo.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.IgnoreCase">
      <summary vsli:raw="Gets the value indicating if the string comparison should ignore the case of the member name.">Obtém o valor que indica se a comparação de cadeias de caracteres deve ignorar as maiúsculas e minúsculas do nome do membro.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if case is ignored; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Se o caso for ignorado; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.Name">
      <summary vsli:raw="Gets the name of the member to obtain.">Obtém o nome do membro a ser obtido.</summary>
      <returns vsli:raw="The name of the member to obtain.">O nome do membro a ser obtido.</returns>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">O tipo de resultado da operação.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">O <see cref="T:System.Type" /> objeto que representa o tipo de resultado da operação.</returns>
    </member>
    <member name="T:System.Dynamic.IDynamicMetaObjectProvider">
      <summary vsli:raw="Represents a dynamic object, that can have its operations bound at runtime.">Representa um objeto dinâmico, que pode ter suas operações associadas no runtime.</summary>
    </member>
    <member name="M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Returns the &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; responsible for binding operations performed on this object.">Retorna o <see cref="T:System.Dynamic.DynamicMetaObject" /> responsável pelas operações de associação executadas neste objeto.</summary>
      <param name="parameter" vsli:raw="The expression tree representation of the runtime value.">A representação em árvore de expressão do valor do runtime.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; to bind this object.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> para associar a este objeto.</returns>
    </member>
    <member name="T:System.Dynamic.IInvokeOnGetBinder">
      <summary vsli:raw="Represents information about a dynamic get member operation that indicates if the get member should invoke properties when they perform the get operation.">Representa informações sobre uma operação de membro de obtenção dinâmico que indica se o membro de get deve invocar propriedades ao executar a operação get.</summary>
    </member>
    <member name="P:System.Dynamic.IInvokeOnGetBinder.InvokeOnGet">
      <summary vsli:raw="Gets the value indicating if this get member operation should invoke properties when they perform the get operation. The default value when this interface is not present is true.">Obtém o valor que indica se essa operação de obtenção de membro deve invocar propriedades ao executar a operação get. O valor padrão quando essa interface não está presente é true.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if this get member operation should invoke properties when they perform the get operation; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Se essa operação get member deve invocar Propriedades quando executam a operação get; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="T:System.Dynamic.InvokeBinder">
      <summary vsli:raw="Represents the invoke dynamic operation at the call site, providing the binding semantic and the details about the operation.">Representa a operação dinâmica de invocação no site de chamada, fornecendo a semântica de associação e os detalhes sobre a operação.</summary>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.#ctor(System.Dynamic.CallInfo)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.InvokeBinder&quot; /&gt;.">Inicializa uma nova instância do <see cref="T:System.Dynamic.InvokeBinder" />.</summary>
      <param name="callInfo" vsli:raw="The signature of the arguments at the call site.">A assinatura dos argumentos no site da chamada.</param>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic invoke operation.">Executa a associação da operação de invocação dinâmica.</summary>
      <param name="target" vsli:raw="The target of the dynamic invoke operation.">O destino da operação de invocação dinâmica.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic invoke operation.">Uma matriz de argumentos da operação de invocação dinâmica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic invoke operation if the target dynamic object cannot bind.">Executará a associação de uma operação de invocação dinâmica se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target" vsli:raw="The target of the dynamic invoke operation.">O destino da operação de invocação dinâmica.</param>
      <param name="args" vsli:raw="The arguments of the dynamic invoke operation.">Os argumentos da operação de invocação dinâmica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic invoke operation if the target dynamic object cannot bind.">Executará a associação de uma operação de invocação dinâmica se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target" vsli:raw="The target of the dynamic invoke operation.">O destino da operação de invocação dinâmica.</param>
      <param name="args" vsli:raw="The arguments of the dynamic invoke operation.">Os argumentos da operação de invocação dinâmica.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">O resultado da associação a ser usado se a associação falhar ou nulo.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeBinder.CallInfo">
      <summary vsli:raw="Gets the signature of the arguments at the call site.">Obtém a assinatura dos argumentos no site da chamada.</summary>
      <returns vsli:raw="The signature of the arguments at the call site.">A assinatura dos argumentos no site da chamada.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">O tipo de resultado da operação.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">O <see cref="T:System.Type" /> objeto que representa o tipo de resultado da operação.</returns>
    </member>
    <member name="T:System.Dynamic.InvokeMemberBinder">
      <summary vsli:raw="Represents the invoke member dynamic operation at the call site, providing the binding semantic and the details about the operation.">Representa a operação dinâmica de membro de invocação no site de chamada, fornecendo a semântica de associação e os detalhes sobre a operação.</summary>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.#ctor(System.String,System.Boolean,System.Dynamic.CallInfo)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.InvokeMemberBinder&quot; /&gt;.">Inicializa uma nova instância do <see cref="T:System.Dynamic.InvokeMemberBinder" />.</summary>
      <param name="name" vsli:raw="The name of the member to invoke.">O nome do membro a ser invocado.</param>
      <param name="ignoreCase" vsli:raw="true if the name should be matched ignoring case; false otherwise.">true se o nome precisar ser correspondido ignorando maiúsculas e minúsculas; caso contrário, false.</param>
      <param name="callInfo" vsli:raw="The signature of the arguments at the call site.">A assinatura dos argumentos no site da chamada.</param>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic invoke member operation.">Executa a associação da operação de invocação de membro dinâmica.</summary>
      <param name="target" vsli:raw="The target of the dynamic invoke member operation.">O destino da operação de invocação de membro dinâmica.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic invoke member operation.">Uma matriz de argumentos da operação de invocação de membro dinâmica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic invoke operation if the target dynamic object cannot bind.">Quando substituída na classe derivada, executa a associação de uma operação de invocação dinâmica se o objeto dinâmico de destino não pode ser associado.</summary>
      <param name="target" vsli:raw="The target of the dynamic invoke operation.">O destino da operação de invocação dinâmica.</param>
      <param name="args" vsli:raw="The arguments of the dynamic invoke operation.">Os argumentos da operação de invocação dinâmica.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">O resultado da associação a ser usado se a associação falhar ou nulo.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvokeMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic invoke member operation if the target dynamic object cannot bind.">Executará a associação da operação de invocação de membro dinâmica se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target" vsli:raw="The target of the dynamic invoke member operation.">O destino da operação de invocação de membro dinâmica.</param>
      <param name="args" vsli:raw="The arguments of the dynamic invoke member operation.">Os argumentos da operação de invocação de membro dinâmica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvokeMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic invoke member operation if the target dynamic object cannot bind.">Quando substituída na classe derivada, executa a associação de uma operação de invocação de membro dinâmica se o objeto dinâmico de destino não pode ser associado.</summary>
      <param name="target" vsli:raw="The target of the dynamic invoke member operation.">O destino da operação de invocação de membro dinâmica.</param>
      <param name="args" vsli:raw="The arguments of the dynamic invoke member operation.">Os argumentos da operação de invocação de membro dinâmica.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">O resultado da associação a ser usado se a associação falhar ou nulo.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.CallInfo">
      <summary vsli:raw="Gets the signature of the arguments at the call site.">Obtém a assinatura dos argumentos no site da chamada.</summary>
      <returns vsli:raw="The signature of the arguments at the call site.">A assinatura dos argumentos no site da chamada.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.IgnoreCase">
      <summary vsli:raw="Gets the value indicating if the string comparison should ignore the case of the member name.">Obtém o valor que indica se a comparação de cadeias de caracteres deve ignorar as maiúsculas e minúsculas do nome do membro.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if case is ignored; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Se o caso for ignorado; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.Name">
      <summary vsli:raw="Gets the name of the member to invoke.">Obtém o nome do membro a ser invocado.</summary>
      <returns vsli:raw="The name of the member to invoke.">O nome do membro a ser invocado.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">O tipo de resultado da operação.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">O <see cref="T:System.Type" /> objeto que representa o tipo de resultado da operação.</returns>
    </member>
    <member name="T:System.Dynamic.SetIndexBinder">
      <summary vsli:raw="Represents the dynamic set index operation at the call site, providing the binding semantic and the details about the operation.">Representa a operação de índice de definição dinâmica no site de chamada, fornecendo a semântica de associação e os detalhes sobre a operação.</summary>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.SetIndexBinder&quot; /&gt;.">Inicializa uma nova instância do <see cref="T:System.Dynamic.SetIndexBinder" />.</summary>
      <param name="callInfo" vsli:raw="The signature of the arguments at the call site.">A assinatura dos argumentos no site da chamada.</param>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic set index operation.">Executa a associação da operação dinâmica de definição de índice.</summary>
      <param name="target" vsli:raw="The target of the dynamic set index operation.">O destino da operação dinâmica de definição de índice.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic set index operation.">Uma matriz de argumentos da operação dinâmica de definição de índice.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.FallbackSetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic set index operation if the target dynamic object cannot bind.">Executará a associação de uma operação dinâmica de definição de índice se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target" vsli:raw="The target of the dynamic set index operation.">O destino da operação dinâmica de definição de índice.</param>
      <param name="indexes" vsli:raw="The arguments of the dynamic set index operation.">Os argumentos da operação dinâmica de definição de índice.</param>
      <param name="value" vsli:raw="The value to set to the collection.">O valor a ser definido para a coleção.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.FallbackSetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="When overridden in the derived class, performs the binding of the dynamic set index operation if the target dynamic object cannot bind.">Quando substituído na classe derivada, executará a associação da operação dinâmica de definição de índice se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target" vsli:raw="The target of the dynamic set index operation.">O destino da operação dinâmica de definição de índice.</param>
      <param name="indexes" vsli:raw="The arguments of the dynamic set index operation.">Os argumentos da operação dinâmica de definição de índice.</param>
      <param name="value" vsli:raw="The value to set to the collection.">O valor a ser definido para a coleção.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">O resultado da associação a ser usado se a associação falhar ou nulo.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="P:System.Dynamic.SetIndexBinder.CallInfo">
      <summary vsli:raw="Gets the signature of the arguments at the call site.">Obtém a assinatura dos argumentos no site da chamada.</summary>
      <returns vsli:raw="The signature of the arguments at the call site.">A assinatura dos argumentos no site da chamada.</returns>
    </member>
    <member name="P:System.Dynamic.SetIndexBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">O tipo de resultado da operação.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">O <see cref="T:System.Type" /> objeto que representa o tipo de resultado da operação.</returns>
    </member>
    <member name="T:System.Dynamic.SetMemberBinder">
      <summary vsli:raw="Represents the dynamic set member operation at the call site, providing the binding semantic and the details about the operation.">Representa a operação de membro de definição dinâmica no site de chamada, fornecendo a semântica de associação e os detalhes sobre a operação.</summary>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.#ctor(System.String,System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.SetMemberBinder&quot; /&gt;.">Inicializa uma nova instância do <see cref="T:System.Dynamic.SetMemberBinder" />.</summary>
      <param name="name" vsli:raw="The name of the member to obtain.">O nome do membro a ser obtido.</param>
      <param name="ignoreCase" vsli:raw="Is true if the name should be matched ignoring case; false otherwise.">Será verdadeiro se o nome precisar ser correspondido ignorando maiúsculas e minúsculas; caso contrário, será falso.</param>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic set member operation.">Executa a associação da operação de membro de conjunto dinâmico.</summary>
      <param name="target" vsli:raw="The target of the dynamic set member operation.">O destino da operação dinâmica de definição de membro.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic set member operation.">Uma matriz de argumentos da operação dinâmica de definição de membro.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.FallbackSetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic set member operation if the target dynamic object cannot bind.">Executará a associação da operação dinâmica de definição de membro se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target" vsli:raw="The target of the dynamic set member operation.">O destino da operação dinâmica de definição de membro.</param>
      <param name="value" vsli:raw="The value to set to the member.">O valor a ser definido para o membro.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.FallbackSetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the dynamic set member operation if the target dynamic object cannot bind.">Executará a associação da operação dinâmica de definição de membro se o objeto dinâmico de destino não puder ser associado.</summary>
      <param name="target" vsli:raw="The target of the dynamic set member operation.">O destino da operação dinâmica de definição de membro.</param>
      <param name="value" vsli:raw="The value to set to the member.">O valor a ser definido para o membro.</param>
      <param name="errorSuggestion" vsli:raw="The binding result to use if binding fails, or null.">O resultado da associação a ser usado se a associação falhar ou nulo.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.IgnoreCase">
      <summary vsli:raw="Gets the value indicating if the string comparison should ignore the case of the member name.">Obtém o valor que indica se a comparação de cadeias de caracteres deve ignorar as maiúsculas e minúsculas do nome do membro.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if case is ignored; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Se o caso for ignorado; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.Name">
      <summary vsli:raw="Gets the name of the member to obtain.">Obtém o nome do membro a ser obtido.</summary>
      <returns vsli:raw="The name of the member to obtain.">O nome do membro a ser obtido.</returns>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">O tipo de resultado da operação.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">O <see cref="T:System.Type" /> objeto que representa o tipo de resultado da operação.</returns>
    </member>
    <member name="T:System.Dynamic.UnaryOperationBinder">
      <summary vsli:raw="Represents the unary dynamic operation at the call site, providing the binding semantic and the details about the operation.">Representa a operação dinâmica unária no site de chamada, fornecendo a semântica de associação e os detalhes sobre a operação.</summary>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.#ctor(System.Linq.Expressions.ExpressionType)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Dynamic.BinaryOperationBinder&quot; /&gt; class.">Inicializa uma nova instância da classe <see cref="T:System.Dynamic.BinaryOperationBinder" />.</summary>
      <param name="operation" vsli:raw="The unary operation kind.">O tipo de operação unária.</param>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary vsli:raw="Performs the binding of the dynamic unary operation.">Executa a associação da operação unária dinâmica.</summary>
      <param name="target" vsli:raw="The target of the dynamic operation.">O destino da operação dinâmica.</param>
      <param name="args" vsli:raw="An array of arguments of the dynamic operation.">Uma matriz de argumentos da operação dinâmica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.FallbackUnaryOperation(System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the unary dynamic operation if the target dynamic object cannot bind.">Executa a associação da operação unária dinâmica caso o objeto dinâmico de destino não possa ser associado.</summary>
      <param name="target" vsli:raw="The target of the dynamic unary operation.">O destino da operação unária dinâmica.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.FallbackUnaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary vsli:raw="Performs the binding of the unary dynamic operation if the target dynamic object cannot bind.">Executa a associação da operação unária dinâmica caso o objeto dinâmico de destino não possa ser associado.</summary>
      <param name="target" vsli:raw="The target of the dynamic unary operation.">O destino da operação unária dinâmica.</param>
      <param name="errorSuggestion" vsli:raw="The binding result in case the binding fails, or null.">O resultado da associação no caso de falha da associação ou nulo.</param>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Dynamic.DynamicMetaObject&quot; /&gt; representing the result of the binding.">O <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa o resultado da associação.</returns>
    </member>
    <member name="P:System.Dynamic.UnaryOperationBinder.Operation">
      <summary vsli:raw="The unary operation kind.">O tipo de operação unária.</summary>
      <returns vsli:raw="The object of the &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents the unary operation kind.">O objeto do <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa o tipo de operação unário.</returns>
    </member>
    <member name="P:System.Dynamic.UnaryOperationBinder.ReturnType">
      <summary vsli:raw="The result type of the operation.">O tipo de resultado da operação.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the result type of the operation.">O <see cref="T:System.Type" /> objeto que representa o tipo de resultado da operação.</returns>
    </member>
    <member name="T:System.Linq.Expressions.BinaryExpression">
      <summary vsli:raw="Represents an expression that has a binary operator.">Representa uma expressão com um operador binário.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Expede o método específico de visita para esse tipo de nó. Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">O visitante com o qual visitar esse nó.</param>
      <returns vsli:raw="The result of visiting this node.">O resultado de visitar esse nó.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Reduce">
      <summary vsli:raw="Reduces the binary expression node to a simpler expression.">Reduz o nó de expressão binária para uma expressão mais simples.</summary>
      <returns vsli:raw="The reduced expression.">A expressão reduzida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="left" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> do resultado.</param>
      <param name="conversion" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> do resultado.</param>
      <param name="right" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> do resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.CanReduce">
      <summary vsli:raw="Gets a value that indicates whether the expression tree node can be reduced.">Obtém um valor que indica se o nó da árvore de expressão pode ser reduzido.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the expression tree node can be reduced; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Se o nó da árvore de expressão puder ser reduzido; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Conversion">
      <summary vsli:raw="Gets the type conversion function that is used by a coalescing or compound assignment operation.">Obtém a função de conversão de tipo que é usada por uma operação de atribuição composta ou de união.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that represents a type conversion function.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que representa uma função de conversão de tipo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLifted">
      <summary vsli:raw="Gets a value that indicates whether the expression tree node represents a lifted call to an operator.">Obtém um valor que indica se o nó da árvore de expressão representa uma chamada cancelada a um operador.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the node represents a lifted call; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Se o nó representa uma chamada levantada; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull">
      <summary vsli:raw="Gets a value that indicates whether the expression tree node represents a lifted call to an operator whose return type is lifted to a nullable type.">Obtém um valor que indica se o nó da árvore de expressão representa uma chamada cancelada a um operador cujo tipo de retorno é elevado para um tipo que permite valor nulo.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operator's return type is lifted to a nullable type; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Se o tipo de retorno do operador for elevado para um tipo anulável; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Left">
      <summary vsli:raw="Gets the left operand of the binary operation.">Obtém o operando esquerdo da operação binária.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the left operand of the binary operation.">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando esquerdo da operação binária.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Method">
      <summary vsli:raw="Gets the implementing method for the binary operation.">Obtém o método de implementação para a operação binária.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">O <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Right">
      <summary vsli:raw="Gets the right operand of the binary operation.">Obtém o operando direito da operação binária.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the right operand of the binary operation.">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando direito da operação binária.</returns>
    </member>
    <member name="T:System.Linq.Expressions.BlockExpression">
      <summary vsli:raw="Represents a block that contains a sequence of expressions where variables can be defined.">Representa um bloco que contém uma sequência de expressões em que variáveis podem ser definidas.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Expede o método específico de visita para esse tipo de nó. Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">O visitante com o qual visitar esse nó.</param>
      <returns vsli:raw="The result of visiting this node.">O resultado de visitar esse nó.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="variables" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.BlockExpression.Variables&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.BlockExpression.Variables" /> do resultado.</param>
      <param name="expressions" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.BlockExpression.Expressions&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.BlockExpression.Expressions" /> do resultado.</param>
      <returns vsli:raw="This expression if no children changed, or an expression with the updated children.">Essa expressão se nenhum filho tiver sido alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Expressions">
      <summary vsli:raw="Gets the expressions in this block.">Obtém as expressões neste bloco.</summary>
      <returns vsli:raw="The read-only collection containing all the expressions in this block.">A coleção somente leitura que contém todas as expressões neste bloco.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.NodeType">
      <summary vsli:raw="Returns the node type of this expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Retorna o tipo de nó dessa expressão. Nós de extensão devem retornar <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> ao substituírem esse método.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Result">
      <summary vsli:raw="Gets the last expression in this block.">Obtém a última expressão neste bloco.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; object representing the last expression in this block.">O <see cref="T:System.Linq.Expressions.Expression" /> objeto que representa a última expressão neste bloco.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.BlockExpression.Type&quot; /&gt; that represents the static type of the expression.">O <see cref="P:System.Linq.Expressions.BlockExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Variables">
      <summary vsli:raw="Gets the variables defined in this block.">Obtém as variáveis definidas neste bloco.</summary>
      <returns vsli:raw="The read-only collection containing all the variables defined in this block.">A coleção somente leitura que contém todas as variáveis definidas neste bloco.</returns>
    </member>
    <member name="T:System.Linq.Expressions.CatchBlock">
      <summary vsli:raw="Represents a catch statement in a try block.">Representa uma instrução catch em um bloco try.</summary>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.ToString">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.String&quot; /&gt; that represents the current &lt;see cref=&quot;T:System.Object&quot; /&gt;.">Retorna um valor <see cref="T:System.String" /> que representa o <see cref="T:System.Object" /> atual.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; that represents the current &lt;see cref=&quot;T:System.Object&quot; /&gt;.">Um <see cref="T:System.String" /> que representa o <see cref="T:System.Object" /> atual.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.Update(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="variable" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.CatchBlock.Variable&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.CatchBlock.Variable" /> do resultado.</param>
      <param name="filter" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.CatchBlock.Filter&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.CatchBlock.Filter" /> do resultado.</param>
      <param name="body" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.CatchBlock.Body&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.CatchBlock.Body" /> do resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Body">
      <summary vsli:raw="Gets the body of the catch block.">Obtém o corpo do bloco catch.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; object representing the catch body.">O <see cref="T:System.Linq.Expressions.Expression" /> objeto que representa o corpo da captura.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Filter">
      <summary vsli:raw="Gets the body of the &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; filter.">Obtém o corpo do filtro <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; object representing the body of the &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; filter.">O <see cref="T:System.Linq.Expressions.Expression" /> objeto que representa o corpo do <see cref="T:System.Linq.Expressions.CatchBlock" /> filtro.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Test">
      <summary vsli:raw="Gets the type of &lt;see cref=&quot;T:System.Exception&quot; /&gt; this handler catches.">Obtém o tipo de <see cref="T:System.Exception" /> que esse manipulador captura.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the type of &lt;see cref=&quot;T:System.Exception&quot; /&gt; this handler catches.">O <see cref="T:System.Type" /> objeto que representa o tipo desse <see cref="T:System.Exception" /> manipulador captura.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Variable">
      <summary vsli:raw="Gets a reference to the &lt;see cref=&quot;T:System.Exception&quot; /&gt; object caught by this handler.">Obtém uma referência para o objeto <see cref="T:System.Exception" /> capturado por este manipulador.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; object representing a reference to the &lt;see cref=&quot;T:System.Exception&quot; /&gt; object caught by this handler.">O <see cref="T:System.Linq.Expressions.ParameterExpression" /> objeto que representa uma referência ao <see cref="T:System.Exception" /> objeto capturado por este manipulador.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConditionalExpression">
      <summary vsli:raw="Represents an expression that has a conditional operator.">Representa uma expressão com um operador condicional.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Expede o método específico de visita para esse tipo de nó. Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">O visitante com o qual visitar esse nó.</param>
      <returns vsli:raw="The result of visiting this node.">O resultado de visitar esse nó.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="test" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> do resultado.</param>
      <param name="ifTrue" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> do resultado.</param>
      <param name="ifFalse" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfFalse&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> do resultado.</param>
      <returns vsli:raw="This expression if no children changed, or an expression with the updated children.">Essa expressão se nenhum filho tiver sido alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfFalse">
      <summary vsli:raw="Gets the expression to execute if the test evaluates to &lt;see langword=&quot;false&quot; /&gt;.">Obtém a expressão a ser executada se o teste for avaliado como <see langword="false" />.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the expression to execute if the test is &lt;see langword=&quot;false&quot; /&gt;.">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa a expressão a ser executada se o teste for <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfTrue">
      <summary vsli:raw="Gets the expression to execute if the test evaluates to &lt;see langword=&quot;true&quot; /&gt;.">Obtém a expressão a ser executada se o teste for avaliado como <see langword="true" />.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the expression to execute if the test is &lt;see langword=&quot;true&quot; /&gt;.">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa a expressão a ser executada se o teste for <see langword="true" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.NodeType">
      <summary vsli:raw="Returns the node type of this expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Retorna o tipo de nó dessa expressão. Nós de extensão devem retornar <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> ao substituírem esse método.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Test">
      <summary vsli:raw="Gets the test of the conditional operation.">Obtém o teste da operação condicional.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the test of the conditional operation.">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o teste da operação condicional.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Type&quot; /&gt; that represents the static type of the expression.">O <see cref="P:System.Linq.Expressions.ConditionalExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConstantExpression">
      <summary vsli:raw="Represents an expression that has a constant value.">Representa uma expressão que tem um valor constante.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConstantExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Expede o método específico de visita para esse tipo de nó. Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">O visitante com o qual visitar esse nó.</param>
      <returns vsli:raw="The result of visiting this node.">O resultado de visitar esse nó.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.NodeType">
      <summary vsli:raw="Returns the node type of this Expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Retorna o tipo de nó dessa Expressão. Nós de extensão devem retornar <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> ao substituírem esse método.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ConstantExpression.Type&quot; /&gt; that represents the static type of the expression.">O <see cref="P:System.Linq.Expressions.ConstantExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Value">
      <summary vsli:raw="Gets the value of the constant expression.">Obtém o valor da expressão de constante.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Object&quot; /&gt; equal to the value of the represented expression.">Um <see cref="T:System.Object" /> igual ao valor da expressão representada.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DebugInfoExpression">
      <summary vsli:raw="Emits or clears a sequence point for debug information. This allows the debugger to highlight the correct source code when debugging.">Emite ou limpa um ponto de sequência para informações de depuração. Isso permite que o depurador realce o código-fonte correto durante a depuração.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DebugInfoExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Expede o método específico de visita para esse tipo de nó. Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">O visitante com o qual visitar esse nó.</param>
      <returns vsli:raw="The result of visiting this node.">O resultado de visitar esse nó.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Document">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt; that represents the source file.">Obtém o <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa o arquivo de origem.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt; that represents the source file.">O <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa o arquivo de origem.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndColumn">
      <summary vsli:raw="Gets the end column of this &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;.">Obtém a coluna final deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns vsli:raw="The number of the end column of the code that was used to generate the wrapped expression.">O número da coluna final do código que foi usado para gerar a expressão encapsulada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndLine">
      <summary vsli:raw="Gets the end line of this &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;.">Obtém a linha final deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns vsli:raw="The number of the end line of the code that was used to generate the wrapped expression.">O número da linha final do código que foi usado para gerar a expressão encapsulada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.IsClear">
      <summary vsli:raw="Gets the value to indicate if the &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt; is for clearing a sequence point.">Obtém o valor para indicar se o <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> é para limpar um ponto de sequência.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt; is for clearing a sequence point; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Se <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> for para limpar um ponto de sequência; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retorna o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa essa expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartColumn">
      <summary vsli:raw="Gets the start column of this &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;.">Obtém a coluna inicial deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns vsli:raw="The number of the start column of the code that was used to generate the wrapped expression.">O número da coluna inicial do código que foi usado para gerar a expressão encapsulada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartLine">
      <summary vsli:raw="Gets the start line of this &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;.">Obtém a linha inicial deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns vsli:raw="The number of the start line of the code that was used to generate the wrapped expression.">O número da linha inicial do código que foi usado para gerar a expressão encapsulada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.DebugInfoExpression.Type&quot; /&gt; that represents the static type of the expression.">O <see cref="P:System.Linq.Expressions.DebugInfoExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DefaultExpression">
      <summary vsli:raw="Represents the default value of a type or an empty expression.">Representa o valor padrão de um tipo ou uma expressão vazia.</summary>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.NodeType">
      <summary vsli:raw="Returns the node type of this expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Retorna o tipo de nó dessa expressão. Nós de extensão devem retornar <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> ao substituírem esse método.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.DefaultExpression.Type&quot; /&gt; that represents the static type of the expression.">O <see cref="P:System.Linq.Expressions.DefaultExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DynamicExpression">
      <summary vsli:raw="Represents a dynamic operation.">Representa uma operação dinâmica.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Expede o método específico de visita para esse tipo de nó. Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">O visitante com o qual visitar esse nó.</param>
      <returns vsli:raw="The result of visiting this node.">O resultado de visitar esse nó.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">O associador de runtime para a operação dinâmica.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">O tipo de resultado da expressão dinâmica.</param>
      <param name="arguments" vsli:raw="The arguments to the dynamic operation.">Os argumentos para a operação dinâmica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;,  and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidos para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">O associador de runtime para a operação dinâmica.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">O tipo de resultado da expressão dinâmica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">O primeiro argumento para a operação dinâmica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;,  and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidos para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">O associador de runtime para a operação dinâmica.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">O tipo de resultado da expressão dinâmica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">O primeiro argumento para a operação dinâmica.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">O segundo argumento para a operação dinâmica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidos para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">O associador de runtime para a operação dinâmica.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">O tipo de resultado da expressão dinâmica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">O primeiro argumento para a operação dinâmica.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">O segundo argumento para a operação dinâmica.</param>
      <param name="arg2" vsli:raw="The third argument to the dynamic operation.">O terceiro argumento para a operação dinâmica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidos para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">O associador de runtime para a operação dinâmica.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">O tipo de resultado da expressão dinâmica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">O primeiro argumento para a operação dinâmica.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">O segundo argumento para a operação dinâmica.</param>
      <param name="arg2" vsli:raw="The third argument to the dynamic operation.">O terceiro argumento para a operação dinâmica.</param>
      <param name="arg3" vsli:raw="The fourth argument to the dynamic operation.">O quarto argumento para a operação dinâmica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidos para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">O associador de runtime para a operação dinâmica.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">O tipo de resultado da expressão dinâmica.</param>
      <param name="arguments" vsli:raw="The arguments to the dynamic operation.">Os argumentos para a operação dinâmica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidos para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">O associador de runtime para a operação dinâmica.</param>
      <param name="arguments" vsli:raw="The arguments to the dynamic operation.">Os argumentos para a operação dinâmica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidos para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; and one argument.">Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido e um argumento.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">O associador de runtime para a operação dinâmica.</param>
      <param name="arg0" vsli:raw="The argument to the dynamic operation.">O argumento para a operação dinâmica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidos para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; and two arguments.">Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido e dois argumentos.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">O associador de runtime para a operação dinâmica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">O primeiro argumento para a operação dinâmica.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">O segundo argumento para a operação dinâmica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidos para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; and three arguments.">Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido e três argumentos.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">O associador de runtime para a operação dinâmica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">O primeiro argumento para a operação dinâmica.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">O segundo argumento para a operação dinâmica.</param>
      <param name="arg2" vsli:raw="The third argument to the dynamic operation.">O terceiro argumento para a operação dinâmica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidos para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; and four arguments.">Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido e quatro argumentos.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">O associador de runtime para a operação dinâmica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">O primeiro argumento para a operação dinâmica.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">O segundo argumento para a operação dinâmica.</param>
      <param name="arg2" vsli:raw="The third argument to the dynamic operation.">O terceiro argumento para a operação dinâmica.</param>
      <param name="arg3" vsli:raw="The fourth argument to the dynamic operation.">O quarto argumento para a operação dinâmica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidos para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">O associador de runtime para a operação dinâmica.</param>
      <param name="arguments" vsli:raw="The arguments to the dynamic operation.">Os argumentos para a operação dinâmica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt;, and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidos para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary vsli:raw="Returns the argument at index, throwing if index is out of bounds. You should not use this member. It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Retorna o argumento no índice, lançando se o índice estiver fora dos limites. Você não deve usar esse membro. Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho.</summary>
      <param name="index" vsli:raw="The index of the argument.">O índice do argumento.</param>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retorna <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IDynamicExpression#CreateCallSite">
      <summary vsli:raw="Optionally creates the CallSite and returns the CallSite for the DynamicExpression's polymorphic inline cache. You should not use this member. It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Opcionalmente, cria e retorna o CallSite para o cache embutido polimórfico de DynamicExpression. Você não deve usar esse membro. Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho.</summary>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Object&quot; /&gt;.">Retorna <see cref="T:System.Object" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IDynamicExpression#Rewrite(System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Rewrite this node replacing the dynamic expression's arguments with the provided values. The number of &lt;paramref name=&quot;args&quot; /&gt; needs to match the number of the current expression. You should not use this type. It is only public due to assembly refactoring, and it is used internally for performance optimizations. This helper method allows re-writing of nodes to be independent of the specific implementation class deriving from DynamicExpression that is being used at the call site.">Regrava este nó substituindo os argumentos da expressão dinâmica pelos valores fornecidos. O número de <paramref name="args" /> precisa corresponder ao número da expressão atual. Você não deve usar esse tipo. Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho. Esse método auxiliar permite que a regravação de nós seja independente da classe de implementação específica derivada de DynamicExpression que está sendo usada no local da chamada.</summary>
      <param name="args" vsli:raw="The arguments.">Os argumentos.</param>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;, the rewritten expression.">Retorna <see cref="T:System.Linq.Expressions.Expression" />, a expressão reescrita.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Compares the value sent to the parameter, &lt;paramref name=&quot;arguments&quot; /&gt;, to the &lt;see langword=&quot;Arguments&quot; /&gt; property of the current instance of &lt;see langword=&quot;DynamicExpression&quot; /&gt;. If the values of the parameter and the property are equal, the current instance is returned. If they are not equal, a new &lt;see langword=&quot;DynamicExpression&quot; /&gt; instance is returned that is identical to the current instance except that the &lt;see langword=&quot;Arguments&quot; /&gt; property is set to the value of parameter &lt;paramref name=&quot;arguments&quot; /&gt;.">Compara o valor enviado para o parâmetro, <paramref name="arguments" />, para a propriedade <see langword="Arguments" /> da instância atual do <see langword="DynamicExpression" />. Se os valores do parâmetro e a propriedade forem iguais, a instância atual será retornada. Se não forem iguais, uma nova instância <see langword="DynamicExpression" /> será retornada idêntica à instância atual, exceto se a propriedade <see langword="Arguments" /> for definida como o valor do parâmetro <paramref name="arguments" />.</summary>
      <param name="arguments" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> do resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Arguments">
      <summary vsli:raw="Gets the arguments to the dynamic operation.">Obtém os argumentos para a operação dinâmica.</summary>
      <returns vsli:raw="The read-only collections containing the arguments to the dynamic operation.">As coleções somente leitura que contêm os argumentos para a operação dinâmica.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Binder">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;, which determines the run-time behavior of the dynamic site.">Obtém o <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />, que determina o comportamento de tempo de execução do site dinâmico.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;, which determines the run-time behavior of the dynamic site.">O <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> , que determina o comportamento de tempo de execução do site dinâmico.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.DelegateType">
      <summary vsli:raw="Gets the type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">Obtém o tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">O <see cref="T:System.Type" /> objeto que representa o tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.NodeType">
      <summary vsli:raw="Returns the node type of this expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Retorna o tipo de nó dessa expressão. Nós de extensão devem retornar <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> ao substituírem esse método.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary vsli:raw="Returns the number of arguments to the expression tree node. You should not use this member. It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Retorna o número de argumentos para o nó de árvore de expressão. Você não deve usar esse membro. Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho.</summary>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">Retorna <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Type&quot; /&gt; that represents the static type of the expression.">O <see cref="P:System.Linq.Expressions.DynamicExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DynamicExpressionVisitor">
      <summary vsli:raw="Represents a visitor or rewriter for dynamic expression trees.">Representa um visitante ou regravador de árvores de expressão dinâmica.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpressionVisitor.#ctor">
      <summary vsli:raw="Initializes a new instance of &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpressionVisitor&quot; /&gt;.">Inicializa uma nova instância de <see cref="T:System.Linq.Expressions.DynamicExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpressionVisitor.VisitDynamic(System.Linq.Expressions.DynamicExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.DynamicExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;, the modified expression, if it or any subexpression is modified; otherwise, returns the original expression.">Retorna <see cref="T:System.Linq.Expressions.Expression" />, a expressão modificada, se ela ou alguma subexpressão tiver sido modificada, caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ElementInit">
      <summary vsli:raw="Represents an initializer for a single element of an &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt; collection.">Representa um inicializador para um único elemento de uma coleção <see cref="T:System.Collections.IEnumerable" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary vsli:raw="Returns the argument at index, throwing if index is out of bounds.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Retorna o argumento no índice, lançando se o índice estiver fora dos limites.  Você não deve usar esse membro.  Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho.</summary>
      <param name="index" vsli:raw="The index of the argument.">O índice do argumento.</param>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retorna <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.ToString">
      <summary vsli:raw="Returns a textual representation of an &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; object.">Retorna uma representação textual de um objeto <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns vsli:raw="A textual representation of the &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; object.">Uma representação textual do objeto <see cref="T:System.Linq.Expressions.ElementInit" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="arguments" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.Arguments&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> do resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.AddMethod">
      <summary vsli:raw="Gets the instance method that is used to add an element to an &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt; collection.">Obtém o método de instância que é usado para adicionar um elemento a uma coleção <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents an instance method that adds an element to a collection.">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de instância que adiciona um elemento a uma coleção.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.Arguments">
      <summary vsli:raw="Gets the collection of arguments that are passed to a method that adds an element to an &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt; collection.">Obtém a coleção de argumentos que são passados para um método que adiciona um elemento a uma coleção <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that represent the arguments for a method that adds an element to a collection.">Um <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> dos <see cref="T:System.Linq.Expressions.Expression" /> objetos que representam os argumentos para um método que adiciona um elemento a uma coleção.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary vsli:raw="Returns the number of arguments to the expression tree node.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Retorna o número de argumentos para o nó de árvore de expressão.  Você não deve usar esse membro.  Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho.</summary>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">Retorna <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:System.Linq.Expressions.Expression">
      <summary vsli:raw="Provides the base class from which the classes that represent expression tree nodes are derived. It also contains &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) factory methods to create the various node types. This is an &lt;see langword=&quot;abstract&quot; /&gt; class.">Fornece a classe base da qual são derivadas as classes que representam nós de árvore de expressão. Também contém métodos de fábrica <see langword="static" /> (<see langword="Shared" /> no Visual Basic) para criar os diferentes tipos de nós. Esta é uma classe <see langword="abstract" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor">
      <summary vsli:raw="Constructs a new instance of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Constrói uma nova instância de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor(System.Linq.Expressions.ExpressionType,System.Type)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; class.">Inicializa uma nova instância da classe <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <param name="nodeType" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; to set as the node type.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> para definir como tipo de nó.</param>
      <param name="type" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">O <see cref="P:System.Linq.Expressions.Expression.Type" /> desse <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Expede o método específico de visita para esse tipo de nó. Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">O visitante com o qual visitar esse nó.</param>
      <returns vsli:raw="The result of visiting this node.">O resultado de visitar esse nó.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic addition operation that does not have overflow checking.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de adição que não tem verificação de estouro.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The addition operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">O operador de adição não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Add&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic addition operation that does not have overflow checking. The implementing method can be specified.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de adição que não tem verificação de estouro. O método de implementação pode ser especificado.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the addition operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> é <see langword="null" /> e o operador de adição não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Add&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an addition assignment operation that does not have overflow checking.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que não tem a verificação de estouro.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AddAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an addition assignment operation that does not have overflow checking.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que não tem a verificação de estouro.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AddAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an addition assignment operation that does not have overflow checking.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que não tem a verificação de estouro.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AddAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an addition assignment operation that has overflow checking.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que tem verificação de estouro.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AddAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an addition assignment operation that has overflow checking.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que tem verificação de estouro.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AddAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an addition assignment operation that has overflow checking.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que tem verificação de estouro.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AddAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic addition operation that has overflow checking.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de adição que tem verificação de estouro.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The addition operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">O operador de adição não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AddChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic addition operation that has overflow checking. The implementing method can be specified.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de adição que tem verificação de estouro. O método de implementação pode ser especificado.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the addition operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> é <see langword="null" /> e o operador de adição não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AddChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise &lt;see langword=&quot;AND&quot; /&gt; operation.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="AND" /> bit a bit.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The bitwise &lt;see langword=&quot;AND&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">O operador <see langword="AND" /> bit a bit não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.And&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.And" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise &lt;see langword=&quot;AND&quot; /&gt; operation. The implementing method can be specified.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="AND" /> bit a bit. O método de implementação pode ser especificado.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the bitwise &lt;see langword=&quot;AND&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> é <see langword="null" /> e o operador <see langword="AND" /> bit a bit não é definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.And&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.And" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a conditional &lt;see langword=&quot;AND&quot; /&gt; operation that evaluates the second operand only if the first operand evaluates to &lt;see langword=&quot;true&quot; /&gt;.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="AND" /> condicional que avalia o segundo operando somente se o primeiro operando é avaliado como <see langword="true" />.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The bitwise &lt;see langword=&quot;AND&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type are not the same Boolean type.">O operador <see langword="AND" /> bit a bit não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.  
  
- ou - 
 <paramref name="left" />.Type e <paramref name="right" />.Type não são do mesmo tipo booliano.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AndAlso&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a conditional &lt;see langword=&quot;AND&quot; /&gt; operation that evaluates the second operand only if the first operand is resolved to true. The implementing method can be specified.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="AND" /> condicional que avalia o segundo operando somente se o primeiro operando é resolvido para verdadeiro. O método de implementação pode ser especificado.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the bitwise &lt;see langword=&quot;AND&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type are not the same Boolean type.">
        <paramref name="method" /> é <see langword="null" /> e o operador <see langword="AND" /> bit a bit não é definido para <paramref name="left" />.Type e <paramref name="right" />.Type.  
  
- ou - 
 <paramref name="method" /> é <see langword="null" /> e Type.<paramref name="left" /> e Type.<paramref name="right" /> não são do mesmo tipo booliano.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AndAlso&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise AND assignment operation.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição AND bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AndAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise AND assignment operation.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição AND bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AndAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise AND assignment operation.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição AND bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.AndAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt; to access a multidimensional array.">Cria uma <see cref="T:System.Linq.Expressions.IndexExpression" /> para acessar uma matriz multidimensional.</summary>
      <param name="array" vsli:raw="An expression that represents the multidimensional array.">Uma expressão que representa a matriz multidimensional.</param>
      <param name="indexes" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; containing expressions used to index the array.">Uma <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém as expressões usadas para indexar a matriz.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt; to access an array.">Cria uma <see cref="T:System.Linq.Expressions.IndexExpression" /> para acessar uma matriz.</summary>
      <param name="array" vsli:raw="An expression representing the array to index.">Uma expressão que representa a matriz a ser indexada.</param>
      <param name="indexes" vsli:raw="An array that contains expressions used to index the array.">Uma matriz que contém as expressões usadas para indexar a matriz.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents applying an array index operator to an array of rank more than one.">Cria uma <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa a aplicação de um operador de índice de matriz a uma matriz de classificação superior a um.</summary>
      <param name="array" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> igual a ele.</param>
      <param name="indexes" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; or &lt;paramref name=&quot;indexes&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="array" /> ou <paramref name="indexes" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt;.Type does not represent an array type.  &#xA;  &#xA; -or-  &#xA;  &#xA; The rank of &lt;paramref name=&quot;array&quot; /&gt;.Type does not match the number of elements in &lt;paramref name=&quot;indexes&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of one or more elements of &lt;paramref name=&quot;indexes&quot; /&gt; does not represent the &lt;see cref=&quot;T:System.Int32&quot; /&gt; type.">
        <paramref name="array" />.Type não representa um tipo de matriz.  
  
- ou - 
A classificação de <paramref name="array" />.Type não corresponde ao número de elementos em <paramref name="indexes" />.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um ou mais elementos de <paramref name="indexes" /> não representa o tipo <see cref="T:System.Int32" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents applying an array index operator to an array of rank one.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa a aplicação de um operador de índice de matriz a uma matriz de classificação um.</summary>
      <param name="array" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="index" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; or &lt;paramref name=&quot;index&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="array" /> ou <paramref name="index" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt;.Type does not represent an array type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;array&quot; /&gt;.Type represents an array type whose rank is not 1.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;index&quot; /&gt;.Type does not represent the &lt;see cref=&quot;T:System.Int32&quot; /&gt; type.">
        <paramref name="array" />.Type não representa um tipo de matriz.  
  
- ou - 
 <paramref name="array" />.Type representa um tipo de matriz cuja classificação não é 1.  
  
- ou - 
 <paramref name="index" />.Type não representa o tipo <see cref="T:System.Int32" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ArrayIndex&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents applying an array index operator to a multidimensional array.">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa a aplicação de um operador de índice de matriz a uma matriz multidimensional.</summary>
      <param name="array" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; instances - indexes for the array index operation.">Uma matriz de instâncias <see cref="T:System.Linq.Expressions.Expression" />/índices para a operação de índice da matriz.</param>
      <param name="indexes" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; collection.">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; or &lt;paramref name=&quot;indexes&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="array" /> ou <paramref name="indexes" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt;.Type does not represent an array type.  &#xA;  &#xA; -or-  &#xA;  &#xA; The rank of &lt;paramref name=&quot;array&quot; /&gt;.Type does not match the number of elements in &lt;paramref name=&quot;indexes&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of one or more elements of &lt;paramref name=&quot;indexes&quot; /&gt; does not represent the &lt;see cref=&quot;T:System.Int32&quot; /&gt; type.">
        <paramref name="array" />.Type não representa um tipo de matriz.  
  
- ou - 
A classificação de <paramref name="array" />.Type não corresponde ao número de elementos em <paramref name="indexes" />.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um ou mais elementos de <paramref name="indexes" /> não representa o tipo <see cref="T:System.Int32" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents an expression for obtaining the length of a one-dimensional array.">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma expressão para obter o comprimento de uma matriz unidimensional.</summary>
      <param name="array" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="array" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt;.Type does not represent an array type.">
        <paramref name="array" />.Type não representa um tipo de matriz.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ArrayLength&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to &lt;paramref name=&quot;array&quot; /&gt;.">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a <paramref name="array" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an assignment operation.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Assign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberAssignment&quot; /&gt; that represents the initialization of a field or property.">Cria um <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa a inicialização de um campo ou propriedade.</summary>
      <param name="member" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MemberInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> igual a ele.</param>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberAssignment.Expression&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; or &lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="member" /> ou <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; does not represent a field or property.  &#xA;  &#xA; -or-  &#xA;  &#xA; The property represented by &lt;paramref name=&quot;member&quot; /&gt; does not have a &lt;see langword=&quot;set&quot; /&gt; accessor.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type is not assignable to the type of the field or property that &lt;paramref name=&quot;member&quot; /&gt; represents.">
        <paramref name="member" /> não representa um campo ou propriedade.  
  
- ou - 
A propriedade representada por <paramref name="member" /> não tem um acessador <see langword="set" />.  
  
- ou - 
 <paramref name="expression" />.Type não é atribuível ao tipo de campo ou à propriedade que <paramref name="member" /> representa.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberAssignment&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.Assignment&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberAssignment.Expression&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.MemberAssignment" /> que tem <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberAssignment&quot; /&gt; that represents the initialization of a member by using a property accessor method.">Cria uma <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa a inicialização de um membro usando um método de acessador de propriedade.</summary>
      <param name="propertyAccessor" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents a property accessor method.">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</param>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberAssignment.Expression&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; or &lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="propertyAccessor" /> ou <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; does not represent a property accessor method.  &#xA;  &#xA; -or-  &#xA;  &#xA; The property accessed by &lt;paramref name=&quot;propertyAccessor&quot; /&gt; does not have a &lt;see langword=&quot;set&quot; /&gt; accessor.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type is not assignable to the type of the field or property that &lt;paramref name=&quot;member&quot; /&gt; represents.">
        <paramref name="propertyAccessor" /> não representa um método de acessador de propriedade.  
  
- ou - 
A propriedade acessada por <paramref name="propertyAccessor" /> não tem um acessador <see langword="set" />.  
  
- ou - 
 <paramref name="expression" />.Type não é atribuível ao tipo de campo ou à propriedade que <paramref name="member" /> representa.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberAssignment&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.Assignment&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; that represents the property accessed in &lt;paramref name=&quot;propertyAccessor&quot; /&gt;, and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberAssignment.Expression&quot; /&gt; property set to &lt;paramref name=&quot;expression&quot; /&gt;.">Um <see cref="T:System.Linq.Expressions.MemberAssignment" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> definida para o <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" /> e a propriedade <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> definida para <paramref name="expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains the given expressions and has no variables.">Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões determinadas e não tem variáveis.</summary>
      <param name="expressions" vsli:raw="The expressions in the block.">As expressões no bloco.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains the given variables and expressions.">Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões e variáveis determinadas.</summary>
      <param name="variables" vsli:raw="The variables in the block.">As variáveis no bloco.</param>
      <param name="expressions" vsli:raw="The expressions in the block.">As expressões no bloco.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains the given variables and expressions.">Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões e variáveis determinadas.</summary>
      <param name="variables" vsli:raw="The variables in the block.">As variáveis no bloco.</param>
      <param name="expressions" vsli:raw="The expressions in the block.">As expressões no bloco.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains two expressions and has no variables.">Cria uma <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém duas expressões e não tem variáveis.</summary>
      <param name="arg0" vsli:raw="The first expression in the block.">A primeira expressão no bloco.</param>
      <param name="arg1" vsli:raw="The second expression in the block.">A segunda expressão no bloco.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains three expressions and has no variables.">Cria uma <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém três expressões e não tem variáveis.</summary>
      <param name="arg0" vsli:raw="The first expression in the block.">A primeira expressão no bloco.</param>
      <param name="arg1" vsli:raw="The second expression in the block.">A segunda expressão no bloco.</param>
      <param name="arg2" vsli:raw="The third expression in the block.">A terceira expressão no bloco.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains four expressions and has no variables.">Cria uma <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém quatro expressões e não tem variáveis.</summary>
      <param name="arg0" vsli:raw="The first expression in the block.">A primeira expressão no bloco.</param>
      <param name="arg1" vsli:raw="The second expression in the block.">A segunda expressão no bloco.</param>
      <param name="arg2" vsli:raw="The third expression in the block.">A terceira expressão no bloco.</param>
      <param name="arg3" vsli:raw="The fourth expression in the block.">A quarta expressão no bloco.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains five expressions and has no variables.">Cria uma <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém cinco expressões e não tem variáveis.</summary>
      <param name="arg0" vsli:raw="The first expression in the block.">A primeira expressão no bloco.</param>
      <param name="arg1" vsli:raw="The second expression in the block.">A segunda expressão no bloco.</param>
      <param name="arg2" vsli:raw="The third expression in the block.">A terceira expressão no bloco.</param>
      <param name="arg3" vsli:raw="The fourth expression in the block.">A quarta expressão no bloco.</param>
      <param name="arg4" vsli:raw="The fifth expression in the block.">A quinta expressão no bloco.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains the given expressions and has no variables.">Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões determinadas e não tem variáveis.</summary>
      <param name="expressions" vsli:raw="The expressions in the block.">As expressões no bloco.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains the given expressions, has no variables and has specific result type.">Cria uma <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões fornecidas, não tem variáveis e tem um tipo de resultado específico.</summary>
      <param name="type" vsli:raw="The result type of the block.">O tipo de resultado do bloco.</param>
      <param name="expressions" vsli:raw="The expressions in the block.">As expressões no bloco.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains the given variables and expressions.">Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões e variáveis determinadas.</summary>
      <param name="type" vsli:raw="The result type of the block.">O tipo de resultado do bloco.</param>
      <param name="variables" vsli:raw="The variables in the block.">As variáveis no bloco.</param>
      <param name="expressions" vsli:raw="The expressions in the block.">As expressões no bloco.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains the given variables and expressions.">Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões e variáveis determinadas.</summary>
      <param name="type" vsli:raw="The result type of the block.">O tipo de resultado do bloco.</param>
      <param name="variables" vsli:raw="The variables in the block.">As variáveis no bloco.</param>
      <param name="expressions" vsli:raw="The expressions in the block.">As expressões no bloco.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt; that contains the given expressions, has no variables and has specific result type.">Cria uma <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões fornecidas, não tem variáveis e tem um tipo de resultado específico.</summary>
      <param name="type" vsli:raw="The result type of the block.">O tipo de resultado do bloco.</param>
      <param name="expressions" vsli:raw="The expressions in the block.">As expressões no bloco.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a break statement.">Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução break.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Break, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, and a null value to be passed to the target label upon jumping.">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" /> e um valor nulo a ser passado para o rótulo de destino ao saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a break statement. The value passed to the label upon jumping can be specified.">Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução break. O valor passado para o rótulo no salto pode ser especificado.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <param name="value" vsli:raw="The value that will be passed to the associated label upon jumping.">O valor que será passado para o rótulo associado ao saltar.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Break, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, and &lt;paramref name=&quot;value&quot; /&gt; to be passed to the target label upon jumping.">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" /> e <paramref name="value" /> a ser passado para o rótulo de destino ao saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a break statement with the specified type. The value passed to the label upon jumping can be specified.">Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução break com o tipo especificado. O valor passado para o rótulo no salto pode ser especificado.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <param name="value" vsli:raw="The value that will be passed to the associated label upon jumping.">O valor que será passado para o rótulo associado ao saltar.</param>
      <param name="type" vsli:raw="An &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Break, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;paramref name=&quot;type&quot; /&gt;, and &lt;paramref name=&quot;value&quot; /&gt; to be passed to the target label upon jumping.">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" />, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e <paramref name="value" /> a serem passados para o rótulo de destino após saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a break statement with the specified type.">Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução break com o tipo especificado.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <param name="type" vsli:raw="An &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Break, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, and the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;paramref name=&quot;type&quot; /&gt;.">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" /> e a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a method that takes no arguments.">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método que não aceita argumentos.</summary>
      <param name="instance" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that specifies the instance for an instance method call (pass &lt;see langword=&quot;null&quot; /&gt; for a &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method).">Um <see cref="T:System.Linq.Expressions.Expression" /> que especifica a instância de uma chamada de método de instância (passa <see langword="null" /> para um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic)).</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;instance&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;method&quot; /&gt; represents an instance method.">
        <paramref name="method" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="instance" /> é <see langword="null" /> e <paramref name="method" /> representa um método de instância.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;instance&quot; /&gt;.Type is not assignable to the declaring type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">
        <paramref name="instance" />. O tipo não é atribuível ao tipo de declaração de método representada pelo <paramref name="method" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a method that takes arguments.">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método que aceita argumentos.</summary>
      <param name="instance" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; property equal to (pass &lt;see langword=&quot;null&quot; /&gt; for a &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method).">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> igual a (passar <see langword="null" /> para um método <see langword="static" /> [<see langword="Shared" /> no Visual Basic]).</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</param>
      <param name="arguments" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;instance&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;method&quot; /&gt; represents an instance method.">
        <paramref name="method" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="instance" /> é <see langword="null" /> e <paramref name="method" /> representa um método de instância.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;instance&quot; /&gt;.Type is not assignable to the declaring type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The number of elements in &lt;paramref name=&quot;arguments&quot; /&gt; does not equal the number of parameters for the method represented by &lt;paramref name=&quot;method&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more of the elements of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the corresponding parameter for the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">
        <paramref name="instance" />. O tipo não é atribuível ao tipo de declaração de método representada pelo <paramref name="method" />.  
  
- ou - 
O número de elementos em <paramref name="arguments" /> não é igual ao número de parâmetros para o método representado por <paramref name="method" />.  
  
- ou - 
Um ou mais dos elementos de <paramref name="arguments" /> não é atribuível ao parâmetro correspondente para o método representado por <paramref name="method" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a method that takes two arguments.">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método que aceita dois argumentos.</summary>
      <param name="instance" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that specifies the instance for an instance call. (pass null for a static (Shared in Visual Basic) method).">Um <see cref="T:System.Linq.Expressions.Expression" /> que especifica a instância de uma chamada de instância. (passar nulo para um método estático [compartilhado no Visual Basic]).</param>
      <param name="method" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the target method.">O <see cref="T:System.Reflection.MethodInfo" /> que representa o método de destino.</param>
      <param name="arg0" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the first argument.">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</param>
      <param name="arg1" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the second argument.">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a method that takes three arguments.">Cria uma <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método que usa três argumentos.</summary>
      <param name="instance" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that specifies the instance for an instance call. (pass null for a static (Shared in Visual Basic) method).">Um <see cref="T:System.Linq.Expressions.Expression" /> que especifica a instância de uma chamada de instância. (passar nulo para um método estático [compartilhado no Visual Basic]).</param>
      <param name="method" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the target method.">O <see cref="T:System.Reflection.MethodInfo" /> que representa o método de destino.</param>
      <param name="arg0" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the first argument.">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</param>
      <param name="arg1" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the second argument.">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</param>
      <param name="arg2" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the third argument.">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o terceiro argumento.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a method that takes arguments.">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método que aceita argumentos.</summary>
      <param name="instance" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that specifies the instance for an instance method call (pass &lt;see langword=&quot;null&quot; /&gt; for a &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method).">Um <see cref="T:System.Linq.Expressions.Expression" /> que especifica a instância de uma chamada de método de instância (passa <see langword="null" /> para um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic)).</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; collection.">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;instance&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;method&quot; /&gt; represents an instance method.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;arguments&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and one or more of its elements is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="method" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="instance" /> é <see langword="null" /> e <paramref name="method" /> representa um método de instância.  
  
- ou - 
 <paramref name="arguments" /> não é <see langword="null" /> e um ou mais dos seus elementos é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;instance&quot; /&gt;.Type is not assignable to the declaring type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The number of elements in &lt;paramref name=&quot;arguments&quot; /&gt; does not equal the number of parameters for the method represented by &lt;paramref name=&quot;method&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more of the elements of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the corresponding parameter for the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">
        <paramref name="instance" />. O tipo não é atribuível ao tipo de declaração de método representada pelo <paramref name="method" />.  
  
- ou - 
O número de elementos em <paramref name="arguments" /> não é igual ao número de parâmetros para o método representado por <paramref name="method" />.  
  
- ou - 
Um ou mais dos elementos de <paramref name="arguments" /> não é atribuível ao parâmetro correspondente para o método representado por <paramref name="method" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a method by calling the appropriate factory method.">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método chamando o método de fábrica apropriado.</summary>
      <param name="instance" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; whose &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property value will be searched for a specific method.">Um <see cref="T:System.Linq.Expressions.Expression" /> cujo valor da propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> será pesquisado quanto a um método específico.</param>
      <param name="methodName" vsli:raw="The name of the method.">O nome do método.</param>
      <param name="typeArguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects that specify the type parameters of the generic method. This argument should be null when methodName specifies a non-generic method.">Uma matriz de objetos <see cref="T:System.Type" /> que especificam os parâmetros de tipo do método genérico. Esse argumento deve ser nulo quando methodName especifica um método não genérico.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that represents the arguments to the method.">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representa os argumentos para o método.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;instance&quot; /&gt; or &lt;paramref name=&quot;methodName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="instance" /> ou <paramref name="methodName" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="No method whose name is &lt;paramref name=&quot;methodName&quot; /&gt;, whose type parameters match &lt;paramref name=&quot;typeArguments&quot; /&gt;, and whose parameter types match &lt;paramref name=&quot;arguments&quot; /&gt; is found in &lt;paramref name=&quot;instance&quot; /&gt;.Type or its base types.  &#xA;  &#xA; -or-  &#xA;  &#xA; More than one method whose name is &lt;paramref name=&quot;methodName&quot; /&gt;, whose type parameters match &lt;paramref name=&quot;typeArguments&quot; /&gt;, and whose parameter types match &lt;paramref name=&quot;arguments&quot; /&gt; is found in &lt;paramref name=&quot;instance&quot; /&gt;.Type or its base types.">Nenhum método cujo nome é <paramref name="methodName" />, cujos parâmetros de tipo correspondem a <paramref name="typeArguments" /> e cujos tipos de parâmetro correspondem a <paramref name="arguments" /> foi encontrado em <paramref name="instance" />.Type ou em seus tipos base.  
  
- ou - 
Mais de um método cujo nome é <paramref name="methodName" />, cujos parâmetros de tipo correspondem a <paramref name="typeArguments" /> e cujos tipos de parâmetro correspondem a <paramref name="arguments" /> foi encontrado em <paramref name="instance" />.Type ou em seus tipos base.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; property equal to &lt;paramref name=&quot;instance&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; set to the &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the specified instance method, and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; set to the specified arguments.">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> igual a <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definido como o <see cref="T:System.Reflection.MethodInfo" /> que representa o método de instância especificado e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definido como os argumentos especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a static (Shared in Visual Basic) method.">Cria uma <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método estático (compartilhado no Visual Basic).</summary>
      <param name="method" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the target method.">O <see cref="T:System.Reflection.MethodInfo" /> que representa o método de destino.</param>
      <param name="arguments" vsli:raw="A collection of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the call arguments.">Uma coleção de <see cref="T:System.Linq.Expressions.Expression" /> que representa os argumentos de chamada.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method that takes one argument.">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic) que aceita um argumento.</summary>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</param>
      <param name="arg0" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the first argument.">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is null.">
        <paramref name="method" /> é nulo.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a static method that takes two arguments.">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método estático que aceita dois argumentos.</summary>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</param>
      <param name="arg0" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the first argument.">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</param>
      <param name="arg1" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the second argument.">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is null.">
        <paramref name="method" /> é nulo.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a static method that takes three arguments.">Cria uma <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método estático que usa três argumentos.</summary>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</param>
      <param name="arg0" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the first argument.">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</param>
      <param name="arg1" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the second argument.">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</param>
      <param name="arg2" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the third argument.">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o terceiro argumento.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is null.">
        <paramref name="method" /> é nulo.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a static method that takes four arguments.">Cria uma <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método estático que aceita quatro argumentos.</summary>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</param>
      <param name="arg0" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the first argument.">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</param>
      <param name="arg1" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the second argument.">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</param>
      <param name="arg2" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the third argument.">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o terceiro argumento.</param>
      <param name="arg3" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the fourth argument.">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o quarto argumento.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is null.">
        <paramref name="method" /> é nulo.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a static method that takes five arguments.">Cria uma <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método estático que aceita cinco argumentos.</summary>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</param>
      <param name="arg0" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the first argument.">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</param>
      <param name="arg1" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the second argument.">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</param>
      <param name="arg2" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the third argument.">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o terceiro argumento.</param>
      <param name="arg3" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the fourth argument.">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o quarto argumento.</param>
      <param name="arg4" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the fifth argument.">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o quinto argumento.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is null.">
        <paramref name="method" /> é nulo.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method that has arguments.">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic) que tem argumentos.</summary>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents a &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method to set the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic) igual ao qual definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; collection.">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="method" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The number of elements in &lt;paramref name=&quot;arguments&quot; /&gt; does not equal the number of parameters for the method represented by &lt;paramref name=&quot;method&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more of the elements of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the corresponding parameter for the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">O número de elementos em <paramref name="arguments" /> não é igual ao número de parâmetros para o método representado por <paramref name="method" />.  
  
- ou - 
Um ou mais dos elementos de <paramref name="arguments" /> não é atribuível ao parâmetro correspondente para o método representado por <paramref name="method" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that represents a call to a &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method by calling the appropriate factory method.">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic) chamando o método de fábrica apropriado.</summary>
      <param name="type" vsli:raw="The type that contains the specified &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method.">O tipo que contém o método <see langword="static" /> especificado (<see langword="Shared" /> no Visual Basic).</param>
      <param name="methodName" vsli:raw="The name of the method.">O nome do método.</param>
      <param name="typeArguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Type&quot; /&gt; objects that specify the type parameters of the generic method. This argument should be null when methodName specifies a non-generic method.">Uma matriz de objetos <see cref="T:System.Type" /> que especificam os parâmetros de tipo do método genérico. Esse argumento deve ser nulo quando methodName especifica um método não genérico.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that represent the arguments to the method.">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representam os argumentos para o método.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; or &lt;paramref name=&quot;methodName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" /> ou <paramref name="methodName" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="No method whose name is &lt;paramref name=&quot;methodName&quot; /&gt;, whose type parameters match &lt;paramref name=&quot;typeArguments&quot; /&gt;, and whose parameter types match &lt;paramref name=&quot;arguments&quot; /&gt; is found in &lt;paramref name=&quot;type&quot; /&gt; or its base types.  &#xA;  &#xA; -or-  &#xA;  &#xA; More than one method whose name is &lt;paramref name=&quot;methodName&quot; /&gt;, whose type parameters match &lt;paramref name=&quot;typeArguments&quot; /&gt;, and whose parameter types match &lt;paramref name=&quot;arguments&quot; /&gt; is found in &lt;paramref name=&quot;type&quot; /&gt; or its base types.">Nenhum método cujo nome é <paramref name="methodName" />, cujos parâmetros de tipo correspondem a <paramref name="typeArguments" /> e cujos tipos de parâmetro correspondem a <paramref name="arguments" /> foi encontrado em <paramref name="type" /> ou em seus tipos base.  
  
- ou - 
Mais de um método cujo nome é <paramref name="methodName" />, cujos parâmetros de tipo correspondem a <paramref name="typeArguments" /> e cujos tipos de parâmetro correspondem a <paramref name="arguments" /> foi encontrado em <paramref name="type" /> ou em seus tipos base.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Call&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Method&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the specified &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) method, and the &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; property set to the specified arguments.">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definida como o <see cref="T:System.Reflection.MethodInfo" /> que representa o método <see langword="static" /> especificado (<see langword="Shared" /> no Visual Basic) e a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definida como os argumentos especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; representing a catch statement with a reference to the caught &lt;see cref=&quot;T:System.Exception&quot; /&gt; object for use in the handler body.">Cria uma <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch com uma referência para o objeto <see cref="T:System.Exception" /> capturado para uso no corpo do manipulador.</summary>
      <param name="variable" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; representing a reference to the &lt;see cref=&quot;T:System.Exception&quot; /&gt; object caught by this handler.">Uma <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa uma referência para o objeto <see cref="T:System.Exception" /> capturado por este manipulador.</param>
      <param name="body" vsli:raw="The body of the catch statement.">O corpo da instrução catch.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.CatchBlock" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; representing a catch statement with an &lt;see cref=&quot;T:System.Exception&quot; /&gt; filter and a reference to the caught &lt;see cref=&quot;T:System.Exception&quot; /&gt; object.">Cria uma <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch com um filtro <see cref="T:System.Exception" /> e uma referência para o objeto <see cref="T:System.Exception" /> capturado.</summary>
      <param name="variable" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; representing a reference to the &lt;see cref=&quot;T:System.Exception&quot; /&gt; object caught by this handler.">Uma <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa uma referência para o objeto <see cref="T:System.Exception" /> capturado por este manipulador.</param>
      <param name="body" vsli:raw="The body of the catch statement.">O corpo da instrução catch.</param>
      <param name="filter" vsli:raw="The body of the &lt;see cref=&quot;T:System.Exception&quot; /&gt; filter.">O corpo do filtro <see cref="T:System.Exception" />.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.CatchBlock" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; representing a catch statement.">Cria uma <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch.</summary>
      <param name="type" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; of &lt;see cref=&quot;T:System.Exception&quot; /&gt; this &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; will handle.">O <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que esse <see cref="T:System.Linq.Expressions.CatchBlock" /> tratará.</param>
      <param name="body" vsli:raw="The body of the catch statement.">O corpo da instrução catch.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.CatchBlock" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; representing a catch statement with an &lt;see cref=&quot;T:System.Exception&quot; /&gt; filter but no reference to the caught &lt;see cref=&quot;T:System.Exception&quot; /&gt; object.">Cria uma <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch com um filtro <see cref="T:System.Exception" />, mas nenhuma referência ao objeto <see cref="T:System.Exception" /> capturado.</summary>
      <param name="type" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; of &lt;see cref=&quot;T:System.Exception&quot; /&gt; this &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; will handle.">O <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que esse <see cref="T:System.Linq.Expressions.CatchBlock" /> tratará.</param>
      <param name="body" vsli:raw="The body of the catch statement.">O corpo da instrução catch.</param>
      <param name="filter" vsli:raw="The body of the &lt;see cref=&quot;T:System.Exception&quot; /&gt; filter.">O corpo do filtro <see cref="T:System.Exception" />.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.CatchBlock" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt; for clearing a sequence point.">Cria uma <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> para limpar um ponto de sequência.</summary>
      <param name="document" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt; that represents the source file.">O <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa o arquivo de origem.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt; for clearing a sequence point.">Uma instância de <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> para limpar um ponto de sequência.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a coalescing operation.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de união.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of &lt;paramref name=&quot;left&quot; /&gt; does not represent a reference type or a nullable value type.">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> do <paramref name="left" /> não representa um tipo de referência nem um tipo de valor que permite um valor null.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type are not convertible to each other.">
        <paramref name="left" />.Type e <paramref name="right" />.Type não são conversíveis entre si.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Coalesce&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a coalescing operation, given a conversion function.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de união, dada uma função de conversão.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type are not convertible to each other.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;conversion&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;conversion&quot; /&gt;.Type is a delegate type that does not take exactly one argument.">
        <paramref name="left" />.Type e <paramref name="right" />.Type não são conversíveis entre si.  
  
- ou - 
 <paramref name="conversion" /> não é <see langword="null" /> e <paramref name="conversion" />. O tipo é um tipo delegado que não aceita exatamente um argumento.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of &lt;paramref name=&quot;left&quot; /&gt; does not represent a reference type or a nullable value type.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of &lt;paramref name=&quot;left&quot; /&gt; represents a type that is not assignable to the parameter type of the delegate type &lt;paramref name=&quot;conversion&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of &lt;paramref name=&quot;right&quot; /&gt; is not equal to the return type of the delegate type &lt;paramref name=&quot;conversion&quot; /&gt;.Type.">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> do <paramref name="left" /> não representa um tipo de referência nem um tipo de valor que permite um valor null.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> representa um tipo que não é atribuível ao tipo de parâmetro do tipo delegado <paramref name="conversion" />.Type.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="right" /> não é igual ao tipo de retorno do tipo delegado <paramref name="conversion" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Coalesce&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; that represents a conditional statement.">Cria um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa uma instrução condicional.</summary>
      <param name="test" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> igual a ele.</param>
      <param name="ifTrue" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> igual a ele.</param>
      <param name="ifFalse" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfFalse&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;test&quot; /&gt; or &lt;paramref name=&quot;ifTrue&quot; /&gt; or &lt;paramref name=&quot;ifFalse&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="test" />, <paramref name="ifTrue" /> ou <paramref name="ifFalse" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;test&quot; /&gt;.Type is not &lt;see cref=&quot;T:System.Boolean&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;ifTrue&quot; /&gt;.Type is not equal to &lt;paramref name=&quot;ifFalse&quot; /&gt;.Type.">
        <paramref name="test" />.Type não é <see cref="T:System.Boolean" />.  
  
- ou - 
 <paramref name="ifTrue" />.Type não é igual a <paramref name="ifFalse" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Conditional&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfFalse&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e as propriedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; that represents a conditional statement.">Cria um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa uma instrução condicional.</summary>
      <param name="test" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> igual a ele.</param>
      <param name="ifTrue" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> igual a ele.</param>
      <param name="ifFalse" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfFalse&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> igual a ele.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Conditional&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfFalse&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e as propriedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ConstantExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.ConstantExpression.Value&quot; /&gt; property set to the specified value.">Cria uma <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> definida para o valor especificado.</summary>
      <param name="value" vsli:raw="An &lt;see cref=&quot;T:System.Object&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConstantExpression.Value&quot; /&gt; property equal to.">Um <see cref="T:System.Object" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ConstantExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Constant&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ConstantExpression.Value&quot; /&gt; property set to the specified value.">Uma <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> e a propriedade <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ConstantExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.ConstantExpression.Value&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; properties set to the specified values.">Cria uma <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tem as propriedades <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> definidas com os valores especificados.</summary>
      <param name="value" vsli:raw="An &lt;see cref=&quot;T:System.Object&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConstantExpression.Value&quot; /&gt; property equal to.">Um <see cref="T:System.Object" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> igual a ele.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;type&quot; /&gt; is not assignable from the dynamic type of &lt;paramref name=&quot;value&quot; /&gt;.">
        <paramref name="value" /> não é <see langword="null" /> e <paramref name="type" /> não pode ser atribuído do tipo dinâmico de <paramref name="value" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ConstantExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Constant&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ConstantExpression.Value&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> e as propriedades <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a continue statement.">Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução continue.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Continue, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, and a null value to be passed to the target label upon jumping.">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" /> e um valor nulo a ser passado para o rótulo de destino ao saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a continue statement with the specified type.">Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução continue com o tipo especificado.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <param name="type" vsli:raw="An &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Continue, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;paramref name=&quot;type&quot; /&gt;, and a null value to be passed to the target label upon jumping.">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" />, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e um valor nulo a ser passado para o rótulo de destino ao saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a type conversion operation.">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de conversão de tipo.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="No conversion operator is defined between &lt;paramref name=&quot;expression&quot; /&gt;.Type and &lt;paramref name=&quot;type&quot; /&gt;.">Não há nenhum operador de conversão definido entre <paramref name="expression" />.Type e <paramref name="type" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Convert&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a conversion operation for which the implementing method is specified.">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de conversão para a qual o método de implementação é especificado.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly one argument.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="No conversion operator is defined between &lt;paramref name=&quot;expression&quot; /&gt;.Type and &lt;paramref name=&quot;type&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type is not assignable to the argument type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The return type of the method represented by &lt;paramref name=&quot;method&quot; /&gt; is not assignable to &lt;paramref name=&quot;type&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type or &lt;paramref name=&quot;type&quot; /&gt; is a nullable value type and the corresponding non-nullable value type does not equal the argument type or the return type, respectively, of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">Não há nenhum operador de conversão definido entre <paramref name="expression" />.Type e <paramref name="type" />.  
  
- ou - 
 <paramref name="expression" />.Type não é atribuível ao tipo de argumento do método representado pelo <paramref name="method" />.  
  
- ou - 
O tipo de retorno do método representado por <paramref name="method" /> não é atribuível ao <paramref name="type" />.  
  
- ou - 
 <paramref name="expression" />.Type ou <paramref name="type" /> é um tipo de valor que permite valor nulo e o tipo de valor que não permite valor nulo correspondente não é igual ao tipo de argumento ou ao tipo de retorno, respectivamente, do método representado por <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException" vsli:raw="More than one method that matches the &lt;paramref name=&quot;method&quot; /&gt; description was found.">Foi encontrado mais de um método que corresponde à descrição de <paramref name="method" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Convert&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a conversion operation that throws an exception if the target type is overflowed.">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de conversão que lança uma exceção se o tipo de destino está estourado.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="No conversion operator is defined between &lt;paramref name=&quot;expression&quot; /&gt;.Type and &lt;paramref name=&quot;type&quot; /&gt;.">Não há nenhum operador de conversão definido entre <paramref name="expression" />.Type e <paramref name="type" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ConvertChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a conversion operation that throws an exception if the target type is overflowed and for which the implementing method is specified.">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de conversão que lança uma exceção se o tipo de destino está estourado e para o qual o método de implementação é especificado.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly one argument.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="No conversion operator is defined between &lt;paramref name=&quot;expression&quot; /&gt;.Type and &lt;paramref name=&quot;type&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type is not assignable to the argument type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The return type of the method represented by &lt;paramref name=&quot;method&quot; /&gt; is not assignable to &lt;paramref name=&quot;type&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type or &lt;paramref name=&quot;type&quot; /&gt; is a nullable value type and the corresponding non-nullable value type does not equal the argument type or the return type, respectively, of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">Não há nenhum operador de conversão definido entre <paramref name="expression" />.Type e <paramref name="type" />.  
  
- ou - 
 <paramref name="expression" />.Type não é atribuível ao tipo de argumento do método representado pelo <paramref name="method" />.  
  
- ou - 
O tipo de retorno do método representado por <paramref name="method" /> não é atribuível ao <paramref name="type" />.  
  
- ou - 
 <paramref name="expression" />.Type ou <paramref name="type" /> é um tipo de valor que permite valor nulo e o tipo de valor que não permite valor nulo correspondente não é igual ao tipo de argumento ou ao tipo de retorno, respectivamente, do método representado por <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException" vsli:raw="More than one method that matches the &lt;paramref name=&quot;method&quot; /&gt; description was found.">Foi encontrado mais de um método que corresponde à descrição de <paramref name="method" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ConvertChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt; with the specified span.">Cria uma <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> com o intervalo especificado.</summary>
      <param name="document" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt; that represents the source file.">O <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa o arquivo de origem.</param>
      <param name="startLine" vsli:raw="The start line of this &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;. Must be greater than 0.">A linha inicial deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Deve ser maior que 0.</param>
      <param name="startColumn" vsli:raw="The start column of this &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;. Must be greater than 0.">A coluna inicial deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Deve ser maior que 0.</param>
      <param name="endLine" vsli:raw="The end line of this &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;. Must be greater or equal than the start line.">A linha final deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Deve ser maior ou igual à linha inicial.</param>
      <param name="endColumn" vsli:raw="The end column of this &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;. If the end line is the same as the start line, it must be greater or equal than the start column. In any case, must be greater than 0.">A coluna final deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Se a linha final é a mesma que a linha inicial, ela deve ser maior ou igual à coluna inicial. Em qualquer caso, ela deve ser maior que 0.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;.">Uma instância de <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the decrementing of the expression by 1.">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa o decremento da expressão em 1.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to decrement.">Um <see cref="T:System.Linq.Expressions.Expression" /> para diminuir.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the decremented expression.">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão decrementada.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the decrementing of the expression by 1.">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa o decremento da expressão em 1.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to decrement.">Um <see cref="T:System.Linq.Expressions.Expression" /> para diminuir.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the decremented expression.">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão decrementada.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Default(System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DefaultExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to the specified type.">Cria um <see cref="T:System.Linq.Expressions.DefaultExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para o tipo especificado.</summary>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DefaultExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Default&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to the specified type.">Um <see cref="T:System.Linq.Expressions.DefaultExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> e a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para o tipo especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic division operation.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de divisão.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para o qual definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para o qual definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The division operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">O operador de divisão não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Divide&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic division operation. The implementing method can be specified.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de divisão. O método de implementação pode ser especificado.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the division operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> é <see langword="null" /> e o operador de divisão não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Divide&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a division assignment operation that does not have overflow checking.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de divisão de adição que não tem verificação de estouro.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.DivideAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a division assignment operation that does not have overflow checking.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de divisão de adição que não tem verificação de estouro.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.DivideAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a division assignment operation that does not have overflow checking.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de divisão de adição que não tem verificação de estouro.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.DivideAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">O associador de runtime para a operação dinâmica.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">O tipo de resultado da expressão dinâmica.</param>
      <param name="arguments" vsli:raw="The arguments to the dynamic operation.">Os argumentos para a operação dinâmica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem a <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">O associador de runtime para a operação dinâmica.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">O tipo de resultado da expressão dinâmica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">O primeiro argumento para a operação dinâmica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem a <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">O associador de runtime para a operação dinâmica.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">O tipo de resultado da expressão dinâmica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">O primeiro argumento para a operação dinâmica.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">O segundo argumento para a operação dinâmica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem a <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">O associador de runtime para a operação dinâmica.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">O tipo de resultado da expressão dinâmica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">O primeiro argumento para a operação dinâmica.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">O segundo argumento para a operação dinâmica.</param>
      <param name="arg2" vsli:raw="The third argument to the dynamic operation.">O terceiro argumento para a operação dinâmica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem a <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">O associador de runtime para a operação dinâmica.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">O tipo de resultado da expressão dinâmica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">O primeiro argumento para a operação dinâmica.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">O segundo argumento para a operação dinâmica.</param>
      <param name="arg2" vsli:raw="The third argument to the dynamic operation.">O terceiro argumento para a operação dinâmica.</param>
      <param name="arg3" vsli:raw="The fourth argument to the dynamic operation.">O quarto argumento para a operação dinâmica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem a <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">O associador de runtime para a operação dinâmica.</param>
      <param name="returnType" vsli:raw="The result type of the dynamic expression.">O tipo de resultado da expressão dinâmica.</param>
      <param name="arguments" vsli:raw="The arguments to the dynamic operation.">Os argumentos para a operação dinâmica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem a <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt;, given an &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; as the second argument.">Cria uma <see cref="T:System.Linq.Expressions.ElementInit" />, dado um <see cref="T:System.Collections.Generic.IEnumerable`1" /> como o segundo argumento.</summary>
      <param name="addMethod" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.AddMethod&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> igual a ele.</param>
      <param name="arguments" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to set the &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.Arguments&quot; /&gt; property equal to.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> igual aos quais definir a propriedade <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;addMethod&quot; /&gt; or &lt;paramref name=&quot;arguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="addMethod" /> ou <paramref name="arguments" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The method that &lt;paramref name=&quot;addMethod&quot; /&gt; represents is not named &quot;Add&quot; (case insensitive).  &#xA;  &#xA; -or-  &#xA;  &#xA; The method that &lt;paramref name=&quot;addMethod&quot; /&gt; represents is not an instance method.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;arguments&quot; /&gt; does not contain the same number of elements as the number of parameters for the method that &lt;paramref name=&quot;addMethod&quot; /&gt; represents.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of one or more elements of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the type of the corresponding parameter of the method that &lt;paramref name=&quot;addMethod&quot; /&gt; represents.">O método representado por <paramref name="addMethod" /> não é nomeado "Add" (não diferencia maiúsculas de minúsculas).  
  
- ou - 
O método representado por <paramref name="addMethod" /> não é um método de instância.  
  
- ou - 
 <paramref name="arguments" /> não contém o mesmo número de elementos que o número de parâmetros para o método representado por <paramref name="addMethod" />.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um ou mais elementos de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do método representado por <paramref name="addMethod" />.</exception>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.AddMethod&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.Arguments&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.ElementInit" /> que tem as propriedades <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> e <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt;, given an array of values as the second argument.">Cria uma <see cref="T:System.Linq.Expressions.ElementInit" />, dada uma matriz de valores como o segundo argumento.</summary>
      <param name="addMethod" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.AddMethod&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> igual a ele.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to set the &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.Arguments&quot; /&gt; property equal to.">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> igual aos quais definir a propriedade <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;addMethod&quot; /&gt; or &lt;paramref name=&quot;arguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="addMethod" /> ou <paramref name="arguments" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The method that addMethod represents is not named &quot;Add&quot; (case insensitive).  &#xA;  &#xA; -or-  &#xA;  &#xA; The method that addMethod represents is not an instance method.  &#xA;  &#xA; -or-  &#xA;  &#xA; arguments does not contain the same number of elements as the number of parameters for the method that addMethod represents.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of one or more elements of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the type of the corresponding parameter of the method that &lt;paramref name=&quot;addMethod&quot; /&gt; represents.">O método representado por addMethod não é nomeado "Add" (não diferencia maiúsculas de minúsculas).  
  
- ou - 
O método representado por addMethod não é um método de instância.  
  
- ou - 
arguments não contém o mesmo número de elementos que o número de parâmetros para o método representado por addMethod.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um ou mais elementos de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do método representado por <paramref name="addMethod" />.</exception>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.AddMethod&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.ElementInit.Arguments&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.ElementInit" /> que tem as propriedades <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> e <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Empty">
      <summary vsli:raw="Creates an empty expression that has &lt;see cref=&quot;T:System.Void&quot; /&gt; type.">Cria uma expressão vazia com o tipo <see cref="T:System.Void" />.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DefaultExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Default&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;see cref=&quot;T:System.Void&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.DefaultExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> e a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida como <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an equality comparison.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de igualdade.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The equality operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">O operador de igualdade não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Equal&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an equality comparison. The implementing method can be specified.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de igualdade. O método de implementação pode ser especificado.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="liftToNull" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;true&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the equality operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> é <see langword="null" /> e o operador de igualdade não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Equal&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise &lt;see langword=&quot;XOR&quot; /&gt; operation, using &lt;c&gt;op_ExclusiveOr&lt;/c&gt; for user-defined types.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="XOR" /> bit a bit, usando <c>op_ExclusiveOr</c> para tipos definidos pelo usuário.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see langword=&quot;XOR&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">O operador <see langword="XOR" /> não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ExclusiveOr&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise &lt;see langword=&quot;XOR&quot; /&gt; operation, using &lt;c&gt;op_ExclusiveOr&lt;/c&gt; for user-defined types. The implementing method can be specified.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="XOR" /> bit a bit, usando <c>op_ExclusiveOr</c> para tipos definidos pelo usuário. O método de implementação pode ser especificado.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the &lt;see langword=&quot;XOR&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> é <see langword="null" /> e o operador <see langword="XOR" /> não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ExclusiveOr&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise XOR assignment operation, using &lt;c&gt;op_ExclusiveOr&lt;/c&gt; for user-defined types.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição XOR bit a bit, usando <c>op_ExclusiveOr</c> para tipos definidos pelo usuário.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise XOR assignment operation, using &lt;c&gt;op_ExclusiveOr&lt;/c&gt; for user-defined types.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição XOR bit a bit, usando <c>op_ExclusiveOr</c> para tipos definidos pelo usuário.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise XOR assignment operation, using &lt;c&gt;op_ExclusiveOr&lt;/c&gt; for user-defined types.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição XOR bit a bit, usando <c>op_ExclusiveOr</c> para tipos definidos pelo usuário.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that represents accessing a field.">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a um campo.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; property equal to. For &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), &lt;paramref name=&quot;expression&quot; /&gt; must be &lt;see langword=&quot;null&quot; /&gt;.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> igual a ele. Para <see langword="static" /> (<see langword="Shared" /> no Visual Basic), <paramref name="expression" /> deve ser <see langword="null" />.</param>
      <param name="field" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.FieldInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Member&quot; /&gt; property equal to.">O <see cref="T:System.Reflection.FieldInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> propriedade será definida.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;field&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The field represented by &lt;paramref name=&quot;field&quot; /&gt; is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) and &lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="field" /> é <see langword="null" />.  
  
- ou - 
O campo representado por <paramref name="field" /> não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) e <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt;.Type is not assignable to the declaring type of the field represented by &lt;paramref name=&quot;field&quot; /&gt;.">
        <paramref name="expression" />.Type não pode ser atribuído ao tipo declarativo do campo representado por <paramref name="field" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MemberAccess&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Member&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> e <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that represents accessing a field given the name of the field.">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a um campo dado o nome do campo.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; whose &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; contains a field named &lt;paramref name=&quot;fieldName&quot; /&gt;. This can be null for static fields.">Um <see cref="T:System.Linq.Expressions.Expression" /> cujo <see cref="P:System.Linq.Expressions.Expression.Type" /> contém um campo chamado <paramref name="fieldName" />. Pode ser nulo para campos estáticos.</param>
      <param name="fieldName" vsli:raw="The name of a field to be accessed.">O nome de um campo a ser acessado.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;fieldName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> ou <paramref name="fieldName" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="No field named &lt;paramref name=&quot;fieldName&quot; /&gt; is defined in &lt;paramref name=&quot;expression&quot; /&gt;.Type or its base types.">Nenhum campo nomeado <paramref name="fieldName" /> é definido no tipo <paramref name="expression" /> ou em seus tipos base.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MemberAccess&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; property set to &lt;paramref name=&quot;expression&quot; /&gt;, and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.FieldInfo&quot; /&gt; that represents the field denoted by &lt;paramref name=&quot;fieldName&quot; /&gt;.">Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> definida como <paramref name="expression" /> e a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definida como o <see cref="T:System.Reflection.FieldInfo" /> que representa o campo indicado por <paramref name="fieldName" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that represents accessing a field.">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a um campo.</summary>
      <param name="expression" vsli:raw="The containing object of the field. This can be null for static fields.">O objeto recipiente do campo. Pode ser nulo para campos estáticos.</param>
      <param name="type" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; that contains the field.">O <see cref="P:System.Linq.Expressions.Expression.Type" /> que contém o campo.</param>
      <param name="fieldName" vsli:raw="The field to be accessed.">O campo a ser acessado.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.MemberExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Type&quot; /&gt; object that represents a generic &lt;see cref=&quot;T:System.Action&quot; /&gt; delegate type that has specific type arguments.">Cria um objeto <see cref="T:System.Type" /> que representa um tipo de delegado genérico <c>System.Action</c> que tem argumentos de tipo específicos.</summary>
      <param name="typeArgs" vsli:raw="An array of up to sixteen &lt;see cref=&quot;T:System.Type&quot; /&gt; objects that specify the type arguments for the &lt;see cref=&quot;T:System.Action&quot; /&gt; delegate type.">Uma matriz de um a dezesseis objetos <see cref="T:System.Type" /> que especifica os argumentos de tipo para o tipo de delegado <see langword="System.Action" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;typeArgs&quot; /&gt; contains more than sixteen elements.">
        <paramref name="typeArgs" /> contém mais de dezesseis elementos.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;typeArgs&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="typeArgs" /> é <see langword="null" />.</exception>
      <returns vsli:raw="The type of a &lt;see cref=&quot;T:System.Action&quot; /&gt; delegate that has the specified type arguments.">O tipo de um delegado <c>System.Action</c> que tem os argumentos de tipo especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])">
      <summary vsli:raw="Gets a &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; object that represents a generic &lt;see cref=&quot;T:System.Func`1&quot; /&gt; or &lt;see cref=&quot;T:System.Action&quot; /&gt; delegate type that has specific type arguments.">Obtém um objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa um tipo de delegado genérico <c>System.Func</c> ou <c>System.Action</c> que tem argumentos de tipo específicos.</summary>
      <param name="typeArgs" vsli:raw="The type arguments of the delegate.">Os argumentos de tipo do delegado.</param>
      <returns vsli:raw="The delegate type.">O tipo de delegado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; object that represents a generic &lt;see cref=&quot;T:System.Func`1&quot; /&gt; delegate type that has specific type arguments. The last type argument specifies the return type of the created delegate.">Cria um objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa um tipo de delegado genérico <c>System.Func</c>, que tem argumentos de tipo específicos. O último argumento de tipo especifica o tipo de retorno do delegado criado.</summary>
      <param name="typeArgs" vsli:raw="An array of one to seventeen &lt;see cref=&quot;T:System.Type&quot; /&gt; objects that specify the type arguments for the &lt;see langword=&quot;System.Func&quot; /&gt; delegate type.">Uma matriz de um a dezessete objetos <see cref="T:System.Type" /> que especifica os argumentos de tipo para o tipo de delegado <see langword="System.Func" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;typeArgs&quot; /&gt; contains fewer than one or more than seventeen elements.">
        <paramref name="typeArgs" /> contém menos de um ou mais de dezessete elementos.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;typeArgs&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="typeArgs" /> é <see langword="null" />.</exception>
      <returns vsli:raw="The type of a &lt;see cref=&quot;T:System.Func`1&quot; /&gt; delegate that has the specified type arguments.">O tipo de um delegado <c>System.Func</c> que tem os argumentos de tipo especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a &quot;go to&quot; statement.">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução "go to".</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Goto, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to the specified value, and a null value to be passed to the target label upon jumping.">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para o valor especificado e um valor nulo a ser passado para o rótulo de destino após saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a &quot;go to&quot; statement. The value passed to the label upon jumping can be specified.">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução "go to". O valor passado para o rótulo no salto pode ser especificado.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <param name="value" vsli:raw="The value that will be passed to the associated label upon jumping.">O valor que será passado para o rótulo associado ao saltar.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Goto, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, and &lt;paramref name=&quot;value&quot; /&gt; to be passed to the target label upon jumping.">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" /> e <paramref name="value" /> a ser passado para o rótulo de destino ao saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a &quot;go to&quot; statement with the specified type. The value passed to the label upon jumping can be specified.">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução "go to" com o tipo especificado. O valor passado para o rótulo no salto pode ser especificado.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <param name="value" vsli:raw="The value that will be passed to the associated label upon jumping.">O valor que será passado para o rótulo associado ao saltar.</param>
      <param name="type" vsli:raw="An &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Goto, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;paramref name=&quot;type&quot; /&gt;, and &lt;paramref name=&quot;value&quot; /&gt; to be passed to the target label upon jumping.">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" />, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e <paramref name="value" /> a ser passado para o rótulo de destino ao saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a &quot;go to&quot; statement with the specified type.">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução "go to" com o tipo especificado.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <param name="type" vsli:raw="An &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Goto, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to the specified value, the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;paramref name=&quot;type&quot; /&gt;, and a null value to be passed to the target label upon jumping.">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para o valor especificado, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e um valor nulo a serem passados para o rótulo de destino após saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a &quot;greater than&quot; numeric comparison.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "maior que".</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &quot;greater than&quot; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">O operador “maior que” não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.GreaterThan&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a &quot;greater than&quot; numeric comparison. The implementing method can be specified.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "maior que". O método de implementação pode ser especificado.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="liftToNull" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;true&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the &quot;greater than&quot; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> é <see langword="null" /> e o operador "maior que" não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.GreaterThan&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a &quot;greater than or equal&quot; numeric comparison.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "maior ou igual a".</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &quot;greater than or equal&quot; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">O operador “maior ou igual a” não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a &quot;greater than or equal&quot; numeric comparison.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "maior ou igual a".</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="liftToNull" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;true&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the &quot;greater than or equal&quot; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> é <see langword="null" /> e o operador "maior ou igual a" não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; that represents a conditional block with an &lt;see langword=&quot;if&quot; /&gt; statement.">Cria um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa um bloco condicional com uma instrução <see langword="if" />.</summary>
      <param name="test" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> igual a ele.</param>
      <param name="ifTrue" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Conditional&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt;, properties set to the specified values. The &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfFalse&quot; /&gt; property is set to default expression and the type of the resulting &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; returned by this method is &lt;see cref=&quot;T:System.Void&quot; /&gt;.">Um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e as propriedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> definidas como os valores especificados. A propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> foi definida como a expressão padrão e o tipo do <see cref="T:System.Linq.Expressions.ConditionalExpression" /> resultante retornado por esse método é <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; that represents a conditional block with &lt;see langword=&quot;if&quot; /&gt; and &lt;see langword=&quot;else&quot; /&gt; statements.">Cria um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa um bloco condicional com as instruções <see langword="if" /> e <see langword="else" />.</summary>
      <param name="test" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> igual a ele.</param>
      <param name="ifTrue" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> igual a ele.</param>
      <param name="ifFalse" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfFalse&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Conditional&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.Test&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfTrue&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.ConditionalExpression.IfFalse&quot; /&gt; properties set to the specified values. The type of the resulting &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt; returned by this method is &lt;see cref=&quot;T:System.Void&quot; /&gt;.">Um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e as propriedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> definidas com os valores especificados. O tipo de <see cref="T:System.Linq.Expressions.ConditionalExpression" /> resultante retornado por esse método é <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the incrementing of the expression value by 1.">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa o incremento do valor da expressão em 1.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to increment.">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser incrementado.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the incremented expression.">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão incrementada.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the incrementing of the expression by 1.">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa o incremento da expressão em 1.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to increment.">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser incrementado.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the incremented expression.">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão incrementada.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.InvocationExpression&quot; /&gt; that applies a delegate or lambda expression to a list of argument expressions.">Cria um <see cref="T:System.Linq.Expressions.InvocationExpression" /> que se aplica a uma expressão de delegado ou lambda para uma lista de expressões de argumento.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the delegate or lambda expression to be applied to.">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa a expressão de delegado ou lambda à qual aplicar.</param>
      <param name="arguments" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that represent the arguments that the delegate or lambda expression is applied to.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> que representam os argumentos aos quais a expressão de delegado ou lambda é aplicada.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt;.Type does not represent a delegate type or an &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the type of the corresponding parameter of the delegate represented by &lt;paramref name=&quot;expression&quot; /&gt;.">
        <paramref name="expression" />.Type não representa um tipo de delegado nem um <see cref="T:System.Linq.Expressions.Expression`1" />.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não é atribuível ao tipo de parâmetro correspondente ao delegado representado por <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;arguments&quot; /&gt; does not contain the same number of elements as the list of parameters for the delegate represented by &lt;paramref name=&quot;expression&quot; /&gt;.">
        <paramref name="arguments" /> não contém o mesmo número de elementos da lista de parâmetros para o delegado representado por <paramref name="expression" />.</exception>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.InvocationExpression&quot; /&gt; that applies the specified delegate or lambda expression to the provided arguments.">Um <see cref="T:System.Linq.Expressions.InvocationExpression" /> que se aplica à expressão de delegado ou lambda especificada para os argumentos fornecidos.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.InvocationExpression&quot; /&gt; that applies a delegate or lambda expression to a list of argument expressions.">Cria um <see cref="T:System.Linq.Expressions.InvocationExpression" /> que se aplica a uma expressão de delegado ou lambda para uma lista de expressões de argumento.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the delegate or lambda expression to be applied.">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa a expressão de delegado ou lambda a ser aplicada.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that represent the arguments that the delegate or lambda expression is applied to.">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representam os argumentos aos quais que a expressão de delegado ou lambda são aplicados.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt;.Type does not represent a delegate type or an &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the type of the corresponding parameter of the delegate represented by &lt;paramref name=&quot;expression&quot; /&gt;.">
        <paramref name="expression" />.Type não representa um tipo de delegado nem um <see cref="T:System.Linq.Expressions.Expression`1" />.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não é atribuível ao tipo de parâmetro correspondente ao delegado representado por <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;arguments&quot; /&gt; does not contain the same number of elements as the list of parameters for the delegate represented by &lt;paramref name=&quot;expression&quot; /&gt;.">
        <paramref name="arguments" /> não contém o mesmo número de elementos da lista de parâmetros para o delegado representado por <paramref name="expression" />.</exception>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.InvocationExpression&quot; /&gt; that applies the specified delegate or lambda expression to the provided arguments.">Um <see cref="T:System.Linq.Expressions.InvocationExpression" /> que se aplica à expressão de delegado ou lambda especificada para os argumentos fornecidos.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Returns whether the expression evaluates to false.">Retorna se a expressão é avaliada como false.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to evaluate.">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser avaliado.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;.">Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Returns whether the expression evaluates to false.">Retorna se a expressão é avaliada como false.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to evaluate.">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser avaliado.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;.">Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Returns whether the expression evaluates to true.">Retorna se a expressão é avaliada como true.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to evaluate.">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser avaliado.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;.">Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Returns whether the expression evaluates to true.">Retorna se a expressão é avaliada como true.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to evaluate.">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser avaliado.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;.">Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; representing a label with void type and no name.">Cria um <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa um rótulo com um tipo void e sem nenhum nome.</summary>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt;.">O novo <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt; representing a label without a default value.">Cria um <see cref="T:System.Linq.Expressions.LabelExpression" /> que representa um rótulo com um valor padrão.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; which this &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt; will be associated with.">O <see cref="T:System.Linq.Expressions.LabelTarget" /> ao qual esse <see cref="T:System.Linq.Expressions.LabelExpression" /> será associado.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt; without a default value.">Um <see cref="T:System.Linq.Expressions.LabelExpression" /> sem um valor padrão.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt; representing a label with the given default value.">Cria um <see cref="T:System.Linq.Expressions.LabelExpression" /> que representa um rótulo com o valor padrão fornecido.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; which this &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt; will be associated with.">O <see cref="T:System.Linq.Expressions.LabelTarget" /> ao qual esse <see cref="T:System.Linq.Expressions.LabelExpression" /> será associado.</param>
      <param name="defaultValue" vsli:raw="The value of this &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt; when the label is reached through regular control flow.">O valor desse <see cref="T:System.Linq.Expressions.LabelExpression" /> quando o rótulo é acessado por meio de fluxo de controle normal.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt; with the given default value.">Um <see cref="T:System.Linq.Expressions.LabelExpression" /> com o valor padrão fornecido.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; representing a label with void type and the given name.">Cria um <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa um rótulo com um tipo void e o nome fornecido.</summary>
      <param name="name" vsli:raw="The name of the label.">O nome do rótulo.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt;.">O novo <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; representing a label with the given type.">Cria um <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa um rótulo com o tipo fornecido.</summary>
      <param name="type" vsli:raw="The type of value that is passed when jumping to the label.">O tipo de valor que é passado ao saltar para o rótulo.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt;.">O novo <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; representing a label with the given type and name.">Cria um <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa um rótulo com o tipo e nome fornecidos.</summary>
      <param name="type" vsli:raw="The type of value that is passed when jumping to the label.">O tipo de valor que é passado ao saltar para o rótulo.</param>
      <param name="name" vsli:raw="The name of the label.">O nome do rótulo.</param>
      <returns vsli:raw="The new &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt;.">O novo <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; by first constructing a delegate type from the expression body, a parameter that indicates whether tail call optimization will be applied, and an enumerable collection of parameter expressions. It can be used when the delegate type is not known at compile time.">Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> construindo primeiro um tipo delegado do corpo da expressão, um parâmetro que indica se a otimização da parte final da chamada será aplicada e uma coleção enumerável de expressões de parâmetro. Ele pode ser usado quando o tipo de delegado não é conhecido em tempo de compilação.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; by first constructing a delegate type from the expression body, a parameter that indicates whether tail call optimization will be applied, and an array of parameter expressions. It can be used when the delegate type is not known at compile time.">Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> construindo primeiro um tipo delegado do corpo da expressão, um parâmetro que indica se a otimização da parte final da chamada será aplicada e uma matriz de expressões de parâmetro. Ele pode ser usado quando o tipo de delegado não é conhecido em tempo de compilação.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
      <param name="parameters" vsli:raw="An array that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Uma matriz que contém os objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; by first constructing a delegate type from the expression body, and an enumerable collection of parameter expressions. It can be used when the delegate type is not known at compile time.">Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> construindo primeiro um tipo delegado do corpo da expressão e uma coleção enumerável de expressões de parâmetro. Ele pode ser usado quando o tipo de delegado não é conhecido em tempo de compilação.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; by first constructing a delegate type from the expression body, and an array of parameter expressions. It can be used when the delegate type is not known at compile time.">Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> construindo primeiro um tipo delegado do corpo da expressão e uma matriz de expressões de parâmetro. Ele pode ser usado quando o tipo de delegado não é conhecido em tempo de compilação.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="parameters" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;body&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;parameters&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="body" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos de <paramref name="parameters" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;parameters&quot; /&gt; contains more than sixteen elements.">
        <paramref name="parameters" /> contém mais de dezesseis elementos.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; by first constructing a delegate type from the expression body, the name for the lambda, a parameter that indicates whether tail call optimization will be applied, and an enumerable collection of parameter expressions. It can be used when the delegate type is not known at compile time.">Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> construindo primeiro um tipo delegado do corpo da expressão, o nome do lambda, um parâmetro que indica se a otimização da parte final da chamada será aplicada e uma coleção enumerável de expressões de parâmetro. Ele pode ser usado quando o tipo de delegado não é conhecido em tempo de compilação.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="name" vsli:raw="The name for the lambda. Used for emitting debug information.">O nome para o lambda. Usada para emitir informações de depuração.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; by first constructing a delegate type from the expression body, the name for the lambda, and an enumerable collection of parameter expressions. It can be used when the delegate type is not known at compile time.">Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> construindo primeiro um tipo delegado do corpo da expressão, o nome do lambda e uma coleção enumerável de expressões de parâmetro. Ele pode ser usado quando o tipo de delegado não é conhecido em tempo de compilação.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="name" vsli:raw="The name for the lambda. Used for emitting debug information.">O nome para o lambda. Usada para emitir informações de depuração.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; where the delegate type is known at compile time, with a parameter that indicates whether tail call optimization will be applied, and an enumerable collection of parameter expressions.">Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> em que o tipo delegado é conhecido no tempo de compilação, com um parâmetro que indica se a otimização da parte final da chamada será aplicada e uma coleção enumerável de expressões de parâmetro.</summary>
      <param name="delegateType" vsli:raw="A &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; representing the delegate signature for the lambda.">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa a assinatura de delegado para o lambda.</param>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; where the delegate type is known at compile time, with a parameter that indicates whether tail call optimization will be applied, and an array of parameter expressions.">Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> em que o tipo delegado é conhecido no tempo de compilação, com um parâmetro que indica se a otimização da parte final da chamada será aplicada e uma matriz de expressões de parâmetro.</summary>
      <param name="delegateType" vsli:raw="A &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; representing the delegate signature for the lambda.">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa a assinatura de delegado para o lambda.</param>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
      <param name="parameters" vsli:raw="An array that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Uma matriz que contém os objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; where the delegate type is known at compile time, with an enumerable collection of parameter expressions.">Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> em que o tipo delegado é conhecido no tempo de compilação, com uma coleção enumerável de expressões de parâmetro.</summary>
      <param name="delegateType" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents a delegate signature for the lambda.">Um <see cref="T:System.Type" /> que representa uma assinatura de delegado para lambda.</param>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;delegateType&quot; /&gt; or &lt;paramref name=&quot;body&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements in &lt;paramref name=&quot;parameters&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="delegateType" /> ou <paramref name="body" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos em <paramref name="parameters" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;delegateType&quot; /&gt; does not represent a delegate type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;body&quot; /&gt;.Type represents a type that is not assignable to the return type of the delegate type represented by &lt;paramref name=&quot;delegateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;parameters&quot; /&gt; does not contain the same number of elements as the list of parameters for the delegate type represented by &lt;paramref name=&quot;delegateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;parameters&quot; /&gt; is not assignable from the type of the corresponding parameter type of the delegate type represented by &lt;paramref name=&quot;delegateType&quot; /&gt;.">
        <paramref name="delegateType" /> não representa um tipo de delegado.  
  
- ou - 
 <paramref name="body" />.Type representa um tipo que não é atribuível ao tipo de retorno do tipo de delegado representado por <paramref name="delegateType" />.  
  
- ou - 
 <paramref name="parameters" /> não contém o mesmo número de elementos da lista de parâmetros para o tipo de delegado representado por <paramref name="delegateType" />.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="parameters" /> não é atribuível do tipo de parâmetro correspondente do tipo de delegado representado por <paramref name="delegateType" />.</exception>
      <returns vsli:raw="An object that represents a lambda expression which has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">Um objeto que representa uma expressão lambda que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; where the delegate type is known at compile time, with an array of parameter expressions.">Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> em que o tipo delegado é conhecido no tempo de compilação, com uma matriz de expressões de parâmetro.</summary>
      <param name="delegateType" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents a delegate signature for the lambda.">Um <see cref="T:System.Type" /> que representa uma assinatura de delegado para lambda.</param>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="parameters" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;delegateType&quot; /&gt; or &lt;paramref name=&quot;body&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements in &lt;paramref name=&quot;parameters&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="delegateType" /> ou <paramref name="body" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos em <paramref name="parameters" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;delegateType&quot; /&gt; does not represent a delegate type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;body&quot; /&gt;.Type represents a type that is not assignable to the return type of the delegate type represented by &lt;paramref name=&quot;delegateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;parameters&quot; /&gt; does not contain the same number of elements as the list of parameters for the delegate type represented by &lt;paramref name=&quot;delegateType&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;parameters&quot; /&gt; is not assignable from the type of the corresponding parameter type of the delegate type represented by &lt;paramref name=&quot;delegateType&quot; /&gt;.">
        <paramref name="delegateType" /> não representa um tipo de delegado.  
  
- ou - 
 <paramref name="body" />.Type representa um tipo que não é atribuível ao tipo de retorno do tipo de delegado representado por <paramref name="delegateType" />.  
  
- ou - 
 <paramref name="parameters" /> não contém o mesmo número de elementos da lista de parâmetros para o tipo de delegado representado por <paramref name="delegateType" />.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="parameters" /> não é atribuível do tipo de parâmetro correspondente do tipo de delegado representado por <paramref name="delegateType" />.</exception>
      <returns vsli:raw="An object that represents a lambda expression which has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">Um objeto que representa uma expressão lambda que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; where the delegate type is known at compile time, with the name for the lambda, a parameter that indicates whether tail call optimization will be applied, and an enumerable collection of parameter expressions.">Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> em que o tipo delegado é conhecido no tempo de compilação, com o nome do lambda, um parâmetro que indica se a otimização da parte final da chamada será aplicada e uma coleção enumerável de expressões de parâmetro.</summary>
      <param name="delegateType" vsli:raw="A &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; representing the delegate signature for the lambda.">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa a assinatura de delegado para o lambda.</param>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="name" vsli:raw="The name for the lambda. Used for emitting debug information.">O nome para o lambda. Usada para emitir informações de depuração.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; where the delegate type is known at compile time, with the name for the lambda, and an enumerable collection of parameter expressions.">Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> em que o tipo delegado é conhecido no tempo de compilação, com o nome do lambda e uma coleção enumerável de expressões de parâmetro.</summary>
      <param name="delegateType" vsli:raw="A &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; representing the delegate signature for the lambda.">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa a assinatura de delegado para o lambda.</param>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="name" vsli:raw="The name for the lambda. Used for emitting debug information.">O nome para o lambda. Usada para emitir informações de depuração.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to Lambda and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; where the delegate type is known at compile time, with a parameter that indicates whether tail call optimization will be applied, and an enumerable collection of parameter expressions.">Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> em que o tipo delegado é conhecido no tempo de compilação, com um parâmetro que indica se a otimização da parte final da chamada será aplicada e uma coleção enumerável de expressões de parâmetro.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate" vsli:raw="The delegate type.">O tipo de delegado.</typeparam>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; where the delegate type is known at compile time, with a parameter that indicates whether tail call optimization will be applied, and an array of parameter expressions.">Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> em que o tipo delegado é conhecido no tempo de compilação, com um parâmetro que indica se a otimização da parte final da chamada será aplicada e uma matriz de expressões de parâmetro.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
      <param name="parameters" vsli:raw="An array that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Uma matriz que contém os objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate" vsli:raw="The delegate type.">O tipo de delegado.</typeparam>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; where the delegate type is known at compile time, with an enumerable collection of parameter expressions.">Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> em que o tipo delegado é conhecido no tempo de compilação, com uma coleção enumerável de expressões de parâmetro.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate" vsli:raw="A delegate type.">Um tipo de delegado.</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;body&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements in &lt;paramref name=&quot;parameters&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="body" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos em <paramref name="parameters" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;TDelegate&quot; /&gt; is not a delegate type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;body&quot; /&gt;.Type represents a type that is not assignable to the return type of &lt;paramref name=&quot;TDelegate&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;parameters&quot; /&gt; does not contain the same number of elements as the list of parameters for &lt;paramref name=&quot;TDelegate&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;parameters&quot; /&gt; is not assignable from the type of the corresponding parameter type of &lt;paramref name=&quot;TDelegate&quot; /&gt;.">
        <paramref name="TDelegate" /> não é um tipo de delegado.  
  
- ou - 
 <paramref name="body" />.Type representa um tipo que não pode ser atribuído ao tipo de retorno de <paramref name="TDelegate" />.  
  
- ou - 
 <paramref name="parameters" /> não contém o mesmo número de elementos que a lista de parâmetros de <paramref name="TDelegate" />.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="parameters" /> não pode ser atribuída do tipo de parâmetro correspondente de <paramref name="TDelegate" />.</exception>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; where the delegate type is known at compile time, with an array of parameter expressions.">Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> em que o tipo delegado é conhecido no tempo de compilação, com uma matriz de expressões de parâmetro.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="parameters" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate" vsli:raw="A delegate type.">Um tipo de delegado.</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;body&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements in &lt;paramref name=&quot;parameters&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="body" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos em <paramref name="parameters" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;TDelegate&quot; /&gt; is not a delegate type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;body&quot; /&gt;.Type represents a type that is not assignable to the return type of &lt;paramref name=&quot;TDelegate&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;parameters&quot; /&gt; does not contain the same number of elements as the list of parameters for &lt;paramref name=&quot;TDelegate&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;parameters&quot; /&gt; is not assignable from the type of the corresponding parameter type of &lt;paramref name=&quot;TDelegate&quot; /&gt;.">
        <paramref name="TDelegate" /> não é um tipo de delegado.  
  
- ou - 
 <paramref name="body" />.Type representa um tipo que não pode ser atribuído ao tipo de retorno de <paramref name="TDelegate" />.  
  
- ou - 
 <paramref name="parameters" /> não contém o mesmo número de elementos que a lista de parâmetros de <paramref name="TDelegate" />.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="parameters" /> não pode ser atribuída do tipo de parâmetro correspondente de <paramref name="TDelegate" />.</exception>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; where the delegate type is known at compile time, with the name for the lambda, a parameter that indicates whether tail call optimization will be applied, and an enumerable collection of parameter expressions.">Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> em que o tipo delegado é conhecido no tempo de compilação, com o nome do lambda, um parâmetro que indica se a otimização da parte final da chamada será aplicada e uma coleção enumerável de expressões de parâmetro.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="name" vsli:raw="The name of the lambda. Used for generating debugging info.">O nome do lambda. Usado para gerar informações de depuração.</param>
      <param name="tailCall" vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; that indicates if tail call optimization will be applied when compiling the created expression.">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate" vsli:raw="The delegate type.">O tipo de delegado.</typeparam>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; where the delegate type is known at compile time, with the name for the lambda, and an enumerable collection of parameter expressions.">Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> em que o tipo delegado é conhecido no tempo de compilação, com o nome do lambda e uma coleção enumerável de expressões de parâmetro.</summary>
      <param name="body" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
      <param name="name" vsli:raw="The name of the lambda. Used for generating debugging information.">O nome do lambda. Usado para gerar informações de depuração.</param>
      <param name="parameters" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate" vsli:raw="The delegate type.">O tipo de delegado.</typeparam>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Lambda&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise left-shift operation.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de deslocamento à esquerda bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The left-shift operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">O operador de deslocamento à esquerda não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LeftShift&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise left-shift operation.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de deslocamento à esquerda bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the left-shift operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> é <see langword="null" /> e o operador de deslocamento à esquerda não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LeftShift&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise left-shift assignment operation.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à esquerda bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LeftShiftAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise left-shift assignment operation.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à esquerda bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LeftShiftAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise left-shift assignment operation.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à esquerda bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LeftShiftAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a &quot;less than&quot; numeric comparison.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "menor que".</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &quot;less than&quot; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">O operador “menor que” não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LessThan&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a &quot;less than&quot; numeric comparison.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "menor que".</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="liftToNull" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;true&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the &quot;less than&quot; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> é <see langword="null" /> e o operador "menor que" não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LessThan&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a &quot; less than or equal&quot; numeric comparison.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "menor ou igual a".</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &quot;less than or equal&quot; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">O operador "menor ou igual a" não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LessThanOrEqual&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a &quot;less than or equal&quot; numeric comparison.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "menor ou igual a".</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="liftToNull" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;true&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the &quot;less than or equal&quot; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> é <see langword="null" /> e o operador "menor ou igual a" não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.LessThanOrEqual&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt; where the member is a field or property.">Cria um <see cref="T:System.Linq.Expressions.MemberListBinding" /> em que o membro é um campo ou propriedade.</summary>
      <param name="member" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; that represents a field or property to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MemberInfo" /> que representa um campo ou propriedade igual à qual definir a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="initializers" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="member" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; does not represent a field or property.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Reflection.FieldInfo.FieldType&quot; /&gt; or &lt;see cref=&quot;P:System.Reflection.PropertyInfo.PropertyType&quot; /&gt; of the field or property that &lt;paramref name=&quot;member&quot; /&gt; represents does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.">
        <paramref name="member" /> não representa um campo ou propriedade.  
  
- ou - 
O <see cref="P:System.Reflection.FieldInfo.FieldType" /> ou <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> do campo ou propriedade representada por <paramref name="member" /> não implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.ListBinding&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.MemberListBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt; where the member is a field or property.">Cria um <see cref="T:System.Linq.Expressions.MemberListBinding" /> em que o membro é um campo ou propriedade.</summary>
      <param name="member" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; that represents a field or property to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MemberInfo" /> que representa um campo ou propriedade igual à qual definir a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="initializers" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; collection.">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="member" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; does not represent a field or property.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Reflection.FieldInfo.FieldType&quot; /&gt; or &lt;see cref=&quot;P:System.Reflection.PropertyInfo.PropertyType&quot; /&gt; of the field or property that &lt;paramref name=&quot;member&quot; /&gt; represents does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.">
        <paramref name="member" /> não representa um campo ou propriedade.  
  
- ou - 
O <see cref="P:System.Reflection.FieldInfo.FieldType" /> ou <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> do campo ou propriedade representada por <paramref name="member" /> não implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.ListBinding&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.MemberListBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt; based on a specified property accessor method.">Cria um <see cref="T:System.Linq.Expressions.MemberListBinding" /> com base em um método de acessador de propriedade especificado.</summary>
      <param name="propertyAccessor" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents a property accessor method.">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</param>
      <param name="initializers" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="propertyAccessor" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; does not represent a property accessor method.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Reflection.PropertyInfo.PropertyType&quot; /&gt; of the property that the method represented by &lt;paramref name=&quot;propertyAccessor&quot; /&gt; accesses does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.">
        <paramref name="propertyAccessor" /> não representa um método de acessador de propriedade.  
  
- ou - 
O <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> da propriedade acessada pelo método representado por <paramref name="propertyAccessor" /> não implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.ListBinding&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; that represents the property accessed in &lt;paramref name=&quot;propertyAccessor&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; populated with the elements of &lt;paramref name=&quot;initializers&quot; /&gt;.">Um <see cref="T:System.Linq.Expressions.MemberListBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> definida para o <see cref="T:System.Reflection.MemberInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" /> e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populada com os elementos de <paramref name="initializers" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt; object based on a specified property accessor method.">Cria um objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> com base em um método de acessador de propriedade especificado.</summary>
      <param name="propertyAccessor" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents a property accessor method.">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</param>
      <param name="initializers" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; collection.">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="propertyAccessor" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; does not represent a property accessor method.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Reflection.PropertyInfo.PropertyType&quot; /&gt; of the property that the method represented by &lt;paramref name=&quot;propertyAccessor&quot; /&gt; accesses does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.">
        <paramref name="propertyAccessor" /> não representa um método de acessador de propriedade.  
  
- ou - 
O <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> da propriedade acessada pelo método representado por <paramref name="propertyAccessor" /> não implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.ListBinding&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; that represents the property accessed in &lt;paramref name=&quot;propertyAccessor&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; populated with the elements of &lt;paramref name=&quot;initializers&quot; /&gt;.">Um <see cref="T:System.Linq.Expressions.MemberListBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> definida para o <see cref="T:System.Reflection.MemberInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" /> e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populada com os elementos de <paramref name="initializers" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that uses specified &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to initialize a collection.">Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa objetos <see cref="T:System.Linq.Expressions.ElementInit" /> especificados para inicializar uma coleção.</summary>
      <param name="newExpression" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</param>
      <param name="initializers" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt; or &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt;.Type does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.">
        <paramref name="newExpression" />.Type não implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ListInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e as propriedades <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that uses a method named &quot;Add&quot; to add elements to a collection.">Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa um método chamado "Add" para adicionar elementos a uma coleção.</summary>
      <param name="newExpression" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</param>
      <param name="initializers" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt; or &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt;.Type does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.">
        <paramref name="newExpression" />.Type não implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="There is no instance method named &quot;Add&quot; (case insensitive) declared in &lt;paramref name=&quot;newExpression&quot; /&gt;.Type or its base type.  &#xA;  &#xA; -or-  &#xA;  &#xA; The add method on &lt;paramref name=&quot;newExpression&quot; /&gt;.Type or its base type does not take exactly one argument.  &#xA;  &#xA; -or-  &#xA;  &#xA; The type represented by the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of the first element of &lt;paramref name=&quot;initializers&quot; /&gt; is not assignable to the argument type of the add method on &lt;paramref name=&quot;newExpression&quot; /&gt;.Type or its base type.  &#xA;  &#xA; -or-  &#xA;  &#xA; More than one argument-compatible method named &quot;Add&quot; (case-insensitive) exists on &lt;paramref name=&quot;newExpression&quot; /&gt;.Type and/or its base type.">Não há nenhum método de instância nomeado "Add" (não diferencia maiúsculas de minúsculas) declarado em <paramref name="newExpression" />.Type ou no tipo base dele.  
  
- ou - 
O método add no <paramref name="newExpression" />.Type ou no tipo base dele não aceita exatamente um argumento.  
  
- ou - 
O tipo representado pela propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> do primeiro elemento de <paramref name="initializers" /> não é atribuível ao tipo de argumento do método add em <paramref name="newExpression" />.Type ou no tipo base dele.  
  
- ou - 
Existe mais de um método compatível com o argumento nomeado "Add" (não diferencia maiúsculas de minúsculas) em <paramref name="newExpression" />.Type e/ou o tipo base dele.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ListInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property set to the specified value.">Uma <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that uses specified &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to initialize a collection.">Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa objetos <see cref="T:System.Linq.Expressions.ElementInit" /> especificados para inicializar uma coleção.</summary>
      <param name="newExpression" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</param>
      <param name="initializers" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; collection.">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt; or &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt;.Type does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.">
        <paramref name="newExpression" />.Type não implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ListInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e as propriedades <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that uses a method named &quot;Add&quot; to add elements to a collection.">Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa um método chamado "Add" para adicionar elementos a uma coleção.</summary>
      <param name="newExpression" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</param>
      <param name="initializers" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; collection.">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt; or &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt;.Type does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.">
        <paramref name="newExpression" />.Type não implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="There is no instance method named &quot;Add&quot; (case insensitive) declared in &lt;paramref name=&quot;newExpression&quot; /&gt;.Type or its base type.  &#xA;  &#xA; -or-  &#xA;  &#xA; The add method on &lt;paramref name=&quot;newExpression&quot; /&gt;.Type or its base type does not take exactly one argument.  &#xA;  &#xA; -or-  &#xA;  &#xA; The type represented by the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of the first element of &lt;paramref name=&quot;initializers&quot; /&gt; is not assignable to the argument type of the add method on &lt;paramref name=&quot;newExpression&quot; /&gt;.Type or its base type.  &#xA;  &#xA; -or-  &#xA;  &#xA; More than one argument-compatible method named &quot;Add&quot; (case-insensitive) exists on &lt;paramref name=&quot;newExpression&quot; /&gt;.Type and/or its base type.">Não há nenhum método de instância nomeado "Add" (não diferencia maiúsculas de minúsculas) declarado em <paramref name="newExpression" />.Type ou no tipo base dele.  
  
- ou - 
O método add no <paramref name="newExpression" />.Type ou no tipo base dele não aceita exatamente um argumento.  
  
- ou - 
O tipo representado pela propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> do primeiro elemento de <paramref name="initializers" /> não é atribuível ao tipo de argumento do método add em <paramref name="newExpression" />.Type ou no tipo base dele.  
  
- ou - 
Existe mais de um método compatível com o argumento nomeado "Add" (não diferencia maiúsculas de minúsculas) em <paramref name="newExpression" />.Type e/ou o tipo base dele.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ListInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property set to the specified value.">Uma <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that uses a specified method to add elements to a collection.">Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa um método especificado para adicionar elementos a uma coleção.</summary>
      <param name="newExpression" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</param>
      <param name="addMethod" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents an instance method named &quot;Add&quot; (case insensitive), that adds an element to a collection.">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de instância nomeado "Add" (não diferencia maiúsculas de minúsculas), que adiciona um elemento a uma coleção.</param>
      <param name="initializers" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt; or &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt;.Type does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;addMethod&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and it does not represent an instance method named &quot;Add&quot; (case insensitive) that takes exactly one argument.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;addMethod&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the type represented by the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of one or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; is not assignable to the argument type of the method that &lt;paramref name=&quot;addMethod&quot; /&gt; represents.">
        <paramref name="newExpression" />.Type não implementa <see cref="T:System.Collections.IEnumerable" />.  
  
- ou - 
 <paramref name="addMethod" /> não é <see langword="null" /> e não representa um método de instância nomeado "Add" (não diferencia maiúsculas de minúsculas) que aceita exatamente um argumento.  
  
- ou - 
 <paramref name="addMethod" /> não é <see langword="null" /> e o tipo representado pela propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um ou mais elementos de <paramref name="initializers" /> não pode ser atribuída ao tipo de argumento do método representado por <paramref name="addMethod" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;addMethod&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and no instance method named &quot;Add&quot; that takes one type-compatible argument exists on &lt;paramref name=&quot;newExpression&quot; /&gt;.Type or its base type.">
        <paramref name="addMethod" /> é <see langword="null" /> e nenhum método de instância nomeado "Add" que aceita um argumento de tipo compatível existe no <paramref name="newExpression" />.Type ou no tipo base dele.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ListInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property set to the specified value.">Uma <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that uses a specified method to add elements to a collection.">Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa um método especificado para adicionar elementos a uma coleção.</summary>
      <param name="newExpression" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</param>
      <param name="addMethod" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents an instance method that takes one argument, that adds an element to a collection.">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de instância que aceita um argumento, que adiciona um elemento a uma coleção.</param>
      <param name="initializers" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; collection.">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt; or &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; One or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; are &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.  
  
- ou - 
Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt;.Type does not implement &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;addMethod&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and it does not represent an instance method named &quot;Add&quot; (case insensitive) that takes exactly one argument.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;addMethod&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the type represented by the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of one or more elements of &lt;paramref name=&quot;initializers&quot; /&gt; is not assignable to the argument type of the method that &lt;paramref name=&quot;addMethod&quot; /&gt; represents.">
        <paramref name="newExpression" />.Type não implementa <see cref="T:System.Collections.IEnumerable" />.  
  
- ou - 
 <paramref name="addMethod" /> não é <see langword="null" /> e não representa um método de instância nomeado "Add" (não diferencia maiúsculas de minúsculas) que aceita exatamente um argumento.  
  
- ou - 
 <paramref name="addMethod" /> não é <see langword="null" /> e o tipo representado pela propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um ou mais elementos de <paramref name="initializers" /> não pode ser atribuída ao tipo de argumento do método representado por <paramref name="addMethod" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;addMethod&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and no instance method named &quot;Add&quot; that takes one type-compatible argument exists on &lt;paramref name=&quot;newExpression&quot; /&gt;.Type or its base type.">
        <paramref name="addMethod" /> é <see langword="null" /> e nenhum método de instância nomeado "Add" que aceita um argumento de tipo compatível existe no <paramref name="newExpression" />.Type ou no tipo base dele.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ListInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property set to the specified value.">Uma <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LoopExpression&quot; /&gt; with the given body.">Cria um <see cref="T:System.Linq.Expressions.LoopExpression" /> com o corpo fornecido.</summary>
      <param name="body" vsli:raw="The body of the loop.">O corpo do loop.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.LoopExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.LoopExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LoopExpression&quot; /&gt; with the given body and break target.">Cria um <see cref="T:System.Linq.Expressions.LoopExpression" /> com o destino corpo e interrupção determinado.</summary>
      <param name="body" vsli:raw="The body of the loop.">O corpo do loop.</param>
      <param name="break" vsli:raw="The break target used by the loop body.">O destino de interrupção usado pelo corpo do loop.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.LoopExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.LoopExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.LoopExpression&quot; /&gt; with the given body.">Cria um <see cref="T:System.Linq.Expressions.LoopExpression" /> com o corpo fornecido.</summary>
      <param name="body" vsli:raw="The body of the loop.">O corpo do loop.</param>
      <param name="break" vsli:raw="The break target used by the loop body.">O destino de interrupção usado pelo corpo do loop.</param>
      <param name="continue" vsli:raw="The continue target used by the loop body.">O destino continue usado pelo corpo do loop.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.LoopExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.LoopExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt;, given the left and right operands, by calling an appropriate factory method.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" />, considerando os operandos esquerdos e direito, chamando um método de fábrica apropriado.</summary>
      <param name="binaryType" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that specifies the type of binary operation.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica o tipo de operação binária.</param>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the left operand.">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando esquerdo.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the right operand.">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando direito.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;binaryType&quot; /&gt; does not correspond to a binary expression node.">
        <paramref name="binaryType" /> não corresponde a um nó de expressão binária.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that results from calling the appropriate factory method.">O <see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de chamar o método de fábrica apropriado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt;, given the left operand, right operand and implementing method, by calling the appropriate factory method.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" />, dado o operando esquerdo, o operando direito e o método de implementação, chamando o método de fábrica apropriado.</summary>
      <param name="binaryType" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that specifies the type of binary operation.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica o tipo de operação binária.</param>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the left operand.">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando esquerdo.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the right operand.">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando direito.</param>
      <param name="liftToNull" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;true&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that specifies the implementing method.">Um <see cref="T:System.Reflection.MethodInfo" /> que especifica o método de implementação.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;binaryType&quot; /&gt; does not correspond to a binary expression node.">
        <paramref name="binaryType" /> não corresponde a um nó de expressão binária.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that results from calling the appropriate factory method.">O <see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de chamar o método de fábrica apropriado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt;, given the left operand, right operand, implementing method and type conversion function, by calling the appropriate factory method.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" />, dado o operando esquerdo, o operando direito, o método de implementação e a função de conversão de tipo, chamando o método de fábrica apropriado.</summary>
      <param name="binaryType" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that specifies the type of binary operation.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica o tipo de operação binária.</param>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the left operand.">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando esquerdo.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the right operand.">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando direito.</param>
      <param name="liftToNull" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;true&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that specifies the implementing method.">Um <see cref="T:System.Reflection.MethodInfo" /> que especifica o método de implementação.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; that represents a type conversion function. This parameter is used only if &lt;paramref name=&quot;binaryType&quot; /&gt; is &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Coalesce&quot; /&gt; or compound assignment.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que representa uma função de conversão de tipo. Esse parâmetro é usado somente se <paramref name="binaryType" /> é <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> ou uma atribuição composta.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;binaryType&quot; /&gt; does not correspond to a binary expression node.">
        <paramref name="binaryType" /> não corresponde a um nó de expressão binária.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that results from calling the appropriate factory method.">O <see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de chamar o método de fábrica apropriado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; representing a catch statement with the specified elements.">Cria um <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch com os elementos especificados.</summary>
      <param name="type" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; of &lt;see cref=&quot;T:System.Exception&quot; /&gt; this &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; will handle.">O <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que esse <see cref="T:System.Linq.Expressions.CatchBlock" /> tratará.</param>
      <param name="variable" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; representing a reference to the &lt;see cref=&quot;T:System.Exception&quot; /&gt; object caught by this handler.">Uma <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa uma referência para o objeto <see cref="T:System.Exception" /> capturado por este manipulador.</param>
      <param name="body" vsli:raw="The body of the catch statement.">O corpo da instrução catch.</param>
      <param name="filter" vsli:raw="The body of the &lt;see cref=&quot;T:System.Exception&quot; /&gt; filter.">O corpo do filtro <see cref="T:System.Exception" />.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.CatchBlock" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">O associador de runtime para a operação dinâmica.</param>
      <param name="arguments" vsli:raw="The arguments to the dynamic operation.">Os argumentos para a operação dinâmica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; and one argument.">Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido e um argumento.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">O associador de runtime para a operação dinâmica.</param>
      <param name="arg0" vsli:raw="The argument to the dynamic operation.">O argumento para a operação dinâmica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; and two arguments.">Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido e dois argumentos.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">O associador de runtime para a operação dinâmica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">O primeiro argumento para a operação dinâmica.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">O segundo argumento para a operação dinâmica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; and three arguments.">Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido e três argumentos.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">O associador de runtime para a operação dinâmica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">O primeiro argumento para a operação dinâmica.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">O segundo argumento para a operação dinâmica.</param>
      <param name="arg2" vsli:raw="The third argument to the dynamic operation.">O terceiro argumento para a operação dinâmica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; and four arguments.">Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido e quatro argumentos.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">O associador de runtime para a operação dinâmica.</param>
      <param name="arg0" vsli:raw="The first argument to the dynamic operation.">O primeiro argumento para a operação dinâmica.</param>
      <param name="arg1" vsli:raw="The second argument to the dynamic operation.">O segundo argumento para a operação dinâmica.</param>
      <param name="arg2" vsli:raw="The third argument to the dynamic operation.">O terceiro argumento para a operação dinâmica.</param>
      <param name="arg3" vsli:raw="The fourth argument to the dynamic operation.">O quarto argumento para a operação dinâmica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that represents a dynamic operation bound by the provided &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt;.">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</summary>
      <param name="delegateType" vsli:raw="The type of the delegate used by the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSite&quot; /&gt;.">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder" vsli:raw="The runtime binder for the dynamic operation.">O associador de runtime para a operação dinâmica.</param>
      <param name="arguments" vsli:raw="The arguments to the dynamic operation.">Os argumentos para a operação dinâmica.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt; that has &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Dynamic&quot; /&gt; and has the &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.DelegateType&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Binder&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.DynamicExpression.Arguments&quot; /&gt; set to the specified values.">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a jump of the specified &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpressionKind&quot; /&gt;. The value passed to the label upon jumping can also be specified.">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa um link do <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> especificado. O valor passado para o rótulo ao saltar também pode ser especificado.</summary>
      <param name="kind" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpressionKind&quot; /&gt; of the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> do <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <param name="value" vsli:raw="The value that will be passed to the associated label upon jumping.">O valor que será passado para o rótulo associado ao saltar.</param>
      <param name="type" vsli:raw="An &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to &lt;paramref name=&quot;kind&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;paramref name=&quot;type&quot; /&gt;, and &lt;paramref name=&quot;value&quot; /&gt; to be passed to the target label upon jumping.">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a <paramref name="kind" />, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" />, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e <paramref name="value" /> a ser passado para o rótulo de destino ao saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt; that represents accessing an indexed property in an object.">Cria um <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa o acesso a uma propriedade indexada em um objeto.</summary>
      <param name="instance" vsli:raw="The object to which the property belongs. It should be null if the property is &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;shared&quot; /&gt; in Visual Basic).">O objeto ao qual a propriedade pertence. Deve ser nulo se a propriedade for <see langword="static" /> (<see langword="shared" /> no Visual Basic).</param>
      <param name="indexer" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the property to index.">Um <see cref="T:System.Linq.Expressions.Expression" /> representando a propriedade a indexar.</param>
      <param name="arguments" vsli:raw="An &lt;c&gt;IEnumerable&amp;lt;Expression&amp;gt;&lt;/c&gt; (&lt;c&gt;IEnumerable (Of Expression)&lt;/c&gt; in Visual Basic) that contains the arguments that will be used to index the property.">Um <c>IEnumerable&lt;Expression&gt;</c> (<c>IEnumerable (Of Expression)</c> no Visual Basic) que contém os argumentos que serão usados para indexar a propriedade.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that represents accessing either a field or a property.">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a um campo ou uma propriedade.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the object that the member belongs to. This can be null for static members.">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o objeto ao qual o membro pertence. Isso pode ser nulo para membros estáticos.</param>
      <param name="member" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; that describes the field or property to be accessed.">O <see cref="T:System.Reflection.MemberInfo" /> que descreve a propriedade ou o campo a ser acessado.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="member" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; does not represent a field or property.">
        <paramref name="member" /> não representa um campo ou propriedade.</exception>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that results from calling the appropriate factory method.">O <see cref="T:System.Linq.Expressions.MemberExpression" /> que resulta de chamar o método de fábrica apropriado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt; representing a try block with the specified elements.">Cria um <see cref="T:System.Linq.Expressions.TryExpression" /> que representa um bloco try com os elementos especificados.</summary>
      <param name="type" vsli:raw="The result type of the try expression. If null, body and all handlers must have identical type.">O tipo de resultado da expressão try. Se for null, o corpo e todos os manipuladores devem ter tipo idêntico.</param>
      <param name="body" vsli:raw="The body of the try block.">O corpo do bloco try.</param>
      <param name="finally" vsli:raw="The body of the finally block. Pass null if the try block has no finally block associated with it.">O corpo do bloco finally. Passe null se o bloco try não tem bloco finally associado a ele.</param>
      <param name="fault" vsli:raw="The body of the fault block. Pass null if the try block has no fault block associated with it.">O corpo do bloco de falha. Passe null se o bloco try não tem bloco fault associado a ele.</param>
      <param name="handlers" vsli:raw="A collection of &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt;s representing the catch statements to be associated with the try block.">Uma coleção de <see cref="T:System.Linq.Expressions.CatchBlock" />s representando as instruções catch a serem associados com o bloco try.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.TryExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;, given an operand, by calling the appropriate factory method.">Dado um determinado operando, cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> chamando o método de fábrica apropriado.</summary>
      <param name="unaryType" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that specifies the type of unary operation.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica o tipo de operação unária.</param>
      <param name="operand" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the operand.">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando.</param>
      <param name="type" vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; that specifies the type to be converted to (pass &lt;see langword=&quot;null&quot; /&gt; if not applicable).">O <see cref="T:System.Type" /> que especifica o tipo no qual converter (passe <see langword="null" /> se não for aplicável).</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;operand&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="operand" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;unaryType&quot; /&gt; does not correspond to a unary expression node.">
        <paramref name="unaryType" /> não corresponde a um nó de expressão unária.</exception>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that results from calling the appropriate factory method.">O <see cref="T:System.Linq.Expressions.UnaryExpression" /> que resulta de chamar o método de fábrica apropriado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;, given an operand and implementing method, by calling the appropriate factory method.">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" />, dado um operando e um método de implementação, chamando o método de fábrica apropriado.</summary>
      <param name="unaryType" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that specifies the type of unary operation.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica o tipo de operação unária.</param>
      <param name="operand" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the operand.">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando.</param>
      <param name="type" vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; that specifies the type to be converted to (pass &lt;see langword=&quot;null&quot; /&gt; if not applicable).">O <see cref="T:System.Type" /> que especifica o tipo no qual converter (passe <see langword="null" /> se não for aplicável).</param>
      <param name="method" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">O <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;operand&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="operand" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;unaryType&quot; /&gt; does not correspond to a unary expression node.">
        <paramref name="unaryType" /> não corresponde a um nó de expressão unária.</exception>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that results from calling the appropriate factory method.">O <see cref="T:System.Linq.Expressions.UnaryExpression" /> que resulta de chamar o método de fábrica apropriado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt; that represents the recursive initialization of members of a field or property.">Cria um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa a inicialização recursiva de membros de um campo ou propriedade.</summary>
      <param name="member" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property equal to.">O <see cref="T:System.Reflection.MemberInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propriedade será definida.</param>
      <param name="bindings" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; or &lt;paramref name=&quot;bindings&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="member" /> ou <paramref name="bindings" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; does not represent a field or property.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property of an element of &lt;paramref name=&quot;bindings&quot; /&gt; does not represent a member of the type of the field or property that &lt;paramref name=&quot;member&quot; /&gt; represents.">
        <paramref name="member" /> não representa um campo ou propriedade.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de um elemento de <paramref name="bindings" /> não representa um membro do tipo do campo ou propriedade representada por <paramref name="member" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.MemberBinding&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt; that represents the recursive initialization of members of a field or property.">Cria um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa a inicialização recursiva de membros de um campo ou propriedade.</summary>
      <param name="member" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property equal to.">O <see cref="T:System.Reflection.MemberInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propriedade será definida.</param>
      <param name="bindings" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; collection.">Uma matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; or &lt;paramref name=&quot;bindings&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="member" /> ou <paramref name="bindings" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;member&quot; /&gt; does not represent a field or property.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property of an element of &lt;paramref name=&quot;bindings&quot; /&gt; does not represent a member of the type of the field or property that &lt;paramref name=&quot;member&quot; /&gt; represents.">
        <paramref name="member" /> não representa um campo ou propriedade.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de um elemento de <paramref name="bindings" /> não representa um membro do tipo do campo ou propriedade representada por <paramref name="member" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.MemberBinding&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt; that represents the recursive initialization of members of a member that is accessed by using a property accessor method.">Cria um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa a inicialização recursiva de membros de um membro que é acessado usando um método de acessador de propriedade.</summary>
      <param name="propertyAccessor" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents a property accessor method.">O <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</param>
      <param name="bindings" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; or &lt;paramref name=&quot;bindings&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="propertyAccessor" /> ou <paramref name="bindings" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; does not represent a property accessor method.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property of an element of &lt;paramref name=&quot;bindings&quot; /&gt; does not represent a member of the type of the property accessed by the method that &lt;paramref name=&quot;propertyAccessor&quot; /&gt; represents.">
        <paramref name="propertyAccessor" /> não representa um método de acessador de propriedade.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de um elemento de <paramref name="bindings" /> não representa um membro do tipo da propriedade acessada pelo método representado por <paramref name="propertyAccessor" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.MemberBinding&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; that represents the property accessed in &lt;paramref name=&quot;propertyAccessor&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> definida para o <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" /> e propriedades <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt; that represents the recursive initialization of members of a member that is accessed by using a property accessor method.">Cria um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa a inicialização recursiva de membros de um membro que é acessado usando um método de acessador de propriedade.</summary>
      <param name="propertyAccessor" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents a property accessor method.">O <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</param>
      <param name="bindings" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; collection.">Uma matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; or &lt;paramref name=&quot;bindings&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="propertyAccessor" /> ou <paramref name="bindings" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; does not represent a property accessor method.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property of an element of &lt;paramref name=&quot;bindings&quot; /&gt; does not represent a member of the type of the property accessed by the method that &lt;paramref name=&quot;propertyAccessor&quot; /&gt; represents.">
        <paramref name="propertyAccessor" /> não representa um método de acessador de propriedade.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de um elemento de <paramref name="bindings" /> não representa um membro do tipo da propriedade acessada pelo método representado por <paramref name="propertyAccessor" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.BindingType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.MemberBindingType.MemberBinding&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; that represents the property accessed in &lt;paramref name=&quot;propertyAccessor&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> definida para o <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" /> e propriedades <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary vsli:raw="Represents an expression that creates a new object and initializes a property of the object.">Representa uma expressão que cria um novo objeto e inicializa uma propriedade do objeto.</summary>
      <param name="newExpression" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.NewExpression&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> igual a ele.</param>
      <param name="bindings" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.Bindings&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt; or &lt;paramref name=&quot;bindings&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="newExpression" /> ou <paramref name="bindings" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property of an element of &lt;paramref name=&quot;bindings&quot; /&gt; does not represent a member of the type that &lt;paramref name=&quot;newExpression&quot; /&gt;.Type represents.">A propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de um elemento de <paramref name="bindings" /> não representa um membro do tipo representado por <paramref name="newExpression" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberInitExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MemberInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.NewExpression&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.Bindings&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.MemberInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberInitExpression&quot; /&gt;.">Cria um <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <param name="newExpression" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.NewExpression&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> igual a ele.</param>
      <param name="bindings" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.Bindings&quot; /&gt; collection.">Uma matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;newExpression&quot; /&gt; or &lt;paramref name=&quot;bindings&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="newExpression" /> ou <paramref name="bindings" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberBinding.Member&quot; /&gt; property of an element of &lt;paramref name=&quot;bindings&quot; /&gt; does not represent a member of the type that &lt;paramref name=&quot;newExpression&quot; /&gt;.Type represents.">A propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de um elemento de <paramref name="bindings" /> não representa um membro do tipo representado por <paramref name="newExpression" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberInitExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MemberInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.NewExpression&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.Bindings&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.MemberInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic remainder operation.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação restante aritmética.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The modulus operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">O operador modulus não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Modulo&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic remainder operation.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação restante aritmética.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the modulus operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> é <see langword="null" /> e operador de módulo não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Modulo&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a remainder assignment operation.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição pendente.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ModuloAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a remainder assignment operation.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição pendente.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ModuloAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a remainder assignment operation.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição pendente.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.ModuloAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic multiplication operation that does not have overflow checking.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de multiplicação que não tem verificação de estouro.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The multiplication operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">O operador de multiplicação não está definido como <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Multiply&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic multiplication operation that does not have overflow checking.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de multiplicação que não tem verificação de estouro.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the multiplication operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> é <see langword="null" /> e o operador de multiplicação não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Multiply&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a multiplication assignment operation that does not have overflow checking.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que não tem verificação de estouro.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MultiplyAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a multiplication assignment operation that does not have overflow checking.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que não tem verificação de estouro.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MultiplyAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a multiplication assignment operation that does not have overflow checking.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que não tem verificação de estouro.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MultiplyAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a multiplication assignment operation that has overflow checking.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que tem verificação de estouro.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a multiplication assignment operation that has overflow checking.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que tem verificação de estouro.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a multiplication assignment operation that has overflow checking.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que tem verificação de estouro.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic multiplication operation that has overflow checking.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de multiplicação que tem verificação de estouro.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The multiplication operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">O operador de multiplicação não está definido como <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MultiplyChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic multiplication operation that has overflow checking.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de multiplicação que tem verificação de estouro.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the multiplication operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> é <see langword="null" /> e o operador de multiplicação não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MultiplyChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents an arithmetic negation operation.">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação aritmética de negação.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The unary minus operator is not defined for &lt;paramref name=&quot;expression&quot; /&gt;.Type.">O operador de menos unário não está definido para <paramref name="expression" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Negate&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property set to the specified value.">Uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents an arithmetic negation operation.">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação aritmética de negação.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly one argument.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the unary minus operator is not defined for &lt;paramref name=&quot;expression&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">
        <paramref name="method" /> é <see langword="null" /> e o operador unário de menos não foi definido para <paramref name="expression" />.Type.  
  
- ou - 
 <paramref name="expression" />.Type (ou o respectivo tipo que não permite valor nulo correspondente se ele é um tipo que permite valor nulo) não é atribuível ao tipo de argumento do método representado por <paramref name="method" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Negate&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents an arithmetic negation operation that has overflow checking.">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação aritmética de negação de adição que tem verificação de estouro.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The unary minus operator is not defined for &lt;paramref name=&quot;expression&quot; /&gt;.Type.">O operador de menos unário não está definido para <paramref name="expression" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NegateChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property set to the specified value.">Uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents an arithmetic negation operation that has overflow checking. The implementing method can be specified.">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação aritmética de negação de adição que tem verificação de estouro. O método de implementação pode ser especificado.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly one argument.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the unary minus operator is not defined for &lt;paramref name=&quot;expression&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">
        <paramref name="method" /> é <see langword="null" /> e o operador unário de menos não foi definido para <paramref name="expression" />.Type.  
  
- ou - 
 <paramref name="expression" />.Type (ou o respectivo tipo que não permite valor nulo correspondente se ele é um tipo que permite valor nulo) não é atribuível ao tipo de argumento do método representado por <paramref name="method" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NegateChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that represents calling the specified constructor that takes no arguments.">Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada ao construtor especificado que não aceita nenhum argumento.</summary>
      <param name="constructor" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; property equal to.">O <see cref="T:System.Reflection.ConstructorInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> propriedade será definida.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;constructor&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="constructor" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents has at least one parameter.">O construtor representado por <paramref name="constructor" /> tem pelo menos um parâmetro.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.New&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; property set to the specified value.">Uma <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e a propriedade <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that represents calling the specified constructor with the specified arguments.">Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada ao construtor especificado com os argumentos especificados.</summary>
      <param name="constructor" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; property equal to.">O <see cref="T:System.Reflection.ConstructorInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> propriedade será definida.</param>
      <param name="arguments" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;constructor&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;arguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="constructor" /> é <see langword="null" />.  
  
- ou - 
Um elemento de <paramref name="arguments" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;arguments&quot; /&gt; parameter does not contain the same number of elements as the number of parameters for the constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the type of the corresponding parameter of the constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents.">O parâmetro <paramref name="arguments" /> não contém o mesmo número de elementos que o número de parâmetros do construtor representado por <paramref name="constructor" />.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do construtor representado por <paramref name="constructor" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.New&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e as propriedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> e <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that represents calling the specified constructor with the specified arguments. The members that access the constructor initialized fields are specified.">Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada ao construtor especificado com os argumentos especificados. Os membros que acessam os campos inicializados pelo construtor são especificados.</summary>
      <param name="constructor" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; property equal to.">O <see cref="T:System.Reflection.ConstructorInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> propriedade será definida.</param>
      <param name="arguments" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Members&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Reflection.MemberInfo" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;constructor&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;arguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;members&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="constructor" /> é <see langword="null" />.  
  
- ou - 
Um elemento de <paramref name="arguments" /> é <see langword="null" />.  
  
- ou - 
Um elemento de <paramref name="members" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;arguments&quot; /&gt; parameter does not contain the same number of elements as the number of parameters for the constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the type of the corresponding parameter of the constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;members&quot; /&gt; parameter does not have the same number of elements as &lt;paramref name=&quot;arguments&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;arguments&quot; /&gt; has a &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property that represents a type that is not assignable to the type of the member that is represented by the corresponding element of &lt;paramref name=&quot;members&quot; /&gt;.">O parâmetro <paramref name="arguments" /> não contém o mesmo número de elementos que o número de parâmetros do construtor representado por <paramref name="constructor" />.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do construtor representado por <paramref name="constructor" />.  
  
- ou - 
O parâmetro <paramref name="members" /> não tem o mesmo número de elementos de <paramref name="arguments" />.  
  
- ou - 
Um elemento de <paramref name="arguments" /> tem uma propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa um tipo que não é atribuível ao tipo do membro que é representado pelo elemento correspondente de <paramref name="members" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.New&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Members&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e as propriedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> e <see cref="P:System.Linq.Expressions.NewExpression.Members" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that represents calling the specified constructor with the specified arguments. The members that access the constructor initialized fields are specified as an array.">Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada ao construtor especificado com os argumentos especificados. Os membros que acessam os campos inicializados pelo construtor são especificados como uma matriz.</summary>
      <param name="constructor" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; property equal to.">O <see cref="T:System.Reflection.ConstructorInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> propriedade será definida.</param>
      <param name="arguments" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members" vsli:raw="An array of &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Members&quot; /&gt; collection.">Uma matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;constructor&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;arguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;members&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="constructor" /> é <see langword="null" />.  
  
- ou - 
Um elemento de <paramref name="arguments" /> é <see langword="null" />.  
  
- ou - 
Um elemento de <paramref name="members" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;arguments&quot; /&gt; parameter does not contain the same number of elements as the number of parameters for the constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the type of the corresponding parameter of the constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;members&quot; /&gt; parameter does not have the same number of elements as &lt;paramref name=&quot;arguments&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;arguments&quot; /&gt; has a &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property that represents a type that is not assignable to the type of the member that is represented by the corresponding element of &lt;paramref name=&quot;members&quot; /&gt;.">O parâmetro <paramref name="arguments" /> não contém o mesmo número de elementos que o número de parâmetros do construtor representado por <paramref name="constructor" />.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do construtor representado por <paramref name="constructor" />.  
  
- ou - 
O parâmetro <paramref name="members" /> não tem o mesmo número de elementos de <paramref name="arguments" />.  
  
- ou - 
Um elemento de <paramref name="arguments" /> tem uma propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa um tipo que não é atribuível ao tipo do membro que é representado pelo elemento correspondente de <paramref name="members" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.New&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Members&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e as propriedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> e <see cref="P:System.Linq.Expressions.NewExpression.Members" /> definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that represents calling the specified constructor with the specified arguments.">Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada ao construtor especificado com os argumentos especificados.</summary>
      <param name="constructor" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; property equal to.">O <see cref="T:System.Reflection.ConstructorInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> propriedade será definida.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; collection.">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;constructor&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;arguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="constructor" /> é <see langword="null" />.  
  
- ou - 
Um elemento de <paramref name="arguments" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;arguments&quot; /&gt; does match the number of parameters for the constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;arguments&quot; /&gt; is not assignable to the type of the corresponding parameter of the constructor that &lt;paramref name=&quot;constructor&quot; /&gt; represents.">O tamanho de <paramref name="arguments" /> corresponde ao número de parâmetros do construtor representado por <paramref name="constructor" />.  
  
- ou - 
A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do construtor representado por <paramref name="constructor" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.New&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e as propriedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> e <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that represents calling the parameterless constructor of the specified type.">Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada para o construtor sem parâmetro do tipo especificado.</summary>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that has a constructor that takes no arguments.">Um <see cref="T:System.Type" /> contém um construtor que não aceita argumentos.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The type that &lt;paramref name=&quot;type&quot; /&gt; represents does not have a constructor without parameters.">O tipo que <paramref name="type" /> representa não tem um construtor sem parâmetros.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.New&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Constructor&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; that represents the constructor without parameters for the specified type.">A <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e a propriedade <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> definida como o <see cref="T:System.Reflection.ConstructorInfo" /> que representa o construtor sem parâmetros para o tipo especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt; that represents creating an array that has a specified rank.">Cria uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa a criação de uma matriz que tem uma classificação especificada.</summary>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents the element type of the array.">Um <see cref="T:System.Type" /> que representa o tipo de elemento da matriz.</param>
      <param name="bounds" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; or &lt;paramref name=&quot;bounds&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;bounds&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" /> ou <paramref name="bounds" /> é <see langword="null" />.  
  
- ou - 
Um elemento de <paramref name="bounds" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;bounds&quot; /&gt; does not represent an integral type.">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="bounds" /> não representa um tipo integral.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NewArrayBounds&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; property set to the specified value.">Uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> e a propriedade <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt; that represents creating an array that has a specified rank.">Cria uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa a criação de uma matriz que tem uma classificação especificada.</summary>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents the element type of the array.">Um <see cref="T:System.Type" /> que representa o tipo de elemento da matriz.</param>
      <param name="bounds" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; collection.">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; or &lt;paramref name=&quot;bounds&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;bounds&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" /> ou <paramref name="bounds" /> é <see langword="null" />.  
  
- ou - 
Um elemento de <paramref name="bounds" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;bounds&quot; /&gt; does not represent an integral type.">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="bounds" /> não representa um tipo integral.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NewArrayBounds&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; property set to the specified value.">Uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> e a propriedade <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt; that represents creating a one-dimensional array and initializing it from a list of elements.">Cria um <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa a criação de uma matriz unidimensional e a inicialização dela de uma lista de elementos.</summary>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents the element type of the array.">Um <see cref="T:System.Type" /> que representa o tipo de elemento da matriz.</param>
      <param name="initializers" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; that contains &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; collection.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; or &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" /> ou <paramref name="initializers" /> é <see langword="null" />.  
  
- ou - 
Um elemento de <paramref name="initializers" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;initializers&quot; /&gt; represents a type that is not assignable to the type that &lt;paramref name=&quot;type&quot; /&gt; represents.">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento <paramref name="initializers" /> representa um tipo que não é atribuível ao tipo representado por <paramref name="type" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NewArrayInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; property set to the specified value.">Uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> e a propriedade <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt; that represents creating a one-dimensional array and initializing it from a list of elements.">Cria um <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa a criação de uma matriz unidimensional e a inicialização dela de uma lista de elementos.</summary>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents the element type of the array.">Um <see cref="T:System.Type" /> que representa o tipo de elemento da matriz.</param>
      <param name="initializers" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; collection.">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; or &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; An element of &lt;paramref name=&quot;initializers&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" /> ou <paramref name="initializers" /> é <see langword="null" />.  
  
- ou - 
Um elemento de <paramref name="initializers" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property of an element of &lt;paramref name=&quot;initializers&quot; /&gt; represents a type that is not assignable to the type &lt;paramref name=&quot;type&quot; /&gt;.">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="initializers" /> representa um tipo que não é atribuível ao tipo <paramref name="type" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NewArrayInit&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; property set to the specified value.">Uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> e a propriedade <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a bitwise complement operation.">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de complemento bit a bit.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The unary not operator is not defined for &lt;paramref name=&quot;expression&quot; /&gt;.Type.">O não operador unário não é definido para <paramref name="expression" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Not&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property set to the specified value.">Uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a bitwise complement operation. The implementing method can be specified.">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de complemento bit a bit. O método de implementação pode ser especificado.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly one argument.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the unary not operator is not defined for &lt;paramref name=&quot;expression&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">
        <paramref name="method" /> é <see langword="null" /> e o operador não unário não foi definido para <paramref name="expression" />.Type.  
  
- ou - 
 <paramref name="expression" />.Type (ou o respectivo tipo que não permite valor nulo correspondente se ele é um tipo que permite valor nulo) não é atribuível ao tipo de argumento do método representado por <paramref name="method" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Not&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an inequality comparison.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de desigualdade.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The inequality operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">O operador de desigualdade não está definido como <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NotEqual&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an inequality comparison.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de desigualdade.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="liftToNull" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;true&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to set &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt; to &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the inequality operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> é <see langword="null" /> e o operador de desigualdade não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NotEqual&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Returns the expression representing the ones complement.">Retorna a expressão que representa o complemento de um.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Um <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;.">Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Returns the expression representing the ones complement.">Retorna a expressão que representa o complemento de um.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Um <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;.">Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise &lt;see langword=&quot;OR&quot; /&gt; operation.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="OR" /> bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The bitwise &lt;see langword=&quot;OR&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">O operador <see langword="OR" /> bit a bit não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Or&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise &lt;see langword=&quot;OR&quot; /&gt; operation.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="OR" /> bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the bitwise &lt;see langword=&quot;OR&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> é <see langword="null" /> e o operador <see langword="OR" /> bit a bit não é definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Or&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise OR assignment operation.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição OR bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.OrAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise OR assignment operation.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição OR bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.OrAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise OR assignment operation.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição OR bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.OrAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a conditional &lt;see langword=&quot;OR&quot; /&gt; operation that evaluates the second operand only if the first operand evaluates to &lt;see langword=&quot;false&quot; /&gt;.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="OR" /> condicional que avalia o segundo operando somente se o primeiro operando é avaliado como <see langword="false" />.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The bitwise &lt;see langword=&quot;OR&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type are not the same Boolean type.">O operador <see langword="OR" /> bit a bit não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.  
  
- ou - 
 <paramref name="left" />.Type e <paramref name="right" />.Type não são do mesmo tipo booliano.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.OrElse&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a conditional &lt;see langword=&quot;OR&quot; /&gt; operation that evaluates the second operand only if the first operand evaluates to &lt;see langword=&quot;false&quot; /&gt;.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="OR" /> condicional que avalia o segundo operando somente se o primeiro operando é avaliado como <see langword="false" />.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the bitwise &lt;see langword=&quot;OR&quot; /&gt; operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type are not the same Boolean type.">
        <paramref name="method" /> é <see langword="null" /> e o operador <see langword="OR" /> bit a bit não é definido para <paramref name="left" />.Type e <paramref name="right" />.Type.  
  
- ou - 
 <paramref name="method" /> é <see langword="null" /> e Type.<paramref name="left" /> e Type.<paramref name="right" /> não são do mesmo tipo booliano.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.OrElse&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; node that can be used to identify a parameter or a variable in an expression tree.">Cria um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que pode ser usado para identificar um parâmetro ou uma variável em uma árvore de expressão.</summary>
      <param name="type" vsli:raw="The type of the parameter or variable.">O tipo do parâmetro ou da variável.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; node with the specified name and type.">Um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> com o nome e tipo especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; node that can be used to identify a parameter or a variable in an expression tree.">Cria um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que pode ser usado para identificar um parâmetro ou uma variável em uma árvore de expressão.</summary>
      <param name="type" vsli:raw="The type of the parameter or variable.">O tipo do parâmetro ou da variável.</param>
      <param name="name" vsli:raw="The name of the parameter or variable, used for debugging or printing purpose only.">O nome do parâmetro ou variável, usado para fins de depuração ou impressão apenas.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" /> é <see langword="null" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Parameter&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.ParameterExpression.Name&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.ParameterExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> e as propriedades <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a atribuição da expressão seguida de um decremento subsequente da expressão original em 1.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to apply the operations on.">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the resultant expression.">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a atribuição da expressão seguida de um decremento subsequente da expressão original em 1.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to apply the operations on.">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the resultant expression.">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a atribuição da expressão seguida de um incremento de 1 à expressão original.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to apply the operations on.">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the resultant expression.">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a atribuição da expressão seguida de um incremento de 1 à expressão original.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to apply the operations on.">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the resultant expression.">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents raising a number to a power.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa a elevação de um número a uma potência.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The exponentiation operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;left&quot; /&gt;.Type and/or &lt;paramref name=&quot;right&quot; /&gt;.Type are not &lt;see cref=&quot;T:System.Double&quot; /&gt;.">O operador de exponenciação não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.  
  
- ou - 
 <paramref name="left" />.Type e/ou <paramref name="right" />.Type não são <see cref="T:System.Double" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Power&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents raising a number to a power.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa a elevação de um número a uma potência.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the exponentiation operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;left&quot; /&gt;.Type and/or &lt;paramref name=&quot;right&quot; /&gt;.Type are not &lt;see cref=&quot;T:System.Double&quot; /&gt;.">
        <paramref name="method" /> é <see langword="null" /> e o operador de exponenciação não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.  
  
- ou - 
 <paramref name="method" /> é <see langword="null" /> e <paramref name="left" />.Type e/ou <paramref name="right" />.Type não são <see cref="T:System.Double" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Power&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents raising an expression to a power and assigning the result back to the expression.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa elevar uma expressão a uma potência e atribuir o resultado de volta à expressão.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.PowerAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents raising an expression to a power and assigning the result back to the expression.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa elevar uma expressão a uma potência e atribuir o resultado de volta à expressão.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.PowerAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents raising an expression to a power and assigning the result back to the expression.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa elevar uma expressão a uma potência e atribuir o resultado de volta à expressão.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.PowerAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that decrements the expression by 1 and assigns the result back to the expression.">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que decrementa a expressão por 1 e atribui o resultado de volta à expressão.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to apply the operations on.">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the resultant expression.">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that decrements the expression by 1 and assigns the result back to the expression.">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que decrementa a expressão por 1 e atribui o resultado de volta à expressão.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to apply the operations on.">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the resultant expression.">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that increments the expression by 1 and assigns the result back to the expression.">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que incrementa a expressão em 1 e atribui o resultado de volta à expressão.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to apply the operations on.">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the resultant expression.">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that increments the expression by 1 and assigns the result back to the expression.">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que incrementa a expressão em 1 e atribui o resultado de volta à expressão.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to apply the operations on.">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the resultant expression.">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that represents accessing a property by using a property accessor method.">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a uma propriedade usando um método de acessador de propriedade.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; property equal to. This can be null for static properties.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> igual a ele. Pode ser nulo para propriedades estáticas.</param>
      <param name="propertyAccessor" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents a property accessor method.">O <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;propertyAccessor&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method that &lt;paramref name=&quot;propertyAccessor&quot; /&gt; represents is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) and &lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="propertyAccessor" /> é <see langword="null" />.  
  
- ou - 
O método representado por <paramref name="propertyAccessor" /> não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) e <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt;.Type is not assignable to the declaring type of the method represented by &lt;paramref name=&quot;propertyAccessor&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method that &lt;paramref name=&quot;propertyAccessor&quot; /&gt; represents is not a property accessor method.">
        <paramref name="expression" />. O tipo não é atribuível ao tipo de declaração de método representada pelo <paramref name="propertyAccessor" />.  
  
- ou - 
O método representado por <paramref name="propertyAccessor" /> não é um método de acessador de propriedade.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MemberAccess&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; property set to &lt;paramref name=&quot;expression&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; that represents the property accessed in &lt;paramref name=&quot;propertyAccessor&quot; /&gt;.">Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> definida como <paramref name="expression" /> e a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definida como o <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that represents accessing a property.">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a uma propriedade.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; property equal to. This can be null for static properties.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> igual a ele. Pode ser nulo para propriedades estáticas.</param>
      <param name="property" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Member&quot; /&gt; property equal to.">O <see cref="T:System.Reflection.PropertyInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> propriedade será definida.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;property&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The property that &lt;paramref name=&quot;property&quot; /&gt; represents is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic) and &lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="property" /> é <see langword="null" />.  
  
- ou - 
A propriedade que o <paramref name="property" /> representa não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) e o <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt;.Type is not assignable to the declaring type of the property that &lt;paramref name=&quot;property&quot; /&gt; represents.">
        <paramref name="expression" />.Type não é atribuível ao tipo de declaração da propriedade que o <paramref name="property" /> representa.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MemberAccess&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Member&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> e <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt; representing the access to an indexed property.">Cria um <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa o acesso a uma propriedade indexada.</summary>
      <param name="instance" vsli:raw="The object to which the property belongs. If the property is static/shared, it must be null.">O objeto ao qual a propriedade pertence. Se a propriedade for estática/compartilhada, ela deverá ser nula.</param>
      <param name="indexer" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; that represents the property to index.">O <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade de índice.</param>
      <param name="arguments" vsli:raw="An &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that are used to index the property.">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> de objetos <see cref="T:System.Linq.Expressions.Expression" /> que são usados para indexar a propriedade.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt; representing the access to an indexed property.">Cria um <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa o acesso a uma propriedade indexada.</summary>
      <param name="instance" vsli:raw="The object to which the property belongs. If the property is static/shared, it must be null.">O objeto ao qual a propriedade pertence. Se a propriedade for estática/compartilhada, ela deverá ser nula.</param>
      <param name="indexer" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; that represents the property to index.">O <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade de índice.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that are used to index the property.">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que são usados para a propriedade de índice.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that represents accessing a property.">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a uma propriedade.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; whose &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; contains a property named &lt;paramref name=&quot;propertyName&quot; /&gt;. This can be &lt;see langword=&quot;null&quot; /&gt; for static properties.">Um <see cref="T:System.Linq.Expressions.Expression" /> cujo <see cref="P:System.Linq.Expressions.Expression.Type" /> contém uma propriedade chamada <paramref name="propertyName" />. Pode ser <see langword="null" /> para propriedades estáticas.</param>
      <param name="propertyName" vsli:raw="The name of a property to be accessed.">O nome de uma propriedade a ser acessada.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;propertyName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> ou <paramref name="propertyName" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="No property named &lt;paramref name=&quot;propertyName&quot; /&gt; is defined in &lt;paramref name=&quot;expression&quot; /&gt;.Type or its base types.">Nenhuma propriedade nomeada <paramref name="propertyName" /> é definida no tipo <paramref name="expression" /> ou em seus tipos base.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MemberAccess&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; property set to &lt;paramref name=&quot;expression&quot; /&gt;, and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; that represents the property denoted by &lt;paramref name=&quot;propertyName&quot; /&gt;.">Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> definida como <paramref name="expression" /> e a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definida como o <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade indicada por <paramref name="propertyName" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt; representing the access to an indexed property.">Cria um <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa o acesso a uma propriedade indexada.</summary>
      <param name="instance" vsli:raw="The object to which the property belongs. If the property is static/shared, it must be null.">O objeto ao qual a propriedade pertence. Se a propriedade for estática/compartilhada, ela deverá ser nula.</param>
      <param name="propertyName" vsli:raw="The name of the indexer.">o nome do indexador.</param>
      <param name="arguments" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that are used to index the property.">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que são usados para a propriedade de índice.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; accessing a property.">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> acessando uma propriedade.</summary>
      <param name="expression" vsli:raw="The containing object of the property. This can be null for static properties.">O objeto recipiente da propriedade. Pode ser nulo para propriedades estáticas.</param>
      <param name="type" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; that contains the property.">O <see cref="P:System.Linq.Expressions.Expression.Type" /> que contém a propriedade.</param>
      <param name="propertyName" vsli:raw="The property to be accessed.">A propriedade a ser acessada.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.MemberExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that represents accessing a property or field.">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a uma propriedade ou campo.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; whose &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; contains a property or field named &lt;paramref name=&quot;propertyOrFieldName&quot; /&gt;.">Um <see cref="T:System.Linq.Expressions.Expression" /> cujo <see cref="P:System.Linq.Expressions.Expression.Type" /> contém uma propriedade ou campo chamado <paramref name="propertyOrFieldName" />. Isso pode ser nulo para membros estáticos.</param>
      <param name="propertyOrFieldName" vsli:raw="The name of a property or field to be accessed.">O nome de uma propriedade ou campo a ser acessado.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;propertyOrFieldName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> ou <paramref name="propertyOrFieldName" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="No property or field named &lt;paramref name=&quot;propertyOrFieldName&quot; /&gt; is defined in &lt;paramref name=&quot;expression&quot; /&gt;.Type or its base types.">Nenhuma propriedade nomeado <paramref name="propertyOrFieldName" /> é definido em <paramref name="expression" />.Type ou em seus tipos base.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.MemberAccess&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; property set to &lt;paramref name=&quot;expression&quot; /&gt;, and the &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Member&quot; /&gt; property set to the &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.FieldInfo&quot; /&gt; that represents the property or field denoted by &lt;paramref name=&quot;propertyOrFieldName&quot; /&gt;.">Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> definida como <paramref name="expression" /> e a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definida como o <see cref="T:System.Reflection.PropertyInfo" /> ou <see cref="T:System.Reflection.FieldInfo" /> que representa a propriedade indicada por <paramref name="propertyOrFieldName" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents an expression that has a constant value of type &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma expressão que tem um valor constante do tipo <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> é <see langword="null" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Quote&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property set to the specified value.">Uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Reduce">
      <summary vsli:raw="Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.">Reduz esse nó a uma expressão mais simples. Se CanReduce retornar true, ele deverá retornar uma expressão válida. Esse método pode retornar outro nó que também precisa ser reduzido.</summary>
      <returns vsli:raw="The reduced expression.">A expressão reduzida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceAndCheck">
      <summary vsli:raw="Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.">Reduz esse nó a uma expressão mais simples. Se CanReduce retornar true, ele deverá retornar uma expressão válida. Esse método pode retornar outro nó que também precisa ser reduzido.</summary>
      <returns vsli:raw="The reduced expression.">A expressão reduzida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceExtensions">
      <summary vsli:raw="Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.">Reduz a expressão a um tipo de nó conhecido (que não é um nó de extensão) ou apenas retorna a expressão se ele já é um tipo conhecido.</summary>
      <returns vsli:raw="The reduced expression.">A expressão reduzida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a reference equality comparison.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de igualdade de referência.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Equal&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a reference inequality comparison.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de desigualdade de referência.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NotEqual&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a rethrowing of an exception.">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um relançamento de uma exceção.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a rethrowing of an exception.">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um relançamento de uma exceção.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow(System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a rethrowing of an exception with a given type.">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um relançamento de uma exceção com um determinado tipo.</summary>
      <param name="type" vsli:raw="The new &lt;see cref=&quot;T:System.Type&quot; /&gt; of the expression.">O novo <see cref="T:System.Type" /> da expressão.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a rethrowing of an exception.">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um relançamento de uma exceção.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a return statement.">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa um demonstrativo de retorno.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Return, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, and a null value to be passed to the target label upon jumping.">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Return, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" /> e um valor nulo a ser passado para o rótulo de destino ao saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a return statement. The value passed to the label upon jumping can be specified.">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa um demonstrativo de retorno. O valor passado para o rótulo no salto pode ser especificado.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <param name="value" vsli:raw="The value that will be passed to the associated label upon jumping.">O valor que será passado para o rótulo associado ao saltar.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Continue, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, and &lt;paramref name=&quot;value&quot; /&gt; to be passed to the target label upon jumping.">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continuar, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida como <paramref name="target" /> e <paramref name="value" /> a ser passado para o rótulo de destino ao saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a return statement with the specified type. The value passed to the label upon jumping can be specified.">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução return com o tipo especificado. O valor passado para o rótulo no salto pode ser especificado.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <param name="value" vsli:raw="The value that will be passed to the associated label upon jumping.">O valor que será passado para o rótulo associado ao saltar.</param>
      <param name="type" vsli:raw="An &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Continue, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;paramref name=&quot;type&quot; /&gt;, and &lt;paramref name=&quot;value&quot; /&gt; to be passed to the target label upon jumping.">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" />, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e <paramref name="value" /> a ser passado para o rótulo de destino ao saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; representing a return statement with the specified type.">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução return com o tipo especificado.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; will jump to.">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
      <param name="type" vsli:raw="An &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; with &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Kind&quot; /&gt; equal to Return, the &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property set to &lt;paramref name=&quot;target&quot; /&gt;, the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property set to &lt;paramref name=&quot;type&quot; /&gt;, and a null value to be passed to the target label upon jumping.">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Return, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" />, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e um valor nulo a ser passado para o rótulo de destino ao saltar.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise right-shift operation.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de deslocamento à direita bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The right-shift operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">O operador de deslocamento à direita não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.RightShift&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise right-shift operation.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de deslocamento à direita bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the right-shift operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> é <see langword="null" /> e o operador de deslocamento à direita não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.RightShift&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise right-shift assignment operation.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à direita bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.RightShiftAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise right-shift assignment operation.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à direita bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.RightShiftAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a bitwise right-shift assignment operation.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à direita bit a bit.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.RightShiftAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Linq.Expressions.RuntimeVariablesExpression&quot; /&gt;.">Cria uma instância de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <param name="variables" vsli:raw="A collection of &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.RuntimeVariablesExpression.Variables&quot; /&gt; collection.">Uma coleção de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.RuntimeVariablesExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.RuntimeVariables&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.RuntimeVariablesExpression.Variables&quot; /&gt; property set to the specified value.">Uma instância de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> e a propriedade <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Linq.Expressions.RuntimeVariablesExpression&quot; /&gt;.">Cria uma instância de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <param name="variables" vsli:raw="An array of &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects to use to populate the &lt;see cref=&quot;P:System.Linq.Expressions.RuntimeVariablesExpression.Variables&quot; /&gt; collection.">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.RuntimeVariablesExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.RuntimeVariables&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.RuntimeVariablesExpression.Variables&quot; /&gt; property set to the specified value.">Uma instância de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> e a propriedade <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic subtraction operation that does not have overflow checking.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de subtração que não tem verificação de estouro.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The subtraction operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">O operador de subtração não está definido como <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Subtract&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic subtraction operation that does not have overflow checking.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de subtração que não tem verificação de estouro.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the subtraction operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> é <see langword="null" /> e o operador de subtração não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Subtract&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a subtraction assignment operation that does not have overflow checking.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que não tem a verificação de estouro.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.SubtractAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a subtraction assignment operation that does not have overflow checking.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que não tem a verificação de estouro.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.SubtractAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a subtraction assignment operation that does not have overflow checking.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que não tem a verificação de estouro.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.SubtractAssign&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a subtraction assignment operation that has overflow checking.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que tem verificação de estouro.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a subtraction assignment operation that has overflow checking.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que tem verificação de estouro.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents a subtraction assignment operation that has overflow checking.">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que tem verificação de estouro.</summary>
      <param name="left" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <param name="conversion" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Conversion&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic subtraction operation that has overflow checking.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de subtração que tem verificação de estouro.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The subtraction operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">O operador de subtração não está definido como <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.SubtractChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that represents an arithmetic subtraction operation that has overflow checking.">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de subtração que tem verificação de estouro.</summary>
      <param name="left" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
      <param name="right" vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;left&quot; /&gt; or &lt;paramref name=&quot;right&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly two arguments.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the subtraction operator is not defined for &lt;paramref name=&quot;left&quot; /&gt;.Type and &lt;paramref name=&quot;right&quot; /&gt;.Type.">
        <paramref name="method" /> é <see langword="null" /> e o operador de subtração não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.SubtractChecked&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Left&quot; /&gt;, &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Right&quot; /&gt;, and &lt;see cref=&quot;P:System.Linq.Expressions.BinaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt; that represents a &lt;see langword=&quot;switch&quot; /&gt; statement that has a default case.">Cria um <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> que tem um caso padrão.</summary>
      <param name="switchValue" vsli:raw="The value to be tested against each case.">O valor a ser testado para cada caso.</param>
      <param name="defaultBody" vsli:raw="The result of the switch if &lt;paramref name=&quot;switchValue&quot; /&gt; does not match any of the cases.">O resultado da opção se <paramref name="switchValue" /> não corresponde a nenhum dos casos.</param>
      <param name="cases" vsli:raw="The set of cases for this switch expression.">O conjunto de casos para esta expressão de comutador.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt; that represents a &lt;see langword=&quot;switch&quot; /&gt; statement that has a default case.">Cria um <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> que tem um caso padrão.</summary>
      <param name="switchValue" vsli:raw="The value to be tested against each case.">O valor a ser testado para cada caso.</param>
      <param name="defaultBody" vsli:raw="The result of the switch if &lt;paramref name=&quot;switchValue&quot; /&gt; does not match any of the cases.">O resultado da opção se <paramref name="switchValue" /> não corresponde a nenhum dos casos.</param>
      <param name="comparison" vsli:raw="The equality comparison method to use.">O método de comparação de igualdade para usar.</param>
      <param name="cases" vsli:raw="The set of cases for this switch expression.">O conjunto de casos para esta expressão de comutador.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt; that represents a &lt;see langword=&quot;switch&quot; /&gt; statement that has a default case.">Cria um <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> que tem um caso padrão.</summary>
      <param name="switchValue" vsli:raw="The value to be tested against each case.">O valor a ser testado para cada caso.</param>
      <param name="defaultBody" vsli:raw="The result of the switch if &lt;paramref name=&quot;switchValue&quot; /&gt; does not match any of the cases.">O resultado da opção se <paramref name="switchValue" /> não corresponde a nenhum dos casos.</param>
      <param name="comparison" vsli:raw="The equality comparison method to use.">O método de comparação de igualdade para usar.</param>
      <param name="cases" vsli:raw="The set of cases for this switch expression.">O conjunto de casos para esta expressão de comutador.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt; that represents a &lt;see langword=&quot;switch&quot; /&gt; statement without a default case.">Cria uma <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> sem um caso padrão.</summary>
      <param name="switchValue" vsli:raw="The value to be tested against each case.">O valor a ser testado para cada caso.</param>
      <param name="cases" vsli:raw="The set of cases for this switch expression.">O conjunto de casos para esta expressão de comutador.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt; that represents a &lt;see langword=&quot;switch&quot; /&gt; statement that has a default case.">Cria um <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> que tem um caso padrão.</summary>
      <param name="type" vsli:raw="The result type of the switch.">O tipo de resultado da opção.</param>
      <param name="switchValue" vsli:raw="The value to be tested against each case.">O valor a ser testado para cada caso.</param>
      <param name="defaultBody" vsli:raw="The result of the switch if &lt;paramref name=&quot;switchValue&quot; /&gt; does not match any of the cases.">O resultado da opção se <paramref name="switchValue" /> não corresponde a nenhum dos casos.</param>
      <param name="comparison" vsli:raw="The equality comparison method to use.">O método de comparação de igualdade para usar.</param>
      <param name="cases" vsli:raw="The set of cases for this switch expression.">O conjunto de casos para esta expressão de comutador.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt; that represents a &lt;see langword=&quot;switch&quot; /&gt; statement that has a default case.">Cria um <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> que tem um caso padrão.</summary>
      <param name="type" vsli:raw="The result type of the switch.">O tipo de resultado da opção.</param>
      <param name="switchValue" vsli:raw="The value to be tested against each case.">O valor a ser testado para cada caso.</param>
      <param name="defaultBody" vsli:raw="The result of the switch if &lt;paramref name=&quot;switchValue&quot; /&gt; does not match any of the cases.">O resultado da opção se <paramref name="switchValue" /> não corresponde a nenhum dos casos.</param>
      <param name="comparison" vsli:raw="The equality comparison method to use.">O método de comparação de igualdade para usar.</param>
      <param name="cases" vsli:raw="The set of cases for this switch expression.">O conjunto de casos para esta expressão de comutador.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchCase&quot; /&gt; object to be used in a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt; object.">Cria um objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> a ser usado em um objeto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <param name="body" vsli:raw="The body of the case.">O corpo do caso.</param>
      <param name="testValues" vsli:raw="The test values of the case.">Os valores de teste do caso.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.SwitchCase&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.SwitchCase" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchCase&quot; /&gt; for use in a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">Cria um <see cref="T:System.Linq.Expressions.SwitchCase" /> para uso em um <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <param name="body" vsli:raw="The body of the case.">O corpo do caso.</param>
      <param name="testValues" vsli:raw="The test values of the case.">Os valores de teste do caso.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.SwitchCase&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.SwitchCase" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt;.">Cria uma instância de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName" vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.FileName&quot; /&gt; equal to.">Uma <see cref="T:System.String" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.FileName&quot; /&gt; property set to the specified value.">Um <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tem a propriedade <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt;.">Cria uma instância de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName" vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.FileName&quot; /&gt; equal to.">Uma <see cref="T:System.String" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language" vsli:raw="A &lt;see cref=&quot;T:System.Guid&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.Language&quot; /&gt; equal to.">Uma <see cref="T:System.Guid" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.FileName&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.Language&quot; /&gt; properties set to the specified value.">Um <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tem as propriedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> definidas para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt;.">Cria uma instância de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName" vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.FileName&quot; /&gt; equal to.">Uma <see cref="T:System.String" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language" vsli:raw="A &lt;see cref=&quot;T:System.Guid&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.Language&quot; /&gt; equal to.">Uma <see cref="T:System.Guid" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <param name="languageVendor" vsli:raw="A &lt;see cref=&quot;T:System.Guid&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor&quot; /&gt; equal to.">Uma <see cref="T:System.Guid" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.FileName&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.Language&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor&quot; /&gt; properties set to the specified value.">Um <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tem as propriedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> definidas para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt;.">Cria uma instância de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <param name="fileName" vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.FileName&quot; /&gt; equal to.">Uma <see cref="T:System.String" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language" vsli:raw="A &lt;see cref=&quot;T:System.Guid&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.Language&quot; /&gt; equal to.">Uma <see cref="T:System.Guid" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <param name="languageVendor" vsli:raw="A &lt;see cref=&quot;T:System.Guid&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor&quot; /&gt; equal to.">Uma <see cref="T:System.Guid" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</param>
      <param name="documentType" vsli:raw="A &lt;see cref=&quot;T:System.Guid&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType&quot; /&gt; equal to.">Uma <see cref="T:System.Guid" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.SymbolDocumentInfo&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.FileName&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.Language&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType&quot; /&gt; properties set to the specified value.">Um <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tem as propriedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> definidas para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a throwing of an exception.">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma geração de uma exceção.</summary>
      <param name="value" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Um <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the exception.">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a exceção.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a throwing of an exception with a given type.">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um lançamento de uma exceção com um determinado tipo.</summary>
      <param name="value" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Um <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type" vsli:raw="The new &lt;see cref=&quot;T:System.Type&quot; /&gt; of the expression.">O novo <see cref="T:System.Type" /> da expressão.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents the exception.">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a exceção.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ToString">
      <summary vsli:raw="Returns a textual representation of the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retorna uma representação textual de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="A textual representation of the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Uma representação textual de <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt; representing a try block with any number of catch statements and neither a fault nor finally block.">Cria um <see cref="T:System.Linq.Expressions.TryExpression" /> representando um bloco try com qualquer número de instruções catch e nem um bloco fault nem finally.</summary>
      <param name="body" vsli:raw="The body of the try block.">O corpo do bloco try.</param>
      <param name="handlers" vsli:raw="The array of zero or more &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; expressions representing the catch statements to be associated with the try block.">A matriz de zero ou mais expressões <see cref="T:System.Linq.Expressions.CatchBlock" /> representando as instruções catch a serem associados com o bloco try.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.TryExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt; representing a try block with any number of catch statements and a finally block.">Cria uma <see cref="T:System.Linq.Expressions.TryExpression" /> representando um bloco try com qualquer número de instruções catch e um bloco finally.</summary>
      <param name="body" vsli:raw="The body of the try block.">O corpo do bloco try.</param>
      <param name="finally" vsli:raw="The body of the finally block.">O corpo do bloco finally.</param>
      <param name="handlers" vsli:raw="The array of zero or more &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; expressions representing the catch statements to be associated with the try block.">A matriz de zero ou mais expressões <see cref="T:System.Linq.Expressions.CatchBlock" /> representando as instruções catch a serem associados com o bloco try.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.TryExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt; representing a try block with a fault block and no catch statements.">Cria uma <see cref="T:System.Linq.Expressions.TryExpression" /> representando um bloco try com um bloco fault e nenhuma instrução catch.</summary>
      <param name="body" vsli:raw="The body of the try block.">O corpo do bloco try.</param>
      <param name="fault" vsli:raw="The body of the fault block.">O corpo do bloco de falha.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.TryExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt; representing a try block with a finally block and no catch statements.">Cria uma <see cref="T:System.Linq.Expressions.TryExpression" /> representando um bloco try com um bloco finally e nenhuma instrução catch.</summary>
      <param name="body" vsli:raw="The body of the try block.">O corpo do bloco try.</param>
      <param name="finally" vsli:raw="The body of the finally block.">O corpo do bloco finally.</param>
      <returns vsli:raw="The created &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt;.">O <see cref="T:System.Linq.Expressions.TryExpression" /> criado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; object that represents a generic System.Action delegate type that has specific type arguments.">Cria um objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa um tipo de delegado genérico System.Action que tem argumentos de tipo específicos.</summary>
      <param name="typeArgs" vsli:raw="An array of Type objects that specify the type arguments for the System.Action delegate type.">Uma matriz de objetos Type que especifica os argumentos de tipo para o tipo de delegado System.Action.</param>
      <param name="actionType" vsli:raw="When this method returns, contains the generic System.Action delegate type that has specific type arguments. Contains null if there is no generic System.Action delegate that matches the &lt;paramref name=&quot;typeArgs&quot; /&gt;. This parameter is passed uninitialized.">Quando esse método retorna, ele contém o tipo de delegado genérico System.Action, que tem argumentos de tipo específicos. Contém NULL se não houver nenhum delegado System. Action genérico que corresponda a <paramref name="typeArgs" /> . Este parâmetro é passado não inicializado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if generic System.Action delegate type was created for specific &lt;paramref name=&quot;typeArgs&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o tipo de delegado genérico System.Action foi criado para um <paramref name="typeArgs" /> específico; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; object that represents a generic System.Func delegate type that has specific type arguments. The last type argument specifies the return type of the created delegate.">Cria um objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa um tipo de delegado genérico System.Func, que tem argumentos de tipo específicos. O último argumento de tipo especifica o tipo de retorno do delegado criado.</summary>
      <param name="typeArgs" vsli:raw="An array of Type objects that specify the type arguments for the System.Func delegate type.">Uma matriz de objetos Type que especifica os argumentos de tipo para o tipo de delegado System.Func.</param>
      <param name="funcType" vsli:raw="When this method returns, contains the generic System.Func delegate type that has specific type arguments. Contains null if there is no generic System.Func delegate that matches the &lt;paramref name=&quot;typeArgs&quot; /&gt;. This parameter is passed uninitialized.">Quando esse método retorna, ele contém o tipo de delegado genérico System.Func, que tem argumentos de tipo específicos. Contém NULL se não houver nenhum delegado System. Func genérico que corresponda a <paramref name="typeArgs" /> . Este parâmetro é passado não inicializado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if generic System.Func delegate type was created for specific &lt;paramref name=&quot;typeArgs&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o tipo de delegado genérico System.Func foi criado para um <paramref name="typeArgs" /> específico; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents an explicit reference or boxing conversion where &lt;see langword=&quot;null&quot; /&gt; is supplied if the conversion fails.">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma conversão boxing ou de referência explícita em que <see langword="null" /> será fornecido se a conversão falhar.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; property equal to.">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.TypeAs&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.TypeBinaryExpression&quot; /&gt; that compares run-time type identity.">Cria uma <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> que compara a identidade de tipo de tempo de execução.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="T:System.Linq.Expressions.Expression" /> igual a ele.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand&quot; /&gt; property equal to.">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> igual a ele.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.TypeBinaryExpression&quot; /&gt; for which the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property is equal to &lt;see cref=&quot;M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)&quot; /&gt; and for which the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand&quot; /&gt; properties are set to the specified values.">Uma <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> para a qual a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> é igual a <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> e para a qual as propriedades <see cref="T:System.Linq.Expressions.Expression" /> e <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> estão definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.TypeBinaryExpression&quot; /&gt;.">Cria um <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.Expression&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> igual a ele.</param>
      <param name="type" vsli:raw="A &lt;see cref=&quot;P:System.Linq.Expressions.Expression.Type&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand&quot; /&gt; property equal to.">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; or &lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.TypeBinaryExpression&quot; /&gt; for which the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property is equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.TypeIs&quot; /&gt; and for which the &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.Expression&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand&quot; /&gt; properties are set to the specified values.">Uma <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> para a qual a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> é igual a <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> e para a qual as propriedades <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> e <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> estão definidas para os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a unary plus operation.">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação unária de adição.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The unary plus operator is not defined for &lt;paramref name=&quot;expression&quot; /&gt;.Type.">O operador de mais unário não foi definido para <paramref name="expression" />.Type.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.UnaryPlus&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property set to the specified value.">Uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> definida para o valor especificado.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents a unary plus operation.">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação unária de adição.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property equal to.">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
      <param name="method" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; to set the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; property equal to.">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;expression&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="expression" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is not &lt;see langword=&quot;null&quot; /&gt; and the method it represents returns &lt;see langword=&quot;void&quot; /&gt;, is not &lt;see langword=&quot;static&quot; /&gt; (&lt;see langword=&quot;Shared&quot; /&gt; in Visual Basic), or does not take exactly one argument.">
        <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and the unary plus operator is not defined for &lt;paramref name=&quot;expression&quot; /&gt;.Type.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;expression&quot; /&gt;.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by &lt;paramref name=&quot;method&quot; /&gt;.">
        <paramref name="method" /> é <see langword="null" /> e o operador unário de mais de não foi definido para <paramref name="expression" />.Type.  
  
- ou - 
 <paramref name="expression" />.Type (ou o respectivo tipo que não permite valor nulo correspondente se ele é um tipo que permite valor nulo) não é atribuível ao tipo de argumento do método representado por <paramref name="method" />.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that has the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.UnaryPlus&quot; /&gt; and the &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; and &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Method&quot; /&gt; properties set to the specified values.">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt; that represents an explicit unboxing.">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma conversão unboxing explícita.</summary>
      <param name="expression" vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; to unbox.">Um <see cref="T:System.Linq.Expressions.Expression" /> para realizar conversão unboxing.</param>
      <param name="type" vsli:raw="The new &lt;see cref=&quot;T:System.Type&quot; /&gt; of the expression.">O novo <see cref="T:System.Type" /> da expressão.</param>
      <returns vsli:raw="An instance of &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;.">Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; node that can be used to identify a parameter or a variable in an expression tree.">Cria um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que pode ser usado para identificar um parâmetro ou uma variável em uma árvore de expressão.</summary>
      <param name="type" vsli:raw="The type of the parameter or variable.">O tipo do parâmetro ou da variável.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; node with the specified name and type.">Um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> com o nome e o tipo especificados</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; node that can be used to identify a parameter or a variable in an expression tree.">Cria um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que pode ser usado para identificar um parâmetro ou uma variável em uma árvore de expressão.</summary>
      <param name="type" vsli:raw="The type of the parameter or variable.">O tipo do parâmetro ou da variável.</param>
      <param name="name" vsli:raw="The name of the parameter or variable. This name is used for debugging or printing purpose only.">O nome do parâmetro ou da variável. Esse nome é usado apenas para finalidades de depuração ou de impressão.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; node with the specified name and type.">Um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> com o nome e tipo especificados.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Reduces the node and then calls the visitor delegate on the reduced expression. The method throws an exception if the node is not reducible.">Reduz o nó e, em seguida, chama o delegado visitante na expressão reduzida. O método gera uma exceção se o nó não é reduzível.</summary>
      <param name="visitor" vsli:raw="An instance of &lt;see cref=&quot;T:System.Func`2&quot; /&gt;.">Uma instância de <see cref="T:System.Func`2" />.</param>
      <returns vsli:raw="The expression being visited, or an expression which should replace it in the tree.">A expressão que está sendo visitada ou uma expressão que deve substituí-la na árvore.</returns>
    </member>
    <member name="P:System.Linq.Expressions.Expression.CanReduce">
      <summary vsli:raw="Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.">Indica que o nó pode ser reduzido a um nó mais simples. Se isso retornar verdadeiro, Reduce() poderá ser chamado para produzir a forma reduzida.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the node can be reduced; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Se o nó puder ser reduzido; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.Expression.NodeType">
      <summary vsli:raw="Gets the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Obtém o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="One of the &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; values.">Um dos valores de <see cref="T:System.Linq.Expressions.ExpressionType" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.Expression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents the static type of the expression.">O <see cref="T:System.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.Expression`1">
      <summary vsli:raw="Represents a strongly typed lambda expression as a data structure in the form of an expression tree. This class cannot be inherited.">Representa uma expressão lambda fortemente tipada como uma estrutura de dados na forma de uma árvore de expressão. Essa classe não pode ser herdada.</summary>
      <typeparam name="TDelegate" vsli:raw="The type of the delegate that the &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt; represents.">O tipo do delegado que o <see cref="T:System.Linq.Expressions.Expression`1" /> representa.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile">
      <summary vsli:raw="Compiles the lambda expression described by the expression tree into executable code and produces a delegate that represents the lambda expression.">Compila a expressão lambda descrita pela árvore de expressão em um código executável e produz um delegado que representa a expressão lambda.</summary>
      <returns vsli:raw="A delegate of type &lt;paramref name=&quot;TDelegate&quot; /&gt; that represents the compiled lambda expression described by the &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt;.">Um delegado do tipo <paramref name="TDelegate" /> que representa a expressão lambda compilada descrita pelo <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile(System.Boolean)">
      <summary vsli:raw="Compiles the lambda expression described by the expression tree into interpreted or compiled code and produces a delegate that represents the lambda expression.">Compila a expressão lambda descrita pela árvore de expressão em um código interpretado ou compilado e produz um delegado que representa a expressão lambda.</summary>
      <param name="preferInterpretation" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to indicate that the expression should be compiled to an interpreted form, if it is available; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> para indicar que a expressão deverá ser compilada em um formato interpretado, se ele estiver disponível; <see langword="false" /> caso contrário.</param>
      <returns vsli:raw="A delegate that represents the compiled lambda expression described by the &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt;.">Um delegado que representa a expressão lambda compilada descrita pelo <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile(System.Runtime.CompilerServices.DebugInfoGenerator)">
      <summary vsli:raw="Produces a delegate that represents the lambda expression.">Produz um delegado que representa a expressão lambda.</summary>
      <param name="debugInfoGenerator" vsli:raw="Debugging information generator used by the compiler to mark sequence points and annotate local variables.">O gerador de informações de depuração usado pelo compilador para marcar pontos de sequência e anotar as variáveis locais.</param>
      <returns vsli:raw="A delegate containing the compiled version of the lambda.">Um delegado que contém a versão compilada da expressão lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="body" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Body&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> do resultado.</param>
      <param name="parameters" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Parameters&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> do resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionType">
      <summary vsli:raw="Describes the node types for the nodes of an expression tree.">Descreve os tipos de nós para os nós de uma árvore de expressão.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Add">
      <summary vsli:raw="An addition operation, such as &lt;c&gt;a + b&lt;/c&gt;, without overflow checking, for numeric operands.">Uma operação de adição, tal como <c>a + b</c>, sem verificação de estouro, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssign">
      <summary vsli:raw="An addition compound assignment operation, such as &lt;c&gt;(a += b)&lt;/c&gt;, without overflow checking, for numeric operands.">Uma operação de adição de atribuição composta, tal como <c>(a += b)</c>, sem verificação de estouro, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssignChecked">
      <summary vsli:raw="An addition compound assignment operation, such as &lt;c&gt;(a += b)&lt;/c&gt;, with overflow checking, for numeric operands.">Uma operação de adição de atribuição composta, tal como <c>(a += b)</c>, com verificação de estouro, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddChecked">
      <summary vsli:raw="An addition operation, such as &lt;c&gt;(a + b)&lt;/c&gt;, with overflow checking, for numeric operands.">Uma operação de adição, tal como <c>(a + b)</c>, com verificação de estouro, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.And">
      <summary vsli:raw="A bitwise or logical &lt;see langword=&quot;AND&quot; /&gt; operation, such as &lt;c&gt;(a &amp;amp; b)&lt;/c&gt; in C# and &lt;c&gt;(a And b)&lt;/c&gt; in Visual Basic.">Uma operação <see langword="AND" /> lógica ou bit a bit, tal como <c>(a &amp; b)</c> em C# e <c>(a And b)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAlso">
      <summary vsli:raw="A conditional &lt;see langword=&quot;AND&quot; /&gt; operation that evaluates the second operand only if the first operand evaluates to &lt;see langword=&quot;true&quot; /&gt;. It corresponds to &lt;c&gt;(a &amp;amp;&amp;amp; b)&lt;/c&gt; in C# and &lt;c&gt;(a AndAlso b)&lt;/c&gt; in Visual Basic.">Uma operação <see langword="AND" /> condicional que avalia o segundo operando somente se o primeiro operando é avaliado como <see langword="true" />. Ele corresponde a <c>(a &amp;&amp; b)</c> em C# e <c>(a AndAlso b)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAssign">
      <summary vsli:raw="A bitwise or logical &lt;see langword=&quot;AND&quot; /&gt; compound assignment operation, such as &lt;c&gt;(a &amp;amp;= b)&lt;/c&gt; in C#.">Uma operação de atribuição de associação de nível lógico ou de bits lógica <see langword="AND" /> , como <c>(a &amp; = b)</c> em C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayIndex">
      <summary vsli:raw="An indexing operation in a one-dimensional array, such as &lt;c&gt;array[index]&lt;/c&gt; in C# or &lt;c&gt;array(index)&lt;/c&gt; in Visual Basic.">Uma operação de indexação em uma matriz unidimensional, tal como <c>array[index]</c> em C# ou <c>array(index)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayLength">
      <summary vsli:raw="An operation that obtains the length of a one-dimensional array, such as &lt;c&gt;array.Length&lt;/c&gt;.">Uma operação que obtém o tamanho de uma matriz unidimensional, tal como <c>array.Length</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Assign">
      <summary vsli:raw="An assignment operation, such as &lt;c&gt;(a = b)&lt;/c&gt;.">Uma operação de atribuição, tal como <c>(a = b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Block">
      <summary vsli:raw="A block of expressions.">Um bloco de expressões.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Call">
      <summary vsli:raw="A method call, such as in the &lt;c&gt;obj.sampleMethod()&lt;/c&gt; expression.">Uma chamada de método, como na expressão <c>obj.sampleMethod()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Coalesce">
      <summary vsli:raw="A node that represents a null coalescing operation, such as &lt;c&gt;(a ?? b)&lt;/c&gt; in C# or &lt;c&gt;If(a, b)&lt;/c&gt; in Visual Basic.">Um nó que representa uma operação de união nula, tal como <c>(a ?? b)</c> em C# ou <c>If(a, b)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Conditional">
      <summary vsli:raw="A conditional operation, such as &lt;c&gt;a &amp;gt; b ? a : b&lt;/c&gt; in C# or &lt;c&gt;If(a &amp;gt; b, a, b)&lt;/c&gt; in Visual Basic.">Uma operação condicional, tal como <c>a &gt; b ? a : b</c> em C# ou <c>If(a &gt; b, a, b)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Constant">
      <summary vsli:raw="A constant value.">Um valor constante.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Convert">
      <summary vsli:raw="A cast or conversion operation, such as &lt;c&gt;(SampleType)obj&lt;/c&gt; in C#or &lt;c&gt;CType(obj, SampleType)&lt;/c&gt; in Visual Basic. For a numeric conversion, if the converted value is too large for the destination type, no exception is thrown.">Uma operação de conversão ou transmissão, tal como <c>(SampleType)obj</c> em C# ou <c>CType(obj, SampleType)</c> no Visual Basic. Para uma conversão numérica, se o valor convertido é muito grande para o tipo de destino, nenhuma exceção é lançada.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ConvertChecked">
      <summary vsli:raw="A cast or conversion operation, such as &lt;c&gt;(SampleType)obj&lt;/c&gt; in C#or &lt;c&gt;CType(obj, SampleType)&lt;/c&gt; in Visual Basic. For a numeric conversion, if the converted value does not fit the destination type, an exception is thrown.">Uma operação de conversão ou transmissão, tal como <c>(SampleType)obj</c> em C# ou <c>CType(obj, SampleType)</c> no Visual Basic. Para uma conversão numérica, se o valor convertido não se ajusta ao tipo de destino, nenhuma exceção será lançada.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DebugInfo">
      <summary vsli:raw="Debugging information.">Informações de depuração.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Decrement">
      <summary vsli:raw="A unary decrement operation, such as &lt;c&gt;(a - 1)&lt;/c&gt; in C# and Visual Basic. The object &lt;c&gt;a&lt;/c&gt; should not be modified in place.">Uma operação de decremento unária, tal como <c>(a – 1)</c> em C# e Visual Basic. O objeto <c>a</c> não deve ser modificado no lugar em que se encontra.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Default">
      <summary vsli:raw="A default value.">Um valor padrão.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Divide">
      <summary vsli:raw="A division operation, such as &lt;c&gt;(a / b)&lt;/c&gt;, for numeric operands.">Uma operação de divisão, tal como <c>(a / b)</c>, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DivideAssign">
      <summary vsli:raw="An division compound assignment operation, such as &lt;c&gt;(a /= b)&lt;/c&gt;, for numeric operands.">Uma operação de divisão de atribuição composta, tal como <c>(a /= b)</c>, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Dynamic">
      <summary vsli:raw="A dynamic operation.">Uma operação dinâmica.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Equal">
      <summary vsli:raw="A node that represents an equality comparison, such as &lt;c&gt;(a == b)&lt;/c&gt; in C# or &lt;c&gt;(a = b)&lt;/c&gt; in Visual Basic.">Um nó que representa uma comparação de igualdade, tal como <c>(a == b)</c> em C# ou <c>(a = b)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOr">
      <summary vsli:raw="A bitwise or logical &lt;see langword=&quot;XOR&quot; /&gt; operation, such as &lt;c&gt;(a ^ b)&lt;/c&gt; in C# or &lt;c&gt;(a Xor b)&lt;/c&gt; in Visual Basic.">Uma operação <see langword="XOR" /> lógica ou bit a bit, tal como <c>(a ^ b)</c> em C# e <c>(a Xor b)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign">
      <summary vsli:raw="A bitwise or logical &lt;see langword=&quot;XOR&quot; /&gt; compound assignment operation, such as &lt;c&gt;(a ^= b)&lt;/c&gt; in C#.">Uma operação de atribuição composta <see langword="XOR" /> lógica ou bit a bit como <c>(a ^= b)</c> em C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Extension">
      <summary vsli:raw="An extension expression.">Uma expressão de extensão.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Goto">
      <summary vsli:raw="A &quot;go to&quot; expression, such as &lt;c&gt;goto Label&lt;/c&gt; in C# or &lt;c&gt;GoTo Label&lt;/c&gt; in Visual Basic.">Uma expressão "go to", tal como <c>goto Rótulo</c> em C# ou <c>GoTo Rótulo</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThan">
      <summary vsli:raw="A &quot;greater than&quot; comparison, such as &lt;c&gt;(a &amp;gt; b)&lt;/c&gt;.">Uma comparação "maior que", tal como <c>(a &gt; b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual">
      <summary vsli:raw="A &quot;greater than or equal to&quot; comparison, such as &lt;c&gt;(a &amp;gt;= b)&lt;/c&gt;.">Uma comparação "maior que ou igual a" como <c>(a &gt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Increment">
      <summary vsli:raw="A unary increment operation, such as &lt;c&gt;(a + 1)&lt;/c&gt; in C# and Visual Basic. The object &lt;c&gt;a&lt;/c&gt; should not be modified in place.">Uma operação de incremento unária como <c>(a + 1)</c> em C# e Visual Basic. O objeto <c>a</c> não deve ser modificado no lugar em que se encontra.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Index">
      <summary vsli:raw="An index operation or an operation that accesses a property that takes arguments.">Uma operação de índice ou uma operação que acessa uma propriedade que aceita argumentos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Invoke">
      <summary vsli:raw="An operation that invokes a delegate or lambda expression, such as &lt;c&gt;sampleDelegate.Invoke()&lt;/c&gt;.">Uma operação que invoca uma expressão delegada ou lambda, tal como <c>sampleDelegate.Invoke()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsFalse">
      <summary vsli:raw="A &lt;see langword=&quot;false&quot; /&gt; condition value.">Um valor de condição <see langword="false" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsTrue">
      <summary vsli:raw="A &lt;see langword=&quot;true&quot; /&gt; condition value.">Um valor de condição <see langword="true" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Label">
      <summary vsli:raw="A label.">Um rótulo.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Lambda">
      <summary vsli:raw="A lambda expression, such as &lt;c&gt;a =&amp;gt; a + a&lt;/c&gt; in C# or &lt;c&gt;Function(a) a + a&lt;/c&gt; in Visual Basic.">Uma expressão lambda, tal como <c>a =&gt; a + a</c> em C# ou <c>Function(a) a + a</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShift">
      <summary vsli:raw="A bitwise left-shift operation, such as &lt;c&gt;(a &amp;lt;&amp;lt; b)&lt;/c&gt;.">Uma operação bit a bit de deslocamento à esquerda, tal como <c>(a &lt;&lt; b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign">
      <summary vsli:raw="A bitwise left-shift compound assignment, such as &lt;c&gt;(a &amp;lt;&amp;lt;= b)&lt;/c&gt;.">Uma atribuição composta bit a bit de deslocamento à esquerda, tal como <c>(a &lt;&lt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThan">
      <summary vsli:raw="A &quot;less than&quot; comparison, such as &lt;c&gt;(a &amp;lt; b)&lt;/c&gt;.">Uma comparação "menor que", tal como <c>(a &lt; b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual">
      <summary vsli:raw="A &quot;less than or equal to&quot; comparison, such as &lt;c&gt;(a &amp;lt;= b)&lt;/c&gt;.">Uma comparação "menor que ou igual a", tal como <c>(a &lt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ListInit">
      <summary vsli:raw="An operation that creates a new &lt;see cref=&quot;T:System.Collections.IEnumerable&quot; /&gt; object and initializes it from a list of elements, such as &lt;c&gt;new List&amp;lt;SampleType&amp;gt;(){ a, b, c }&lt;/c&gt; in C# or &lt;c&gt;Dim sampleList = { a, b, c }&lt;/c&gt; in Visual Basic.">Uma operação que cria um novo objeto <see cref="T:System.Collections.IEnumerable" /> e o inicializa de uma lista de elementos, tais como <c>new List&lt;SampleType&gt;(){ a, b, c }</c> em C# ou <c>Dim sampleList = { a, b, c }</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Loop">
      <summary vsli:raw="A loop, such as &lt;c&gt;for&lt;/c&gt; or &lt;c&gt;while&lt;/c&gt;.">Um loop, assim como <c>for</c> ou <c>while</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberAccess">
      <summary vsli:raw="An operation that reads from a field or property, such as &lt;c&gt;obj.SampleProperty&lt;/c&gt;.">Uma operação que lê de um campo ou propriedade, tal como <c>obj.SampleProperty</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberInit">
      <summary vsli:raw="An operation that creates a new object and initializes one or more of its members, such as &lt;c&gt;new Point { X = 1, Y = 2 }&lt;/c&gt; in C# or &lt;c&gt;New Point With {.X = 1, .Y = 2}&lt;/c&gt; in Visual Basic.">Uma operação que cria um novo objeto e inicializa um ou mais de seus membros, tal como <c>new Point { X = 1, Y = 2 }</c> em C# ou <c>New Point With {.X = 1, .Y = 2}</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Modulo">
      <summary vsli:raw="An arithmetic remainder operation, such as &lt;c&gt;(a % b)&lt;/c&gt; in C# or &lt;c&gt;(a Mod b)&lt;/c&gt; in Visual Basic.">Uma operação aritmética restante, tal como <c>(a % b)</c> em C# ou <c>(a Mod b)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ModuloAssign">
      <summary vsli:raw="An arithmetic remainder compound assignment operation, such as &lt;c&gt;(a %= b)&lt;/c&gt; in C#.">Uma operação aritmética restante de atribuição composta, tal como <c>(a %= b)</c> em C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Multiply">
      <summary vsli:raw="A multiplication operation, such as &lt;c&gt;(a * b)&lt;/c&gt;, without overflow checking, for numeric operands.">Uma operação de multiplicação, tal como <c>(a * b)</c>, sem verificação de estouro, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssign">
      <summary vsli:raw="A multiplication compound assignment operation, such as &lt;c&gt;(a *= b)&lt;/c&gt;, without overflow checking, for numeric operands.">Uma operação de multiplicação de atribuição composta, tal como <c>(a *= b)</c>, sem verificação de estouro, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked">
      <summary vsli:raw="A multiplication compound assignment operation, such as &lt;c&gt;(a *= b)&lt;/c&gt;, that has overflow checking, for numeric operands.">Uma operação de multiplicação de atribuição composta, tal como <c>(a *= b)</c>, que tem verificação de estouro, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyChecked">
      <summary vsli:raw="An multiplication operation, such as &lt;c&gt;(a * b)&lt;/c&gt;, that has overflow checking, for numeric operands.">Uma operação de multiplicação, tal como <c>(a * b)</c>, com verificação de estouro, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Negate">
      <summary vsli:raw="An arithmetic negation operation, such as &lt;c&gt;(-a)&lt;/c&gt;. The object &lt;c&gt;a&lt;/c&gt; should not be modified in place.">Uma operação de negação aritmética, tal como <c>(-a)</c>. O objeto <c>a</c> não deve ser modificado no lugar em que se encontra.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NegateChecked">
      <summary vsli:raw="An arithmetic negation operation, such as &lt;c&gt;(-a)&lt;/c&gt;, that has overflow checking. The object &lt;c&gt;a&lt;/c&gt; should not be modified in place.">Uma operação de negação aritmética, tal como <c>(-a)</c>, que tem a verificação de estouro. O objeto <c>a</c> não deve ser modificado no lugar em que se encontra.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.New">
      <summary vsli:raw="An operation that calls a constructor to create a new object, such as &lt;c&gt;new SampleType()&lt;/c&gt;.">Uma operação que chama um construtor para criar um novo objeto, tal como <c>new SampleType()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayBounds">
      <summary vsli:raw="An operation that creates a new array, in which the bounds for each dimension are specified, such as &lt;c&gt;new SampleType[dim1, dim2]&lt;/c&gt; in C# or &lt;c&gt;New SampleType(dim1, dim2)&lt;/c&gt; in Visual Basic.">Uma operação que cria uma nova matriz e na qual os limites de cada dimensão são especificados, tal como <c>new SampleType[dim1, dim2]</c> em C# ou <c>New SampleType(dim1, dim2)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayInit">
      <summary vsli:raw="An operation that creates a new one-dimensional array and initializes it from a list of elements, such as &lt;c&gt;new SampleType[]{a, b, c}&lt;/c&gt; in C# or &lt;c&gt;New SampleType(){a, b, c}&lt;/c&gt; in Visual Basic.">Uma operação que cria uma nova matriz unidirecional e a inicializa de uma lista de elementos, tal como <c>new SampleType[]{a, b, c}</c> em C# ou <c>New SampleType(){a, b, c}</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Not">
      <summary vsli:raw="A bitwise complement or logical negation operation. In C#, it is equivalent to &lt;c&gt;(~a)&lt;/c&gt; for integral types and to &lt;c&gt;(!a)&lt;/c&gt; for Boolean values. In Visual Basic, it is equivalent to &lt;c&gt;(Not a)&lt;/c&gt;. The object &lt;c&gt;a&lt;/c&gt; should not be modified in place.">Uma operação de negação lógica ou de complemento bit a bit. Em C#, é equivalente a <c>(~a)</c> para tipos integrais e a <c>(!a)</c> para valores boolianos. No Visual Basic, é equivalente a <c>(Not a)</c>. O objeto <c>a</c> não deve ser modificado no lugar em que se encontra.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NotEqual">
      <summary vsli:raw="An inequality comparison, such as &lt;c&gt;(a != b)&lt;/c&gt; in C# or &lt;c&gt;(a &amp;lt;&amp;gt; b)&lt;/c&gt; in Visual Basic.">Uma comparação de desigualdade, tal como <c>(a != b)</c> em C# ou <c>(a &lt;&gt; b)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OnesComplement">
      <summary vsli:raw="A ones complement operation, such as &lt;c&gt;(~a)&lt;/c&gt; in C#.">Uma operação de um complemento, tal como <c>(~a)</c> em C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Or">
      <summary vsli:raw="A bitwise or logical &lt;see langword=&quot;OR&quot; /&gt; operation, such as &lt;c&gt;(a | b)&lt;/c&gt; in C# or &lt;c&gt;(a Or b)&lt;/c&gt; in Visual Basic.">Uma operação <see langword="OR" /> lógica ou bit a bit, tal como <c>(a ^ b)</c> em C# e <c>(a Or b)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrAssign">
      <summary vsli:raw="A bitwise or logical &lt;see langword=&quot;OR&quot; /&gt; compound assignment, such as &lt;c&gt;(a |= b)&lt;/c&gt; in C#.">Uma atribuição composta <see langword="OR" /> lógica ou bit a bit, tal como <c>(a |= b)</c> em C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrElse">
      <summary vsli:raw="A short-circuiting conditional &lt;see langword=&quot;OR&quot; /&gt; operation, such as &lt;c&gt;(a || b)&lt;/c&gt; in C# or &lt;c&gt;(a OrElse b)&lt;/c&gt; in Visual Basic.">Uma operação <see langword="OR" /> condicional de curto-circuito, tal como <c>(a || b)</c> em C# ou <c>(a OrElse b)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Parameter">
      <summary vsli:raw="A reference to a parameter or variable that is defined in the context of the expression. For more information, see &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt;.">Uma referência a um parâmetro ou uma variável que é definida no contexto da expressão. Para obter mais informações, consulte <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostDecrementAssign">
      <summary vsli:raw="A unary postfix decrement, such as &lt;c&gt;(a--)&lt;/c&gt;. The object &lt;c&gt;a&lt;/c&gt; should be modified in place.">Um decremento de sufixo unário, tal como <c>(a--)</c>. O objeto <c>a</c> deve ser modificado no lugar.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostIncrementAssign">
      <summary vsli:raw="A unary postfix increment, such as &lt;c&gt;(a++)&lt;/c&gt;. The object &lt;c&gt;a&lt;/c&gt; should be modified in place.">Um incremento de sufixo unário, tal como <c>(a++)</c>. O objeto <c>a</c> deve ser modificado no lugar.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Power">
      <summary vsli:raw="A mathematical operation that raises a number to a power, such as &lt;c&gt;(a ^ b)&lt;/c&gt; in Visual Basic.">Uma operação matemática que eleva um número a uma potência, tal como <c>(a ^ b)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PowerAssign">
      <summary vsli:raw="A compound assignment operation that raises a number to a power, such as &lt;c&gt;(a ^= b)&lt;/c&gt; in Visual Basic.">Uma operação de atribuição composta que eleva um número a uma potência, tal como <c>(a ^= b)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreDecrementAssign">
      <summary vsli:raw="A unary prefix decrement, such as &lt;c&gt;(--a)&lt;/c&gt;. The object &lt;c&gt;a&lt;/c&gt; should be modified in place.">Um decremento de prefixo unário, tal como <c>(--a)</c>. O objeto <c>a</c> deve ser modificado no lugar.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreIncrementAssign">
      <summary vsli:raw="A unary prefix increment, such as &lt;c&gt;(++a)&lt;/c&gt;. The object &lt;c&gt;a&lt;/c&gt; should be modified in place.">Um incremento de prefixo unário, como <c>(++a)</c>. O objeto <c>a</c> deve ser modificado no lugar.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Quote">
      <summary vsli:raw="An expression that has a constant value of type &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;. A &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Quote&quot; /&gt; node can contain references to parameters that are defined in the context of the expression it represents.">Uma expressão que tem um valor constante do tipo <see cref="T:System.Linq.Expressions.Expression" />. Um nó <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> pode conter referências a parâmetros que são definidas no contexto da expressão que ele representa.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShift">
      <summary vsli:raw="A bitwise right-shift operation, such as &lt;c&gt;(a &amp;gt;&amp;gt; b)&lt;/c&gt;.">Uma operação bit a bit de deslocamento à direita, tal como <c>(a &gt;&gt; b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShiftAssign">
      <summary vsli:raw="A bitwise right-shift compound assignment operation, such as &lt;c&gt;(a &amp;gt;&amp;gt;= b)&lt;/c&gt;.">Uma operação de atribuição composta de deslocamento à direita, tal como <c>(a &gt;&gt;= b)</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RuntimeVariables">
      <summary vsli:raw="A list of run-time variables. For more information, see &lt;see cref=&quot;T:System.Linq.Expressions.RuntimeVariablesExpression&quot; /&gt;.">Uma lista de variáveis de tempo de execução. Para obter mais informações, consulte <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Subtract">
      <summary vsli:raw="A subtraction operation, such as &lt;c&gt;(a - b)&lt;/c&gt;, without overflow checking, for numeric operands.">Uma operação de subtração como <c>(a – b)</c>, sem verificação de estouro, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssign">
      <summary vsli:raw="A subtraction compound assignment operation, such as &lt;c&gt;(a -= b)&lt;/c&gt;, without overflow checking, for numeric operands.">Uma operação de subtração de atribuição composta como <c>(a -= b)</c>, sem verificação de estouro, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked">
      <summary vsli:raw="A subtraction compound assignment operation, such as &lt;c&gt;(a -= b)&lt;/c&gt;, that has overflow checking, for numeric operands.">Uma operação de subtração de atribuição composta como <c>(a -= b)</c>, com verificação de estouro, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractChecked">
      <summary vsli:raw="An arithmetic subtraction operation, such as &lt;c&gt;(a - b)&lt;/c&gt;, that has overflow checking, for numeric operands.">Uma operação aritmética de subtração, como <c>(a – b)</c>, com verificação de estouro, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Switch">
      <summary vsli:raw="A switch operation, such as &lt;see langword=&quot;switch&quot; /&gt; in C# or &lt;see langword=&quot;Select Case&quot; /&gt; in Visual Basic.">Uma operação do comutador, como <see langword="switch" /> em C# ou <see langword="Select Case" /> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Throw">
      <summary vsli:raw="An operation that throws an exception, such as &lt;c&gt;throw new Exception()&lt;/c&gt;.">Uma operação que gera uma exceção, tal como <c>throw new Exception()</c>.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Try">
      <summary vsli:raw="A &lt;see langword=&quot;try-catch&quot; /&gt; expression.">Uma expressão <see langword="try-catch" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeAs">
      <summary vsli:raw="An explicit reference or boxing conversion in which &lt;see langword=&quot;null&quot; /&gt; is supplied if the conversion fails, such as &lt;c&gt;(obj as SampleType)&lt;/c&gt; in C# or &lt;c&gt;TryCast(obj, SampleType)&lt;/c&gt; in Visual Basic.">Uma referência explícita ou conversão boxing na qual <see langword="null" /> será fornecido se a conversão falhar, como <c>(obj as SampleType)</c> em C# ou <c>TryCast(obj, SampleType)</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeEqual">
      <summary vsli:raw="An exact type test.">Um teste de tipo exato.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeIs">
      <summary vsli:raw="A type test, such as &lt;c&gt;obj is SampleType&lt;/c&gt; in C# or &lt;c&gt;TypeOf obj is SampleType&lt;/c&gt; in Visual Basic.">Um tipo de teste, tal como <c>obj is SampleType</c> em C# ou <c>TypeOf obj is SampleType</c> no Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.UnaryPlus">
      <summary vsli:raw="A unary plus operation, such as &lt;c&gt;(+a)&lt;/c&gt;. The result of a predefined unary plus operation is the value of the operand, but user-defined implementations might have unusual results.">Uma operação de mais unária, tal como <c>(+a)</c>. O resultado de uma operação de mais unária predefinida é o valor do operando, mas implementações definidas pelo usuário podem ter resultados incomuns.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Unbox">
      <summary vsli:raw="An unbox value type operation, such as &lt;see langword=&quot;unbox&quot; /&gt; and &lt;see langword=&quot;unbox.any&quot; /&gt; instructions in MSIL.">Uma operação do tipo valor de unbox, como instruções <see langword="unbox" /> e <see langword="unbox.any" /> no MSIL.</summary>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionVisitor">
      <summary vsli:raw="Represents a visitor or rewriter for expression trees.">Representa um visitante ou regravador para árvores de expressão.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.#ctor">
      <summary vsli:raw="Initializes a new instance of &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionVisitor&quot; /&gt;.">Inicializa uma nova instância de <see cref="T:System.Linq.Expressions.ExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Dispatches the list of expressions to one of the more specialized visit methods in this class.">Envia a lista de expressões para um dos métodos de visita mais especializados nessa classe.</summary>
      <param name="nodes" vsli:raw="The expressions to visit.">As expressões a visitar.</param>
      <returns vsli:raw="The modified expression list, if any one of the elements were modified; otherwise, returns the original expression list.">A lista de expressões modificada, se qualquer um dos elementos tiver sido modificado; caso contrário, retornará a lista de expressões original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Dispatches the expression to one of the more specialized visit methods in this class.">Envia a expressão a um dos métodos de visita mais especializados nessa classe.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Func{``0,``0})">
      <summary vsli:raw="Visits all nodes in the collection using a specified element visitor.">Visita todos os nós na coleção usando um visitante de elemento especificado.</summary>
      <param name="nodes" vsli:raw="The nodes to visit.">Os nós a visitar.</param>
      <param name="elementVisitor" vsli:raw="A delegate that visits a single element, optionally replacing it with a new element.">Um delegado que visita um único elemento, substituindo-o opcionalmente por um novo elemento.</param>
      <typeparam name="T" vsli:raw="The type of the nodes.">O tipo dos nós.</typeparam>
      <returns vsli:raw="The modified node list, if any of the elements were modified; otherwise, returns the original node list.">A lista de nós modificada, se qualquer dos elementos tiver sido modificado; caso contrário, retornará a lista de nós original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(``0,System.String)">
      <summary vsli:raw="Visits an expression, casting the result back to the original expression type.">Visita uma expressão, convertendo os resultados de volta ao tipo de expressão original.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <param name="callerName" vsli:raw="The name of the calling method; used to report to report a better error message.">O nome do método de chamada; usado para relatar uma mensagem de erro melhor.</param>
      <typeparam name="T" vsli:raw="The type of the expression.">O tipo de expressão.</typeparam>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The visit method for this node returned a different type.">O método visit para este nó retornou um tipo diferente.</exception>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.String)">
      <summary vsli:raw="Visits all expressions in the collection, casting the results back to the original expression type.">Visitas todas as expressões na coleção, convertendo os resultados de volta para o tipo de expressão original.</summary>
      <param name="nodes" vsli:raw="The expressions to visit.">As expressões a visitar.</param>
      <param name="callerName" vsli:raw="The name of the calling method; used to report a better error message.">O nome do método de chamada; usado para relatar uma mensagem de erro melhor.</param>
      <typeparam name="T" vsli:raw="The type of the expressions.">O tipo das expressões.</typeparam>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The visit method for one of the expressions returned a different type.">O método visit para uma das expressões retornou um tipo diferente.</exception>
      <returns vsli:raw="The modified expression collection, if any expression was modified; otherwise, returns the original expression collection.">A coleção de expressões modificada, se qualquer expressão foi modificada; caso contrário, retorna a coleção de expressões original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.BinaryExpression&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.BinaryExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.BlockExpression&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.BlockExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitCatchBlock(System.Linq.Expressions.CatchBlock)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.ConditionalExpression&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.ConditionalExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
      <summary vsli:raw="Visits the &lt;see cref=&quot;T:System.Linq.Expressions.ConstantExpression&quot; /&gt;.">Visita o <see cref="T:System.Linq.Expressions.ConstantExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDebugInfo(System.Linq.Expressions.DebugInfoExpression)">
      <summary vsli:raw="Visits the &lt;see cref=&quot;T:System.Linq.Expressions.DebugInfoExpression&quot; /&gt;.">Visita o <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDefault(System.Linq.Expressions.DefaultExpression)">
      <summary vsli:raw="Visits the &lt;see cref=&quot;T:System.Linq.Expressions.DefaultExpression&quot; /&gt;.">Visita o <see cref="T:System.Linq.Expressions.DefaultExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDynamic(System.Linq.Expressions.DynamicExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.DynamicExpression&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.DynamicExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitElementInit(System.Linq.Expressions.ElementInit)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitExtension(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Visits the children of the extension expression.">Visita os filhos da expressão de extensão.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitGoto(System.Linq.Expressions.GotoExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitIndex(System.Linq.Expressions.IndexExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.IndexExpression&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.IndexExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.InvocationExpression&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.InvocationExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabel(System.Linq.Expressions.LabelExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.LabelExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabelTarget(System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Visits the &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt;.">Visita o <see cref="T:System.Linq.Expressions.LabelTarget" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.Expression`1&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.Expression`1" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <typeparam name="T" vsli:raw="The type of the delegate.">O tipo do delegado.</typeparam>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.ListInitExpression&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.ListInitExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLoop(System.Linq.Expressions.LoopExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.LoopExpression&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.LoopExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMember(System.Linq.Expressions.MemberExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberExpression&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.MemberExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberAssignment&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.MemberAssignment" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberBinding(System.Linq.Expressions.MemberBinding)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberInitExpression&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberListBinding&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.MemberListBinding" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberMemberBinding&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.MemberMemberBinding" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.NewExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.NewArrayExpression&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.NewArrayExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
      <summary vsli:raw="Visits the &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt;.">Visita o <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitRuntimeVariables(System.Linq.Expressions.RuntimeVariablesExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.RuntimeVariablesExpression&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitch(System.Linq.Expressions.SwitchExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitchCase(System.Linq.Expressions.SwitchCase)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.SwitchCase&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTry(System.Linq.Expressions.TryExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.TryExpression&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.TryExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTypeBinary(System.Linq.Expressions.TypeBinaryExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.TypeBinaryExpression&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
      <summary vsli:raw="Visits the children of the &lt;see cref=&quot;T:System.Linq.Expressions.UnaryExpression&quot; /&gt;.">Visita os filhos de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</summary>
      <param name="node" vsli:raw="The expression to visit.">A expressão a ser visitada.</param>
      <returns vsli:raw="The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.">A expressão modificada, se ela ou alguma subexpressão tiver sido modificada; caso contrário, retornará a expressão original.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpression">
      <summary vsli:raw="Represents an unconditional jump. This includes return statements, break and continue statements, and other jumps.">Representa um salto incondicional. Isso inclui o instruções de retorno, interrupção e continuação, entre outros saltos.</summary>
    </member>
    <member name="M:System.Linq.Expressions.GotoExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Target&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> do resultado.</param>
      <param name="value" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Value&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Value" /> do resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Kind">
      <summary vsli:raw="The kind of the &quot;go to&quot; expression. Serves information purposes only.">O tipo da expressão "go to". Serve apenas para fins informativos.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpressionKind&quot; /&gt; object representing the kind of the &quot;go to&quot; expression.">O <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> objeto que representa a espécie da expressão "go to".</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retorna o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa essa expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Target">
      <summary vsli:raw="The target label where this node jumps to.">O rótulo de destino para o qual este nó salta.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; object representing the target label for this node.">O <see cref="T:System.Linq.Expressions.LabelTarget" /> objeto que representa o rótulo de destino para este nó.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.GotoExpression.Type&quot; /&gt; that represents the static type of the expression.">O <see cref="P:System.Linq.Expressions.GotoExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Value">
      <summary vsli:raw="The value passed to the target, or null if the target is of type System.Void.">O valor passado para o destino ou nulo, se o destino é do tipo System.Void.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; object representing the value passed to the target or null.">O <see cref="T:System.Linq.Expressions.Expression" /> objeto que representa o valor passado para o destino ou nulo.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpressionKind">
      <summary vsli:raw="Specifies what kind of jump this &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; represents.">Especifica qual tipo de link esta <see cref="T:System.Linq.Expressions.GotoExpression" /> representa.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Break">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; that represents a break statement.">Uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução break.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Continue">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; that represents a continue statement.">Uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução continue.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Goto">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; that represents a jump to some location.">Uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa um link para um local.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Return">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt; that represents a return statement.">Uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução return.</summary>
    </member>
    <member name="T:System.Linq.Expressions.IArgumentProvider">
      <summary vsli:raw="Provides an internal interface for accessing the arguments of multiple tree nodes (DynamicExpression, ElementInit, MethodCallExpression, InvocationExpression, NewExpression, and IndexExpression).  This API is for internal use only.">Fornece uma interface interna para acessar os argumentos de vários nós de árvore (DynamicExpression, ElementInit, MethodCallExpression, InvocationExpression, NewExpression e IndexExpression).  Esta API é somente para uso interno.</summary>
    </member>
    <member name="M:System.Linq.Expressions.IArgumentProvider.GetArgument(System.Int32)">
      <summary vsli:raw="Returns the argument at &lt;paramref name=&quot;index&quot; /&gt;, throwing if &lt;paramref name=&quot;index&quot; /&gt; is out of bounds. This API is for internal use only.">Retorna o argumento no <paramref name="index" />, gerando se o <paramref name="index" /> estiver fora dos limites. Esta API é somente para uso interno.</summary>
      <param name="index" vsli:raw="The index of the argument.">O índice do argumento.</param>
      <returns vsli:raw="The argument at index.">O argumento no índice.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IArgumentProvider.ArgumentCount">
      <summary vsli:raw="Returns the number of arguments to the expression tree node. This API is for internal use only.">Retorna o número de argumentos para o nó de árvore de expressão. Esta API é somente para uso interno.</summary>
      <returns vsli:raw="The number of arguments to the expression tree node as &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">O número de argumentos para o nó da árvore de expressão como <see cref="T:System.Int32" /> .</returns>
    </member>
    <member name="T:System.Linq.Expressions.IDynamicExpression">
      <summary vsli:raw="Provides an internal interface for accessing the arguments of DynamicExpression tree nodes as well as CallSite and Rewriting functionality.  You should not use this API.  It is only public due to DLL refactoring and exists only for internal performance optimizations.">Fornece uma interface interna para acessar os argumentos de nós de árvore DynamicExpression, bem como funcionalidades de CallSite e de regravação.  Você não deve usar essa API.  Ela só é pública devido à refatoração de DLL e existe somente para otimizações de desempenho internas.</summary>
    </member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.CreateCallSite">
      <summary vsli:raw="Optionally creates the CallSite and returns the CallSite for the DynamicExpression's polymorphic inline cache.  You should not use this type.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Opcionalmente, cria e retorna o CallSite para o cache embutido polimórfico de DynamicExpression.  Você não deve usar esse tipo.  Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho.</summary>
      <returns vsli:raw="The CallSite for the DynamicExpression's polymorphic inline cache.">O CallSite para o cache embutido polimórfico de DynamicExpression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.Rewrite(System.Linq.Expressions.Expression[])">
      <summary vsli:raw="Rewrites this node replacing the dynamic expression's arguments with the provided values.  The number of &lt;paramref name=&quot;args&quot; /&gt; needs to match the number of the current expression.  You should not use this type.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.  This helper method allows re-writing of nodes to be independent of the specific implementation class deriving from DynamicExpression that is being used at the call site.">Regrava esse nó substituindo argumentos da expressão dinâmica pelos valores fornecidos.  O número de <paramref name="args" /> precisa corresponder ao número da expressão atual.  Você não deve usar esse tipo.  Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho.  Esse método auxiliar permite que a regravação de nós seja independente da classe de implementação específica derivada de DynamicExpression que está sendo usada no local da chamada.</summary>
      <param name="args" vsli:raw="The arguments used to replace this node.">Os argumentos usados para substituir esse nó.</param>
      <returns vsli:raw="The rewritten node, but if no changes were made, then returns the same node.">O nó regravado, mas se nenhuma alteração foi feita, retorna o mesmo nó.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IDynamicExpression.DelegateType">
      <summary vsli:raw="Gets the delegate type used by the CallSite, which is the type of the rules used in the dynamic expression's polymorphic inline cache.">Obtém o tipo de delegado usado pelo CallSite, que é o tipo das regras usadas no cache embutido polimórfico da expressão dinâmica.</summary>
      <returns vsli:raw="The delegate type used by the CallSite.">O tipo delegado usado pelo chamada.</returns>
    </member>
    <member name="T:System.Linq.Expressions.IndexExpression">
      <summary vsli:raw="Represents indexing a property or array.">Representa uma propriedade ou uma matriz de indexação.</summary>
    </member>
    <member name="M:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary vsli:raw="Returns the argument at index, throwing if index is out of bounds.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Retorna o argumento no índice, lançando se o índice estiver fora dos limites.  Você não deve usar esse membro.  Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho.</summary>
      <param name="index" vsli:raw="The index of the argument.">O índice do argumento.</param>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retorna <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IndexExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="object" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.IndexExpression.Object&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.IndexExpression.Object" /> do resultado.</param>
      <param name="arguments" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.IndexExpression.Arguments&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.IndexExpression.Arguments" /> do resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Arguments">
      <summary vsli:raw="Gets the arguments that will be used to index the property or array.">Obtém os argumentos que será usado para indexar a propriedade ou a matriz.</summary>
      <returns vsli:raw="The read-only collection containing the arguments that will be used to index the property or array.">A coleção somente leitura que contém os argumentos que serão usados para indexar a propriedade ou a matriz.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Indexer">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; for the property if the expression represents an indexed property, returns null otherwise.">Obtém o <see cref="T:System.Reflection.PropertyInfo" /> para a propriedade se a expressão representa uma propriedade indexada; caso contrário, retorna um valor nulo.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.PropertyInfo&quot; /&gt; for the property if the expression represents an indexed property, otherwise null.">O <see cref="T:System.Reflection.PropertyInfo" /> para a propriedade se a expressão representa uma propriedade indexada, caso contrário, NULL.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retorna o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa essa expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Object">
      <summary vsli:raw="An object to index.">Um objeto a indexar.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the object to index.">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o objeto a ser indexado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary vsli:raw="Returns the number of arguments to the expression tree node.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Retorna o número de argumentos para o nó de árvore de expressão.  Você não deve usar esse membro.  Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho.</summary>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">Retorna <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.IndexExpression.Type&quot; /&gt; that represents the static type of the expression.">O <see cref="P:System.Linq.Expressions.IndexExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.InvocationExpression">
      <summary vsli:raw="Represents an expression that applies a delegate or lambda expression to a list of argument expressions.">Representa uma expressão que se aplica a um delegado ou a expressão lambda para uma lista de expressões de argumento.</summary>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary vsli:raw="Returns the argument at index, throwing if index is out of bounds.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Retorna o argumento no índice, lançando se o índice estiver fora dos limites.  Você não deve usar esse membro.  Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho.</summary>
      <param name="index" vsli:raw="The index of the argument.">O índice do argumento.</param>
      <returns vsli:raw="The argument at index, throwing if index is out of bounds, as &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">O argumento no índice, gerando exceção se o índice está fora dos limites, assim como <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="expression" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.InvocationExpression.Expression&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> do resultado.</param>
      <param name="arguments" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.InvocationExpression.Arguments&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.InvocationExpression.Arguments" /> do resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Arguments">
      <summary vsli:raw="Gets the arguments that the delegate or lambda expression is applied to.">Obtém os argumentos aos quais que a expressão de delegado ou lambda é aplicada.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects which represent the arguments that the delegate is applied to.">Um <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> dos <see cref="T:System.Linq.Expressions.Expression" /> objetos que representam os argumentos aos quais o delegado é aplicado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Expression">
      <summary vsli:raw="Gets the delegate or lambda expression to be applied.">Obtém a expressão de delegado ou lambda a aplicar.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the delegate to be applied.">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o delegado a ser aplicado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.NodeType">
      <summary vsli:raw="Returns the node type of this expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Retorna o tipo de nó dessa expressão. Nós de extensão devem retornar <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> ao substituírem esse método.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary vsli:raw="Returns the number of arguments to the expression tree node.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Retorna o número de argumentos para o nó de árvore de expressão.  Você não deve usar esse membro.  Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho.</summary>
      <returns vsli:raw="The number of arguments to the expression tree node as &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">O número de argumentos para o nó da árvore de expressão como <see cref="T:System.Int32" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;P:System.Linq.Expressions.InvocationExpression.Expression&quot; /&gt; represents.">Obtém o tipo estático da expressão que esse <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.InvocationExpression.Type&quot; /&gt; that represents the static type of the expression.">O <see cref="P:System.Linq.Expressions.InvocationExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LabelExpression">
      <summary vsli:raw="Represents a label, which can be put in any &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; context. If it is jumped to, it will get the value provided by the corresponding &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt;. Otherwise, it receives the value in &lt;see cref=&quot;P:System.Linq.Expressions.LabelExpression.DefaultValue&quot; /&gt;. If the &lt;see cref=&quot;T:System.Type&quot; /&gt; equals System.Void, no value should be provided.">Representa um rótulo, que pode ser colocado em qualquer contexto <see cref="T:System.Linq.Expressions.Expression" />. Se for o destino do salto, ele receberá o valor fornecido pela <see cref="T:System.Linq.Expressions.GotoExpression" /> correspondente. Caso contrário, ele receberá o valor em <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" />. Se <see cref="T:System.Type" /> for igual a System.Void, nenhum valor deverá ser fornecido.</summary>
    </member>
    <member name="M:System.Linq.Expressions.LabelExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LabelExpression.Target&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.LabelExpression.Target" /> do resultado.</param>
      <param name="defaultValue" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LabelExpression.DefaultValue&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" /> do resultado</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.DefaultValue">
      <summary vsli:raw="The value of the &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt; when the label is reached through regular control flow (for example, is not jumped to).">O valor de <see cref="T:System.Linq.Expressions.LabelExpression" /> quando o rótulo é acessado por meio de fluxo de controle normal (por exemplo, não saltou).</summary>
      <returns vsli:raw="The Expression object representing the value of the &lt;see cref=&quot;T:System.Linq.Expressions.LabelExpression&quot; /&gt;.">O objeto Expressão que representa o valor de <see cref="T:System.Linq.Expressions.LabelExpression" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retorna o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa essa expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Target">
      <summary vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; which this label is associated with.">O <see cref="T:System.Linq.Expressions.LabelTarget" /> ao qual o rótulo está associado.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; which this label is associated with.">O <see cref="T:System.Linq.Expressions.LabelTarget" /> ao qual o rótulo está associado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LabelExpression.Type&quot; /&gt; that represents the static type of the expression.">O <see cref="P:System.Linq.Expressions.LabelExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LabelTarget">
      <summary vsli:raw="Used to represent the target of a &lt;see cref=&quot;T:System.Linq.Expressions.GotoExpression&quot; /&gt;.">Usado para representar o destino de um <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.LabelTarget.ToString">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.String&quot; /&gt; that represents the current &lt;see cref=&quot;T:System.Object&quot; /&gt;.">Retorna um valor <see cref="T:System.String" /> que representa o <see cref="T:System.Object" /> atual.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; that represents the current &lt;see cref=&quot;T:System.Object&quot; /&gt;.">Um <see cref="T:System.String" /> que representa o <see cref="T:System.Object" /> atual.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Name">
      <summary vsli:raw="Gets the name of the label.">Obtém o nome do rótulo.</summary>
      <returns vsli:raw="The name of the label.">O nome do rótulo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Type">
      <summary vsli:raw="The type of value that is passed when jumping to the label (or &lt;see cref=&quot;T:System.Void&quot; /&gt; if no value should be passed).">O tipo de valor que é passado ao saltar para o rótulo (ou <see cref="T:System.Void" />, caso nenhum valor deva ser passado).</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the type of the value that is passed when jumping to the label or &lt;see cref=&quot;T:System.Void&quot; /&gt; if no value should be passed.">O <see cref="T:System.Type" /> objeto que representa o tipo do valor que é passado ao saltar para o rótulo ou <see cref="T:System.Void" /> se nenhum valor deve ser passado</returns>
    </member>
    <member name="T:System.Linq.Expressions.LambdaExpression">
      <summary vsli:raw="Describes a lambda expression. This captures a block of code that is similar to a .NET method body.">Descreve uma expressão lambda. Isso captura um bloco de código semelhante a um corpo de método do .NET.</summary>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile">
      <summary vsli:raw="Produces a delegate that represents the lambda expression.">Produz um delegado que representa a expressão lambda.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Delegate&quot; /&gt; that contains the compiled version of the lambda expression.">Um <see cref="T:System.Delegate" /> que contém a versão compilada da expressão lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile(System.Boolean)">
      <summary vsli:raw="Produces an interpreted or compiled delegate that represents the lambda expression.">Produz um delegado interpretado ou compilado que representa a expressão lambda.</summary>
      <param name="preferInterpretation" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to indicate that the expression should be compiled to an interpreted form, if it's available; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para indicar que a expressão deverá ser compilada em um formato interpretado, se ele estiver disponível; <see langword="false" /> caso contrário.</param>
      <returns vsli:raw="A delegate that represents the compiled lambda expression described by the &lt;see cref=&quot;T:System.Linq.Expressions.LambdaExpression&quot; /&gt; object.">Um delegado que representa a expressão lambda compilada descrita pelo objeto <see cref="T:System.Linq.Expressions.LambdaExpression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile(System.Runtime.CompilerServices.DebugInfoGenerator)">
      <summary vsli:raw="Produces a delegate that represents the lambda expression.">Produz um delegado que representa a expressão lambda.</summary>
      <param name="debugInfoGenerator" vsli:raw="Debugging information generator used by the compiler to mark sequence points and annotate local variables.">O gerador de informações de depuração usado pelo compilador para marcar pontos de sequência e anotar as variáveis locais.</param>
      <returns vsli:raw="A delegate containing the compiled version of the lambda.">Um delegado que contém a versão compilada da expressão lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Body">
      <summary vsli:raw="Gets the body of the lambda expression.">Obtém o corpo da expressão lambda.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the body of the lambda expression.">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o corpo da expressão lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Name">
      <summary vsli:raw="Gets the name of the lambda expression.">Obtém o nome da expressão lambda.</summary>
      <returns vsli:raw="The name of the lambda expression.">O nome da expressão lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retorna o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa essa expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Parameters">
      <summary vsli:raw="Gets the parameters of the lambda expression.">Obtém os parâmetros da expressão lambda.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; objects that represent the parameters of the lambda expression.">Um <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representam os parâmetros da expressão lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.ReturnType">
      <summary vsli:raw="Gets the return type of the lambda expression.">Obtém o tipo de retorno da expressão lambda.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Type&quot; /&gt; object representing the type of the lambda expression.">O <see cref="T:System.Type" /> objeto que representa o tipo da expressão lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.TailCall">
      <summary vsli:raw="Gets the value that indicates if the lambda expression will be compiled with the tail call optimization.">Obtém o valor que indica se a expressão lambda será compilada com a otimização de chamada tail.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lambda expression will be compiled with the tail call optimization; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a expressão lambda será compilada com a otimização da chamada tail; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LambdaExpression.Type&quot; /&gt; that represents the static type of the expression.">O <see cref="P:System.Linq.Expressions.LambdaExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ListInitExpression">
      <summary vsli:raw="Represents a constructor call that has a collection initializer.">Representa uma chamada de construtor com um inicializador de coleção.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Reduce">
      <summary vsli:raw="Reduces the binary expression node to a simpler expression.">Reduz o nó de expressão binária para uma expressão mais simples.</summary>
      <returns vsli:raw="The reduced expression.">A expressão reduzida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="newExpression" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.NewExpression&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> do resultado.</param>
      <param name="initializers" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Initializers&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> do resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.CanReduce">
      <summary vsli:raw="Gets a value that indicates whether the expression tree node can be reduced.">Obtém um valor que indica se o nó da árvore de expressão pode ser reduzido.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the node can be reduced; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Se o nó puder ser reduzido; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Initializers">
      <summary vsli:raw="Gets the element initializers that are used to initialize a collection.">Obtém os inicializadores de elemento usados para inicializar uma coleção.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects which represent the elements that are used to initialize the collection.">Um <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> dos <see cref="T:System.Linq.Expressions.ElementInit" /> objetos que representam os elementos que são usados para inicializar a coleção.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NewExpression">
      <summary vsli:raw="Gets the expression that contains a call to the constructor of a collection type.">Obtém a expressão que contém uma chamada para o construtor de um tipo de coleção.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that represents the call to the constructor of a collection type.">Um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa a chamada para o construtor de um tipo de coleção.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retorna o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa essa expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ListInitExpression.Type&quot; /&gt; that represents the static type of the expression.">O <see cref="P:System.Linq.Expressions.ListInitExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LoopExpression">
      <summary vsli:raw="Represents an infinite loop. It can be exited with &quot;break&quot;.">Representa um loop infinito. Pode ser encerrado com "quebra".</summary>
    </member>
    <member name="M:System.Linq.Expressions.LoopExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="breakLabel" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LoopExpression.BreakLabel&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.LoopExpression.BreakLabel" /> do resultado.</param>
      <param name="continueLabel" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LoopExpression.ContinueLabel&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.LoopExpression.ContinueLabel" /> do resultado.</param>
      <param name="body" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LoopExpression.Body&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.LoopExpression.Body" /> do resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Body">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that is the body of the loop.">Obtém o <see cref="T:System.Linq.Expressions.Expression" /> que é o corpo do loop.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that is the body of the loop.">O <see cref="T:System.Linq.Expressions.Expression" /> que é o corpo do loop.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.BreakLabel">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that is used by the loop body as a break statement target.">Obtém o <see cref="T:System.Linq.Expressions.LabelTarget" /> que é usado pelo corpo do loop como um destino de instrução de interromper.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that is used by the loop body as a break statement target.">O <see cref="T:System.Linq.Expressions.LabelTarget" /> que é usado pelo corpo do loop como um destino de instrução break.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.ContinueLabel">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that is used by the loop body as a continue statement target.">Obtém o <see cref="T:System.Linq.Expressions.LabelTarget" /> que é usado pelo corpo do loop como um destino de instrução de continuar.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; that is used by the loop body as a continue statement target.">O <see cref="T:System.Linq.Expressions.LabelTarget" /> que é usado pelo corpo do loop como um destino da instrução Continue.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.NodeType">
      <summary vsli:raw="Returns the node type of this expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Retorna o tipo de nó dessa expressão. Nós de extensão devem retornar <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> ao substituírem esse método.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.LoopExpression.Type&quot; /&gt; that represents the static type of the expression.">O <see cref="P:System.Linq.Expressions.LoopExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberAssignment">
      <summary vsli:raw="Represents assignment operation for a field or property of an object.">Representa a operação de atribuição para um campo ou propriedade de um objeto.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberAssignment.Update(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="expression" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberAssignment.Expression&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> do resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberAssignment.Expression">
      <summary vsli:raw="Gets the expression to assign to the field or property.">Obtém a expressão a ser atribuída ao campo ou à propriedade.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the value to assign to the field or property.">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o valor a ser atribuído ao campo ou à propriedade.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBinding">
      <summary vsli:raw="Provides the base class from which the classes that represent bindings that are used to initialize members of a newly created object derive.">Fornece a classe base da qual derivam as classes que representam as associações que são usadas para inicializar os membros de derivação de um objeto recém-criado.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.#ctor(System.Linq.Expressions.MemberBindingType,System.Reflection.MemberInfo)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; class.">Inicializa uma nova instância da classe <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <param name="type" vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.MemberBindingType&quot; /&gt; that discriminates the type of binding that is represented.">O <see cref="T:System.Linq.Expressions.MemberBindingType" /> que discrimina o tipo de associação representado.</param>
      <param name="member" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; that represents a field or property to be initialized.">O <see cref="T:System.Reflection.MemberInfo" /> que representa um campo ou propriedade a ser inicializado.</param>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.ToString">
      <summary vsli:raw="Returns a textual representation of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt;.">Retorna uma representação textual de <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns vsli:raw="A textual representation of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt;.">Uma representação textual de <see cref="T:System.Linq.Expressions.MemberBinding" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.BindingType">
      <summary vsli:raw="Gets the type of binding that is represented.">Obtém o tipo de associação representado.</summary>
      <returns vsli:raw="One of the &lt;see cref=&quot;T:System.Linq.Expressions.MemberBindingType&quot; /&gt; values.">Um dos valores de <see cref="T:System.Linq.Expressions.MemberBindingType" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.Member">
      <summary vsli:raw="Gets the field or property to be initialized.">Obtém o campo ou a propriedade a ser inicializado.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; that represents the field or property to be initialized.">O <see cref="T:System.Reflection.MemberInfo" /> que representa o campo ou a propriedade a ser inicializada.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBindingType">
      <summary vsli:raw="Describes the binding types that are used in &lt;see cref=&quot;T:System.Linq.Expressions.MemberInitExpression&quot; /&gt; objects.">Descreve os tipos de associação usados em objetos <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.Assignment">
      <summary vsli:raw="A binding that represents initializing a member with the value of an expression.">Uma associação que representa a inicialização de um membro com o valor de uma expressão.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.ListBinding">
      <summary vsli:raw="A binding that represents initializing a member of type &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt; or &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot; /&gt; from a list of elements.">Uma associação que representa a inicialização de um membro do tipo <see cref="T:System.Collections.IList" /> ou <see cref="T:System.Collections.Generic.ICollection`1" /> de uma lista de elementos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.MemberBinding">
      <summary vsli:raw="A binding that represents recursively initializing members of a member.">Uma associação que representa inicializar recursivamente os membros de um membro.</summary>
    </member>
    <member name="T:System.Linq.Expressions.MemberExpression">
      <summary vsli:raw="Represents accessing a field or property.">Representa o acesso a um campo ou propriedade.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Expede o método específico de visita para esse tipo de nó. Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">O visitante com o qual visitar esse nó.</param>
      <returns vsli:raw="The result of visiting this node.">O resultado de visitar esse nó.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Update(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="expression" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> do resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Expression">
      <summary vsli:raw="Gets the containing object of the field or property.">Obtém o objeto recipiente do campo ou da propriedade.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the containing object of the field or property.">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o objeto recipiente do campo ou da propriedade.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Member">
      <summary vsli:raw="Gets the field or property to be accessed.">Obtém o campo ou a propriedade a ser acessada.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; that represents the field or property to be accessed.">O <see cref="T:System.Reflection.MemberInfo" /> que representa o campo ou a propriedade a ser acessada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;P:System.Linq.Expressions.MemberExpression.Expression&quot; /&gt;.">Retorna o tipo de nó deste <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa essa expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberInitExpression">
      <summary vsli:raw="Represents calling a constructor and initializing one or more members of the new object.">Representa a chamada de um construtor e a inicialização de um ou mais membros do novo objeto.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Reduce">
      <summary vsli:raw="Reduces the &lt;see cref=&quot;T:System.Linq.Expressions.MemberInitExpression&quot; /&gt; to a simpler expression.">Reduz o <see cref="T:System.Linq.Expressions.MemberInitExpression" /> a uma expressão mais simples.</summary>
      <returns vsli:raw="The reduced expression.">A expressão reduzida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="newExpression" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.NewExpression&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> do resultado.</param>
      <param name="bindings" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.Bindings&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> do resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Bindings">
      <summary vsli:raw="Gets the bindings that describe how to initialize the members of the newly created object.">Obtém as associações que descrevem como inicializar os membros do objeto recém-criado.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; objects which describe how to initialize the members.">Um <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> dos <see cref="T:System.Linq.Expressions.MemberBinding" /> objetos que descrevem como inicializar os membros.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.CanReduce">
      <summary vsli:raw="Gets a value that indicates whether the expression tree node can be reduced.">Obtém um valor que indica se o nó da árvore de expressão pode ser reduzido.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the node can be reduced; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Se o nó puder ser reduzido; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NewExpression">
      <summary vsli:raw="Gets the expression that represents the constructor call.">Obtém a expressão que representa a chamada do construtor.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Linq.Expressions.NewExpression&quot; /&gt; that represents the constructor call.">Um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa a chamada de construtor.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NodeType">
      <summary vsli:raw="Returns the node type of this Expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Retorna o tipo de nó dessa Expressão. Nós de extensão devem retornar <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> ao substituírem esse método.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberInitExpression.Type&quot; /&gt; that represents the static type of the expression.">O <see cref="P:System.Linq.Expressions.MemberInitExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberListBinding">
      <summary vsli:raw="Represents initializing the elements of a collection member of a newly created object.">Representa os elementos de inicialização de um membro da coleção de um objeto recém-criado.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberListBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="initializers" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberListBinding.Initializers&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> do resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberListBinding.Initializers">
      <summary vsli:raw="Gets the element initializers for initializing a collection member of a newly created object.">Obtém os inicializadores de elemento para inicializar um membro da coleção de um objeto recém-criado.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.ElementInit&quot; /&gt; objects to initialize a collection member with.">Um <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> dos <see cref="T:System.Linq.Expressions.ElementInit" /> objetos para os quais inicializar um membro da coleção.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberMemberBinding">
      <summary vsli:raw="Represents initializing members of a member of a newly created object.">Representa os membros de inicialização de um membro de um objeto recém-criado.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberMemberBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="bindings" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MemberMemberBinding.Bindings&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> do resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberMemberBinding.Bindings">
      <summary vsli:raw="Gets the bindings that describe how to initialize the members of a member.">Obtém as associações que descrevem como inicializar os membros de um membro.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.MemberBinding&quot; /&gt; objects that describe how to initialize the members of the member.">Um <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> dos <see cref="T:System.Linq.Expressions.MemberBinding" /> objetos que descrevem como inicializar os membros do membro.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MethodCallExpression">
      <summary vsli:raw="Represents a call to either static or an instance method.">Representa uma chamada para um método estático ou uma instância.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Expede o método específico de visita para esse tipo de nó. Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">O visitante com o qual visitar esse nó.</param>
      <returns vsli:raw="The result of visiting this node.">O resultado de visitar esse nó.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary vsli:raw="Returns the argument at index, throwing if index is out of bounds.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Retorna o argumento no índice, lançando se o índice estiver fora dos limites.  Você não deve usar esse membro.  Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho.</summary>
      <param name="index" vsli:raw="The index of the argument.">O índice do argumento.</param>
      <returns vsli:raw="Returns &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retorna <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="object" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Object&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> do resultado.</param>
      <param name="arguments" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Arguments&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> do resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Arguments">
      <summary vsli:raw="Gets a collection of expressions that represent arguments of the called method.">Obtém uma coleção de expressões que representam os argumentos do método chamado.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects which represent the arguments to the called method.">Um <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> dos <see cref="T:System.Linq.Expressions.Expression" /> objetos que representam os argumentos para o método chamado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Method">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; for the method to be called.">Obtém o <see cref="T:System.Reflection.MethodInfo" /> para o método a ser chamado.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the called method.">O <see cref="T:System.Reflection.MethodInfo" /> que representa o método chamado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retorna o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa essa expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Object">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the instance for instance method calls or null for static method calls.">Obtém o <see cref="T:System.Linq.Expressions.Expression" /> que representa a instância para chamadas de método de instância ou nulo para chamadas de método estático.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the receiving object of the method.">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o objeto de recebimento do método.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary vsli:raw="Returns the number of arguments to the expression tree node.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.">Retorna o número de argumentos para o nó de árvore de expressão.  Você não deve usar esse membro.  Ele só é público devido a refatoração de assembly e é usado internamente para otimizações de desempenho.</summary>
      <returns vsli:raw="The number of arguments to the expression tree node as  &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">O número de argumentos para o nó da árvore de expressão como  <see cref="T:System.Int32" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.MethodCallExpression.Type&quot; /&gt; that represents the static type of the expression.">O <see cref="P:System.Linq.Expressions.MethodCallExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.NewArrayExpression">
      <summary vsli:raw="Represents creating a new array and possibly initializing the elements of the new array.">Representa a criação de uma nova matriz e possível inicialização dos elementos da nova matriz.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Expede o método específico de visita para esse tipo de nó. Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">O visitante com o qual visitar esse nó.</param>
      <returns vsli:raw="The result of visiting this node.">O resultado de visitar esse nó.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="expressions" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Expressions&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> do resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Expressions">
      <summary vsli:raw="Gets the bounds of the array if the value of the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property is &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NewArrayBounds&quot; /&gt;, or the values to initialize the elements of the new array if the value of the &lt;see cref=&quot;P:System.Linq.Expressions.Expression.NodeType&quot; /&gt; property is &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.NewArrayInit&quot; /&gt;.">Obterá os limites da matriz se o valor da propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> for <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" />, ou os valores para inicializar os elementos da nova matriz se o valor da propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> for <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects which represent either the bounds of the array or the initialization values.">Um <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> dos <see cref="T:System.Linq.Expressions.Expression" /> objetos que representam os limites da matriz ou os valores de inicialização.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.NewArrayExpression.Type&quot; /&gt; that represents the static type of the expression.">O <see cref="P:System.Linq.Expressions.NewArrayExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.NewExpression">
      <summary vsli:raw="Represents a constructor call.">Representa uma chamada de construtor.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Expede o método específico de visita para esse tipo de nó. Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">O visitante com o qual visitar esse nó.</param>
      <returns vsli:raw="The result of visiting this node.">O resultado de visitar esse nó.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)">
      <summary vsli:raw="Returns the argument at index, throwing if index is out of bounds.">Retorna o argumento no índice, lançando se o índice estiver fora dos limites.</summary>
      <param name="index" vsli:raw="The index of the argument.">O índice do argumento.</param>
      <returns vsli:raw="The argument at index, throwing if index is out of bounds.">O argumento no índice, lançando se o índice estiver fora dos limites.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="arguments" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Arguments&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> do resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Arguments">
      <summary vsli:raw="Gets the arguments to the constructor.">Obtém os argumentos para o construtor.</summary>
      <returns vsli:raw="A collection of &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; objects that represent the arguments to the constructor.">Uma coleção de <see cref="T:System.Linq.Expressions.Expression" /> objetos que representam os argumentos para o construtor.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Constructor">
      <summary vsli:raw="Gets the called constructor.">Obtém o construtor chamado.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.ConstructorInfo&quot; /&gt; that represents the called constructor.">O <see cref="T:System.Reflection.ConstructorInfo" /> que representa o construtor chamado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Members">
      <summary vsli:raw="Gets the members that can retrieve the values of the fields that were initialized with constructor arguments.">Obtém os membros que podem recuperar os valores dos campos que foram inicializados com os argumentos de construtor.</summary>
      <returns vsli:raw="A collection of &lt;see cref=&quot;T:System.Reflection.MemberInfo&quot; /&gt; objects that represent the members that can retrieve the values of the fields that were initialized with constructor arguments.">Uma coleção de <see cref="T:System.Reflection.MemberInfo" /> objetos que representam os membros que podem recuperar os valores dos campos que foram inicializados com argumentos de construtor.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retorna o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa essa expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount">
      <summary vsli:raw="Gets the number of arguments to the expression tree node.">Obtém o número de argumentos para o nó de árvore de expressão.</summary>
      <returns vsli:raw="The number of arguments to the expression tree node.">O número de argumentos para o nó da árvore de expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.NewExpression.Type&quot; /&gt; that represents the static type of the expression.">O <see cref="P:System.Linq.Expressions.NewExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ParameterExpression">
      <summary vsli:raw="Represents a named parameter expression.">Representa uma expressão de parâmetro nomeada.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ParameterExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary vsli:raw="Dispatches to the specific visit method for this node type. For example, &lt;see cref=&quot;T:System.Linq.Expressions.MethodCallExpression&quot; /&gt; calls the &lt;see cref=&quot;M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)&quot; /&gt;.">Expede o método específico de visita para esse tipo de nó. Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <param name="visitor" vsli:raw="The visitor to visit this node with.">O visitante com o qual visitar esse nó.</param>
      <returns vsli:raw="The result of visiting this node.">O resultado de visitar esse nó.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.IsByRef">
      <summary vsli:raw="Indicates that this &lt;c&gt;ParameterExpression&lt;/c&gt; is to be treated as a &lt;see langword=&quot;ByRef&quot; /&gt; parameter.">Indica que esta <c>ParameterExpression</c> deve ser tratada como um parâmetro <see langword="ByRef" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if this &lt;c&gt;ParameterExpression&lt;/c&gt; is a &lt;see langword=&quot;ByRef&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Se essa <c>parameterid</c> for um <see langword="ByRef" /> parâmetro; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Name">
      <summary vsli:raw="Gets the name of the parameter or variable.">Obtém o nome do parâmetro ou variável.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; that contains the name of the parameter.">Uma <see cref="T:System.String" /> que contém o nome do parâmetro.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retorna o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa essa expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.ParameterExpression.Type&quot; /&gt; that represents the static type of the expression.">O <see cref="P:System.Linq.Expressions.ParameterExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.RuntimeVariablesExpression">
      <summary vsli:raw="An expression that provides runtime read/write permission for variables.">Uma expressão que fornece permissões de leitura/gravação em runtime para variáveis.</summary>
    </member>
    <member name="M:System.Linq.Expressions.RuntimeVariablesExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="variables" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.RuntimeVariablesExpression.Variables&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> do resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.NodeType">
      <summary vsli:raw="Returns the node type of this Expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Retorna o tipo de nó dessa Expressão. Nós de extensão devem retornar <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> ao substituírem esse método.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.RuntimeVariablesExpression.Type&quot; /&gt; that represents the static type of the expression.">O <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables">
      <summary vsli:raw="The variables or parameters to which to provide runtime access.">As variáveis ou parâmetros aos quais fornecer acesso de runtime.</summary>
      <returns vsli:raw="The read-only collection containing parameters that will be provided the runtime access.">A coleção somente leitura que contém parâmetros que receberão o acesso de tempo de execução.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchCase">
      <summary vsli:raw="Represents one case of a &lt;see cref=&quot;T:System.Linq.Expressions.SwitchExpression&quot; /&gt;.">Representa uma ocorrência de um <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.ToString">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.String&quot; /&gt; that represents the current &lt;see cref=&quot;T:System.Object&quot; /&gt;.">Retorna um valor <see cref="T:System.String" /> que representa o <see cref="T:System.Object" /> atual.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; that represents the current &lt;see cref=&quot;T:System.Object&quot; /&gt;.">Um <see cref="T:System.String" /> que representa o <see cref="T:System.Object" /> atual.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="testValues" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.SwitchCase.TestValues&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.SwitchCase.TestValues" /> do resultado.</param>
      <param name="body" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.SwitchCase.Body&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.SwitchCase.Body" /> do resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.Body">
      <summary vsli:raw="Gets the body of this case.">Obtém o corpo do caso.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; object that represents the body of the case block.">O <see cref="T:System.Linq.Expressions.Expression" /> objeto que representa o corpo do bloco de caso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.TestValues">
      <summary vsli:raw="Gets the values of this case. This case is selected for execution when the &lt;see cref=&quot;P:System.Linq.Expressions.SwitchExpression.SwitchValue&quot; /&gt; matches any of these values.">Obtém os valores do caso. Esse caso é selecionado para execução quando o <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> corresponde a qualquer um desses valores.</summary>
      <returns vsli:raw="The read-only collection of the values for this case block.">A coleção somente leitura dos valores para esse bloco de caso.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchExpression">
      <summary vsli:raw="Represents a control expression that handles multiple selections by passing control to &lt;see cref=&quot;T:System.Linq.Expressions.SwitchCase&quot; /&gt;.">Representa uma expressão de controle que trata de várias seleções passando o controle para <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.SwitchExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase},System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="switchValue" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.SwitchExpression.SwitchValue&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> do resultado.</param>
      <param name="cases" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.SwitchExpression.Cases&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.SwitchExpression.Cases" /> do resultado.</param>
      <param name="defaultBody" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.SwitchExpression.DefaultBody&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.SwitchExpression.DefaultBody" /> do resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Cases">
      <summary vsli:raw="Gets the collection of &lt;see cref=&quot;T:System.Linq.Expressions.SwitchCase&quot; /&gt; objects for the switch.">Obtém a coleção de objetos <see cref="T:System.Linq.Expressions.SwitchCase" /> para o comutador.</summary>
      <returns vsli:raw="The collection of &lt;see cref=&quot;T:System.Linq.Expressions.SwitchCase&quot; /&gt; objects.">A coleção de objetos <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Comparison">
      <summary vsli:raw="Gets the equality comparison method, if any.">Obtém o método de comparação de igualdade, se houver.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; object representing the equality comparison method.">O <see cref="T:System.Reflection.MethodInfo" /> objeto que representa o método de comparação de igualdade.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.DefaultBody">
      <summary vsli:raw="Gets the test for the switch.">Obtém o teste para o comutador.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; object representing the test for the switch.">O <see cref="T:System.Linq.Expressions.Expression" /> objeto que representa o teste para a opção.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.NodeType">
      <summary vsli:raw="Returns the node type of this Expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Retorna o tipo de nó dessa Expressão. Nós de extensão devem retornar <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> ao substituírem esse método.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.SwitchValue">
      <summary vsli:raw="Gets the test for the switch.">Obtém o teste para o comutador.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; object representing the test for the switch.">O <see cref="T:System.Linq.Expressions.Expression" /> objeto que representa o teste para a opção.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.SwitchExpression.Type&quot; /&gt; that represents the static type of the expression.">O <see cref="P:System.Linq.Expressions.SwitchExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SymbolDocumentInfo">
      <summary vsli:raw="Stores information necessary to emit debugging symbol information for a source file, in particular the file name and unique language identifier.">Armazena as informações necessárias para emitir informações de símbolo de depuração para um arquivo de origem, especificamente o nome do arquivo e o identificador de linguagem exclusivo.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType">
      <summary vsli:raw="Returns the document type's unique identifier, if any.">Retorna o identificador exclusivo do tipo do documento, se houver. Define GUID como padrão para um arquivo de texto.</summary>
      <returns vsli:raw="The document type's unique identifier. The default is the GUID for a text file.">O identificador exclusivo do tipo de documento.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.FileName">
      <summary vsli:raw="The source file name.">O nome do arquivo de origem.</summary>
      <returns vsli:raw="The string representing the source file name.">A cadeia de caracteres que representa o nome do arquivo de origem.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.Language">
      <summary vsli:raw="Returns the language's unique identifier, if any.">Retorna o identificador exclusivo da linguagem, se houver.</summary>
      <returns vsli:raw="The language's unique identifier.">O identificador exclusivo do idioma</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor">
      <summary vsli:raw="Returns the language vendor's unique identifier, if any.">Retorna o identificador exclusivo do fornecedor da linguagem, se houver.</summary>
      <returns vsli:raw="The language vendor's unique identifier.">O identificador exclusivo do fornecedor do idioma.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TryExpression">
      <summary vsli:raw="Represents a try/catch/finally/fault block.">Representa um bloco try/catch/finally/fault.</summary>
    </member>
    <member name="M:System.Linq.Expressions.TryExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="body" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.TryExpression.Body&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.TryExpression.Body" /> do resultado.</param>
      <param name="handlers" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.TryExpression.Handlers&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.TryExpression.Handlers" /> do resultado.</param>
      <param name="finally" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.TryExpression.Finally&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.TryExpression.Finally" /> do resultado.</param>
      <param name="fault" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.TryExpression.Fault&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.TryExpression.Fault" /> do resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Body">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the body of the try block.">Obtém o <see cref="T:System.Linq.Expressions.Expression" /> que representa o corpo do bloco try.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the body of the try block.">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o corpo do bloco try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Fault">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the fault block.">Obtém o <see cref="T:System.Linq.Expressions.Expression" /> que representa o bloco de falha.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the fault block.">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o bloco de falha.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Finally">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the finally block.">Obtém o <see cref="T:System.Linq.Expressions.Expression" /> que representa o bloco finally.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; representing the finally block.">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o bloco finally.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Handlers">
      <summary vsli:raw="Gets the collection of &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; expressions associated with the try block.">Obtém a coleção de expressões <see cref="T:System.Linq.Expressions.CatchBlock" /> associadas ao bloco try.</summary>
      <returns vsli:raw="The collection of &lt;see cref=&quot;T:System.Linq.Expressions.CatchBlock&quot; /&gt; expressions associated with the try block.">A coleção de <see cref="T:System.Linq.Expressions.CatchBlock" /> expressões associadas ao bloco try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retorna o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa essa expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.TryExpression.Type&quot; /&gt; that represents the static type of the expression.">O <see cref="P:System.Linq.Expressions.TryExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TypeBinaryExpression">
      <summary vsli:raw="Represents an operation between an expression and a type.">Representa uma operação entre uma expressão e um tipo.</summary>
    </member>
    <member name="M:System.Linq.Expressions.TypeBinaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="expression" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.Expression&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> do resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Expression">
      <summary vsli:raw="Gets the expression operand of a type test operation.">Obtém o operando de expressão de uma operação de teste de tipo.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the expression operand of a type test operation.">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando de expressão de uma operação de teste de tipo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.NodeType">
      <summary vsli:raw="Returns the node type of this Expression. Extension nodes should return &lt;see cref=&quot;F:System.Linq.Expressions.ExpressionType.Extension&quot; /&gt; when overriding this method.">Retorna o tipo de nó dessa Expressão. Nós de extensão devem retornar <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> ao substituírem esse método.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; of the expression.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.Expression&quot; /&gt; represents.">Obtém o tipo estático da expressão que esse <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.TypeBinaryExpression.Type&quot; /&gt; that represents the static type of the expression.">O <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand">
      <summary vsli:raw="Gets the type operand of a type test operation.">Obtém o operando de tipo de uma operação de teste de tipo.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents the type operand of a type test operation.">Um <see cref="T:System.Type" /> que representa o operando de tipo de uma operação de teste de tipo.</returns>
    </member>
    <member name="T:System.Linq.Expressions.UnaryExpression">
      <summary vsli:raw="Represents an expression that has a unary operator.">Representa uma expressão com um operador unário.</summary>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Reduce">
      <summary vsli:raw="Reduces the expression node to a simpler expression.">Reduz o nó de expressão para uma expressão mais simples.</summary>
      <returns vsli:raw="The reduced expression.">A expressão reduzida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.">Cria uma nova expressão que é parecida com esta, mas usando os filhos fornecidos. Se todos os filhos forem os mesmos, ela retornará esta expressão.</summary>
      <param name="operand" vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Operand&quot; /&gt; property of the result.">A propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> do resultado.</param>
      <returns vsli:raw="This expression if no children are changed or an expression with the updated children.">Essa expressão se nenhum filho foi alterado ou uma expressão com os filhos atualizados.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.CanReduce">
      <summary vsli:raw="Gets a value that indicates whether the expression tree node can be reduced.">Obtém um valor que indica se o nó da árvore de expressão pode ser reduzido.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if a node can be reduced; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se um nó puder ser reduzido; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLifted">
      <summary vsli:raw="Gets a value that indicates whether the expression tree node represents a lifted call to an operator.">Obtém um valor que indica se o nó da árvore de expressão representa uma chamada cancelada a um operador.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the node represents a lifted call; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Se o nó representa uma chamada levantada; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLiftedToNull">
      <summary vsli:raw="Gets a value that indicates whether the expression tree node represents a lifted call to an operator whose return type is lifted to a nullable type.">Obtém um valor que indica se o nó da árvore de expressão representa uma chamada cancelada a um operador cujo tipo de retorno é elevado para um tipo que permite valor nulo.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operator's return type is lifted to a nullable type; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Se o tipo de retorno do operador for elevado para um tipo anulável; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Method">
      <summary vsli:raw="Gets the implementing method for the unary operation.">Obtém o método de implementação para a operação unária.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Reflection.MethodInfo&quot; /&gt; that represents the implementing method.">O <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.NodeType">
      <summary vsli:raw="Returns the node type of this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt;.">Retorna o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.ExpressionType&quot; /&gt; that represents this expression.">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa essa expressão.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Operand">
      <summary vsli:raw="Gets the operand of the unary operation.">Obtém o operando da operação unária.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that represents the operand of the unary operation.">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando da operação unária.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Type">
      <summary vsli:raw="Gets the static type of the expression that this &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; represents.">Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;P:System.Linq.Expressions.UnaryExpression.Type&quot; /&gt; that represents the static type of the expression.">O <see cref="P:System.Linq.Expressions.UnaryExpression.Type" /> que representa o tipo estático da expressão.</returns>
    </member>
    <member name="T:System.Linq.IOrderedQueryable">
      <summary vsli:raw="Represents the result of a sorting operation.">Representa o resultado de uma operação de classificação.</summary>
    </member>
    <member name="T:System.Linq.IOrderedQueryable`1">
      <summary vsli:raw="Represents the result of a sorting operation.">Representa o resultado de uma operação de classificação.</summary>
      <typeparam name="T" vsli:raw="The type of the content of the data source.">O tipo de conteúdo da fonte de dados.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryable">
      <summary vsli:raw="Provides functionality to evaluate queries against a specific data source wherein the type of the data is not specified.">Fornece a funcionalidade para avaliar as consultas em uma fonte de dados específica no qual o tipo de dado não foi especificado.</summary>
    </member>
    <member name="P:System.Linq.IQueryable.ElementType">
      <summary vsli:raw="Gets the type of the element(s) that are returned when the expression tree associated with this instance of &lt;see cref=&quot;T:System.Linq.IQueryable&quot; /&gt; is executed.">Obtém o tipo de elemento que é retornado quando a árvore de expressão associada a esta instância do <see cref="T:System.Linq.IQueryable" /> é executada.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Type&quot; /&gt; that represents the type of the element(s) that are returned when the expression tree associated with this object is executed.">Um <see cref="T:System.Type" /> que representa o tipo de elemento que é retornado quando a árvore de expressão associada a este objeto é executada.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Expression">
      <summary vsli:raw="Gets the expression tree that is associated with the instance of &lt;see cref=&quot;T:System.Linq.IQueryable&quot; /&gt;.">Obtém a árvore de expressão que é associada à instância de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; that is associated with this instance of &lt;see cref=&quot;T:System.Linq.IQueryable&quot; /&gt;.">A <see cref="T:System.Linq.Expressions.Expression" /> associada a essa instância de <see cref="T:System.Linq.IQueryable" />.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Provider">
      <summary vsli:raw="Gets the query provider that is associated with this data source.">Obtém o provedor de consulta associado esta fonte de dados.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.IQueryProvider&quot; /&gt; that is associated with this data source.">A <see cref="T:System.Linq.IQueryProvider" /> associado a essa fonte de dados.</returns>
    </member>
    <member name="T:System.Linq.IQueryable`1">
      <summary vsli:raw="Provides functionality to evaluate queries against a specific data source wherein the type of the data is known.">Fornece a funcionalidade para avaliar as consultas em uma fonte de dados específica no qual o tipo de dado é conhecido.</summary>
      <typeparam name="T" vsli:raw="The type of the data in the data source.">O tipo de dados na fonte de dados.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryProvider">
      <summary vsli:raw="Defines methods to create and execute queries that are described by an &lt;see cref=&quot;T:System.Linq.IQueryable&quot; /&gt; object.">Define métodos para criar e executar consultas que são descritas por um objeto <see cref="T:System.Linq.IQueryable" />.</summary>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Constructs an &lt;see cref=&quot;T:System.Linq.IQueryable&quot; /&gt; object that can evaluate the query represented by a specified expression tree.">Constrói um objeto <see cref="T:System.Linq.IQueryable" /> que pode avaliar a consulta representada por uma árvore de expressão especificada.</summary>
      <param name="expression" vsli:raw="An expression tree that represents a LINQ query.">Uma árvore de expressão que representa uma consulta LINQ.</param>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.IQueryable&quot; /&gt; that can evaluate the query represented by the specified expression tree.">Um objeto <see cref="T:System.Linq.IQueryable" /> que pode avaliar a consulta representada pela árvore de expressão especificada.</returns>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery``1(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Constructs an &lt;see cref=&quot;T:System.Linq.IQueryable`1&quot; /&gt; object that can evaluate the query represented by a specified expression tree.">Constrói um objeto <see cref="T:System.Linq.IQueryable`1" /> que pode avaliar a consulta representada por uma árvore de expressão especificada.</summary>
      <param name="expression" vsli:raw="An expression tree that represents a LINQ query.">Uma árvore de expressão que representa uma consulta LINQ.</param>
      <typeparam name="TElement" vsli:raw="The type of the elements of the &lt;see cref=&quot;T:System.Linq.IQueryable`1&quot; /&gt; that is returned.">O tipo dos elementos do <see cref="T:System.Linq.IQueryable`1" /> que é retornado.</typeparam>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Linq.IQueryable`1&quot; /&gt; that can evaluate the query represented by the specified expression tree.">Um objeto <see cref="T:System.Linq.IQueryable`1" /> que pode avaliar a consulta representada pela árvore de expressão especificada.</returns>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Executes the query represented by a specified expression tree.">Executa a consulta representada por uma árvore de expressão especificada.</summary>
      <param name="expression" vsli:raw="An expression tree that represents a LINQ query.">Uma árvore de expressão que representa uma consulta LINQ.</param>
      <returns vsli:raw="The value that results from executing the specified query.">O valor resultante da execução da consulta especificada.</returns>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute``1(System.Linq.Expressions.Expression)">
      <summary vsli:raw="Executes the strongly-typed query represented by a specified expression tree.">Executa a consulta fortemente tipada representada por uma árvore de expressão especificada.</summary>
      <param name="expression" vsli:raw="An expression tree that represents a LINQ query.">Uma árvore de expressão que representa uma consulta LINQ.</param>
      <typeparam name="TResult" vsli:raw="The type of the value that results from executing the query.">O tipo do valor resultante da execução da consulta.</typeparam>
      <returns vsli:raw="The value that results from executing the specified query.">O valor resultante da execução da consulta especificada.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSite">
      <summary vsli:raw="A dynamic call site base class. This type is used as a parameter type to the dynamic site targets.">Uma classe base de sites dinâmicos de chamada. Esse tipo é usado como um tipo de parâmetro para os destinos de site dinâmicos.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSite.Create(System.Type,System.Runtime.CompilerServices.CallSiteBinder)">
      <summary vsli:raw="Creates a call site with the given delegate type and binder.">Cria um site de chamada com o associador e o tipo de delegado fornecidos.</summary>
      <param name="delegateType" vsli:raw="The call site delegate type.">O tipo de delegado do site de chamada.</param>
      <param name="binder" vsli:raw="The call site binder.">O associador do site de chamada.</param>
      <returns vsli:raw="The new call site.">O novo site de chamada.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSite.Binder">
      <summary vsli:raw="Class responsible for binding dynamic operations on the dynamic site.">Classe responsável pela associação das operações dinâmicas no site dinâmico.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; object responsible for binding dynamic operations.">O <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> objeto responsável por associar operações dinâmicas.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSite`1">
      <summary vsli:raw="Dynamic site type.">Tipo de site dinâmico.</summary>
      <typeparam name="T" vsli:raw="The delegate type.">O tipo de delegado.</typeparam>
    </member>
    <member name="F:System.Runtime.CompilerServices.CallSite`1.Target">
      <summary vsli:raw="The Level 0 cache - a delegate specialized based on the site history.">O cache de Nível 0 – um delegado especializado com base no histórico do site.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSite`1.Create(System.Runtime.CompilerServices.CallSiteBinder)">
      <summary vsli:raw="Creates an instance of the dynamic call site, initialized with the binder responsible for the runtime binding of the dynamic operations at this call site.">Cria uma instância do site de chamada dinâmico, inicializada com o associador responsável pela associação em runtime das operações dinâmicas neste site de chamada.</summary>
      <param name="binder" vsli:raw="The binder responsible for the runtime binding of the dynamic operations at this call site.">O associador responsável pela associação em runtime das operações dinâmicas neste site de chamada.</param>
      <returns vsli:raw="The new instance of dynamic call site.">A nova instância do site de chamada dinâmico.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSite`1.Update">
      <summary vsli:raw="The update delegate. Called when the dynamic site experiences cache miss.">O delegado de atualização. Chamado quando o site dinâmico apresenta perda no cache.</summary>
      <returns vsli:raw="The update delegate.">O delegado de atualização.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSiteBinder">
      <summary vsli:raw="Class responsible for runtime binding of the dynamic operations on the dynamic call site.">Classe responsável pela associação em runtime das operações dinâmicas no site de chamada dinâmico.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Runtime.CompilerServices.CallSiteBinder&quot; /&gt; class.">Inicializa uma nova instância da classe <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.Bind(System.Object[],System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.LabelTarget)">
      <summary vsli:raw="Performs the runtime binding of the dynamic operation on a set of arguments.">Executa a associação em runtime da operação dinâmica em um conjunto de argumentos.</summary>
      <param name="args" vsli:raw="An array of arguments to the dynamic operation.">Uma matriz de argumentos para a operação dinâmica.</param>
      <param name="parameters" vsli:raw="The array of &lt;see cref=&quot;T:System.Linq.Expressions.ParameterExpression&quot; /&gt; instances that represent the parameters of the call site in the binding process.">A matriz de instâncias de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representam os parâmetros do site de chamada no processo de associação.</param>
      <param name="returnLabel" vsli:raw="A LabelTarget used to return the result of the dynamic binding.">Um LabelTarget usado para retornar o resultado da associação dinâmica.</param>
      <returns vsli:raw="An Expression that performs tests on the dynamic operation arguments, and performs the dynamic operation if the tests are valid. If the tests fail on subsequent occurrences of the dynamic operation, Bind will be called again to produce a new &lt;see cref=&quot;T:System.Linq.Expressions.Expression&quot; /&gt; for the new argument types.">Uma expressão que executa testes nos argumentos de operação dinâmica e executa a operação dinâmica se os testes forem válidos. Se os testes falham em ocorrências posteriores da operação dinâmica, Bind será chamado novamente para gerar um novo <see cref="T:System.Linq.Expressions.Expression" /> para os novos tipos de argumento.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.BindDelegate``1(System.Runtime.CompilerServices.CallSite{``0},System.Object[])">
      <summary vsli:raw="Provides low-level runtime binding support. Classes can override this and provide a direct delegate for the implementation of rule. This can enable saving rules to disk, having specialized rules available at runtime, or providing a different caching policy.">Dá suporte à associação em runtime de baixo nível. As classes podem substituir isso e fornecer um delegado direto para a implementação da regra. Isso pode habilitar o salvamento de regras em disco, a presença de regras especializadas disponíveis em runtime ou o fornecimento de uma política diferente de armazenamento em cache.</summary>
      <param name="site" vsli:raw="The CallSite the bind is being performed for.">O CallSite para o qual a associação está sendo executada.</param>
      <param name="args" vsli:raw="The arguments for the binder.">Os argumentos para o associador.</param>
      <typeparam name="T" vsli:raw="The target type of the CallSite.">O tipo de destino do chamada.</typeparam>
      <returns vsli:raw="A new delegate which replaces the CallSite Target.">Um novo delegado que substitui o destino de CallSite.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.CacheTarget``1(``0)">
      <summary vsli:raw="Adds a target to the cache of known targets. The cached targets will be scanned before calling BindDelegate to produce the new rule.">Adiciona um destino ao cache de destinos conhecidos. Os destinos armazenados em cache serão verificados antes de chamar BindDelegate para produzir a nova regra.</summary>
      <param name="target" vsli:raw="The target delegate to be added to the cache.">O delegado de destino a ser adicionado ao cache.</param>
      <typeparam name="T" vsli:raw="The type of target being added.">O tipo de destino que está sendo adicionado.</typeparam>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSiteBinder.UpdateLabel">
      <summary vsli:raw="Gets a label that can be used to cause the binding to be updated. It indicates that the expression's binding is no longer valid. This is typically used when the &quot;version&quot; of a dynamic object has changed.">Obtém um rótulo que pode ser usado para fazer com que a associação seja atualizada. Indica que a associação da expressão deixou de ser válida. Normalmente, é usado quando a "versão" de um objeto dinâmico foi alterada.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Linq.Expressions.LabelTarget&quot; /&gt; object representing a label that can be used to trigger the binding update.">O <see cref="T:System.Linq.Expressions.LabelTarget" /> objeto que representa um rótulo que pode ser usado para disparar a atualização de associação.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSiteHelpers">
      <summary vsli:raw="Class that contains helper methods for DLR CallSites.">Classe que contém métodos auxiliares para CallSites do DLR.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteHelpers.IsInternalFrame(System.Reflection.MethodBase)">
      <summary vsli:raw="Checks if a &lt;see cref=&quot;T:System.Reflection.MethodBase&quot; /&gt; is internally used by DLR and should not be displayed on the language code's stack.">Verifica se um <see cref="T:System.Reflection.MethodBase" /> é usado internamente pelo DLR e não deve ser exibido na pilha do código de linguagem.</summary>
      <param name="mb" vsli:raw="The input &lt;see cref=&quot;T:System.Reflection.MethodBase&quot; /&gt;.">A entrada <see cref="T:System.Reflection.MethodBase" /></param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the input &lt;see cref=&quot;T:System.Reflection.MethodBase&quot; /&gt; is internally used by DLR and should not be displayed on the language code's stack. Otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se um <see cref="T:System.Reflection.MethodBase" /> for usado internamente pelo DLR e não precisar ser exibido na pilha do código de linguagem. Caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.DebugInfoGenerator">
      <summary vsli:raw="Generates debug information for lambda expressions in an expression tree.">Gera informações de depuração para expressões lambda em uma árvore de expressão.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DebugInfoGenerator.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Runtime.CompilerServices.DebugInfoGenerator&quot; /&gt; class.">Inicializa uma nova instância da classe <see cref="T:System.Runtime.CompilerServices.DebugInfoGenerator" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DebugInfoGenerator.CreatePdbGenerator">
      <summary vsli:raw="Creates a program database (PDB) symbol generator.">Cria um gerador de símbolo PDB (banco de dados de programa).</summary>
      <returns vsli:raw="A PDB symbol generator.">Um gerador de símbolo PDB.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.DebugInfoGenerator.MarkSequencePoint(System.Linq.Expressions.LambdaExpression,System.Int32,System.Linq.Expressions.DebugInfoExpression)">
      <summary vsli:raw="Marks a sequence point in Microsoft intermediate language (MSIL) code.">Marca um ponto de sequência no código de MSIL (Microsoft Intermediate Language).</summary>
      <param name="method" vsli:raw="The lambda expression that is generated.">A expressão lambda que é gerada.</param>
      <param name="ilOffset" vsli:raw="The offset within MSIL code at which to mark the sequence point.">O deslocamento dentro do código MSIL no qual marcar o ponto de sequência.</param>
      <param name="sequencePoint" vsli:raw="Debug information that corresponds to the sequence point.">Informações de depuração que correspondem ao ponto de sequência.</param>
    </member>
    <member name="T:System.Runtime.CompilerServices.DynamicAttribute">
      <summary vsli:raw="Indicates that the use of &lt;see cref=&quot;T:System.Object&quot; /&gt; on a member is meant to be treated as a dynamically dispatched type.">Indica que o uso do <see cref="T:System.Object" /> em um membro deve ser tratado como um tipo expedido dinamicamente.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DynamicAttribute.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Runtime.CompilerServices.DynamicAttribute&quot; /&gt; class.">Inicializa uma nova instância da classe <see cref="T:System.Runtime.CompilerServices.DynamicAttribute" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DynamicAttribute.#ctor(System.Boolean[])">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Runtime.CompilerServices.DynamicAttribute&quot; /&gt; class.">Inicializa uma nova instância da classe <see cref="T:System.Runtime.CompilerServices.DynamicAttribute" />.</summary>
      <param name="transformFlags" vsli:raw="Specifies, in a prefix traversal of a type's construction, which &lt;see cref=&quot;T:System.Object&quot; /&gt; occurrences are meant to be treated as a dynamically dispatched type.">Especifica, em uma passagem de prefixo de construção de um tipo, que ocorrências <see cref="T:System.Object" /> devem ser tratadas como um tipo expedido dinamicamente.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.DynamicAttribute.TransformFlags">
      <summary vsli:raw="Specifies, in a prefix traversal of a type's construction, which &lt;see cref=&quot;T:System.Object&quot; /&gt; occurrences are meant to be treated as a dynamically dispatched type.">Especifica, em uma passagem de prefixo de construção de um tipo, que ocorrências <see cref="T:System.Object" /> devem ser tratadas como um tipo expedido dinamicamente.</summary>
      <returns vsli:raw="The list of &lt;see cref=&quot;T:System.Object&quot; /&gt; occurrences that are meant to be treated as a dynamically dispatched type.">A lista de <see cref="T:System.Object" /> ocorrências que devem ser tratadas como um tipo expedido dinamicamente.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.IRuntimeVariables">
      <summary vsli:raw="Represents the values of run-time variables.">Representa os valores das variáveis de tempo de execução.</summary>
    </member>
    <member name="P:System.Runtime.CompilerServices.IRuntimeVariables.Count">
      <summary vsli:raw="Gets a count of the run-time variables.">Obtém uma contagem das variáveis de tempo de execução.</summary>
      <returns vsli:raw="The number of run-time variables.">O número de variáveis de tempo de execução.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.IRuntimeVariables.Item(System.Int32)">
      <summary vsli:raw="Gets the value of the run-time variable at the specified index.">Obtém o valor da variável de tempo de execução no índice especificado.</summary>
      <param name="index" vsli:raw="The zero-based index of the run-time variable whose value is to be returned.">O índice baseado em zero da variável de tempo de execução cujo valor será retornado.</param>
      <returns vsli:raw="The value of the run-time variable.">O valor da variável de tempo de execução.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1">
      <summary vsli:raw="The builder for read only collection.">O construtor para coleção somente leitura.</summary>
      <typeparam name="T" vsli:raw="The type of the collection element.">O tipo do elemento de coleção.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.#ctor">
      <summary vsli:raw="Constructs a &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Constrói um <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary vsli:raw="Constructs a &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;, copying the contents of the given collection.">Constrói um <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />, copiando o conteúdo da coleção fornecida.</summary>
      <param name="collection" vsli:raw="Collection to copy elements from.">Coleção da qual copiar elementos.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.#ctor(System.Int32)">
      <summary vsli:raw="Constructs a &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt; with a given initial capacity. The contents are empty but builder will have reserved room for the given number of elements before any reallocations are required.">Constrói um <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> com uma capacidade inicial fornecida. O conteúdo está vazio, mas o construtor terá reservado espaço para o número fornecido de elementos antes que as realocações sejam necessárias.</summary>
      <param name="capacity" vsli:raw="Initial capacity.">Capacidade inicial.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Add(`0)">
      <summary vsli:raw="Adds an item to the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Adiciona um item ao <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <param name="item" vsli:raw="The object to add to the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">O objeto a ser adicionado ao <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Clear">
      <summary vsli:raw="Removes all items from the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Remove todos os itens do <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Contains(`0)">
      <summary vsli:raw="Determines whether the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt; contains a specific value.">Determinará se o <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> contiver um valor específico.</summary>
      <param name="item" vsli:raw="the object to locate in the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">o objeto a ser localizado no <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if item is found in the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o item for encontrado no <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.CopyTo(`0[],System.Int32)">
      <summary vsli:raw="Copies the elements of the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt; to an &lt;see cref=&quot;T:System.Array&quot; /&gt;, starting at particular &lt;see cref=&quot;T:System.Array&quot; /&gt; index.">Copia os elementos do <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> para um <see cref="T:System.Array" />, começando em no índice <see cref="T:System.Array" /> determinado.</summary>
      <param name="array" vsli:raw="The one-dimensional &lt;see cref=&quot;T:System.Array&quot; /&gt; that is the destination of the elements copied from &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">O <see cref="T:System.Array" /> unidimensional que é o destino dos elementos copiados de <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
      <param name="arrayIndex" vsli:raw="The zero-based index in array at which copying begins.">O índice de base zero na matriz no qual a cópia começa.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Collections.Generic.IEnumerator`1&quot; /&gt; that can be used to iterate through the collection.">Um <see cref="T:System.Collections.Generic.IEnumerator`1" /> que pode ser usado para ser iterado por meio da coleção.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.IndexOf(`0)">
      <summary vsli:raw="Returns the index of the first occurrence of a given value in the builder.">Retorna o índice da primeira ocorrência de um valor fornecido no construtor.</summary>
      <param name="item" vsli:raw="An item to search for.">Um item a ser pesquisado.</param>
      <returns vsli:raw="The index of the first occurrence of an item.">O índice da primeira ocorrência de um item.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Insert(System.Int32,`0)">
      <summary vsli:raw="Inserts an item to the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt; at the specified index.">Insere um item na <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> no índice especificado.</summary>
      <param name="index" vsli:raw="The zero-based index at which item should be inserted.">O índice baseado em zero no qual o item deve ser inserido.</param>
      <param name="item" vsli:raw="The object to insert into the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">O objeto a ser inserido no <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Remove(`0)">
      <summary vsli:raw="Removes the first occurrence of a specific object from the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Remove a primeira ocorrência de um objeto específico do <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <param name="item" vsli:raw="The object to remove from the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">O objeto a remover do <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if item was successfully removed from the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;; otherwise, false. This method also returns false if item is not found in the original &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">
        <see langword="true" /> se o item foi removido com êxito do <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />; caso contrário, false. Esse método também retornará false se o item não for encontrado no <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> original.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.RemoveAt(System.Int32)">
      <summary vsli:raw="Removes the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt; item at the specified index.">Remove o item <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> no índice especificado.</summary>
      <param name="index" vsli:raw="The zero-based index of the item to remove.">O índice com base em zero do item a ser removido.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Reverse">
      <summary vsli:raw="Reverses the order of the elements in the entire &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Inverte a ordem dos elementos em todo o <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Reverse(System.Int32,System.Int32)">
      <summary vsli:raw="Reverses the order of the elements in the specified range.">Inverte a ordem dos elementos no intervalo especificado.</summary>
      <param name="index" vsli:raw="The zero-based starting index of the range to reverse.">O índice inicial baseado em zero do intervalo a ser revertido.</param>
      <param name="count" vsli:raw="The number of elements in the range to reverse.">O número de elementos no intervalo a serem revertidos.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <summary vsli:raw="Copies the elements of the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot; /&gt; to an array, starting at the specified array index.">Copia os elementos do <see cref="T:System.Collections.Generic.ICollection`1" /> para uma matriz, começando no índice da matriz especificada.</summary>
      <param name="array" vsli:raw="The one-dimensional array that is the destination of the elements copied from &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot; /&gt;. The array must have zero-based indexing.">A matriz unidimensional que é o destino dos elementos copiados de <see cref="T:System.Collections.Generic.ICollection`1" />. A matriz deve ter indexação com base em zero.</param>
      <param name="index" vsli:raw="The zero-based index in &lt;paramref name=&quot;array&quot; /&gt; at which copying begins.">O índice com base em zero em <paramref name="array" /> no qual a cópia começa.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; that can be used to iterate through the collection.">Um <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Add(System.Object)">
      <summary vsli:raw="Adds an item to the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;.">Adiciona um item ao <see cref="T:System.Collections.IList" />.</summary>
      <param name="value" vsli:raw="The &lt;see cref=&quot;T:System.Object&quot; /&gt; to add to the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;.">O <see cref="T:System.Object" /> para adicionar ao <see cref="T:System.Collections.IList" />.</param>
      <returns vsli:raw="The position into which the new element was inserted.">A posição na qual o novo elemento foi inserido.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Contains(System.Object)">
      <summary vsli:raw="Determines whether the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt; contains a specific value.">Determinará se o <see cref="T:System.Collections.IList" /> contiver um valor específico.</summary>
      <param name="value" vsli:raw="The &lt;see cref=&quot;T:System.Object&quot; /&gt; to locate in the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;.">O <see cref="T:System.Object" /> a ser localizado no <see cref="T:System.Collections.IList" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;item&quot; /&gt; is found in the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="item" /> for encontrado no <see cref="T:System.Collections.IList" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#IndexOf(System.Object)">
      <summary vsli:raw="Determines the index of a specific item in the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;.">Determina o índice de um item específico em <see cref="T:System.Collections.IList" />.</summary>
      <param name="value" vsli:raw="The object to locate in the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;.">O objeto a ser localizado no <see cref="T:System.Collections.IList" />.</param>
      <returns vsli:raw="The index of &lt;paramref name=&quot;item&quot; /&gt; if found in the list; otherwise, -1.">O índice de <paramref name="item" /> se encontrado na lista; caso contrário, -1.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Insert(System.Int32,System.Object)">
      <summary vsli:raw="Inserts an item to the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt; at the specified index.">Insere um item na <see cref="T:System.Collections.IList" /> no índice especificado.</summary>
      <param name="index" vsli:raw="The zero-based index at which &lt;paramref name=&quot;item&quot; /&gt; should be inserted.">O índice de base zero no qual o <paramref name="item" /> deve ser inserido.</param>
      <param name="value" vsli:raw="The object to insert into the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;.">O objeto a ser inserido no <see cref="T:System.Collections.IList" />.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Remove(System.Object)">
      <summary vsli:raw="Removes the first occurrence of a specific object from the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;.">Remove a primeira ocorrência de um objeto específico do <see cref="T:System.Collections.IList" />.</summary>
      <param name="value" vsli:raw="The object to remove from the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt;.">O objeto a remover do <see cref="T:System.Collections.IList" />.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.ToArray">
      <summary vsli:raw="Copies the elements of the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt; to a new array.">Copia os elementos do <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> em uma nova matriz.</summary>
      <returns vsli:raw="An array containing copies of the elements of the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Uma matriz que contém cópias dos elementos do <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.ToReadOnlyCollection">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; containing all of the elements of the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;, avoiding copying the elements to the new array if possible. Resets the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt; after the &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt; has been created.">Cria um <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> que contém todos os elementos do <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />, evitando copiar os elementos para a nova matriz, se possível. Redefinirá o <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> depois que o <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> tiver sido criado.</summary>
      <returns vsli:raw="A new instance of &lt;see cref=&quot;T:System.Collections.ObjectModel.ReadOnlyCollection`1&quot; /&gt;.">Uma nova instância de <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Capacity">
      <summary vsli:raw="Gets or sets the capacity of this &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Obtém ou define a capacidade deste <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <returns vsli:raw="The capacity of this &lt;c&gt;ReadOnlyCollectionBuilder.&lt;/c&gt;">A capacidade deste <c>ReadOnlyCollectionBuilder.</c></returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Count">
      <summary vsli:raw="Gets the number of elements in the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">Obtém o número de elementos no <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
      <returns vsli:raw="The number of elements in the &lt;see cref=&quot;T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1&quot; /&gt;.">O número de elementos em <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.Item(System.Int32)">
      <summary vsli:raw="Gets or sets the element at the specified index.">Obtém ou define o elemento no índice especificado.</summary>
      <param name="index" vsli:raw="The zero-based index of the element to get or set.">O índice com base em zero do elemento a ser obtido ou definido.</param>
      <returns vsli:raw="The element at the specified index.">O elemento no índice especificado.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
      <summary vsli:raw="Gets a value indicating whether the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot; /&gt; is read-only.">Obtém um valor que indica se o <see cref="T:System.Collections.Generic.ICollection`1" /> é somente leitura.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot; /&gt; is read-only; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o <see cref="T:System.Collections.Generic.ICollection`1" /> for somente leitura; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#ICollection#IsSynchronized">
      <summary vsli:raw="Gets a value indicating whether access to the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; is synchronized (thread safe).">Obtém um valor que indica se o acesso à <see cref="T:System.Collections.ICollection" /> é sincronizado (thread-safe).</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if access to the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt; is synchronized (thread safe); otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> caso o acesso ao <see cref="T:System.Collections.ICollection" /> seja sincronizado (thread-safe); do contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#ICollection#SyncRoot">
      <summary vsli:raw="Gets an object that can be used to synchronize access to the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt;.">Obtém um objeto que pode ser usado para sincronizar o acesso ao <see cref="T:System.Collections.ICollection" />.</summary>
      <returns vsli:raw="An object that can be used to synchronize access to the &lt;see cref=&quot;T:System.Collections.ICollection&quot; /&gt;.">Um objeto que pode ser usado para sincronizar o acesso à <see cref="T:System.Collections.ICollection" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#IsFixedSize">
      <summary vsli:raw="Gets a value indicating whether the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt; has a fixed size.">Obtém um valor que indica se o <see cref="T:System.Collections.IList" /> tem um tamanho fixo.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt; has a fixed size; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o <see cref="T:System.Collections.IList" /> tiver um valor fixo; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#IsReadOnly">
      <summary vsli:raw="Gets a value indicating whether the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt; is read-only.">Obtém um valor que indica se o <see cref="T:System.Collections.IList" /> é somente leitura.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Collections.IList&quot; /&gt; is read-only; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o <see cref="T:System.Collections.IList" /> for somente leitura; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1.System#Collections#IList#Item(System.Int32)">
      <summary vsli:raw="Gets or sets the element at the specified index.">Obtém ou define o elemento no índice especificado.</summary>
      <param name="index" vsli:raw="The zero-based index of the element to get or set.">O índice com base em zero do elemento a ser obtido ou definido.</param>
      <returns vsli:raw="The element at the specified index.">O elemento no índice especificado.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.RuleCache`1">
      <summary vsli:raw="Represents a cache of runtime binding rules.">Representa um cache de regras de associação em runtime.</summary>
      <typeparam name="T" vsli:raw="The delegate type.">O tipo de delegado.</typeparam>
    </member>
  </members>
</doc>