<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Memory</name>
  </assembly>
  <members>
    <member name="T:System.Buffers.ArrayBufferWriter`1">
      <summary>Rappresenta un sink di output supportato da matrici e basato su heap in cui <typeparam name="T" /> è possibile scrivere dati.</summary>
      <typeparam name="T">Tipo degli elementi in questa <see cref="T:System.Buffers.ArrayBufferWriter`1" /> istanza.</typeparam>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.#ctor">
      <summary>Crea un'istanza di <see cref="T:System.Buffers.ArrayBufferWriter`1" /> in cui è possibile scrivere dati, con la capacità iniziale predefinita.</summary>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.#ctor(System.Int32)">
      <summary>Crea un'istanza di <see cref="T:System.Buffers.ArrayBufferWriter`1" /> in cui è possibile scrivere dati, con una capacità iniziale specificata.</summary>
      <param name="initialCapacity">La capacità minima con cui inizializzare il buffer sottostante.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="initialCapacity" /> è minore o uguale a 0.</exception>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.Advance(System.Int32)">
      <summary>Comunica a <see cref="T:System.Buffers.IBufferWriter`1" /> che sono stati scritti <paramref name="count" /> elementi nell'output <see cref="T:System.Span`1" />/<see cref="T:System.Memory`1" /></summary>
      <param name="count">Il numero di elementi scritti.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="count" /> è negativo.</exception>
      <exception cref="T:System.InvalidOperationException">La chiamata al metodo tenta di avanzare oltre la fine del buffer sottostante.</exception>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.Clear">
      <summary>Cancella i dati scritti nel buffer sottostante.</summary>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.GetMemory(System.Int32)">
      <summary>Restituisce un oggetto <see cref="T:System.Memory`1" /> nel quale scrivere la cui lunghezza è almeno quella specificata da <paramref name="sizeHint" />.</summary>
      <param name="sizeHint">La lunghezza minima richiesta di <see cref="T:System.Memory`1" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="sizeHint" /> è negativo.</exception>
      <returns>
        <see cref="T:System.Memory`1" /> la cui lunghezza è almeno <paramref name="sizeHint" />.  Se <paramref name="sizeHint" /> non viene specificato o è uguale a 0, viene restituito un buffer non vuoto.</returns>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.GetSpan(System.Int32)">
      <summary>Restituisce un oggetto <see cref="T:System.Span`1" /> nel quale scrivere la cui lunghezza è almeno quella specificata.</summary>
      <param name="sizeHint">La lunghezza minima richiesta di <see cref="T:System.Span`1" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="sizeHint" /> è negativo.</exception>
      <returns>Un intervallo di almeno <paramref name="sizeHint" /> in lunghezza. Se <paramref name="sizeHint" /> non viene specificato o è uguale a 0, viene restituito un buffer non vuoto.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.Capacity">
      <summary>Ottiene la quantità totale di spazio all'interno del buffer sottostante.</summary>
      <returns>Capacità totale del buffer sottostante.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.FreeCapacity">
      <summary>Ottiene la quantità di spazio disponibile in cui è possibile scrivere senza determinare l'aumento del buffer sottostante.</summary>
      <returns>Spazio disponibile per la scrittura senza forzare l'aumento delle dimensioni del buffer sottostante.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenCount">
      <summary>Ottiene la quantità di dati scritti nel buffer sottostante.</summary>
      <returns>Quantità di dati scritti nel buffer sottostante.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenMemory">
      <summary>Ottiene un oggetto <see cref="T:System.ReadOnlyMemory`1" /> che contiene i dati scritti finora nel buffer sottostante.</summary>
      <returns>Dati scritti nel buffer sottostante.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenSpan">
      <summary>Ottiene un oggetto <see cref="T:System.ReadOnlySpan`1" /> che contiene i dati scritti finora nel buffer sottostante.</summary>
      <returns>Dati scritti nel buffer sottostante.</returns>
    </member>
    <member name="T:System.Buffers.Binary.BinaryPrimitives">
      <summary>Legge i byte come primitive con un ordine dei byte specifico.</summary>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadDoubleBigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Legge un <see cref="T:System.Double" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source">Intervallo di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.Double" />.</exception>
      <returns>Valore big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadDoubleLittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Legge un <see cref="T:System.Double" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source">Intervallo di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.Double" />.</exception>
      <returns>Valore little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Legge un <see cref="T:System.Int16" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source">Intervallo di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.Int16" />.</exception>
      <returns>Valore big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Legge un <see cref="T:System.Int16" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source">Intervallo di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.Int16" />.</exception>
      <returns>Valore little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Legge un <see cref="T:System.Int32" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source">Intervallo di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.Int32" />.</exception>
      <returns>Valore big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Legge un <see cref="T:System.Int32" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source">Intervallo di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.Int32" />.</exception>
      <returns>Valore little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Legge un <see cref="T:System.Int64" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source">Intervallo di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.Int64" />.</exception>
      <returns>Valore big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Legge un <see cref="T:System.Int64" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source">Intervallo di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.Int64" />.</exception>
      <returns>Valore little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadSingleBigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Legge un <see cref="T:System.Single" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source">Intervallo di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.Single" />.</exception>
      <returns>Valore big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadSingleLittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Legge un <see cref="T:System.Single" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source">Intervallo di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.Single" />.</exception>
      <returns>Valore little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Legge un <see cref="T:System.UInt16" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source">Intervallo di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.UInt16" />.</exception>
      <returns>Valore big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Legge un <see cref="T:System.UInt16" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source">Intervallo di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.UInt16" />.</exception>
      <returns>Valore little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Legge un <see cref="T:System.UInt32" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source">Intervallo di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.UInt32" />.</exception>
      <returns>Valore big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Legge un <see cref="T:System.UInt32" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source">Intervallo di byte di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.UInt32" />.</exception>
      <returns>Valore little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Legge un <see cref="T:System.UInt64" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source">Intervallo di byte di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.UInt64" />.</exception>
      <returns>Valore big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Legge un <see cref="T:System.UInt64" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source">Intervallo di byte di sola lettura da leggere.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> è troppo piccolo per contenere un <see cref="T:System.UInt64" />.</exception>
      <returns>Valore little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Byte)">
      <summary>Inverte un valore primitivo eseguendo uno scambio dell'ordine dei byte del valore <see cref="T:System.Byte" /> specificato, operazione in realtà senza effetti per un <see cref="T:System.Byte" />.</summary>
      <param name="value">Valore da invertire.</param>
      <returns>Valore passato, non modificato.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int16)">
      <summary>Inverte un valore primitivo eseguendo uno scambio dell'ordine dei byte del valore <see cref="T:System.Int16" /> specificato.</summary>
      <param name="value">Valore da invertire.</param>
      <returns>Valore invertito.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int32)">
      <summary>Inverte un valore primitivo eseguendo uno scambio dell'ordine dei byte del valore <see cref="T:System.Int32" /> specificato.</summary>
      <param name="value">Valore da invertire.</param>
      <returns>Valore invertito.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int64)">
      <summary>Inverte un valore primitivo eseguendo uno scambio dell'ordine dei byte del valore <see cref="T:System.Int64" /> specificato.</summary>
      <param name="value">Valore da invertire.</param>
      <returns>Valore invertito.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.SByte)">
      <summary>Inverte un valore primitivo eseguendo uno scambio dell'ordine dei byte del valore <see cref="T:System.SByte" /> specificato, operazione in realtà senza effetti per un <see cref="T:System.SByte" />.</summary>
      <param name="value">Valore da invertire.</param>
      <returns>Valore passato, non modificato.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt16)">
      <summary>Inverte un valore primitivo eseguendo uno scambio dell'ordine dei byte del valore <see cref="T:System.UInt16" /> specificato.</summary>
      <param name="value">Valore da invertire.</param>
      <returns>Valore invertito.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt32)">
      <summary>Inverte un valore primitivo eseguendo uno scambio dell'ordine dei byte del valore <see cref="T:System.UInt32" /> specificato.</summary>
      <param name="value">Valore da invertire.</param>
      <returns>Valore invertito.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt64)">
      <summary>Inverte un valore primitivo eseguendo uno scambio dell'ordine dei byte del valore <see cref="T:System.UInt64" /> specificato.</summary>
      <param name="value">Valore da invertire.</param>
      <returns>Valore invertito.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadDoubleBigEndian(System.ReadOnlySpan{System.Byte},System.Double@)">
      <summary>Legge un <see cref="T:System.Double" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value">Al termine, questo metodo contiene il valore letto dall'intervallo di byte di sola lettura, come big endian.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Double" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadDoubleLittleEndian(System.ReadOnlySpan{System.Byte},System.Double@)">
      <summary>Legge un <see cref="T:System.Double" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value">Al termine, questo metodo contiene il valore letto dall'intervallo di byte di sola lettura, come little endian.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Double" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16BigEndian(System.ReadOnlySpan{System.Byte},System.Int16@)">
      <summary>Legge un <see cref="T:System.Int16" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value">Al termine di questo metodo, il valore letto dall'intervallo di byte di sola lettura, come big endian.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Int16" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.Int16@)">
      <summary>Legge un <see cref="T:System.Int16" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value">Al termine di questo metodo, il valore letto dall'intervallo di byte di sola lettura, come little endian.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Int16" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32BigEndian(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Legge un <see cref="T:System.Int32" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value">Al termine di questo metodo, il valore letto dall'intervallo di byte di sola lettura, come big endian.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Int32" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Legge un <see cref="T:System.Int32" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value">Al termine di questo metodo, il valore letto dall'intervallo di byte di sola lettura, come little endian.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Int32" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64BigEndian(System.ReadOnlySpan{System.Byte},System.Int64@)">
      <summary>Legge un <see cref="T:System.Int64" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value">Al termine di questo metodo, il valore letto dall'intervallo di byte di sola lettura, come big endian.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Int64" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.Int64@)">
      <summary>Legge un <see cref="T:System.Int64" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value">Al termine di questo metodo, il valore letto dall'intervallo di byte di sola lettura, come little endian.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Int64" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadSingleBigEndian(System.ReadOnlySpan{System.Byte},System.Single@)">
      <summary>Legge un <see cref="T:System.Single" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value">Al termine, questo metodo contiene il valore letto dall'intervallo di byte di sola lettura, come big endian.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Single" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadSingleLittleEndian(System.ReadOnlySpan{System.Byte},System.Single@)">
      <summary>Legge un <see cref="T:System.Single" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value">Al termine, questo metodo contiene il valore letto dall'intervallo di byte di sola lettura, come little endian.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Single" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16BigEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)">
      <summary>Legge un <see cref="T:System.UInt16" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value">Al termine di questo metodo, il valore letto dall'intervallo di byte di sola lettura, come big endian.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.UInt16" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)">
      <summary>Legge un <see cref="T:System.UInt16" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value">Al termine di questo metodo, il valore letto dall'intervallo di byte di sola lettura, come little endian.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.UInt16" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32BigEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)">
      <summary>Legge un <see cref="T:System.UInt32" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value">Al termine di questo metodo, il valore letto dall'intervallo di byte di sola lettura, come big endian.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.UInt32" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)">
      <summary>Legge un <see cref="T:System.UInt32" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value">Al termine di questo metodo, il valore letto dall'intervallo di byte di sola lettura, come little endian.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.UInt32" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64BigEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)">
      <summary>Legge un <see cref="T:System.UInt64" /> dall'inizio di un intervallo di byte di sola lettura, come big endian.</summary>
      <param name="source">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value">Al termine di questo metodo, il valore letto dall'intervallo di byte di sola lettura, come big endian.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.UInt64" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)">
      <summary>Legge un <see cref="T:System.UInt64" /> dall'inizio di un intervallo di byte di sola lettura, come little endian.</summary>
      <param name="source">Intervallo di byte di sola lettura da leggere.</param>
      <param name="value">Al termine di questo metodo, il valore letto dall'intervallo di byte di sola lettura, come little endian.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.UInt64" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleBigEndian(System.Span{System.Byte},System.Double)">
      <summary>Scrive un <see cref="T:System.Double" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Double" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleLittleEndian(System.Span{System.Byte},System.Double)">
      <summary>Scrive un <see cref="T:System.Double" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Double" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16BigEndian(System.Span{System.Byte},System.Int16)">
      <summary>Scrive un <see cref="T:System.Int16" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Int16" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16LittleEndian(System.Span{System.Byte},System.Int16)">
      <summary>Scrive un <see cref="T:System.Int16" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Int16" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32BigEndian(System.Span{System.Byte},System.Int32)">
      <summary>Scrive un <see cref="T:System.Int32" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Int32" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32LittleEndian(System.Span{System.Byte},System.Int32)">
      <summary>Scrive un <see cref="T:System.Int32" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Int32" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64BigEndian(System.Span{System.Byte},System.Int64)">
      <summary>Scrive un <see cref="T:System.Int64" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Int64" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64LittleEndian(System.Span{System.Byte},System.Int64)">
      <summary>Scrive un <see cref="T:System.Int64" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Int64" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteSingleBigEndian(System.Span{System.Byte},System.Single)">
      <summary>Scrive un <see cref="T:System.Single" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Single" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteSingleLittleEndian(System.Span{System.Byte},System.Single)">
      <summary>Scrive un <see cref="T:System.Single" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.Single" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)">
      <summary>Scrive un <see cref="T:System.UInt16" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.UInt16" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)">
      <summary>Scrive un <see cref="T:System.UInt16" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.UInt16" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)">
      <summary>Scrive un <see cref="T:System.UInt32" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.UInt32" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)">
      <summary>Scrive un <see cref="T:System.UInt32" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.UInt32" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)">
      <summary>Scrive un <see cref="T:System.UInt64" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.UInt64" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)">
      <summary>Scrive un <see cref="T:System.UInt64" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <returns>
        <see langword="true" /> se l'intervallo è sufficientemente grande da contenere un <see cref="T:System.UInt64" />. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteDoubleBigEndian(System.Span{System.Byte},System.Double)">
      <summary>Scrive un <see cref="T:System.Double" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteDoubleLittleEndian(System.Span{System.Byte},System.Double)">
      <summary>Scrive un <see cref="T:System.Double" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16BigEndian(System.Span{System.Byte},System.Int16)">
      <summary>Scrive un <see cref="T:System.Int16" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.Int16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16LittleEndian(System.Span{System.Byte},System.Int16)">
      <summary>Scrive un <see cref="T:System.Int16" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.Int16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32BigEndian(System.Span{System.Byte},System.Int32)">
      <summary>Scrive un <see cref="T:System.Int32" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32LittleEndian(System.Span{System.Byte},System.Int32)">
      <summary>Scrive un <see cref="T:System.Int32" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64BigEndian(System.Span{System.Byte},System.Int64)">
      <summary>Scrive un <see cref="T:System.Int64" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.Int64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64LittleEndian(System.Span{System.Byte},System.Int64)">
      <summary>Scrive un <see cref="T:System.Int64" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.Int64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteSingleBigEndian(System.Span{System.Byte},System.Single)">
      <summary>Scrive un <see cref="T:System.Single" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.Single" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteSingleLittleEndian(System.Span{System.Byte},System.Single)">
      <summary>Scrive un <see cref="T:System.Single" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.Single" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)">
      <summary>Scrive un <see cref="T:System.UInt16" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.UInt16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)">
      <summary>Scrive un <see cref="T:System.UInt16" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.UInt16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)">
      <summary>Scrive un <see cref="T:System.UInt32" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.UInt32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)">
      <summary>Scrive un <see cref="T:System.UInt32" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.UInt32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)">
      <summary>Scrive un <see cref="T:System.UInt64" /> in un intervallo di byte, come big endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come big endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.UInt64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)">
      <summary>Scrive un <see cref="T:System.UInt64" /> in un intervallo di byte, come little endian.</summary>
      <param name="destination">Intervallo di byte in cui deve essere scritto il valore, come little endian.</param>
      <param name="value">Valore da scrivere nell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> è troppo piccolo per contenere un <see cref="T:System.UInt64" />.</exception>
    </member>
    <member name="T:System.Buffers.BuffersExtensions">
      <summary>Fornisce metodi di estensione per <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.CopyTo``1(System.Buffers.ReadOnlySequence{``0},System.Span{``0})">
      <summary>Copia <see cref="T:System.Buffers.ReadOnlySequence`1" /> nel <see cref="T:System.Span`1" /> specificato.</summary>
      <param name="source">Il <see cref="T:System.Buffers.ReadOnlySequence`1" /> di origine.</param>
      <param name="destination">
        <see cref="T:System.Span`1" /> di destinazione.</param>
      <typeparam name="T">Tipo degli elementi nell'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> .</typeparam>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.PositionOf``1(System.Buffers.ReadOnlySequence{``0},``0)">
      <summary>Restituisce la posizione della prima occorrenza di <paramref name="item" /> in <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <param name="source">Il <see cref="T:System.Buffers.ReadOnlySequence`1" /> di origine.</param>
      <param name="value">Elemento da trovare in <see cref="T:System.Buffers.ReadOnlySequence`1" />.</param>
      <typeparam name="T">Tipo degli elementi nell'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> .</typeparam>
      <returns>Oggetto il cui metodo <see cref="M:System.SequencePosition.GetInteger" /> restituisce la posizione della prima occorrenza di <paramref name="item" />, o un oggetto la cui proprietà <see langword="Nullable&lt;SequencePosition&gt;.HasValue" /> è <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.ToArray``1(System.Buffers.ReadOnlySequence{``0})">
      <summary>Converte <see cref="T:System.Buffers.ReadOnlySequence`1" /> in una matrice.</summary>
      <param name="sequence">Sequenza di sola lettura da convertire in una matrice.</param>
      <typeparam name="T">Tipo degli elementi nell'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> .</typeparam>
      <returns>Matrice che contiene i dati nella sequenza di sola lettura corrente.</returns>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.Write``1(System.Buffers.IBufferWriter{``0},System.ReadOnlySpan{``0})">
      <summary>Scrive il contenuto di <paramref name="value" /> in <paramref name="writer" />.</summary>
      <param name="writer">Writer del buffer in cui scrivere <paramref name="value" />.</param>
      <param name="value">Intervallo di sola lettura da scrivere in <paramref name="writer" />.</param>
      <typeparam name="T">Tipo degli elementi nell'oggetto <see cref="T:System.ReadOnlySpan`1" /> .</typeparam>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="writer" /> è più breve di <paramref name="value" />.</exception>
    </member>
    <member name="T:System.Buffers.IBufferWriter`1">
      <summary>Rappresenta un sink di output in cui è possibile scrivere dati <typeparamref name="T" />.</summary>
      <typeparam name="T">Tipo degli elementi nell'oggetto <see cref="T:System.Buffers.IBufferWriter`1" /> .</typeparam>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.Advance(System.Int32)">
      <summary>Comunica a <see cref="T:System.Buffers.IBufferWriter`1" /> che gli elementi di dati <paramref name="count" /> sono stati scritti nell'elemento <see cref="T:System.Span`1" /> o <see cref="T:System.Memory`1" /> di output.</summary>
      <param name="count">Numero di elementi di dati scritti in <see cref="T:System.Span`1" /> o <see cref="T:System.Memory`1" />.</param>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.GetMemory(System.Int32)">
      <summary>Restituisce un elemento <see cref="T:System.Memory`1" /> in cui scrivere, con almeno le dimensioni richieste (specificate da <paramref name="sizeHint" />).</summary>
      <param name="sizeHint">Lunghezza minima dell'elemento <see cref="T:System.Memory`1" /> restituito. Se è 0, viene restituito un buffer non vuoto.</param>
      <exception cref="T:System.OutOfMemoryException">Le dimensioni del buffer richieste non sono disponibili.</exception>
      <returns>Elemento <see cref="T:System.Memory`1" /> con dimensioni pari almeno a <paramref name="sizeHint" />. Se <paramref name="sizeHint" /> è 0, restituisce un buffer non vuoto.</returns>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)">
      <summary>Restituisce un elemento <see cref="T:System.Span`1" /> in cui scrivere, con almeno le dimensioni richieste (specificate da <paramref name="sizeHint" />).</summary>
      <param name="sizeHint">Lunghezza minima dell'elemento <see cref="T:System.Span`1" /> restituito. Se è 0, viene restituito un buffer non vuoto.</param>
      <returns>Elemento <see cref="T:System.Span`1" /> con dimensioni pari almeno a <paramref name="sizeHint" />. Se <paramref name="sizeHint" /> è 0, restituisce un buffer non vuoto.</returns>
    </member>
    <member name="T:System.Buffers.MemoryPool`1">
      <summary>Rappresenta un pool di blocchi di memoria.</summary>
      <typeparam name="T">Tipo di elementi nel pool di memoria.</typeparam>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.#ctor">
      <summary>Costruisce una nuova istanza di un pool di memoria.</summary>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Dispose">
      <summary>Rilascia tutte le risorse usate dal pool di memoria.</summary>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Dispose(System.Boolean)">
      <summary>Rilascia le risorse non gestite usate dal pool di memoria e, facoltativamente, le risorse gestite.</summary>
      <param name="disposing">
        <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Rent(System.Int32)">
      <summary>Restituisce un blocco di memoria in grado di contenere almeno <paramref name="minBufferSize" /> elementi di T.</summary>
      <param name="minBufferSize">Numero minimo di elementi di <typeparamref name="T" /> che può contenere il pool di memoria. Il valore -1 restituisce un pool di memoria impostato sulle dimensioni predefinite per il pool.</param>
      <returns>Un blocco di memoria in grado di contenere almeno <paramref name="minBufferSize" /> elementi di T.</returns>
    </member>
    <member name="P:System.Buffers.MemoryPool`1.MaxBufferSize">
      <summary>Ottiene la dimensione massima del buffer supportata da questo pool.</summary>
      <returns>Dimensione massima del buffer supportata da questo pool.</returns>
    </member>
    <member name="P:System.Buffers.MemoryPool`1.Shared">
      <summary>Ottiene un'istanza singleton di un pool di memoria basato su matrici.</summary>
      <returns>Istanza singleton di un pool di memoria.</returns>
    </member>
    <member name="T:System.Buffers.ReadOnlySequence`1">
      <summary>Rappresenta una sequenza in grado di leggere una serie sequenziale di <typeparamref name="T" />.</summary>
      <typeparam name="T">Tipo degli elementi nella sequenza di sola lettura.</typeparam>
    </member>
    <member name="F:System.Buffers.ReadOnlySequence`1.Empty">
      <summary>Restituisce un oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> vuoto.</summary>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[])">
      <summary>Crea un'istanza di <see cref="T:System.Buffers.ReadOnlySequence`1" /> da <paramref name="array" />.</summary>
      <param name="array">Matrice da cui creare una sequenza di sola lettura.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[],System.Int32,System.Int32)">
      <summary>Crea un'istanza di <see cref="T:System.Buffers.ReadOnlySequence`1" /> da una sezione di una matrice.</summary>
      <param name="array">Matrice da cui creare la sequenza di sola lettura.</param>
      <param name="start">Indice in base zero del primo elemento nella matrice da includere nella sequenza di sola lettura.</param>
      <param name="length">Numero di elementi da includere nella sequenza di sola lettura.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.Buffers.ReadOnlySequenceSegment{`0},System.Int32,System.Buffers.ReadOnlySequenceSegment{`0},System.Int32)">
      <summary>Crea un'istanza di <see cref="T:System.Buffers.ReadOnlySequence`1" /> da un elenco di memoria collegata rappresentato da segmenti iniziali e finali e dagli indici corrispondenti in essi contenuti.</summary>
      <param name="startSegment">Nodo iniziale dell'elenco di memoria collegata.</param>
      <param name="startIndex">Posizione dell'inizio della sequenza all'interno di <paramref name="startSegment" />.</param>
      <param name="endSegment">Nodo finale dell'elenco di memoria collegata.</param>
      <param name="endIndex">Posizione della fine della sequenza all'interno di <paramref name="endSegment" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="startSegment" /> o <paramref name="endSegment" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">L'indice corrente di <paramref name="startSegment" /> è maggiore dell'indice corrente di <paramref name="endSegment" />, anche se <paramref name="startSegment" /> è diverso da <paramref name="endSegment" />.

-oppure-

<paramref name="startSegment" /> è uguale a <paramref name="endSegment" /> ma <paramref name="endIndex" /> è minore di <paramref name="startIndex" />.

-oppure-

<paramref name="startIndex" /> è maggiore della lunghezza del blocco di memoria sottostante di <paramref name="startSegment" />.</exception>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.ReadOnlyMemory{`0})">
      <summary>Crea un'istanza di <see cref="T:System.Buffers.ReadOnlySequence`1" /> da <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <param name="memory">Blocco di memoria di sola lettura di elementi di tipo <typeparamref name="T" />.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetEnumerator">
      <summary>Restituisce un enumeratore per <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <returns>Restituisce un enumeratore per <see cref="T:System.Buffers.ReadOnlySequence`1" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetOffset(System.SequencePosition)">
      <summary>Restituisce l'offset di un oggetto <paramref name="position" /> all'interno di questa sequenza dall'inizio.</summary>
      <param name="position">
        <see cref="T:System.SequencePosition" /> di cui ottenere l'offset.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">La posizione non è compresa nell'intervallo consentito.</exception>
      <returns>Offset dall'inizio della sequenza.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64)">
      <summary>Restituisce una nuova <see cref="T:System.SequencePosition" /> in corrispondenza di <paramref name="offset" /> dall'inizio della sequenza.</summary>
      <param name="offset">Offset dall'inizio della sequenza.</param>
      <returns>Oggetto che rappresenta la posizione della sequenza che inizia in corrispondenza dell'elemento <paramref name="offset" /> specificato dall'inizio della sequenza.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64,System.SequencePosition)">
      <summary>Restituisce una nuovo elemento <see cref="T:System.SequencePosition" /> a partire dall'offset specificato dalla posizione di <paramref name="origin" />.</summary>
      <param name="offset">Offset dalla posizione della sequenza <paramref name="origin" /> specificata.</param>
      <param name="origin">Posizione della sequenza che rappresenta il punto da cui avviare l'offset.</param>
      <returns>Oggetto che rappresenta la posizione della sequenza che inizia in corrispondenza della posizione di <paramref name="offset" /> dell'oggetto posizione <paramref name="origin" /> specificato.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.Int32)">
      <summary>Crea una sezione dall'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> corrente, a partire da <paramref name="start" />, con <paramref name="length" /> elementi.</summary>
      <param name="start">Indice in corrispondenza del quale iniziare la sezione.</param>
      <param name="length">Lunghezza della sezione.</param>
      <returns>Sezione costituita da <paramref name="length" /> elementi dall'istanza corrente a partire dall'indice <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.SequencePosition)">
      <summary>Crea una sezione dall'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> corrente, a partire da <paramref name="start" /> e fino a <paramref name="end" /> (esclusivo).</summary>
      <param name="start">Indice in corrispondenza del quale iniziare la sezione.</param>
      <param name="end">Fine (esclusiva) <see cref="T:System.SequencePosition" /> della sezione.</param>
      <returns>Sezione costituita da elementi dall'indice <paramref name="start" /> fino alla posizione della sequenza <paramref name="end" />, non inclusa, nella sequenza di sola lettura corrente.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64)">
      <summary>Crea una sezione dall'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> corrente, iniziando in corrispondenza dell'indice specificato e continuando fino alla fine della sequenza di sola lettura.</summary>
      <param name="start">Indice iniziale in corrispondenza del quale iniziare la sezione.</param>
      <returns>Una sezione che inizia dall'indice <paramref name="start" /> e continua fino alla fine della sequenza corrente di sola lettura.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.Int64)">
      <summary>Crea una sezione dall'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> specificato, a partire da <paramref name="start" />, con <paramref name="length" /> elementi.</summary>
      <param name="start">Indice in corrispondenza del quale iniziare la sezione.</param>
      <param name="length">Lunghezza della sezione.</param>
      <returns>Sezione costituita da <paramref name="length" /> elementi dall'istanza corrente a partire dall'indice <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.SequencePosition)">
      <summary>Crea una sezione dall'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> corrente, a partire da <paramref name="start" /> e fino a <paramref name="end" /> (esclusivo).</summary>
      <param name="start">Indice in corrispondenza del quale iniziare la sezione.</param>
      <param name="end">Fine (esclusiva) della sezione.</param>
      <returns>Sezione costituita da elementi dall'indice <paramref name="start" /> fino alla posizione della sequenza <paramref name="end" />, non inclusa, nella sequenza di sola lettura corrente.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition)">
      <summary>Crea una sezione dall'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> corrente, iniziando in corrispondenza della posizione della sequenza specificata e continuando fino alla fine della sequenza di sola lettura.</summary>
      <param name="start">Valore <see cref="T:System.SequencePosition" /> iniziale (inclusivo) in corrispondenza del quale iniziare questa sezione.</param>
      <returns>Una sezione che inizia dalla posizione della sequenza <paramref name="start" /> e continua fino alla fine della sequenza corrente di sola lettura.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int32)">
      <summary>Crea una sezione dall'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> corrente, a partire da <paramref name="start" />, con <paramref name="length" /> elementi.</summary>
      <param name="start">Valore <see cref="T:System.SequencePosition" /> iniziale (inclusivo) in corrispondenza del quale iniziare questa sezione.</param>
      <param name="length">Lunghezza della sezione.</param>
      <returns>Sezione costituita da <paramref name="length" /> elementi dall'istanza corrente a partire dalla posizione della sequenza <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int64)">
      <summary>Crea una sezione dall'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> corrente, a partire da <paramref name="start" />, con <paramref name="length" /> elementi.</summary>
      <param name="start">Valore <see cref="T:System.SequencePosition" /> iniziale (inclusivo) in corrispondenza del quale iniziare questa sezione.</param>
      <param name="length">Lunghezza della sezione.</param>
      <returns>Sezione costituita da <paramref name="length" /> elementi dall'istanza corrente a partire dalla posizione della sequenza <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.SequencePosition)">
      <summary>Crea una sezione dall'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> corrente, a partire da <paramref name="start" /> e fino a <paramref name="end" /> (esclusivo).</summary>
      <param name="start">Valore <see cref="T:System.SequencePosition" /> iniziale (inclusivo) in corrispondenza del quale iniziare questa sezione.</param>
      <param name="end">Valore finale (esclusivo) <see cref="T:System.SequencePosition" /> della sezione.</param>
      <returns>Sezione costituita da elementi dalla posizione della sequenza <paramref name="start" /> fino alla posizione della sequenza <paramref name="end" />, non inclusa, nella sequenza di sola lettura corrente.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.ToString">
      <summary>Restituisce una stringa che rappresenta la sequenza corrente.</summary>
      <returns>Stringa che rappresenta la sequenza corrente.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.TryGet(System.SequencePosition@,System.ReadOnlyMemory{`0}@,System.Boolean)">
      <summary>Tenta di recuperare il segmento successivo dopo <paramref name="position" /> e restituisce un valore che indica se l'operazione è riuscita.</summary>
      <param name="position">Posizione della sequenza corrente.</param>
      <param name="memory">Intervallo di memoria di sola lettura che contiene il segmento successivo dopo <paramref name="position" />.</param>
      <param name="advance">
        <see langword="true" /> se <paramref name="position" /> deve essere all'inizio del segmento successivo. In caso contrario, <see langword="false" />.</param>
      <returns>Restituisce <see langword="true" /> se il metodo ha restituito il segmento successivo o <see langword="false" /> se è stata raggiunta la fine della sequenza di sola lettura.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.End">
      <summary>Ottiene la posizione alla fine di <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.First">
      <summary>Ottiene <see cref="T:System.ReadOnlyMemory`1" /> dal primo segmento.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.FirstSpan">
      <summary>Ottiene <see cref="T:System.ReadOnlySpan`1" /> dal primo segmento.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.IsEmpty">
      <summary>Ottiene un valore che indica se <see cref="T:System.Buffers.ReadOnlySequence`1" /> è vuoto.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.IsSingleSegment">
      <summary>Ottiene un valore che indica se <see cref="T:System.Buffers.ReadOnlySequence`1" /> contiene un singolo segmento <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <returns>
        <see langword="true" /> Se la sequenza di sola lettura è vuota; in caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Length">
      <summary>Ottiene la lunghezza dell'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <returns>Lunghezza della sequenza di sola lettura.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Start">
      <summary>Ottiene la posizione all'inizio di <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="T:System.Buffers.ReadOnlySequence`1.Enumerator">
      <summary>Rappresenta un enumeratore su <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <typeparam name="T" />
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.#ctor(System.Buffers.ReadOnlySequence{`0}@)">
      <summary>Inizializza l'enumeratore.</summary>
      <param name="sequence">Insieme <see cref="T:System.Buffers.ReadOnlySequence`1" /> da enumerare.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.MoveNext">
      <summary>Passa al successivo oggetto <see cref="T:System.ReadOnlyMemory`1" /> nell'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente all'elemento successivo; <see langword="false" /> se è stata raggiunta la fine della sequenza.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Enumerator.Current">
      <summary>Ottiene l'oggetto <see cref="T:System.ReadOnlyMemory`1" /> corrente.</summary>
      <returns>Oggetto <see cref="T:System.ReadOnlyMemory`1" /> corrente.</returns>
    </member>
    <member name="T:System.Buffers.ReadOnlySequenceSegment`1">
      <summary>Rappresenta un elenco collegato di nodi <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <typeparam name="T">Tipo di elementi nel segmento di sequenza di sola lettura.</typeparam>
    </member>
    <member name="M:System.Buffers.ReadOnlySequenceSegment`1.#ctor">
      <summary>Inizializza una nuova istanza della classe <see cref="T:System.Buffers.ReadOnlySequenceSegment`1" />.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Memory">
      <summary>Ottiene o imposta un valore <see cref="T:System.ReadOnlyMemory`1" /> per il nodo corrente.</summary>
      <returns>
        <see cref="T:System.ReadOnlyMemory`1" />Valore per il nodo corrente.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Next">
      <summary>Ottiene o imposta il nodo successivo.</summary>
      <returns>Nodo successivo.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.RunningIndex">
      <summary>Ottiene o imposta la somma delle lunghezze di nodo prima del nodo corrente.</summary>
      <returns>Somma delle lunghezze dei nodi prima del nodo corrente.</returns>
    </member>
    <member name="T:System.Buffers.SequenceReader`1">
      <summary>Fornisce metodi per la lettura di dati binari e di testo da un oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> con particolare attenzione alle prestazioni e allocazioni di heap minime o assenti.</summary>
      <typeparam name="T">Tipo della sequenza di sola lettura.</typeparam>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.#ctor(System.Buffers.ReadOnlySequence{`0})">
      <summary>Crea un oggetto <see cref="T:System.Buffers.SequenceReader`1" /> su un oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> specificato.</summary>
      <param name="sequence">La sequenza di sola lettura sulla quale creare <see cref="T:System.Buffers.SequenceReader`1" />.</param>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.Advance(System.Int64)">
      <summary>Sposta il lettore in avanti di un numero specificato di elementi.</summary>
      <param name="count">Il numero di elementi da far avanzare.</param>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePast(`0)">
      <summary>Avanza oltre le istanze consecutive dell'oggetto <paramref name="value" /> specificato.</summary>
      <param name="value">Il valore oltre il quale il lettore deve avanzare.</param>
      <returns>Il numero di posizioni di cui è avanzato il lettore.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0)">
      <summary>Avanza oltre le istanze consecutive di uno di due valori specificati.</summary>
      <param name="value0">Il primo valore da ignorare.</param>
      <param name="value1">Il secondo valore da ignorare.</param>
      <returns>Il numero di posizioni di cui è avanzato il lettore.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0)">
      <summary>Avanza oltre le istanze consecutive di uno di tre valori specificati.</summary>
      <param name="value0">Il primo valore da ignorare.</param>
      <param name="value1">Il secondo valore da ignorare.</param>
      <param name="value2">Il terzo valore da ignorare.</param>
      <returns>Il numero di posizioni di cui è avanzato il lettore.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0,`0)">
      <summary>Avanza oltre le istanze consecutive di uno di quattro valori specificati.</summary>
      <param name="value0">Il primo valore da ignorare.</param>
      <param name="value1">Il secondo valore da ignorare.</param>
      <param name="value2">Il terzo valore da ignorare.</param>
      <param name="value3">Il quarto valore da ignorare.</param>
      <returns>Il numero di posizioni di cui è avanzato il lettore.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(System.ReadOnlySpan{`0})">
      <summary>Ignora le istanze consecutive di qualsiasi oggetto <paramref name="values" /> specificato.</summary>
      <param name="values">I valori da ignorare.</param>
      <returns>Il numero di posizioni di cui è avanzato il lettore.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvanceToEnd">
      <summary>Sposta il lettore alla fine della sequenza.</summary>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.IsNext(`0,System.Boolean)">
      <summary>Controlla se un valore specificato è successivo nella sequenza.</summary>
      <param name="next">Il valore con cui confrontare gli elementi successivi.</param>
      <param name="advancePast">
        <see langword="true" /> per spostarsi oltre i valori <paramref name="next" /> se vengono trovati. In caso contrario, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> se i valori sono successivi nella sequenza. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.IsNext(System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Controlla se i valori specificati in un intervallo di sola lettura sono successivi nella sequenza.</summary>
      <param name="next">L'intervallo con cui confrontare gli elementi successivi.</param>
      <param name="advancePast">
        <see langword="true" /> per spostarsi oltre i valori <paramref name="next" /> se vengono trovati. In caso contrario, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> se i valori sono successivi nella sequenza. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.Rewind(System.Int64)">
      <summary>Sposta il lettore indietro del numero specificato di elementi.</summary>
      <param name="count">Numero di elementi.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> è negativo o maggiore di <see cref="P:System.Buffers.SequenceReader`1.Consumed" />.</exception>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryAdvanceTo(`0,System.Boolean)">
      <summary>Cerca un delimitatore specificato e facoltativamente avanza oltre se viene trovato.</summary>
      <param name="delimiter">Il delimitatore da cercare.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> per superare l'oggetto <paramref name="delimiter" /> se viene trovato; in caso contrario, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> se l'oggetto <paramref name="delimiter" /> specificato viene trovato; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryAdvanceToAny(System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Cerca i delimitatori compresi in una serie di delimitatori specificati e facoltativamente avanza oltre il primo da trovare.</summary>
      <param name="delimiters">I delimitatori da cercare.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> per spostarsi oltre la prima istanza di uno qualsiasi degli oggetti <paramref name="delimiters" /> specificati. <see langword="false" /> per non sposarsi oltre il delimitatore.</param>
      <returns>
        <see langword="true" /> se viene trovato uno dei <paramref name="delimiters" /> specificati. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryCopyTo(System.Span{`0})">
      <summary>Copia i dati dalla posizione corrente nell'intervallo di destinazione specificato se sono disponibili dati sufficienti per riempirlo.</summary>
      <param name="destination">Intervallo di destinazione in cui eseguire la copia.</param>
      <returns>
        <see langword="true" /> se sono disponibili dati sufficienti per riempire completamente l'intervallo <paramref name="destination" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryPeek(`0@)">
      <summary>Visualizza il valore successivo senza far avanzare il lettore.</summary>
      <param name="value">Il valore successivo o il valore predefinito se alla fine del lettore.</param>
      <returns>
        <see langword="true" /> se il lettore non è alla fine e l'operazione di visualizzazione è riuscita; <see langword="false" /> se si è alla fine del lettore.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryPeek(System.Int64,`0@)">
      <summary>Visualizza il valore successivo in corrispondenza dell'offset specificato senza far avanzare il lettore.</summary>
      <param name="offset">Offset dalla posizione corrente.</param>
      <param name="value">Il valore successivo o il valore predefinito se alla fine del lettore.</param>
      <returns>
        <see langword="true" /> se il lettore non è alla fine e l'operazione di visualizzazione è riuscita; <see langword="false" /> se si è alla fine del lettore.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryRead(`0@)">
      <summary>Legge il valore successivo e fa avanzare il lettore.</summary>
      <param name="value">Il valore successivo o il valore predefinito se alla fine del lettore.</param>
      <returns>
        <see langword="true" /> se il lettore non è alla fine e l'operazione di lettura è riuscita; <see langword="false" /> se si è alla fine del lettore.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,`0,System.Boolean)">
      <summary>Prova a leggere tutto fino all'oggetto <paramref name="delimiter" /> specificato, ignorando i delimitatori preceduti da <paramref name="delimiterEscape" />.</summary>
      <param name="sequence">Quando il metodo viene restituito, contiene i dati letti, se presenti.</param>
      <param name="delimiter">Il delimitatore da cercare.</param>
      <param name="delimiterEscape">Un valore che indica che un oggetto <paramref name="delimiter" /> immediatamente seguente deve essere ignorato.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> per spostarsi oltre il <paramref name="delimiter" /> se viene trovato. In caso contrario, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> se l'oggetto <paramref name="delimiter" /> viene trovato; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,System.Boolean)">
      <summary>Prova a leggere tutto fino all'oggetto <paramref name="delimiter" /> specificato.</summary>
      <param name="sequence">Quando il metodo viene restituito, contiene i dati letti, se presenti.</param>
      <param name="delimiter">Il delimitatore da cercare.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> per spostarsi oltre il <paramref name="delimiter" /> se viene trovato. In caso contrario, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> se l'oggetto <paramref name="delimiter" /> viene trovato; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Prova a leggere i dati finché l'intero delimitatore specificato come intervallo di sola lettura corrisponde.</summary>
      <param name="sequence">Quando il metodo viene restituito, contiene i dati letti, se presenti.</param>
      <param name="delimiter">Un intervallo di sola lettura contenente uno o più delimitatori.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> per spostarsi oltre il <paramref name="delimiter" /> se viene trovato. In caso contrario, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> se l'oggetto <paramref name="delimiter" /> viene trovato; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,`0,System.Boolean)">
      <summary>Prova a leggere tutto fino all'oggetto <paramref name="delimiter" /> specificato, ignorando i delimitatori preceduti da <paramref name="delimiterEscape" />.</summary>
      <param name="span">Quando il metodo viene restituito, contiene i dati letti, se presenti.</param>
      <param name="delimiter">Il delimitatore da cercare.</param>
      <param name="delimiterEscape">Un valore che indica che un oggetto <paramref name="delimiter" /> immediatamente seguente deve essere ignorato.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> per spostarsi oltre il <paramref name="delimiter" /> se viene trovato. In caso contrario, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> se l'oggetto <paramref name="delimiter" /> viene trovato; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,System.Boolean)">
      <summary>Prova a leggere tutto fino all'oggetto <paramref name="delimiter" /> specificato.</summary>
      <param name="span">Quando il metodo viene restituito, contiene i dati letti, se presenti.</param>
      <param name="delimiter">Il delimitatore da cercare.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> per spostarsi oltre il <paramref name="delimiter" /> se viene trovato. In caso contrario, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> se l'oggetto <paramref name="delimiter" /> viene trovato; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Prova a leggere tutto fino all'oggetto <paramref name="delimiter" /> specificato.</summary>
      <param name="sequence">Gli eventuali dati letti.</param>
      <param name="delimiter">Il delimitatore da cercare.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> per superare l'oggetto <paramref name="delimiter" />, se trovato.</param>
      <param name="span">Gli eventuali dati letti.</param>
      <returns>
        <see langword="true" /> se l'oggetto <paramref name="delimiter" /> viene trovato; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadToAny(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Prova a leggere tutto fino a uno qualsiasi degli oggetti <paramref name="delimiters" /> specificati.</summary>
      <param name="sequence">Quando il metodo viene restituito, contiene i dati letti, se presenti.</param>
      <param name="delimiters">I delimitatori da cercare.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> per spostarsi oltre la prima istanza trovata di uno qualsiasi dei <paramref name="delimiters" /> specificati. In caso contrario <see langword="false" />.</param>
      <returns>
        <see langword="true" /> se uno qualsiasi degli oggetti <paramref name="delimiters" /> viene trovato; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadToAny(System.ReadOnlySpan{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Prova a leggere tutto fino a uno qualsiasi degli oggetti <paramref name="delimiters" /> specificati.</summary>
      <param name="span">Quando il metodo viene restituito, contiene i dati letti, se presenti.</param>
      <param name="delimiters">I delimitatori da cercare.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> per spostarsi oltre la prima istanza trovata di uno qualsiasi dei <paramref name="delimiters" /> specificati. In caso contrario <see langword="false" />.</param>
      <returns>
        <see langword="true" /> se uno qualsiasi degli oggetti <paramref name="delimiters" /> viene trovato; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Consumed">
      <summary>Ottiene il numero totale di valori <typeparamref name="T" /> elaborati dal lettore.</summary>
      <returns>Numero totale di valori elaborati dal reader.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.CurrentSpan">
      <summary>Ottiene un oggetto <see cref="T:System.Span`1" /> contenente il segmento corrente in <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns>Intervallo che contiene il segmento corrente nella sequenza.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.CurrentSpanIndex">
      <summary>Ottiene l'indice in <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />.</summary>
      <returns>Indice nell'oggetto <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.End">
      <summary>Ottiene un valore che indica se non sono presenti altri dati in <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns>
        <see langword="true" /> Quando non sono presenti altri dati nell'oggetto <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> ; in caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Length">
      <summary>Ottiene il numero di elementi presenti nell'oggetto <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> del lettore.</summary>
      <returns>Numero di elementi nell'oggetto del Reader <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Position">
      <summary>Ottiene la posizione corrente in <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns>Posizione corrente nell'oggetto <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Remaining">
      <summary>Ottiene gli elementi rimanenti nell'oggetto <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> del lettore.</summary>
      <returns>Gli elementi rimanenti nel lettore <see cref="P:System.Buffers.SequenceReader`1.Sequence" /></returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Sequence">
      <summary>Ottiene l'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> sottostante per il lettore.</summary>
      <returns>Sequenza di sola lettura sottostante per il lettore.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.UnreadSequence">
      <summary>Ottiene la parte non letta di <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns>Parte non letta dell'oggetto <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.UnreadSpan">
      <summary>Ottiene la parte non letta di <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />.</summary>
      <returns>Parte non letta dell'oggetto <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> .</returns>
    </member>
    <member name="T:System.Buffers.SequenceReaderExtensions">
      <summary>Fornisce funzionalità estese per la classe <see cref="T:System.Buffers.SequenceReader`1" /> che consentono la lettura di valori numerici specifici endian da dati binari.</summary>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int16@)">
      <summary>Tenta di leggere un valore <see cref="T:System.Int16" /> come big endian.</summary>
      <param name="reader">Istanza del lettore della sequenza di byte da cui deve essere letto il valore.</param>
      <param name="value">Al termine del metodo, il valore letto dal lettore della sequenza di byte, come big endian.</param>
      <returns>
        <see langword="true" /> se l'operazione di lettura ha esito positivo; <see langword="false" /> se non ci sono dati sufficienti per <see cref="T:System.Int16" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int32@)">
      <summary>Tenta di leggere un valore <see cref="T:System.Int32" /> come big endian.</summary>
      <param name="reader">Lettore della sequenza di byte da cui leggere il valore.</param>
      <param name="value">Al termine del metodo, il valore letto dal lettore della sequenza di byte, come big endian.</param>
      <returns>
        <see langword="true" /> se l'operazione di lettura ha esito positivo; <see langword="false" /> se non ci sono dati sufficienti per <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int64@)">
      <summary>Tenta di leggere un valore <see cref="T:System.Int64" /> come big endian.</summary>
      <param name="reader">Istanza del lettore della sequenza di byte da cui deve essere letto il valore.</param>
      <param name="value">Al termine del metodo, il valore letto dal lettore della sequenza di byte, come big endian.</param>
      <returns>
        <see langword="true" /> se l'operazione di lettura ha esito positivo; <see langword="false" /> se non ci sono dati sufficienti per <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int16@)">
      <summary>Tenta di leggere un valore <see cref="T:System.Int16" /> come little endian.</summary>
      <param name="reader">Istanza del lettore della sequenza di byte da cui deve essere letto il valore.</param>
      <param name="value">Al termine del metodo, il valore letto dal lettore della sequenza di byte, come little endian.</param>
      <returns>
        <see langword="true" /> se l'operazione di lettura ha esito positivo; <see langword="false" /> se non ci sono dati sufficienti per <see cref="T:System.Int16" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int32@)">
      <summary>Tenta di leggere un valore <see cref="T:System.Int32" /> come little endian.</summary>
      <param name="reader">Istanza del lettore della sequenza di byte da cui deve essere letto il valore.</param>
      <param name="value">Al termine del metodo, il valore letto dal lettore della sequenza di byte, come little endian.</param>
      <returns>
        <see langword="true" /> se l'operazione di lettura ha esito positivo; <see langword="false" /> se non ci sono dati sufficienti per <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int64@)">
      <summary>Tenta di leggere un valore <see cref="T:System.Int64" /> come little endian.</summary>
      <param name="reader">Istanza del lettore della sequenza di byte da cui deve essere letto il valore.</param>
      <param name="value">Al termine del metodo, il valore letto dal lettore della sequenza di byte, come little endian.</param>
      <returns>
        <see langword="true" /> se l'operazione di lettura ha esito positivo; <see langword="false" /> se non ci sono dati sufficienti per <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="T:System.Buffers.StandardFormat">
      <summary>Rappresenta una stringa in formato standard senza usare una stringa effettiva.</summary>
    </member>
    <member name="F:System.Buffers.StandardFormat.MaxPrecision">
      <summary>Definisce il valore di precisione valido massimo.</summary>
    </member>
    <member name="F:System.Buffers.StandardFormat.NoPrecision">
      <summary>Indica che un formato non usa una precisione o che la precisione non è specificata.</summary>
    </member>
    <member name="M:System.Buffers.StandardFormat.#ctor(System.Char,System.Byte)">
      <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Buffers.StandardFormat" />.</summary>
      <param name="symbol">Identificatore di formato specifico del tipo, ad esempio 'G', 'D' o 'X'.</param>
      <param name="precision">Valore di precisione facoltativo compreso tra 0 e 99 oppure il valore speciale <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> (predefinito).</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="symbol" /> non è <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> e il relativo valore è maggiore di <see cref="F:System.Buffers.StandardFormat.MaxPrecision" />.

-oppure-

L'elemento <paramref name="symbol" /> non può essere convertito in <see cref="T:System.Byte" />.</exception>
    </member>
    <member name="M:System.Buffers.StandardFormat.Equals(System.Buffers.StandardFormat)">
      <summary>Restituisce un valore che indica se l'oggetto <see cref="T:System.Buffers.StandardFormat" /> specificato è uguale all'istanza corrente.</summary>
      <param name="other">Formato da confrontare con l'istanza corrente.</param>
      <returns>
        <see langword="true" /> se le due istanze sono uguali, in caso contrario <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Equals(System.Object)">
      <summary>Restituisce un valore che indica se l'oggetto specificato è un oggetto <see cref="T:System.Buffers.StandardFormat" /> uguale all'istanza corrente.</summary>
      <param name="obj">Oggetto da confrontare con l'istanza corrente.</param>
      <returns>
        <see langword="true" /> se le due istanze sono uguali, in caso contrario <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.GetHashCode">
      <summary>Restituisce il codice hash per l'istanza.</summary>
      <returns>Codice hash per l'istanza.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Equality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
      <summary>Restituisce un valore che indica se due istanze di <see cref="T:System.Buffers.StandardFormat" /> sono uguali.</summary>
      <param name="left">Primo formato da confrontare.</param>
      <param name="right">Secondo formato da confrontare.</param>
      <returns>
        <see langword="true" /> se le due istanze sono uguali, in caso contrario <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Implicit(System.Char)~System.Buffers.StandardFormat">
      <summary>Converte un carattere in un'istanza di <see cref="T:System.Buffers.StandardFormat" /> con la precisione <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</summary>
      <param name="symbol">Carattere da convertire in un valore <see cref="T:System.Buffers.StandardFormat" />.</param>
      <returns>Formato con una proprietà <see cref="P:System.Buffers.StandardFormat.Symbol" /> uguale a <paramref name="symbol" /> e una proprietà <see cref="P:System.Buffers.StandardFormat.Precision" /> uguale a <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Inequality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
      <summary>Determina se due istanze di <see cref="T:System.Buffers.StandardFormat" /> sono diverse.</summary>
      <param name="left">Primo formato da confrontare.</param>
      <param name="right">Secondo formato da confrontare.</param>
      <returns>
        <see langword="true" /> se i due formati sono diversi. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Parse(System.ReadOnlySpan{System.Char})">
      <summary>Converte un <see langword="ReadOnlySpan&lt;System.Char&gt;" /> in un'istanza di <see cref="T:System.Buffers.StandardFormat" /> con la precisione <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</summary>
      <param name="format">Estensione di sola lettura che contiene il carattere da analizzare.</param>
      <returns>Valore il cui valore della proprietà <see cref="P:System.Buffers.StandardFormat.Symbol" /> è il carattere in <paramref name="format" /> e il cui valore della proprietà <see cref="P:System.Buffers.StandardFormat.Precision" /> è <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Parse(System.String)">
      <summary>Converte una stringa di formato standard .NET classica in un'istanza di <see cref="T:System.Buffers.StandardFormat" />.</summary>
      <param name="format">Stringa di formato standard .NET classica.</param>
      <exception cref="T:System.FormatException">
        <paramref name="format" /> non è una stringa in formato standard valido.</exception>
      <returns>Formato.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.ToString">
      <summary>Restituisce la rappresentazione di stringa di questo formato.</summary>
      <returns>Rappresentazione di stringa di questo formato.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.TryParse(System.ReadOnlySpan{System.Char},System.Buffers.StandardFormat@)">
      <summary>Tenta di convertire un <see langword="ReadOnlySpan&lt;Char&gt;" /> in un'istanza di <see cref="T:System.Buffers.StandardFormat" /> e restituisce un valore che indica se l'operazione di analisi ha avuto esito positivo.</summary>
      <param name="format">Estensione di sola lettura che contiene il carattere da convertire.</param>
      <param name="result">Quando questo metodo termina, contiene l'istanza di <see cref="T:System.Buffers.StandardFormat" /> analizzata se l'operazione è stata completata correttamente.</param>
      <returns>
        <see langword="true" /> se l'operazione di analisi ha avuto esito positivo. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.HasPrecision">
      <summary>Ottiene un valore che indica se un formato ha una precisione definita.</summary>
      <returns>
        <see langword="true" /> Se il formato ha una precisione diversa da <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> ; in caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.IsDefault">
      <summary>Ottiene un valore che indica se l'istanza corrente è un formato predefinito.</summary>
      <returns>
        <see langword="true" /> Se l'istanza corrente è un formato predefinito. in caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.Precision">
      <summary>Ottiene il componente di precisione del formato.</summary>
      <returns>Componente di precisione, che può essere <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> o può variare da 0 a 9.</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.Symbol">
      <summary>Ottiene il componente di carattere del formato.</summary>
      <returns>Componente carattere del formato.</returns>
    </member>
    <member name="T:System.Buffers.Text.Base64">
      <summary>Esegue la conversione tra dati binari e testo con codifica UTF-8 rappresentato in base 64.</summary>
    </member>
    <member name="M:System.Buffers.Text.Base64.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean)">
      <summary>Decodifica in dati binari l'intervallo di testo con codifica UTF-8 rappresentato come base 64. Se l'input non è un multiplo di 4, decodificherà quanto è possibile fino al multiplo di 4 più vicino.</summary>
      <param name="utf8">Intervallo di input che contiene testo con codifica UTF-8 in base 64 che deve essere decodificato.</param>
      <param name="bytes">Intervallo di output che contiene il risultato dell'operazione, vale a dire i dati binari decodificati.</param>
      <param name="bytesConsumed">Numero di byte di input utilizzati durante l'operazione. Può essere usato per sezionare l'input per le chiamate successive, se necessario.</param>
      <param name="bytesWritten">Numero di byte scritti nell'intervallo di output. Può essere usato per sezionare l'output per le chiamate successive, se necessario.</param>
      <param name="isFinalBlock">
        <see langword="true" /> (impostazione predefinita) se l'intervallo di input contiene tutti i dati da decodificare. <see langword="false" /> se l'intervallo di input contiene dati parziali e seguono altri dati.</param>
      <returns>Uno dei valori di enumerazione indicante lo stato dell'operazione di decodifica.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.DecodeFromUtf8InPlace(System.Span{System.Byte},System.Int32@)">
      <summary>Decodifica in dati binari l'intervallo di testo con codifica UTF-8 in base 64 (sul posto). L'output binario decodificato è più piccolo rispetto ai dati di testo contenuti nell'input (l'operazione comprime i dati). Se l'input non è un multiplo di 4, il metodo non decodificherà i dati.</summary>
      <param name="buffer">L'intervallo di input che contiene i dati di testo in base 64 che devono essere decodificati.</param>
      <param name="bytesWritten">Numero di byte scritti nel buffer.</param>
      <returns>Uno dei valori di enumerazione indicante lo stato dell'operazione di decodifica.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.EncodeToUtf8(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean)">
      <summary>Codifica l'intervallo di dati binari in testo con codifica UTF-8 rappresentato come base 64.</summary>
      <param name="bytes">Intervallo di input che contiene i dati binari che devono essere codificati.</param>
      <param name="utf8">Intervallo di output che contiene il risultato dell'operazione, vale a dire il testo con codifica UTF-8 in base 64.</param>
      <param name="bytesConsumed">Numero di byte di input utilizzati durante l'operazione. Può essere usato per sezionare l'input per le chiamate successive, se necessario.</param>
      <param name="bytesWritten">Numero di byte scritti nell'intervallo di output. Può essere usato per sezionare l'output per le chiamate successive, se necessario.</param>
      <param name="isFinalBlock">
        <see langword="true" /> (impostazione predefinita) se l'intervallo di input contiene tutti i dati da codificare. <see langword="false" /> se l'intervallo di input contiene dati parziali e seguono altri dati.</param>
      <returns>Uno dei valori di enumerazione indicante lo stato dell'operazione di codifica.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.EncodeToUtf8InPlace(System.Span{System.Byte},System.Int32,System.Int32@)">
      <summary>Codifica l'intervallo di dati binari (sul posto) in testo con codifica UTF-8 rappresentato come base 64. L'output di testo codificato è più grande rispetto ai dati binari contenuti nell'input (l'operazione incrementa i dati).</summary>
      <param name="buffer">Intervallo di input che contiene i dati binari che devono essere codificati. Poiché il metodo esegue una conversione sul posto, deve essere di dimensioni sufficienti per archiviare il risultato dell'operazione.</param>
      <param name="dataLength">Numero di byte di dati binari contenuti all'interno del buffer che deve essere codificato. Questo valore deve essere minore rispetto alla lunghezza del buffer.</param>
      <param name="bytesWritten">Numero di byte scritti nel buffer.</param>
      <returns>Uno dei valori di enumerazione indicante lo stato dell'operazione di codifica.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.GetMaxDecodedFromUtf8Length(System.Int32)">
      <summary>Restituisce la lunghezza massima (in byte) del risultato, se fosse necessario decodificare il testo con codifica base 64 entro un intervallo di byte con la lunghezza specificata.</summary>
      <param name="length">Dimensioni dell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> è minore di 0.</exception>
      <returns>Lunghezza massima (in byte) del risultato.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.GetMaxEncodedToUtf8Length(System.Int32)">
      <summary>Restituisce la lunghezza massima (in byte) del risultato, se fosse necessario codificare dati binari entro un intervallo di byte con la lunghezza specificata.</summary>
      <param name="length">Dimensioni dell'intervallo di byte.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> è minore di 0 o maggiore di 1610612733 (perché la codifica incrementa i dati di 4/3).</exception>
      <returns>Lunghezza massima (in byte) del risultato.</returns>
    </member>
    <member name="T:System.Buffers.Text.Utf8Formatter">
      <summary>Fornisce metodi statici per formattare i tipi di dati comuni come stringhe Utf8.</summary>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Boolean,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatta un elemento <see cref="T:System.Boolean" /> come stringa UTF8.</summary>
      <param name="value">Valore da formattare.</param>
      <param name="destination">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format">Il formato standard da usare.</param>
      <returns>
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Byte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatta un elemento <see cref="T:System.Byte" /> come stringa UTF8.</summary>
      <param name="value">Valore da formattare.</param>
      <param name="destination">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format">Il formato standard da usare.</param>
      <returns>
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTime,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatta un elemento <see cref="T:System.DateTime" /> come stringa UTF8.</summary>
      <param name="value">Valore da formattare.</param>
      <param name="destination">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format">Il formato standard da usare.</param>
      <returns>
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTimeOffset,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatta un elemento <see cref="T:System.DateTimeOffset" /> come stringa UTF8.</summary>
      <param name="value">Valore da formattare.</param>
      <param name="destination">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format">Il formato standard da usare.</param>
      <returns>
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Decimal,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatta un elemento <see cref="T:System.Decimal" /> come stringa UTF8.</summary>
      <param name="value">Valore da formattare.</param>
      <param name="destination">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format">Il formato standard da usare.</param>
      <returns>
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Double,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatta un elemento <see cref="T:System.Double" /> come stringa UTF8.</summary>
      <param name="value">Valore da formattare.</param>
      <param name="destination">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format">Il formato standard da usare.</param>
      <returns>
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Guid,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatta un elemento <see cref="T:System.Guid" /> come stringa UTF8.</summary>
      <param name="value">Valore da formattare.</param>
      <param name="destination">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format">Il formato standard da usare.</param>
      <returns>
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatta un elemento <see cref="T:System.Int16" /> come stringa UTF8.</summary>
      <param name="value">Valore da formattare.</param>
      <param name="destination">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format">Il formato standard da usare.</param>
      <returns>
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatta un elemento <see cref="T:System.Int32" /> come stringa UTF8.</summary>
      <param name="value">Valore da formattare.</param>
      <param name="destination">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format">Il formato standard da usare.</param>
      <returns>
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatta un elemento <see cref="T:System.Int64" /> come stringa UTF8.</summary>
      <param name="value">Valore da formattare.</param>
      <param name="destination">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format">Il formato standard da usare.</param>
      <returns>
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.SByte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatta un elemento <see cref="T:System.SByte" /> come stringa UTF8.</summary>
      <param name="value">Valore da formattare.</param>
      <param name="destination">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format">Il formato standard da usare.</param>
      <returns>
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Single,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatta un elemento <see cref="T:System.Single" /> come stringa UTF8.</summary>
      <param name="value">Valore da formattare.</param>
      <param name="destination">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format">Il formato standard da usare.</param>
      <returns>
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.TimeSpan,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatta un elemento <see cref="T:System.TimeSpan" /> come stringa UTF8.</summary>
      <param name="value">Valore da formattare.</param>
      <param name="destination">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format">Il formato standard da usare.</param>
      <returns>
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatta un elemento <see cref="T:System.UInt16" /> come stringa UTF8.</summary>
      <param name="value">Valore da formattare.</param>
      <param name="destination">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format">Il formato standard da usare.</param>
      <returns>
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatta un elemento <see cref="T:System.UInt32" /> come stringa UTF8.</summary>
      <param name="value">Valore da formattare.</param>
      <param name="destination">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format">Il formato standard da usare.</param>
      <returns>
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formatta un elemento <see cref="T:System.UInt64" /> come stringa UTF8.</summary>
      <param name="value">Valore da formattare.</param>
      <param name="destination">Buffer in cui scrivere il valore in formato UTF8.</param>
      <param name="bytesWritten">Quando il metodo restituisce un risultato, contiene la lunghezza del testo formattato in byte.</param>
      <param name="format">Il formato standard da usare.</param>
      <returns>
        <see langword="true" /> se l'operazione di formattazione ha esito positivo, <see langword="false" /> se <paramref name="buffer" /> è troppo piccolo.</returns>
    </member>
    <member name="T:System.Buffers.Text.Utf8Parser">
      <summary>Offre metodi statici per analizzare le stringhe UTF8 in tipi di dati comuni.</summary>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Boolean@,System.Int32@,System.Char)">
      <summary>Analizza un elemento <see cref="T:System.Boolean" /> all'inizio di una stringa UTF8.</summary>
      <param name="source">Stringa UTF8 da analizzare.</param>
      <param name="value">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat">Il formato previsto della stringa UTF8.</param>
      <returns>
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Byte@,System.Int32@,System.Char)">
      <summary>Analizza un elemento <see cref="T:System.Byte" /> all'inizio di una stringa UTF8.</summary>
      <param name="source">Stringa UTF8 da analizzare.</param>
      <param name="value">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat">Il formato previsto della stringa UTF8.</param>
      <returns>
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.DateTime@,System.Int32@,System.Char)">
      <summary>Analizza un elemento <see cref="T:System.DateTime" /> all'inizio di una stringa UTF8.</summary>
      <param name="source">Stringa UTF8 da analizzare.</param>
      <param name="value">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat">Il formato previsto della stringa UTF8.</param>
      <returns>
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.DateTimeOffset@,System.Int32@,System.Char)">
      <summary>Analizza un elemento <see cref="T:System.DateTimeOffset" /> all'inizio di una stringa UTF8.</summary>
      <param name="source">Stringa UTF8 da analizzare.</param>
      <param name="value">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat">Il formato previsto della stringa UTF8.</param>
      <returns>
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Decimal@,System.Int32@,System.Char)">
      <summary>Analizza un elemento <see cref="T:System.Decimal" /> all'inizio di una stringa UTF8.</summary>
      <param name="source">Stringa UTF8 da analizzare.</param>
      <param name="value">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat">Il formato previsto della stringa UTF8.</param>
      <returns>
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Double@,System.Int32@,System.Char)">
      <summary>Analizza un elemento <see cref="T:System.Double" /> all'inizio di una stringa UTF8.</summary>
      <param name="source">Stringa UTF8 da analizzare.</param>
      <param name="value">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat">Il formato previsto della stringa UTF8.</param>
      <returns>
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Guid@,System.Int32@,System.Char)">
      <summary>Analizza un elemento <see cref="T:System.Guid" /> all'inizio di una stringa UTF8.</summary>
      <param name="source">Stringa UTF8 da analizzare.</param>
      <param name="value">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat">Il formato previsto della stringa UTF8.</param>
      <returns>
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int16@,System.Int32@,System.Char)">
      <summary>Analizza un elemento <see cref="T:System.Int16" /> all'inizio di una stringa UTF8.</summary>
      <param name="source">Stringa UTF8 da analizzare.</param>
      <param name="value">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat">Il formato previsto della stringa UTF8.</param>
      <returns>
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int32@,System.Int32@,System.Char)">
      <summary>Analizza un elemento <see cref="T:System.Int32" /> all'inizio di una stringa UTF8.</summary>
      <param name="source">Stringa UTF8 da analizzare.</param>
      <param name="value">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat">Il formato previsto della stringa UTF8.</param>
      <returns>
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int64@,System.Int32@,System.Char)">
      <summary>Analizza un elemento <see cref="T:System.Int64" /> all'inizio di una stringa UTF8.</summary>
      <param name="source">Stringa UTF8 da analizzare.</param>
      <param name="value">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat">Il formato previsto della stringa UTF8.</param>
      <returns>
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.SByte@,System.Int32@,System.Char)">
      <summary>Analizza un elemento <see cref="T:System.SByte" /> all'inizio di una stringa UTF8.</summary>
      <param name="source">Stringa UTF8 da analizzare.</param>
      <param name="value">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat">Il formato previsto della stringa UTF8.</param>
      <returns>
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Single@,System.Int32@,System.Char)">
      <summary>Analizza un elemento <see cref="T:System.Single" /> all'inizio di una stringa UTF8.</summary>
      <param name="source">Stringa UTF8 da analizzare.</param>
      <param name="value">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat">Il formato previsto della stringa UTF8.</param>
      <returns>
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.TimeSpan@,System.Int32@,System.Char)">
      <summary>Analizza un elemento <see cref="T:System.TimeSpan" /> all'inizio di una stringa UTF8.</summary>
      <param name="source">Stringa UTF8 da analizzare.</param>
      <param name="value">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat">Il formato previsto della stringa UTF8.</param>
      <returns>
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt16@,System.Int32@,System.Char)">
      <summary>Analizza un elemento <see cref="T:System.UInt16" /> all'inizio di una stringa UTF8.</summary>
      <param name="source">Stringa UTF8 da analizzare.</param>
      <param name="value">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat">Il formato previsto della stringa UTF8.</param>
      <returns>
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt32@,System.Int32@,System.Char)">
      <summary>Analizza un elemento <see cref="T:System.UInt32" /> all'inizio di una stringa UTF8.</summary>
      <param name="source">Stringa UTF8 da analizzare.</param>
      <param name="value">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat">Il formato previsto della stringa UTF8.</param>
      <returns>
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt64@,System.Int32@,System.Char)">
      <summary>Analizza un elemento <see cref="T:System.UInt64" /> all'inizio di una stringa UTF8.</summary>
      <param name="source">Stringa UTF8 da analizzare.</param>
      <param name="value">Quando il metodo restituisce un risultato, contiene il valore analizzato da <paramref name="source" /> se l'operazione di analisi ha avuto esito positivo.</param>
      <param name="bytesConsumed">Se l'operazione di analisi ha esito positivo, contiene la lunghezza in byte della sottostringa analizzata quando il metodo restituisce un risultato. Se il metodo ha esito negativo, <paramref name="bytesConsumed" /> è impostato su 0.</param>
      <param name="standardFormat">Il formato previsto della stringa UTF8.</param>
      <returns>
        <see langword="true" /> per l'esito positivo, <see langword="false" /> se la stringa non è sintatticamente valida oppure si è verificato un overflow o underflow.</returns>
    </member>
    <member name="T:System.MemoryExtensions">
      <summary>Specifica metodi di estensione per i tipi correlati alla memoria e all'intervallo, come ad esempio <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />, <see cref="T:System.Span`1" /> e <see cref="T:System.ReadOnlySpan`1" />.</summary>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String)">
      <summary>Crea un nuovo oggetto <see langword="ReadOnlyMemory&lt;Char&gt;" /> sulla parte della stringa di destinazione.</summary>
      <param name="text">La stringa di destinazione.</param>
      <returns>Rappresentazione in memoria dei caratteri di sola lettura della stringa oppure <see langword="default" /> se <paramref name="text" /> è <see langword="null" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Index)">
      <summary>Crea un nuovo oggetto <see langword="ReadOnlyMemory&lt;Char&gt;" /> sulla parte della stringa di destinazione a partire da un indice specificato.</summary>
      <param name="text">La stringa di destinazione.</param>
      <param name="startIndex">Indice in corrispondenza del quale iniziare la sezione.</param>
      <returns>Rappresentazione in memoria dei caratteri di sola lettura della stringa.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32)">
      <summary>Crea un nuovo oggetto <see langword="ReadOnlyMemory&lt;Char&gt;" /> sulla parte della stringa di destinazione a partire da una posizione di carattere specificata.</summary>
      <param name="text">La stringa di destinazione.</param>
      <param name="start">Indice in corrispondenza del quale iniziare la sezione.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> non è compreso nell'intervallo di <paramref name="text" /> (<paramref name="start" /> è &lt; 0 o &gt; <c>text.Length</c>).</exception>
      <returns>Rappresentazione in memoria dei caratteri di sola lettura della stringa oppure <see langword="default" /> se <paramref name="text" /> è <see langword="null" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32,System.Int32)">
      <summary>Crea un nuovo oggetto <see langword="ReadOnlyMemory&lt;Char&gt;" /> su una parte della stringa di destinazione a partire da una posizione specificata con una lunghezza.</summary>
      <param name="text">La stringa di destinazione.</param>
      <param name="start">Indice in corrispondenza del quale iniziare la sezione.</param>
      <param name="length">Lunghezza desiderata della sezione.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> o <paramref name="start" /> + <paramref name="length" /> non è compreso nell'intervallo di <paramref name="text" />.</exception>
      <returns>Rappresentazione in memoria dei caratteri di sola lettura della stringa oppure <see langword="default" /> se <paramref name="text" /> è <see langword="null" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Range)">
      <summary>Crea un nuovo oggetto <see langword="ReadOnlyMemory&lt;Char&gt;" /> su un intervallo specificato della stringa di destinazione.</summary>
      <param name="text">La stringa di destinazione.</param>
      <param name="range">Intervallo che indica l'inizio e la lunghezza della stringa sezionata.</param>
      <returns>Rappresentazione in memoria dei caratteri di sola lettura della stringa.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[])">
      <summary>Crea una nuova area di memoria sulla matrice di destinazione.</summary>
      <param name="array">Matrice da convertire.</param>
      <typeparam name="T">Tipo della matrice</typeparam>
      <returns>Rappresentazione in memoria di una parte della matrice o della matrice intera.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Index)">
      <summary>Crea una nuova area di memoria sulla parte della matrice di destinazione a partire da un indice specificato fino alla fine della matrice.</summary>
      <param name="array">Matrice da convertire.</param>
      <param name="startIndex">Prima posizione della matrice.</param>
      <typeparam name="T">Tipo della matrice</typeparam>
      <returns>Rappresentazione in memoria di una parte della matrice o della matrice intera.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32)">
      <summary>Crea una nuova area di memoria sulla parte della matrice di destinazione a partire da una posizione specificata fino alla fine della matrice.</summary>
      <param name="array">Matrice di destinazione.</param>
      <param name="start">Indice in corrispondenza del quale iniziare l'area di memoria.</param>
      <typeparam name="T">Tipo della matrice</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="array" /> è covariante e il tipo di matrice non è esattamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Indice <paramref name="start" /> minore di 0 o maggiore di <see langword="array.Length" />.</exception>
      <returns>Rappresentazione in memoria di una parte della matrice o della matrice intera.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32,System.Int32)">
      <summary>Crea una nuova area di memoria sulla parte della matrice di destinazione a partire da una posizione specificata con una lunghezza specificata.</summary>
      <param name="array">Matrice di destinazione.</param>
      <param name="start">Indice in corrispondenza del quale iniziare l'area di memoria.</param>
      <param name="length">Numero di elementi nell'area di memoria.</param>
      <typeparam name="T">Tipo della matrice</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="array" /> è covariante e il tipo di matrice non è esattamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> o <paramref name="start" /> + <paramref name="length" /> non è compreso nell'intervallo di <paramref name="array" />.</exception>
      <returns>Rappresentazione in memoria di una parte della matrice o della matrice intera.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Range)">
      <summary>Crea una nuova area di memoria sulla parte della matrice di destinazione a partire dall'indice di inizio inclusivo dell'intervallo fino all'indice finale esclusivo dell'intervallo.</summary>
      <param name="array">Matrice da convertire.</param>
      <param name="range">Intervallo da convertire dalla matrice.</param>
      <typeparam name="T">Tipo della matrice</typeparam>
      <returns>Rappresentazione in memoria di una parte della matrice o della matrice intera.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0})">
      <summary>Crea una nuova area di memoria sulla parte del segmento della matrice di destinazione.</summary>
      <param name="segment">Segmento da convertire.</param>
      <typeparam name="T">Tipo del segmento.</typeparam>
      <returns>Rappresentazione in memoria del segmento.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32)">
      <summary>Crea una nuova area di memoria sulla parte del segmento della matrice di destinazione a partire da una posizione specificata fino alla fine del segmento.</summary>
      <param name="segment">Segmento della matrice di destinazione.</param>
      <param name="start">Indice in corrispondenza del quale iniziare l'area di memoria.</param>
      <typeparam name="T">Tipo della matrice</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="segment" /> è covariante e il tipo di <paramref name="segment" /> non è esattamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> è minore di 0 o maggiore di <see langword="segment.Count" />.</exception>
      <returns>Rappresentazione in memoria di una parte della matrice o della matrice intera.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32,System.Int32)">
      <summary>Crea una nuova area di memoria sulla parte del segmento della matrice di destinazione a partire da una posizione specificata fino alla lunghezza specificata.</summary>
      <param name="segment">Segmento della matrice di destinazione.</param>
      <param name="start">Indice in corrispondenza del quale iniziare l'area di memoria.</param>
      <param name="length">Numero di elementi nella memoria.</param>
      <typeparam name="T">Tipo della matrice</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="segment" /> è covariante e il tipo di matrice non è esattamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> o <paramref name="start" /> + <paramref name="length" /> non è compreso nell'intervallo di <paramref name="segment" />.</exception>
      <returns>Rappresentazione in memoria di una parte della matrice o della matrice intera.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String)">
      <summary>Crea un nuovo intervallo di sola lettura su una parte della stringa di destinazione da una posizione specificata per un numero di caratteri specificato.</summary>
      <param name="text">La stringa di destinazione.</param>
      <returns>Rappresentazione dell'intervallo di sola lettura della stringa.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32)">
      <summary>Crea un nuovo intervallo di sola lettura su una parte della stringa di destinazione da una posizione specificata fino alla fine della stringa.</summary>
      <param name="text">La stringa di destinazione.</param>
      <param name="start">Indice in corrispondenza del quale iniziare la sezione.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="text" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> è minore di 0 o maggiore di <see langword="text.Length" />.</exception>
      <returns>Rappresentazione dell'intervallo di sola lettura della stringa.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32,System.Int32)">
      <summary>Crea un nuovo intervallo di sola lettura su una stringa.</summary>
      <param name="text">La stringa di destinazione.</param>
      <param name="start">Indice in corrispondenza del quale iniziare la sezione.</param>
      <param name="length">Lunghezza desiderata della sezione.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> o <paramref name="start" /> + <paramref name="length" /> non è compreso nell'intervallo di <paramref name="text" />.</exception>
      <returns>Rappresentazione dell'intervallo di sola lettura della stringa.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[])">
      <summary>Crea un nuovo intervallo su una matrice di destinazione.</summary>
      <param name="array">Matrice da convertire.</param>
      <typeparam name="T">Tipo della matrice</typeparam>
      <returns>Rappresentazione dell'intervallo della matrice.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Index)">
      <summary>Crea un nuovo intervallo sulla parte della matrice di destinazione definita da un valore <see cref="T:System.Index" />.</summary>
      <param name="array">Matrice da convertire.</param>
      <param name="startIndex">Indice iniziale.</param>
      <typeparam name="T">Tipo di matrice.</typeparam>
      <returns>Rappresentazione dell'intervallo della matrice.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32)">
      <summary>Crea un nuovo intervallo su una parte della matrice di destinazione a partire da una posizione specificata fino alla fine della matrice.</summary>
      <param name="array">Matrice da convertire.</param>
      <param name="start">Indice iniziale da cui verrà convertita la matrice.</param>
      <typeparam name="T">Tipo della matrice</typeparam>
      <returns>Rappresentazione dell'intervallo della matrice.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32,System.Int32)">
      <summary>Crea un nuovo intervallo su una parte della matrice di destinazione a partire da una posizione specificata per una lunghezza definita.</summary>
      <param name="array">Matrice di destinazione.</param>
      <param name="start">Indice in corrispondenza del quale iniziare l'intervallo.</param>
      <param name="length">Numero di elementi nell'intervallo.</param>
      <typeparam name="T">Tipo della matrice</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="array" /> è covariante e il tipo di matrice non è esattamente <see langword="T[]" />".</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> o <paramref name="start" /> + <paramref name="length" /> non è compreso nell'intervallo di <paramref name="text" />.</exception>
      <returns>Rappresentazione dell'intervallo della matrice.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Range)">
      <summary>Crea un nuovo intervallo sulla parte della matrice di destinazione definita da un valore <see cref="T:System.Range" />.</summary>
      <param name="array">Matrice da convertire.</param>
      <param name="range">Intervallo della matrice da convertire.</param>
      <typeparam name="T">Tipo della matrice</typeparam>
      <returns>Rappresentazione dell'intervallo della matrice.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0})">
      <summary>Crea un nuovo intervallo su un segmento della matrice di destinazione.</summary>
      <param name="segment">Segmento di matrice da convertire.</param>
      <typeparam name="T">Tipo del segmento di matrice.</typeparam>
      <returns>Rappresentazione dell'intervallo del segmento della matrice.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Index)">
      <summary>Crea un nuovo intervallo su una parte del segmento della matrice di destinazione a partire da un indice specificato fino alla fine del segmento.</summary>
      <param name="segment">Segmento della matrice di destinazione.</param>
      <param name="startIndex">Indice in corrispondenza del quale iniziare l'intervallo.</param>
      <typeparam name="T">Tipo del segmento di matrice.</typeparam>
      <returns>Rappresentazione dell'intervallo del segmento della matrice.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32)">
      <summary>Crea un nuovo intervallo su una parte del segmento della stringa di destinazione da una posizione specificata alla fine del segmento.</summary>
      <param name="segment">Segmento della matrice di destinazione.</param>
      <param name="start">Indice in corrispondenza del quale iniziare l'intervallo.</param>
      <typeparam name="T">Tipo del segmento di matrice.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="segment" /> è covariante e il tipo di matrice non è esattamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> è minore di 0 o maggiore di <see langword="segment.Count" />.</exception>
      <returns>Rappresentazione dell'intervallo del segmento della matrice.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32,System.Int32)">
      <summary>Crea un nuovo intervallo su una parte del segmento della stringa di destinazione da una posizione specificata per una lunghezza definita.</summary>
      <param name="segment">Segmento della matrice di destinazione.</param>
      <param name="start">Indice in corrispondenza del quale iniziare l'intervallo.</param>
      <param name="length">Numero di elementi nell'intervallo.</param>
      <typeparam name="T">Tipo del segmento di matrice.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="segment" /> è covariante e il tipo di matrice non è esattamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> o <paramref name="start" /> + <paramref name="length" /> non è compreso nell'intervallo di <paramref name="segment" />.</exception>
      <returns>Rappresentazione dell'intervallo della matrice.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Range)">
      <summary>Crea un nuovo intervallo su una parte di un segmento della matrice di destinazione usando gli indici di inizio e di fine dell'intervallo.</summary>
      <param name="segment">Segmento della matrice di destinazione.</param>
      <param name="range">Intervallo con indici iniziali e finali da usare per sezionare la matrice.</param>
      <typeparam name="T">Tipo del segmento di matrice.</typeparam>
      <returns>Rappresentazione dell'intervallo del segmento della matrice.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``1(System.ReadOnlySpan{``0},System.IComparable{``0})">
      <summary>Esegue la ricerca di un valore in un'intera matrice <see cref="T:System.ReadOnlySpan`1" /> ordinata usando l'interfaccia generica <see cref="T:System.IComparable`1" /> specificata.</summary>
      <param name="span">Matrice <see cref="T:System.ReadOnlySpan`1" /> ordinata in cui eseguire la ricerca.</param>
      <param name="comparable">Oggetto <see cref="T:System.IComparable`1" /> da usare per i confronti.</param>
      <typeparam name="T">Tipo di elemento dell'intervallo.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> è <see langword="null" />.</exception>
      <returns>Indice in base zero di <paramref name="comparable" /> nell'oggetto <paramref name="span" /> ordinato, se <paramref name="comparable" /> viene trovato; in caso contrario, un numero negativo che rappresenta il complemento bit per bit dell'indice dell'elemento successivo maggiore di <paramref name="comparable" /> o, se non è disponibile alcun elemento maggiore, il complemento bit per bit di <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``1(System.Span{``0},System.IComparable{``0})">
      <summary>Esegue la ricerca di un valore in un'intera matrice <see cref="T:System.Span`1" /> ordinata usando l'interfaccia generica <see cref="T:System.IComparable`1" /> specificata.</summary>
      <param name="span">Matrice <see cref="T:System.Span`1" /> ordinata in cui eseguire la ricerca.</param>
      <param name="comparable">Oggetto <see cref="T:System.IComparable`1" /> da usare per i confronti.</param>
      <typeparam name="T">Tipo di elemento dell'intervallo.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> è <see langword="null" />.</exception>
      <returns>Indice in base zero di <paramref name="comparable" /> nell'oggetto <paramref name="span" /> ordinato, se <paramref name="comparable" /> viene trovato; in caso contrario, un numero negativo che rappresenta il complemento bit per bit dell'indice dell'elemento successivo maggiore di <paramref name="comparable" /> o, se non è disponibile alcun elemento maggiore, il complemento bit per bit di <see cref="P:System.Span`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``0,``1)">
      <summary>Esegue la ricerca di un valore specifico in un'intera matrice <see cref="T:System.ReadOnlySpan`1" /> ordinata usando il tipo generico <typeparamref name="TComparer" /> specificato.</summary>
      <param name="span">Matrice <see cref="T:System.ReadOnlySpan`1" /> ordinata in cui eseguire la ricerca.</param>
      <param name="value">Oggetto da individuare. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
      <param name="comparer">Oggetto <typeparamref name="TComparer" /> da usare per i confronti.</param>
      <typeparam name="T">Tipo di elemento dell'intervallo.</typeparam>
      <typeparam name="TComparer">Tipo specifico di <see cref="T:System.Collections.Generic.IComparer`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparer" /> è <see langword="null" />.</exception>
      <returns>Indice in base zero di <paramref name="value" /> nell'oggetto <paramref name="span" /> ordinato, se <paramref name="value" /> viene trovato; in caso contrario, un numero negativo che rappresenta il complemento bit per bit dell'indice dell'elemento successivo maggiore di <paramref name="value" /> o, se non è disponibile alcun elemento maggiore, il complemento bit per bit di <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``1)">
      <summary>Esegue la ricerca di un valore in un'intera matrice <see cref="T:System.ReadOnlySpan`1" /> ordinata usando il tipo generico <typeparamref name="TComparable" /> specificato.</summary>
      <param name="span">Matrice <see cref="T:System.ReadOnlySpan`1" /> ordinata in cui eseguire la ricerca.</param>
      <param name="comparable">Oggetto <typeparamref name="TComparable" /> da usare per i confronti.</param>
      <typeparam name="T">Tipo di elemento dell'intervallo.</typeparam>
      <typeparam name="TComparable">Tipo specifico di <see cref="T:System.IComparable`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> è <see langword="null" />.</exception>
      <returns>Indice in base zero di <paramref name="comparable" /> nell'oggetto <paramref name="span" /> ordinato, se <paramref name="comparable" /> viene trovato; in caso contrario, un numero negativo che rappresenta il complemento bit per bit dell'indice dell'elemento successivo maggiore di <paramref name="comparable" /> o, se non è disponibile alcun elemento maggiore, il complemento bit per bit di <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``0,``1)">
      <summary>Esegue la ricerca di un valore specifico in un'intera matrice <see cref="T:System.Span`1" /> ordinata usando il tipo generico <typeparamref name="TComparer" /> specificato.</summary>
      <param name="span">Matrice <see cref="T:System.Span`1" /> ordinata in cui eseguire la ricerca.</param>
      <param name="value">Oggetto da individuare. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
      <param name="comparer">Oggetto <typeparamref name="TComparer" /> da usare per i confronti.</param>
      <typeparam name="T">Tipo di elemento dell'intervallo.</typeparam>
      <typeparam name="TComparer">Tipo specifico di <see cref="T:System.Collections.Generic.IComparer`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparer" /> è <see langword="null" />.</exception>
      <returns>Indice in base zero di <paramref name="value" /> nell'oggetto <paramref name="span" /> ordinato, se <paramref name="value" /> viene trovato; in caso contrario, un numero negativo che rappresenta il complemento bit per bit dell'indice dell'elemento successivo maggiore di <paramref name="value" /> o, se non è disponibile alcun elemento maggiore, il complemento bit per bit di <see cref="P:System.Span`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``1)">
      <summary>Esegue la ricerca di un valore in un'intera matrice <see cref="T:System.Span`1" /> ordinata usando il tipo generico <typeparamref name="TComparable" /> specificato.</summary>
      <param name="span">Matrice <see cref="T:System.Span`1" /> ordinata in cui eseguire la ricerca.</param>
      <param name="comparable">Oggetto <typeparamref name="TComparable" /> da usare per i confronti.</param>
      <typeparam name="T">Tipo di elemento dell'intervallo.</typeparam>
      <typeparam name="TComparable">Tipo specifico di <see cref="T:System.IComparable`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> è <see langword="null" />.</exception>
      <returns>Indice in base zero di <paramref name="comparable" /> nell'oggetto <paramref name="span" /> ordinato, se <paramref name="comparable" /> viene trovato; in caso contrario, un numero negativo che rappresenta il complemento bit per bit dell'indice dell'elemento successivo maggiore di <paramref name="comparable" /> o, se non è disponibile alcun elemento maggiore, il complemento bit per bit di <see cref="P:System.Span`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.CompareTo(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Confronta un intervallo di caratteri con un altro usando un confronto di stringhe specificato e restituisce un intero che ne indica la posizione relativa nell'ordinamento.</summary>
      <param name="span">Intervallo di origine.</param>
      <param name="other">Valore da confrontare con l'intervallo di origine.</param>
      <param name="comparisonType">Valore di enumerazione che determina la modalità di confronto tra <paramref name="span" /> e <paramref name="other" />.</param>
      <returns>Intero con segno che indica l'ordine relativo di <paramref name="span" /> e <paramref name="other" />:   - Se minore di 0, <paramref name="span" /> precede <paramref name="other" />.   - Se 0, <paramref name="span" /> è uguale a <paramref name="other" />.   - Se maggiore di 0, <paramref name="span" /> segue <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Indica se un valore specificato è presente all'interno di un intervallo di caratteri di sola lettura.</summary>
      <param name="span">Intervallo di origine.</param>
      <param name="value">Valore da cercare all'interno dell'intervallo di origine.</param>
      <param name="comparisonType">Valore di enumerazione che determina la modalità di confronto dei caratteri tra <paramref name="span" /> e <paramref name="value" />.</param>
      <returns>
        <see langword="true" /> se <paramref name="value" /> è presente all'interno dell'intervallo; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains``1(System.ReadOnlySpan{``0},``0)">
      <summary>Indica se un valore specificato viene trovato in un intervallo di sola lettura. I valori vengono confrontati tramite IEquatable{T}.Equals(T).</summary>
      <param name="span">Intervallo da ricercare.</param>
      <param name="value">Valore da cercare.</param>
      <typeparam name="T">Tipo dell'intervallo.</typeparam>
      <returns>
        <see langword="true" /> se il valore viene trovato; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains``1(System.Span{``0},``0)">
      <summary>Indica se un valore specificato viene trovato in un intervallo. I valori vengono confrontati tramite IEquatable{T}.Equals(T).</summary>
      <param name="span">Intervallo da ricercare.</param>
      <param name="value">Valore da cercare.</param>
      <typeparam name="T">Tipo degli elementi nell'intervallo.</typeparam>
      <returns>
        <see langword="true" /> se il valore viene trovato; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Memory{``0})">
      <summary>Copia il contenuto della matrice in un'area di memoria.</summary>
      <param name="source">Matrice da cui copiare elementi.</param>
      <param name="destination">Memoria in cui copiare elementi.</param>
      <typeparam name="T">Tipo della matrice</typeparam>
      <exception cref="T:System.ArgumentException">La destinazione è più corta della matrice di origine.</exception>
    </member>
    <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Span{``0})">
      <summary>Copia il contenuto della matrice nell'intervallo.</summary>
      <param name="source">Matrice da cui copiare elementi.</param>
      <param name="destination">Intervallo in cui copiare gli elementi.</param>
      <typeparam name="T">Tipo della matrice</typeparam>
      <exception cref="T:System.ArgumentException">L'intervallo di destinazione è più corto della matrice di origine.</exception>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Determina se la fine di <paramref name="span" /> corrisponde al valore di <paramref name="value" /> specificato quando il confronto avviene usando l'opzione <paramref name="comparisonType" /> selezionata.</summary>
      <param name="span">Intervallo di origine.</param>
      <param name="value">Sequenza da confrontare con la fine dell'intervallo di origine.</param>
      <param name="comparisonType">Valore di enumerazione che determina la modalità di confronto tra <paramref name="span" /> e <paramref name="value" />.</param>
      <returns>
        <see langword="true" /> se <paramref name="value" /> corrisponde alla fine di <paramref name="span" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Determina se la sequenza specificata viene visualizzata alla fine di un intervallo di sola lettura.</summary>
      <param name="span">Intervallo di origine.</param>
      <param name="value">Sequenza da confrontare con la fine dell'intervallo di origine.</param>
      <typeparam name="T">Tipo dell'intervallo.</typeparam>
      <returns>
        <see langword="true" /> se <paramref name="value" /> corrisponde alla fine di <paramref name="span" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Determina se la sequenza specificata viene visualizzata alla fine di un intervallo.</summary>
      <param name="span">Intervallo di origine.</param>
      <param name="value">Sequenza da confrontare con la fine dell'intervallo di origine.</param>
      <typeparam name="T">Tipo dell'intervallo.</typeparam>
      <returns>
        <see langword="true" /> se <paramref name="value" /> corrisponde alla fine di <paramref name="span" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EnumerateRunes(System.ReadOnlySpan{System.Char})">
      <summary>Restituisce un'enumerazione di <see cref="T:System.Text.Rune" /> dall'intervallo di sola lettura specificato.</summary>
      <param name="span">Intervallo di origine.</param>
      <returns>Enumeratore di Rune.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EnumerateRunes(System.Span{System.Char})">
      <summary>Restituisce un'enumerazione di <see cref="T:System.Text.Rune" /> dall'intervallo specificato.</summary>
      <param name="span">Intervallo di origine.</param>
      <returns>Enumeratore di Rune.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Equals(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Determina se questo oggetto <paramref name="span" /> e l'intervallo <paramref name="other" /> specificato presentano gli stessi caratteri quando vengono confrontati usando l'opzione <paramref name="comparisonType" /> selezionata.</summary>
      <param name="span">Intervallo di origine.</param>
      <param name="other">Valore da confrontare con l'intervallo di origine.</param>
      <param name="comparisonType">Valore di enumerazione che determina la modalità di confronto tra <paramref name="span" /> e <paramref name="other" />.</param>
      <returns>
        <see langword="true" /> se sono uguali; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Restituisce l'indice in base zero della prima occorrenza dell'oggetto <paramref name="value" /> specificato nell'oggetto <paramref name="span" /> corrente.</summary>
      <param name="span">Intervallo di origine.</param>
      <param name="value">Valore da cercare all'interno dell'intervallo di origine.</param>
      <param name="comparisonType">Valore di enumerazione che determina la modalità di confronto tra <paramref name="span" /> e <paramref name="value" />.</param>
      <returns>Indice dell'occorrenza del valore nell'intervallo.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},``0)">
      <summary>Cerca il valore specificato e restituisce l'indice della prima occorrenza. I valori vengono confrontati tramite IEquatable{T}.Equals(T).</summary>
      <param name="span">Intervallo da ricercare.</param>
      <param name="value">Valore da cercare.</param>
      <typeparam name="T">Tipo di span e value.</typeparam>
      <returns>Indice dell'occorrenza del valore nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Cerca la sequenza specificata e restituisce l'indice della prima occorrenza. I valori vengono confrontati tramite IEquatable{T}.Equals(T).</summary>
      <param name="span">Intervallo da ricercare.</param>
      <param name="value">Sequenza da cercare.</param>
      <typeparam name="T">Tipo di span e value.</typeparam>
      <returns>Indice dell'occorrenza del valore nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},``0)">
      <summary>Cerca il valore specificato e restituisce l'indice della prima occorrenza. I valori vengono confrontati tramite IEquatable{T}.Equals(T).</summary>
      <param name="span">Intervallo da ricercare.</param>
      <param name="value">Valore da cercare.</param>
      <typeparam name="T">Tipo di span e value.</typeparam>
      <returns>Indice dell'occorrenza del valore nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Cerca la sequenza specificata e restituisce l'indice della prima occorrenza. I valori vengono confrontati tramite IEquatable{T}.Equals(T).</summary>
      <param name="span">Intervallo da ricercare.</param>
      <param name="value">Sequenza da cercare.</param>
      <typeparam name="T">Tipo di span e value.</typeparam>
      <returns>Indice dell'occorrenza del valore nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
      <summary>Cerca il primo indice di uno dei valori specificati simile alla chiamata di IndexOf eseguita più volte con l'operatore logico OR.</summary>
      <param name="span">Intervallo da ricercare.</param>
      <param name="value0">Uno dei valori da cercare.</param>
      <param name="value1">Uno dei valori da cercare.</param>
      <typeparam name="T">Tipo dell'intervallo e dei valori.</typeparam>
      <returns>Primo indice dell'occorrenza dei valori nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
      <summary>Cerca il primo indice di uno dei valori specificati simile alla chiamata di IndexOf eseguita più volte con l'operatore logico OR.</summary>
      <param name="span">Intervallo da ricercare.</param>
      <param name="value0">Uno dei valori da cercare.</param>
      <param name="value1">Uno dei valori da cercare.</param>
      <param name="value2">Uno dei valori da cercare.</param>
      <typeparam name="T">Tipo dell'intervallo e dei valori.</typeparam>
      <returns>Primo indice dell'occorrenza dei valori nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Cerca il primo indice di uno dei valori specificati simile alla chiamata di IndexOf eseguita più volte con l'operatore logico OR.</summary>
      <param name="span">Intervallo da ricercare.</param>
      <param name="values">Set di valori da cercare.</param>
      <typeparam name="T">Tipo dell'intervallo e dei valori.</typeparam>
      <returns>Primo indice dell'occorrenza dei valori nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0)">
      <summary>Cerca il primo indice di uno dei valori specificati simile alla chiamata di IndexOf eseguita più volte con l'operatore logico OR.</summary>
      <param name="span">Intervallo da ricercare.</param>
      <param name="value0">Uno dei valori da cercare.</param>
      <param name="value1">Uno dei valori da cercare.</param>
      <typeparam name="T">Tipo dell'intervallo e dei valori.</typeparam>
      <returns>Primo indice dell'occorrenza dei valori nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0,``0)">
      <summary>Cerca il primo indice di uno dei valori specificati simile alla chiamata di IndexOf eseguita più volte con l'operatore logico OR.</summary>
      <param name="span">Intervallo da ricercare.</param>
      <param name="value0">Uno dei valori da cercare.</param>
      <param name="value1">Uno dei valori da cercare.</param>
      <param name="value2">Uno dei valori da cercare.</param>
      <typeparam name="T">Tipo dell'intervallo e dei valori.</typeparam>
      <returns>Primo indice dell'occorrenza dei valori nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Cerca il primo indice di uno dei valori specificati simile alla chiamata di IndexOf eseguita più volte con l'operatore logico OR.</summary>
      <param name="span">Intervallo da ricercare.</param>
      <param name="values">Set di valori da cercare.</param>
      <typeparam name="T">Tipo dell'intervallo e dei valori.</typeparam>
      <returns>Primo indice dell'occorrenza dei valori nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IsWhiteSpace(System.ReadOnlySpan{System.Char})">
      <summary>Indica se l'intervallo specificato contiene solo spazi vuoti.</summary>
      <param name="span">Intervallo di origine.</param>
      <returns>
        <see langword="true" /> se l'intervallo contiene solo spazi vuoti; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Restituisce l'indice in base zero dell'ultima occorrenza dell'oggetto <paramref name="value" /> specificato nell'oggetto <paramref name="span" /> corrente.</summary>
      <param name="span">Intervallo di origine.</param>
      <param name="value">Valore da cercare all'interno dell'intervallo di origine.</param>
      <param name="comparisonType">Valore di enumerazione che determina la modalità di confronto tra <paramref name="span" /> e <paramref name="value" />.</param>
      <returns>Indice dell'ultima occorrenza del valore nell'intervallo.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},``0)">
      <summary>Cerca il valore specificato e restituisce l'indice dell'ultima occorrenza. I valori vengono confrontati tramite IEquatable{T}.Equals(T).</summary>
      <param name="span">Intervallo da ricercare.</param>
      <param name="value">Valore da cercare.</param>
      <typeparam name="T">Tipo di span e value.</typeparam>
      <returns>Indice dell'ultima occorrenza del valore nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Cerca la sequenza specificata e restituisce l'indice dell'ultima occorrenza. I valori vengono confrontati tramite IEquatable{T}.Equals(T).</summary>
      <param name="span">Intervallo da ricercare.</param>
      <param name="value">Sequenza da cercare.</param>
      <typeparam name="T">Tipo di span e value.</typeparam>
      <returns>Indice dell'ultima occorrenza del valore nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},``0)">
      <summary>Cerca il valore specificato e restituisce l'indice dell'ultima occorrenza. I valori vengono confrontati tramite IEquatable{T}.Equals(T).</summary>
      <param name="span">Intervallo da ricercare.</param>
      <param name="value">Valore da cercare.</param>
      <typeparam name="T">Tipo di span e value.</typeparam>
      <returns>Indice dell'ultima occorrenza del valore nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Cerca la sequenza specificata e restituisce l'indice dell'ultima occorrenza. I valori vengono confrontati tramite IEquatable{T}.Equals(T).</summary>
      <param name="span">Intervallo da ricercare.</param>
      <param name="value">Sequenza da cercare.</param>
      <typeparam name="T">Tipo di span e value.</typeparam>
      <returns>Indice dell'ultima occorrenza del valore nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
      <summary>Cerca l'ultimo indice di uno dei valori specificati simile alla chiamata di LastIndexOf eseguita più volte con l'operatore logico OR.</summary>
      <param name="span">Intervallo da ricercare.</param>
      <param name="value0">Uno dei valori da cercare.</param>
      <param name="value1">Uno dei valori da cercare.</param>
      <typeparam name="T">Tipo dell'intervallo e dei valori.</typeparam>
      <returns>Indice dell'ultima occorrenza dei valori nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
      <summary>Cerca l'ultimo indice di uno dei valori specificati simile alla chiamata di LastIndexOf eseguita più volte con l'operatore logico OR.</summary>
      <param name="span">Intervallo da ricercare.</param>
      <param name="value0">Uno dei valori da cercare.</param>
      <param name="value1">Uno dei valori da cercare.</param>
      <param name="value2">Uno dei valori da cercare.</param>
      <typeparam name="T">Tipo dell'intervallo e dei valori.</typeparam>
      <returns>Indice dell'ultima occorrenza dei valori nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Cerca l'ultimo indice di uno dei valori specificati simile alla chiamata di LastIndexOf eseguita più volte con l'operatore logico OR.</summary>
      <param name="span">Intervallo da ricercare.</param>
      <param name="values">Set di valori da cercare.</param>
      <typeparam name="T">Tipo dell'intervallo e dei valori.</typeparam>
      <returns>Indice dell'ultima occorrenza dei valori nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0)">
      <summary>Cerca l'ultimo indice di uno dei valori specificati simile alla chiamata di LastIndexOf eseguita più volte con l'operatore logico OR.</summary>
      <param name="span">Intervallo da ricercare.</param>
      <param name="value0">Uno dei valori da cercare.</param>
      <param name="value1">Uno dei valori da cercare.</param>
      <typeparam name="T">Tipo dell'intervallo e dei valori.</typeparam>
      <returns>Indice dell'ultima occorrenza dei valori nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0,``0)">
      <summary>Cerca l'ultimo indice di uno dei valori specificati simile alla chiamata di LastIndexOf eseguita più volte con l'operatore logico OR.</summary>
      <param name="span">Intervallo da ricercare.</param>
      <param name="value0">Uno dei valori da cercare.</param>
      <param name="value1">Uno dei valori da cercare.</param>
      <param name="value2">Uno dei valori da cercare.</param>
      <typeparam name="T">Tipo dell'intervallo e dei valori.</typeparam>
      <returns>Indice dell'ultima occorrenza dei valori nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Cerca l'ultimo indice di uno dei valori specificati simile alla chiamata di LastIndexOf eseguita più volte con l'operatore logico OR.</summary>
      <param name="span">Intervallo da ricercare.</param>
      <param name="values">Set di valori da cercare.</param>
      <typeparam name="T">Tipo dell'intervallo e dei valori.</typeparam>
      <returns>Indice dell'ultima occorrenza dei valori nell'intervallo. Se non viene trovato, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Determina se due sequenze di sola lettura si sovrappongono in memoria.</summary>
      <param name="span">Prima sequenza.</param>
      <param name="other">Seconda sequenza.</param>
      <typeparam name="T">Tipo di elementi nella sequenza di sola lettura.</typeparam>
      <returns>
        <see langword="true" /> se le due sequenze si sovrappongono; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Int32@)">
      <summary>Determina se due sequenze di sola lettura si sovrappongono in memoria e genera l'offset dell'elemento.</summary>
      <param name="span">Prima sequenza.</param>
      <param name="other">Seconda sequenza.</param>
      <param name="elementOffset">Quando il metodo restituisce un risultato, contiene l'offset compreso tra <paramref name="span" /> e <paramref name="other" />.</param>
      <typeparam name="T">Tipo di elementi nell'intervallo.</typeparam>
      <returns>
        <see langword="true" /> se le due sequenze si sovrappongono; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Determina se un intervallo e un intervallo di sola lettura si sovrappongono in memoria.</summary>
      <param name="span">Intervallo da confrontare.</param>
      <param name="other">Intervallo di sola lettura da confrontare.</param>
      <typeparam name="T">Tipo di elementi nell'intervallo.</typeparam>
      <returns>
        <see langword="true" /> se le due sequenze si sovrappongono; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0},System.Int32@)">
      <summary>Determina se un intervallo e un intervallo di sola lettura si sovrappongono in memoria e genera l'offset dell'elemento.</summary>
      <param name="span">Prima sequenza da confrontare.</param>
      <param name="other">Seconda sequenza da confrontare.</param>
      <param name="elementOffset">Quando il metodo restituisce un risultato, contiene l'offset compreso tra <paramref name="span" /> e <paramref name="other" />.</param>
      <typeparam name="T">Tipo di elementi nell'intervallo.</typeparam>
      <returns>
        <see langword="true" /> se le due sequenze si sovrappongono; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Reverse``1(System.Span{``0})">
      <summary>Inverte la sequenza degli elementi nell'intero intervallo.</summary>
      <param name="span">Intervallo da invertire.</param>
      <typeparam name="T">Tipo di elementi nell'intervallo.</typeparam>
    </member>
    <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Determina l'ordine relativo di due sequenze di sola lettura confrontando i relativi elementi usando IComparable{T}.CompareTo(T).</summary>
      <param name="span">Prima sequenza da confrontare.</param>
      <param name="other">Seconda sequenza da confrontare.</param>
      <typeparam name="T">Tipo di elementi della sequenza.</typeparam>
      <returns>Intero con segno che indica l'ordine relativo di <paramref name="span" /> e <paramref name="other" />:   - Se minore di 0, <paramref name="span" /> precede <paramref name="other" />.   - Se 0, <paramref name="span" /> è uguale a <paramref name="other" />.   - Se maggiore di 0, <paramref name="span" /> segue <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Determina l'ordine relativo di un intervallo e di un intervallo di sola lettura confrontando i relativi elementi usando IComparable{T}.CompareTo(T).</summary>
      <param name="span">Intervallo da confrontare.</param>
      <param name="other">Intervallo di sola lettura da confrontare.</param>
      <typeparam name="T">Tipo di elementi nell'intervallo.</typeparam>
      <returns>Intero con segno che indica l'ordine relativo di <paramref name="span" /> e <paramref name="other" />:   - Se minore di 0, <paramref name="span" /> precede <paramref name="other" />.   - Se 0, <paramref name="span" /> è uguale a <paramref name="other" />.   - Se maggiore di 0, <paramref name="span" /> segue <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceEqual``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Determina se due sequenze di sola lettura sono uguali confrontando gli elementi con IEquatable{T}.Equals(T).</summary>
      <param name="span">Prima sequenza da confrontare.</param>
      <param name="other">Seconda sequenza da confrontare.</param>
      <typeparam name="T">Tipo di elementi della sequenza.</typeparam>
      <returns>
        <see langword="true" /> se le due sequenze sono uguali; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceEqual``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Determina se un intervallo e un intervallo di sola lettura sono uguali confrontando gli elementi con IEquatable{T}.Equals(T).</summary>
      <param name="span">Intervallo da confrontare.</param>
      <param name="other">Intervallo di sola lettura da confrontare.</param>
      <typeparam name="T">Tipo di elementi della sequenza.</typeparam>
      <returns>
        <see langword="true" /> se le due sequenze sono uguali; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Sort``1(System.Span{``0})">
      <summary>Ordina gli elementi dell'intera <see cref="T:System.Span`1" /> usando l'implementazione <see cref="T:System.IComparable`1" /> di ogni elemento dell'oggetto <see cref="T:System.Span`1" /></summary>
      <param name="span">Intervallo di memoria da ordinare.</param>
      <typeparam name="T">Tipo degli elementi dell'intervallo.</typeparam>
      <exception cref="T:System.InvalidOperationException">Uno o più elementi in <paramref name="span" /> non implementano l'interfaccia <see cref="T:System.IComparable`1" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``1(System.Span{``0},System.Comparison{``0})">
      <summary>Ordina gli elementi nell'intera classe <see cref="T:System.Span`1" /> usando l'oggetto <see cref="T:System.Comparison`1" /> specificato.</summary>
      <param name="span">Intervallo di memoria da ordinare.</param>
      <param name="comparison">Metodo da usare quando si confrontano gli elementi.</param>
      <typeparam name="T">Tipo degli elementi dell'intervallo.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparison" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``2(System.Span{``0},``1)">
      <summary>Ordina gli elementi nell'intera <see cref="T:System.Span`1" /> usando <typeparamref name="TComparer" />.</summary>
      <param name="span">Intervallo di memoria da ordinare.</param>
      <param name="comparer">Metodo da usare quando si confrontano gli elementi oppure <see langword="null" /> per usare l'implementazione dell'interfaccia <see cref="T:System.IComparable`1" /> di ogni elemento.</param>
      <typeparam name="T">Tipo degli elementi dell'intervallo.</typeparam>
      <typeparam name="TComparer">Tipo dell'operatore di confronto da utilizzare per confrontare gli elementi.</typeparam>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="comparer" /> è <see langword="null" /> e uno o più elementi in <paramref name="span" /> non implementano l'interfaccia <see cref="T:System.IComparable`1" />.</exception>
      <exception cref="T:System.ArgumentException">L'implementazione di <paramref name="comparer" /> ha causato un errore durante l'ordinamento.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``2(System.Span{``0},System.Span{``1})">
      <summary>Ordina una coppia di intervalli (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi del primo oggetto <see cref="T:System.Span`1" /> usando l'implementazione di <see cref="T:System.IComparable`1" /> di ogni chiave.</summary>
      <param name="keys">Intervallo che contiene le chiavi da ordinare.</param>
      <param name="items">Intervallo che contiene gli elementi corrispondenti alle chiavi in <paramref name="keys" />.</param>
      <typeparam name="TKey">Tipo degli elementi dell'intervallo di chiavi.</typeparam>
      <typeparam name="TValue">Tipo degli elementi dell'intervallo di elementi.</typeparam>
      <exception cref="T:System.ArgumentException">La lunghezza di <paramref name="keys" /> non è uguale alla lunghezza di <paramref name="items" />.</exception>
      <exception cref="T:System.InvalidOperationException">Uno o più elementi in <paramref name="keys" /> non implementano l'interfaccia <see cref="T:System.IComparable`1" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``2(System.Span{``0},System.Span{``1},System.Comparison{``0})">
      <summary>Ordina una coppia di intervalli (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi del primo oggetto <see cref="T:System.Span`1" /> usando il confronto specificato.</summary>
      <param name="keys">Intervallo che contiene le chiavi da ordinare.</param>
      <param name="items">Intervallo che contiene gli elementi corrispondenti alle chiavi in <paramref name="keys" />.</param>
      <param name="comparison">Oggetto <see cref="T:System.Comparison`1" /> da usare quando si confrontano gli elementi.</param>
      <typeparam name="TKey">Tipo degli elementi dell'intervallo di chiavi.</typeparam>
      <typeparam name="TValue">Tipo degli elementi dell'intervallo di elementi.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparison" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La lunghezza di <paramref name="keys" /> non è uguale alla lunghezza di <paramref name="items" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``3(System.Span{``0},System.Span{``1},``2)">
      <summary>Ordina una coppia di intervalli (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi del primo oggetto <see cref="T:System.Span`1" /> usando l'operatore di confronto specificato.</summary>
      <param name="keys">Intervallo che contiene le chiavi da ordinare.</param>
      <param name="items">Intervallo che contiene gli elementi corrispondenti alle chiavi in <paramref name="keys" />.</param>
      <param name="comparer">Implementazione di <see cref="T:System.Collections.Generic.IComparer`1" /> da usare per il confronto tra gli elementi oppure <see langword="null" /> per usare l'implementazione dell'interfaccia <see cref="T:System.IComparable`1" /> di ogni elemento.</param>
      <typeparam name="TKey">Tipo degli elementi dell'intervallo di chiavi.</typeparam>
      <typeparam name="TValue">Tipo degli elementi dell'intervallo di elementi.</typeparam>
      <typeparam name="TComparer">Tipo dell'operatore di confronto da utilizzare per confrontare gli elementi.</typeparam>
      <exception cref="T:System.ArgumentException">La lunghezza di <paramref name="keys" /> non è uguale alla lunghezza di <paramref name="items" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="comparer" /> è <see langword="null" /> e uno o più elementi in <paramref name="keys" /> non implementano l'interfaccia <see cref="T:System.IComparable`1" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Determina se un intervallo di caratteri di sola lettura inizia con un valore specificato quando viene confrontato con un valore <see cref="T:System.StringComparison" /> specifico.</summary>
      <param name="span">Intervallo di origine.</param>
      <param name="value">Sequenza da confrontare con l'inizio dell'intervallo di origine.</param>
      <param name="comparisonType">Valore di enumerazione che determina la modalità di confronto tra <paramref name="span" /> e <paramref name="value" />.</param>
      <returns>
        <see langword="true" /> se <paramref name="value" /> corrisponde all'inizio di <paramref name="span" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Determina se una sequenza specificata viene visualizzata all'inizio di un intervallo di sola lettura.</summary>
      <param name="span">Intervallo di caratteri di sola lettura in cui eseguire la ricerca.</param>
      <param name="value">Sequenza da cercare all'inizio di <paramref name="span" />.</param>
      <typeparam name="T">Tipo di elementi nell'intervallo.</typeparam>
      <returns>
        <see langword="true" /> se <paramref name="value" /> corrisponde all'inizio di <paramref name="span" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Determina se una sequenza specificata viene visualizzata all'inizio di un intervallo.</summary>
      <param name="span">Intervallo da ricercare.</param>
      <param name="value">Sequenza da cercare all'inizio di <paramref name="span" />.</param>
      <typeparam name="T">Tipo degli elementi nell'intervallo.</typeparam>
      <returns>
        <see langword="true" /> se <paramref name="value" /> corrisponde all'inizio di <paramref name="span" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToLower(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
      <summary>Copia i caratteri dall'intervallo di origine alla destinazione, convertendo ogni carattere in minuscolo, usando le regole di distinzione tra maiuscola e minuscola delle impostazioni cultura specificate.</summary>
      <param name="source">Intervallo di origine.</param>
      <param name="destination">Intervallo di destinazione che contiene i caratteri trasformati.</param>
      <param name="culture">Oggetto che fornisce le regole specifiche delle impostazioni cultura sull'uso di maiuscole e minuscole.</param>
      <exception cref="T:System.InvalidOperationException">I buffer di origine e di destinazione si sovrappongono.</exception>
      <returns>Numero di caratteri scritti nell'intervallo di destinazione. Se la destinazione è troppo piccola, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToLowerInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
      <summary>Copia i caratteri dall'intervallo di origine alla destinazione, convertendo ogni carattere in minuscolo, usando le regole di distinzione tra maiuscola e minuscola delle impostazioni cultura inglese non dipendenti da paese/area geografica.</summary>
      <param name="source">Intervallo di origine.</param>
      <param name="destination">Intervallo di destinazione che contiene i caratteri trasformati.</param>
      <exception cref="T:System.InvalidOperationException">I buffer di origine e di destinazione si sovrappongono.</exception>
      <returns>Numero di caratteri scritti nell'intervallo di destinazione. Se la destinazione è troppo piccola, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToUpper(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
      <summary>Copia i caratteri dall'intervallo di origine alla destinazione, convertendo ogni carattere in maiuscolo, usando le regole di distinzione tra maiuscola e minuscola delle impostazioni cultura specificate.</summary>
      <param name="source">Intervallo di origine.</param>
      <param name="destination">Intervallo di destinazione che contiene i caratteri trasformati.</param>
      <param name="culture">Oggetto che fornisce le regole specifiche delle impostazioni cultura sull'uso di maiuscole e minuscole.</param>
      <exception cref="T:System.InvalidOperationException">I buffer di origine e di destinazione si sovrappongono.</exception>
      <returns>Numero di caratteri scritti nell'intervallo di destinazione. Se la destinazione è troppo piccola, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToUpperInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
      <summary>Copia i caratteri dall'intervallo di origine alla destinazione, convertendo ogni carattere in maiuscolo, usando le regole di distinzione tra maiuscola e minuscola delle impostazioni cultura inglese non dipendenti da paese/area geografica.</summary>
      <param name="source">Intervallo di origine.</param>
      <param name="destination">Intervallo di destinazione che contiene i caratteri trasformati.</param>
      <exception cref="T:System.InvalidOperationException">I buffer di origine e di destinazione si sovrappongono.</exception>
      <returns>Numero di caratteri scritti nell'intervallo di destinazione. Se la destinazione è troppo piccola, restituisce -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.Memory{System.Char})">
      <summary>Rimuove tutti gli spazi vuoti iniziali e finali da un'area di memoria dei caratteri.</summary>
      <param name="memory">Memoria di origine da cui vengono rimossi i caratteri.</param>
      <returns>Area di memoria da cui vengono ritagliati i caratteri.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlyMemory{System.Char})">
      <summary>Rimuove tutti gli spazi vuoti iniziali e finali da un'area di memoria dei caratteri di sola lettura.</summary>
      <param name="memory">Memoria di origine da cui vengono rimossi i caratteri.</param>
      <returns>Area di memoria da cui vengono ritagliati i caratteri.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char})">
      <summary>Rimuove tutti gli spazi vuoti iniziali e finali da un intervallo di caratteri di sola lettura.</summary>
      <param name="span">Intervallo di origine da cui vengono rimossi i caratteri.</param>
      <returns>Intervallo di caratteri di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.Char)">
      <summary>Rimuove tutte le occorrenze iniziali e finali da un carattere specificato da un intervallo di caratteri di sola lettura.</summary>
      <param name="span">Intervallo di origine da cui viene rimosso il carattere.</param>
      <param name="trimChar">Carattere specificato da cercare e rimuovere.</param>
      <returns>Intervallo di caratteri di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>Rimuove tutte le occorrenze iniziali e finali di un set di caratteri specificato in un intervallo di sola lettura da un intervallo di caratteri di sola lettura.</summary>
      <param name="span">Intervallo di origine da cui vengono rimossi i caratteri.</param>
      <param name="trimChars">Intervallo contenente il set di caratteri da rimuovere.</param>
      <returns>Intervallo di caratteri di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.Span{System.Char})">
      <summary>Rimuove tutti gli spazi vuoti iniziali e finali da un intervallo di caratteri.</summary>
      <param name="span">Intervallo di origine da cui vengono rimossi i caratteri.</param>
      <returns>Intervallo di caratteri ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Memory{``0},``0)">
      <summary>Rimuove tutte le occorrenze iniziali e finali di un elemento specificato da un'area di memoria.</summary>
      <param name="memory">Memoria di origine da cui viene rimosso l'elemento.</param>
      <param name="trimElement">Elemento specificato da cercare e rimuovere.</param>
      <typeparam name="T">Tipo degli elementi nell'area di memoria.</typeparam>
      <returns>Area di memoria ritagliata.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary>Rimuove tutte le occorrenze iniziali e finali di un set di elementi specificato in un intervallo di sola lettura da un'area di memoria.</summary>
      <param name="memory">Memoria di origine da cui vengono rimossi gli elementi.</param>
      <param name="trimElements">Intervallo contenente il set di elementi da rimuovere.</param>
      <typeparam name="T">Tipo degli elementi nell'area di memoria.</typeparam>
      <returns>Area di memoria ritagliata.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},``0)">
      <summary>Rimuove tutte le occorrenze iniziali e finali di un elemento specificato da un'area di memoria di sola lettura.</summary>
      <param name="memory">Memoria di origine da cui viene rimosso l'elemento.</param>
      <param name="trimElement">Elemento specificato da cercare e rimuovere.</param>
      <typeparam name="T">Tipo degli elementi nell'area di memoria di sola lettura.</typeparam>
      <returns>Area di memoria di sola lettura ritagliata.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary>Rimuove tutte le occorrenze iniziali e finali di un set di elementi specificato in un intervallo di sola lettura da un'area di memoria di sola lettura.</summary>
      <param name="memory">Memoria di origine da cui vengono rimossi gli elementi.</param>
      <param name="trimElements">Intervallo contenente il set di elementi da rimuovere.</param>
      <typeparam name="T">Tipo degli elementi nell'area di memoria di sola lettura.</typeparam>
      <returns>Area di memoria di sola lettura ritagliata.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},``0)">
      <summary>Rimuove tutte le occorrenze iniziali e finali di un elemento specificato da un intervallo di sola lettura.</summary>
      <param name="span">Intervallo di origine da cui viene rimosso l'elemento.</param>
      <param name="trimElement">Elemento specificato da cercare e rimuovere.</param>
      <typeparam name="T">Tipo degli elementi nell'intervallo di sola lettura.</typeparam>
      <returns>Intervallo di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Rimuove tutte le occorrenze iniziali e finali di un set di elementi specificato in un intervallo di sola lettura da un intervallo di sola lettura.</summary>
      <param name="span">Intervallo di origine da cui vengono rimossi gli elementi.</param>
      <param name="trimElements">Intervallo contenente il set di elementi da rimuovere.</param>
      <typeparam name="T">Tipo degli elementi nell'intervallo di sola lettura.</typeparam>
      <returns>Intervallo di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Span{``0},``0)">
      <summary>Rimuove tutte le occorrenze iniziali e finali di un elemento specificato da un intervallo.</summary>
      <param name="span">Intervallo di origine da cui viene rimosso l'elemento.</param>
      <param name="trimElement">Elemento specificato da cercare e rimuovere.</param>
      <typeparam name="T">Tipo degli elementi nell'intervallo.</typeparam>
      <returns>Intervallo ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Rimuove tutte le occorrenze iniziali e finali di un set di elementi specificato in un intervallo di sola lettura da un intervallo.</summary>
      <param name="span">Intervallo di origine da cui vengono rimossi gli elementi.</param>
      <param name="trimElements">Intervallo contenente il set di elementi da rimuovere.</param>
      <typeparam name="T">Tipo degli elementi nell'intervallo.</typeparam>
      <returns>Intervallo ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.Memory{System.Char})">
      <summary>Rimuove tutti gli spazi vuoti finali da un'area di memoria dei caratteri.</summary>
      <param name="memory">Memoria di origine da cui vengono rimossi i caratteri.</param>
      <returns>Area di memoria da cui vengono ritagliati i caratteri.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlyMemory{System.Char})">
      <summary>Rimuove tutti gli spazi vuoti finali da un'area di memoria dei caratteri di sola lettura.</summary>
      <param name="memory">Memoria di origine da cui vengono rimossi i caratteri.</param>
      <returns>Intervallo di caratteri di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char})">
      <summary>Rimuove tutti gli spazi vuoti finali da un intervallo di caratteri di sola lettura.</summary>
      <param name="span">Intervallo di origine da cui vengono rimossi i caratteri.</param>
      <returns>Intervallo di caratteri di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.Char)">
      <summary>Rimuove tutte le occorrenze finali da un carattere specificato da un intervallo di sola lettura.</summary>
      <param name="span">Intervallo di origine da cui viene rimosso il carattere.</param>
      <param name="trimChar">Carattere specificato da cercare e rimuovere.</param>
      <returns>Intervallo di caratteri di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>Rimuove tutte le occorrenze finali di un set di caratteri specificato in un intervallo di sola lettura da un intervallo di caratteri di sola lettura.</summary>
      <param name="span">Intervallo di origine da cui vengono rimossi i caratteri.</param>
      <param name="trimChars">Intervallo contenente il set di caratteri da rimuovere.</param>
      <returns>Intervallo di caratteri di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.Span{System.Char})">
      <summary>Rimuove tutti gli spazi vuoti finali da un intervallo di caratteri.</summary>
      <param name="span">Intervallo di origine da cui vengono rimossi i caratteri.</param>
      <returns>Intervallo di caratteri ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},``0)">
      <summary>Rimuove tutte le occorrenze finali di un elemento specificato da un'area di memoria dei caratteri.</summary>
      <param name="memory">Memoria di origine da cui viene rimosso l'elemento.</param>
      <param name="trimElement">Elemento specificato da cercare e rimuovere.</param>
      <typeparam name="T">Tipo degli elementi nell'area di memoria.</typeparam>
      <returns>Area di memoria ritagliata.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary>Rimuove tutte le occorrenze finali di un set di elementi specificato in un intervallo di sola lettura da un'area di memoria.</summary>
      <param name="memory">Memoria di origine da cui vengono rimossi gli elementi.</param>
      <param name="trimElements">Intervallo contenente il set di elementi da rimuovere.</param>
      <typeparam name="T">Tipo degli elementi nell'area di memoria.</typeparam>
      <returns>Area di memoria ritagliata.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},``0)">
      <summary>Rimuove tutte le occorrenze finali di un elemento specificato da un'area di memoria di sola lettura.</summary>
      <param name="memory">Memoria di origine da cui viene rimosso l'elemento.</param>
      <param name="trimElement">Elemento specificato da cercare e rimuovere.</param>
      <typeparam name="T">Tipo degli elementi nell'area di memoria di sola lettura.</typeparam>
      <returns>Area di memoria di sola lettura ritagliata.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary>Rimuove tutte le occorrenze finali di un set di elementi specificato in un intervallo di sola lettura da un'area di memoria di sola lettura.</summary>
      <param name="memory">Memoria di origine da cui vengono rimossi gli elementi.</param>
      <param name="trimElements">Intervallo contenente il set di elementi da rimuovere.</param>
      <typeparam name="T">Tipo degli elementi nell'area di memoria di sola lettura.</typeparam>
      <returns>Area di memoria di sola lettura ritagliata.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},``0)">
      <summary>Rimuove tutte le occorrenze finali di un elemento specificato da un intervallo di sola lettura.</summary>
      <param name="span">Intervallo di origine da cui viene rimosso l'elemento.</param>
      <param name="trimElement">Elemento specificato da cercare e rimuovere.</param>
      <typeparam name="T">Tipo degli elementi nell'intervallo di sola lettura.</typeparam>
      <returns>Intervallo di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Rimuove tutte le occorrenze finali di un set di elementi specificato in un intervallo di sola lettura da un intervallo di sola lettura.</summary>
      <param name="span">Intervallo di origine da cui vengono rimossi gli elementi.</param>
      <param name="trimElements">Intervallo contenente il set di elementi da rimuovere.</param>
      <typeparam name="T">Tipo degli elementi nell'intervallo di sola lettura.</typeparam>
      <returns>Intervallo di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},``0)">
      <summary>Rimuove tutte le occorrenze finali di un elemento specificato da un intervallo.</summary>
      <param name="span">Intervallo di origine da cui viene rimosso l'elemento.</param>
      <param name="trimElement">Elemento specificato da cercare e rimuovere.</param>
      <typeparam name="T">Tipo degli elementi nell'intervallo.</typeparam>
      <returns>Intervallo ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Rimuove tutte le occorrenze finali di un set di elementi specificato in un intervallo di sola lettura da un intervallo.</summary>
      <param name="span">Intervallo di origine da cui vengono rimossi gli elementi.</param>
      <param name="trimElements">Intervallo contenente il set di elementi da rimuovere.</param>
      <typeparam name="T">Tipo degli elementi nell'intervallo.</typeparam>
      <returns>Intervallo ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.Memory{System.Char})">
      <summary>Rimuove tutti gli spazi vuoti iniziali da un'area di memoria.</summary>
      <param name="memory">Memoria di origine da cui vengono rimossi i caratteri.</param>
      <returns>Area di memoria da cui vengono ritagliati i caratteri.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlyMemory{System.Char})">
      <summary>Rimuove tutti gli spazi vuoti iniziali da un'area di memoria di sola lettura.</summary>
      <param name="memory">Memoria di origine da cui vengono rimossi i caratteri.</param>
      <returns>Area di memoria di sola lettura da cui vengono ritagliati i caratteri.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char})">
      <summary>Rimuove tutti gli spazi vuoti iniziali da un intervallo di sola lettura.</summary>
      <param name="span">Intervallo di origine da cui vengono rimossi i caratteri.</param>
      <returns>Intervallo di caratteri di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.Char)">
      <summary>Rimuove tutte le occorrenze iniziali di un carattere specificato dall'intervallo.</summary>
      <param name="span">Intervallo di origine da cui viene rimosso il carattere.</param>
      <param name="trimChar">Carattere specificato da cercare e rimuovere.</param>
      <returns>Intervallo di caratteri di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>Rimuove tutte le occorrenze iniziali di un set di caratteri specificato in un intervallo di sola lettura dall'intervallo.</summary>
      <param name="span">Intervallo di origine da cui vengono rimossi i caratteri.</param>
      <param name="trimChars">Intervallo contenente il set di caratteri da rimuovere.</param>
      <returns>Intervallo di caratteri di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.Span{System.Char})">
      <summary>Rimuove tutti gli spazi vuoti iniziali da un intervallo.</summary>
      <param name="span">Intervallo di origine da cui vengono rimossi i caratteri.</param>
      <returns>Intervallo di caratteri ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},``0)">
      <summary>Rimuove tutte le occorrenze iniziali di un elemento specificato da un'area di memoria.</summary>
      <param name="memory">Area di memoria di origine da cui viene rimosso l'elemento.</param>
      <param name="trimElement">Elemento specificato da cercare e rimuovere.</param>
      <typeparam name="T">Tipo degli elementi nell'area di memoria.</typeparam>
      <returns>Area di memoria ritagliata.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary>Rimuove tutte le occorrenze iniziali di un set di elementi specificato in un intervallo di sola lettura da un'area di memoria.</summary>
      <param name="memory">Memoria di origine da cui vengono rimossi gli elementi.</param>
      <param name="trimElements">Intervallo contenente il set di elementi da rimuovere.</param>
      <typeparam name="T">Tipo degli elementi nell'area di memoria.</typeparam>
      <returns>Area di memoria ritagliata.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},``0)">
      <summary>Rimuove tutte le occorrenze iniziali di un elemento specificato da un'area di memoria.</summary>
      <param name="memory">Memoria di origine da cui viene rimosso l'elemento.</param>
      <param name="trimElement">Elemento specificato da cercare e rimuovere.</param>
      <typeparam name="T">Tipo degli elementi nell'area di memoria di sola lettura.</typeparam>
      <returns>Area di memoria di sola lettura ritagliata.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary>Rimuove tutte le occorrenze iniziali di un set di elementi specificato in un intervallo di sola lettura da un'area di memoria.</summary>
      <param name="memory">Memoria di origine da cui vengono rimossi gli elementi.</param>
      <param name="trimElements">Intervallo contenente il set di elementi da rimuovere.</param>
      <typeparam name="T">Tipo degli elementi nell'area di memoria di sola lettura.</typeparam>
      <returns>Area di memoria di sola lettura ritagliata.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},``0)">
      <summary>Rimuove tutte le occorrenze iniziali di un elemento specificato da un intervallo.</summary>
      <param name="span">Intervallo di origine da cui viene rimosso l'elemento.</param>
      <param name="trimElement">Elemento specificato da cercare e rimuovere.</param>
      <typeparam name="T">Tipo degli elementi nell'intervallo di sola lettura.</typeparam>
      <returns>Intervallo di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Rimuove tutte le occorrenze iniziali di un set di elementi specificato in un intervallo di sola lettura da un intervallo.</summary>
      <param name="span">Intervallo di origine da cui vengono rimossi gli elementi.</param>
      <param name="trimElements">Intervallo contenente il set di elementi da rimuovere.</param>
      <typeparam name="T">Tipo degli elementi nell'intervallo di sola lettura.</typeparam>
      <returns>Intervallo di sola lettura ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},``0)">
      <summary>Rimuove tutte le occorrenze iniziali di un elemento specificato da un intervallo.</summary>
      <param name="span">Intervallo di origine da cui viene rimosso l'elemento.</param>
      <param name="trimElement">Elemento specificato da cercare e rimuovere.</param>
      <typeparam name="T">Tipo degli elementi nell'intervallo.</typeparam>
      <returns>Intervallo ritagliato.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Rimuove tutte le occorrenze iniziali di un set di elementi specificato in un intervallo di sola lettura da un intervallo.</summary>
      <param name="span">Intervallo di origine da cui vengono rimossi gli elementi.</param>
      <param name="trimElements">Intervallo contenente il set di elementi da rimuovere.</param>
      <typeparam name="T">Tipo degli elementi nell'intervallo.</typeparam>
      <returns>Intervallo ritagliato.</returns>
    </member>
    <member name="T:System.Runtime.InteropServices.MemoryMarshal">
      <summary>Fornisce metodi per l'interoperabilità con <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />, <see cref="T:System.Span`1" /> e <see cref="T:System.ReadOnlySpan`1" />.</summary>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.ReadOnlySpan{``0})">
      <summary>Esegue il cast di un oggetto <see cref="T:System.ReadOnlySpan`1" /> di un tipo primitivo, <paramref name="T" />, in un oggetto <see langword="ReadOnlySpan&lt;Byte&gt;" />.</summary>
      <param name="span">Sezione di origine da convertire.</param>
      <typeparam name="T">Tipo di elementi nell'intervallo di sola lettura.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> contiene riferimenti o puntatori.</exception>
      <exception cref="T:System.OverflowException">La proprietà <see cref="P:System.ReadOnlySpan`1.Length" /> del nuovo oggetto <see cref="T:System.ReadOnlySpan`1" /> supererebbe <see cref="F:System.Int32.MaxValue" /></exception>
      <returns>Intervallo di sola lettura di tipo <see cref="T:System.Byte" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.Span{``0})">
      <summary>Esegue il cast di un oggetto <see cref="T:System.Span`1" /> di un tipo primitivo, <paramref name="T" />, in un oggetto <see langword="Span&lt;Byte&gt;" />.</summary>
      <param name="span">Sezione di origine da convertire.</param>
      <typeparam name="T">Tipo di elementi nell'intervallo.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> contiene riferimenti o puntatori.</exception>
      <exception cref="T:System.OverflowException">La proprietà <see cref="P:System.Span`1.Length" /> del nuovo oggetto <see cref="T:System.Span`1" /> supererebbe <see cref="F:System.Int32.MaxValue" /></exception>
      <returns>Intervallo di tipo <see cref="T:System.Byte" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsMemory``1(System.ReadOnlyMemory{``0})">
      <summary>Crea un'istanza di <see cref="T:System.Memory`1" /> da un oggetto <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <param name="memory">Buffer di memoria di sola lettura.</param>
      <typeparam name="T">Tipo di elementi nel buffer di memoria di sola lettura.</typeparam>
      <returns>Blocco di memoria che rappresenta la stessa memoria di <see cref="T:System.ReadOnlyMemory`1" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.ReadOnlySpan{System.Byte})">
      <summary>Reinterpreta un intervallo di sola lettura di byte come riferimento di sola lettura per la struttura di tipo <paramref name="T" />.</summary>
      <param name="span">Intervallo di sola lettura da reinterpretare.</param>
      <typeparam name="T">Tipo del riferimento restituito.</typeparam>
      <returns>Il riferimento di sola lettura per la struttura di tipo <paramref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.Span{System.Byte})">
      <summary>Reinterpreta un intervallo di byte come riferimento per la struttura di tipo <paramref name="T" />.</summary>
      <param name="span">Intervallo da reinterpretare.</param>
      <typeparam name="T">Tipo del riferimento restituito.</typeparam>
      <returns>Riferimento per la struttura di tipo <paramref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.ReadOnlySpan{``0})">
      <summary>Esegue il cast di un intervallo di sola lettura di un tipo primitivo in un intervallo di sola lettura di un altro tipo primitivo.</summary>
      <param name="span">Sezione di origine da convertire.</param>
      <typeparam name="TFrom">Tipo dell'intervallo di origine.</typeparam>
      <typeparam name="TTo">Tipo dell'intervallo di destinazione.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="TFrom" /> o <paramref name="TTo" /> contiene riferimenti o puntatori.</exception>
      <returns>Intervallo di sola lettura convertito.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.Span{``0})">
      <summary>Esegue il cast di un intervallo di un tipo primitivo in un intervallo di un altro tipo primitivo.</summary>
      <param name="span">Sezione di origine da convertire.</param>
      <typeparam name="TFrom">Tipo dell'intervallo di origine.</typeparam>
      <typeparam name="TTo">Tipo dell'intervallo di destinazione.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="TFrom" /> o <paramref name="TTo" /> contiene riferimenti o puntatori.</exception>
      <returns>Intervallo convertito.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateFromPinnedArray``1(``0[],System.Int32,System.Int32)">
      <summary>Crea un nuovo buffer di memoria sulla parte della matrice di destinazione già bloccata che inizia in corrispondenza dell'indice <paramref name="start" /> ed è costituita da elementi <paramref name="length" />.</summary>
      <param name="array">Matrice di origine già bloccata.</param>
      <param name="start">Indice di <paramref name="array" /> da cui iniziare il blocco di memoria.</param>
      <param name="length">Numero di elementi da includere nel blocco di memoria.</param>
      <typeparam name="T">Tipo della matrice</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="array" /> è covariante e il tipo di <paramref name="array" /> non è esattamente <paramref name="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> o l'indice finale non è compreso nell'intervallo tra 0 e <see cref="P:System.Array.Length" />.</exception>
      <returns>Blocco di memoria sugli elementi specificati di <paramref name="array" />. Se <paramref name="array" /> è <see langword="null" /> o se <paramref name="start" /> e <paramref name="length" /> sono 0, il metodo restituisce un'istanza <see cref="T:System.Memory`1" /> di zero <see cref="P:System.Memory`1.Length" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan``1(``0@,System.Int32)">
      <summary>Crea un nuovo intervallo di sola lettura su una parte di un normale oggetto gestito.</summary>
      <param name="reference">Riferimento ai dati.</param>
      <param name="length">Numero di elementi <paramref name="T" /> contenuti in <paramref name="reference" />.</param>
      <typeparam name="T">Tipo di elementi di dati.</typeparam>
      <returns>Intervallo di sola lettura.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateSpan``1(``0@,System.Int32)">
      <summary>Crea un nuovo intervallo su una parte di un normale oggetto gestito.</summary>
      <param name="reference">Riferimento ai dati.</param>
      <param name="length">Numero di elementi <paramref name="T" /> contenuti in <paramref name="reference" />.</param>
      <typeparam name="T">Tipo di elementi di dati.</typeparam>
      <returns>Intervallo.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetArrayDataReference``1(``0[])">
      <summary>Restituisce un riferimento allo 0-esimo elemento di <paramref name="array" />. Se la matrice è vuota, restituisce un riferimento alla posizione in cui sarebbe stato archiviato lo 0-esimo elemento. Un riferimento di questo tipo può essere usato per il blocco, ma non deve mai essere dereferenziato.</summary>
      <param name="array">Matrice da analizzare.</param>
      <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
      <exception cref="T:System.NullReferenceException">
        <paramref name="array" /> è <see langword="null" />.</exception>
      <returns>Riferimento all'elemento 0th in <paramref name="array" /></returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.ReadOnlySpan{``0})">
      <summary>Restituisce un riferimento all'elemento dell'intervallo di sola lettura in corrispondenza dell'indice 0.</summary>
      <param name="span">Intervallo di sola lettura da cui viene recuperato il riferimento.</param>
      <typeparam name="T">Tipo di elementi nell'intervallo.</typeparam>
      <returns>Riferimento all'elemento in corrispondenza dell'indice 0.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.Span{``0})">
      <summary>Restituisce un riferimento all'elemento dell'intervallo in corrispondenza dell'indice 0.</summary>
      <param name="span">Intervallo da cui viene recuperato il riferimento.</param>
      <typeparam name="T">Tipo di elementi nell'intervallo.</typeparam>
      <returns>Riferimento all'elemento in corrispondenza dell'indice 0.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Read``1(System.ReadOnlySpan{System.Byte})">
      <summary>Legge una struttura di tipo <param name="T" /> da un intervallo di sola lettura di byte.</summary>
      <param name="source">Intervallo di sola lettura.</param>
      <typeparam name="T">Tipo dell'elemento da recuperare dall'intervallo di sola lettura.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> contiene riferimenti o puntatori.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> è minore di <paramref name="T" />.</exception>
      <returns>Struttura recuperata dall'intervallo di sola lettura.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.ToEnumerable``1(System.ReadOnlyMemory{``0})">
      <summary>Crea una vista <see cref="T:System.Collections.Generic.IEnumerable`1" /> del buffer di memoria di sola lettura specificato.</summary>
      <param name="memory">Buffer di memoria di sola lettura.</param>
      <typeparam name="T">Tipo di elementi nel buffer di memoria di sola lettura.</typeparam>
      <returns>Vista enumerabile di <paramref name="memory" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetArray``1(System.ReadOnlyMemory{``0},System.ArraySegment{``0}@)">
      <summary>Prova a ottenere un segmento di matrice dal buffer di memoria sottostante. Il valore restituito indica l'esito positivo dell'operazione.</summary>
      <param name="memory">Buffer di memoria di sola lettura.</param>
      <param name="segment">Quando termina, questo metodo contiene il segmento di matrice recuperato dal buffer di memoria di sola lettura sottostante. Se il metodo non riesce, restituisce un segmento di matrice predefinito.</param>
      <typeparam name="T">Tipo di elementi nel buffer di memoria di sola lettura.</typeparam>
      <returns>
        <see langword="true" /> se la chiamata al metodo riesce; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@)">
      <summary>Tenta di recuperare un <see cref="T:System.Buffers.MemoryManager`1" /> dal buffer di memoria di sola lettura sottostante.</summary>
      <param name="memory">Buffer di memoria di sola lettura per cui ottenere il gestore di memoria.</param>
      <param name="manager">Quando il metodo termina, il gestore di <paramref name="memory" />.</param>
      <typeparam name="T">Tipo di elementi nel buffer di memoria di sola lettura.</typeparam>
      <typeparam name="TManager">Tipo di <see cref="T:System.Buffers.MemoryManager`1" /> da recuperare.</typeparam>
      <returns>
        <see langword="true" /> se il metodo ha recuperato il gestore di memoria; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@,System.Int32@,System.Int32@)">
      <summary>Tenta di recuperare un <see cref="T:System.Buffers.MemoryManager`1" />, l'indice iniziale e la lunghezza dal buffer di memoria di sola lettura sottostante.</summary>
      <param name="memory">Buffer di memoria di sola lettura per cui ottenere il gestore di memoria.</param>
      <param name="manager">Quando il metodo termina, il gestore di <paramref name="memory" />.</param>
      <param name="start">Quando il metodo termina, offset dall'inizio di <paramref name="manager" /> rappresentato da <paramref name="memory" />.</param>
      <param name="length">Quando il metodo termina, lunghezza di <paramref name="manager" /> rappresentato da <paramref name="memory" />.</param>
      <typeparam name="T">Tipo di elementi nel buffer di memoria di sola lettura.</typeparam>
      <typeparam name="TManager">Tipo di <see cref="T:System.Buffers.MemoryManager`1" /> da recuperare.</typeparam>
      <returns>
        <see langword="true" /> se il metodo è riuscito; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetString(System.ReadOnlyMemory{System.Char},System.String@,System.Int32@,System.Int32@)">
      <summary>Prova a ottenere la stringa sottostante da un <see langword="System.ReadOnlyMemory&lt;Char&gt;" />.</summary>
      <param name="memory">Memoria di sola lettura che contiene un blocco di caratteri.</param>
      <param name="text">Quando il metodo termina, stringa contenuta nel buffer di memoria.</param>
      <param name="start">Posizione iniziale in <paramref name="text" />.</param>
      <param name="length">Numero di caratteri in <paramref name="text" />.</param>
      <returns>
        <see langword="true" /> se il metodo recupera correttamente la stringa sottostante; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryRead``1(System.ReadOnlySpan{System.Byte},``0@)">
      <summary>Tenta di leggere una struttura di tipo <paramref name="T" /> da un intervallo di sola lettura di byte.</summary>
      <param name="source">Intervallo di sola lettura di byte.</param>
      <param name="value">Quando il metodo termina, istanza di <paramref name="T" />.</param>
      <typeparam name="T">Tipo di struttura da recuperare.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> contiene riferimenti o puntatori.</exception>
      <returns>
        <see langword="true" /> se il metodo riesce a recuperare un'istanza della struttura; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryWrite``1(System.Span{System.Byte},``0@)">
      <summary>Tenta di scrivere una struttura di tipo <paramref name="T" /> in un intervallo di byte.</summary>
      <param name="destination">Intervallo di byte per contenere la struttura.</param>
      <param name="value">Struttura da scrivere nell'intervallo.</param>
      <typeparam name="T">Tipo della struttura.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> contiene riferimenti o puntatori.</exception>
      <returns>
        <see langword="true" /> se l'operazione di scrittura ha esito positivo; in caso contrario, <see langword="false" />. Il metodo restituisce <see langword="false" /> se l'intervallo è troppo piccolo per contenere <paramref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Write``1(System.Span{System.Byte},``0@)">
      <summary>Scrive una struttura di tipo <paramref name="T" /> in un intervallo di byte.</summary>
      <param name="destination">Intervallo di byte per contenere la struttura.</param>
      <param name="value">Struttura da scrivere nell'intervallo.</param>
      <typeparam name="T">Tipo della struttura.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> contiene riferimenti o puntatori.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> è troppo piccolo per contenere <paramref name="value" />.</exception>
    </member>
    <member name="T:System.Runtime.InteropServices.SequenceMarshal">
      <summary>Offre una raccolta di metodi per l'interoperabilità con <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetArray``1(System.Buffers.ReadOnlySequence{``0},System.ArraySegment{``0}@)">
      <summary>Ottiene un segmento di matrice dalla sequenza di sola lettura sottostante.</summary>
      <param name="sequence">Sequenza di sola lettura da cui verrà recuperato il segmento di matrice.</param>
      <param name="segment">Segmento di matrice restituito.</param>
      <typeparam name="T">Tipo della sequenza di sola lettura.</typeparam>
      <returns>
        <see langword="true" /> se è possibile recuperare il segmento di matrice; in caso contrario, <see langword="false" /> e viene restituito un segmento di matrice predefinito.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlyMemory``1(System.Buffers.ReadOnlySequence{``0},System.ReadOnlyMemory{``0}@)">
      <summary>Tenta di recuperare una memoria di sola lettura dalla sequenza di sola lettura specificata.</summary>
      <param name="sequence">Sequenza di sola lettura da cui verrà recuperata la memoria.</param>
      <param name="memory">Memoria di sola lettura di tipo T restituita.</param>
      <typeparam name="T">Tipo della sequenza di sola lettura.</typeparam>
      <returns>
        <see langword="true" /> se è possibile recuperare la memoria di sola lettura; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlySequenceSegment``1(System.Buffers.ReadOnlySequence{``0},System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@,System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@)">
      <summary>Tenta di recuperare un segmento di sequenza di sola lettura dalla sequenza di sola lettura specificata.</summary>
      <param name="sequence">Sequenza di sola lettura da cui verrà recuperato il segmento di sequenza di sola lettura.</param>
      <param name="startSegment">Segmento di sequenza di sola lettura iniziale.</param>
      <param name="startIndex">Posizione iniziale.</param>
      <param name="endSegment">Segmento di sequenza di sola lettura finale.</param>
      <param name="endIndex">Posizione finale.</param>
      <typeparam name="T">Tipo della sequenza di sola lettura.</typeparam>
      <returns>
        <see langword="true" /> se è possibile recuperare il segmento di sequenza di sola lettura; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryRead``1(System.Buffers.SequenceReader{System.Byte}@,``0@)">
      <summary>Tenta di leggere il tipo specificato dal buffer. L'uso di questo metodo con struct arbitrari è pericoloso. Per altre informazioni, vedere la sezione Osservazioni.</summary>
      <param name="reader">Riferimento al lettore di sequenze.</param>
      <param name="value">Valore restituito se la lettura è riuscita. <paramref name="value" /> sarà <see langword="default" /> se l'operazione non è riuscita (a causa di mancanza di spazio).</param>
      <typeparam name="T">Tipo del valore.</typeparam>
      <returns>
        <see langword="true" /> se il tentativo di lettura è riuscito, <see langword="false" /> in caso contrario.</returns>
    </member>
    <member name="T:System.SequencePosition">
      <summary>Rappresenta una posizione in un set di memoria non contiguo. Le proprietà di questo tipo devono essere interpretate solo dal tipo che le ha create.</summary>
    </member>
    <member name="M:System.SequencePosition.#ctor(System.Object,System.Int32)">
      <summary>Inizializza una nuova istanza dell'elemento struct <see cref="T:System.SequencePosition" />.</summary>
      <param name="object">Set di memoria non contiguo.</param>
      <param name="integer">Posizione in <paramref name="object" />.</param>
    </member>
    <member name="M:System.SequencePosition.Equals(System.Object)">
      <summary>Restituisce un valore che indica se l'istanza corrente è uguale a un altro oggetto.</summary>
      <param name="obj">Oggetto da confrontare con l'istanza corrente.</param>
      <returns>
        <see langword="true" /> se <paramref name="obj" /> è di tipo <see cref="T:System.SequencePosition" /> ed è uguale al valore dell'istanza corrente. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.SequencePosition.Equals(System.SequencePosition)">
      <summary>Indica se l'istanza corrente è uguale a un altro oggetto <see cref="T:System.SequencePosition" />.</summary>
      <param name="other">Posizione della sequenza da confrontare con l'istanza corrente.</param>
      <returns>
        <see langword="true" /> se le due istanze sono uguali. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.SequencePosition.GetHashCode">
      <summary>Restituisce il codice hash per l'istanza.</summary>
      <returns>Codice hash per l'istanza.</returns>
    </member>
    <member name="M:System.SequencePosition.GetInteger">
      <summary>Restituisce la parte intera di <see cref="T:System.SequencePosition" />.</summary>
      <returns>Parte intera della posizione della sequenza.</returns>
    </member>
    <member name="M:System.SequencePosition.GetObject">
      <summary>Restituisce la parte oggetto di <see cref="T:System.SequencePosition" />.</summary>
      <returns>Parte dell'oggetto della posizione della sequenza.</returns>
    </member>
    <member name="T:System.Text.EncodingExtensions">
      <summary>Fornisce metodi di estensione per i tipi di codifica, ad esempio <see cref="T:System.Text.Encoding" />, <see cref="T:System.Text.Encoder" /> e <see cref="T:System.Text.Decoder" />.</summary>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Decoder,System.Buffers.ReadOnlySequence{System.Byte}@,System.Buffers.IBufferWriter{System.Char},System.Boolean,System.Int64@,System.Boolean@)">
      <summary>Converte un oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> in caratteri con codifica UTF-16 e scrive il risultato in <paramref name="writer" />.</summary>
      <param name="decoder">Istanza del decodificatore in grado di convertire i byte in valori <see langword="char" />.</param>
      <param name="bytes">Sequenza di byte da decodificare.</param>
      <param name="writer">Buffer in cui verranno scritti i caratteri decodificati.</param>
      <param name="flush">
        <see langword="true" /> per indicare che non esistono altri dati da convertire; in caso contrario <see langword="false" />.</param>
      <param name="charsUsed">Quando termina, questo metodo contiene il numero di caratteri scritti in <paramref name="writer" />.</param>
      <param name="completed">Quando termina, questo metodo contiene <see langword="true" /> se <paramref name="decoder" /> non contiene uno stato interno parziale; in caso contrario, <see langword="false" />.
Se <paramref name="flush" /> è <see langword="true" />, verrà sempre impostato su <see langword="true" /> quando il metodo termina.</param>
      <exception cref="T:System.Text.DecoderFallbackException">
        <paramref name="bytes" /> contiene dati che non possono essere decodificati e <paramref name="decoder" /> è configurato per generare un'eccezione quando viene rilevato questo tipo di dati.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Decoder,System.ReadOnlySpan{System.Byte},System.Buffers.IBufferWriter{System.Char},System.Boolean,System.Int64@,System.Boolean@)">
      <summary>Converte un oggetto <see cref="T:System.ReadOnlySpan`1" /> in caratteri usando <paramref name="decoder" /> e scrive il risultato in <paramref name="writer" />.</summary>
      <param name="decoder">Istanza del decodificatore in grado di convertire i byte in valori <see langword="char" />.</param>
      <param name="bytes">Sequenza di byte da decodificare.</param>
      <param name="writer">Il buffer in cui verranno scritti i caratteri decodificati.</param>
      <param name="flush">
        <see langword="true" /> per indicare che non esistono altri dati da convertire; in caso contrario <see langword="false" />.</param>
      <param name="charsUsed">Quando termina, questo metodo contiene il numero di oggetti <see langword="char" /> scritti in <paramref name="writer" />.</param>
      <param name="completed">Quando termina, questo metodo contiene <see langword="true" /> se <paramref name="decoder" /> non contiene uno stato interno parziale; in caso contrario, <see langword="false" />.
Se <paramref name="flush" /> è <see langword="true" />, verrà sempre impostato su <see langword="true" /> quando il metodo termina.</param>
      <exception cref="T:System.Text.DecoderFallbackException">
        <paramref name="bytes" /> contiene dati che non possono essere codificati e <paramref name="decoder" /> è configurato per generare un'eccezione quando viene rilevato questo tipo di dati.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Encoder,System.Buffers.ReadOnlySequence{System.Char}@,System.Buffers.IBufferWriter{System.Byte},System.Boolean,System.Int64@,System.Boolean@)">
      <summary>Converte un oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> in byte codificati e scrive il risultato in <paramref name="writer" />.</summary>
      <param name="encoder">Istanza del codificatore in grado di convertire valori <see langword="char" /> in byte.</param>
      <param name="chars">Sequenza di caratteri da codificare.</param>
      <param name="writer">Buffer in cui verranno scritti i byte codificati.</param>
      <param name="flush">
        <see langword="true" /> per indicare che non esistono altri dati da convertire; in caso contrario <see langword="false" />.</param>
      <param name="bytesUsed">Quando termina, questo metodo contiene il numero di oggetti <see langword="byte" /> scritti in <paramref name="writer" />.</param>
      <param name="completed">Quando termina, questo metodo contiene <see langword="true" /> se l'input fino a <paramref name="bytesUsed" /> è stato interamente convertito; in caso contrario, <see langword="false" />. Se <paramref name="flush" /> è <see langword="true" />, verrà sempre impostato su <see langword="true" /> quando il metodo termina.</param>
      <exception cref="T:System.Text.EncoderFallbackException">
        <paramref name="chars" /> contiene dati che non possono essere codificati e <paramref name="encoder" /> è configurato per generare un'eccezione quando viene rilevato questo tipo di dati.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Encoder,System.ReadOnlySpan{System.Char},System.Buffers.IBufferWriter{System.Byte},System.Boolean,System.Int64@,System.Boolean@)">
      <summary>Converte un oggetto <see cref="T:System.ReadOnlySpan`1" /> in byte usando <paramref name="encoder" /> e scrive il risultato in <paramref name="writer" />.</summary>
      <param name="encoder">Istanza del codificatore in grado di convertire valori <see langword="char" /> in byte.</param>
      <param name="chars">Sequenza di caratteri da codificare.</param>
      <param name="writer">Buffer in cui verranno scritti i byte codificati.</param>
      <param name="flush">
        <see langword="true" /> per indicare che non esistono altri dati da convertire; in caso contrario <see langword="false" />.</param>
      <param name="bytesUsed">Quando termina, questo metodo contiene il numero di oggetti <see langword="byte" /> scritti in <paramref name="writer" />.</param>
      <param name="completed">Quando termina, questo metodo contiene <see langword="true" /> se <paramref name="encoder" /> non contiene uno stato interno parziale; in caso contrario, <see langword="false" />.
Se <paramref name="flush" /> è <see langword="true" />, verrà sempre impostato su <see langword="true" /> quando il metodo termina.</param>
      <exception cref="T:System.Text.EncoderFallbackException">
        <paramref name="chars" /> contiene dati che non possono essere codificati e <paramref name="encoder" /> è configurato per generare un'eccezione quando viene rilevato questo tipo di dati.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Char}@)">
      <summary>Codifica l'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> specificato in una matrice <see cref="T:System.Byte" /> usando l'oggetto <see cref="T:System.Text.Encoding" /> specificato.</summary>
      <param name="encoding">Codifica che rappresenta il modo in cui devono essere codificati i dati in <paramref name="chars" />.</param>
      <param name="chars">Sequenza da codificare in byte.</param>
      <exception cref="T:System.Text.EncoderFallbackException">
        <paramref name="chars" /> contiene dati che non possono essere codificati e <paramref name="encoding" /> è configurato per generare un'eccezione quando viene rilevato questo tipo di dati.</exception>
      <returns>Matrice <see cref="T:System.Byte" /> che rappresenta il contenuto codificato di <paramref name="chars" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Char}@,System.Buffers.IBufferWriter{System.Byte})">
      <summary>Decodifica l'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> specificato in <see langword="byte" /> usando l'oggetto <see cref="T:System.Text.Encoding" /> specificato e scrive il risultato in <paramref name="writer" />.</summary>
      <param name="encoding">Codifica che rappresenta il modo in cui devono essere codificati i dati in <paramref name="chars" />.</param>
      <param name="chars">Oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> di cui deve essere codificato il contenuto.</param>
      <param name="writer">Buffer in cui verranno scritti i byte codificati.</param>
      <exception cref="T:System.Text.EncoderFallbackException">
        <paramref name="chars" /> contiene dati che non possono essere codificati e <paramref name="encoding" /> è configurato per generare un'eccezione quando viene rilevato questo tipo di dati.</exception>
      <returns>Numero di byte scritti in <paramref name="writer" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Char}@,System.Span{System.Byte})">
      <summary>Codifica l'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> specificato in <see langword="byte" /> usando l'oggetto <see cref="T:System.Text.Encoding" /> specificato e visualizza il risultato in <paramref name="bytes" />.</summary>
      <param name="encoding">Codifica che rappresenta il modo in cui devono essere codificati i dati in <paramref name="chars" />.</param>
      <param name="chars">Sequenza da codificare in byte.</param>
      <param name="bytes">Buffer di destinazione in cui verranno scritti i byte codificati.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="bytes" /> non è sufficientemente grande da contenere il formato codificato di <paramref name="chars" />.</exception>
      <exception cref="T:System.Text.EncoderFallbackException">
        <paramref name="chars" /> contiene dati che non possono essere codificati e <paramref name="encoding" /> è configurato per generare un'eccezione quando viene rilevato questo tipo di dati.</exception>
      <returns>Numero di byte scritti in <paramref name="bytes" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.ReadOnlySpan{System.Char},System.Buffers.IBufferWriter{System.Byte})">
      <summary>Codifica l'oggetto <see cref="T:System.ReadOnlySpan`1" /> specificato in <see langword="byte" /> usando l'oggetto <see cref="T:System.Text.Encoding" /> specificato e scrive il risultato in <paramref name="writer" />.</summary>
      <param name="encoding">Codifica che rappresenta il modo in cui devono essere codificati i dati in <paramref name="chars" />.</param>
      <param name="chars">Sequenza da codificare in byte.</param>
      <param name="writer">Buffer in cui verranno scritti i byte codificati.</param>
      <exception cref="T:System.Text.EncoderFallbackException">
        <paramref name="chars" /> contiene dati che non possono essere codificati e <paramref name="encoding" /> è configurato per generare un'eccezione quando viene rilevato questo tipo di dati.</exception>
      <returns>Numero di byte scritti in <paramref name="writer" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetChars(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Byte}@,System.Buffers.IBufferWriter{System.Char})">
      <summary>Decodifica l'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> specificato in <see langword="char" /> usando l'oggetto <see cref="T:System.Text.Encoding" /> specificato e scrive il risultato in <paramref name="writer" />.</summary>
      <param name="encoding">Codifica che rappresenta il modo in cui devono essere decodificati i dati in <paramref name="bytes" />.</param>
      <param name="bytes">Sequenza di cui devono essere decodificati i byte.</param>
      <param name="writer">Il buffer in cui verranno scritti i caratteri decodificati.</param>
      <exception cref="T:System.Text.DecoderFallbackException">
        <paramref name="bytes" /> contiene dati che non possono essere decodificati e <paramref name="encoding" /> è configurato per generare un'eccezione quando viene rilevato questo tipo di dati.</exception>
      <returns>Numero di caratteri scritti in <paramref name="writer" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetChars(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Byte}@,System.Span{System.Char})">
      <summary>Decodifica l'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> specificato in <see langword="char" /> usando l'oggetto <see cref="T:System.Text.Encoding" /> specificato e visualizza il risultato in <paramref name="chars" />.</summary>
      <param name="encoding">Codifica che rappresenta il modo in cui vengono codificati i dati in <paramref name="bytes" />.</param>
      <param name="bytes">Sequenza da decodificare in caratteri.</param>
      <param name="chars">Buffer di destinazione in cui verranno scritti i caratteri decodificati.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="chars" /> non è sufficientemente grande da contenere il formato codificato di <paramref name="bytes" />.</exception>
      <exception cref="T:System.Text.DecoderFallbackException">
        <paramref name="bytes" /> contiene dati che non possono essere decodificati e <paramref name="encoding" /> è configurato per generare un'eccezione quando viene rilevato questo tipo di dati.</exception>
      <returns>Numero di caratteri scritti in <paramref name="chars" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetChars(System.Text.Encoding,System.ReadOnlySpan{System.Byte},System.Buffers.IBufferWriter{System.Char})">
      <summary>Decodifica l'oggetto <see cref="T:System.ReadOnlySpan`1" /> specificato in <see langword="char" /> usando l'oggetto <see cref="T:System.Text.Encoding" /> specificato e scrive il risultato in <paramref name="writer" />.</summary>
      <param name="encoding">Codifica che rappresenta il modo in cui devono essere decodificati i dati in <paramref name="bytes" />.</param>
      <param name="bytes">Intervallo di byte da decodificare.</param>
      <param name="writer">Il buffer in cui verranno scritti i caratteri decodificati.</param>
      <exception cref="T:System.Text.DecoderFallbackException">
        <paramref name="bytes" /> contiene dati che non possono essere decodificati e <paramref name="encoding" /> è configurato per generare un'eccezione quando viene rilevato questo tipo di dati.</exception>
      <returns>Numero di caratteri scritti in <paramref name="writer" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetString(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Byte}@)">
      <summary>Decodifica l'oggetto <see cref="T:System.Buffers.ReadOnlySequence`1" /> specificato in una <see cref="T:System.String" /> usando l'oggetto <see cref="T:System.Text.Encoding" /> specificato.</summary>
      <param name="encoding">Codifica che rappresenta il modo in cui vengono codificati i dati in <paramref name="bytes" />.</param>
      <param name="bytes">Sequenza da decodificare in caratteri.</param>
      <exception cref="T:System.Text.DecoderFallbackException">
        <paramref name="bytes" /> contiene dati che non possono essere decodificati e <paramref name="encoding" /> è configurato per generare un'eccezione quando viene rilevato questo tipo di dati.</exception>
      <returns>Oggetto <see cref="T:System.String" /> che rappresenta il contenuto decodificato di <paramref name="bytes" />.</returns>
    </member>
    <member name="T:System.Text.SpanRuneEnumerator">
      <summary>Fornisce un enumeratore per i valori di <see cref="T:System.Text.Rune" /> rappresentati da un intervallo contenente testo UTF-16.</summary>
    </member>
    <member name="M:System.Text.SpanRuneEnumerator.GetEnumerator">
      <summary>Restituisce l'istanza dell'enumeratore corrente.</summary>
      <returns>Istanza dell'enumeratore corrente.</returns>
    </member>
    <member name="M:System.Text.SpanRuneEnumerator.MoveNext">
      <summary>Sposta l'enumeratore all'elemento <see cref="T:System.Text.Rune" /> successivo dell'intervallo.</summary>
      <returns>
        <see langword="true" /> se l'enumeratore è stato spostato correttamente all'elemento successivo; <see langword="false" /> se è stata raggiunta la fine dell'intervallo.</returns>
    </member>
    <member name="P:System.Text.SpanRuneEnumerator.Current">
      <summary>Ottiene l'oggetto <see cref="T:System.Text.Rune" /> in corrispondenza della posizione corrente dell'enumeratore.</summary>
      <returns>Oggetto <see cref="T:System.Text.Rune" /> in corrispondenza della posizione corrente dell'enumeratore.</returns>
    </member>
  </members>
</doc>