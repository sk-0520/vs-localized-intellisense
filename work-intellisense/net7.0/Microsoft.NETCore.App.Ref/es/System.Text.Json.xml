<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Text.Json</name>
  </assembly>
  <members>
    <member name="T:System.Text.Json.JsonCommentHandling">
      <summary>Define cómo controla los comentarios la estructura <see cref="T:System.Text.Json.Utf8JsonReader" />.</summary>
    </member>
    <member name="F:System.Text.Json.JsonCommentHandling.Allow">
      <summary>Permite comentarios dentro de la entrada JSON y los trata como tokens válidos. Durante la lectura, el autor de la llamada puede acceder a los valores de comentario.</summary>
    </member>
    <member name="F:System.Text.Json.JsonCommentHandling.Disallow">
      <summary>No permite comentarios dentro de la entrada JSON. Si se encuentran comentarios, se tratan como JSON no válido y se inicia una excepción <see cref="T:System.Text.Json.JsonException" />. Este es el valor predeterminado.</summary>
    </member>
    <member name="F:System.Text.Json.JsonCommentHandling.Skip">
      <summary>Permite comentarios dentro de la entrada JSON y los ignora. <see cref="T:System.Text.Json.Utf8JsonReader" /> se comporta como si no hubiera comentarios.</summary>
    </member>
    <member name="T:System.Text.Json.JsonDocument">
      <summary>Ofrece un mecanismo de examen del contenido estructural de un valor JSON sin crear automáticamente instancias de valores de datos.</summary>
    </member>
    <member name="M:System.Text.Json.JsonDocument.Dispose">
      <summary>Libera los recursos que usa la instancia <see cref="T:System.Text.Json.JsonDocument" />.</summary>
    </member>
    <member name="M:System.Text.Json.JsonDocument.Parse(System.Buffers.ReadOnlySequence{System.Byte},System.Text.Json.JsonDocumentOptions)">
      <summary>Analiza una secuencia como texto codificado con UTF-8 que representa un único valor de byte JSON en un objeto JsonDocument.</summary>
      <param name="utf8Json">Texto JSON que se va a analizar.</param>
      <param name="options">Opciones para controlar el comportamiento de los lectores durante el análisis.</param>
      <exception cref="T:System.Text.Json.JsonException">
        <paramref name="utf8Json" /> no representa un único valor JSON válido.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="options" /> contiene opciones no compatibles.</exception>
      <returns>Representación JsonDocument del valor JSON.</returns>
    </member>
    <member name="M:System.Text.Json.JsonDocument.Parse(System.IO.Stream,System.Text.Json.JsonDocumentOptions)">
      <summary>Analiza un objeto <see cref="T:System.IO.Stream" /> como datos codificados con UTF-8 que representan un único valor JSON en un objeto JsonDocument. La secuencia se lee hasta su finalización.</summary>
      <param name="utf8Json">Datos JSON que se van a analizar.</param>
      <param name="options">Opciones para controlar el comportamiento de los lectores durante el análisis.</param>
      <exception cref="T:System.Text.Json.JsonException">
        <paramref name="utf8Json" /> no representa un único valor JSON válido.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="options" /> contiene opciones no compatibles.</exception>
      <returns>Representación JsonDocument del valor JSON.</returns>
    </member>
    <member name="M:System.Text.Json.JsonDocument.Parse(System.ReadOnlyMemory{System.Byte},System.Text.Json.JsonDocumentOptions)">
      <summary>Analiza la memoria como texto codificado con UTF-8 que representa un valor de byte JSON único en un objeto JsonDocument.</summary>
      <param name="utf8Json">Texto JSON que se va a analizar.</param>
      <param name="options">Opciones para controlar el comportamiento de los lectores durante el análisis.</param>
      <exception cref="T:System.Text.Json.JsonException">
        <paramref name="utf8Json" /> no representa un único valor JSON válido.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="options" /> contiene opciones no compatibles.</exception>
      <returns>Representación JsonDocument del valor JSON.</returns>
    </member>
    <member name="M:System.Text.Json.JsonDocument.Parse(System.ReadOnlyMemory{System.Char},System.Text.Json.JsonDocumentOptions)">
      <summary>Analiza texto que representa un único valor de carácter JSON en un objeto JsonDocument.</summary>
      <param name="json">Texto JSON que se va a analizar.</param>
      <param name="options">Opciones para controlar el comportamiento de los lectores durante el análisis.</param>
      <exception cref="T:System.Text.Json.JsonException">
        <paramref name="json" /> no representa un único valor JSON válido.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="options" /> contiene opciones no compatibles.</exception>
      <returns>Representación JsonDocument del valor JSON.</returns>
    </member>
    <member name="M:System.Text.Json.JsonDocument.Parse(System.String,System.Text.Json.JsonDocumentOptions)">
      <summary>Analiza texto que representa un único valor de cadena JSON en un objeto JsonDocument.</summary>
      <param name="json">Texto JSON que se va a analizar.</param>
      <param name="options">Opciones para controlar el comportamiento de los lectores durante el análisis.</param>
      <exception cref="T:System.Text.Json.JsonException">
        <paramref name="json" /> no representa un único valor JSON válido.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="options" /> contiene opciones no compatibles.</exception>
      <returns>Representación JsonDocument del valor JSON.</returns>
    </member>
    <member name="M:System.Text.Json.JsonDocument.ParseAsync(System.IO.Stream,System.Text.Json.JsonDocumentOptions,System.Threading.CancellationToken)">
      <summary>Analiza un objeto <see cref="T:System.IO.Stream" /> como datos codificados con UTF-8 que representan un único valor JSON en un objeto JsonDocument. La secuencia se lee hasta su finalización.</summary>
      <param name="utf8Json">Datos JSON que se van a analizar.</param>
      <param name="options">Opciones para controlar el comportamiento de los lectores durante el análisis.</param>
      <param name="cancellationToken">Token para supervisar solicitudes de cancelación.</param>
      <exception cref="T:System.Text.Json.JsonException">
        <paramref name="utf8Json" /> no representa un único valor JSON válido.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="options" /> contiene opciones no compatibles.</exception>
      <returns>Tarea que genera una representación JsonDocument del valor JSON.</returns>
    </member>
    <member name="M:System.Text.Json.JsonDocument.ParseValue(System.Text.Json.Utf8JsonReader@)">
      <summary>Analiza un valor JSON (incluidos objetos o matrices) del lector proporcionado.</summary>
      <param name="reader">El lector que se va a leer.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="reader" /> contiene opciones no compatibles.

o bien

El token <paramref name="reader" /> actual no inicia o representa un valor.</exception>
      <exception cref="T:System.Text.Json.JsonException">No se pudo leer un valor del lector.</exception>
      <returns>Lee un objeto JsonDocument que representa el valor (y los valores anidados) del lector.</returns>
    </member>
    <member name="M:System.Text.Json.JsonDocument.TryParseValue(System.Text.Json.Utf8JsonReader@,System.Text.Json.JsonDocument@)">
      <summary>Intenta analizar un valor JSON (incluidos objetos o matrices) del lector proporcionado.</summary>
      <param name="reader">El lector que se va a leer.</param>
      <param name="document">Cuando este método devuelve un resultado, contiene el valor analizado.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="reader" /> contiene opciones no compatibles.

o bien

El token <paramref name="reader" /> actual no inicia o representa un valor.</exception>
      <exception cref="T:System.Text.Json.JsonException">No se pudo leer un valor del lector.</exception>
      <returns>
        <see langword="true" /> si un valor se leyó y analizó en un objeto JsonDocument; <see langword="false" /> si el lector se quedó sin datos durante el análisis. Las demás situaciones dan como resultado una excepción.</returns>
    </member>
    <member name="M:System.Text.Json.JsonDocument.WriteTo(System.Text.Json.Utf8JsonWriter)">
      <summary>Escribe el documento en el escritor proporcionado como un valor JSON.</summary>
      <param name="writer">Escritor en el que se va a escribir el documento.</param>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="writer" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este <see cref="P:System.Text.Json.JsonDocument.RootElement" /> daría como resultado un JSON no válido.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
    </member>
    <member name="P:System.Text.Json.JsonDocument.RootElement">
      <summary>Obtiene el elemento raíz del documento JSON.</summary>
      <returns>
        <see cref="T:System.Text.Json.JsonElement" />Que representa el valor del documento.</returns>
    </member>
    <member name="T:System.Text.Json.JsonDocumentOptions">
      <summary>Proporciona la capacidad de que el usuario defina el comportamiento personalizado al analizar JSON para crear <see cref="T:System.Text.Json.JsonDocument" />.</summary>
    </member>
    <member name="P:System.Text.Json.JsonDocumentOptions.AllowTrailingCommas">
      <summary>Obtiene o establece un valor que indica si se permite (y se ignora) una coma adicional al final de una lista de valores JSON en un objeto o una matriz dentro de la carga de JSON que se lee.</summary>
      <returns>
        <see langword="true" /> Si se permite una coma adicional al final de una lista de valores JSON de un objeto o una matriz; en caso contrario, <see langword="false" /> . Valor predeterminado: <see langword="false" /></returns>
    </member>
    <member name="P:System.Text.Json.JsonDocumentOptions.CommentHandling">
      <summary>Obtiene o establece un valor que determina cómo <see cref="T:System.Text.Json.JsonDocument" /> controla los comentarios al leer los datos JSON.</summary>
      <exception cref="T:System.ArgumentOutOfRangeException">La enumeración de control de comentarios se establece en un valor que no se admite (o que no se encuentra dentro del rango de enumeración <see cref="T:System.Text.Json.JsonCommentHandling" />).</exception>
      <returns>Uno de los valores de enumeración que indica cómo se controlan los comentarios.</returns>
    </member>
    <member name="P:System.Text.Json.JsonDocumentOptions.MaxDepth">
      <summary>Obtiene o establece la profundidad máxima permitida al analizar datos JSON, y el valor predeterminado (es decir, 0) indica una profundidad máxima de 64.</summary>
      <exception cref="T:System.ArgumentOutOfRangeException">La profundidad máxima está establecida en un valor negativo.</exception>
      <returns>La profundidad máxima permitida al analizar datos JSON.</returns>
    </member>
    <member name="T:System.Text.Json.JsonElement">
      <summary>Representa un valor JSON específico en un objeto <see cref="T:System.Text.Json.JsonDocument" />.</summary>
    </member>
    <member name="M:System.Text.Json.JsonElement.Clone">
      <summary>Obtiene un objeto JsonElement que se puede almacenar de forma segura más allá de la duración del <see cref="T:System.Text.Json.JsonDocument" /> original.</summary>
      <returns>Objeto JsonElement que se puede almacenar de forma segura más allá de la duración del <see cref="T:System.Text.Json.JsonDocument" /> original.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.EnumerateArray">
      <summary>Obtiene un enumerador que enumera los valores de la matriz JSON representados por este JsonElement.</summary>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Array" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Enumerador que enumera los valores de la matriz JSON representados por este JsonElement.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.EnumerateObject">
      <summary>Obtiene un enumerador que enumera las propiedades del objeto JSON representadas por este JsonElement.</summary>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Object" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Enumerador que enumera las propiedades del objeto JSON representadas por este JsonElement.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.GetArrayLength">
      <summary>Obtiene el número de valores incluidos en el valor de matriz actual.</summary>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Array" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Número de valores incluidos en el valor de matriz actual.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.GetBoolean">
      <summary>Obtiene el valor del elemento como <see cref="T:System.Boolean" />.</summary>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.True" /> ni <see cref="F:System.Text.Json.JsonValueKind.False" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Valor del elemento como <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.GetByte">
      <summary>Obtiene el número JSON actual como <see cref="T:System.Byte" />.</summary>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Number" />.</exception>
      <exception cref="T:System.FormatException">El valor no se puede representar como <see cref="T:System.Byte" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Número JSON actual como <see cref="T:System.Byte" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.GetBytesFromBase64">
      <summary>Obtiene el valor del elemento como matriz de bytes.</summary>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.String" />.</exception>
      <exception cref="T:System.FormatException">El valor no está codificado como texto Base64 y, por tanto, no se puede descodificar en bytes.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Valor descodificado como matriz de bytes.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.GetDateTime">
      <summary>Obtiene el valor del elemento como <see cref="T:System.DateTime" />.</summary>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.String" />.</exception>
      <exception cref="T:System.FormatException">El valor no se puede leer como <see cref="T:System.DateTime" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Valor del elemento como <see cref="T:System.DateTime" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.GetDateTimeOffset">
      <summary>Obtiene el valor del elemento como <see cref="T:System.DateTimeOffset" />.</summary>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.String" />.</exception>
      <exception cref="T:System.FormatException">El valor no se puede leer como <see cref="T:System.DateTimeOffset" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Valor del elemento como <see cref="T:System.DateTimeOffset" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.GetDecimal">
      <summary>Obtiene el número JSON actual como <see cref="T:System.Decimal" />.</summary>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Number" />.</exception>
      <exception cref="T:System.FormatException">El valor no se puede representar como <see cref="T:System.Decimal" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Número JSON actual como <see cref="T:System.Decimal" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.GetDouble">
      <summary>Obtiene el número JSON actual como <see cref="T:System.Double" />.</summary>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Number" />.</exception>
      <exception cref="T:System.FormatException">El valor no se puede representar como <see cref="T:System.Double" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Número JSON actual como <see cref="T:System.Double" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.GetGuid">
      <summary>Obtiene el valor del elemento como <see cref="T:System.Guid" />.</summary>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.String" />.</exception>
      <exception cref="T:System.FormatException">El valor no se puede representar como <see cref="T:System.Guid" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Valor del elemento como <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.GetInt16">
      <summary>Obtiene el número JSON actual como <see cref="T:System.Int16" />.</summary>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Number" />.</exception>
      <exception cref="T:System.FormatException">El valor no se puede representar como <see cref="T:System.Int16" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Número JSON actual como <see cref="T:System.Int16" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.GetInt32">
      <summary>Obtiene el número JSON actual como <see cref="T:System.Int32" />.</summary>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Number" />.</exception>
      <exception cref="T:System.FormatException">El valor no se puede representar como <see cref="T:System.Int32" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Número JSON actual como <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.GetInt64">
      <summary>Obtiene el número JSON actual como <see cref="T:System.Int64" />.</summary>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Number" />.</exception>
      <exception cref="T:System.FormatException">El valor no se puede representar como <see cref="T:System.Int64" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Número JSON actual como <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.GetProperty(System.ReadOnlySpan{System.Byte})">
      <summary>Obtiene un objeto <see cref="T:System.Text.Json.JsonElement" /> que representa el valor de una propiedad obligatoria identificada por <paramref name="utf8PropertyName" />.</summary>
      <param name="utf8PropertyName">Representación UTF-8 (sin marca de orden de bytes [BOM]) del nombre de la propiedad que se va a devolver.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Object" />.</exception>
      <exception cref="T:System.Collections.Generic.KeyNotFoundException">No se encontró ninguna propiedad con el nombre solicitado.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Objeto <see cref="T:System.Text.Json.JsonElement" /> que representa el valor de la propiedad solicitada.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.GetProperty(System.ReadOnlySpan{System.Char})">
      <summary>Obtiene un objeto <see cref="T:System.Text.Json.JsonElement" /> que representa el valor de una propiedad obligatoria identificada por <paramref name="propertyName" />.</summary>
      <param name="propertyName">Nombre de la propiedad cuyo valor se va a devolver.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Object" />.</exception>
      <exception cref="T:System.Collections.Generic.KeyNotFoundException">No se encontró ninguna propiedad con el nombre solicitado.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Objeto <see cref="T:System.Text.Json.JsonElement" /> que representa el valor de la propiedad solicitada.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.GetProperty(System.String)">
      <summary>Obtiene un objeto <see cref="T:System.Text.Json.JsonElement" /> que representa el valor de una propiedad obligatoria identificada por <paramref name="propertyName" />.</summary>
      <param name="propertyName">Nombre de la propiedad cuyo valor se va a devolver.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Object" />.</exception>
      <exception cref="T:System.Collections.Generic.KeyNotFoundException">No se encontró ninguna propiedad con el nombre solicitado.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Objeto <see cref="T:System.Text.Json.JsonElement" /> que representa el valor de la propiedad solicitada.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.GetRawText">
      <summary>Obtiene una cadena que representa los datos de entrada originales que respaldan este valor.</summary>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Datos de entrada originales que respaldan este valor.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.GetSByte">
      <summary>Obtiene el número JSON actual como <see cref="T:System.SByte" />.</summary>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Number" />.</exception>
      <exception cref="T:System.FormatException">El valor no se puede representar como <see cref="T:System.SByte" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Número JSON actual como <see cref="T:System.SByte" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.GetSingle">
      <summary>Obtiene el número JSON actual como <see cref="T:System.Single" />.</summary>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Number" />.</exception>
      <exception cref="T:System.FormatException">El valor no se puede representar como <see cref="T:System.Single" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Número JSON actual como <see cref="T:System.Single" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.GetString">
      <summary>Obtiene el valor del elemento como <see cref="T:System.String" />.</summary>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.String" /> ni <see cref="F:System.Text.Json.JsonValueKind.Null" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Valor del elemento como <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.GetUInt16">
      <summary>Obtiene el número JSON actual como <see cref="T:System.UInt16" />.</summary>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Number" />.</exception>
      <exception cref="T:System.FormatException">El valor no se puede representar como <see cref="T:System.UInt16" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Número JSON actual como <see cref="T:System.UInt16" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.GetUInt32">
      <summary>Obtiene el número JSON actual como <see cref="T:System.UInt32" />.</summary>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Number" />.</exception>
      <exception cref="T:System.FormatException">El valor no se puede representar como <see cref="T:System.UInt32" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Número JSON actual como <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.GetUInt64">
      <summary>Obtiene el número JSON actual como <see cref="T:System.UInt64" />.</summary>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Number" />.</exception>
      <exception cref="T:System.FormatException">El valor no se puede representar como <see cref="T:System.UInt64" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Número JSON actual como <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.ToString">
      <summary>Obtiene una representación de cadena del valor actual correspondiente al tipo de valor.</summary>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Representación de cadena del valor actual correspondiente al tipo de valor.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.TryGetByte(System.Byte@)">
      <summary>Número de intentos para representar el número JSON actual como <see cref="T:System.Byte" />.</summary>
      <param name="value">Cuando el método devuelve un valor, contiene el equivalente en bytes del número JSON actual si la conversión se realizó correctamente.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Number" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>
        <see langword="true" /> si el número puede representarse como <see cref="T:System.Byte" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.TryGetBytesFromBase64(System.Byte[]@)">
      <summary>Intenta representar la cadena JSON actual como matriz de bytes, suponiendo que se trata de una codificación en Base64.</summary>
      <param name="value">Si el método se ejecuta correctamente, contiene la representación binaria descodificada del texto en Base64.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.String" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>
        <see langword="true" /> si el valor del token completo está codificado como texto válido Base64 y se puede descodificar correctamente en bytes; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.TryGetDateTime(System.DateTime@)">
      <summary>Número de intentos para representar la cadena JSON actual como <see cref="T:System.DateTime" />.</summary>
      <param name="value">Cuando este método devuelve un resultado, contiene el valor de fecha y hora equivalente a la cadena JSON actual.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.String" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>
        <see langword="true" /> si la cadena puede representarse como <see cref="T:System.DateTime" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.TryGetDateTimeOffset(System.DateTimeOffset@)">
      <summary>Número de intentos para representar la cadena JSON actual como <see cref="T:System.DateTimeOffset" />.</summary>
      <param name="value">Cuando este método devuelve un resultado, contiene la fecha y hora equivalente a la cadena JSON actual.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.String" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>
        <see langword="true" /> si la cadena puede representarse como <see cref="T:System.DateTimeOffset" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.TryGetDecimal(System.Decimal@)">
      <summary>Número de intentos para representar el número JSON actual como <see cref="T:System.Decimal" />.</summary>
      <param name="value">Cuando este método devuelve un resultado, contiene el decimal equivalente del número JSON actual.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Number" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>
        <see langword="true" /> si el número puede representarse como <see cref="T:System.Decimal" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.TryGetDouble(System.Double@)">
      <summary>Número de intentos para representar el número JSON actual como <see cref="T:System.Double" />.</summary>
      <param name="value">Cuando este método devuelve un resultado, contiene un valor de número de punto flotante de doble precisión equivalente a la cadena JSON actual.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Number" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>
        <see langword="true" /> si el número puede representarse como <see cref="T:System.Double" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.TryGetGuid(System.Guid@)">
      <summary>Número de intentos para representar la cadena JSON actual como <see cref="T:System.Guid" />.</summary>
      <param name="value">Cuando este método devuelve un resultado, contiene el GUID equivalente a la cadena JSON actual.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.String" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>
        <see langword="true" /> si la cadena puede representarse como <see cref="T:System.Guid" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.TryGetInt16(System.Int16@)">
      <summary>Número de intentos para representar el número JSON actual como <see cref="T:System.Int16" />.</summary>
      <param name="value">Cuando el método devuelve un valor, contiene el equivalente en enteros de 16 bits del número JSON actual si la conversión se realizó correctamente.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Number" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>
        <see langword="true" /> si el número puede representarse como <see cref="T:System.Int16" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.TryGetInt32(System.Int32@)">
      <summary>Número de intentos para representar el número JSON actual como <see cref="T:System.Int32" />.</summary>
      <param name="value">Cuando este método devuelve un resultado, contiene un valor entero de 32 bits equivalente a la cadena JSON actual.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Number" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>
        <see langword="true" /> si el número puede representarse como <see cref="T:System.Int32" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.TryGetInt64(System.Int64@)">
      <summary>Número de intentos para representar el número JSON actual como <see cref="T:System.Int64" />.</summary>
      <param name="value">Cuando este método devuelve un resultado, contiene un valor entero de 64 bits equivalente a la cadena JSON actual.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Number" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>
        <see langword="true" /> si el número puede representarse como <see cref="T:System.Int64" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.TryGetProperty(System.ReadOnlySpan{System.Byte},System.Text.Json.JsonElement@)">
      <summary>Busca una propiedad denominada <paramref name="utf8PropertyName" /> en el objeto actual y devuelve un valor que indica si dicha propiedad existe o no. Cuando la propiedad existe, el método asigna su valor al argumento <paramref name="value" />.</summary>
      <param name="utf8PropertyName">Representación UTF-8 (sin marca de orden de bytes [BOM]) del nombre de la propiedad que se va a devolver.</param>
      <param name="value">Recibe el valor de la propiedad encontrada.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Object" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>
        <see langword="true" /> si se encuentra la propiedad; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.TryGetProperty(System.ReadOnlySpan{System.Char},System.Text.Json.JsonElement@)">
      <summary>Busca una propiedad denominada <paramref name="propertyName" /> en el objeto actual y devuelve un valor que indica si dicha propiedad existe o no. Cuando la propiedad existe, el método asigna su valor al argumento <paramref name="value" />.</summary>
      <param name="propertyName">Nombre de la propiedad que se va a buscar.</param>
      <param name="value">Cuando este método devuelve un resultado, contiene el valor de la propiedad especificada.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Object" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>
        <see langword="true" /> si se encuentra la propiedad; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.TryGetProperty(System.String,System.Text.Json.JsonElement@)">
      <summary>Busca una propiedad denominada <paramref name="propertyName" /> en el objeto actual y devuelve un valor que indica si dicha propiedad existe o no. Cuando la propiedad existe, su valor se asigna al argumento <paramref name="value" />.</summary>
      <param name="propertyName">Nombre de la propiedad que se va a buscar.</param>
      <param name="value">Cuando este método devuelve un resultado, contiene el valor de la propiedad especificada.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Object" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>
        <see langword="true" /> si se encuentra la propiedad; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.TryGetSByte(System.SByte@)">
      <summary>Número de intentos para representar el número JSON actual como <see cref="T:System.SByte" />.</summary>
      <param name="value">Cuando el método devuelve un valor, contiene el equivalente en bytes firmados del número JSON actual si la conversión se realizó correctamente.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Number" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>
        <see langword="true" /> si el número puede representarse como <see cref="T:System.SByte" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.TryGetSingle(System.Single@)">
      <summary>Número de intentos para representar el número JSON actual como <see cref="T:System.Single" />.</summary>
      <param name="value">Cuando este método devuelve un resultado, contiene un valor de número de punto flotante de precisión sencilla equivalente a la cadena JSON actual.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Number" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>
        <see langword="true" /> si el número puede representarse como <see cref="T:System.Single" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.TryGetUInt16(System.UInt16@)">
      <summary>Número de intentos para representar el número JSON actual como <see cref="T:System.UInt16" />.</summary>
      <param name="value">Cuando el método devuelve un valor, contiene el equivalente en enteros de 16 bits sin firmar del número JSON actual si la conversión se realizó correctamente.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Number" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>
        <see langword="true" /> si el número puede representarse como <see cref="T:System.UInt16" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.TryGetUInt32(System.UInt32@)">
      <summary>Número de intentos para representar el número JSON actual como <see cref="T:System.UInt32" />.</summary>
      <param name="value">Cuando este método devuelve un resultado, contiene un valor entero de 32 bits sin signo equivalente al número JSON actual.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Number" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>
        <see langword="true" /> si el número puede representarse como <see cref="T:System.UInt32" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.TryGetUInt64(System.UInt64@)">
      <summary>Número de intentos para representar el número JSON actual como <see cref="T:System.UInt64" />.</summary>
      <param name="value">Cuando este método devuelve un resultado, contiene un valor entero de 64 bits sin signo equivalente al número JSON actual.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Number" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>
        <see langword="true" /> si el número puede representarse como <see cref="T:System.UInt64" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.ValueEquals(System.ReadOnlySpan{System.Byte})">
      <summary>Compara el texto representado por un intervalo de bytes codificado en UTF8 con el valor de cadena de este elemento.</summary>
      <param name="utf8Text">El texto con codificación UTF-8 con el que se va a comparar.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.String" />.</exception>
      <returns>
        <see langword="true" /> si el valor de cadena de este elemento tiene la misma codificación UTF-8 que <paramref name="utf8Text" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.ValueEquals(System.ReadOnlySpan{System.Char})">
      <summary>Compara un intervalo de cadena de solo lectura especificado con el valor de cadena de este elemento.</summary>
      <param name="text">El texto que se va a comparar.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.String" />.</exception>
      <returns>
        <see langword="true" /> si el valor de cadena de este elemento coincide con <paramref name="text" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.ValueEquals(System.String)">
      <summary>Compara una cadena especificada con el valor de cadena de este elemento.</summary>
      <param name="text">El texto que se va a comparar.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.String" />.</exception>
      <returns>
        <see langword="true" /> si el valor de cadena de este elemento coincide con <paramref name="text" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.WriteTo(System.Text.Json.Utf8JsonWriter)">
      <summary>Escribe el elemento en el escritor especificado como un valor JSON.</summary>
      <param name="writer">Escritor en el que se va a escribir el elemento.</param>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="writer" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor es <see cref="F:System.Text.Json.JsonValueKind.Undefined" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
    </member>
    <member name="P:System.Text.Json.JsonElement.Item(System.Int32)">
      <summary>Obtiene el valor en el índice especificado si el valor actual es un objeto <see cref="F:System.Text.Json.JsonValueKind.Array" />.</summary>
      <param name="index">Índice del elemento.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.ValueKind" /> de este valor no es <see cref="F:System.Text.Json.JsonValueKind.Array" />.</exception>
      <exception cref="T:System.IndexOutOfRangeException">
        <paramref name="index" /> no está en el rango [0, <see cref="M:System.Text.Json.JsonElement.GetArrayLength" />()).</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Valor en el índice especificado.</returns>
    </member>
    <member name="P:System.Text.Json.JsonElement.ValueKind">
      <summary>Obtiene el tipo del valor JSON actual.</summary>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      <returns>Tipo del valor JSON actual.</returns>
    </member>
    <member name="T:System.Text.Json.JsonElement.ArrayEnumerator">
      <summary>Representa un enumerador del contenido de una matriz JSON.</summary>
    </member>
    <member name="M:System.Text.Json.JsonElement.ArrayEnumerator.Dispose">
      <summary>Libera los recursos que usa la instancia <see cref="T:System.Text.Json.JsonElement.ArrayEnumerator" />.</summary>
    </member>
    <member name="M:System.Text.Json.JsonElement.ArrayEnumerator.GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Un enumerador que se puede usar para iterar por la matriz.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.ArrayEnumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.ArrayEnumerator.Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Text.Json.JsonElement.ArrayEnumerator.System#Collections#Generic#IEnumerable{System#Text#Json#JsonElement}#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Un enumerado de una matriz de <see cref="T:System.Text.Json.JsonElement" /> que se puede usar para iterar a través de la colección.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.ArrayEnumerator.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Text.Json.JsonElement.ArrayEnumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Text.Json.JsonElement.ArrayEnumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Text.Json.JsonElement.ObjectEnumerator">
      <summary>Representa un enumerador de las propiedades de un objeto JSON.</summary>
    </member>
    <member name="M:System.Text.Json.JsonElement.ObjectEnumerator.Dispose">
      <summary>Libera los recursos que usa la instancia <see cref="T:System.Text.Json.JsonElement.ObjectEnumerator" />.</summary>
    </member>
    <member name="M:System.Text.Json.JsonElement.ObjectEnumerator.GetEnumerator">
      <summary>Devuelve un enumerador que itera las propiedades de un objeto.</summary>
      <returns>Enumerador que se puede utilizar para iterar el objeto.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.ObjectEnumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección.</summary>
      <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.ObjectEnumerator.Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
    </member>
    <member name="M:System.Text.Json.JsonElement.ObjectEnumerator.System#Collections#Generic#IEnumerable{System#Text#Json#JsonProperty}#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Enumerador de objetos <see cref="T:System.Text.Json.JsonProperty" /> que se puede usar para iterar por la colección.</returns>
    </member>
    <member name="M:System.Text.Json.JsonElement.ObjectEnumerator.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración la colección.</returns>
    </member>
    <member name="P:System.Text.Json.JsonElement.ObjectEnumerator.Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="P:System.Text.Json.JsonElement.ObjectEnumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección en la posición actual del enumerador.</returns>
    </member>
    <member name="T:System.Text.Json.JsonEncodedText">
      <summary>Proporciona métodos para transformar el texto con codificación UTF-8 o UTF-16 en un formato adecuado para JSON.</summary>
    </member>
    <member name="M:System.Text.Json.JsonEncodedText.Encode(System.ReadOnlySpan{System.Byte},System.Text.Encodings.Web.JavaScriptEncoder)">
      <summary>Codifica un valor de texto UTF-8 como cadena JSON.</summary>
      <param name="utf8Value">Texto codificado en UTF-8 que se va a convertir en texto codificado en JSON.</param>
      <param name="encoder">El codificador que se va a utilizar al escapar la cadena, o bien <see langword="null" /> para usar el codificador predeterminado.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="utf8Value" /> es demasiado grande.

O bien

<paramref name="utf8Value" /> contiene bytes UTF-8 no válidos.</exception>
      <returns>Texto JSON codificado.</returns>
    </member>
    <member name="M:System.Text.Json.JsonEncodedText.Encode(System.ReadOnlySpan{System.Char},System.Text.Encodings.Web.JavaScriptEncoder)">
      <summary>Codifica un valor de texto especificado como cadena JSON.</summary>
      <param name="value">Valor que se va a convertir en texto codificado en JSON.</param>
      <param name="encoder">El codificador que se va a utilizar al escapar la cadena, o bien <see langword="null" /> para usar el codificador predeterminado.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> es demasiado grande.

O bien

<paramref name="value" /> contiene caracteres UTF-16 no válidos.</exception>
      <returns>Texto JSON codificado.</returns>
    </member>
    <member name="M:System.Text.Json.JsonEncodedText.Encode(System.String,System.Text.Encodings.Web.JavaScriptEncoder)">
      <summary>Codifica el valor del texto de cadena como cadena JSON.</summary>
      <param name="value">Valor que se va a convertir en texto codificado en JSON.</param>
      <param name="encoder">El codificador que se va a utilizar al escapar la cadena, o bien <see langword="null" /> para usar el codificador predeterminado.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> es demasiado grande.

O bien

<paramref name="value" /> contiene caracteres UTF-16 no válidos.</exception>
      <returns>Texto JSON codificado.</returns>
    </member>
    <member name="M:System.Text.Json.JsonEncodedText.Equals(System.Object)">
      <summary>Determina si esta instancia y un objeto especificado, que también debe ser una instancia <see cref="T:System.Text.Json.JsonEncodedText" />, tienen el mismo valor.</summary>
      <param name="obj">Objeto que se va a comparar con esta instancia.</param>
      <returns>
        <see langword="true" /> si la instancia actual y <paramref name="obj" /> son iguales; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonEncodedText.Equals(System.Text.Json.JsonEncodedText)">
      <summary>Determina si esta instancia y otra instancia <see cref="T:System.Text.Json.JsonEncodedText" /> especificada tienen el mismo valor.</summary>
      <param name="other">Objeto que se va a comparar con esta instancia.</param>
      <returns>
        <see langword="true" /> si esta instancia <paramref name="other" /> tienen el mismo valor; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonEncodedText.GetHashCode">
      <summary>Devuelve el código hash de este objeto <see cref="T:System.Text.Json.JsonEncodedText" />.</summary>
      <returns>Código hash de esta instancia.</returns>
    </member>
    <member name="M:System.Text.Json.JsonEncodedText.ToString">
      <summary>Convierte el valor de la instancia en un objeto <see cref="T:System.String" />.</summary>
      <returns>Cadena con codificación UTF-16 subyacente.</returns>
    </member>
    <member name="P:System.Text.Json.JsonEncodedText.EncodedUtf8Bytes">
      <summary>Obtiene la representación codificada en UTF-8 del texto JSON codificado previamente.</summary>
      <returns>Representación codificada en UTF-8 del texto JSON codificado previamente.</returns>
    </member>
    <member name="T:System.Text.Json.JsonException">
      <summary>Define un objeto de excepción personalizado que se produce cuando se encuentra texto JSON no válido, cuando se pasa la profundidad máxima definida o el texto JSON no es compatible con el tipo de una propiedad en un objeto.</summary>
    </member>
    <member name="M:System.Text.Json.JsonException.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.Json.JsonException" />.</summary>
    </member>
    <member name="M:System.Text.Json.JsonException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Crea un nuevo objeto de excepción con datos serializados.</summary>
      <param name="info">Datos serializados del objeto sobre la excepción producida.</param>
      <param name="context">Un objeto que contiene información contextual sobre el origen o el destino.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="info" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Text.Json.JsonException.#ctor(System.String)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.Json.JsonException" /> con el mensaje de error especificado.</summary>
      <param name="message">Mensaje de error específico del contexto.</param>
    </member>
    <member name="M:System.Text.Json.JsonException.#ctor(System.String,System.Exception)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.Json.JsonException" />, con un mensaje de error especificado y una referencia a la excepción interna que representa la causa de esta excepción.</summary>
      <param name="message">Mensaje de error específico del contexto.</param>
      <param name="innerException">Excepción que ha producido la excepción actual.</param>
    </member>
    <member name="M:System.Text.Json.JsonException.#ctor(System.String,System.String,System.Nullable{System.Int64},System.Nullable{System.Int64})">
      <summary>Crea un objeto de excepción para retransmitir información de error al usuario.</summary>
      <param name="message">Mensaje de error específico del contexto.</param>
      <param name="path">La ruta de acceso donde se encontró el JSON no válido.</param>
      <param name="lineNumber">Número de línea (a partir de 0) en el que se ha encontrado el código JSON no válido al deserializar.</param>
      <param name="bytePositionInLine">Recuento de bytes en la línea actual (a partir de 0) donde se ha detectado el código JSON no válido.</param>
    </member>
    <member name="M:System.Text.Json.JsonException.#ctor(System.String,System.String,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Exception)">
      <summary>Crea un objeto de excepción para retransmitir información de error al usuario, incluida una excepción interna especificada.</summary>
      <param name="message">Mensaje de error específico del contexto.</param>
      <param name="path">La ruta de acceso donde se encontró el JSON no válido.</param>
      <param name="lineNumber">Número de línea (a partir de 0) en el que se ha encontrado el código JSON no válido al deserializar.</param>
      <param name="bytePositionInLine">Recuento de bytes (a partir de 0) en la línea actual donde se ha detectado el código JSON no válido.</param>
      <param name="innerException">Excepción que ha producido la excepción actual.</param>
    </member>
    <member name="M:System.Text.Json.JsonException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Establece el objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> con información sobre la excepción.</summary>
      <param name="info">Datos serializados del objeto sobre la excepción producida.</param>
      <param name="context">Un objeto que contiene información contextual sobre el origen o el destino.</param>
    </member>
    <member name="P:System.Text.Json.JsonException.BytePositionInLine">
      <summary>Obtiene el número de base cero de bytes leídos en la línea actual antes de la excepción.</summary>
      <returns>Número de bytes de base cero leídos en la línea actual antes de la excepción.</returns>
    </member>
    <member name="P:System.Text.Json.JsonException.LineNumber">
      <summary>Obtiene el número de base cero de líneas leídas antes de la excepción.</summary>
      <returns>Número de líneas de base cero leídas antes de la excepción.</returns>
    </member>
    <member name="P:System.Text.Json.JsonException.Message">
      <summary>Obtiene un mensaje que describe la excepción actual.</summary>
      <returns>Mensaje de error que describe la excepción actual.</returns>
    </member>
    <member name="P:System.Text.Json.JsonException.Path">
      <summary>Obtiene la ruta de acceso dentro del código JSON donde se encontró la excepción.</summary>
      <returns>Ruta de acceso dentro del código JSON donde se encontró la excepción.</returns>
    </member>
    <member name="T:System.Text.Json.JsonNamingPolicy">
      <summary>Determina la directiva de nomenclatura que se usa para convertir un nombre basado en cadena a otro formato, como, por ejemplo, un formato en notación camello.</summary>
    </member>
    <member name="M:System.Text.Json.JsonNamingPolicy.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.Json.JsonNamingPolicy" />.</summary>
    </member>
    <member name="M:System.Text.Json.JsonNamingPolicy.ConvertName(System.String)">
      <summary>Si se reemplaza en una clase derivada, convierte el nombre especificado de acuerdo con la directiva.</summary>
      <param name="name">El nombre que se va a convertir.</param>
      <returns>El nombre convertido.</returns>
    </member>
    <member name="P:System.Text.Json.JsonNamingPolicy.CamelCase">
      <summary>Obtiene la directiva de nomenclatura para la notación camello.</summary>
      <returns>La Directiva de nomenclatura para las mayúsculas y minúsculas Camel.</returns>
    </member>
    <member name="T:System.Text.Json.JsonProperty">
      <summary>Representa una sola propiedad de un objeto JSON.</summary>
    </member>
    <member name="M:System.Text.Json.JsonProperty.NameEquals(System.ReadOnlySpan{System.Byte})">
      <summary>Compara el texto con codificación UTF-8 especificado con el nombre de esta propiedad.</summary>
      <param name="utf8Text">El texto con codificación UTF-8 con el que se va a comparar.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="T:System.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />.</exception>
      <returns>
        <see langword="true" /> si el nombre de esta propiedad tiene la misma codificación UTF-8 que <paramref name="utf8Text" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonProperty.NameEquals(System.ReadOnlySpan{System.Char})">
      <summary>Compara el texto especificado como un intervalo de caracteres con el nombre de esta propiedad.</summary>
      <param name="text">El texto que se va a comparar.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="T:System.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />.</exception>
      <returns>
        <see langword="true" /> si el nombre de esta propiedad coincide con <paramref name="text" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonProperty.NameEquals(System.String)">
      <summary>Compara la cadena especificada con el nombre de esta propiedad.</summary>
      <param name="text">El texto que se va a comparar.</param>
      <exception cref="T:System.InvalidOperationException">El elemento <see cref="T:System.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />.</exception>
      <returns>
        <see langword="true" /> si el nombre de esta propiedad coincide con <paramref name="text" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.JsonProperty.ToString">
      <summary>Proporciona una representación de cadena de la propiedad con fines de depuración.</summary>
      <returns>Cadena que contiene el valor no interpretado de la propiedad, que comienza por el tipo declarativo open-quote y termina en el último carácter que forma parte del valor.</returns>
    </member>
    <member name="M:System.Text.Json.JsonProperty.WriteTo(System.Text.Json.Utf8JsonWriter)">
      <summary>Escribe la propiedad en el escritor proporcionado como una propiedad de objeto JSON con nombre.</summary>
      <param name="writer">Escritor en el que se va a escribir la propiedad.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="writer" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <see cref="P:System.Text.Json.JsonProperty.Name" /> es demasiado grande para ser una propiedad de objeto JSON.</exception>
      <exception cref="T:System.InvalidOperationException">El <see cref="P:System.Text.Json.JsonElement.ValueKind" /> del valor <see cref="P:System.Text.Json.JsonProperty.Value" /> de esta propiedad JSON daría como resultado un JSON no válido.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
    </member>
    <member name="P:System.Text.Json.JsonProperty.Name">
      <summary>Obtiene el nombre de esta propiedad.</summary>
      <returns>Nombre de esta propiedad.</returns>
    </member>
    <member name="P:System.Text.Json.JsonProperty.Value">
      <summary>Obtiene el valor de esta propiedad.</summary>
      <returns>Valor de esta propiedad.</returns>
    </member>
    <member name="T:System.Text.Json.JsonReaderOptions">
      <summary>Proporciona la capacidad de que el usuario defina el comportamiento personalizado al leer JSON.</summary>
    </member>
    <member name="P:System.Text.Json.JsonReaderOptions.AllowTrailingCommas">
      <summary>Obtiene o establece un valor que define si se permite (y se ignora) una coma adicional al final de una lista de valores JSON en un objeto o una matriz dentro de la carga de JSON que se lee.</summary>
      <returns>
        <see langword="true" /> Si se permite una coma adicional; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Text.Json.JsonReaderOptions.CommentHandling">
      <summary>Obtiene o establece un valor que determina cómo <see cref="T:System.Text.Json.Utf8JsonReader" /> controla los comentarios al leer los datos JSON.</summary>
      <exception cref="T:System.ArgumentOutOfRangeException">La propiedad se establece en un valor que no es miembro de la enumeración <see cref="T:System.Text.Json.JsonCommentHandling" />.</exception>
      <returns>Uno de los valores de enumeración que indica cómo se controlan los comentarios.</returns>
    </member>
    <member name="P:System.Text.Json.JsonReaderOptions.MaxDepth">
      <summary>Obtiene o establece la profundidad máxima permitida al leer JSON, y el valor predeterminado (es decir, 0) indica una profundidad máxima de 64.</summary>
      <exception cref="T:System.ArgumentOutOfRangeException">La profundidad máxima se establece en un valor negativo.</exception>
      <returns>Profundidad máxima permitida al leer JSON.</returns>
    </member>
    <member name="T:System.Text.Json.JsonReaderState">
      <summary>Define un tipo opaco que contiene y guarda toda la información de estado relevante, que se debe proporcionar a <see cref="T:System.Text.Json.Utf8JsonReader" /> para continuar leyendo después de procesar los datos incompletos.</summary>
    </member>
    <member name="M:System.Text.Json.JsonReaderState.#ctor(System.Text.Json.JsonReaderOptions)">
      <summary>Crea una instancia de <see cref="T:System.Text.Json.JsonReaderState" />.</summary>
      <param name="options">Define el comportamiento personalizado de la <see cref="T:System.Text.Json.Utf8JsonReader" /> que es diferente de la JSON RFC (por ejemplo, cómo controlar los comentarios o la profundidad máxima permitida durante la lectura). De forma predeterminada, la <see cref="T:System.Text.Json.Utf8JsonReader" /> sigue estrictamente la JSON RFC (los comentarios en JSON no son válidos) y lee hasta una profundidad máxima de 64.</param>
      <exception cref="T:System.ArgumentException">La profundidad máxima se establece en un valor no positivo (&lt; 0).</exception>
    </member>
    <member name="P:System.Text.Json.JsonReaderState.Options">
      <summary>Obtiene el comportamiento personalizado que se va a usar cuando la lectura de datos JSON mediante la estructura <see cref="T:System.Text.Json.Utf8JsonReader" /> pueda desviarse del cumplimiento estricto de la especificación de JSON, que es el comportamiento predeterminado.</summary>
      <returns>Comportamiento personalizado que se va a usar al leer datos JSON.</returns>
    </member>
    <member name="T:System.Text.Json.JsonSerializer">
      <summary>Proporciona funcionalidad para serializar objetos o tipos de valor en JSON y para deserializar JSON en objetos o tipos de valor.</summary>
    </member>
    <member name="M:System.Text.Json.JsonSerializer.Deserialize(System.ReadOnlySpan{System.Byte},System.Type,System.Text.Json.JsonSerializerOptions)">
      <summary>Analiza el texto con codificación UTF-8 que representa un único valor JSON en una instancia de un tipo especificado.</summary>
      <param name="utf8Json">Texto JSON que se va a analizar.</param>
      <param name="returnType">Tipo del objeto al que se va a convertir y devolver.</param>
      <param name="options">Opciones para controlar el comportamiento durante el análisis.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="returnType" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Text.Json.JsonException">El JSON no es válido.

o bien

<typeparamref name="returnType" /> no es compatible con el JSON.

o bien

Hay datos restantes en el intervalo más allá de un único valor JSON.</exception>
      <exception cref="T:System.NotSupportedException">No hay ningún <see cref="System.Text.Json.Serialization.JsonConverter" /> compatible para <paramref name="returnType" /> o sus miembros serializables.</exception>
      <returns>Representación <paramref name="returnType" /> del valor JSON.</returns>
    </member>
    <member name="M:System.Text.Json.JsonSerializer.Deserialize(System.String,System.Type,System.Text.Json.JsonSerializerOptions)">
      <summary>Analiza el texto que representa un único valor JSON en una instancia de un tipo especificado.</summary>
      <param name="json">Texto JSON que se va a analizar.</param>
      <param name="returnType">Tipo del objeto al que se va a convertir y devolver.</param>
      <param name="options">Opciones para controlar el comportamiento durante el análisis.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="json" /> o <paramref name="returnType" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Text.Json.JsonException">El JSON no es válido.
          
o bien

<typeparamref name="TValue" /> no es compatible con el JSON.

o bien

Hay datos restantes en el intervalo más allá de un único valor JSON.</exception>
      <exception cref="T:System.NotSupportedException">No hay ningún <see cref="System.Text.Json.Serialization.JsonConverter" /> compatible para <paramref name="returnType" /> o sus miembros serializables.</exception>
      <returns>Representación <paramref name="returnType" /> del valor JSON.</returns>
    </member>
    <member name="M:System.Text.Json.JsonSerializer.Deserialize(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
      <summary>Lee un valor JSON (incluidos objetos o matrices) desde el lector proporcionado y lo convierte en una instancia del tipo especificado.</summary>
      <param name="reader">Lector desde el que se va a leer el JSON.</param>
      <param name="returnType">Tipo del objeto al que se va a convertir y devolver.</param>
      <param name="options">Opciones para controlar el comportamiento del serializador durante la lectura.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="returnType" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Text.Json.JsonException">El JSON no es válido.
          
o bien

<typeparamref name="returnType" /> no es compatible con el JSON.

o bien

No se pudo leer un valor del lector.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="reader" /> usa opciones no compatibles.</exception>
      <exception cref="T:System.NotSupportedException">No hay ningún <see cref="System.Text.Json.Serialization.JsonConverter" /> compatible para <paramref name="returnType" /> o sus miembros serializables.</exception>
      <returns>Representación <paramref name="returnType" /> del valor JSON.</returns>
    </member>
    <member name="M:System.Text.Json.JsonSerializer.Deserialize``1(System.ReadOnlySpan{System.Byte},System.Text.Json.JsonSerializerOptions)">
      <summary>Analiza el texto con codificación UTF-8 que representa un único valor JSON en una instancia del tipo especificado por un parámetro de tipo genérico.</summary>
      <param name="utf8Json">Texto JSON que se va a analizar.</param>
      <param name="options">Opciones para controlar el comportamiento durante el análisis.</param>
      <typeparam name="TValue">Tipo de destino del texto con codificación UTF-8.</typeparam>
      <exception cref="T:System.Text.Json.JsonException">El JSON no es válido.

o bien

<typeparamref name="TValue" /> no es compatible con el JSON.

o bien

Hay datos restantes en el intervalo más allá de un único valor JSON.</exception>
      <exception cref="T:System.NotSupportedException">No hay ningún <see cref="System.Text.Json.Serialization.JsonConverter" /> compatible para <typeparamref name="TValue" /> o sus miembros serializables.</exception>
      <returns>Representación <typeparamref name="TValue" /> del valor JSON.</returns>
    </member>
    <member name="M:System.Text.Json.JsonSerializer.Deserialize``1(System.String,System.Text.Json.JsonSerializerOptions)">
      <summary>Analiza el texto que representa un único valor JSON en una instancia del tipo especificado por un parámetro de tipo genérico.</summary>
      <param name="json">Texto JSON que se va a analizar.</param>
      <param name="options">Opciones para controlar el comportamiento durante el análisis.</param>
      <typeparam name="TValue">Tipo de destino del valor JSON.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="json" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Text.Json.JsonException">El JSON no es válido.

o bien

<typeparamref name="TValue" /> no es compatible con el JSON.

o bien

Hay datos restantes en el intervalo más allá de un único valor JSON.</exception>
      <exception cref="T:System.NotSupportedException">No hay ningún <see cref="System.Text.Json.Serialization.JsonConverter" /> compatible para <typeparamref name="TValue" /> o sus miembros serializables.</exception>
      <returns>Representación <typeparamref name="TValue" /> del valor JSON.</returns>
    </member>
    <member name="M:System.Text.Json.JsonSerializer.Deserialize``1(System.Text.Json.Utf8JsonReader@,System.Text.Json.JsonSerializerOptions)">
      <summary>Lee un valor JSON (incluidos objetos o matrices) desde el lector proporcionado en una instancia del tipo especificado por un parámetro de tipo genérico.</summary>
      <param name="reader">Lector desde el que se va a leer el JSON.</param>
      <param name="options">Opciones para controlar el comportamiento del serializador durante la lectura.</param>
      <typeparam name="TValue">Tipo de destino del valor JSON.</typeparam>
      <exception cref="T:System.Text.Json.JsonException">El JSON no es válido.

o bien

<typeparamref name="TValue" /> no es compatible con el JSON.

o bien

No se pudo leer un valor del lector.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="reader" /> usa opciones no compatibles.</exception>
      <exception cref="T:System.NotSupportedException">No hay ningún <see cref="System.Text.Json.Serialization.JsonConverter" /> compatible para <typeparamref name="TValue" /> o sus miembros serializables.</exception>
      <returns>Representación <typeparamref name="TValue" /> del valor JSON.</returns>
    </member>
    <member name="M:System.Text.Json.JsonSerializer.DeserializeAsync(System.IO.Stream,System.Type,System.Text.Json.JsonSerializerOptions,System.Threading.CancellationToken)">
      <summary>Lee asincrónicamente el texto con codificación UTF-8 que representa un único valor JSON en una instancia de un tipo especificado. La secuencia se lee hasta su finalización.</summary>
      <param name="utf8Json">Datos JSON que se van a analizar.</param>
      <param name="returnType">Tipo del objeto al que se va a convertir y devolver.</param>
      <param name="options">Opciones para controlar el comportamiento durante la lectura.</param>
      <param name="cancellationToken">Token de cancelación que puede usarse para cancelar la operación de lectura.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="utf8Json" /> o <paramref name="returnType" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Text.Json.JsonException">El JSON no es válido.

o bien

<typeparamref name="TValue" /> no es compatible con el JSON.

o bien

Hay datos restantes en la secuencia.</exception>
      <exception cref="T:System.NotSupportedException">No hay ningún <see cref="System.Text.Json.Serialization.JsonConverter" /> compatible para <paramref name="returnType" /> o sus miembros serializables.</exception>
      <returns>Representación <paramref name="returnType" /> del valor JSON.</returns>
    </member>
    <member name="M:System.Text.Json.JsonSerializer.DeserializeAsync``1(System.IO.Stream,System.Text.Json.JsonSerializerOptions,System.Threading.CancellationToken)">
      <summary>Lee asincrónicamente el texto con codificación UTF-8 que representa un único valor JSON en una instancia de un tipo especificado por un parámetro de tipo genérico. La secuencia se lee hasta su finalización.</summary>
      <param name="utf8Json">Datos JSON que se van a analizar.</param>
      <param name="options">Opciones para controlar el comportamiento durante la lectura.</param>
      <param name="cancellationToken">Token que puede usarse para cancelar la operación de lectura.</param>
      <typeparam name="TValue">Tipo de destino del valor JSON.</typeparam>
      <exception cref="T:System.Text.Json.JsonException">El JSON no es válido.

o bien

<typeparamref name="TValue" /> no es compatible con el JSON.

o bien

Hay datos restantes en la secuencia.</exception>
      <exception cref="T:System.NotSupportedException">No hay ningún <see cref="System.Text.Json.Serialization.JsonConverter" /> compatible para <typeparamref name="TValue" /> o sus miembros serializables.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="utf8Json" /> es <see langword="null" />.</exception>
      <returns>Representación <typeparamref name="TValue" /> del valor JSON.</returns>
    </member>
    <member name="M:System.Text.Json.JsonSerializer.Serialize(System.Object,System.Type,System.Text.Json.JsonSerializerOptions)">
      <summary>Convierte el valor de un tipo especificado en una cadena JSON.</summary>
      <param name="value">Valor que se va a convertir.</param>
      <param name="inputType">Tipo de <paramref name="value" /> que se va a convertir.</param>
      <param name="options">Opciones para controlar el comportamiento de la conversión.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="inputType" /> no es compatible con <paramref name="value" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="inputType" /> es <see langword="null" />.</exception>
      <exception cref="T:System.NotSupportedException">No hay ningún <see cref="System.Text.Json.Serialization.JsonConverter" /> compatible para <paramref name="inputType" /> o sus miembros serializables.</exception>
      <returns>Representación de cadena JSON del valor.</returns>
    </member>
    <member name="M:System.Text.Json.JsonSerializer.Serialize(System.Text.Json.Utf8JsonWriter,System.Object,System.Type,System.Text.Json.JsonSerializerOptions)">
      <summary>Escribe la representación JSON del tipo especificado en el sistema de escritura proporcionado.</summary>
      <param name="writer">Sistema de escritura JSON en el que se va a escribir.</param>
      <param name="value">Valor que se va a convertir y leer.</param>
      <param name="inputType">Tipo de <paramref name="value" /> que se va a convertir.</param>
      <param name="options">Opciones para controlar el comportamiento de la serialización.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="inputType" /> no es compatible con <paramref name="value" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="writer" /> o <paramref name="inputType" /> es <see langword="null" />.</exception>
      <exception cref="T:System.NotSupportedException">No hay ningún <see cref="System.Text.Json.Serialization.JsonConverter" /> compatible para <paramref name="inputType" /> o sus miembros serializables.</exception>
    </member>
    <member name="M:System.Text.Json.JsonSerializer.Serialize``1(``0,System.Text.Json.JsonSerializerOptions)">
      <summary>Convierte el valor de un tipo especificado por un parámetro de tipo genérico en una cadena JSON.</summary>
      <param name="value">Valor que se va a convertir.</param>
      <param name="options">Opciones para controlar el comportamiento de la serialización.</param>
      <typeparam name="TValue">Tipo del valor que se va a serializar.</typeparam>
      <exception cref="T:System.NotSupportedException">No hay ningún <see cref="System.Text.Json.Serialization.JsonConverter" /> compatible para <typeparamref name="TValue" /> o sus miembros serializables.</exception>
      <returns>Una representación de cadena JSON del valor.</returns>
    </member>
    <member name="M:System.Text.Json.JsonSerializer.Serialize``1(System.Text.Json.Utf8JsonWriter,``0,System.Text.Json.JsonSerializerOptions)">
      <summary>Escribe la representación JSON de un tipo especificado por un parámetro de tipo genérico en el sistema de escritura proporcionado.</summary>
      <param name="writer">Un sistema de escritura JSON en el que se va a escribir.</param>
      <param name="value">Valor que se va a convertir y leer.</param>
      <param name="options">Opciones para controlar el comportamiento de la serialización.</param>
      <typeparam name="TValue">Tipo del valor que se va a serializar.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="writer" /> es <see langword="null" />.</exception>
      <exception cref="T:System.NotSupportedException">No hay ningún <see cref="System.Text.Json.Serialization.JsonConverter" /> compatible para <typeparamref name="TValue" /> o sus miembros serializables.</exception>
    </member>
    <member name="M:System.Text.Json.JsonSerializer.SerializeAsync(System.IO.Stream,System.Object,System.Type,System.Text.Json.JsonSerializerOptions,System.Threading.CancellationToken)">
      <summary>Convierte de forma asincrónica el valor de un tipo especificado en texto JSON con codificación UTF-8 y lo escribe en la secuencia especificada.</summary>
      <param name="utf8Json">Secuencia con codificación UTF-8 en la que se va a escribir.</param>
      <param name="value">Valor que se va a convertir.</param>
      <param name="inputType">Tipo de <paramref name="value" /> que se va a convertir.</param>
      <param name="options">Opciones para controlar el comportamiento de la serialización.</param>
      <param name="cancellationToken">Token que puede usarse para cancelar la operación de escritura.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="inputType" /> no es compatible con <paramref name="value" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="utf8Json" /> o <paramref name="inputType" /> es <see langword="null" />.</exception>
      <exception cref="T:System.NotSupportedException">No hay ningún <see cref="System.Text.Json.Serialization.JsonConverter" /> compatible para <paramref name="inputType" /> o sus miembros serializables.</exception>
      <returns>Tarea que representa la operación de escritura asincrónica.</returns>
    </member>
    <member name="M:System.Text.Json.JsonSerializer.SerializeAsync``1(System.IO.Stream,``0,System.Text.Json.JsonSerializerOptions,System.Threading.CancellationToken)">
      <summary>Convierte de forma asincrónica un valor de un tipo especificado por un parámetro de tipo genérico a texto JSON con codificación UTF-8 y lo escribe en una secuencia.</summary>
      <param name="utf8Json">Secuencia con codificación UTF-8 en la que se va a escribir.</param>
      <param name="value">Valor que se va a convertir.</param>
      <param name="options">Opciones para controlar el comportamiento de la serialización.</param>
      <param name="cancellationToken">Token que puede usarse para cancelar la operación de escritura.</param>
      <typeparam name="TValue">Tipo del valor que se va a serializar.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="utf8Json" /> es <see langword="null" />.</exception>
      <exception cref="T:System.NotSupportedException">No hay ningún <see cref="System.Text.Json.Serialization.JsonConverter" /> compatible para <typeparamref name="TValue" /> o sus miembros serializables.</exception>
      <returns>Tarea que representa la operación de escritura asincrónica.</returns>
    </member>
    <member name="M:System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(System.Object,System.Type,System.Text.Json.JsonSerializerOptions)">
      <summary>Convierte un valor del tipo especificado en una cadena JSON, codificada como bytes UTF-8.</summary>
      <param name="value">Valor que se va a convertir.</param>
      <param name="inputType">Tipo de <paramref name="value" /> que se va a convertir.</param>
      <param name="options">Opciones para controlar el comportamiento de la conversión.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="inputType" /> no es compatible con <paramref name="value" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="inputType" /> es <see langword="null" />.</exception>
      <exception cref="T:System.NotSupportedException">No hay ningún <see cref="System.Text.Json.Serialization.JsonConverter" /> compatible para <paramref name="inputType" /> o sus miembros serializables.</exception>
      <returns>Una representación de cadena JSON del valor, codificada como bytes UTF-8.</returns>
    </member>
    <member name="M:System.Text.Json.JsonSerializer.SerializeToUtf8Bytes``1(``0,System.Text.Json.JsonSerializerOptions)">
      <summary>Convierte el valor de un tipo especificado por un parámetro de tipo genérico en una cadena JSON, codificada como bytes UTF-8.</summary>
      <param name="value">Valor que se va a convertir.</param>
      <param name="options">Opciones para controlar el comportamiento de la conversión.</param>
      <typeparam name="TValue">Tipo del valor.</typeparam>
      <exception cref="T:System.NotSupportedException">No hay ningún <see cref="System.Text.Json.Serialization.JsonConverter" /> compatible para <typeparamref name="TValue" /> o sus miembros serializables.</exception>
      <returns>Una representación de cadena JSON del valor, codificada como bytes UTF-8.</returns>
    </member>
    <member name="T:System.Text.Json.JsonSerializerDefaults">
      <summary>Especifica las opciones predeterminadas que usa <see cref="T:System.Text.Json.JsonSerializerOptions" />.</summary>
    </member>
    <member name="F:System.Text.Json.JsonSerializerDefaults.General">
      <summary>Especifica que se deben usar los valores de uso general. Se trata de la misma configuración que se aplica si <see cref="T:System.Text.Json.JsonSerializerDefaults" /> no se especifica.</summary>
    </member>
    <member name="F:System.Text.Json.JsonSerializerDefaults.Web">
      <summary>Especifica que los valores se deben usar de forma más adecuada para escenarios basados en Web.</summary>
    </member>
    <member name="T:System.Text.Json.JsonSerializerOptions">
      <summary>Proporciona las opciones que se usarán con <see cref="T:System.Text.Json.JsonSerializer" />.</summary>
    </member>
    <member name="M:System.Text.Json.JsonSerializerOptions.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.Json.JsonSerializerOptions" />.</summary>
    </member>
    <member name="M:System.Text.Json.JsonSerializerOptions.#ctor(System.Text.Json.JsonSerializerDefaults)">
      <summary>Construye una instancia nueva de <see cref="T:System.Text.Json.JsonSerializerOptions" /> con un conjunto predefinido de opciones que determina el elemento <see cref="T:System.Text.Json.JsonSerializerDefaults" /> especificado.</summary>
      <param name="defaults">
        <see cref="T:System.Text.Json.JsonSerializerDefaults" /> sobre el que se va a razonar.</param>
    </member>
    <member name="M:System.Text.Json.JsonSerializerOptions.#ctor(System.Text.Json.JsonSerializerOptions)">
      <summary>Copia las opciones de una instancia de <see cref="T:System.Text.Json.JsonSerializerOptions" /> en una nueva instancia.</summary>
      <param name="options">Instancia de opciones de la que se van a copiar opciones.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="options" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Text.Json.JsonSerializerOptions.GetConverter(System.Type)">
      <summary>Devuelve el convertidor para el tipo especificado.</summary>
      <param name="typeToConvert">El tipo para el que se va a devolver un convertidor.</param>
      <exception cref="T:System.InvalidOperationException">El objeto <see cref="System.Text.Json.Serialization.JsonConverter" /> configurado para <paramref name="typeToConvert" /> devolvió un convertidor no válido.</exception>
      <exception cref="T:System.NotSupportedException">No hay ningún <see cref="System.Text.Json.Serialization.JsonConverter" /> compatible para <paramref name="typeToConvert" /> o sus miembros serializables.</exception>
      <returns>El primer convertidor que admite el tipo especificado o <see langword="null" />, si no hay convertidor.</returns>
    </member>
    <member name="P:System.Text.Json.JsonSerializerOptions.AllowTrailingCommas">
      <summary>Obtiene o establece un valor que indica si se permite (y se ignora) una coma adicional al final de una lista de valores JSON en un objeto o una matriz dentro de la carga de JSON que se deserializa.</summary>
      <exception cref="T:System.InvalidOperationException">Esta propiedad se estableció una vez que se completó la serialización o la deserialización.</exception>
      <returns>
        <see langword="true" /> es si se permite (y se omite) una coma adicional al final de una lista de valores JSON de un objeto o una matriz. <see langword="false" /> en caso contrario,.</returns>
    </member>
    <member name="P:System.Text.Json.JsonSerializerOptions.Converters">
      <summary>Obtiene la lista de convertidores definidos por el usuario que se registraron.</summary>
      <returns>Lista de convertidores personalizados.</returns>
    </member>
    <member name="P:System.Text.Json.JsonSerializerOptions.DefaultBufferSize">
      <summary>Obtiene o establece el tamaño de búfer predeterminado, en bytes, que se usará al crear búferes temporales.</summary>
      <exception cref="T:System.ArgumentException">El tamaño de búfer es menor que 1.</exception>
      <exception cref="T:System.InvalidOperationException">Esta propiedad se estableció una vez que se completó la serialización o la deserialización.</exception>
      <returns>Tamaño de búfer predeterminado en bytes.</returns>
    </member>
    <member name="P:System.Text.Json.JsonSerializerOptions.DefaultIgnoreCondition">
      <summary>Especifica una condición para determinar cuándo se omiten las propiedades con valores predeterminados durante la serialización o la deserialización.
El valor predeterminado es <see cref="F:System.Text.Json.Serialization.JsonIgnoreCondition.Never" />.</summary>
      <exception cref="T:System.ArgumentException">Esta propiedad se establece en <see cref="F:System.Text.Json.Serialization.JsonIgnoreCondition.Always" />.</exception>
      <exception cref="T:System.InvalidOperationException">Esta propiedad se establece después de que se haya realizado la serialización o la deserialización.

o bien

<see cref="P:System.Text.Json.JsonSerializerOptions.IgnoreNullValues" /> se ha establecido en <see langword="true" />. Estas propiedades no se pueden usar de forma conjunta.</exception>
    </member>
    <member name="P:System.Text.Json.JsonSerializerOptions.DictionaryKeyPolicy">
      <summary>Obtiene o establece la directiva que se usa para convertir el nombre de una clave <see cref="T:System.Collections.IDictionary" /> en otro formato, como la grafía Camel.</summary>
      <returns>La Directiva que se usa para convertir el <see cref="T:System.Collections.IDictionary" /> nombre de una clave en otro formato.</returns>
    </member>
    <member name="P:System.Text.Json.JsonSerializerOptions.Encoder">
      <summary>Obtiene o establece el codificador que se va a usar al escapar cadenas, o bien <see langword="null" /> para usar el codificador predeterminado.</summary>
      <returns>Codificación de caracteres de JavaScript.</returns>
    </member>
    <member name="P:System.Text.Json.JsonSerializerOptions.IgnoreNullValues">
      <summary>Obtiene o establece un valor que determina si los valores <see langword="null" /> se omiten durante la serialización y la deserialización. El valor predeterminado es <see langword="false" />.</summary>
      <exception cref="T:System.InvalidOperationException">Esta propiedad se estableció una vez que se completó la serialización o la deserialización.

o bien

<see cref="P:System.Text.Json.JsonSerializerOptions.DefaultIgnoreCondition" /> se ha establecido en un valor que no es el predeterminado. Estas propiedades no se pueden usar de forma conjunta.</exception>
      <returns>
        <see langword="true" /> para omitir los valores NULL durante la serialización y deserialización; en caso contrario, vea langword = "false"/ &gt; .</returns>
    </member>
    <member name="P:System.Text.Json.JsonSerializerOptions.IgnoreReadOnlyFields">
      <summary>Determina si los campos de solo lectura se omiten durante la serialización. Una propiedad es de solo lectura si no está marcada con la palabra clave <see langword="readonly" />. El valor predeterminado es <see langword="false" />.</summary>
      <exception cref="T:System.InvalidOperationException">Esta propiedad se establece después de que se haya realizado la serialización o la deserialización.</exception>
      <returns>
        <see langword="true" /> Si los campos de solo lectura deben omitirse durante la serialización; <see langword="false" /> en caso contrario,.</returns>
    </member>
    <member name="P:System.Text.Json.JsonSerializerOptions.IgnoreReadOnlyProperties">
      <summary>Obtiene un valor que determina si las propiedades de solo lectura se omiten durante la serialización. El valor predeterminado es <see langword="false" />.</summary>
      <exception cref="T:System.InvalidOperationException">Esta propiedad se estableció una vez que se completó la serialización o la deserialización.</exception>
      <returns>
        <see langword="true" /> para omitir las propiedades de solo lectura durante la serialización; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Text.Json.JsonSerializerOptions.IncludeFields">
      <summary>Determina si los campos se administran con serialización y deserialización.
El valor predeterminado es <see langword="false" />.</summary>
      <exception cref="T:System.InvalidOperationException">Esta propiedad se establece después de que se haya realizado la serialización o la deserialización.</exception>
    </member>
    <member name="P:System.Text.Json.JsonSerializerOptions.MaxDepth">
      <summary>Obtiene o establece la profundidad máxima permitida al serializar o deserializar JSON, con el valor predeterminado de 0 que indica una profundidad máxima de 64.</summary>
      <exception cref="T:System.InvalidOperationException">Esta propiedad se estableció una vez que se completó la serialización o la deserialización.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">La profundidad máxima está establecida en un valor negativo.</exception>
      <returns>La profundidad máxima permitida al serializar o deserializar JSON.</returns>
    </member>
    <member name="P:System.Text.Json.JsonSerializerOptions.NumberHandling">
      <summary>Especifica cómo se deben administrar los tipos de número en la serialización o deserialización.</summary>
      <exception cref="T:System.InvalidOperationException">Esta propiedad se establece después de que se haya realizado la serialización o la deserialización.</exception>
    </member>
    <member name="P:System.Text.Json.JsonSerializerOptions.PropertyNameCaseInsensitive">
      <summary>Obtiene o establece un valor que determina si el nombre de una propiedad usa una comparación que no distingue entre mayúsculas y minúsculas durante la deserialización. El valor predeterminado es <see langword="false" />.</summary>
      <returns>
        <see langword="true" /> para comparar los nombres de propiedad mediante la comparación sin distinción entre mayúsculas y minúsculas; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Text.Json.JsonSerializerOptions.PropertyNamingPolicy">
      <summary>Obtiene o establece un valor que especifica la directiva usada para convertir el nombre de una propiedad de un objeto en otro formato, como la grafía Camel, o <see langword="null" /> para no modificar los nombres de propiedad.</summary>
      <returns>Una directiva de nomenclatura de propiedades o <see langword="null" /> para dejar los nombres de propiedad sin cambios.</returns>
    </member>
    <member name="P:System.Text.Json.JsonSerializerOptions.ReadCommentHandling">
      <summary>Obtiene o establece un valor que define cómo se administran los comentarios durante la deserialización.</summary>
      <exception cref="T:System.InvalidOperationException">Esta propiedad se estableció una vez que se completó la serialización o la deserialización.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">La enumeración de control de comentarios se establece en un valor que no se admite (o que no se encuentra dentro del rango de enumeración <see cref="T:System.Text.Json.JsonCommentHandling" />).</exception>
      <returns>Valor que indica si se permiten los comentarios, si no se permiten o se omiten.</returns>
    </member>
    <member name="P:System.Text.Json.JsonSerializerOptions.ReferenceHandler">
      <summary>Configura cómo se controlan las referencias a objetos al leer y escribir JSON.</summary>
    </member>
    <member name="P:System.Text.Json.JsonSerializerOptions.WriteIndented">
      <summary>Obtiene o establece un valor que define si JSON debe usar la impresión con sangría. De manera predeterminada, JSON se serializa sin ningún espacio en blanco adicional.</summary>
      <exception cref="T:System.InvalidOperationException">Esta propiedad se estableció una vez que se completó la serialización o la deserialización.</exception>
      <returns>
        <see langword="true" /> Si JSON debe imprimirse en la serialización; en caso contrario, <see langword="false" /> . De manera predeterminada, es <see langword="false" />.</returns>
    </member>
    <member name="T:System.Text.Json.JsonTokenType">
      <summary>Define los distintos tokens de JSON que componen un texto JSON.</summary>
    </member>
    <member name="F:System.Text.Json.JsonTokenType.Comment">
      <summary>El tipo de token es una cadena de comentario.</summary>
    </member>
    <member name="F:System.Text.Json.JsonTokenType.EndArray">
      <summary>El tipo de token es el final de una matriz JSON.</summary>
    </member>
    <member name="F:System.Text.Json.JsonTokenType.EndObject">
      <summary>El tipo de token es el final de un objeto JSON.</summary>
    </member>
    <member name="F:System.Text.Json.JsonTokenType.False">
      <summary>El tipo de token es el literal JSON false.</summary>
    </member>
    <member name="F:System.Text.Json.JsonTokenType.None">
      <summary>No hay ningún valor (a diferencia de <see cref="F:System.Text.Json.JsonTokenType.Null" />).</summary>
    </member>
    <member name="F:System.Text.Json.JsonTokenType.Null">
      <summary>El tipo de token es el literal JSON null.</summary>
    </member>
    <member name="F:System.Text.Json.JsonTokenType.Number">
      <summary>El tipo de token es un número JSON.</summary>
    </member>
    <member name="F:System.Text.Json.JsonTokenType.PropertyName">
      <summary>El tipo de token es un nombre de propiedad JSON.</summary>
    </member>
    <member name="F:System.Text.Json.JsonTokenType.StartArray">
      <summary>El tipo de token es el comienzo de una matriz JSON.</summary>
    </member>
    <member name="F:System.Text.Json.JsonTokenType.StartObject">
      <summary>El tipo de token es el comienzo de un objeto JSON.</summary>
    </member>
    <member name="F:System.Text.Json.JsonTokenType.String">
      <summary>El tipo de token es una cadena JSON.</summary>
    </member>
    <member name="F:System.Text.Json.JsonTokenType.True">
      <summary>El tipo de token es el literal JSON true.</summary>
    </member>
    <member name="T:System.Text.Json.JsonValueKind">
      <summary>Especifica el tipo de datos de un valor JSON.</summary>
    </member>
    <member name="F:System.Text.Json.JsonValueKind.Array">
      <summary>Matriz de JSON.</summary>
    </member>
    <member name="F:System.Text.Json.JsonValueKind.False">
      <summary>Valor de JSON false.</summary>
    </member>
    <member name="F:System.Text.Json.JsonValueKind.Null">
      <summary>Valor de JSON null.</summary>
    </member>
    <member name="F:System.Text.Json.JsonValueKind.Number">
      <summary>Número de JSON.</summary>
    </member>
    <member name="F:System.Text.Json.JsonValueKind.Object">
      <summary>Objeto JSON.</summary>
    </member>
    <member name="F:System.Text.Json.JsonValueKind.String">
      <summary>Cadena JSON.</summary>
    </member>
    <member name="F:System.Text.Json.JsonValueKind.True">
      <summary>Valor de JSON true.</summary>
    </member>
    <member name="F:System.Text.Json.JsonValueKind.Undefined">
      <summary>No hay ningún valor (a diferencia de <see cref="F:System.Text.Json.JsonValueKind.Null" />).</summary>
    </member>
    <member name="T:System.Text.Json.JsonWriterOptions">
      <summary>Permite al usuario definir el comportamiento personalizado al escribir JSON mediante <see cref="T:System.Text.Json.Utf8JsonWriter" />.</summary>
    </member>
    <member name="P:System.Text.Json.JsonWriterOptions.Encoder">
      <summary>Obtiene o establece el codificador que se va a usar al escapar cadenas, o bien <see langword="null" /> para usar el codificador predeterminado.</summary>
      <returns>Codificador de caracteres de JavaScript que se usa para invalidar el comportamiento de escape.</returns>
    </member>
    <member name="P:System.Text.Json.JsonWriterOptions.Indented">
      <summary>Obtiene o establece un valor que indica si <see cref="T:System.Text.Json.Utf8JsonWriter" /> debe dar formato a la salida JSON, lo que incluye la aplicación de sangría a tokens de JSON anidados, la adición de nuevas líneas y la adición de espacio en blanco entre los nombres y valores de propiedades.</summary>
      <returns>
        <see langword="true" /> para dar formato a la salida JSON; <see langword="false" /> para escribir sin ningún espacio en blanco adicional. De manera predeterminada, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Text.Json.JsonWriterOptions.SkipValidation">
      <summary>Obtiene o establece un valor que indica si <see cref="T:System.Text.Json.Utf8JsonWriter" /> debe omitir la validación estructural y permitir que el usuario escriba JSON no válido.</summary>
      <returns>
        <see langword="true" /> para omitir la validación estructural y permitir JSON no válido; <see langword="false" /> para producir una excepción <see cref="T:System.InvalidOperationException" /> en cualquier intento de escribir JSON no válido.</returns>
    </member>
    <member name="T:System.Text.Json.Serialization.JsonAttribute">
      <summary>Proporciona la clase base para los atributos de serialización.</summary>
    </member>
    <member name="M:System.Text.Json.Serialization.JsonAttribute.#ctor">
      <summary>Crea una nueva instancia de <see cref="T:System.Text.Json.Serialization.JsonAttribute" />.</summary>
    </member>
    <member name="T:System.Text.Json.Serialization.JsonConstructorAttribute">
      <summary>Cuando se coloca en un constructor, indica que se debe utilizar el constructor para crear instancias del tipo en la deserialización.</summary>
    </member>
    <member name="M:System.Text.Json.Serialization.JsonConstructorAttribute.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.Json.Serialization.JsonConstructorAttribute" />.</summary>
    </member>
    <member name="T:System.Text.Json.Serialization.JsonConverter">
      <summary>Convierte un objeto o un valor en JSON o desde JSON.</summary>
    </member>
    <member name="M:System.Text.Json.Serialization.JsonConverter.CanConvert(System.Type)">
      <summary>Cuando se reemplaza en una clase derivada, determina si la instancia del convertidor puede convertir el tipo de objeto especificado.</summary>
      <param name="typeToConvert">El tipo del objeto que se comprobará si se puede convertir por esta instancia del convertidor.</param>
      <returns>
        <see langword="true" /> si la instancia puede convertir el tipo de objeto especificado; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Text.Json.Serialization.JsonConverter`1">
      <summary>Convierte un objeto o un valor en JSON o desde JSON.</summary>
      <typeparam name="T">Tipo de objeto o valor controlado por el convertidor.</typeparam>
    </member>
    <member name="M:System.Text.Json.Serialization.JsonConverter`1.#ctor">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Text.Json.Serialization.JsonConverter`1" />.</summary>
    </member>
    <member name="M:System.Text.Json.Serialization.JsonConverter`1.CanConvert(System.Type)">
      <summary>Determina si el tipo especificado se puede convertir.</summary>
      <param name="typeToConvert">El tipo con el que se va a comparar.</param>
      <returns>Es <see langword="true" /> si se puede convertir el tipo; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.Serialization.JsonConverter`1.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
      <summary>Lee y convierte el JSON en el tipo <typeparamref name="T" />.</summary>
      <param name="reader">Lector.</param>
      <param name="typeToConvert">Tipo que se va a convertir.</param>
      <param name="options">Objeto que especifica las opciones de serialización que se van a utilizar.</param>
      <returns>El valor convertido.</returns>
    </member>
    <member name="M:System.Text.Json.Serialization.JsonConverter`1.Write(System.Text.Json.Utf8JsonWriter,`0,System.Text.Json.JsonSerializerOptions)">
      <summary>Escribe un valor especificado como JSON.</summary>
      <param name="writer">El sistema de escritura en el que se va a escribir.</param>
      <param name="value">Valor que se va a convertir en JSON.</param>
      <param name="options">Objeto que especifica las opciones de serialización que se van a utilizar.</param>
    </member>
    <member name="P:System.Text.Json.Serialization.JsonConverter`1.HandleNull">
      <summary>Indica si <see langword="null" /> se debe pasar al convertidor en la serialización y si <see cref="F:System.Text.Json.JsonTokenType.Null" /> debe pasarse en la deserialización.</summary>
    </member>
    <member name="T:System.Text.Json.Serialization.JsonConverterAttribute">
      <summary>Cuando se coloca en una propiedad o tipo, especifica el tipo de convertidor que se usará.</summary>
    </member>
    <member name="M:System.Text.Json.Serialization.JsonConverterAttribute.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.Json.Serialization.JsonConverterAttribute" />.</summary>
    </member>
    <member name="M:System.Text.Json.Serialization.JsonConverterAttribute.#ctor(System.Type)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Text.Json.Serialization.JsonConverterAttribute" /> con el tipo de convertidor especificado.</summary>
      <param name="converterType">Tipo de convertidor.</param>
    </member>
    <member name="M:System.Text.Json.Serialization.JsonConverterAttribute.CreateConverter(System.Type)">
      <summary>Cuando se reemplaza en una clase derivada y <see cref="P:System.Text.Json.Serialization.JsonConverterAttribute.ConverterType" /> es <see langword="null" />, permite que la clase derivada cree un <see cref="T:System.Text.Json.Serialization.JsonConverter" /> para pasar el estado adicional.</summary>
      <param name="typeToConvert">Tipo de convertidor.</param>
      <returns>Convertidor personalizado.</returns>
    </member>
    <member name="P:System.Text.Json.Serialization.JsonConverterAttribute.ConverterType">
      <summary>Obtiene el tipo de <see cref="T:System.Text.Json.Serialization.JsonConverterAttribute" />, o bien <see langword="null" /> si se ha creado sin un tipo.</summary>
      <returns>Tipo de <see cref="T:System.Text.Json.Serialization.JsonConverterAttribute" /> , o <see langword="null" /> si se creó sin un tipo.</returns>
    </member>
    <member name="T:System.Text.Json.Serialization.JsonConverterFactory">
      <summary>Admite la conversión de varios tipos mediante el uso de un patrón factory.</summary>
    </member>
    <member name="M:System.Text.Json.Serialization.JsonConverterFactory.#ctor">
      <summary>Cuando se invalida en una clase derivada, inicializa una nueva instancia de la clase <see cref="T:System.Text.Json.Serialization.JsonConverterFactory" />.</summary>
    </member>
    <member name="M:System.Text.Json.Serialization.JsonConverterFactory.CreateConverter(System.Type,System.Text.Json.JsonSerializerOptions)">
      <summary>Crea un convertidor para un tipo especificado.</summary>
      <param name="typeToConvert">Tipo controlado por el convertidor.</param>
      <param name="options">Opciones de serialización que se van a utilizar.</param>
      <returns>Convertidor para el que <typeparamref name="T" /> es compatible con <paramref name="typeToConvert" />.</returns>
    </member>
    <member name="T:System.Text.Json.Serialization.JsonExtensionDataAttribute">
      <summary>Cuando se coloca en una propiedad de tipo <see cref="T:System.Collections.Generic.IDictionary`2" />, las propiedades que no tengan un miembro coincidente se agregan a ese diccionario durante la deserialización y se escriben durante la serialización.</summary>
    </member>
    <member name="M:System.Text.Json.Serialization.JsonExtensionDataAttribute.#ctor">
      <summary>Crea una nueva instancia de la clase <see cref="T:System.Text.Json.Serialization.JsonExtensionDataAttribute" />.</summary>
    </member>
    <member name="T:System.Text.Json.Serialization.JsonIgnoreAttribute">
      <summary>Impide la serialización o deserialización de una propiedad.</summary>
    </member>
    <member name="M:System.Text.Json.Serialization.JsonIgnoreAttribute.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.Json.Serialization.JsonIgnoreAttribute" />.</summary>
    </member>
    <member name="P:System.Text.Json.Serialization.JsonIgnoreAttribute.Condition">
      <summary>Especifica la condición que se debe cumplir antes de que se omita una propiedad.</summary>
    </member>
    <member name="T:System.Text.Json.Serialization.JsonIgnoreCondition">
      <summary>Controla cómo <see cref="T:System.Text.Json.Serialization.JsonIgnoreAttribute" /> omite las propiedades en la serialización y la deserialización.</summary>
    </member>
    <member name="F:System.Text.Json.Serialization.JsonIgnoreCondition.Always">
      <summary>Siempre se omitirá la propiedad.</summary>
    </member>
    <member name="F:System.Text.Json.Serialization.JsonIgnoreCondition.Never">
      <summary>La propiedad se serializará y deserializará siempre, con independencia de la configuración de <see cref="P:System.Text.Json.JsonSerializerOptions.IgnoreNullValues" />.</summary>
    </member>
    <member name="F:System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault">
      <summary>Solo se omitirá la propiedad si es <see langword="null" />.</summary>
    </member>
    <member name="F:System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull">
      <summary>Si el valor es <see langword="null" />, la propiedad se omite durante la serialización. Esto solo se aplica a los campos y las propiedades de tipo de referencia.</summary>
    </member>
    <member name="T:System.Text.Json.Serialization.JsonIncludeAttribute">
      <summary>Indica que se debe incluir el miembro para la serialización y deserialización.</summary>
      <exception cref="T:System.InvalidOperationException">El atributo se aplica a una propiedad no pública.</exception>
    </member>
    <member name="M:System.Text.Json.Serialization.JsonIncludeAttribute.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.Json.Serialization.JsonIncludeAttribute" />.</summary>
    </member>
    <member name="T:System.Text.Json.Serialization.JsonNumberHandling">
      <summary>Determina cómo <see cref="T:System.Text.Json.JsonSerializer" /> administra los números al realizar la serialización y la deserialización.</summary>
    </member>
    <member name="F:System.Text.Json.Serialization.JsonNumberHandling.AllowNamedFloatingPointLiterals">
      <summary>Los tokens "NaN", "Infinity" e "-Infinity" de <see cref="F:System.Text.Json.JsonTokenType.String" /> se pueden leer como constantes de punto flotante y los valores <see cref="T:System.Single" /> y <see cref="T:System.Double" /> de estas constantes se escribirán como sus representaciones de cadena JSON correspondientes.</summary>
    </member>
    <member name="F:System.Text.Json.Serialization.JsonNumberHandling.AllowReadingFromString">
      <summary>Los números se pueden leer de los tokens <see cref="F:System.Text.Json.JsonTokenType.String" />. No impide que los números se lean del token <see cref="F:System.Text.Json.JsonTokenType.Number" />.</summary>
    </member>
    <member name="F:System.Text.Json.Serialization.JsonNumberHandling.Strict">
      <summary>Los números solo se leerán de los tokens <see cref="F:System.Text.Json.JsonTokenType.Number" /> y solo se escribirán como números JSON (sin comillas).</summary>
    </member>
    <member name="F:System.Text.Json.Serialization.JsonNumberHandling.WriteAsString">
      <summary>Los números se escribirán como cadenas JSON (con comillas), no como números JSON.</summary>
    </member>
    <member name="T:System.Text.Json.Serialization.JsonNumberHandlingAttribute">
      <summary>Cuando se coloca en un tipo, propiedad o campo, indica qué configuración de <see cref="T:System.Text.Json.Serialization.JsonNumberHandling" /> se debe usar al serializar o deserializar números.</summary>
    </member>
    <member name="M:System.Text.Json.Serialization.JsonNumberHandlingAttribute.#ctor(System.Text.Json.Serialization.JsonNumberHandling)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.Json.Serialization.JsonNumberHandlingAttribute" />.</summary>
      <param name="handling">Combinación bit a bit de los valores de enumeración que especifican cómo se deben controlar los tipos de número al serializar o deserializar.</param>
    </member>
    <member name="P:System.Text.Json.Serialization.JsonNumberHandlingAttribute.Handling">
      <summary>Indica qué configuración se debe usar al serializar o deserializar números.</summary>
      <returns>Objeto que determina el número de valores de serialización y deserialización.</returns>
    </member>
    <member name="T:System.Text.Json.Serialization.JsonPropertyNameAttribute">
      <summary>Especifica el nombre de la propiedad que se encuentra en el código JSON al serializar y deserializar. Esto invalida cualquier directiva de nomenclatura especificada por <see cref="T:System.Text.Json.JsonNamingPolicy" />.</summary>
    </member>
    <member name="M:System.Text.Json.Serialization.JsonPropertyNameAttribute.#ctor(System.String)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Text.Json.Serialization.JsonPropertyNameAttribute" /> con el nombre de propiedad especificado.</summary>
      <param name="name">Nombre de la propiedad.</param>
    </member>
    <member name="P:System.Text.Json.Serialization.JsonPropertyNameAttribute.Name">
      <summary>Obtiene el nombre de la propiedad.</summary>
      <returns>Nombre de la propiedad.</returns>
    </member>
    <member name="T:System.Text.Json.Serialization.JsonStringEnumConverter">
      <summary>Convierte los valores de enumeración en cadenas y a partir de cadenas.</summary>
    </member>
    <member name="M:System.Text.Json.Serialization.JsonStringEnumConverter.#ctor">
      <summary>Inicializa una instancia de la clase <see cref="T:System.Text.Json.Serialization.JsonStringEnumConverter" /> con la directiva de nomenclatura predeterminada que permite valores enteros.</summary>
    </member>
    <member name="M:System.Text.Json.Serialization.JsonStringEnumConverter.#ctor(System.Text.Json.JsonNamingPolicy,System.Boolean)">
      <summary>Inicializa una instancia de la clase <see cref="T:System.Text.Json.Serialization.JsonStringEnumConverter" /> con una directiva de nomenclatura especificada y un valor que indica si se permiten valores de enumeración no definidos.</summary>
      <param name="namingPolicy">Directiva de nomenclatura opcional para escribir valores de enumeración.</param>
      <param name="allowIntegerValues">
        <see langword="true" /> para permitir valores de enumeración no definidos; en caso contrario, <see langword="false" />. Cuando es <see langword="true" />, si no se define un valor de enumeración, se generará como un número en lugar de como cadena.</param>
    </member>
    <member name="M:System.Text.Json.Serialization.JsonStringEnumConverter.CanConvert(System.Type)">
      <summary>Determina si el tipo especificado puede convertirse en una enumeración.</summary>
      <param name="typeToConvert">Tipo que se va a comprobar.</param>
      <returns>Es <see langword="true" /> si se puede convertir el tipo; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.Serialization.JsonStringEnumConverter.CreateConverter(System.Type,System.Text.Json.JsonSerializerOptions)">
      <summary>Crea un convertidor para el tipo especificado.</summary>
      <param name="typeToConvert">Tipo controlado por el convertidor.</param>
      <param name="options">Opciones de serialización que se van a utilizar.</param>
      <returns>Convertidor para el que <typeparamref name="T" /> es compatible con <paramref name="typeToConvert" />.</returns>
    </member>
    <member name="T:System.Text.Json.Serialization.ReferenceHandler">
      <summary>Esta clase define cómo <see cref="T:System.Text.Json.JsonSerializer" /> trata las referencias en la serialización y deserialización.</summary>
    </member>
    <member name="M:System.Text.Json.Serialization.ReferenceHandler.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.Json.Serialization.ReferenceHandler" />.</summary>
    </member>
    <member name="M:System.Text.Json.Serialization.ReferenceHandler.CreateResolver">
      <summary>Devuelve el elemento <see cref="T:System.Text.Json.Serialization.ReferenceResolver" /> utilizado para cada llamada de serialización.</summary>
      <returns>Resolución que se va a utilizar para la serialización y deserialización.</returns>
    </member>
    <member name="P:System.Text.Json.Serialization.ReferenceHandler.Preserve">
      <summary>Se respetarán las propiedades de metadatos al deserializar objetos y matrices JSON en tipos de referencia y se escribirán al serializar tipos de referencia. Esto es necesario para crear un archivo JSON de recorrido de ida y vuelta a partir de objetos que incluyan ciclos o referencias duplicadas.</summary>
    </member>
    <member name="T:System.Text.Json.Serialization.ReferenceHandler`1">
      <summary>Esta clase define cómo <see cref="T:System.Text.Json.JsonSerializer" /> trata las referencias en la serialización y deserialización.</summary>
      <typeparam name="T">Tipo de <see cref="T:System.Text.Json.Serialization.ReferenceResolver" /> que se va a crear en cada llamada de serialización o deserialización.</typeparam>
    </member>
    <member name="M:System.Text.Json.Serialization.ReferenceHandler`1.#ctor">
      <summary>Inicializa una nueva instancia de la clase genérica <see cref="T:System.Text.Json.Serialization.ReferenceHandler`1" /> que puede crear una instancia de <see cref="T:System.Text.Json.Serialization.ReferenceResolver" /> del especificado <typeparam name="T" />.</summary>
    </member>
    <member name="M:System.Text.Json.Serialization.ReferenceHandler`1.CreateResolver">
      <summary>Crea un nuevo elemento <see cref="T:System.Text.Json.Serialization.ReferenceResolver" /> de tipo <typeparamref name="T" /> utilizado para cada llamada de serialización.</summary>
      <returns>Nueva resolución que se va a usar para la serialización y deserialización.</returns>
    </member>
    <member name="T:System.Text.Json.Serialization.ReferenceResolver">
      <summary>Esta clase define cómo <see cref="T:System.Text.Json.JsonSerializer" /> trata las referencias en la serialización y deserialización.
Define el comportamiento básico de conservar las referencias en la serialización y deserialización.</summary>
    </member>
    <member name="M:System.Text.Json.Serialization.ReferenceResolver.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.Json.Serialization.ReferenceResolver" />.</summary>
    </member>
    <member name="M:System.Text.Json.Serialization.ReferenceResolver.AddReference(System.String,System.Object)">
      <summary>Agrega una entrada al contenedor de referencias utilizando el identificador y el valor especificados.
Se llama a este método cuando se lee una propiedad de metadatos de $id desde un objeto JSON.</summary>
      <param name="referenceId">Identificador del objeto o matriz JSON.</param>
      <param name="value">Valor del objeto de tipo de referencia de CLR que es el resultado de analizar el objeto JSON.</param>
    </member>
    <member name="M:System.Text.Json.Serialization.ReferenceResolver.GetReference(System.Object,System.Boolean@)">
      <summary>Obtiene el identificador de referencia del valor especificado si existe; de lo contrario, se asigna un nuevo identificador.
Se llama a este método antes de que se escriba un objeto CLR para que podamos decidir si escribir $id y enumerar el resto de sus propiedades o $ref y depurar paso a paso por instrucciones el objeto siguiente.</summary>
      <param name="value">Valor del objeto de tipo de referencia de CLR para el que se va a obtener un identificador.</param>
      <param name="alreadyExists">Este método devuelve <see langword="true" /> si ya existe una referencia al valor; de lo contrario, <see langword="false" />.</param>
      <returns>Identificador de referencia del objeto especificado.</returns>
    </member>
    <member name="M:System.Text.Json.Serialization.ReferenceResolver.ResolveReference(System.String)">
      <summary>Devuelve el objeto de tipo de referencia de CLR relacionado con el identificador de referencia especificado. Se llama a este método cuando se lee la propiedad de metadatos de $ref.</summary>
      <param name="referenceId">Identificador de referencia relacionado con el objeto devuelto.</param>
      <returns>Objeto de tipo de referencia relacionado con el identificador de referencia especificado.</returns>
    </member>
    <member name="T:System.Text.Json.Utf8JsonReader">
      <summary>Proporciona una API de alto rendimiento para acceso de solo avance y solo lectura a texto JSON con codificación UTF-8.</summary>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.#ctor(System.Buffers.ReadOnlySequence{System.Byte},System.Boolean,System.Text.Json.JsonReaderState)">
      <summary>Inicializa una nueva instancia de la estructura <see cref="T:System.Text.Json.Utf8JsonReader" /> que procesa una secuencia de solo lectura de texto con codificación UTF-8 e indica si la entrada contiene todo el texto que se va a procesar.</summary>
      <param name="jsonData">Texto JSON con codificación UTF-8 que se va a procesar.</param>
      <param name="isFinalBlock">
        <see langword="true" /> para indicar que la secuencia de entrada contiene todos los datos que se van a procesar; <see langword="false" /> para indicar que el intervalo de entrada contiene datos parciales con más datos a continuación.</param>
      <param name="state">Objeto que contiene el estado del lector. Si esta es la primera llamada al constructor, pase el estado predeterminado; de lo contrario, pase el valor de la propiedad <see cref="P:System.Text.Json.Utf8JsonReader.CurrentState" /> desde la instancia anterior de <see cref="T:System.Text.Json.Utf8JsonReader" />.</param>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.#ctor(System.Buffers.ReadOnlySequence{System.Byte},System.Text.Json.JsonReaderOptions)">
      <summary>Inicializa una nueva instancia de la estructura <see cref="T:System.Text.Json.Utf8JsonReader" /> que procesa una secuencia de solo lectura de texto con codificación UTF-8 mediante las opciones especificadas.</summary>
      <param name="jsonData">Texto JSON con codificación UTF-8 que se va a procesar.</param>
      <param name="options">Define el comportamiento personalizado de <see cref="T:System.Text.Json.Utf8JsonReader" />, que es diferente de la RFC de JSON (por ejemplo, cómo controlar los comentarios o la profundidad máxima permitida durante la lectura). De forma predeterminada, el <see cref="T:System.Text.Json.Utf8JsonReader" /> sigue estrictamente RFC de JSON; los comentarios en JSON no son válidos y la profundidad máxima es 64.</param>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.#ctor(System.ReadOnlySpan{System.Byte},System.Boolean,System.Text.Json.JsonReaderState)">
      <summary>Inicializa una nueva instancia de la estructura <see cref="T:System.Text.Json.Utf8JsonReader" /> que procesa un intervalo de solo lectura de texto con codificación UTF-8 e indica si la entrada contiene todo el texto que se va a procesar.</summary>
      <param name="jsonData">Texto JSON con codificación UTF-8 que se va a procesar.</param>
      <param name="isFinalBlock">
        <see langword="true" /> para indicar que la secuencia de entrada contiene todos los datos que se van a procesar; <see langword="false" /> para indicar que el intervalo de entrada contiene datos parciales con más datos a continuación.</param>
      <param name="state">Objeto que contiene el estado del lector. Si esta es la primera llamada al constructor, pase el estado predeterminado; de lo contrario, pase el valor de la propiedad <see cref="P:System.Text.Json.Utf8JsonReader.CurrentState" /> desde la instancia anterior de <see cref="T:System.Text.Json.Utf8JsonReader" />.</param>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.#ctor(System.ReadOnlySpan{System.Byte},System.Text.Json.JsonReaderOptions)">
      <summary>Inicializa una nueva instancia de la estructura <see cref="T:System.Text.Json.Utf8JsonReader" /> que procesa un intervalo de solo lectura de texto con codificación UTF-8 mediante las opciones especificadas.</summary>
      <param name="jsonData">Texto JSON con codificación UTF-8 que se va a procesar.</param>
      <param name="options">Define el comportamiento personalizado de <see cref="T:System.Text.Json.Utf8JsonReader" />, que es diferente de la RFC de JSON (por ejemplo, cómo controlar los comentarios o la profundidad máxima permitida durante la lectura). De forma predeterminada, el <see cref="T:System.Text.Json.Utf8JsonReader" /> sigue estrictamente RFC de JSON; los comentarios en JSON no son válidos y la profundidad máxima es 64.</param>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.GetBoolean">
      <summary>Lee el valor del token de JSON siguiente del origen como un valor <see cref="T:System.Boolean" />.</summary>
      <exception cref="T:System.InvalidOperationException">El valor del token de JSON no es un valor booleano (es decir, <see cref="F:System.Text.Json.JsonTokenType.True" /> o <see cref="F:System.Text.Json.JsonTokenType.False" />).</exception>
      <returns>
        <see langword="true" /> si <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> es <see cref="F:System.Text.Json.JsonTokenType.True" />; <see langword="false" /> si <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> es <see cref="F:System.Text.Json.JsonTokenType.False" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.GetByte">
      <summary>Analiza el valor del token JSON actual del origen como un <see cref="T:System.Byte" />.</summary>
      <exception cref="T:System.InvalidOperationException">El valor del token JSON no es un <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
      <exception cref="T:System.FormatException">El formato numérico del valor del token JSON es incorrecto (por ejemplo, contiene un valor fraccionario o está escrito en notación científica).
          
o bien

El valor del token de JSON representa un número menor que <see cref="F:System.Byte.MinValue" /> o mayor que <see cref="F:System.Byte.MaxValue" />.</exception>
      <returns>Valor del token con codificación UTF-8.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.GetBytesFromBase64">
      <summary>Analiza el valor del token JSON actual del origen y descodifica la cadena JSON con codificación Base64 como una matriz de bytes.</summary>
      <exception cref="T:System.InvalidOperationException">El tipo del token JSON no es <see cref="F:System.Text.Json.JsonTokenType.String" />.</exception>
      <exception cref="T:System.FormatException">El valor no está codificado como texto en Base64 y, por tanto, no se puede descodificar en bytes.

o bien

El valor contiene caracteres no válidos o más de dos caracteres de relleno.

o bien

El valor está incompleto. Es decir, la longitud de la cadena JSON no es múltiplo de 4.</exception>
      <returns>Matriz de bytes que representa el valor del token JSON actual.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.GetComment">
      <summary>Analiza el valor del token JSON actual del origen como comentario, transcodificado como <see cref="T:System.String" />.</summary>
      <exception cref="T:System.InvalidOperationException">El token JSON no es un comentario.</exception>
      <returns>Comentario que representa el valor del token JSON actual.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.GetDateTime">
      <summary>Lee el valor del token de JSON siguiente del origen y lo analiza en <see cref="T:System.DateTime" />.</summary>
      <exception cref="T:System.InvalidOperationException">El valor del token JSON no es un objeto <see cref="F:System.Text.Json.JsonTokenType.String" />.</exception>
      <exception cref="T:System.FormatException">El valor del token de JSON no se puede leer como <see cref="T:System.DateTime" />.
        
o bien 
El valor entero del token con codificación UTF-8 no se puede analizar en un valor <see cref="T:System.DateTime" />.

o bien

El valor del token JSON está en un formato no admitido.</exception>
      <returns>El valor de fecha y hora, si todo el valor del token con codificación UTF-8 se puede analizar correctamente.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.GetDateTimeOffset">
      <summary>Lee el valor del token de JSON siguiente del origen y lo analiza en <see cref="T:System.DateTimeOffset" />.</summary>
      <exception cref="T:System.InvalidOperationException">El valor del token JSON no es un objeto <see cref="F:System.Text.Json.JsonTokenType.String" />.</exception>
      <exception cref="T:System.FormatException">El valor del token de JSON no se puede leer como <see cref="T:System.DateTimeOffset" />.

o bien 
El valor entero del token con codificación UTF-8 no se puede analizar en un valor <see cref="T:System.DateTimeOffset" />.

o bien

El valor del token JSON está en un formato no admitido.</exception>
      <returns>El desplazamiento de fecha y hora, si el valor entero del token con codificación UTF-8 se puede analizar correctamente.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.GetDecimal">
      <summary>Lee el valor del token de JSON siguiente del origen y lo analiza en <see cref="T:System.Decimal" />.</summary>
      <exception cref="T:System.InvalidOperationException">El valor del token de JSON no es un objeto <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
      <exception cref="T:System.FormatException">El valor del token de JSON representa un número menor que <see cref="F:System.Decimal.MinValue" /> o mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
      <returns>Valor del token con codificación UTF-8 que se analiza en <see cref="T:System.Decimal" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.GetDouble">
      <summary>Lee el valor del token de JSON siguiente del origen y lo analiza en <see cref="T:System.Double" />.</summary>
      <exception cref="T:System.InvalidOperationException">El valor del token de JSON no es un objeto <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
      <exception cref="T:System.FormatException">El valor del token de JSON representa un número menor que <see cref="F:System.Double.MinValue" /> o mayor que <see cref="F:System.Double.MaxValue" />.</exception>
      <returns>Valor del token con codificación UTF-8 que se analiza en <see cref="T:System.Double" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.GetGuid">
      <summary>Lee el valor del token de JSON siguiente del origen y lo analiza en <see cref="T:System.Guid" />.</summary>
      <exception cref="T:System.InvalidOperationException">El valor del token JSON no es un objeto <see cref="F:System.Text.Json.JsonTokenType.String" />.</exception>
      <exception cref="T:System.FormatException">El valor del token JSON está en un formato no admitido para un GUID.
        
o bien

El valor entero del token con codificación UTF-8 no se puede analizar en un valor <see cref="T:System.Guid" />.</exception>
      <returns>El valor de GUID, si todo el valor del token con codificación UTF-8 se puede analizar correctamente.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.GetInt16">
      <summary>Analiza el valor del token JSON actual del origen como un <see cref="T:System.Int16" />.</summary>
      <exception cref="T:System.InvalidOperationException">El valor del token JSON no es un <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
      <exception cref="T:System.FormatException">El formato numérico del valor del token JSON es incorrecto (por ejemplo, contiene un valor fraccionario o está escrito en notación científica).
          
o bien

El valor del token de JSON representa un número menor que <see cref="F:System.Int16.MinValue" /> o mayor que <see cref="F:System.Int16.MaxValue" />.</exception>
      <returns>Valor del token con codificación UTF-8 que se analiza en <see cref="T:System.Int16" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.GetInt32">
      <summary>Lee el valor del token de JSON siguiente del origen y lo analiza en <see cref="T:System.Int32" />.</summary>
      <exception cref="T:System.InvalidOperationException">El valor del token de JSON no es un objeto <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
      <exception cref="T:System.FormatException">El valor del token de JSON tiene el formato numérico incorrecto. Por ejemplo, contiene un valor decimal o se escribe en notación científica.
            
o bien

El valor del token de JSON representa un número menor que <see cref="F:System.Int32.MinValue" /> o mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      <returns>Valor del token con codificación UTF-8 que se analiza en <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.GetInt64">
      <summary>Lee el valor del token de JSON siguiente del origen y lo analiza en <see cref="T:System.Int64" />.</summary>
      <exception cref="T:System.InvalidOperationException">El valor del token de JSON no es un objeto <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
      <exception cref="T:System.FormatException">El valor del token de JSON tiene el formato numérico incorrecto. Por ejemplo, contiene un valor decimal o se escribe en notación científica.
            
o bien

El valor del token de JSON representa un número menor que <see cref="F:System.Int64.MinValue" /> o mayor que <see cref="F:System.Int64.MaxValue" />.</exception>
      <returns>Valor del token con codificación UTF-8 que se analiza en <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.GetSByte">
      <summary>Analiza el valor del token JSON actual del origen como un <see cref="T:System.SByte" />.</summary>
      <exception cref="T:System.InvalidOperationException">El valor del token JSON no es un <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
      <exception cref="T:System.FormatException">El formato numérico del valor del token JSON es incorrecto (por ejemplo, contiene un valor fraccionario o está escrito en notación científica).
          
o bien

El valor del token de JSON representa un número menor que <see cref="F:System.SByte.MinValue" /> o mayor que <see cref="F:System.SByte.MaxValue" />.</exception>
      <returns>Valor del token con codificación UTF-8 que se analiza en <see cref="T:System.SByte" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.GetSingle">
      <summary>Lee el valor del token de JSON siguiente del origen y lo analiza en <see cref="T:System.Single" />.</summary>
      <exception cref="T:System.InvalidOperationException">El valor del token de JSON no es un objeto <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
      <exception cref="T:System.FormatException">El valor del token de JSON representa un número menor que <see cref="F:System.Single.MinValue" /> o mayor que <see cref="F:System.Single.MaxValue" />.</exception>
      <returns>Valor del token con codificación UTF-8 que se analiza en <see cref="T:System.Single" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.GetString">
      <summary>Lee el valor del token JSON siguiente del origen, sin escape, y transcodificado como una cadena.</summary>
      <exception cref="T:System.InvalidOperationException">El valor del token de JSON no es una cadena (es decir, no es <see cref="F:System.Text.Json.JsonTokenType.String" />, <see cref="F:System.Text.Json.JsonTokenType.PropertyName" /> ni <see cref="F:System.Text.Json.JsonTokenType.Null" />).

o bien

La cadena JSON contiene bytes UTF-8 no válidos o suplentes UTF-16 no válidos.</exception>
      <returns>Valor del token analizado en una cadena, o <see langword="null" /> si <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> es <see cref="F:System.Text.Json.JsonTokenType.Null" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.GetUInt16">
      <summary>Analiza el valor del token JSON actual del origen como un <see cref="T:System.UInt16" />.</summary>
      <exception cref="T:System.InvalidOperationException">El valor del token JSON no es un <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
      <exception cref="T:System.FormatException">El formato numérico del valor del token JSON es incorrecto (por ejemplo, contiene un valor fraccionario o está escrito en notación científica).
          
o bien

El valor del token de JSON representa un número menor que <see cref="F:System.UInt16.MinValue" /> o mayor que <see cref="F:System.UInt16.MaxValue" />.</exception>
      <returns>Valor del token con codificación UTF-8 que se analiza en <see cref="T:System.UInt16" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.GetUInt32">
      <summary>Lee el valor del token de JSON siguiente del origen y lo analiza en <see cref="T:System.UInt32" />.</summary>
      <exception cref="T:System.InvalidOperationException">El valor del token de JSON no es un objeto <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
      <exception cref="T:System.FormatException">El valor del token de JSON tiene el formato numérico incorrecto. Por ejemplo, contiene un valor decimal o se escribe en notación científica.

o bien

El valor del token de JSON representa un número menor que <see cref="F:System.UInt32.MinValue" /> o mayor que <see cref="F:System.UInt32.MaxValue" />.</exception>
      <returns>Valor del token con codificación UTF-8 que se analiza en <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.GetUInt64">
      <summary>Lee el valor del token de JSON siguiente del origen y lo analiza en <see cref="T:System.UInt64" />.</summary>
      <exception cref="T:System.InvalidOperationException">El valor del token de JSON no es un objeto <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
      <exception cref="T:System.FormatException">El valor del token de JSON tiene el formato numérico incorrecto. Por ejemplo, contiene un valor decimal o se escribe en notación científica.
            
o bien

El valor del token de JSON representa un número menor que <see cref="F:System.UInt64.MinValue" /> o mayor que <see cref="F:System.UInt64.MaxValue" />.</exception>
      <returns>Valor del token con codificación UTF-8 que se analiza en <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.Read">
      <summary>Lee el token JSON siguiente del origen de entrada.</summary>
      <exception cref="T:System.Text.Json.JsonException">Se ha encontrado un token JSON no válido según la RFC de JSON.
        
o bien

La profundidad actual supera el límite recursivo establecido por la profundidad máxima.</exception>
      <returns>
        <see langword="true" /> si el token se ha leído correctamente; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.Skip">
      <summary>Omite los elementos secundarios del token JSON actual.</summary>
      <exception cref="T:System.InvalidOperationException">Se entregaron datos parciales al lector, más datos seguirán (es decir, <see cref="P:System.Text.Json.Utf8JsonReader.IsFinalBlock" /> es <see langword="false" />).</exception>
      <exception cref="T:System.Text.Json.JsonException">Se ha encontrado un token JSON no válido durante la omisión, según la RFC de JSON.

o bien

La profundidad actual supera el límite recursivo establecido por la profundidad máxima.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.TryGetByte(System.Byte@)">
      <summary>Intenta analizar el valor del token JSON actual del origen como <see cref="T:System.Byte" /> y devuelve un valor que indica si la operación se ha realizado correctamente.</summary>
      <param name="value">Cuando este método devuelve un resultado, contiene el valor analizado.</param>
      <exception cref="T:System.InvalidOperationException">El valor del token de JSON no es un objeto <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
      <returns>
        <see langword="true" /> si todo el valor del token con codificación UTF-8 se puede analizar correctamente en un valor <see cref="T:System.Byte" />; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.TryGetBytesFromBase64(System.Byte[]@)">
      <summary>Intenta analizar el valor del token JSON actual del origen, descodifica la cadena JSON con codificación Base64 como una matriz de bytes y devuelve un valor que indica si la operación se ha realizado correctamente.</summary>
      <param name="value">Cuando el método finaliza, contiene la representación binaria descodificada del texto Base64.</param>
      <exception cref="T:System.InvalidOperationException">El token JSON no es <see cref="F:System.Text.Json.JsonTokenType.String" />.</exception>
      <returns>
        <see langword="true" /> si el valor del token completo está codificado como texto válido Base64 y se puede descodificar correctamente en bytes; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.TryGetDateTime(System.DateTime@)">
      <summary>Intenta analizar el valor del token JSON actual del origen como <see cref="T:System.DateTime" /> y devuelve un valor que indica si la operación se ha realizado correctamente.</summary>
      <param name="value">Cuando este método devuelve un resultado, contiene el valor analizado.</param>
      <exception cref="T:System.InvalidOperationException">El valor del token JSON no es un objeto <see cref="F:System.Text.Json.JsonTokenType.String" />.</exception>
      <returns>
        <see langword="true" /> si todo el valor del token con codificación UTF-8 se puede analizar correctamente en un valor <see cref="T:System.DateTime" />; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.TryGetDateTimeOffset(System.DateTimeOffset@)">
      <summary>Intenta analizar el valor del token JSON actual del origen como <see cref="T:System.DateTimeOffset" /> y devuelve un valor que indica si la operación se ha realizado correctamente.</summary>
      <param name="value">Cuando este método devuelve un resultado, contiene el valor analizado.</param>
      <exception cref="T:System.InvalidOperationException">El valor del token JSON no es un objeto <see cref="F:System.Text.Json.JsonTokenType.String" />.</exception>
      <returns>
        <see langword="true" /> si todo el valor del token con codificación UTF-8 se puede analizar correctamente en un valor <see cref="T:System.DateTimeOffset" />; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.TryGetDecimal(System.Decimal@)">
      <summary>Intenta analizar el valor del token JSON actual del origen como <see cref="T:System.Decimal" /> y devuelve un valor que indica si la operación se ha realizado correctamente.</summary>
      <param name="value">Cuando este método devuelve un resultado, contiene el valor analizado.</param>
      <exception cref="T:System.InvalidOperationException">El valor del token de JSON no es un objeto <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
      <returns>
        <see langword="true" /> si todo el valor del token con codificación UTF-8 se puede analizar correctamente en un valor <see cref="T:System.Decimal" />; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.TryGetDouble(System.Double@)">
      <summary>Intenta analizar el valor del token JSON actual del origen como <see cref="T:System.Double" /> y devuelve un valor que indica si la operación se ha realizado correctamente.</summary>
      <param name="value">Cuando este método devuelve un resultado, contiene el valor analizado.</param>
      <exception cref="T:System.InvalidOperationException">El valor del token de JSON no es un objeto <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
      <returns>
        <see langword="true" /> si todo el valor del token con codificación UTF-8 se puede analizar correctamente en un valor <see cref="T:System.Double" />; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.TryGetGuid(System.Guid@)">
      <summary>Intenta analizar el valor del token JSON actual del origen como <see cref="T:System.Guid" /> y devuelve un valor que indica si la operación se ha realizado correctamente.</summary>
      <param name="value">Cuando este método devuelve un resultado, contiene el valor analizado.</param>
      <exception cref="T:System.InvalidOperationException">El valor del token JSON no es un objeto <see cref="F:System.Text.Json.JsonTokenType.String" />.</exception>
      <returns>
        <see langword="true" /> si todo el valor del token con codificación UTF-8 se puede analizar correctamente en un valor <see cref="T:System.Guid" />; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.TryGetInt16(System.Int16@)">
      <summary>Intenta analizar el valor del token JSON actual del origen como <see cref="T:System.Int16" /> y devuelve un valor que indica si la operación se ha realizado correctamente.</summary>
      <param name="value">Cuando este método devuelve un resultado, contiene el valor analizado.</param>
      <exception cref="T:System.InvalidOperationException">El valor del token de JSON no es un objeto <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
      <returns>
        <see langword="true" /> si todo el valor del token con codificación UTF-8 se puede analizar correctamente en un valor <see cref="T:System.Int16" />; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.TryGetInt32(System.Int32@)">
      <summary>Intenta analizar el valor del token JSON actual del origen como <see cref="T:System.Int32" /> y devuelve un valor que indica si la operación se ha realizado correctamente.</summary>
      <param name="value">Cuando este método devuelve un resultado, contiene el valor analizado.</param>
      <exception cref="T:System.InvalidOperationException">El valor del token de JSON no es un objeto <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
      <returns>
        <see langword="true" /> si todo el valor del token con codificación UTF-8 se puede analizar correctamente en un valor <see cref="T:System.Int32" />; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.TryGetInt64(System.Int64@)">
      <summary>Intenta analizar el valor del token JSON actual del origen como <see cref="T:System.Int64" /> y devuelve un valor que indica si la operación se ha realizado correctamente.</summary>
      <param name="value">Cuando este método devuelve un resultado, contiene el valor analizado.</param>
      <exception cref="T:System.InvalidOperationException">El valor del token de JSON no es un objeto <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
      <returns>
        <see langword="true" /> si todo el valor del token con codificación UTF-8 se puede analizar correctamente en un valor <see cref="T:System.Int64" />; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.TryGetSByte(System.SByte@)">
      <summary>Intenta analizar el valor del token JSON actual del origen como <see cref="T:System.SByte" /> y devuelve un valor que indica si la operación se ha realizado correctamente.</summary>
      <param name="value">Cuando este método devuelve un resultado, contiene el valor analizado.</param>
      <exception cref="T:System.InvalidOperationException">El valor del token de JSON no es un objeto <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
      <returns>
        <see langword="true" /> si todo el valor del token con codificación UTF-8 se puede analizar correctamente en un valor <see cref="T:System.SByte" />; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.TryGetSingle(System.Single@)">
      <summary>Intenta analizar el valor del token JSON actual del origen como <see cref="T:System.Single" /> y devuelve un valor que indica si la operación se ha realizado correctamente.</summary>
      <param name="value">Cuando este método devuelve un resultado, contiene el valor analizado.</param>
      <exception cref="T:System.InvalidOperationException">El valor del token de JSON no es un objeto <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
      <returns>
        <see langword="true" /> si todo el valor del token con codificación UTF-8 se puede analizar correctamente en un valor <see cref="T:System.Single" />; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.TryGetUInt16(System.UInt16@)">
      <summary>Intenta analizar el valor del token JSON actual del origen como <see cref="T:System.UInt16" /> y devuelve un valor que indica si la operación se ha realizado correctamente.</summary>
      <param name="value">Cuando este método devuelve un resultado, contiene el valor analizado.</param>
      <exception cref="T:System.InvalidOperationException">El valor del token de JSON no es un objeto <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
      <returns>
        <see langword="true" /> si todo el valor del token con codificación UTF-8 se puede analizar correctamente en un valor <see cref="T:System.UInt16" />; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.TryGetUInt32(System.UInt32@)">
      <summary>Intenta analizar el valor del token JSON actual del origen como <see cref="T:System.UInt32" /> y devuelve un valor que indica si la operación se ha realizado correctamente.</summary>
      <param name="value">Cuando este método devuelve un resultado, contiene el valor analizado.</param>
      <exception cref="T:System.InvalidOperationException">El valor del token de JSON no es un objeto <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
      <returns>
        <see langword="true" /> si todo el valor del token con codificación UTF-8 se puede analizar correctamente en un valor <see cref="T:System.UInt32" />; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.TryGetUInt64(System.UInt64@)">
      <summary>Intenta analizar el valor del token JSON actual del origen como <see cref="T:System.UInt64" /> y devuelve un valor que indica si la operación se ha realizado correctamente.</summary>
      <param name="value">Cuando este método devuelve un resultado, contiene el valor analizado.</param>
      <exception cref="T:System.InvalidOperationException">El valor del token de JSON no es un objeto <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
      <returns>
        <see langword="true" /> si todo el valor del token con codificación UTF-8 se puede analizar correctamente en un valor <see cref="T:System.UInt64" />; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.TrySkip">
      <summary>Intenta omitir los elementos secundarios del token JSON actual.</summary>
      <exception cref="T:System.Text.Json.JsonException">Se ha encontrado un token JSON no válido durante la omisión, según la RFC de JSON.
          
O bien

La profundidad actual supera el límite recursivo establecido por la profundidad máxima.</exception>
      <returns>
        <see langword="true" /> si había suficientes datos para que los elementos secundarios se omitieran correctamente; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.ValueTextEquals(System.ReadOnlySpan{System.Byte})">
      <summary>Compara el texto con codificación UTF-8 de un intervalo de bytes de solo lectura con el valor del token JSON sin escape del origen y devuelve un valor que indica si coinciden.</summary>
      <param name="utf8Text">El texto con codificación UTF-8 con el que se va a comparar.</param>
      <exception cref="T:System.InvalidOperationException">El token JSON no es una cadena (es decir, no es <see cref="F:System.Text.Json.JsonTokenType.String" /> ni <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />).</exception>
      <returns>
        <see langword="true" /> si el valor del token JSON en el origen coincide con el texto de búsqueda con codificación UTF-8; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.ValueTextEquals(System.ReadOnlySpan{System.Char})">
      <summary>Compara el texto de un intervalo de caracteres de solo lectura con el valor del token JSON sin escape del origen y devuelve un valor que indica si coinciden.</summary>
      <param name="text">El texto que se va a comparar.</param>
      <exception cref="T:System.InvalidOperationException">El token JSON no es una cadena (es decir, no es <see cref="F:System.Text.Json.JsonTokenType.String" /> ni <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />).</exception>
      <returns>
        <see langword="true" /> si el valor del token JSON del origen coincide con el texto de búsqueda; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonReader.ValueTextEquals(System.String)">
      <summary>Compara el texto de cadena con el valor del token JSON sin escape del origen y devuelve un valor que indica si coinciden.</summary>
      <param name="text">El texto que se va a comparar.</param>
      <exception cref="T:System.InvalidOperationException">El token JSON no es una cadena (es decir, no es <see cref="F:System.Text.Json.JsonTokenType.String" /> ni <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />).</exception>
      <returns>
        <see langword="true" /> si el valor del token JSON del origen coincide con el texto de búsqueda; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Text.Json.Utf8JsonReader.BytesConsumed">
      <summary>Obtiene el número total de bytes consumidos hasta ahora por esta instancia del <see cref="T:System.Text.Json.Utf8JsonReader" />.</summary>
      <returns>Número total de bytes consumidos hasta ahora.</returns>
    </member>
    <member name="P:System.Text.Json.Utf8JsonReader.CurrentDepth">
      <summary>Obtiene la profundidad del token actual.</summary>
      <returns>Profundidad del token actual.</returns>
    </member>
    <member name="P:System.Text.Json.Utf8JsonReader.CurrentState">
      <summary>Obtiene el estado actual del <see cref="T:System.Text.Json.Utf8JsonReader" /> que se va a pasar a un constructor del <see cref="T:System.Text.Json.Utf8JsonReader" /> con más datos.</summary>
      <returns>Estado actual del lector.</returns>
    </member>
    <member name="P:System.Text.Json.Utf8JsonReader.HasValueSequence">
      <summary>Obtiene un valor que indica qué propiedad <c>Value</c> se va a usar para obtener el valor del token.</summary>
      <returns>
        <see langword="true" />
        <see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" />es si se debe utilizar para obtener el valor del token; <see langword="false" /><see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" /> es si se debe usar en su lugar.</returns>
    </member>
    <member name="P:System.Text.Json.Utf8JsonReader.IsFinalBlock">
      <summary>Obtiene el modo de esta instancia de <see cref="T:System.Text.Json.Utf8JsonReader" />, que indica si se han proporcionado todos los datos JSON o si hay más datos por venir.</summary>
      <returns>
        <see langword="true" /> Si el lector se construyó con el intervalo de entrada o la secuencia que contiene todos los datos JSON que se van a procesar; <see langword="false" /> si el lector se construyó con un intervalo de entrada o una secuencia que puede contener datos JSON parciales con más datos para seguir.</returns>
    </member>
    <member name="P:System.Text.Json.Utf8JsonReader.Position">
      <summary>Obtiene el valor <see cref="T:System.SequencePosition" /> actual dentro del ReadOnlySequence&lt;byte&gt; de entrada con codificación UTF-8 proporcionado, o bien un valor <see cref="T:System.SequencePosition" /> predeterminado si la estructura <see cref="T:System.Text.Json.Utf8JsonReader" /> se ha construido con un ReadOnlySpan&lt;byte&gt;.</summary>
      <returns>El actual <see cref="T:System.SequencePosition" /> dentro del byte ReadOnlySequence de entrada codificado UTF-8 &lt; proporcionado &gt; o un valor predeterminado <see cref="T:System.SequencePosition" /> si el <see cref="T:System.Text.Json.Utf8JsonReader" /> struct se construyó con un &lt; byte ReadOnlySpan &gt; .</returns>
    </member>
    <member name="P:System.Text.Json.Utf8JsonReader.TokenStartIndex">
      <summary>Obtiene el índice en el que comienza el último token JSON procesado (dentro del texto de entrada codificado en UTF-8 proporcionado), y omite los espacios en blanco.</summary>
      <returns>Índice inicial del último token JSON procesado en el texto de entrada codificado en UTF-8 proporcionado.</returns>
    </member>
    <member name="P:System.Text.Json.Utf8JsonReader.TokenType">
      <summary>Obtiene el tipo del último token de JSON procesado en el texto JSON con codificación UTF-8.</summary>
      <returns>Tipo del último token JSON procesado.</returns>
    </member>
    <member name="P:System.Text.Json.Utf8JsonReader.ValueSequence">
      <summary>Obtiene el valor sin procesar del último token procesado como un segmento ReadOnlySequence&lt;byte&gt; de la carga de entrada, solo si el token está contenido en muchos segmentos.</summary>
      <returns>Secuencia de solo lectura de bytes.</returns>
    </member>
    <member name="P:System.Text.Json.Utf8JsonReader.ValueSpan">
      <summary>Obtiene el valor sin procesar del último token procesado como un segmento ReadOnlySpan&lt;byte&gt; de la carga de entrada, si el token se adapta a un único segmento o si el lector se construyó con una carga JSON contenida en ReadOnlySpan&lt;byte&gt;.</summary>
      <returns>Un intervalo de bytes de solo lectura.</returns>
    </member>
    <member name="T:System.Text.Json.Utf8JsonWriter">
      <summary>Proporciona una API de alto rendimiento para la escritura de solo avance sin almacenamiento en caché de texto JSON con codificación UTF-8.</summary>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.#ctor(System.Buffers.IBufferWriter{System.Byte},System.Text.Json.JsonWriterOptions)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.Json.Utf8JsonWriter" /> mediante el <see cref="T:System.Buffers.IBufferWriter`1" /> especificado para escribir la salida y las opciones de personalización.</summary>
      <param name="bufferWriter">Destino de la escritura de texto JSON.</param>
      <param name="options">Define el comportamiento personalizado de <see cref="T:System.Text.Json.Utf8JsonWriter" />. De forma predeterminada, escribe JSON minimizado (sin espacios en blanco adicionales) y valida que el JSON que se escribe es estructuralmente válido según la RFC de JSON.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="bufferWriter" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.#ctor(System.IO.Stream,System.Text.Json.JsonWriterOptions)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.Json.Utf8JsonWriter" /> mediante el flujo especificado para escribir la salida y las opciones de personalización.</summary>
      <param name="utf8Json">Destino de la escritura de texto JSON.</param>
      <param name="options">Define el comportamiento personalizado de <see cref="T:System.Text.Json.Utf8JsonWriter" />. De forma predeterminada, escribe JSON minimizado (sin espacios en blanco adicionales) y valida que el JSON que se escribe es estructuralmente válido según la RFC de JSON.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="utf8Json" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.Dispose">
      <summary>Confirma el texto JSON restante que aún no se ha vaciado y libera todos los recursos utilizados por la instancia actual.</summary>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.DisposeAsync">
      <summary>Confirma asincrónicamente el texto JSON restante que aún no se ha vaciado y libera todos los recursos utilizados por la instancia actual.</summary>
      <returns>Tarea que representa la operación de eliminación asincrónica.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.Flush">
      <summary>Confirma el texto JSON escrito hasta el momento, lo que hace que sea visible en el destino de salida.</summary>
      <exception cref="T:System.ObjectDisposedException">Esta instancia se ha eliminado.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.FlushAsync(System.Threading.CancellationToken)">
      <summary>Confirma asincrónicamente el texto JSON escrito hasta el momento, lo que hace que sea visible en el destino de salida.</summary>
      <param name="cancellationToken">Token para supervisar solicitudes de cancelación. El valor predeterminado es <see cref="P:System.Threading.CancellationToken.None" />.</param>
      <exception cref="T:System.ObjectDisposedException">Esta instancia se ha eliminado.</exception>
      <returns>Tarea que representa la operación de vaciado asincrónica.</returns>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.Reset">
      <summary>Restablece el estado interno de esta instancia para que se pueda reutilizar.</summary>
      <exception cref="T:System.ObjectDisposedException">Esta instancia se ha eliminado.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.Reset(System.Buffers.IBufferWriter{System.Byte})">
      <summary>Restablece el estado interno de esta instancia para que se pueda reutilizar con una nueva instancia de <see cref="T:System.Buffers.IBufferWriter`1" />.</summary>
      <param name="bufferWriter">Destino de la escritura de texto JSON.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="bufferWriter" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Esta instancia se ha eliminado.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.Reset(System.IO.Stream)">
      <summary>Restablece el estado interno de esta instancia para que se pueda reutilizar con una nueva instancia de <see cref="T:System.IO.Stream" />.</summary>
      <param name="utf8Json">Destino de la escritura de texto JSON.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="utf8Json" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Esta instancia se ha eliminado.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteBase64String(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Escribe el nombre de la propiedad y el valor de bytes sin procesar (como cadena JSON codificada en base 64) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="utf8PropertyName">Nombre codificado en UTF-8 de la propiedad que se va a escribir.</param>
      <param name="bytes">Datos binarios que se van a escribir como texto codificado en Base64.</param>
      <exception cref="T:System.ArgumentException">El valor o nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y este método daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteBase64String(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte})">
      <summary>Escribe el nombre de la propiedad y el valor de bytes sin procesar (como cadena JSON codificada en base 64) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="bytes">Datos binarios que se van a escribir como texto codificado en Base64.</param>
      <exception cref="T:System.ArgumentException">El valor o nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y este método daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteBase64String(System.String,System.ReadOnlySpan{System.Byte})">
      <summary>Escribe el nombre de la propiedad y el valor de bytes sin procesar (como cadena JSON codificada en base 64) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="bytes">Datos binarios que se van a escribir como texto codificado en Base64.</param>
      <exception cref="T:System.ArgumentException">El valor o nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y este método daría lugar a la escritura de JSON no válido.</exception>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="propertyName" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteBase64String(System.Text.Json.JsonEncodedText,System.ReadOnlySpan{System.Byte})">
      <summary>Escribe el nombre de la propiedad y el valor de bytes sin procesar codificados previamente (como una cadena JSON codificada en Base64) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre codificado en JSON de la propiedad que se va a escribir.</param>
      <param name="bytes">Datos binarios que se van a escribir como texto codificado en Base64.</param>
      <exception cref="T:System.ArgumentException">El valor especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y este método daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteBase64StringValue(System.ReadOnlySpan{System.Byte})">
      <summary>Escribe el valor de bytes sin procesar como una cadena JSON codificada en Base64 como un elemento de una matriz JSON.</summary>
      <param name="bytes">Los datos binarios que se van a escribir como un elemento de la cadena JSON codificado en Base64 de una matriz JSON.</param>
      <exception cref="T:System.ArgumentException">El valor especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y este método daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteBoolean(System.ReadOnlySpan{System.Byte},System.Boolean)">
      <summary>Escribe el nombre de una propiedad especificado como intervalo de bytes de solo lectura y el valor <see cref="T:System.Boolean" /> (como literal JSON true o false) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
      <param name="value">Valor que se va a escribir como un literal JSON true o false como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteBoolean(System.ReadOnlySpan{System.Char},System.Boolean)">
      <summary>Escribe el nombre de una propiedad especificado como intervalo de caracteres de solo lectura y el valor <see cref="T:System.Boolean" /> (como literal JSON true o false) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va a escribir como un literal JSON true o false como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteBoolean(System.String,System.Boolean)">
      <summary>Escribe el nombre de una propiedad especificado como cadena y el valor <see cref="T:System.Boolean" /> (como literal JSON true o false) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va a escribir como un literal JSON true o false como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="propertyName" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteBoolean(System.Text.Json.JsonEncodedText,System.Boolean)">
      <summary>Escribe el nombre de la propiedad y el valor <see cref="T:System.Boolean" /> codificados previamente (como literal JSON true o false) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de la propiedad con codificación JSON del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va a escribir como un literal JSON true o false como parte del par nombre-valor.</param>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y este método daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteBooleanValue(System.Boolean)">
      <summary>Escribe un valor <see cref="T:System.Boolean" /> (como literal JSON true o false) como elemento de una matriz JSON.</summary>
      <param name="value">Valor que se va a escribir como un literal JSON true o false como un elemento de una matriz JSON.</param>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteCommentValue(System.ReadOnlySpan{System.Byte})">
      <summary>Escribe el valor de texto UTF-8 como comentario JSON.</summary>
      <param name="utf8Value">Valor codificado UTF-8 que se va a escribir como comentario JSON dentro de <c> / *..* / </c>.</param>
      <exception cref="T:System.ArgumentException">El valor especificado es demasiado grande.
        
o bien

<paramref name="utf8Value" /> contiene un delimitador de comentario (es decir, <c>*/</c> ).</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteCommentValue(System.ReadOnlySpan{System.Char})">
      <summary>Escribe el valor de texto UTF-16 como comentario JSON.</summary>
      <param name="value">Valor codificado UTF-16 que se va a escribir como un comentario JSON transcodificado UTF-8 dentro de <c> / *..* / </c>.</param>
      <exception cref="T:System.ArgumentException">El valor especificado es demasiado grande.
        
o bien

<paramref name="value" /> contiene un delimitador de comentario (es decir, <c>*/</c> ).</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteCommentValue(System.String)">
      <summary>Escribe el valor de texto de cadena como comentario JSON.</summary>
      <param name="value">Valor codificado UTF-16 que se va a escribir como un comentario JSON transcodificado UTF-8 dentro de <c> / *..* / </c>.</param>
      <exception cref="T:System.ArgumentException">El valor especificado es demasiado grande.
        
o bien

<paramref name="value" /> contiene un delimitador de comentario (es decir, <c>*/</c> ).</exception>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="value" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteEndArray">
      <summary>Escribe el final de una matriz de JSON.</summary>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteEndObject">
      <summary>Escribe el final de un objeto de JSON.</summary>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNull(System.ReadOnlySpan{System.Byte})">
      <summary>Escribe el nombre de una propiedad especificado como intervalo de bytes de solo lectura y el literal JSON null como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNull(System.ReadOnlySpan{System.Char})">
      <summary>Escribe el nombre de una propiedad especificado como intervalo de caracteres de solo lectura y el literal JSON null como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNull(System.String)">
      <summary>Escribe el nombre de una propiedad especificado como cadena y el literal JSON null como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="propertyName" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNull(System.Text.Json.JsonEncodedText)">
      <summary>Escribe el nombre de propiedad y el literal JSON null codificados previamente como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de la propiedad con codificación JSON del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y este método daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNullValue">
      <summary>Escribe el literal JSON null como un elemento de una matriz JSON.</summary>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Byte},System.Decimal)">
      <summary>Escribe el nombre de propiedad especificado como intervalo de bytes de solo lectura y el valor <see cref="T:System.Decimal" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Byte},System.Double)">
      <summary>Escribe el nombre de propiedad especificado como intervalo de bytes de solo lectura y el valor <see cref="T:System.Double" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Byte},System.Int32)">
      <summary>Escribe el nombre de propiedad especificado como intervalo de bytes de solo lectura y el valor <see cref="T:System.Int32" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Byte},System.Int64)">
      <summary>Escribe el nombre de propiedad especificado como intervalo de bytes de solo lectura y el valor <see cref="T:System.Int64" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Byte},System.Single)">
      <summary>Escribe el nombre de propiedad especificado como intervalo de bytes de solo lectura y el valor <see cref="T:System.Single" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Byte},System.UInt32)">
      <summary>Escribe el nombre de propiedad especificado como intervalo de bytes de solo lectura y el valor <see cref="T:System.UInt32" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Byte},System.UInt64)">
      <summary>Escribe el nombre de propiedad especificado como intervalo de bytes de solo lectura y el valor <see cref="T:System.UInt64" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Char},System.Decimal)">
      <summary>Escribe el nombre de propiedad especificado como intervalo de caracteres de solo lectura y el valor <see cref="T:System.Decimal" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Char},System.Double)">
      <summary>Escribe el nombre de propiedad especificado como intervalo de caracteres de solo lectura y el valor <see cref="T:System.Double" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Char},System.Int32)">
      <summary>Escribe el nombre de propiedad especificado como intervalo de caracteres de solo lectura y el valor <see cref="T:System.Int32" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Char},System.Int64)">
      <summary>Escribe el nombre de propiedad especificado como intervalo de caracteres de solo lectura y el valor <see cref="T:System.Int64" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Char},System.Single)">
      <summary>Escribe el nombre de propiedad especificado como intervalo de caracteres de solo lectura y el valor <see cref="T:System.Single" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Char},System.UInt32)">
      <summary>Escribe el nombre de propiedad especificado como intervalo de caracteres de solo lectura y el valor <see cref="T:System.UInt32" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Char},System.UInt64)">
      <summary>Escribe el nombre de propiedad especificado como intervalo de caracteres de solo lectura y el valor <see cref="T:System.UInt64" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.String,System.Decimal)">
      <summary>Escribe el nombre de propiedad especificado como cadena y el valor <see cref="T:System.Decimal" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="propertyName" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.String,System.Double)">
      <summary>Escribe el nombre de propiedad especificado como cadena y el valor <see cref="T:System.Double" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="propertyName" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.String,System.Int32)">
      <summary>Escribe el nombre de propiedad especificado como cadena y el valor <see cref="T:System.Int32" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="propertyName" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.String,System.Int64)">
      <summary>Escribe el nombre de propiedad especificado como cadena y el valor <see cref="T:System.Int64" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="propertyName" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.String,System.Single)">
      <summary>Escribe el nombre de propiedad especificado como cadena y el valor <see cref="T:System.Single" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="propertyName" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.String,System.UInt32)">
      <summary>Escribe el nombre de propiedad especificado como cadena y el valor <see cref="T:System.UInt32" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="propertyName" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.String,System.UInt64)">
      <summary>Escribe el nombre de propiedad especificado como cadena y el valor <see cref="T:System.UInt64" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="propertyName" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.Text.Json.JsonEncodedText,System.Decimal)">
      <summary>Escribe el nombre de propiedad y el valor <see cref="T:System.Decimal" /> codificados previamente (como número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de la propiedad con codificación JSON del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y este método daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.Text.Json.JsonEncodedText,System.Double)">
      <summary>Escribe el nombre de propiedad y el valor <see cref="T:System.Double" /> codificados previamente (como número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de la propiedad con codificación JSON del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y este método daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.Text.Json.JsonEncodedText,System.Int32)">
      <summary>Escribe el nombre de propiedad y el valor <see cref="T:System.Int32" /> codificados previamente (como número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de la propiedad con codificación JSON del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y este método daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.Text.Json.JsonEncodedText,System.Int64)">
      <summary>Escribe el nombre de propiedad y el valor <see cref="T:System.Int64" /> codificados previamente (como número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de la propiedad con codificación JSON del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y este método daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.Text.Json.JsonEncodedText,System.Single)">
      <summary>Escribe el nombre de propiedad y el valor <see cref="T:System.Single" /> codificados previamente (como número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de la propiedad con codificación JSON del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y este método daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.Text.Json.JsonEncodedText,System.UInt32)">
      <summary>Escribe el nombre de propiedad y el valor <see cref="T:System.UInt32" /> codificados previamente (como número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de la propiedad con codificación JSON del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y este método daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.Text.Json.JsonEncodedText,System.UInt64)">
      <summary>Escribe el nombre de propiedad y el valor <see cref="T:System.UInt64" /> codificados previamente (como número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de la propiedad con codificación JSON del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y este método daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumberValue(System.Decimal)">
      <summary>Escribe el valor <see cref="T:System.Decimal" /> (como un número JSON) como elemento de una matriz JSON.</summary>
      <param name="value">Valor que se va a escribir como un número de JSON como un elemento de una matriz de JSON.</param>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumberValue(System.Double)">
      <summary>Escribe el valor <see cref="T:System.Double" /> (como un número JSON) como elemento de una matriz JSON.</summary>
      <param name="value">Valor que se va a escribir como un número de JSON como un elemento de una matriz de JSON.</param>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumberValue(System.Int32)">
      <summary>Escribe el valor <see cref="T:System.Int32" /> (como un número JSON) como elemento de una matriz JSON.</summary>
      <param name="value">Valor que se va a escribir como un número de JSON como un elemento de una matriz de JSON.</param>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumberValue(System.Int64)">
      <summary>Escribe el valor <see cref="T:System.Int64" /> (como un número JSON) como elemento de una matriz JSON.</summary>
      <param name="value">Valor que se va a escribir como un número de JSON como un elemento de una matriz de JSON.</param>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumberValue(System.Single)">
      <summary>Escribe el valor <see cref="T:System.Single" /> (como un número JSON) como elemento de una matriz JSON.</summary>
      <param name="value">Valor que se va a escribir como un número de JSON como un elemento de una matriz de JSON.</param>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumberValue(System.UInt32)">
      <summary>Escribe el valor <see cref="T:System.UInt32" /> (como un número JSON) como elemento de una matriz JSON.</summary>
      <param name="value">Valor que se va a escribir como un número de JSON como un elemento de una matriz de JSON.</param>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteNumberValue(System.UInt64)">
      <summary>Escribe el valor <see cref="T:System.UInt64" /> (como un número JSON) como elemento de una matriz JSON.</summary>
      <param name="value">Valor que se va a escribir como un número de JSON como un elemento de una matriz de JSON.</param>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WritePropertyName(System.ReadOnlySpan{System.Byte})">
      <summary>Escribe el nombre de propiedad UTF-8 (como una cadena JSON) como primera parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y esta operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WritePropertyName(System.ReadOnlySpan{System.Char})">
      <summary>Escribe el nombre de propiedad (como una cadena JSON) como primera parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y esta operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WritePropertyName(System.String)">
      <summary>Escribe el nombre de propiedad (como una cadena JSON) como primera parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y esta operación de escritura generaría un JSON no válido.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyName" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WritePropertyName(System.Text.Json.JsonEncodedText)">
      <summary>Escribe el nombre de propiedad codificado previamente (como cadena JSON) como primera parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de la propiedad con codificación JSON del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y esta operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteStartArray">
      <summary>Escribe el principio de una matriz de JSON.</summary>
      <exception cref="T:System.InvalidOperationException">La profundidad del archivo JSON supera la profundidad máxima de 1000.

o bien

La validación está habilitada y esta operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteStartArray(System.ReadOnlySpan{System.Byte})">
      <summary>Escribe el principio de una matriz JSON con un nombre de propiedad especificado como intervalo de bytes de solo lectura como la clave.</summary>
      <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 de la matriz JSON que se va a escribir.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La profundidad del archivo JSON supera la profundidad máxima de 1000.

o bien
       
La validación está habilitada y esta operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteStartArray(System.ReadOnlySpan{System.Char})">
      <summary>Escribe el principio de una matriz JSON con un nombre de propiedad especificado como intervalo de caracteres de solo lectura como la clave.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 de la matriz de JSON que se va a transcodificar y escribir como UTF-8.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La profundidad del archivo JSON supera la profundidad máxima de 1000.

o bien
       
La validación está habilitada y esta operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteStartArray(System.String)">
      <summary>Escribe el principio de una matriz JSON con un nombre de propiedad especificado como cadena como la clave.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 de la matriz de JSON que se va a transcodificar y escribir como UTF-8.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La profundidad del archivo JSON supera la profundidad máxima de 1000.

o bien
       
La validación está habilitada y esta operación de escritura generaría un JSON no válido.</exception>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="propertyName" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteStartArray(System.Text.Json.JsonEncodedText)">
      <summary>Escribe el principio de una matriz JSON con un nombre de propiedad codificado previamente como clave.</summary>
      <param name="propertyName">Nombre de propiedad con codificación JSON de la matriz JSON que se va a transcodificar y escribir como UTF-8.</param>
      <exception cref="T:System.InvalidOperationException">La profundidad del código de JSON ha superado la profundidad máxima de 1000.
    
o bien

La validación está habilitada y este método daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteStartObject">
      <summary>Escribe el principio de un objeto de JSON.</summary>
      <exception cref="T:System.InvalidOperationException">La profundidad del archivo JSON supera la profundidad máxima de 1000.

o bien

La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteStartObject(System.ReadOnlySpan{System.Byte})">
      <summary>Escribe el principio de un objeto JSON con un nombre de propiedad especificado como intervalo de bytes de solo lectura como la clave.</summary>
      <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La profundidad del archivo JSON supera la profundidad máxima de 1000. 

o bien
       
La validación está habilitada y esta operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteStartObject(System.ReadOnlySpan{System.Char})">
      <summary>Escribe el principio de un objeto JSON con un nombre de propiedad especificado como intervalo de caracteres de solo lectura como la clave.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La profundidad del archivo JSON supera la profundidad máxima de 1000. 

o bien
       
La validación está habilitada y esta operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteStartObject(System.String)">
      <summary>Escribe el principio de un objeto JSON con un nombre de propiedad especificado como cadena como la clave.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La profundidad del archivo JSON supera la profundidad máxima de 1000. 

o bien
       
La validación está habilitada y esta operación de escritura generaría un JSON no válido.</exception>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="propertyName" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteStartObject(System.Text.Json.JsonEncodedText)">
      <summary>Escribe el principio de un objeto JSON con un nombre de propiedad codificado previamente como clave.</summary>
      <param name="propertyName">Nombre de la propiedad con codificación JSON del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <exception cref="T:System.InvalidOperationException">La profundidad del código de JSON ha superado la profundidad máxima de 1000.
          
o bien

La validación está habilitada y este método daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.ReadOnlySpan{System.Byte},System.DateTime)">
      <summary>Escribe el nombre de propiedad UTF-8 y el valor <see cref="T:System.DateTime" /> (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
      <param name="value">Valor que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.ReadOnlySpan{System.Byte},System.DateTimeOffset)">
      <summary>Escribe el nombre de propiedad UTF-8 y el valor <see cref="T:System.DateTimeOffset" /> (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
      <param name="value">Valor que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.ReadOnlySpan{System.Byte},System.Guid)">
      <summary>Escribe el nombre de propiedad UTF-8 y el valor <see cref="T:System.Guid" /> (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
      <param name="value">Valor que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Escribe el nombre de propiedad UTF-8 y el valor de texto UTF-8 (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
      <param name="utf8Value">Valor con codificación UTF-8 que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El valor o nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Char})">
      <summary>Escribe el nombre de propiedad UTF-8 y el valor de texto UTF-16 (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
      <param name="value">Valor con codificación UTF-16 que se va escribir como una cadena de JSON transcodificada a UTF-8 como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El valor o nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.ReadOnlySpan{System.Byte},System.String)">
      <summary>Escribe el nombre de propiedad UTF-8 y el valor de texto de cadena (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
      <param name="value">Valor con codificación UTF-16 que se va escribir como una cadena de JSON transcodificada a UTF-8 como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El valor o nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.ReadOnlySpan{System.Byte},System.Text.Json.JsonEncodedText)">
      <summary>Escribe el nombre de propiedad UTF-8 y el valor codificado previamente (como cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
      <param name="value">Valor con codificación JSON que se va escribir como cadena JSON transcodificada a UTF-8 como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y este método daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.ReadOnlySpan{System.Char},System.DateTime)">
      <summary>Escribe el nombre de propiedad especificado como intervalo de caracteres de solo lectura y el valor <see cref="T:System.DateTime" /> (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.ReadOnlySpan{System.Char},System.DateTimeOffset)">
      <summary>Escribe el nombre de propiedad especificado como intervalo de caracteres de solo lectura y el valor <see cref="T:System.DateTimeOffset" /> (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.ReadOnlySpan{System.Char},System.Guid)">
      <summary>Escribe el nombre de propiedad especificado como intervalo de caracteres de solo lectura y el valor <see cref="T:System.Guid" /> (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte})">
      <summary>Escribe el nombre de propiedad UTF-16 y el valor de texto UTF-8 (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="utf8Value">Valor con codificación UTF-8 que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El valor o nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>Escribe el nombre de propiedad UTF-16 y el valor de texto UTF-16 (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor con codificación UTF-16 que se va escribir como una cadena de JSON transcodificada a UTF-8 como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El valor o nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.ReadOnlySpan{System.Char},System.String)">
      <summary>Escribe el nombre de propiedad UTF-16 y el valor de texto de cadena (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor con codificación UTF-16 que se va escribir como una cadena de JSON transcodificada a UTF-8 como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El valor o nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.ReadOnlySpan{System.Char},System.Text.Json.JsonEncodedText)">
      <summary>Escribe el nombre de propiedad y el valor codificado previamente (como cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor con codificación JSON que se va escribir como cadena JSON transcodificada a UTF-8 como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.String,System.DateTime)">
      <summary>Escribe el nombre de propiedad especificado como cadena y el valor <see cref="T:System.DateTime" /> (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="propertyName" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.String,System.DateTimeOffset)">
      <summary>Escribe el nombre de propiedad especificado como cadena y el valor <see cref="T:System.DateTimeOffset" /> (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="propertyName" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.String,System.Guid)">
      <summary>Escribe el nombre de propiedad especificado como cadena y el valor <see cref="T:System.Guid" /> (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="propertyName" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.String,System.ReadOnlySpan{System.Byte})">
      <summary>Escribe el nombre de propiedad especificado como cadena y el valor de texto UTF-8 (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="utf8Value">Valor con codificación UTF-8 que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El valor o nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="propertyName" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.String,System.ReadOnlySpan{System.Char})">
      <summary>Escribe el nombre de propiedad especificado como cadena y el valor de texto UTF-16 (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor con codificación UTF-16 que se va escribir como una cadena de JSON transcodificada a UTF-8 como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El valor o nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="propertyName" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.String,System.String)">
      <summary>Escribe el nombre de propiedad especificado como cadena y el valor de texto de cadena (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor con codificación UTF-16 que se va escribir como una cadena de JSON transcodificada a UTF-8 como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El valor o nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="propertyName" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.String,System.Text.Json.JsonEncodedText)">
      <summary>Escribe el nombre de propiedad y el valor codificado previamente (como cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de propiedad del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor con codificación JSON que se va escribir como cadena JSON transcodificada a UTF-8 como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="propertyName" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.Text.Json.JsonEncodedText,System.DateTime)">
      <summary>Escribe el nombre de propiedad y el valor <see cref="T:System.DateTime" /> codificados previamente (como cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de la propiedad con codificación JSON del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.Text.Json.JsonEncodedText,System.DateTimeOffset)">
      <summary>Escribe el nombre de propiedad y el valor <see cref="T:System.DateTimeOffset" /> codificados previamente (como cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de la propiedad con codificación JSON del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.Text.Json.JsonEncodedText,System.Guid)">
      <summary>Escribe el nombre de propiedad y el valor <see cref="T:System.Guid" /> codificados previamente (como cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de la propiedad con codificación JSON del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.Text.Json.JsonEncodedText,System.ReadOnlySpan{System.Byte})">
      <summary>Escribe el nombre de propiedad y el valor de texto UTF-8 codificados previamente (como cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de la propiedad con codificación JSON del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="utf8Value">Valor con codificación UTF-8 que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El valor especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.Text.Json.JsonEncodedText,System.ReadOnlySpan{System.Char})">
      <summary>Escribe el nombre de propiedad y el valor de texto codificados previamente (como cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de la propiedad con codificación JSON del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como cadena JSON transcodificada a UTF-8 como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El valor especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.Text.Json.JsonEncodedText,System.String)">
      <summary>Escribe el nombre de propiedad y el valor de texto de cadena codificados previamente (como cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de la propiedad con codificación JSON del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor que se va escribir como cadena JSON transcodificada a UTF-8 como parte del par nombre-valor.</param>
      <exception cref="T:System.ArgumentException">El valor especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteString(System.Text.Json.JsonEncodedText,System.Text.Json.JsonEncodedText)">
      <summary>Escribe el nombre de propiedad y el valor codificado previamente (como cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
      <param name="propertyName">Nombre de la propiedad con codificación JSON del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
      <param name="value">Valor con codificación JSON que se va escribir como cadena JSON transcodificada a UTF-8 como parte del par nombre-valor.</param>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteStringValue(System.DateTime)">
      <summary>Escribe el valor <see cref="T:System.DateTime" /> (como una cadena JSON) como elemento de una matriz JSON.</summary>
      <param name="value">Valor que se va a escribir como una cadena de JSON como un elemento de una matriz de JSON.</param>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteStringValue(System.DateTimeOffset)">
      <summary>Escribe el valor <see cref="T:System.DateTimeOffset" /> (como una cadena JSON) como elemento de una matriz JSON.</summary>
      <param name="value">Valor que se va a escribir como una cadena de JSON como un elemento de una matriz de JSON.</param>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteStringValue(System.Guid)">
      <summary>Escribe el valor <see cref="T:System.Guid" /> (como una cadena JSON) como elemento de una matriz JSON.</summary>
      <param name="value">Valor que se va a escribir como una cadena de JSON como un elemento de una matriz de JSON.</param>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteStringValue(System.ReadOnlySpan{System.Byte})">
      <summary>Escribe el valor de texto UTF-8 (como una cadena JSON) como elemento de una matriz JSON.</summary>
      <param name="utf8Value">El valor con codificación UTF-8 que se va a escribir como un elemento de cadena de JSON de una matriz de JSON.</param>
      <exception cref="T:System.ArgumentException">El valor especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteStringValue(System.ReadOnlySpan{System.Char})">
      <summary>Escribe el valor de texto UTF-16 (como una cadena JSON) como elemento de una matriz JSON.</summary>
      <param name="value">Valor con codificación UTF-16 que se va a escribir como un elemento de cadena de JSON transcodificado a UTF-8 de una matriz de JSON.</param>
      <exception cref="T:System.ArgumentException">El valor especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteStringValue(System.String)">
      <summary>Escribe el valor de texto de cadena (como una cadena JSON) como elemento de una matriz JSON.</summary>
      <param name="value">Valor con codificación UTF-16 que se va a escribir como un elemento de cadena de JSON transcodificado a UTF-8 de una matriz de JSON.</param>
      <exception cref="T:System.ArgumentException">El valor especificado es demasiado grande.</exception>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="M:System.Text.Json.Utf8JsonWriter.WriteStringValue(System.Text.Json.JsonEncodedText)">
      <summary>Escribe el valor de texto codificado previamente (como cadena JSON) como elemento de una matriz JSON.</summary>
      <param name="value">Valor con codificación JSON que se va a escribir como elemento de cadena JSON transcodificado a UTF-8 de una matriz JSON.</param>
      <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
    </member>
    <member name="P:System.Text.Json.Utf8JsonWriter.BytesCommitted">
      <summary>Obtiene el número total de bytes confirmados en la salida por la instancia actual hasta el momento.</summary>
      <returns>Número total de bytes confirmados en la salida hasta el <see cref="T:System.Text.Json.Utf8JsonWriter" /> momento.</returns>
    </member>
    <member name="P:System.Text.Json.Utf8JsonWriter.BytesPending">
      <summary>Obtiene el número de bytes escritos por el objeto <see cref="T:System.Text.Json.Utf8JsonWriter" /> hasta el momento que aún no se han vaciado en la salida y confirmado.</summary>
      <returns>Número de bytes escritos hasta el momento por el <see cref="T:System.Text.Json.Utf8JsonWriter" /> que aún no se han vaciado en la salida y confirmados.</returns>
    </member>
    <member name="P:System.Text.Json.Utf8JsonWriter.CurrentDepth">
      <summary>Obtiene la profundidad del token actual.</summary>
      <returns>Profundidad del token actual.</returns>
    </member>
    <member name="P:System.Text.Json.Utf8JsonWriter.Options">
      <summary>Obtiene el comportamiento personalizado al escribir JSON con esta instancia, lo que indica si se debe dar formato a la salida mientras se escribe, si se debe omitir la validación JSON estructural y qué caracteres se deben escapar.</summary>
      <returns>Comportamiento personalizado de esta instancia del escritor para dar formato, validar y escapar.</returns>
    </member>
  </members>
</doc>