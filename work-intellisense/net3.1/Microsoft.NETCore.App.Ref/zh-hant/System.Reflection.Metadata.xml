<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:vsli="https://github.com/sk-0520/vs-localized-intellisense/tree/master/schema/2024">
  <assembly>
    <name>System.Reflection.Metadata</name>
  </assembly>
  <members>
    <member name="T:System.Reflection.AssemblyFlags" />
    <member name="F:System.Reflection.AssemblyFlags.ContentTypeMask">
      <summary vsli:raw="Content type masked bits that correspond to values of &lt;see cref=&quot;T:System.Reflection.AssemblyContentType&quot; /&gt;.">與 <see cref="T:System.Reflection.AssemblyContentType" /> 的值相對應的內容類型遮罩位元。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.DisableJitCompileOptimizer">
      <summary vsli:raw="Just-In-Time (JIT) compiler optimization is disabled for the assembly.">已停用組件的 Just-In-Time (JIT) 編譯器最佳化。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.EnableJitCompileTracking">
      <summary vsli:raw="Just-In-Time (JIT) compiler tracking is enabled for the assembly.">已啟用組件的 Just-In-Time (JIT) 編譯器追蹤。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.PublicKey">
      <summary vsli:raw="The assembly reference holds the full (unhashed) public key. Not applicable on assembly definition.">組件參考會持有完整 (未雜湊) 公開金鑰。 不適用於組件定義。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.Retargetable">
      <summary vsli:raw="The implementation of the referenced assembly used at runtime is not expected to match the version seen at compile time.">不預期執行階段所使用參考組件的實作，會符合編譯時間見到的版本。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.WindowsRuntime">
      <summary vsli:raw="The assembly contains Windows Runtime code.">組件包含 Windows 執行階段程式碼。</summary>
    </member>
    <member name="T:System.Reflection.AssemblyHashAlgorithm">
      <summary vsli:raw="Specifies the hash algorithms used for hashing assembly files and for generating the strong name.">指定用於雜湊化組件檔，以及產生強式名稱的雜湊演算法。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.MD5">
      <summary vsli:raw="&lt;para&gt;Retrieves the MD5 message-digest algorithm.&lt;/para&gt;&lt;para&gt;Due to collision problems with MD5, Microsoft recommends SHA256.&lt;/para&gt;&lt;para&gt;MD5 was developed by Rivest in 1991. It is basically MD4 with safety-belts and, while it is slightly slower than MD4, it helps provide more security. The algorithm consists of four distinct rounds, which has a slightly different design from that of MD4. Message-digest size, as well as padding requirements, remain the same.&lt;/para&gt;">擷取 MD5 訊息摘要演算法。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.None">
      <summary vsli:raw="&lt;para&gt;A mask indicating that there is no hash algorithm.&lt;/para&gt;&lt;para&gt;If you specify &lt;see cref=&quot;F:System.Reflection.AssemblyHashAlgorithm.None&quot; /&gt; for a multi-module assembly, the common language runtime defaults to the SHA1 algorithm, since multi-module assemblies need to generate a hash.&lt;/para&gt;">指示沒有雜湊演算法的遮罩。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha1">
      <summary vsli:raw="&lt;para&gt;Retrieves a revision of the Secure Hash Algorithm that corrects an unpublished flaw in SHA.&lt;/para&gt;&lt;para&gt;Due to collision problems with SHA1, Microsoft recommends SHA256.&lt;/para&gt;">接收能修正 SHA 中未發佈缺陷的安全雜湊演算法。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha256">
      <summary vsli:raw="Retrieves a version of the Secure Hash Algorithm with a hash size of 256 bits.">接收雜湊大小為 256 位元的安全雜湊演算法版本。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha384">
      <summary vsli:raw="Retrieves a version of the Secure Hash Algorithm with a hash size of 384 bits.">接收雜湊大小為 384 位元的安全雜湊演算法版本。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha512">
      <summary vsli:raw="Retrieves a version of the Secure Hash Algorithm with a hash size of 512 bits.">接收雜湊大小為 512 位元的安全雜湊演算法版本。</summary>
    </member>
    <member name="T:System.Reflection.DeclarativeSecurityAction">
      <summary vsli:raw="Specifies the security actions that can be performed using declarative security.">指定可以使用宣告式安全性執行的安全性動作。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Assert">
      <summary vsli:raw="The calling code can access the resource identified by the current permission object, even if callers higher in the stack have not been granted permission to access the resource.">即使堆疊中較高層的呼叫端未獲授與權限存取資源，進行呼叫的程式碼仍可以存取由目前權限物件所識別的資源。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Demand">
      <summary vsli:raw="Check that all callers in the call chain have been granted the specified permission.">檢查呼叫鏈中所有呼叫是否都已經獲授與指定權限。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Deny">
      <summary vsli:raw="Without further checks refuse Demand for the specified permission.">拒絕 Demand 指定的權限而不進一步檢查。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.InheritanceDemand">
      <summary vsli:raw="The derived class inheriting the class or overriding a method is required to have the specified permission.">繼承類別或覆寫方法的衍生類別必須有指定權限。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.LinkDemand">
      <summary vsli:raw="Check that the immediate caller has been granted the specified permission.">檢查直接呼叫端是否已獲授與指定權限。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.None">
      <summary vsli:raw="No declarative security action.">沒有宣告式安全性動作。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.PermitOnly">
      <summary vsli:raw="Without further checks, refuse the demand for all permissions other than those specified.">拒絕指定權限以外的所有權限要求，而不進一步檢查。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestMinimum">
      <summary vsli:raw="Request the minimum permissions required for code to run. This action can only be used within the scope of the assembly.">要求執行程式碼所需的最低權限。 這個動作只能在組件的範圍內使用。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestOptional">
      <summary vsli:raw="Request additional permissions that are optional (not required to run). This request implicitly refuses all other permissions not specifically requested. This action can only be used within the scope of the assembly.">要求選擇性 (非執行所需) 的其他權限。 這項要求會隱含拒絕未特別要求的所有其他權限。 這個動作只能在組件的範圍內使用。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestRefuse">
      <summary vsli:raw="Request that permissions that might be misused not be granted to the calling code. This action can only be used within the scope of the assembly.">要求不授與呼叫程式碼可能遭到誤用的權限。 這個動作只能在組件的範圍內使用。</summary>
    </member>
    <member name="T:System.Reflection.ManifestResourceAttributes" />
    <member name="F:System.Reflection.ManifestResourceAttributes.Private">
      <summary vsli:raw="The resource is not exported from the assembly.">資源不會從組件匯出。</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.Public">
      <summary vsli:raw="The resource is exported from the assembly.">資源會從組件匯出。</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.VisibilityMask">
      <summary vsli:raw="Masks just the visibility-related attributes.">只遮罩可見度相關的屬性。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ArrayShape">
      <summary vsli:raw="Represents the shape of an array type.">表示陣列類型的圖形。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ArrayShape.#ctor(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.ArrayShape&quot; /&gt; structure.">初始化 <see cref="T:System.Reflection.Metadata.ArrayShape" /> 結構的新執行個體。</summary>
      <param name="rank" vsli:raw="The number of dimensions in the array.">陣列中維度的數目。</param>
      <param name="sizes" vsli:raw="The size of each dimension.">每一個維度的大小。</param>
      <param name="lowerBounds" vsli:raw="The lower-bound of each dimension.">每一個維度的下限。</param>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.LowerBounds">
      <summary vsli:raw="Gets the lower-bounds of all dimensions. Length may be smaller than rank, in which case the trailing dimensions have unspecified lower bounds.">取得所有維度的下限。 後置維度未指定下限時，長度可能會小於順位。</summary>
      <returns vsli:raw="An array of lower-bounds.">較低範圍的陣列。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Rank">
      <summary vsli:raw="Gets the number of dimensions in the array.">取得陣列的維度數目。</summary>
      <returns vsli:raw="The number of dimensions.">維度的數目。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Sizes">
      <summary vsli:raw="Gets the sizes of all dimensions.">取得所有維度的大小。</summary>
      <returns vsli:raw="An array of sizes.">大小的陣列。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyDefinition" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Flags" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetDeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.PublicKey" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Equality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Inequality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFile" />
    <member name="P:System.Reflection.Metadata.AssemblyFile.ContainsMetadata">
      <summary vsli:raw="Gets a value that indicates whether the file contains metadata.">取得表示檔案是否包含中繼資料的值。</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the file contains metadata, &lt;see langword=&quot;false&quot; /&gt; otherwise.">如果檔案包含中繼資料，<see langword="true" />，否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFile.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyFile.HashValue">
      <summary vsli:raw="Gets the hash value of the file content calculated using &lt;see cref=&quot;P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm&quot; /&gt;.">取得使用 <see cref="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" /> 計算的檔案內容雜湊值。</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.BlobHandle&quot; /&gt; instance representing the hash value of the file content.">
        <see cref="T:System.Reflection.Metadata.BlobHandle" /> 實例，代表檔案內容的雜湊值。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFile.Name">
      <summary vsli:raw="Gets the file name, including its extension.">取得檔案名稱，包括其副檔名。</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.StringHandle&quot; /&gt; instance representing the file name with its extension.">
        <see cref="T:System.Reflection.Metadata.StringHandle" /> 實例，代表檔案名及其副檔名。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.AssemblyFileHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Equality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Inequality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection">
      <summary vsli:raw="Represents a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;.">代表 <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" /> 的集合。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyFileHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.AssemblyReference" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Flags" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.HashValue" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.PublicKeyOrToken" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Equality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Inequality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection">
      <summary vsli:raw="A collection of assembly references.">組件參考的集合。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyReferenceHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.Blob" />
    <member name="M:System.Reflection.Metadata.Blob.GetBytes" />
    <member name="P:System.Reflection.Metadata.Blob.IsDefault" />
    <member name="P:System.Reflection.Metadata.Blob.Length" />
    <member name="T:System.Reflection.Metadata.BlobBuilder" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.#ctor(System.Int32)">
      <param name="capacity" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Align(System.Int32)">
      <param name="alignment" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.AllocateChunk(System.Int32)">
      <param name="minimalSize" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.BlobBuilder.Blobs" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.Current" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.MoveNext" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.Reset" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#Blob}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerable#GetEnumerator" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#IDisposable#Dispose" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.ChunkCapacity" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Clear" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.ContentEquals(System.Reflection.Metadata.BlobBuilder)">
      <summary vsli:raw="Compares the current content of this writer with another one.">將此寫入器的目前內容與另一個比較。</summary>
      <param name="other" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.BlobBuilder&quot; /&gt; instance to compare with this one.">要與此項目比較的 <see cref="T:System.Reflection.Metadata.BlobBuilder" /> 執行個體。</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">如果相等則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">內容是不可寫入的；建立器已與另一個連結。</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.Count" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Free" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.FreeBytes" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.FreeChunk" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.GetBlobs">
      <summary vsli:raw="Returns a sequence of all blobs that represent the content of the builder.">傳回代表建立器內容之所有 Blob 的序列。</summary>
      <returns vsli:raw="A sequence of blobs.">Blob 的序列。</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">內容是不可寫入的；建立器已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkPrefix(System.Reflection.Metadata.BlobBuilder)">
      <param name="prefix" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;prefix&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="prefix" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkSuffix(System.Reflection.Metadata.BlobBuilder)">
      <param name="suffix" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;suffix&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="suffix" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.PadTo(System.Int32)">
      <param name="position" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ReserveBytes(System.Int32)">
      <summary vsli:raw="Reserves a contiguous block of bytes.">保留連續的位元組區塊。</summary>
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> 為負。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray">
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">內容是不可寫入的；建立器已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray(System.Int32,System.Int32)">
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the buffer content.">
        <paramref name="start" /> 和 <paramref name="byteCount" /> 指定的範圍超出緩衝區內容的界限。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">內容是不可寫入的；建立器已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray">
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">內容是不可寫入的；建立器已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the buffer content.">
        <paramref name="start" /> 和 <paramref name="byteCount" /> 指定的範圍超出緩衝區內容的界限。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">內容是不可寫入的；建立器已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.TryWriteBytes(System.IO.Stream,System.Int32)">
      <summary vsli:raw="Attempts to write a sequence of bytes to the builder. A return value indicates the number of bytes successfully written.">嘗試將位元組序列寫入至建立器。 表示成功寫入之位元組數目的傳回值。</summary>
      <param name="source" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <returns vsli:raw="The number of bytes successfully written from &lt;paramref name=&quot;source&quot; /&gt;.">從 <paramref name="source" /> 成功寫入的位元組數目。</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="source" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> 為負。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBoolean(System.Boolean)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Boolean&quot; /&gt; value to the builder.">將 <see cref="T:System.Boolean" /> 值寫入至建立器。</summary>
      <param name="value" vsli:raw="The value to write.">要寫入的值。</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteByte(System.Byte)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Byte&quot; /&gt; value to the builder.">將 <see cref="T:System.Byte" /> 值寫入至建立器。</summary>
      <param name="value" vsli:raw="The value to write.">要寫入的值。</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte*,System.Int32)">
      <summary vsli:raw="Writes a specified number of bytes from a buffer to the builder.">將緩衝區的指定位元組數目寫入至建立器。</summary>
      <param name="buffer" vsli:raw="" />
      <param name="byteCount" vsli:raw="The number of bytes to write.">要寫入的位元組數。</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> 為負。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable, it has been linked with another one.">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte,System.Int32)">
      <summary vsli:raw="Writes a specified number of occurrences of a byte value to the builder.">將位元組值以指定的出現次數寫入建立器。</summary>
      <param name="value" vsli:raw="" />
      <param name="byteCount" vsli:raw="The number of occurences of &lt;paramref name=&quot;value&quot; /&gt; to write.">要寫入之 <paramref name="value" /> 的出現次數。</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> 為負。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable, it has been linked with another one.">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[])">
      <summary vsli:raw="Writes the contents of a byte array to the builder.">將位元組陣列的內容寫入至建立器。</summary>
      <param name="buffer" vsli:raw="The byte array to write.">要寫入的位元組陣列。</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <summary vsli:raw="Writes a specified number of bytes starting at a specified index in a byte array to the builder.">將陣列中從指定索引開始的指定位元組數目，寫入至建立器。</summary>
      <param name="buffer" vsli:raw="" />
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="The number of bytes to write.">要寫入的位元組數。</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of &lt;paramref name=&quot;buffer&quot; /&gt;.">
        <paramref name="start" /> 和 <paramref name="byteCount" /> 指定的範圍超出 <paramref name="buffer" /> 的界限。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Writes the contents of an immutable byte array to the builder.">將不可變位元組陣列的內容寫入至建立器。</summary>
      <param name="buffer" vsli:raw="The array to write.">要寫入的陣列。</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <summary vsli:raw="Writes a specified number of bytes starting at a specified index of an immutable array to the builder.">將不可變陣列中從指定索引開始的指定位元組數目，寫入至建立器。</summary>
      <param name="buffer" vsli:raw="" />
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="The number of bytes to write.">要寫入的位元組數。</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the &lt;paramref name=&quot;buffer&quot; /&gt;.">
        <paramref name="start" /> 和 <paramref name="byteCount" /> 指定的範圍超出 <paramref name="buffer" /> 的界限。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedInteger(System.Int32)">
      <summary vsli:raw="Implements compressed unsigned integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.">依 ECMA-335-II 章節 23.2 的定義，實作已壓縮不帶正負號的整數編碼：Blob 和簽章。</summary>
      <param name="value" vsli:raw="The value to write.">要寫入的值。</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; can't be represented as a compressed unsigned integer.">
        <paramref name="value" /> 不能表示為已壓縮不帶正負號的整數。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedSignedInteger(System.Int32)">
      <summary vsli:raw="Implements compressed signed integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.">依 ECMA-335-II 章節 23.2 的定義，實作已壓縮帶正負號的整數編碼：Blob 和簽章。</summary>
      <param name="value" vsli:raw="The value to write.">要寫入的值。</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; can't be represented as a compressed signed integer.">
        <paramref name="value" /> 不能表示為已壓縮帶正負號的整數。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteConstant(System.Object)">
      <summary vsli:raw="Writes a constant value (see ECMA-335 Partition II section 22.9) at the current position.">在目前位置寫入常數值 (請參閱 ECMA-335 第二篇章節 22.9)。</summary>
      <param name="value" vsli:raw="The constant value to write.">要寫入的常數值。</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is not of a constant type.">
        <paramref name="value" /> 不是常數型別。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.IO.Stream)">
      <param name="destination" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="destination" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available, the builder has been linked with another one.">內容是不可寫入的，建立器已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobBuilder)">
      <param name="destination" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="destination" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available, the builder has been linked with another one.">內容是不可寫入的，建立器已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobWriter@)">
      <param name="destination" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is default (&lt;see cref=&quot;T:System.Reflection.Metadata.BlobWriter&quot; /&gt;).">
        <paramref name="destination" /> 是預設值 (請參閱 <see cref="T:System.Reflection.Metadata.BlobWriter" />)。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available, the builder has been linked with another one.">內容是不可寫入的，建立器已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDateTime(System.DateTime)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDecimal(System.Decimal)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDouble(System.Double)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteGuid(System.Guid)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16(System.Int16)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16BE(System.Int16)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32(System.Int32)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32BE(System.Int32)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt64(System.Int64)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteReference(System.Int32,System.Boolean)">
      <summary vsli:raw="Writes a reference to a heap (heap offset) or a table (row number).">將參考寫入堆積 (堆積位移) 或表格 (列號)。</summary>
      <param name="reference" vsli:raw="Heap offset or table row number.">堆積位移或表格列號。</param>
      <param name="isSmall" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode the reference as a 16-bit integer; &lt;see langword=&quot;false&quot; /&gt; to encode it as a 32-bit integer.">設定為 <see langword="true" /> 會將參考以 16 位元整數編碼；<see langword="false" /> 會將參考以 32 位元整數編碼。</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSByte(System.SByte)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSerializedString(System.String)">
      <summary vsli:raw="Writes a string in SerString format (see ECMA-335-II 23.3 Custom attributes).">以 SerString 格式 (請參閱 ECMA-335-II 23.3 自訂屬性) 寫入字串。</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSingle(System.Single)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16(System.UInt16)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16BE(System.UInt16)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32(System.UInt32)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32BE(System.UInt32)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt64(System.UInt64)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUserString(System.String)">
      <summary vsli:raw="Writes a string in User String (#US) heap format (see ECMA-335-II 24.2.4 #US and #Blob heaps).">以使用者字串 (#US) 堆積格式 (請參閱 ECMA-335-II 24.2.4 #US 和 #Blob 堆積)。</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.Char[])">
      <summary vsli:raw="Writes a UTF16 (little-endian) encoded character array at the current position.">在目前位置寫入 UTF16 (字元組由小到大) 編碼的字元陣列。</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.String)">
      <summary vsli:raw="Writes UTF16 (little-endian) encoded string at the current position.">在目前位置寫入 UTF16 (字元組由小到大) 編碼的字串。</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF8(System.String,System.Boolean)">
      <summary vsli:raw="Writes a UTF8 encoded string at the current position.">在目前位置寫入 UTF8 編碼的字串。</summary>
      <param name="value" vsli:raw="Constant value.">常數值。</param>
      <param name="allowUnpairedSurrogates" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode unpaired surrogates as specified; &lt;see langword=&quot;false&quot; /&gt; to replace them with a U+FFFD character.">設定為 <see langword="true" /> 會以指定方式編碼非成對代理字元；<see langword="false" /> 會以 U+FFFD 字元取代它們。</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="T:System.Reflection.Metadata.BlobContentId" />
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Byte[])">
      <param name="id" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="id" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Guid,System.UInt32)">
      <param name="guid" vsli:raw="" />
      <param name="stamp" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Reflection.Metadata.BlobContentId)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Byte[])">
      <param name="hashCode" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="hashCode" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.GetHashCode" />
    <member name="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />
    <member name="P:System.Reflection.Metadata.BlobContentId.Guid" />
    <member name="P:System.Reflection.Metadata.BlobContentId.IsDefault" />
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Equality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Inequality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobContentId.Stamp" />
    <member name="T:System.Reflection.Metadata.BlobHandle" />
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Reflection.Metadata.BlobHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.BlobHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Equality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Implicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Inequality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.BlobReader" />
    <member name="M:System.Reflection.Metadata.BlobReader.#ctor(System.Byte*,System.Int32)">
      <summary vsli:raw="Creates a reader of the specified memory block.">建立指定記憶體區塊的讀取器。</summary>
      <param name="buffer" vsli:raw="A pointer to the start of the memory block.">記憶體區塊開頭的指標。</param>
      <param name="length" vsli:raw="Length in bytes of the memory block.">記憶體區塊的長度，以位元組為單位。</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;length&quot; /&gt; is greater than zero.">
        <paramref name="buffer" /> 是 <see langword="null" />，且 <paramref name="length" /> 大於零。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;length&quot; /&gt; is negative.">
        <paramref name="length" /> 為負。</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is not little-endian.">目前的平台不是位元組由小到大。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Align(System.Byte)">
      <summary vsli:raw="Repositions the reader forward by the number of bytes required to satisfy the given alignment.">以滿足所給定對齊方式所需的位元組數目，將讀取器向前重新定位。</summary>
      <param name="alignment" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.CurrentPointer">
      <summary vsli:raw="Gets a pointer to the byte at the current position of the reader.">取得讀取器目前位置的指標。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.IndexOf(System.Byte)">
      <summary vsli:raw="Searches for a specified byte in the blob following the current position.">在目前位置後面的 Blob 中搜尋指定位元組。</summary>
      <param name="value" vsli:raw="The byte value to find.">要尋找的位元組值。</param>
      <returns vsli:raw="The index relative to the current position, or -1 if the byte is not found in the blob following the current position.">相對於目前位置的索引，如果在目前位置後面的 Blob 找不到該位元組，則為 -1。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Length">
      <summary vsli:raw="Gets the total length of the underlying memory block.">取得基礎記憶體的長度。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Offset">
      <summary vsli:raw="Gets or sets the offset from the start of the blob to the current position.">取得或設定從 Blob 開頭開始至目前位置的位移。</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The offset is set outside the bounds of the underlying reader.">位移設定在基礎讀取器界限外。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBlobHandle">
      <summary vsli:raw="Reads a Blob heap handle encoded as a compressed integer.">讀取編碼為已壓縮整數的 Blob 堆積控制代碼。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBoolean" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32)">
      <summary vsli:raw="Reads bytes starting at the current position.">讀取從目前位置開始的位元組。</summary>
      <param name="byteCount" vsli:raw="The number of bytes to read.">要讀取的位元組數。</param>
      <returns vsli:raw="The byte array.">位元組陣列。</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; bytes not available.">
        <paramref name="byteCount" /> 位元無法使用。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32,System.Byte[],System.Int32)">
      <summary vsli:raw="Reads bytes starting at the current position and writes them to the specified buffer starting at the specified offset.">從目前位置開始讀取位元組，並在指定緩衝區的指定位移處開始將它們寫入。</summary>
      <param name="byteCount" vsli:raw="The number of bytes to read.">要讀取的位元組數。</param>
      <param name="buffer" vsli:raw="The destination buffer the bytes read will be written to.">所讀取位元組將會寫入的目的地緩衝區。</param>
      <param name="bufferOffset" vsli:raw="The offset in the destination buffer where the bytes read will be written.">所讀取位元組將會寫入之目的地緩衝區中的位移。</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; bytes not available.">
        <paramref name="byteCount" /> 位元無法使用。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadChar" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedInteger">
      <summary vsli:raw="Reads an unsigned compressed integer value. See Metadata Specification section II.23.2: Blobs and signatures.">讀取不帶正負號的已壓縮整數值。 請參閱《中繼資料規格》章節 II.23.2：Blob 和簽章。</summary>
      <returns vsli:raw="The value of the compressed integer that was read.">所讀取已壓縮整數的值。</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data at the current position was not a valid compressed integer.">目前位置的資料不是有效的已壓縮整數。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedSignedInteger">
      <summary vsli:raw="Reads a signed compressed integer value. See Metadata Specification section II.23.2: Blobs and signatures.">讀取帶正負號的已壓縮整數值。 請參閱《中繼資料規格》章節 II.23.2：Blob 和簽章。</summary>
      <returns vsli:raw="The value of the compressed integer that was read.">所讀取已壓縮整數的值。</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data at the current position was not a valid compressed integer.">目前位置的資料不是有效的已壓縮整數。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadConstant(System.Reflection.Metadata.ConstantTypeCode)">
      <summary vsli:raw="Reads a constant value (see ECMA-335 Partition II section 22.9) from the current position.">從目前位置讀取常數值 (請參閱 ECMA-335 第二篇章節 22.9)。</summary>
      <param name="typeCode" vsli:raw="" />
      <returns vsli:raw="A boxed constant value. To avoid allocating the object use Read* methods directly.">Boxed 常數值。 若要避免配置物件，請直接使用 Read* 方法。</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Error while reading from the blob.">讀取 Blob 時發生錯誤。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;typeCode&quot; /&gt; is not a valid &lt;see cref=&quot;T:System.Reflection.Metadata.ConstantTypeCode&quot; /&gt;.">
        <paramref name="typeCode" /> 不是有效的 <see cref="T:System.Reflection.Metadata.ConstantTypeCode" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDateTime" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDecimal">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Decimal&quot; /&gt; number.">讀取 <see cref="T:System.Decimal" /> 數字。</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data at the current position was not a valid &lt;see cref=&quot;T:System.Decimal&quot; /&gt; number.">目前位置的資料不是有效的 <see cref="T:System.Decimal" /> 數字。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDouble" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadGuid" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializationTypeCode">
      <summary vsli:raw="Reads a type code encoded in a serialized custom attribute value.">讀取以序列化自訂屬性值編碼的類型代碼。</summary>
      <returns vsli:raw="&lt;see cref=&quot;F:System.Reflection.Metadata.SerializationTypeCode.Invalid&quot; /&gt; if the encoding is invalid.">如果編碼無效，則為 <see cref="F:System.Reflection.Metadata.SerializationTypeCode.Invalid" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializedString">
      <summary vsli:raw="Reads a string encoded as a compressed integer containing its length followed by its contents in UTF8. Null strings are encoded as a single 0xFF byte.">將字串讀取成編碼為已壓縮整數，包含其長度接著其內容 (UTF8)。 Null 字串會編碼為單一 0xFF 位元組。</summary>
      <returns vsli:raw="A string value, or &lt;see langword=&quot;null&quot; /&gt;.">字串值，或 <see langword="null" />。</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The encoding is invalid.">編碼無效。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureHeader" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureTypeCode">
      <summary vsli:raw="Reads a type code encoded in a signature.">讀取以簽章編碼的類型代碼。</summary>
      <returns vsli:raw="The type code encoded in the serialized custom attribute value if the encoding is valid, or &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Invalid&quot; /&gt; if the encoding is invalid.">如果編碼有效，類型代碼會以序列化自訂屬性值編碼，如果編碼無效，則為 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSingle" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadTypeHandle">
      <summary vsli:raw="Reads a type handle encoded in a signature as TypeDefOrRefOrSpecEncoded (see ECMA-335 II.23.2.8).">將使用簽章編碼的類型控制代碼讀取為 TypeDefOrRefOrSpecEncoded (請參閱 ECMA-335 II.23.2.8)。</summary>
      <returns vsli:raw="The handle when the encoding is valid. Otherwise, a handle where the &lt;see cref=&quot;P:System.Reflection.Metadata.EntityHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;.">當編碼有效時為該控制代碼。 否則是 <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> 屬性為 <see langword="true" /> 的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF16(System.Int32)">
      <summary vsli:raw="Reads a UTF16 (little-endian) encoded string starting at the current position.">從目前位置開始讀取 UTF16 (字元組由小到大) 編碼的字串。</summary>
      <param name="byteCount" vsli:raw="The number of bytes to read.">要讀取的位元組數。</param>
      <returns vsli:raw="The string.">字串。</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; bytes not available.">
        <paramref name="byteCount" /> 位元無法使用。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF8(System.Int32)">
      <summary vsli:raw="Reads a UTF8 encoded string starting at the current position.">從目前位置開始讀取 UTF8 編碼的字串。</summary>
      <param name="byteCount" vsli:raw="The number of bytes to read.">要讀取的位元組數。</param>
      <returns vsli:raw="The string.">字串。</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; bytes not available.">
        <paramref name="byteCount" /> 位元無法使用。</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.RemainingBytes">
      <summary vsli:raw="Gets the number of bytes remaining from current position to the end of the underlying memory block.">取得從目前位置到基礎記憶體區塊結尾的剩餘位元組數目。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Reset">
      <summary vsli:raw="Repositions the reader to the start of the underlying memory block.">將讀取器重新定位至基礎記憶體區塊的開頭。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.StartPointer">
      <summary vsli:raw="Gets a pointer to the byte at the start of the underlying memory block.">取得基礎記憶體區塊開頭處位元組的指標。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedInteger(System.Int32@)">
      <summary vsli:raw="Reads an unsigned compressed integer value. See Metadata Specification section II.23.2: Blobs and signatures.">讀取不帶正負號的已壓縮整數值。 請參閱《中繼資料規格》章節 II.23.2：Blob 和簽章。</summary>
      <param name="value" vsli:raw="The value of the compressed integer that was read.">所讀取已壓縮整數的值。</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the value was read successfully. &lt;see langword=&quot;false&quot; /&gt; if the data at the current position was not a valid compressed integer.">如果成功讀取該值，即為 <see langword="true" />。 如果目前位置的資料不是有效的已壓縮整數，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedSignedInteger(System.Int32@)">
      <summary vsli:raw="Reads a signed compressed integer value. See Metadata Specification section II.23.2: Blobs and signatures.">讀取帶正負號的已壓縮整數值。 請參閱《中繼資料規格》章節 II.23.2：Blob 和簽章。</summary>
      <param name="value" vsli:raw="The value of the compressed integer that was read.">所讀取已壓縮整數的值。</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the value was read successfully. &lt;see langword=&quot;false&quot; /&gt; if the data at the current position was not a valid compressed integer.">如果成功讀取該值，即為 <see langword="true" />。 如果目前位置的資料不是有效的已壓縮整數，則為 <see langword="false" />。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.BlobWriter" />
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[])">
      <param name="buffer" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" vsli:raw="" />
      <param name="start" vsli:raw="" />
      <param name="count" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Int32)">
      <param name="size" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Reflection.Metadata.Blob)">
      <param name="blob" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.Align(System.Int32)">
      <param name="alignment" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.Blob" />
    <member name="M:System.Reflection.Metadata.BlobWriter.Clear" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ContentEquals(System.Reflection.Metadata.BlobWriter)">
      <summary vsli:raw="Compares the current content of this writer with another one.">將此寫入器的目前內容與另一個比較。</summary>
      <param name="other" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.Length" />
    <member name="P:System.Reflection.Metadata.BlobWriter.Offset" />
    <member name="M:System.Reflection.Metadata.BlobWriter.PadTo(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.RemainingBytes" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray(System.Int32,System.Int32)">
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the buffer content.">
        <paramref name="start" /> 和 <paramref name="byteCount" /> 指定的範圍超出緩衝區內容的界限。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the buffer content.">
        <paramref name="start" /> 和 <paramref name="byteCount" /> 指定的範圍超出緩衝區內容的界限。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBoolean(System.Boolean)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteByte(System.Byte)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte*,System.Int32)">
      <param name="buffer" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> 為負。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte,System.Int32)">
      <param name="value" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> 為負。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[])">
      <param name="buffer" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" vsli:raw="" />
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the &lt;paramref name=&quot;buffer&quot; /&gt;.">
        <paramref name="start" /> 和 <paramref name="byteCount" /> 指定的範圍超出 <paramref name="buffer" /> 的界限。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="buffer" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <param name="buffer" vsli:raw="" />
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the &lt;paramref name=&quot;buffer&quot; /&gt;.">
        <paramref name="start" /> 和 <paramref name="byteCount" /> 指定的範圍超出 <paramref name="buffer" /> 的界限。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.IO.Stream,System.Int32)">
      <param name="source" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="source" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> 為負。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Reflection.Metadata.BlobBuilder)">
      <param name="source" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="source" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedInteger(System.Int32)">
      <summary vsli:raw="Implements compressed unsigned integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.">依 ECMA-335-II 章節 23.2 的定義，實作已壓縮不帶正負號的整數編碼：Blob 和簽章。</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; can't be represented as a compressed unsigned integer.">
        <paramref name="value" /> 不能表示為已壓縮不帶正負號的整數。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedSignedInteger(System.Int32)">
      <summary vsli:raw="Implements compressed signed integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.">依 ECMA-335-II 章節 23.2 的定義，實作已壓縮帶正負號的整數編碼：Blob 和簽章。</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; can't be represented as a compressed signed integer.">
        <paramref name="value" /> 不能表示為已壓縮帶正負號的整數。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteConstant(System.Object)">
      <summary vsli:raw="Writes a constant value (see ECMA-335 Partition II section 22.9) at the current position.">在目前位置寫入常數值 (請參閱 ECMA-335 第二篇章節 22.9)。</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is not of a constant type.">
        <paramref name="value" /> 不是常數型別。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDateTime(System.DateTime)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDecimal(System.Decimal)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDouble(System.Double)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteGuid(System.Guid)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16(System.Int16)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16BE(System.Int16)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32(System.Int32)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32BE(System.Int32)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt64(System.Int64)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteReference(System.Int32,System.Boolean)">
      <summary vsli:raw="Writes a reference to a heap (heap offset) or a table (row number).">將參考寫入堆積 (堆積位移) 或表格 (列號)。</summary>
      <param name="reference" vsli:raw="Heap offset or table row number.">堆積位移或表格列號。</param>
      <param name="isSmall" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode the reference as 16-bit integer, &lt;see langword=&quot;false&quot; /&gt; to encode as 32-bit integer.">設定為 <see langword="true" /> 會將參考以 16 位元整數編碼；<see langword="false" /> 會將參考以 32 位元整數編碼。</param>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSByte(System.SByte)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSerializedString(System.String)">
      <summary vsli:raw="Writes a string in SerString format (see ECMA-335-II 23.3 Custom attributes).">以 SerString 格式 (請參閱 ECMA-335-II 23.3 自訂屬性) 寫入字串。</summary>
      <param name="str" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSingle(System.Single)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16(System.UInt16)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16BE(System.UInt16)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32(System.UInt32)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32BE(System.UInt32)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt64(System.UInt64)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)">
      <summary vsli:raw="Writes a string in User String (#US) heap format (see ECMA-335-II 24.2.4 #US and #Blob heaps).">以使用者字串 (#US) 堆積格式 (請參閱 ECMA-335-II 24.2.4 #US 和 #Blob 堆積)。</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.Char[])">
      <summary vsli:raw="Writes a UTF16 (little-endian) encoded string at the current position.">在目前位置寫入 UTF16 (字元組由小到大) 編碼的字串。</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.String)">
      <summary vsli:raw="Writes a UTF16 (little-endian) encoded string at the current position.">在目前位置寫入 UTF16 (字元組由小到大) 編碼的字串。</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF8(System.String,System.Boolean)">
      <summary vsli:raw="Writes a UTF8 encoded string at the current position.">在目前位置寫入 UTF8 編碼的字串。</summary>
      <param name="value" vsli:raw="" />
      <param name="allowUnpairedSurrogates" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Constant" />
    <member name="P:System.Reflection.Metadata.Constant.Parent">
      <summary vsli:raw="Gets the parent handle (&lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;).">取得父代控制代碼 (<see cref="T:System.Reflection.Metadata.ParameterHandle" />、<see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />)。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.TypeCode">
      <summary vsli:raw="Gets a type code that identifies the type of the constant value.">取得識別常數值型別的型別代碼。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.Value">
      <summary vsli:raw="Gets the constant value.">取得常數值。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ConstantHandle" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Reflection.Metadata.ConstantHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ConstantHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Equality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Inequality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.ConstantTypeCode">
      <summary vsli:raw="Specifies values that represent types of metadata constants.">指定表示中繼資料常數類型的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Boolean">
      <summary vsli:raw="A Boolean type.">布林型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Byte">
      <summary vsli:raw="An unsigned 1-byte integer.">不帶正負號的 1 位元整數。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Char">
      <summary vsli:raw="A character type.">字元類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Double">
      <summary vsli:raw="An 8-byte floating point type.">8 位元浮點數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int16">
      <summary vsli:raw="A signed 2-byte integer type.">帶正負號的 2 位元整數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int32">
      <summary vsli:raw="A signed 4-byte integer type.">帶正負號的 4 位元整數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int64">
      <summary vsli:raw="A signed 8-byte integer type.">帶正負號的 8 位元整數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Invalid">
      <summary vsli:raw="An invalid type.">類型無效。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.NullReference">
      <summary vsli:raw="A null reference.">null 參考。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.SByte">
      <summary vsli:raw="A signed 1-byte integer type.">帶正負號的 1 位元整數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Single">
      <summary vsli:raw="A 4-byte floating point type.">4 位元浮點數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.String">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; type.">
        <see cref="T:System.String" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt16">
      <summary vsli:raw="An unsigned 2-byte integer type.">不帶正負號的 2 位元整數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt32">
      <summary vsli:raw="An unsigned 4-byte integer type.">不帶正負號的 4 位元整數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt64">
      <summary vsli:raw="An unsigned 8-byte integer type.">不帶正負號的 8 位元整數類型。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttribute" />
    <member name="P:System.Reflection.Metadata.CustomAttribute.Constructor">
      <summary vsli:raw="Gets the constructor (the &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;) of the custom attribute type.">取得自訂屬性的建構函式 (<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />)。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttribute.DecodeValue``1(System.Reflection.Metadata.ICustomAttributeTypeProvider{``0})">
      <summary vsli:raw="Decodes the arguments encoded in the value blob.">解碼值 Blob 中編碼的引數。</summary>
      <param name="provider" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Parent">
      <summary vsli:raw="Gets the handle of the metadata entity the attribute is applied to.">取得套用屬性之中繼資料實體的控制代碼。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Value">
      <summary vsli:raw="Gets the value of the attribute.">取得屬性值。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandle" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.CustomAttributeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Equality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Inequality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection" />
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomAttributeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1">
      <summary vsli:raw="Represents a named argument decoded from a custom attribute signature.">表示從自訂屬性簽章解碼的具名引數。</summary>
      <typeparam name="TType" vsli:raw="The type used to represent types of values decoded from the custom attribute signature.">用來表示從自訂屬性簽章解碼之數值型別的類型。</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeNamedArgument`1.#ctor(System.String,System.Reflection.Metadata.CustomAttributeNamedArgumentKind,`0,System.Object)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.CustomAttributeNamedArgument`1&quot; /&gt; structure using the specified name, kind, type, and value.">使用指定的名稱、種類、型別和值，將 <see cref="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1" /> 結構的新執行個體初始化。</summary>
      <param name="name" vsli:raw="The name of the argument.">引數的名稱。</param>
      <param name="kind" vsli:raw="The kind of the argument.">引數種類。</param>
      <param name="type" vsli:raw="The type of the argument.">引數型別。</param>
      <param name="value" vsli:raw="The value of the argument.">引數的值。</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Kind">
      <summary vsli:raw="Gets the kind of argument.">取得引數種類。</summary>
      <returns vsli:raw="The argument kind.">引數種類。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Name">
      <summary vsli:raw="Gets the name of the argument.">取得引數名稱。</summary>
      <returns vsli:raw="The argument name.">引數名稱。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Type">
      <summary vsli:raw="Gets the type of the argument.">取得引數型別。</summary>
      <returns vsli:raw="The argument type.">引數類型。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Value">
      <summary vsli:raw="Gets the value of the argument.">取得引數的值。</summary>
      <returns vsli:raw="An object containing the argument value.">包含引數值的物件。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgumentKind">
      <summary vsli:raw="Specifies constants that define the kinds of arguments in a custom attribute signature.">指定在自訂屬性簽章中定義引數種類的常數。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Field">
      <summary vsli:raw="A field argument.">欄位引數。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Property">
      <summary vsli:raw="A property argument.">屬性引數。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1">
      <summary vsli:raw="Represents a typed argument for a custom metadata attribute.">表示自訂中繼資料屬性的具型別引數。</summary>
      <typeparam name="TType" vsli:raw="The type of the argument.">引數型別。</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeTypedArgument`1.#ctor(`0,System.Object)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.CustomAttributeTypedArgument`1&quot; /&gt; structure using the specified argument type and value.">使用指定的引數類型與值，將 <see cref="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1" /> 結構的新執行個體初始化。</summary>
      <param name="type" vsli:raw="The type of the argument.">引數型別。</param>
      <param name="value" vsli:raw="The argument value.">引數值。</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Type">
      <summary vsli:raw="Gets the type of the argument.">取得引數型別。</summary>
      <returns vsli:raw="The argument type.">引數型別。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Value">
      <summary vsli:raw="Gets the value of the argument.">取得引數的值。</summary>
      <returns vsli:raw="The argument value.">引數值。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeValue`1">
      <summary vsli:raw="Represents a custom attribute of the type specified by &lt;paramref name=&quot;TType&quot; /&gt;.">表示 <paramref name="TType" /> 所指定類型的自訂屬性。</summary>
      <typeparam name="TType" vsli:raw="The attribute type.">屬性類型。</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeValue`1.#ctor(System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeTypedArgument{`0}},System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeNamedArgument{`0}})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.CustomAttributeValue`1&quot; /&gt; structure using the specified fixed arguments and named arguments.">使用指定的固定引數與具名引數，將 <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" /> 結構的新執行個體初始化。</summary>
      <param name="fixedArguments" vsli:raw="The fixed arguments.">固定引數。</param>
      <param name="namedArguments" vsli:raw="The named arguments.">具名引數。</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.FixedArguments">
      <summary vsli:raw="Gets the fixed arguments for the custom attribute.">取得自訂屬性的固定引數。</summary>
      <returns vsli:raw="An immutable array of arguments.">引數的不可變數組。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.NamedArguments">
      <summary vsli:raw="Gets the named arguments for the custom attribute value.">取得自訂屬性值的具名引數。</summary>
      <returns vsli:raw="An immutable array of arguments.">引數的不可變數組。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Kind" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Parent" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Value" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Equality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Inequality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomDebugInformationHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.DebugMetadataHeader" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.EntryPoint" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.Id" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.IdStartOffset">
      <summary vsli:raw="Gets the offset (in bytes) from the start of the metadata blob to the start of the &lt;see cref=&quot;P:System.Reflection.Metadata.DebugMetadataHeader.Id&quot; /&gt; blob.">取得從中繼資料 Blob 開始到 <see cref="P:System.Reflection.Metadata.DebugMetadataHeader.Id" /> Blob 開頭的位移 (以位元組為單位)。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttribute" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Action" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Parent" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.PermissionSet" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Equality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Inequality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DeclarativeSecurityAttributeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.Document">
      <summary vsli:raw="The source document in the debug metadata.">偵錯中繼資料中的來源文件。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Hash">
      <summary vsli:raw="Gets the document content hash.">取得文件內容雜湊。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.HashAlgorithm">
      <summary vsli:raw="Gets the hash algorithm used to calculate the &lt;see cref=&quot;P:System.Reflection.Metadata.Document.Hash&quot; /&gt; (SHA1, SHA256, etc.).">取得用來計算 <see cref="P:System.Reflection.Metadata.Document.Hash" /> (SHA1、SHA256 等) 的雜湊演算法。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Language">
      <summary vsli:raw="Gets the source code language (C#, VB, F#, etc.).">取得原始程式碼語言 (C#、VB、F# 等)。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Name">
      <summary vsli:raw="Gets the document name blob.">取得文件名稱 Blob。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandle" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Reflection.Metadata.DocumentHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.DocumentHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Equality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Inequality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection" />
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DocumentHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.DocumentNameBlobHandle">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.BlobHandle&quot; /&gt; representing a blob on #Blob heap in Portable PDB structured as Document Name.">
        <see cref="T:System.Reflection.Metadata.BlobHandle" />，它代表可攜式 PDB 中 #Blob 堆積上的 Blob (結構化為文件名稱)。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.DocumentNameBlobHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Equality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Explicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.DocumentNameBlobHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Implicit(System.Reflection.Metadata.DocumentNameBlobHandle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Inequality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Shape(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <param name="rank" vsli:raw="The number of dimensions in the array (shall be 1 or more)." />
      <param name="sizes" vsli:raw="Dimension sizes. The array may be shorter than &lt;paramref name=&quot;rank&quot; /&gt; but not longer." />
      <param name="lowerBounds" vsli:raw="Dimension lower bounds, or default(&lt;see cref=&quot;T:System.Collections.Immutable.ImmutableArray`1&quot; /&gt;) to set all &lt;paramref name=&quot;rank&quot; /&gt; lower bounds to 0.&#xA; The array may be shorter than &lt;paramref name=&quot;rank&quot; /&gt; but not longer." />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.BlobEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.BlobEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Action{System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder},System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder})">
      <param name="fixedArguments" vsli:raw="Called first, to encode fixed arguments." />
      <param name="namedArguments" vsli:raw="Called second, to encode named arguments." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder@,System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder@)">
      <param name="fixedArguments" vsli:raw="Use first, to encode fixed arguments." />
      <param name="namedArguments" vsli:raw="Use second, to encode named arguments." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.LocalVariableSignature(System.Int32)">
      <param name="variableCount" vsli:raw="Number of local variables." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSignature(System.Reflection.Metadata.SignatureCallingConvention,System.Int32,System.Boolean)">
      <param name="convention" vsli:raw="Calling convention." />
      <param name="genericParameterCount" vsli:raw="Number of generic parameters." />
      <param name="isInstanceMethod" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode an instance method signature, &lt;see langword=&quot;false&quot; /&gt; to encode a static method signature." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSpecificationSignature(System.Int32)">
      <param name="genericArgumentCount" vsli:raw="Number of generic arguments." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetArguments(System.Int32)">
      <param name="argumentCount" vsli:raw="Number of arguments in the set." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetBlob(System.Int32)">
      <param name="attributeCount" vsli:raw="Number of attributes in the set." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PropertySignature(System.Boolean)">
      <param name="isInstanceProperty" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode an instance property signature, &lt;see langword=&quot;false&quot; /&gt; to encode a static property signature." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.TypeSpecificationSignature" />
    <member name="T:System.Reflection.Metadata.Ecma335.CodedIndex" />
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.CustomAttributeType(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasConstant(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomAttribute(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.InterfaceImplementationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignatureHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ManifestResourceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterConstraintHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MethodSpecificationHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.InterfaceImplementationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignatureHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ManifestResourceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterConstraintHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DocumentHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalScopeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalVariableHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalConstantHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.ImportScopeHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasDeclSecurity(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasFieldMarshal(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasSemantics(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.Implementation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberForwarded(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinition&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinition&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberRefParent(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MethodDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.ResolutionScope(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRefOrSpec(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeOrMethodDef(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;." />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.#ctor" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddCatchRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="tryStart" vsli:raw="Label marking the first instruction of the try block." />
      <param name="tryEnd" vsli:raw="Label marking the instruction immediately following the try block." />
      <param name="handlerStart" vsli:raw="Label marking the first instruction of the handler." />
      <param name="handlerEnd" vsli:raw="Label marking the instruction immediately following the handler." />
      <param name="catchType" vsli:raw="The type of exception to be caught: &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFaultRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="tryStart" vsli:raw="Label marking the first instruction of the try block." />
      <param name="tryEnd" vsli:raw="Label marking the instruction immediately following the try block." />
      <param name="handlerStart" vsli:raw="Label marking the first instruction of the handler." />
      <param name="handlerEnd" vsli:raw="Label marking the instruction immediately following the handler." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFilterRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="tryStart" vsli:raw="Label marking the first instruction of the try block." />
      <param name="tryEnd" vsli:raw="Label marking the instruction immediately following the try block." />
      <param name="handlerStart" vsli:raw="Label marking the first instruction of the handler." />
      <param name="handlerEnd" vsli:raw="Label marking the instruction immediately following the handler." />
      <param name="filterStart" vsli:raw="Label marking the first instruction of the filter block." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFinallyRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="tryStart" vsli:raw="Label marking the first instruction of the try block." />
      <param name="tryEnd" vsli:raw="Label marking the instruction immediately following the try block." />
      <param name="handlerStart" vsli:raw="Label marking the first instruction of the handler." />
      <param name="handlerEnd" vsli:raw="Label marking the instruction immediately following the handler." />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ElementType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ObjectArray" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Boolean" />
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Enum(System.String)">
      <param name="enumTypeName" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveSerializationTypeCode)">
      <param name="type" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SystemType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt64" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Count(System.Int32)">
      <param name="count" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.AddModifier(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <param name="type" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;." />
      <param name="isOptional" vsli:raw="Is optional modifier." />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry" />
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.#ctor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="handle" vsli:raw="" />
      <param name="operation" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Handle" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Operation" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueOperation" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddEvent" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddField" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddParameter" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddProperty" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.Default" />
    <member name="T:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Add(System.Reflection.Metadata.ExceptionRegionKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <param name="kind" vsli:raw="Clause kind." />
      <param name="tryOffset" vsli:raw="Try block start offset." />
      <param name="tryLength" vsli:raw="Try block length." />
      <param name="handlerOffset" vsli:raw="Handler start offset." />
      <param name="handlerLength" vsli:raw="Handler length." />
      <param name="catchType" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, or nil if &lt;paramref name=&quot;kind&quot; /&gt; is not &lt;see cref=&quot;F:System.Reflection.Metadata.ExceptionRegionKind.Catch&quot; /&gt;." />
      <param name="filterOffset" vsli:raw="Offset of the filter block, or 0 if the &lt;paramref name=&quot;kind&quot; /&gt; is not &lt;see cref=&quot;F:System.Reflection.Metadata.ExceptionRegionKind.Filter&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddCatch(System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle)">
      <param name="tryOffset" vsli:raw="Try block start offset." />
      <param name="tryLength" vsli:raw="Try block length." />
      <param name="handlerOffset" vsli:raw="Handler start offset." />
      <param name="handlerLength" vsli:raw="Handler length." />
      <param name="catchType" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFault(System.Int32,System.Int32,System.Int32,System.Int32)">
      <param name="tryOffset" vsli:raw="Try block start offset." />
      <param name="tryLength" vsli:raw="Try block length." />
      <param name="handlerOffset" vsli:raw="Handler start offset." />
      <param name="handlerLength" vsli:raw="Handler length." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFilter(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <param name="tryOffset" vsli:raw="Try block start offset." />
      <param name="tryLength" vsli:raw="Try block length." />
      <param name="handlerOffset" vsli:raw="Handler start offset." />
      <param name="handlerLength" vsli:raw="Handler length." />
      <param name="filterOffset" vsli:raw="Offset of the filter block." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFinally(System.Int32,System.Int32,System.Int32,System.Int32)">
      <param name="tryOffset" vsli:raw="Try block start offset." />
      <param name="tryLength" vsli:raw="Try block length." />
      <param name="handlerOffset" vsli:raw="Handler start offset." />
      <param name="handlerLength" vsli:raw="Handler length." />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.HasSmallFormat" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallExceptionRegion(System.Int32,System.Int32)">
      <param name="startOffset" vsli:raw="Start offset of the region." />
      <param name="length" vsli:raw="Length of the region." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallRegionCount(System.Int32)">
      <param name="exceptionRegionCount" vsli:raw="Number of exception regions." />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions.GetTypeDefinitionId(System.Reflection.Metadata.ExportedType)">
      <param name="exportedType" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasExplicitThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.None" />
    <member name="T:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.HeapIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Blob" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Guid" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.String" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.UserString" />
    <member name="T:System.Reflection.Metadata.Ecma335.InstructionEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.Ecma335.ControlFlowBuilder)">
      <param name="codeBuilder" vsli:raw="Builder to write encoded instructions to." />
      <param name="controlFlowBuilder" vsli:raw="Builder tracking labels, branches and exception handlers.&#xA; Must be specified to be able to use some of the control-flow factory methods of &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.InstructionEncoder&quot; /&gt;, such as &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)&quot; /&gt;, &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel&quot; /&gt;, &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)&quot; /&gt; etc." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="code" vsli:raw="Branch instruction to encode." />
      <param name="label" vsli:raw="Label of the target location in instruction stream." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.EntityHandle)">
      <param name="methodHandle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="methodHandle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="methodHandle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="methodHandle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.CallIndirect(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="signature" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.CodeBuilder" />
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" />
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel" />
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgument(System.Int32)">
      <param name="argumentIndex" vsli:raw="Index of the argument." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgumentAddress(System.Int32)">
      <param name="argumentIndex" vsli:raw="Index of the argument." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI4(System.Int32)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI8(System.Int64)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR4(System.Single)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR8(System.Double)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocal(System.Int32)">
      <param name="slotIndex" vsli:raw="Index of the local variable slot." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocalAddress(System.Int32)">
      <param name="slotIndex" vsli:raw="Index of the local variable slot." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="label" vsli:raw="Label to mark." />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.Offset" />
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.OpCode(System.Reflection.Metadata.ILOpCode)">
      <param name="code" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreArgument(System.Int32)">
      <param name="argumentIndex" vsli:raw="Index of the argument." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreLocal(System.Int32)">
      <param name="slotIndex" vsli:raw="Index of the local variable slot." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Int32)">
      <param name="token" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LabelHandle" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.Id">
      <summary vsli:raw="1-based id identifying the label within the context of a &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder&quot; /&gt;.">以 1 為基礎的識別碼，用來識別 <see cref="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" /> 內容中的標籤。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Equality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Inequality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralEncoder">
      <summary vsli:raw="Provides methods for encoding literals.">提供編碼常值的方法。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="Creates a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.LiteralEncoder&quot; /&gt; class with the specified blob builder.">使用指定的 Blob 建立器，來建立 <see cref="T:System.Reflection.Metadata.Ecma335.LiteralEncoder" /> 類別的新執行個體。</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Scalar">
      <summary vsli:raw="Returns the encoder used to encode the literal value.">傳回用來編碼常值的編碼器。</summary>
      <returns vsli:raw="The encoder of the literal value.">常值的編碼器。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ScalarEncoder})">
      <summary vsli:raw="Encodes the type and the value of a literal using the specified delegates.">使用指定的委派來編碼常值的類型和值。</summary>
      <param name="type" vsli:raw="A delegate used to encode the type of the literal. Called first by this method.">用來編碼常值類型的委派。 其為此方法第一個呼叫的委派。</param>
      <param name="scalar" vsli:raw="A delegate used to encode the value of the literal. Called second by this method.">用來編碼常值的委派。 其為此方法第二個呼叫的委派。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder@,System.Reflection.Metadata.Ecma335.ScalarEncoder@)">
      <summary vsli:raw="Returns a pair of encoders that must be used to encode the type and value of a literal in the order they appear in the parameter list.">傳回一對編碼器，必須使用這對編碼器來依常值類型和其值出現在參數清單中的順序來加以編碼。</summary>
      <param name="type" vsli:raw="When this method returns, a custom attribute element type encoder used to encode the type of the literal.">當此方法傳回時，則為用來編碼常值類型的自訂屬性項目類型編碼器。</param>
      <param name="scalar" vsli:raw="When this method returns, a scalar encoded used to encode the value of the literal.">當此方法傳回時，則為用來編碼常值的編碼純量。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.VectorEncoder})">
      <summary vsli:raw="Encodes the type and the items of a vector literal using the specified delegates.">使用指定的委派來編碼向量常值的類型和項目。</summary>
      <param name="arrayType" vsli:raw="A delegate used to encode the type of the vector. Called first by this method.">用來編碼向量類型的委派。 其為此方法第一個呼叫的委派。</param>
      <param name="vector" vsli:raw="A delegate used to encode the items of the vector. Called second by this method.">用來編碼向量項目的委派。 其為此方法第二個呼叫的委派。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder@,System.Reflection.Metadata.Ecma335.VectorEncoder@)">
      <summary vsli:raw="Returns a pair of encoders that must be used to encode the type and the items of a vector literal in the order they appear in the parameter list.">傳回一對編碼器，必須使用這對編碼器來依向量常值類型和其項目出現在參數清單中的順序來加以編碼。</summary>
      <param name="arrayType" vsli:raw="When this method returns, a custom attribute array type encoder used to encode the type of the vector.">當此方法傳回時，則為用來編碼向量類型的自訂屬性陣列類型編碼器。</param>
      <param name="vector" vsli:raw="When this method returns, a vector encoder used to encode the items of the vector.">當此方法傳回時，則為用來編碼向量項目的向量編碼器。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Vector">
      <summary vsli:raw="Gets a vector encoder used to encode the items of a vector.">取得用來編碼向量項目的向量編碼器。</summary>
      <returns vsli:raw="A vector encoder used to encode the items of a vector.">用來編碼向量項目的向量編碼器。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.AddLiteral" />
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.AddVariable" />
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Type(System.Boolean,System.Boolean)">
      <param name="isByRef" vsli:raw="" />
      <param name="isPinned" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.TypedReference" />
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataAggregator" />
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseTableRowCounts" vsli:raw="" />
      <param name="baseHeapSizes" vsli:raw="" />
      <param name="deltaReaders" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Reflection.Metadata.MetadataReader,System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseReader" vsli:raw="" />
      <param name="deltaReaders" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.GetGenerationHandle(System.Reflection.Metadata.Handle,System.Int32@)">
      <summary vsli:raw="Calculates the handle of the entity within the metadata generation it is defined in, given a handle of an entity in an aggregate metadata.">指定彙總中繼資料中實體的控制代碼，以計算在其中定義該實體中繼資料產生內該實體的控制代碼。</summary>
      <param name="handle" vsli:raw="Handle of an entity in an aggregate metadata.">彙總中繼資料中實體的控制代碼。</param>
      <param name="generation" vsli:raw="The generation the entity is defined in.">在其中定義實體的產生。</param>
      <returns vsli:raw="Handle of the entity within the metadata &lt;paramref name=&quot;generation&quot; /&gt;.">中繼資料 <paramref name="generation" /> 內實體的控制代碼。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataBuilder">
      <summary vsli:raw="The MetadataBuilder class writes metadata for an assembly in a highly performant manner. It is designed for use by compilers and other assembly generation tools.">MetadataBuilder 類別會以高效能方式來讀取及寫入組件的中繼資料。 其設計目的是要供編譯器和其他組件產生工具使用。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary vsli:raw="Creates a builder for metadata tables and heaps.">建立用於中繼資料表和堆積的產生器。</summary>
      <param name="userStringHeapStartOffset" vsli:raw="The start offset of the User String heap. The cumulative size of User String heaps of all previous EnC generations should be 0 unless the metadata is EnC delta metadata.">使用者字串堆積的起始位移。 除非中繼資料為 EnC 差異中繼資料，否則所有先前 EnC 產生的使用者字串堆積累計大小應為 0。</param>
      <param name="stringHeapStartOffset" vsli:raw="The start offset of the String heap. The cumulative size of String heaps of all previous EnC generations should be 0 unless the metadata is EnC delta metadata.">字串堆積的起始位移。 除非中繼資料為 EnC 差異中繼資料，否則所有先前 EnC 產生的字串堆積累計大小應為 0。</param>
      <param name="blobHeapStartOffset" vsli:raw="The start offset of the Blob heap. The cumulative size of Blob heaps of all previous EnC generations should be 0 unless the metadata is EnC delta metadata.">Blob 堆積的起始位移。 除非中繼資料為 EnC 差異中繼資料，否則所有先前 EnC 產生的 Blob 堆積累計大小應為 0。</param>
      <param name="guidHeapStartOffset" vsli:raw="The start offset of the Guid heap. The cumulative size of Guid heaps of all previous EnC generations should be 0 unless the metadata is EnC delta metadata.">GUID 堆積的起始位移。 除非中繼資料為 EnC 差異中繼資料，否則所有先前 EnC 產生的 GUID 堆積累計大小應為 0。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssembly(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.AssemblyHashAlgorithm)">
      <param name="name" vsli:raw="" />
      <param name="version" vsli:raw="" />
      <param name="culture" vsli:raw="" />
      <param name="publicKey" vsli:raw="" />
      <param name="flags" vsli:raw="" />
      <param name="hashAlgorithm" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyFile(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Boolean)">
      <param name="name" vsli:raw="" />
      <param name="hashValue" vsli:raw="" />
      <param name="containsMetadata" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyReference(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.Metadata.BlobHandle)">
      <param name="name" vsli:raw="" />
      <param name="version" vsli:raw="" />
      <param name="culture" vsli:raw="" />
      <param name="publicKeyOrToken" vsli:raw="" />
      <param name="flags" vsli:raw="" />
      <param name="hashValue" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddConstant(System.Reflection.Metadata.EntityHandle,System.Object)">
      <summary vsli:raw="Adds a default value for a parameter, field or property.">新增參數、欄位或屬性的預設值。</summary>
      <param name="parent" vsli:raw="The parent entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;.">父實體控制代碼，可能是下列其中一項：<see cref="T:System.Reflection.Metadata.ParameterHandle" />、<see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />。</param>
      <param name="value" vsli:raw="The constant value.">常數值。</param>
      <returns vsli:raw="A handle to the added constant.">已新增之常數的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a custom attribute.">新增自訂屬性。</summary>
      <param name="parent" vsli:raw="An entity to attach the custom attribute to: a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.InterfaceImplementationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignatureHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ManifestResourceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterConstraintHandle&quot; /&gt;, or a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodSpecificationHandle&quot; /&gt;.">要附加自訂屬性的實體：<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.ParameterHandle" />、<see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />、<see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />、<see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />、<see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />、<see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />、<see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />、<see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />、<see cref="T:System.Reflection.Metadata.GenericParameterHandle" />、<see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" /> 或 <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />。</param>
      <param name="constructor" vsli:raw="A custom attribute constructor: a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;.">自訂屬性建構函式：<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />。</param>
      <param name="value" vsli:raw="A custom attribute value blob.">自訂屬性值 Blob。</param>
      <returns vsli:raw="A handle to the added custom attribute.">已新增之自訂屬性的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomDebugInformation(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds custom debug information.">新增自訂偵錯資訊。</summary>
      <param name="parent" vsli:raw="An entity to attach the debug information to: a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.InterfaceImplementationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignatureHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ManifestResourceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterConstraintHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DocumentHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalScopeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalVariableHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalConstantHandle&quot; /&gt;, or a &lt;see cref=&quot;T:System.Reflection.Metadata.ImportScopeHandle&quot; /&gt;.">要附加偵錯資訊的實體：<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.ParameterHandle" />、<see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />、<see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />、<see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />、<see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />、<see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />、<see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />、<see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />、<see cref="T:System.Reflection.Metadata.GenericParameterHandle" />、<see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />、<see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />、<see cref="T:System.Reflection.Metadata.DocumentHandle" />、<see cref="T:System.Reflection.Metadata.LocalScopeHandle" />、<see cref="T:System.Reflection.Metadata.LocalVariableHandle" />、<see cref="T:System.Reflection.Metadata.LocalConstantHandle" /> 或 <see cref="T:System.Reflection.Metadata.ImportScopeHandle" />。</param>
      <param name="kind" vsli:raw="The information kind. Determines the structure of the &lt;paramref name=&quot;value&quot; /&gt; blob.">資訊種類。 判斷 <paramref name="value" /> Blob 的結構。</param>
      <param name="value" vsli:raw="The custom debug information blob.">自訂偵錯資訊 Blob。</param>
      <returns vsli:raw="A handle to the added custom debug information.">已新增之自訂偵錯資訊的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDeclarativeSecurityAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.DeclarativeSecurityAction,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a declarative security attribute to a type, method, or assembly.">將宣告式安全性屬性新增至類型、方法或組件。</summary>
      <param name="parent" vsli:raw="The parent entity handle, which can be one of the following: a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, or a &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;.">父實體控制代碼，可能是下列其中一項：<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />。</param>
      <param name="action" vsli:raw="A declarative security action.">宣告式安全性動作。</param>
      <param name="permissionSet" vsli:raw="The permission set blob.">權限集合 Blob。</param>
      <returns vsli:raw="A handle to the added declarative security attribute.">已新增之宣告式安全性屬性的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDocument(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle)">
      <summary vsli:raw="Adds document debug information.">新增文件偵錯資訊。</summary>
      <param name="name" vsli:raw="The document name blob.">文件名稱 Blob。</param>
      <param name="hashAlgorithm" vsli:raw="THe GUID of the hash algorithm used to calculate the value of &lt;paramref name=&quot;hash&quot; /&gt;.">用來計算 <paramref name="hash" /> 值之雜湊演算法的 GUID。</param>
      <param name="hash" vsli:raw="The hash of the document content.">文件內容的雜湊。</param>
      <param name="language" vsli:raw="The GUID of the language.">語言的 GUID。</param>
      <returns vsli:raw="A handle to the added document.">已新增之文件的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncLogEntry(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="entity" vsli:raw="" />
      <param name="code" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncMapEntry(System.Reflection.Metadata.EntityHandle)">
      <param name="entity" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEvent(System.Reflection.EventAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Adds an event definition.">新增事件定義。</summary>
      <param name="attributes" vsli:raw="The event attributes.">事件屬性。</param>
      <param name="name" vsli:raw="The event name.">事件名稱。</param>
      <param name="type" vsli:raw="The type of the event: a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">事件的類型：<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />。</param>
      <returns vsli:raw="A handle to the added event definition.">已新增之事件定義的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEventMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="declaringType" vsli:raw="" />
      <param name="eventList" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddExportedType(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <summary vsli:raw="Adds an exported type.">新增匯出類型。</summary>
      <param name="attributes" vsli:raw="The type attributes.">類型屬性。</param>
      <param name="namespace" vsli:raw="The type namespace.">類型命名空間。</param>
      <param name="name" vsli:raw="The type name.">類型名稱。</param>
      <param name="implementation" vsli:raw="The implementation entity handle, which can be one of the following: an &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;.">實作實體控制代碼，可能是下列其中一項：<see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />、<see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> 或 <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />。</param>
      <param name="typeDefinitionId" vsli:raw="The type definition ID.">類型定義識別碼。</param>
      <returns vsli:raw="A handle to the added exported type.">已新增之匯出類型的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldDefinition(System.Reflection.FieldAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a field definition.">新增欄位定義。</summary>
      <param name="attributes" vsli:raw="The field attributes.">欄位屬性。</param>
      <param name="name" vsli:raw="The field name.">欄位名稱。</param>
      <param name="signature" vsli:raw="The field signature. Use &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature&quot; /&gt; to construct the blob.">欄位簽章。 使用 <see cref="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature" /> 來建構 Blob。</param>
      <returns vsli:raw="A handle to the added field definition.">已新增之欄位定義的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldLayout(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary vsli:raw="Defines a field layout of a field definition.">定義欄位定義的欄位配置。</summary>
      <param name="field" vsli:raw="The field definition handle.">欄位定義控制代碼。</param>
      <param name="offset" vsli:raw="The byte offset of the field within the declaring type instance.">宣告類型執行個體中欄位的位元組位移。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldRelativeVirtualAddress(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary vsli:raw="Adds a mapping from a field to its initial value stored in the PE image.">新增對應 (從欄位到其儲存在 PE 映像中的初始值)。</summary>
      <param name="field" vsli:raw="The field definition handle.">欄位定義控制代碼。</param>
      <param name="offset" vsli:raw="The offset within the block in the PE image that stores initial values of mapped fields (usually in the .text section).">PE 映像中儲存對應欄位初始值的區塊內位移 (通常是在 .text 區段中)。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameter(System.Reflection.Metadata.EntityHandle,System.Reflection.GenericParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary vsli:raw="Adds a generic parameter definition.">新增泛型參數定義。</summary>
      <param name="parent" vsli:raw="The parent entity handle, which can be either a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;.">父實體控制代碼，可能是 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />。</param>
      <param name="attributes" vsli:raw="The generic parameter attributes.">泛型參數屬性。</param>
      <param name="name" vsli:raw="The parameter name.">參數名稱。</param>
      <param name="index" vsli:raw="The zero-based parameter index.">以零起始的參數索引。</param>
      <returns vsli:raw="A handle to the added generic parameter.">已新增之泛型參數的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameterConstraint(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Adds a type constraint to a generic parameter.">將類型條件約束新增至泛型參數。</summary>
      <param name="genericParameter" vsli:raw="The generic parameter to constrain.">要限制的泛型參數。</param>
      <param name="constraint" vsli:raw="The type constraint, which can be one of the following: a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">類型條件約束，可以是下列其中一項：<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />。</param>
      <returns vsli:raw="A handle to the added generic parameter constraint.">已新增之泛型參數條件約束的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddImportScope(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds local scope debug information.">新增本機範圍偵錯資訊。</summary>
      <param name="parentScope" vsli:raw="The parent scope handle.">父範圍控制代碼。</param>
      <param name="imports" vsli:raw="The import scope handle.">匯入範圍控制代碼。</param>
      <returns vsli:raw="A handle to the added import scope.">已新增之匯入範圍的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddInterfaceImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Adds an interface implementation to a type.">將介面實作新增至類型。</summary>
      <param name="type" vsli:raw="The type implementing the interface.">實作介面的類型。</param>
      <param name="implementedInterface" vsli:raw="The interface being implemented, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">所實作的介面，可以是下列其中一項：<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />。</param>
      <returns vsli:raw="A handle to the added interface implementation.">已新增之介面實作的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalConstant(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds local constant debug information.">新增本機常數偵錯資訊。</summary>
      <param name="name" vsli:raw="The name of the variable.">變數的名稱。</param>
      <param name="signature" vsli:raw="The LocalConstantSig blob.">LocalConstantSig Blob。</param>
      <returns vsli:raw="A handle to the added local constant.">已新增之本機常數的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalScope(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalConstantHandle,System.Int32,System.Int32)">
      <summary vsli:raw="Adds local scope debug information.">新增本機範圍偵錯資訊。</summary>
      <param name="method" vsli:raw="The containing method.">內含方法。</param>
      <param name="importScope" vsli:raw="The handle of the associated import scope.">相關聯之匯入範圍的控制代碼。</param>
      <param name="variableList" vsli:raw="If the scope declares variables, set this to the handle of the first one. Otherwise, set this to the handle of the first variable declared by the next scope definition. If no scope defines any variables, &lt;see langword=&quot;System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(1)&quot; /&gt;.">如果範圍宣告變數，則請將此值設定為第一個變數的控制代碼。 否則，請將此值設定為下一個範圍定義所宣告第一個變數的控制代碼。 如果沒有範圍定義任何變數，則為 <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(1)" />。</param>
      <param name="constantList" vsli:raw="If the scope declares constants, set this the handle of the first one. Otherwise, set this to the handle of the first constant declared by the next scope definition. If no scope defines any constants, &lt;see langword=&quot;System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(1)&quot; /&gt;.">如果範圍宣告常數，則請將此值設定為第一個常數的控制代碼。 否則，請將此值設定為下一個範圍定義所宣告第一個常數的控制代碼。 如果沒有範圍定義任何常數，則為 <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(1)" />。</param>
      <param name="startOffset" vsli:raw="The offset of the first instruction covered by the scope.">範圍所涵蓋第一個指令的位移。</param>
      <param name="length" vsli:raw="The length (in bytes) of the scope.">範圍的長度 (以位元組為單位)。</param>
      <returns vsli:raw="A handle to the added local scope.">已新增之本機範圍的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalVariable(System.Reflection.Metadata.LocalVariableAttributes,System.Int32,System.Reflection.Metadata.StringHandle)">
      <summary vsli:raw="Adds local variable debug information.">新增本機變數偵錯資訊。</summary>
      <param name="attributes" vsli:raw="The local variable attributes.">本機變數屬性。</param>
      <param name="index" vsli:raw="The zero-base index of the local variable in the local signature.">本機簽章中本機變數的以零起始索引。</param>
      <param name="name" vsli:raw="The name of the variable.">變數的名稱。</param>
      <returns vsli:raw="A handle to the added local variable.">已新增之本機變數的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddManifestResource(System.Reflection.ManifestResourceAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.UInt32)">
      <summary vsli:raw="Adds a manifest resource.">新增資訊清單資源。</summary>
      <param name="attributes" vsli:raw="The manifest resource attributes.">資訊清單資源屬性。</param>
      <param name="name" vsli:raw="The name of the manifest resource.">資訊清單資源的名稱。</param>
      <param name="implementation" vsli:raw="The implementation entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, or &lt;see langword=&quot;null&quot; /&gt;.">實作實體控制代碼，可能是下列其中一項：<see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> 或 <see langword="null" />。</param>
      <param name="offset" vsli:raw="Specifies the byte offset within the referenced file at which this resource record begins.">指定此資源記錄在參考檔案檔案中，從其開始處的位元組位移。</param>
      <returns vsli:raw="A handle to the added manifest resource.">已新增之資訊清單資源的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMarshallingDescriptor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds marshalling information to a field or a parameter.">將封送處理資訊新增至欄位或參數。</summary>
      <param name="parent" vsli:raw="The parent entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;.">父實體控制代碼，可能是下列其中一項：<see cref="T:System.Reflection.Metadata.ParameterHandle" /> 或 <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />。</param>
      <param name="descriptor" vsli:raw="The descriptor blob.">描述元 Blob。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMemberReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a MemberRef table row.">新增 MemberRef 資料表資料列。</summary>
      <param name="parent" vsli:raw="The containing entity, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">內含實體，可能是下列其中一項：<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、<see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />、<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />。</param>
      <param name="name" vsli:raw="The member name.">成員名稱。</param>
      <param name="signature" vsli:raw="The member signature.">成員簽章。</param>
      <returns vsli:raw="A handle to the added member reference.">已新增之成員參考的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDebugInformation(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds method debug information.">新增方法偵錯資訊。</summary>
      <param name="document" vsli:raw="The handle of a single document containing all sequence points of the method, or &lt;see langword=&quot;null&quot; /&gt; if the method doesn't have sequence points or spans multiple documents.">單一文件的控制代碼，該文件包含方法的所有序列點；若方法沒有序列點或跨多個文件，則為 <see langword="null" />。</param>
      <param name="sequencePoints" vsli:raw="The sequence Points blob, or &lt;see langword=&quot;null&quot; /&gt; if the method doesn't have sequence points.">序列點 Blob；若方法沒有序列點，則為 <see langword="null" />。</param>
      <returns vsli:raw="A handle to the added method debug information.">已新增之方法偵錯資訊的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDefinition(System.Reflection.MethodAttributes,System.Reflection.MethodImplAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Int32,System.Reflection.Metadata.ParameterHandle)">
      <summary vsli:raw="Adds a method definition.">新增方法定義。</summary>
      <param name="attributes" vsli:raw="The method attributes.">方法屬性。</param>
      <param name="implAttributes" vsli:raw="The method implementation attributes.">方法實作屬性。</param>
      <param name="name" vsli:raw="The method name.">方法名稱。</param>
      <param name="signature" vsli:raw="The method signature.">方法簽章。</param>
      <param name="bodyOffset" vsli:raw="Offset within the block in the PE image that stores method bodies (the IL stream), or -1 if the method doesn't have a body.">PE 映像中儲存方法主體 (IL 資料流) 的區塊內位移；如果方法沒有主體，則為 -1。</param>
      <param name="parameterList" vsli:raw="If the method declares parameters in the Params table, set this to the handle of the first one. Otherwise, set this to the handle of the first parameter declared by the next method definition. If no parameters are declared in the module, &lt;see langword=&quot;System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(1)&quot; /&gt;.">如果方法宣告 Params 資料表中的參數，則請將其設定為第一個參數的控制代碼。 否則，請將此值設定為下一個方法定義所宣告第一個參數的控制代碼。 如果模組中未宣告任何參數，則為 <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(1)" />。</param>
      <returns vsli:raw="A handle to the added method definition.">已新增之方法定義的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Defines an implementation for a method declaration within a type.">定義類型中方法宣告的實作。</summary>
      <param name="type" vsli:raw="The type definition.">類型定義</param>
      <param name="methodBody" vsli:raw="The method body entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;.">方法主體實體控制代碼，可能是下列其中一項：<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />。</param>
      <param name="methodDeclaration" vsli:raw="The method declaration entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;.">方法宣告實體控制代碼，可能是下列其中一項：<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />。</param>
      <returns vsli:raw="A handle to the added method implementation.">已新增之方法實作的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImport(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.MethodImportAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <summary vsli:raw="Adds import information to a method definition.">將匯入資訊新增至方法定義。</summary>
      <param name="method" vsli:raw="The method definition handle.">方法定義控制代碼。</param>
      <param name="attributes" vsli:raw="The method import attributes.">方法匯入屬性。</param>
      <param name="name" vsli:raw="The unmanaged method name.">非受控方法名稱。</param>
      <param name="module" vsli:raw="The module containing the unmanaged method.">包含非受控方法的模組。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSemantics(System.Reflection.Metadata.EntityHandle,System.Reflection.MethodSemanticsAttributes,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary vsli:raw="Associates a method (a getter, a setter, an adder, etc.) with a property or an event.">將方法 (getter、setter、adder 等) 與屬性或事件建立關聯。</summary>
      <param name="association" vsli:raw="The association entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;.">關聯實體控制代碼，可能是下列其中一項：<see cref="T:System.Reflection.Metadata.EventDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />。</param>
      <param name="semantics" vsli:raw="The method semantics attributes.">方法語義屬性。</param>
      <param name="methodDefinition" vsli:raw="The method definition.">方法定義。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSpecification(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a method specification (an instantiation).">新增方法規格 (具現化)。</summary>
      <param name="method" vsli:raw="The generic method entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;.">泛型方法實體控制代碼，可能是下列其中一項：<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />。</param>
      <param name="instantiation" vsli:raw="The instantiation blob encoding the generic arguments of the method.">將方法泛型引數編碼的具現化 Blob。</param>
      <returns vsli:raw="A handle to the added method specification.">已新增之方法規格的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModule(System.Int32,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="generation" vsli:raw="" />
      <param name="moduleName" vsli:raw="" />
      <param name="mvid" vsli:raw="" />
      <param name="encId" vsli:raw="" />
      <param name="encBaseId" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModuleReference(System.Reflection.Metadata.StringHandle)">
      <param name="moduleName" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddNestedType(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <summary vsli:raw="Defines a nesting relationship to specified type definitions.">定義指定類型定義的巢狀關聯性。</summary>
      <param name="type" vsli:raw="The nested type definition handle.">巢狀型別定義控制代碼。</param>
      <param name="enclosingType" vsli:raw="The enclosing type definition handle.">封入類型定義控制代碼。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddParameter(System.Reflection.ParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary vsli:raw="Adds a parameter definition.">新增參數定義。</summary>
      <param name="attributes" vsli:raw="The parameter attributes.">參數屬性。</param>
      <param name="name" vsli:raw="Optional. The parameter name.">選擇性。 參數名稱。</param>
      <param name="sequenceNumber" vsli:raw="The sequence number of the parameter. A value of 0 refers to the owner method's return type; its parameters are then numbered from 1 onward.">參數的序號。 值 0 表示擁有者方法的傳回型別；其參數會接著從 1 開始編號。</param>
      <returns vsli:raw="A handle to the added parameter.">已新增之參數的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddProperty(System.Reflection.PropertyAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a property definition.">新增屬性定義。</summary>
      <param name="attributes" vsli:raw="The property attributes.">屬性 (Property) 的屬性 (Attribute)。</param>
      <param name="name" vsli:raw="The property name.">屬性名稱。</param>
      <param name="signature" vsli:raw="The signature of the property.">屬性的簽章。</param>
      <returns vsli:raw="A handle to the added property definition.">已新增之屬性定義的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddPropertyMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="declaringType" vsli:raw="" />
      <param name="propertyList" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStandaloneSignature(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStateMachineMethod(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary vsli:raw="Adds state machine method debug information.">新增狀態機器方法偵錯資訊。</summary>
      <param name="moveNextMethod" vsli:raw="The handle of the &lt;see langword=&quot;MoveNext&quot; /&gt; method of the state machine (the compiler-generated method).">狀態機器之 <see langword="MoveNext" /> 方法的控制代碼 (編譯器所產生的方法)。</param>
      <param name="kickoffMethod" vsli:raw="The handle of the kickoff method (the user defined iterator/async method).">啟動方法的控制代碼 (使用者定義的反覆運算器/非同步方法)。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeDefinition(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary vsli:raw="Adds a type definition.">新增類型定義。</summary>
      <param name="attributes" vsli:raw="The type attributes.">類型屬性。</param>
      <param name="namespace" vsli:raw="The type namespace.">類型命名空間。</param>
      <param name="name" vsli:raw="The type name.">類型名稱。</param>
      <param name="baseType" vsli:raw="The base type entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, or &lt;see langword=&quot;null&quot; /&gt;.">基底類型實體控制代碼，可能是下列其中一項：<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> 或 <see langword="null" />。</param>
      <param name="fieldList" vsli:raw="If the type declares fields, set this to the handle of the first one. Otherwise, set this to the handle of the first field declared by the next type definition. If no type defines any fields in the module, &lt;see langword=&quot;System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(1)&quot; /&gt;.">如果類型宣告欄位，則請將此值設定為第一個欄位的控制代碼。 否則，請將此值設定為下一個類型定義所宣告第一個欄位的控制代碼。 如果沒有類型定義模組中的任何欄位，則為 <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(1)" />。</param>
      <param name="methodList" vsli:raw="If the type declares methods, the handle of the first one. Otherwise, the handle of the first method declared by the next type definition. If no type defines any methods in the module, &lt;see langword=&quot;System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(1)&quot; /&gt;.">如果類型宣告方法，則為第一個方法的控制代碼。 否則，即會是下一個類型定義所宣告第一個方法的控制代碼。 如果沒有類型定義模組中的任何方法，則為 <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(1)" />。</param>
      <returns vsli:raw="A handle to the added type definition.">已新增之類型定義的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeLayout(System.Reflection.Metadata.TypeDefinitionHandle,System.UInt16,System.UInt32)">
      <summary vsli:raw="Defines a type layout of a type definition.">定義類型定義的類型配置。</summary>
      <param name="type" vsli:raw="The type definition.">類型定義</param>
      <param name="packingSize" vsli:raw="Specifies that fields should be placed within the type instance at byte addresses which are a multiple of &lt;paramref name=&quot;packingSize&quot; /&gt;, or at natural alignment for that field type, whichever is smaller. Its value should be one of the following: 0, 1, 2, 4, 8, 16, 32, 64, or 128. A value of zero indicates that the packing size used should match the default for the current platform.">指定欄位應該放在類型執行個體內，放置處的位元組位址是 <paramref name="packingSize" /> 的倍數，或以該欄位類型的自然對齊方式放置，以較小者為准。 其值應為下列其中一項：0、1、2、4、8、16、32、64 或 128。 值零指出所使用的封裝大小應符合目前平台的預設值。</param>
      <param name="size" vsli:raw="Indicates a minimum size of the type instance and is intended to allow for padding. The amount of memory allocated is the maximum of the size calculated from the layout and &lt;paramref name=&quot;size&quot; /&gt;. Note that if this directive applies to a value type, then the size will be less than 1 MB.">指出類型執行個體的大小下限，目的在於允許填補。 所配置記憶體數量是從配置和 <paramref name="size" /> 計算所得的大小上限。 請注意，如果這個指示詞套用到實值型別，則大小會小於 1 MB。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <summary vsli:raw="Adds a type reference.">新增類型參考。</summary>
      <param name="resolutionScope" vsli:raw="The entity declaring the target type, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, or &lt;see langword=&quot;null&quot; /&gt;.">宣告目標類型的實體，可能是下列其中一項：<see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 或 <see langword="null" />。</param>
      <param name="namespace" vsli:raw="The type reference namespace.">類型參考命名空間。</param>
      <param name="name" vsli:raw="The type reference name.">類型參考名稱。</param>
      <returns vsli:raw="A handle to the added type reference.">已新增之類型參考的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeSpecification(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Byte[])">
      <summary vsli:raw="Adds the specified blob to the Blob heap, if it's not there already.">將指定的 Blob 新增至 Blob 堆積 (如果尚未存在)。</summary>
      <param name="value" vsli:raw="The array containing the blob.">包含 Blob 的陣列。</param>
      <returns vsli:raw="A handle to the added or existing blob.">已新增或現有 Blob 的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Adds the specified blob from a byte array to the Blob heap, if it's not there already.">將指定的 Blob 從位元組陣列新增至 Blob 堆積 (如果尚未存在)。</summary>
      <param name="value" vsli:raw="The array containing the blob.">包含 Blob 的陣列。</param>
      <returns vsli:raw="A handle to the added or existing blob.">已新增或現有 Blob 的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Reflection.Metadata.BlobBuilder)">
      <summary vsli:raw="Adds the specified blob from an immutable byte array to the Blob heap, if it's not there already.">將指定的 Blob 從不可變位元組陣列新增至 Blob 堆積 (如果尚未存在)。</summary>
      <param name="value" vsli:raw="The blob builder instance containing the blob.">包含 Blob 的 Blob 產生器執行個體。</param>
      <returns vsli:raw="A handle to the added or existing blob.">已新增或現有 Blob 的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF16(System.String)">
      <summary vsli:raw="Encodes a string using UTF16 encoding to a blob and adds it to the Blob heap, if it's not there already.">使用 UTF16 編碼將字串編碼為 Blob，並將其新增至 Blob 堆積 (如果尚未存在)。</summary>
      <param name="value" vsli:raw="The string to add.">要加入的字串。</param>
      <returns vsli:raw="A handle to the added or existing blob.">已新增或現有 Blob 的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF8(System.String,System.Boolean)">
      <summary vsli:raw="Encodes a string using UTF8 encoding to a blob and adds it to the Blob heap, if it's not there already.">使用 UTF8 編碼將字串編碼為 Blob，並將其新增至 Blob 堆積 (如果尚未存在)。</summary>
      <param name="value" vsli:raw="The value to add.">要加入的值。</param>
      <param name="allowUnpairedSurrogates" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode the unpaired surrogates as specified; &lt;see langword=&quot;false&quot; /&gt; to replace them with the U+FFFD character.">設定為 <see langword="true" /> 會以指定方式編碼非成對代理字元；設定為 <see langword="false" /> 則會以 U+FFFD 字元取代那些字元。</param>
      <returns vsli:raw="A handle to the added or existing blob.">已新增或現有 Blob 的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddConstantBlob(System.Object)">
      <summary vsli:raw="Encodes a constant value to a blob and adds it to the Blob heap, if it's not there already. Uses UTF16 to encode string constants.">將常數值編碼為 Blob，並將其新增至 Blob 堆積 (如果尚未存在)。 請使用 UTF16 來編碼字串常數。</summary>
      <param name="value" vsli:raw="The constant value to add.">要新增的常數值。</param>
      <returns vsli:raw="A handle to the added or existing blob.">已新增或現有 Blob 的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddDocumentName(System.String)">
      <summary vsli:raw="Encodes a debug document name and adds it to the Blob heap, if it's not there already.">將偵錯文件名稱編碼，並將其新增至 Blob 堆積 (如果尚未存在)。</summary>
      <param name="value" vsli:raw="The document name to add.">要新增的文件名稱。</param>
      <returns vsli:raw="A handle to the added or existing document name blob.">已新增或現有文件名稱 Blob 的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddGuid(System.Guid)">
      <summary vsli:raw="Adds the specified Guid to the Guid heap, if it's not there already.">將指定的 GUID 新增至 GUID 堆積 (如果尚未存在)。</summary>
      <param name="guid" vsli:raw="The Guid to add.">要新增的 GUID。</param>
      <returns vsli:raw="A handle to the added or existing Guid.">已新增或現有 GUID 的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddString(System.String)">
      <summary vsli:raw="Adds the specified string to the string heap, if it's not there already.">將指定的字串新增至字串堆積 (如果尚未存在)。</summary>
      <param name="value" vsli:raw="The string to add.">要加入的字串。</param>
      <returns vsli:raw="A handle to the added or existing string.">已新增或現有字串的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddUserString(System.String)">
      <summary vsli:raw="Adds the specified string to the user string heap, if it's not there already.">將指定的字串新增至使用者字串堆積 (如果尚未存在)。</summary>
      <param name="value" vsli:raw="The string to add.">要加入的字串。</param>
      <returns vsli:raw="A handle to the added or existing string. This value may be used in &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)&quot; /&gt;.">已新增或現有字串的控制代碼。 此值可以在 <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" /> 中使用。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCount(System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary vsli:raw="Returns the current number of items in the specified table.">傳回所指定資料表中目前的項目數。</summary>
      <param name="table" vsli:raw="The table index.">資料表索引。</param>
      <returns vsli:raw="The number of items in the table.">資料表中項目數。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCounts">
      <summary vsli:raw="Returns the current number of items in each table.">傳回每個資料表中目前的項目數。</summary>
      <returns vsli:raw="An array of size &lt;see cref=&quot;F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount&quot; /&gt;, with each item filled with the current row count of the corresponding table.">
        <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" /> 大小的陣列，其中每個項目都會填入相對應資料表的目前資料列計數。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveGuid">
      <summary vsli:raw="Reserves space on the Guid heap for a GUID.">在 GUID 堆積上為 GUID 保留空間。</summary>
      <returns vsli:raw="A handle to the reserved Guid and a &lt;see cref=&quot;T:System.Reflection.Metadata.Blob&quot; /&gt; representing the GUID blob as stored on the heap.">已保留 GUID 的控制代碼，以及代表堆積上所儲存之 GUID Blob 的 <see cref="T:System.Reflection.Metadata.Blob" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveUserString(System.Int32)">
      <summary vsli:raw="Reserves space on the user string heap for a string of the specified length.">在使用者字串堆積上為指定長度的字串保留空間。</summary>
      <param name="length" vsli:raw="The number of characters to reserve.">要保留的字元數。</param>
      <returns vsli:raw="A handle to the reserved user string and a &lt;see cref=&quot;T:System.Reflection.Metadata.Blob&quot; /&gt; representing the entire User String blob (including its length and terminal character). The handle may be used in &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)&quot; /&gt;.&#xA; Use &lt;see cref=&quot;M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)&quot; /&gt; to fill in the blob content.">已保留使用者字串的控制代碼，以及代表整個使用者字串 Blob (包括其長度和結束字元) 的 <see cref="T:System.Reflection.Metadata.Blob" />。 此控制代碼可以在 <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" /> 中使用。
請使用 <see cref="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)" /> 來填入 Blob 內容。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.HeapIndex,System.Int32)">
      <summary vsli:raw="Sets the capacity of the specified heap.">設定指定堆積的容量。</summary>
      <param name="heap" vsli:raw="The heap index.">堆積索引。</param>
      <param name="byteCount" vsli:raw="The number of bytes.">位元組數。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary vsli:raw="Sets the capacity of the specified table.">設定指定資料表的容量。</summary>
      <param name="table" vsli:raw="The table index.">資料表索引。</param>
      <param name="rowCount" vsli:raw="The number of rows in the table.">表格中的列數。</param>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions">
      <summary vsli:raw="Provides extension methods for working with certain raw elements of the ECMA-335 metadata tables and heaps.">提供使用 ECMA-335 中繼資料資料表和堆積特定原始項目的擴充方法。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueLogEntries(System.Reflection.Metadata.MetadataReader)">
      <summary vsli:raw="Enumerates entries of EnC log.">列舉 EnC 記錄的項目。</summary>
      <param name="reader" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueMapEntries(System.Reflection.Metadata.MetadataReader)">
      <summary vsli:raw="Enumerates entries of EnC map.">列舉 EnC 對應的項目。</summary>
      <param name="reader" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary vsli:raw="Returns the offset from the start of metadata to the specified heap.">傳回從中繼資料開頭到指定堆積的位移。</summary>
      <param name="reader" vsli:raw="" />
      <param name="heapIndex" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary vsli:raw="Returns the size of the specified heap.">傳回指定堆積的大小。</summary>
      <param name="reader" vsli:raw="" />
      <param name="heapIndex" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Returns the handle to the &lt;see cref=&quot;T:System.Reflection.Metadata.Blob&quot; /&gt; that follows the given one in the &lt;see cref=&quot;T:System.Reflection.Metadata.Blob&quot; /&gt; heap or a nil handle if it is the last one.">傳回 <see cref="T:System.Reflection.Metadata.Blob" /> 的控制代碼，該控制代碼會位在 <see cref="T:System.Reflection.Metadata.Blob" /> 堆積中所提供項目之後，或若其為最後一個項目，則為 Nil 控制代碼。</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.StringHandle)">
      <summary vsli:raw="Returns the a handle to the string that follows the given one in the string heap, or a nil handle if it is the last one.">傳回字串的控制代碼，該控制代碼會位在字串堆積中所提供項目之後，或若其為最後一個項目，則為 Nil 控制代碼。</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.UserStringHandle)">
      <summary vsli:raw="Returns the a handle to the UserString that follows the given one in the UserString heap or a nil handle if it is the last one.">傳回 UserString 的控制代碼，該控制代碼會位在 UserString 堆積中所提供項目之後，或若其為最後一個項目，則為 Nil 控制代碼。</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary vsli:raw="Returns the offset from the start of metadata to the specified table.">傳回從中繼資料開頭到指定資料表的位移。</summary>
      <param name="reader" vsli:raw="" />
      <param name="tableIndex" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowCount(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary vsli:raw="Returns the number of rows in the specified table.">傳回指定資料表中的資料列數。</summary>
      <param name="reader" vsli:raw="" />
      <param name="tableIndex" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary vsli:raw="Returns the size of a row in the specified table.">傳回指定資料表中的資料列大小。</summary>
      <param name="reader" vsli:raw="" />
      <param name="tableIndex" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithEvents(System.Reflection.Metadata.MetadataReader)">
      <summary vsli:raw="Enumerate types that define one or more events.">列舉定義一或多個事件的類型。</summary>
      <param name="reader" vsli:raw="" />
      <returns vsli:raw="The resulting sequence corresponds exactly to entries in EventMap table, i.e. n-th returned &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; is stored in n-th row of EventMap.">產生的序列會完全對應至 EventMap 資料表中項目，即第 N 個傳回的 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 會儲存在 EventMap 的第 N 列中。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithProperties(System.Reflection.Metadata.MetadataReader)">
      <summary vsli:raw="Enumerate types that define one or more properties.">列舉定義一或多個屬性的類型。</summary>
      <param name="reader" vsli:raw="" />
      <returns vsli:raw="The resulting sequence corresponds exactly to entries in the property map table, that is, the n-th returned &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; is stored in n-th row of the property map.">產生的序列會完全對應至屬性對應資料表中項目，即第 N 個傳回的 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 會儲存在屬性對應的第 N 列中。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)">
      <summary vsli:raw="Given a type handle and a raw type kind found in a signature blob determines whether the target type is a value type or a reference type.">簽章 Blob 中找到的類型控制代碼和原始類型種類會決定目標類型為實值型別還是參考型別。</summary>
      <param name="reader" vsli:raw="" />
      <param name="typeHandle" vsli:raw="" />
      <param name="rawTypeKind" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataRootBuilder">
      <summary vsli:raw="Builder of a Metadata Root to be embedded in a Portable Executable image.">要內嵌於可攜式執行檔映像的中繼資料根建立器。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.String,System.Boolean)">
      <summary vsli:raw="Creates a builder of a metadata root.">建立中繼資料根的建立器。</summary>
      <param name="tablesAndHeaps" vsli:raw="Builder populated with metadata entities stored in tables and values stored in heaps. The entities and values will be enumerated when serializing the metadata root.">使用儲存於資料表的中繼資料實體，以及儲存於堆積的值填入的建立器。 實體與值會在將中繼資料根序列化時進行列舉。</param>
      <param name="metadataVersion" vsli:raw="The version string written to the metadata header. The default value is &quot;v4.0.30319&quot;.">版本字串會寫入至中繼資料標頭。 預設值為 "v4.0.30319"。</param>
      <param name="suppressValidation" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to suppress basic validation of metadata tables during serialization; otherwise, &lt;paramref name=&quot;false&quot; /&gt;.">
        <see langword="true" /> 以在序列化期間隱藏中繼資料表的基本驗證；否則為 <paramref name="false" />。</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.MetadataVersion">
      <summary vsli:raw="The metadata version.">中繼資料版本。</summary>
      <returns vsli:raw="A string that represents the metadata version.">表示中繼資料版本的字串。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Int32,System.Int32)">
      <summary vsli:raw="Serializes metadata root content into the given &lt;see cref=&quot;T:System.Reflection.Metadata.BlobBuilder&quot; /&gt;.">將中繼資料根內容序列化到指定的 <see cref="T:System.Reflection.Metadata.BlobBuilder" />。</summary>
      <param name="builder" vsli:raw="Builder to write to.">要寫入到其中的建立器。</param>
      <param name="methodBodyStreamRva" vsli:raw="The relative virtual address of the start of the method body stream. Used to calculate the final value of RVA fields of MethodDef table.">方法主體資料流開頭的相對虛擬位址。 用來計算 MethodDef 資料表 RVA 欄位的最終值。</param>
      <param name="mappedFieldDataStreamRva" vsli:raw="The relative virtual address of the start of the field init data stream. Used to calculate the final value of RVA fields of FieldRVA table.">欄位初始資料流開頭的相對虛擬位址。 用來計算 FieldRVA 資料表 RVA 欄位的最終值。</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Sizes">
      <summary vsli:raw="Returns sizes of various metadata structures.">傳回不同中繼資料結構的大小。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation">
      <summary vsli:raw="Determines if basic validation of metadata tables should be suppressed. The validation verifies that entries in the tables were added in order required by the ECMA specification. It does not enforce all specification requirements on metadata tables.">判斷是否要隱藏中繼資料表的基本驗證。 驗證會驗證資料表中項目已按照 ECMA 規格要求的順序新增。 其不會在中繼資料表上強制實行所有規格需求。</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to suppress basic validation of metadata tables; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> 隱藏中繼資料資料表的基本驗證;否則，<see langword="false" />。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataSizes">
      <summary vsli:raw="Provides information on sizes of various metadata structures.">提供各種中繼資料結構的大小資訊。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.ExternalRowCounts">
      <summary vsli:raw="External table row count.">外部資料表資料列計數。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataSizes.GetAlignedHeapSize(System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary vsli:raw="Returns aligned size of the specified heap.">傳回指定堆積的對齊大小。</summary>
      <param name="index" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.HeapSizes">
      <summary vsli:raw="Exact (unaligned) heap sizes.">精確 (未對齊) 的堆積大小。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.RowCounts">
      <summary vsli:raw="Table row counts.">資料表資料列計數。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataTokens" />
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyFileHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyReferenceHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.BlobHandle(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ConstantHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomAttributeHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomDebugInformationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DeclarativeSecurityAttributeHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentNameBlobHandle(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Int32)">
      <summary vsli:raw="Creates an entity handle from a token value.">從權杖值建立實體控制代碼。</summary>
      <param name="token" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; from a token value.">從權杖值建立 <see cref="T:System.Reflection.Metadata.EntityHandle" />。</summary>
      <param name="tableIndex" vsli:raw="" />
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EventDefinitionHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ExportedTypeHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterConstraintHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">取得中繼資料堆積資料的位移，該中繼資料對應至指定的 <paramref name="handle" />。</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Zero based offset, or -1 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.MetadataBuilder&quot; /&gt;.">以零為基礎的位移，或若 <paramref name="handle" /> 只能在特定 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 或 <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> 的內容中解譯，則為 -1。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.GuidHandle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">取得中繼資料堆積資料的位移，該中繼資料對應至指定的 <paramref name="handle" />。</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="1-based index into the #Guid heap. Unlike other heaps, which are essentially byte arrays, the #Guid heap is an array of 16-byte GUIDs.">#GUID 堆積中以 1 為基礎的索引。 與其他基本上是位元組陣列的堆積不同，#GUID 堆積是 16 位元組 GUID 的陣列。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">取得中繼資料堆積資料的位移，該中繼資料對應至指定的 <paramref name="handle" />。</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="An offset in the corresponding heap, or -1 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.MetadataBuilder&quot; /&gt;.">對應堆積中的位移，或若 <paramref name="handle" /> 只能在特定 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 或 <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> 的內容中解譯，則為 -1。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt; in the context of &lt;paramref name=&quot;reader&quot; /&gt;.">取得中繼資料堆積資料的位移，該中繼資料對應至 <paramref name="reader" /> 內容中的指定 <paramref name="handle" />。</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Zero based offset, or -1 if &lt;paramref name=&quot;handle&quot; /&gt; isn't a metadata heap handle.">以零為基礎的位移，或若 <paramref name="handle" /> 不是中繼資料堆積控制代碼，則為 -1。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.StringHandle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">取得中繼資料堆積資料的位移，該中繼資料對應至指定的 <paramref name="handle" />。</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Zero-based offset, or -1 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.MetadataBuilder&quot; /&gt;.">以零為基礎的位移，或若 <paramref name="handle" /> 只能在特定 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 或 <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> 的內容中解譯，則為 -1。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.UserStringHandle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">取得中繼資料堆積資料的位移，該中繼資料對應至指定的 <paramref name="handle" />。</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Zero-based offset.">以零為基礎的位移。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Gets the row number of a metadata table entry that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">取得對應至指定 <paramref name="handle" /> 之中繼資料資料表項目的資料列號碼。</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="One based row number, or -1 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt;.&#xA; See &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)&quot; /&gt;.">以一為基礎的資料列號碼，或若 <paramref name="handle" /> 只能在特定 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 的內容中解譯，則為 -1。
請參閱 <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Gets the row number of a metadata table entry that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt; in the context of &lt;paramref name=&quot;reader&quot; /&gt;.">取得對應至 <paramref name="reader" /> 內容中指定 <paramref name="handle" /> 之中繼資料資料表項目的資料列號碼。</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="One based row number.">以一為基礎的資料列號碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Gets the metadata token of the specified &lt;paramref name=&quot;handle&quot; /&gt;.">取得指定 <paramref name="handle" /> 的中繼資料權杖。</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Metadata token, or 0 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt;.">中繼資料權杖，或若 <paramref name="handle" /> 只能在特定 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 的內容中解譯，則為 0。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Gets the metadata token of the specified &lt;paramref name=&quot;handle&quot; /&gt;.">取得指定 <paramref name="handle" /> 的中繼資料權杖。</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Metadata token, or 0 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt;.">中繼資料權杖，或若 <paramref name="handle" /> 只能在特定 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 的內容中解譯，則為 0。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Gets the metadata token of the specified &lt;paramref name=&quot;handle&quot; /&gt; in the context of &lt;paramref name=&quot;reader&quot; /&gt;.">取得 <paramref name="reader" /> 內容中指定 <paramref name="handle" /> 的中繼資料權杖。</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Metadata token.">中繼資料權杖。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Gets the metadata token of the specified &lt;paramref name=&quot;handle&quot; /&gt; in the context of &lt;paramref name=&quot;reader&quot; /&gt;.">取得 <paramref name="reader" /> 內容中指定 <paramref name="handle" /> 的中繼資料權杖。</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Metadata token.">中繼資料權杖。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GuidHandle(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Int32)">
      <summary vsli:raw="Creates a handle from a token value.">從權杖值建立控制代碼。</summary>
      <param name="token" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; from a token value.">從權杖值建立 <see cref="T:System.Reflection.Metadata.EntityHandle" />。</summary>
      <param name="tableIndex" vsli:raw="" />
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.HeapCount">
      <summary vsli:raw="Maximum number of tables that can be present in Ecma335 metadata.">可出現在 Ecma335 中繼資料中的資料表數量上限。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ImportScopeHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.InterfaceImplementationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalScopeHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ManifestResourceHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MemberReferenceHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDebugInformationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodImplementationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodSpecificationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ModuleReferenceHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.PropertyDefinitionHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StandaloneSignatureHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StringHandle(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount">
      <summary vsli:raw="Maximum number of tables that can be present in Ecma335 metadata.">可出現在 Ecma335 中繼資料中的資料表數量上限。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetHeapIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.HeapIndex@)">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.HeapIndex&quot; /&gt; of the heap corresponding to the specified &lt;see cref=&quot;T:System.Reflection.Metadata.HandleKind&quot; /&gt;.">取得堆積的 <see cref="T:System.Reflection.Metadata.Ecma335.HeapIndex" />，其對應至指定的 <see cref="T:System.Reflection.Metadata.HandleKind" />。</summary>
      <param name="type" vsli:raw="Handle type.">控制代碼類型。</param>
      <param name="index" vsli:raw="Heap index.">堆積索引。</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the handle type corresponds to an Ecma335 heap; &lt;see langword=&quot;false&quot; /&gt; otherwise.">若控制代碼類型對應至 Ecma335 堆積，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetTableIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.TableIndex@)">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.TableIndex&quot; /&gt; of the table corresponding to the specified &lt;see cref=&quot;T:System.Reflection.Metadata.HandleKind&quot; /&gt;.">取得資料表的 <see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" />，其對應至指定的 <see cref="T:System.Reflection.Metadata.HandleKind" />。</summary>
      <param name="type" vsli:raw="Handle type.">控制代碼類型。</param>
      <param name="index" vsli:raw="Table index.">資料表索引。</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the handle type corresponds to an Ecma335 or Portable PDB table; &lt;see langword=&quot;false&quot; /&gt; otherwise.">若控制代碼類型對應至 Ecma335 或可攜式 PDB 資料表，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeDefinitionHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeReferenceHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeSpecificationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.UserStringHandle(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyAttributes">
      <summary vsli:raw="Defines method body attributes.">定義方法主體屬性。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.InitLocals">
      <summary vsli:raw="Initializes any locals the method defines to zero and dynamically allocates local memory.">初始化方法定義為零的任何區域變數，並動態地配置本機記憶體。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.None">
      <summary vsli:raw="Performs no local memory initialization.">不執行本機記憶體初始化。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder">
      <summary vsli:raw="Provides an encoder for a method body stream.">提供方法主體資料流的編碼器。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary vsli:raw="Encodes a method body and adds it to the method body stream, using the provided code size, maximum stack size, number of exception regions, local variables' signature handle, method body attributes and allowing to indicate whether the exception regions should be encoded in small format or not.">編碼方法主體並將它新增至方法主體資料流，使用提供的程式碼大小、最大堆疊大小、例外狀況區域的數目、區域變數的簽章控制代碼、方法主體屬性，以及允許以指出例外狀況區域是否應以小型格式編碼。</summary>
      <param name="codeSize" vsli:raw="The number of bytes to be reserved for instructions.">要為指令保留的位元組數目。</param>
      <param name="maxStack" vsli:raw="The maximum stack size.">堆疊大小上限。</param>
      <param name="exceptionRegionCount" vsli:raw="The number of exception regions.">例外狀況區域的數目。</param>
      <param name="hasSmallExceptionRegions" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the exception regions should be encoded in small format; &lt;see langword=&quot;false&quot; /&gt; otherwise.">如果例外狀況區域應該以小型格式編碼，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
      <param name="localVariablesSignature" vsli:raw="The local variables' signature handle.">區域變數的簽章控制代碼。</param>
      <param name="attributes" vsli:raw="The method body attributes.">方法主體屬性。</param>
      <returns vsli:raw="The offset of the encoded body within the method body stream.">已編碼主體在方法主體資料流中的位移。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary vsli:raw="Encodes a method body and adds it to the method body stream, using the provided code size, maximum stack size, number of exception regions, local variables' signature handle, method body attributes, allowing to indicate whether the exception regions should be encoded in small format or not, and allowing to indicate whether the method should allocate from the dynamic local memory pool or not.">編碼方法主體並將它新增至方法主體資料流，使用提供的程式碼大小、最大堆疊大小、例外狀況區域的數目、區域變數的簽章控制代碼、方法主體屬性、允許指出例外狀況區域是否應以小型格式編碼，以及允許以指出方法是否應該從動態本機記憶體集區配置。</summary>
      <param name="codeSize" vsli:raw="The number of bytes to be reserved for instructions.">要為指令保留的位元組數目。</param>
      <param name="maxStack" vsli:raw="The maximum stack size.">堆疊大小上限。</param>
      <param name="exceptionRegionCount" vsli:raw="The number of exception regions.">例外狀況區域的數目。</param>
      <param name="hasSmallExceptionRegions" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the exception regions should be encoded in small format; &lt;see langword=&quot;false&quot; /&gt; otherwise.">如果例外狀況區域應該以小型格式編碼，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
      <param name="localVariablesSignature" vsli:raw="The local variables' signature handle.">區域變數的簽章控制代碼。</param>
      <param name="attributes" vsli:raw="The method body attributes.">方法主體屬性。</param>
      <param name="hasDynamicStackAllocation" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method allocates from the dynamic local memory pool (the &lt;see langword=&quot;localloc&quot; /&gt; instruction); &lt;see langword=&quot;false&quot; /&gt; otherwise.">如果方法是從動態本機記憶體集區配置 (包含 <see langword="true" /> 指令)，則為 <see langword="localloc" />；否則為 <see langword="false" />。</param>
      <returns vsli:raw="The offset of the encoded body within the method body stream.">已編碼主體在方法主體資料流中的位移。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary vsli:raw="Encodes a method body and adds it to the method body stream.">編碼方法主體，並將它新增到方法主體資料流。</summary>
      <param name="instructionEncoder" vsli:raw="The instruction encoder.">指令編碼器。</param>
      <param name="maxStack" vsli:raw="The maximum stack size.">堆疊大小上限。</param>
      <param name="localVariablesSignature" vsli:raw="The local variables' signature handle.">區域變數的簽章控制代碼。</param>
      <param name="attributes" vsli:raw="The method body attributes.">方法主體屬性。</param>
      <returns vsli:raw="The offset of the encoded body within the method body stream.">已編碼主體在方法主體資料流中的位移。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary vsli:raw="Encodes a method body and adds it to the method body stream, using the provided instruction encoder, maximum stack size, local variables' signature handle, method body attributes, and allowing to indicate whether the method should allocate from the dynamic local memory pool or not.">編碼方法主體並將它新增至方法主體資料流，使用提供的指令編碼器、最大堆疊大小、區域變數的簽章控制代碼、方法主體屬性，以及允許以指出方法是否應從動態本機記憶體集區配置。</summary>
      <param name="instructionEncoder" vsli:raw="The instruction encoder.">指令編碼器。</param>
      <param name="maxStack" vsli:raw="The maximum stack size.">堆疊大小上限。</param>
      <param name="localVariablesSignature" vsli:raw="The local variables' signature handle.">區域變數的簽章控制代碼。</param>
      <param name="attributes" vsli:raw="The method body attributes.">方法主體屬性。</param>
      <param name="hasDynamicStackAllocation" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method allocates from the dynamic local memory pool (the IL contains the &lt;see langword=&quot;localloc&quot; /&gt; instruction); &lt;see langword=&quot;false&quot; /&gt; otherwise.">如果方法是從動態本機記憶體集區配置 (IL 包含 <see langword="true" /> 指令)，則為 <see langword="localloc" />；否則為 <see langword="false" />。</param>
      <returns vsli:raw="The offset of the encoded body within the method body stream.">已編碼主體在方法主體資料流中的位移。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody">
      <summary vsli:raw="Describes a method body. This class is meant to used along with the &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder&quot; /&gt; class.">描述方法主體。 此類別的用意是要搭配 <see cref="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder" /> 類別使用。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.ExceptionRegions">
      <summary vsli:raw="Gets an encoder object that can be used to encode exception regions to the method body.">取得可用於將例外狀況區域編碼為方法主體的編碼器物件。</summary>
      <returns vsli:raw="An exception region encoder instance.">例外狀況區域編碼器實例。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Instructions">
      <summary vsli:raw="Gets a blob reserved for instructions.">取得為指令保留的 Blob。</summary>
      <returns vsli:raw="A blob reserved for instructions.">保留用於指示的 blob。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Offset">
      <summary vsli:raw="Gets the offset of the encoded method body in the method body stream.">取得方法主體資料流中已編碼方法主體的位移。</summary>
      <returns vsli:raw="The offset of the encoded method body in the method body stream.">方法主體資料流程中已編碼方法主體的位移。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder">
      <summary vsli:raw="Provides an encoder for method signatures.">提供方法簽章的編碼器。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" vsli:raw="" />
      <param name="hasVarArgs" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.HasVarArgs" />
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Action{System.Reflection.Metadata.Ecma335.ReturnTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ParametersEncoder})">
      <summary vsli:raw="Encodes the provided return type and parameters.">編碼所提供的傳回型別與參數。</summary>
      <param name="parameterCount" vsli:raw="The number of parameters.">參數的數目。</param>
      <param name="returnType" vsli:raw="The method that is called first to encode the return type.">第一個呼叫的方法，以編碼傳回型別。</param>
      <param name="parameters" vsli:raw="The method that is called second to encode the parameters.">第二個呼叫的方法，以編碼參數。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Reflection.Metadata.Ecma335.ReturnTypeEncoder@,System.Reflection.Metadata.Ecma335.ParametersEncoder@)">
      <summary vsli:raw="Encodes the provided return type and parameters, which must be used in the order they appear in the parameter list.">編碼所提供的傳回型別與參數，其必須依它們出現在參數清單中的順序來使用。</summary>
      <param name="parameterCount" vsli:raw="The number of parameters.">參數的數目。</param>
      <param name="returnType" vsli:raw="The method that is called first to encode the return types.">第一個呼叫的方法，以編碼傳回型別。</param>
      <param name="parameters" vsli:raw="The method that is called second to encode the parameters.">第二個呼叫的方法，以編碼參數。</param>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder&quot; /&gt; structure.">初始化 <see cref="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" /> 結構的新執行個體。</summary>
      <param name="builder" vsli:raw="A builder for encoding the named argument.">用來編碼具名引數的建立器。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Action{System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.NameEncoder},System.Action{System.Reflection.Metadata.Ecma335.LiteralEncoder})">
      <summary vsli:raw="Encodes a named argument (a field or property).">編碼具名引數 (欄位或屬性)。</summary>
      <param name="isField" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode a field, &lt;see langword=&quot;false&quot; /&gt; to encode a property.">
        <see langword="true" /> 以編碼欄位，<see langword="false" /> 以編碼屬性。</param>
      <param name="type" vsli:raw="The method to call first to encode the type of the argument.">要第一個呼叫的方法，以編碼引數類型。</param>
      <param name="name" vsli:raw="The method to call second to encode the name of the field or property.">第二個呼叫的方法，以編碼欄位或屬性的名稱。</param>
      <param name="literal" vsli:raw="The method to call third to encode the literal value of the argument.">第三個呼叫的方法，以編碼引數的常值數值。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder@,System.Reflection.Metadata.Ecma335.NameEncoder@,System.Reflection.Metadata.Ecma335.LiteralEncoder@)">
      <summary vsli:raw="Encodes a named argument (a field or property) and returns three encoders that must be used in the order they appear in the parameter list.">編碼具名引數 (欄位或屬性)，並傳回三個必須依它們出現在參數清單中之順序使用的編碼器。</summary>
      <param name="isField" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode a field, &lt;see langword=&quot;false&quot; /&gt; to encode a property.">
        <see langword="true" /> 以編碼欄位，<see langword="false" /> 以編碼屬性。</param>
      <param name="type" vsli:raw="The method to call first to encode the type of the argument.">要第一個呼叫的方法，以編碼引數類型。</param>
      <param name="name" vsli:raw="The method to call second to encode the name of the field or property.">第二個呼叫的方法，以編碼欄位或屬性的名稱。</param>
      <param name="literal" vsli:raw="The method to call third to encode the literal value of the argument.">第三個呼叫的方法，以編碼引數的常值數值。</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.ScalarType" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.SZArray" />
    <member name="T:System.Reflection.Metadata.Ecma335.NameEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NameEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.Name(System.String)">
      <param name="name" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ParametersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" vsli:raw="" />
      <param name="hasVarArgs" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.AddParameter" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.HasVarArgs" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.StartVarArgs" />
    <member name="T:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.TypedReference" />
    <member name="T:System.Reflection.Metadata.Ecma335.PermissionSetEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="typeName" vsli:raw="" />
      <param name="encodedArguments" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Reflection.Metadata.BlobBuilder)">
      <param name="typeName" vsli:raw="" />
      <param name="encodedArguments" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.PortablePdbBuilder">
      <summary vsli:raw="Represents the builder of a Portable PDB image.">代表可攜式 PDB 影像的建立器。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.Collections.Immutable.ImmutableArray{System.Int32},System.Reflection.Metadata.MethodDefinitionHandle,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <summary vsli:raw="Creates a builder of a Portable PDB image.">建立可攜式 PDB 映像的建立器。</summary>
      <param name="tablesAndHeaps" vsli:raw="A builder populated with debug metadata entities stored in tables and values stored in heaps. The entities and values are enumerated when serializing the Portable PDB image.">使用儲存在資料中的偵錯中繼資料實體和儲存在堆積中的值來填入的建立器。 序列化可攜式 PDB 映像時，會列舉實體與值。</param>
      <param name="typeSystemRowCounts" vsli:raw="The row counts of all tables that the associated type system metadata contain. Each slot in the array corresponds to a table (&lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.TableIndex&quot; /&gt;). The length of the array must be equal &lt;see cref=&quot;F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount&quot; /&gt;.">相關聯型別系統中繼資料包含之所有資料表的資料列計數。 陣列中的每個位置都會對應到一個資料表 (<see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" />)。 陣列的長度必須等於 <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" />。</param>
      <param name="entryPoint" vsli:raw="An entry point method definition handle.">進入點方法定義控制代碼。</param>
      <param name="idProvider" vsli:raw="A function that calculates the ID of content represented as a sequence of blobs. If not specified, a default function that ignores the content and returns a content ID based on the current time is used (&lt;see cref=&quot;M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider&quot; /&gt;). You must specify a deterministic function to produce a deterministic Portable PDB image.">計算內容 (以一系列 Blob 表示) 之識別碼的函式。 如果未指定，則為預設函式 (<see cref="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />)，它會忽略內容並傳回以目前時間為基礎的內容識別碼。 您必須指定決定性函數，以產生決定性可攜式 PDB 映像。</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.FormatVersion" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.IdProvider" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.MetadataVersion" />
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <summary vsli:raw="Serializes portable PDB content into the given &lt;see cref=&quot;T:System.Reflection.Metadata.BlobBuilder&quot; /&gt;.">將可攜式 PDB 內容序列化為指定的 <see cref="T:System.Reflection.Metadata.BlobBuilder" />。</summary>
      <param name="builder" vsli:raw="The builder to write to.">要寫入的建立器。</param>
      <returns vsli:raw="The ID of the serialized content.">序列化內容的識別碼。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.TypedReference" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Void" />
    <member name="T:System.Reflection.Metadata.Ecma335.ScalarEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ScalarEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.Constant(System.Object)">
      <summary vsli:raw="Encodes a constant literal.">編碼常數常值。</summary>
      <param name="value" vsli:raw="A constant of type &lt;see cref=&quot;T:System.Boolean&quot; /&gt;, &lt;see cref=&quot;T:System.Byte&quot; /&gt;, &lt;see cref=&quot;T:System.SByte&quot; /&gt;, &lt;see cref=&quot;T:System.Int16&quot; /&gt;, &lt;see cref=&quot;T:System.UInt16&quot; /&gt;, &lt;see cref=&quot;T:System.Int32&quot; /&gt;, &lt;see cref=&quot;T:System.UInt32&quot; /&gt;, &lt;see cref=&quot;T:System.Int64&quot; /&gt;, &lt;see cref=&quot;T:System.UInt64&quot; /&gt;, &lt;see cref=&quot;T:System.Single&quot; /&gt;, &lt;see cref=&quot;T:System.Double&quot; /&gt;, &lt;see cref=&quot;T:System.Char&quot; /&gt; (encoded as a two-byte Unicode character), &lt;see cref=&quot;T:System.String&quot; /&gt; (encoded as SerString), or &lt;see cref=&quot;T:System.Enum&quot; /&gt; (encoded as the underlying integer value).">常數，型別為 <see cref="T:System.Boolean" />、<see cref="T:System.Byte" />、<see cref="T:System.SByte" />、<see cref="T:System.Int16" />、<see cref="T:System.UInt16" />、<see cref="T:System.Int32" />、<see cref="T:System.UInt32" />、<see cref="T:System.Int64" />、<see cref="T:System.UInt64" />、<see cref="T:System.Single" />、<see cref="T:System.Double" />、<see cref="T:System.Char" /> (編碼為二位元組 Unicode 字元)、<see cref="T:System.String" /> (編碼為 SerString)、或 <see cref="T:System.Enum" /> (編碼為基礎整數值)。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.NullArray">
      <summary vsli:raw="Encodes a &lt;see langword=&quot;null&quot; /&gt; literal of type &lt;see cref=&quot;T:System.Array&quot; /&gt;.">編碼型別為 <see langword="null" /> 的 <see cref="T:System.Array" /> 常值。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.SystemType(System.String)">
      <summary vsli:raw="Encodes a literal of type &lt;see cref=&quot;T:System.Type&quot; /&gt; (which can possibly be &lt;see langword=&quot;null&quot; /&gt;).">編碼型別為 <see cref="T:System.Type" /> (可能為 <see langword="null" />) 的常值。</summary>
      <param name="serializedTypeName" vsli:raw="The name of the type, or &lt;see langword=&quot;null&quot; /&gt;.">型別的名稱，或 <see langword="null" />。</param>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2">
      <summary vsli:raw="Decodes signature blobs.">將簽章 Blob 解碼。</summary>
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.#ctor(System.Reflection.Metadata.ISignatureTypeProvider{`0,`1},System.Reflection.Metadata.MetadataReader,`1)">
      <summary vsli:raw="Creates a new &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2&quot; /&gt;.">建立新的 <see cref="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2" />。</summary>
      <param name="provider" vsli:raw="The provider used to obtain type symbols as the signature is decoded.">當簽章解碼時，用來取得型別符號的提供者。</param>
      <param name="metadataReader" vsli:raw="The metadata reader from which the signature was obtained. It may be &lt;see langword=&quot;null&quot; /&gt; if the given provider allows it.">從中取得簽章的中繼資料讀取器。 如果指定的提供者允許，它可以為 <see langword="null" />。</param>
      <param name="genericContext" vsli:raw="Additional context needed to resolve generic parameters.">需要其他內容來解析泛型參數。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeFieldSignature(System.Reflection.Metadata.BlobReader@)">
      <summary vsli:raw="Decodes a field signature blob and advances the reader past the signature.">將欄位簽章 Blob 解碼，並將讀取器前移經過簽章。</summary>
      <param name="blobReader" vsli:raw="The blob reader positioned at a field signature.">定位在欄位簽章的 Blob 讀取器。</param>
      <returns vsli:raw="The decoded field type.">已解碼的欄位類型。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeLocalSignature(System.Reflection.Metadata.BlobReader@)">
      <summary vsli:raw="Decodes a local variable signature blob and advances the reader past the signature.">將區域變數簽章 Blob 解碼，並將讀取器前移經過簽章。</summary>
      <param name="blobReader" vsli:raw="The blob reader positioned at a local variable signature.">定位在區域變數簽章的 Blob 讀取器。</param>
      <returns vsli:raw="The local variable types.">區域變數型別。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSignature(System.Reflection.Metadata.BlobReader@)">
      <summary vsli:raw="Decodes a method (definition, reference, or standalone) or a property signature blob.">將方法 (定義、參考或獨立) 或屬性簽章 Blob 解碼。</summary>
      <param name="blobReader" vsli:raw="A blob reader positioned at a method signature.">定位在方法簽章的 Blob 讀取器。</param>
      <returns vsli:raw="The decoded method signature.">已解碼的方法簽章。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSpecificationSignature(System.Reflection.Metadata.BlobReader@)">
      <summary vsli:raw="Decodes a method specification signature blob and advances the reader past the signature.">將方法規格簽章 Blob 解碼，並將讀取器前移經過簽章。</summary>
      <param name="blobReader" vsli:raw="A blob reader positioned at a valid method specification signature.">定位在有效方法規格簽章的 Blob 讀取器。</param>
      <returns vsli:raw="The types used to instantiate a generic method via the method specification.">用來透過方法規格將泛型方法具現化的型別。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeType(System.Reflection.Metadata.BlobReader@,System.Boolean)">
      <summary vsli:raw="Decodes a type embedded in a signature and advances the reader past the type.">將內嵌在簽章中的型別解碼，並將讀取器前移經過類型。</summary>
      <param name="blobReader" vsli:raw="The blob reader positioned at the leading &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureTypeCode&quot; /&gt;.">定位在前置 <see cref="T:System.Reflection.Metadata.SignatureTypeCode" /> 的 Blob 讀取器。</param>
      <param name="allowTypeSpecifications" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to allow a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt; to follow a (CLASS | VALUETYPE) in the signature; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> 允許 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> 遵循簽章中的 (CLASS | VALUETYPE)；否則為 <see langword="false" />。</param>
      <returns vsli:raw="The decoded type.">已解碼的型別。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Metadata.BlobBuilder&quot; /&gt; where the signature will be written." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Action{System.Reflection.Metadata.Ecma335.SignatureTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ArrayShapeEncoder})">
      <summary vsli:raw="Encodes an array type.">編碼陣列型別。</summary>
      <param name="elementType" vsli:raw="Called first, to encode the type of the element.">第一個呼叫，以編碼元素的型別。</param>
      <param name="arrayShape" vsli:raw="Called second, to encode the shape of the array.">第二個呼叫，以編碼陣列的形狀。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Reflection.Metadata.Ecma335.SignatureTypeEncoder@,System.Reflection.Metadata.Ecma335.ArrayShapeEncoder@)">
      <summary vsli:raw="Encodes an array type. Returns a pair of encoders that must be used in the order they appear in the parameter list.">編碼陣列型別。 傳回一對編碼器，必須依它們出現在參數清單中的順序來使用。</summary>
      <param name="elementType" vsli:raw="Use first, to encode the type of the element.">第一個使用，以編碼元素的型別。</param>
      <param name="arrayShape" vsli:raw="Use second, to encode the shape of the array.">第二個使用，以編碼陣列的形狀。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Boolean" />
    <member name="P:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.CustomModifiers">
      <summary vsli:raw="Starts a signature of a type with custom modifiers.">啟動使用自訂修飾元的型別簽章。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.FunctionPointer(System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.Ecma335.FunctionPointerAttributes,System.Int32)">
      <summary vsli:raw="Starts a function pointer signature.">啟動函式指標簽章。</summary>
      <param name="convention" vsli:raw="Calling convention.">呼叫慣例。</param>
      <param name="attributes" vsli:raw="Function pointer attributes.">函式指標屬性。</param>
      <param name="genericParameterCount" vsli:raw="Generic parameter count.">泛型參數計數。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericInstantiation(System.Reflection.Metadata.EntityHandle,System.Int32,System.Boolean)">
      <summary vsli:raw="Starts a generic instantiation signature.">啟動泛型具現化簽章。</summary>
      <param name="genericType" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />。</param>
      <param name="genericArgumentCount" vsli:raw="Generic argument count.">泛型引數計數。</param>
      <param name="isValueType" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to mark the type as value type, &lt;see langword=&quot;false&quot; /&gt; to mark it as a reference type in the signature.">
        <see langword="true" /> 以將型別標示為實值型別，<see langword="false" /> 以將它在簽章中標記為參考型別。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericMethodTypeParameter(System.Int32)">
      <summary vsli:raw="Encodes a reference to type parameter of a containing generic method.">編碼所含泛型方法的型別參數參考。</summary>
      <param name="parameterIndex" vsli:raw="Parameter index.">參數索引。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericTypeParameter(System.Int32)">
      <summary vsli:raw="Encodes a reference to type parameter of a containing generic type.">編碼所含泛型型別的型別參數參考。</summary>
      <param name="parameterIndex" vsli:raw="Parameter index.">參數索引。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.IntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Pointer">
      <summary vsli:raw="Starts pointer signature.">啟動指標簽章。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary vsli:raw="Writes primitive type code.">寫入簡單型別代碼。</summary>
      <param name="type" vsli:raw="Any primitive type code except for &lt;see cref=&quot;F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference&quot; /&gt; and &lt;see cref=&quot;F:System.Reflection.Metadata.PrimitiveTypeCode.Void&quot; /&gt;.">除了 <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference" /> 與 <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.Void" /> 之外的任何簡單型別代碼。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SZArray">
      <summary vsli:raw="Starts SZ array (vector) signature.">啟動 SZ 陣列 (向量) 簽章。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Type(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <summary vsli:raw="Encodes a reference to a type.">編碼型別的參考。</summary>
      <param name="type" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />。</param>
      <param name="isValueType" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to mark the type as value type, &lt;see langword=&quot;false&quot; /&gt; to mark it as a reference type in the signature.">
        <see langword="true" /> 以將型別標示為實值型別，<see langword="false" /> 以將它在簽章中標記為參考型別。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UIntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.VoidPointer">
      <summary vsli:raw="Encodes a void pointer (&lt;c&gt;void*&lt;/c&gt;).">編碼 Void 指標 (void*) 來存取它所儲存的值。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.TableIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Assembly" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ClassLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Constant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.DeclSecurity" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Document" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncLog" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Event" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ExportedType" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Field" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldMarshal" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldRva" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.File" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParam" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParamConstraint" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImplMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImportScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.InterfaceImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalConstant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalVariable" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ManifestResource" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MemberRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSemantics" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSpec" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Module" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ModuleRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.NestedClass" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Param" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ParamPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Property" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StandAloneSig" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StateMachineMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeSpec" />
    <member name="T:System.Reflection.Metadata.Ecma335.VectorEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.VectorEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.Count(System.Int32)">
      <param name="count" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.EntityHandle">
      <summary vsli:raw="Represents a metadata entity (such as a type reference, type definition, type specification, method definition, or custom attribute).">表示中繼資料實體 (例如類型參考、類型定義、類型規格、方法定義或自訂屬性)。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.EntityHandle.AssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Object)">
      <summary vsli:raw="Returns a value that indicates whether the current instance and the specified object are equal.">傳回值，指出目前執行個體與指定的物件是否相等。</summary>
      <param name="obj" vsli:raw="The object to compare with the current instance.">要與目前執行個體比較的物件。</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is an &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; and is equal to the current instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">如果 <paramref name="obj" /> 是 <see cref="T:System.Reflection.Metadata.EntityHandle" /> 且等於目前的執行個體，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Returns a value that indicates whether the current instance and the specified &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; are equal.">傳回值，指出目前的執行個體與指定的 <see cref="T:System.Reflection.Metadata.EntityHandle" /> 是否相等。</summary>
      <param name="other" vsli:raw="The value to compare with the current instance.">要與目前執行個體比較的值。</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current instance and &lt;paramref name=&quot;other&quot; /&gt; are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">如果目前的執行個體和 <paramref name="other" /> 相等則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.GetHashCode">
      <summary vsli:raw="Returns the hash code for this instance.">傳回這個執行個體的雜湊碼。</summary>
      <returns vsli:raw="The hash code for this instance.">這個執行個體的雜湊碼。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.EntityHandle.IsNil" />
    <member name="P:System.Reflection.Metadata.EntityHandle.Kind" />
    <member name="F:System.Reflection.Metadata.EntityHandle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Equality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Implicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Inequality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.EventAccessors" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Adder" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Others" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Raiser" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Remover" />
    <member name="T:System.Reflection.Metadata.EventDefinition" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Attributes" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Name" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Type" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.EventDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Equality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Inequality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection" />
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#EventDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ExceptionRegion" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.CatchType">
      <summary vsli:raw="Gets a TypeRef, TypeDef, or TypeSpec handle if the region represents a catch, or a nil token otherwise (&lt;see langword=&quot;default&quot; /&gt;(&lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt;)).">如果區域表示 Catch 取得 TypeRef、TypeDef 或 TypeSpec 控制代碼，如果是其他狀況則取得 nil 語彙基元 (<see langword="default" />(<see cref="T:System.Reflection.Metadata.EntityHandle" />))。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.FilterOffset">
      <summary vsli:raw="Gets the IL offset of the start of the filter block, or -1 if the region is not a filter.">取得篩選條件區塊開頭的 IL 位移，如果該區域不是篩選條件，則為 -1。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerLength">
      <summary vsli:raw="Gets the length in bytes of the exception handler.">取得例外狀況處理常式的長度，以位元組為單位。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerOffset">
      <summary vsli:raw="Gets the starting IL offset of the exception handler.">取得例外狀況處理常式的起始 IL 位移。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.Kind" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryLength">
      <summary vsli:raw="Gets the length in bytes of the try block.">取得 try 區塊的長度，以位元組為單位。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryOffset">
      <summary vsli:raw="Gets the starting IL offset of the try block.">取得 try 區塊的起始 IL 長度。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExceptionRegionKind" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Catch" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Fault" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Filter" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Finally" />
    <member name="T:System.Reflection.Metadata.ExportedType" />
    <member name="P:System.Reflection.Metadata.ExportedType.Attributes" />
    <member name="M:System.Reflection.Metadata.ExportedType.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ExportedType.Implementation">
      <summary vsli:raw="Gets a handle to resolve the implementation of the target type.">取得控制代碼，以解析目標型別的實作。</summary>
      <returns vsli:raw="&lt;list type=&quot;bullet&quot;&gt;&lt;item&gt;&lt;description&gt;&lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt; representing another module in the assembly.&lt;/description&gt;&lt;/item&gt;&lt;item&gt;&lt;description&gt;&lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt; representing another assembly if &lt;see cref=&quot;P:System.Reflection.Metadata.ExportedType.IsForwarder&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.&lt;/description&gt;&lt;/item&gt;&lt;item&gt;&lt;description&gt;&lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt; representing the declaring exported type in which this was is nested.&lt;/description&gt;&lt;/item&gt;&lt;/list&gt;">
        <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />表示元件中的另一個模組。
<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />如果<see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder" />為，則<see langword="true" />表示另一個元件。
<see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />，代表宣告匯出的類型，其中會將這個的嵌套在其中。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.IsForwarder" />
    <member name="P:System.Reflection.Metadata.ExportedType.Name">
      <summary vsli:raw="Gets the name of the target type, or &lt;see langword=&quot;default&quot; /&gt; if the type is nested or defined in a root namespace.">取得目標型別的名稱，如果型別是巢狀的或定義在根命名空間中，則為 <see langword="default" />。</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.StringHandle&quot; /&gt; struct instance.">
        <see cref="T:System.Reflection.Metadata.StringHandle" />結構實例。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.Namespace">
      <summary vsli:raw="Gets the full name of the namespace that contains the target type, or &lt;see langword=&quot;default&quot; /&gt; if the type is nested or defined in a root namespace.">取得包含目標型別之命名空間的完整名稱，如果型別是巢狀的或定義在根命名空間中，則為 <see langword="default" />。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.NamespaceDefinition">
      <summary vsli:raw="Gets the definition handle of the namespace where the target type is defined, or &lt;see langword=&quot;default&quot; /&gt; if the type is nested or defined in a root namespace.">取得目標型別所定義在之命名空間的定義控制代碼，如果型別是巢狀的或定義在根命名空間中，則為 <see langword="default" />。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandle" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ExportedTypeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Equality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Inequality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection">
      <summary vsli:raw="Represents a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; instances.">表示 <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 執行個體的集合。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ExportedTypeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.FieldDefinition" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Attributes" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetMarshallingDescriptor" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetOffset">
      <summary vsli:raw="Returns the field layout offset, or -1 if it is not available.">傳回欄位配置位移；如果未提供則為 -1。</summary>
      <returns vsli:raw="The field definition offset, or -1 if it is not available.">欄位定義位移；如果未提供則為 -1。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetRelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Name" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Equality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Inequality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection" />
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#FieldDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.GenericParameter" />
    <member name="P:System.Reflection.Metadata.GenericParameter.Attributes">
      <summary vsli:raw="Gets the attributes specifying variance and constraints.">取得指定變異數和條件約束的屬性。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameter.GetConstraints" />
    <member name="M:System.Reflection.Metadata.GenericParameter.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameter.Index">
      <summary vsli:raw="Gets the zero-based index of the parameter within the declaring generic type or method declaration.">取得宣告的泛型型別或方法宣告內參數之以零為起始的索引。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Name">
      <summary vsli:raw="Gets the name of the generic parameter.">取得泛型參數的名稱。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Parent">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; that represents the parent of this generic parameter.">取得 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />，代表此泛型參數的父代。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraint" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraint.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Parameter">
      <summary vsli:raw="Gets the constrained &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterHandle&quot; /&gt;.">取得受限制的 <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Type">
      <summary vsli:raw="Gets a handle (&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;) &#xA;            specifying from which type this generic parameter is constrained to derive,&#xA;            or which interface this generic parameter is constrained to implement.">取得控制代碼 (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />)，指定此泛型參數從中限制為衍生的型別，或此泛型參數從中限制為實作的介面。</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; instance.">
        <see cref="T:System.Reflection.Metadata.EntityHandle" /> 執行個體。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Equality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Inequality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection">
      <summary vsli:raw="Represents a collection of constraints of a generic type parameter.">表示泛型型別參數條件約束的集合。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.GetEnumerator" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Item(System.Int32)">
      <param name="index" vsli:raw="The zero-based index of the element to get." />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterConstraintHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.GenericParameterHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Reflection.Metadata.GenericParameterHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.GenericParameterHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Equality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Inequality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection">
      <summary vsli:raw="Represents a collection of generic type parameters of a method or type.">表示方法或類型的泛型型別參數集合。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.GetEnumerator" />
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Item(System.Int32)">
      <param name="index" vsli:raw="The zero-based index of the element to get." />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.GuidHandle" />
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Reflection.Metadata.GuidHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.GuidHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Equality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GuidHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Implicit(System.Reflection.Metadata.GuidHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Inequality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Handle">
      <summary vsli:raw="Represents any metadata entity (such as a type reference, a type definition, a type specification, a method definition, or a custom attribute) or value (a string, blob, guid, or user string).">表示任何中繼資料實體 (例如類型參考、類型定義、類型規格、方法定義或自訂屬性) 或值 (字串、Blob、guid 或使用者字串)。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Handle.AssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Reflection.Metadata.Handle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Handle.IsNil" />
    <member name="P:System.Reflection.Metadata.Handle.Kind" />
    <member name="F:System.Reflection.Metadata.Handle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.Handle.op_Equality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.op_Inequality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.HandleComparer" />
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Compares two entity handles.">比較兩個實體控制代碼。</summary>
      <param name="x" vsli:raw="The first entity handle to compare.">要比較的第一個實體控制代碼。</param>
      <param name="y" vsli:raw="The second entity handle to compare.">要比較的第二個實體控制代碼。</param>
      <returns vsli:raw="Zero if the two entity handles are equal, and a non-zero value of they are not.">若兩個實體控制代碼相等，則為零；若它們不相等，則為非零值。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Compares two handles.">比較兩個控制代碼。</summary>
      <param name="x" vsli:raw="The first handle to compare.">要比較的第一個控制代碼。</param>
      <param name="y" vsli:raw="The second handle to compare.">要比較的第二個控制代碼。</param>
      <returns vsli:raw="Zero if the two handles are equal, and a non-zero value if they are not.">若兩個控制代碼相等，則為零；若它們不相等，則為非零值。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.HandleComparer.Default" />
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="x" vsli:raw="The first object of type &lt;paramref name=&quot;T&quot; /&gt; to compare." />
      <param name="y" vsli:raw="The second object of type &lt;paramref name=&quot;T&quot; /&gt; to compare." />
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="x" vsli:raw="The first object of type &lt;paramref name=&quot;T&quot; /&gt; to compare." />
      <param name="y" vsli:raw="The second object of type &lt;paramref name=&quot;T&quot; /&gt; to compare." />
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.EntityHandle)">
      <param name="obj" vsli:raw="The &lt;see cref=&quot;T:System.Object&quot; /&gt; for which a hash code is to be returned." />
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.Handle)">
      <param name="obj" vsli:raw="The &lt;see cref=&quot;T:System.Object&quot; /&gt; for which a hash code is to be returned." />
    </member>
    <member name="T:System.Reflection.Metadata.HandleKind" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyFile" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.Blob" />
    <member name="F:System.Reflection.Metadata.HandleKind.Constant" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.DeclarativeSecurityAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.Document" />
    <member name="F:System.Reflection.Metadata.HandleKind.EventDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ExportedType" />
    <member name="F:System.Reflection.Metadata.HandleKind.FieldDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameterConstraint" />
    <member name="F:System.Reflection.Metadata.HandleKind.Guid" />
    <member name="F:System.Reflection.Metadata.HandleKind.ImportScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.InterfaceImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalConstant" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalVariable" />
    <member name="F:System.Reflection.Metadata.HandleKind.ManifestResource" />
    <member name="F:System.Reflection.Metadata.HandleKind.MemberReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.NamespaceDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.Parameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.PropertyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.StandaloneSignature" />
    <member name="F:System.Reflection.Metadata.HandleKind.String" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.UserString" />
    <member name="T:System.Reflection.Metadata.IConstructedTypeProvider`1">
      <typeparam name="TType" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetArrayType(`0,System.Reflection.Metadata.ArrayShape)">
      <summary vsli:raw="Gets the type symbol for a generalized array of the given element type and shape.">取得指定項目型別和圖形之一般化陣列的型別符號。</summary>
      <param name="elementType" vsli:raw="The type of the elements in the array.">陣列中項目的型別。</param>
      <param name="shape" vsli:raw="The shape (rank, sizes, and lower bounds) of the array.">陣列的圖形 (順位、大小及下限)。</param>
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetByReferenceType(`0)">
      <summary vsli:raw="Gets the type symbol for a managed pointer to the given element type.">取得指定項目型別的受控指標型別符號。</summary>
      <param name="elementType" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetGenericInstantiation(`0,System.Collections.Immutable.ImmutableArray{`0})">
      <summary vsli:raw="Gets the type symbol for a generic instantiation of the given generic type with the given type arguments.">取得指定泛型型別的泛型具現化型別符號，其具有指定的型別引數。</summary>
      <param name="genericType" vsli:raw="" />
      <param name="typeArguments" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetPointerType(`0)">
      <summary vsli:raw="Gets the type symbol for an unmanaged pointer to the given element type.">取得指定項目型別的非受控指標型別符號。</summary>
      <param name="elementType" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.ICustomAttributeTypeProvider`1">
      <typeparam name="TType" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetSystemType">
      <summary vsli:raw="Gets the &lt;typeparamref name=&quot;TType&quot; /&gt; representation for &lt;see cref=&quot;T:System.Type&quot; /&gt;.">取得 <typeparamref name="TType" /> 的 <see cref="T:System.Type" /> 表示。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetTypeFromSerializedName(System.String)">
      <summary vsli:raw="Gets the type symbol for the given serialized type name.">取得指定序列化型別名稱的型別符號。</summary>
      <param name="name" vsli:raw="The serialized type name in so-called &quot;reflection notation&quot; format (as understood by the &lt;see cref=&quot;M:System.Type.GetType(System.String)&quot; /&gt; method.)">使用稱為「反映標記法」格式的序列化型別名稱 (<see cref="M:System.Type.GetType(System.String)" /> 方法可以辨識。)</param>
      <returns vsli:raw="A &lt;typeparamref name=&quot;TType&quot; /&gt; instance.">
        <typeparamref name="TType" /> 執行個體。</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The name is malformed.">名稱的格式不正確。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetUnderlyingEnumType(`0)">
      <summary vsli:raw="Gets the underlying type of the given enum type symbol.">取得指定列舉型別符號的基礎型別。</summary>
      <param name="type" vsli:raw="An enum type.">列舉型別。</param>
      <returns vsli:raw="A type code that indicates the underlying type of the enumeration.">表示基礎列舉型別的型別程式碼。</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The given type symbol does not represent an enum.">指定的型別符號不代表列舉。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.IsSystemType(`0)">
      <summary vsli:raw="Verifies if the given type represents &lt;see cref=&quot;T:System.Type&quot; /&gt;.">驗證指定的型別是否代表 <see cref="T:System.Type" />。</summary>
      <param name="type" vsli:raw="The type to verify.">要驗證的型別。</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the given type is a &lt;see cref=&quot;T:System.Type&quot; /&gt;, &lt;see langword=&quot;false&quot; /&gt; otherwise.">若指定的型別是 <see langword="true" />，則為 <see cref="T:System.Type" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ILOpCode" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.And" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Arglist" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Box" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Break" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Call" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Calli" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Callvirt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Castclass" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ceq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ckfinite" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Constrained" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Dup" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfilter" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfinally" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Isinst" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Jmp" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_5" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_6" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_7" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_m1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelema" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldlen" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldnull" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldstr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldtoken" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldvirtftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Localloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mkrefany" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Neg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newarr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Nop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Not" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Or" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Pop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Readonly" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanytype" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanyval" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ret" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rethrow" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shl" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sizeof" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Switch" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Tail" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Throw" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unaligned" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox_any" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Volatile" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Xor" />
    <member name="T:System.Reflection.Metadata.ILOpCodeExtensions" />
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetBranchOperandSize(System.Reflection.Metadata.ILOpCode)">
      <summary vsli:raw="Calculates the size of the specified branch instruction operand.">計算指定分支指令運算元的大小。</summary>
      <param name="opCode" vsli:raw="The branch op-code.">分支作業碼。</param>
      <returns vsli:raw="1 if &lt;paramref name=&quot;opCode&quot; /&gt; is a short branch, or 4 if it is a long branch.">如果 <paramref name="opCode" /> 是簡短分支，則為 1；如果是完整分支，則為 4。</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The specified &lt;paramref name=&quot;opCode&quot; /&gt; is not a branch op-code.">指定的 <paramref name="opCode" /> 不是分支作業碼。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetLongBranch(System.Reflection.Metadata.ILOpCode)">
      <summary vsli:raw="Gets a long form of the specified branch op-code.">取得指定分支作業碼的完整形式。</summary>
      <param name="opCode" vsli:raw="The branch op-code.">分支作業碼。</param>
      <returns vsli:raw="The long form of the branch op-code.">分支作業碼的完整形式。</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The specified &lt;paramref name=&quot;opCode&quot; /&gt; is not a branch op-code.">指定的 <paramref name="opCode" /> 不是分支作業碼。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetShortBranch(System.Reflection.Metadata.ILOpCode)">
      <summary vsli:raw="Gets a short form of the specified branch op-code.">取得指定分支作業碼的簡短形式。</summary>
      <param name="opCode" vsli:raw="The branch op-code.">分支作業碼。</param>
      <returns vsli:raw="The short form of the branch op-code.">分支作業碼的簡短形式。</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The specified &lt;paramref name=&quot;opCode&quot; /&gt; is not a branch op-code.">指定的 <paramref name="opCode" /> 不是分支作業碼。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.IsBranch(System.Reflection.Metadata.ILOpCode)">
      <summary vsli:raw="Verifies if the specified op-code is a branch to a label.">驗證所指定作業碼是否為標籤的分支。</summary>
      <param name="opCode" vsli:raw="" />
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the specified op-code is a branch to a label, &lt;see langword=&quot;false&quot; /&gt; otherwise.">若所指定作業碼是標籤的分支，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImageFormatLimitationException">
      <summary vsli:raw="The exception that is thrown when an attempt to write metadata exceeds a limit given by the format specification. For example, when the heap size limit is exceeded.">嘗試寫入中繼資料時所擲回的例外狀況，超過格式規格所指定的限制。 例如，超過堆積大小限制時。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.ImageFormatLimitationException&quot; /&gt; class.">初始化 <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> 類別的新執行個體。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.ImageFormatLimitationException&quot; /&gt; class with serialized data.">使用序列化資料，初始化 <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> 類別的新執行個體。</summary>
      <param name="info" vsli:raw="The object that holds the serialized object data.">存放序列物件資料的物件。</param>
      <param name="context" vsli:raw="The contextual information about the source or destination.">關於來源或目的端的內容資訊。</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.ImageFormatLimitationException&quot; /&gt; class with a specified error message.">使用指定的錯誤訊息，初始化 <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> 類別的新執行個體。</summary>
      <param name="message" vsli:raw="The error message that explains the reason for this exception.">解釋這個例外狀況原因的錯誤訊息。</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.ImageFormatLimitationException&quot; /&gt; class with a specified error message and the exception that is the cause of this exception.">使用指定的錯誤訊息和造成這個例外狀況的例外狀況，初始化 <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> 類別的新執行個體。</summary>
      <param name="message" vsli:raw="The error message that explains the reason for this exception.">解釋這個例外狀況原因的錯誤訊息。</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception, or &lt;see langword=&quot;null&quot; /&gt; if no inner exception is specified.">導致目前例外狀況發生的例外狀況；如果沒有指定任何的內部例外狀況，則為 <see langword="null" />。</param>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinition" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Alias" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Kind" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetAssembly" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetNamespace" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetType" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.MoveNext">
      <exception cref="T:System.BadImageFormatException" vsli:raw="Invalid blob format.">無效的 Blob 格式。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Reset" />
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportDefinition}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionKind" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyReference" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyReferenceAlias" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportXmlNamespace" />
    <member name="T:System.Reflection.Metadata.ImportScope">
      <summary vsli:raw="Provides information about the lexical scope within which a group of imports are available. This information is stored in debug metadata.">提供可在該詞彙範圍中進行一組匯入的相關資訊。 此資訊儲存在偵錯中繼資料中。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScope.GetImports" />
    <member name="P:System.Reflection.Metadata.ImportScope.ImportsBlob" />
    <member name="P:System.Reflection.Metadata.ImportScope.Parent" />
    <member name="T:System.Reflection.Metadata.ImportScopeCollection" />
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Count" />
    <member name="T:System.Reflection.Metadata.ImportScopeCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportScopeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ImportScopeHandle" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Reflection.Metadata.ImportScopeHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ImportScopeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Equality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Inequality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementation" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementation.Interface">
      <summary vsli:raw="Gets the interface that is implemented (&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;).">取得實作的介面 (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />)。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandle" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Equality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Inequality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#InterfaceImplementationHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ISignatureTypeProvider`2">
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetFunctionPointerType(System.Reflection.Metadata.MethodSignature{`0})">
      <summary vsli:raw="Gets the type symbol for the function pointer type of the given method &lt;paramref name=&quot;signature&quot; /&gt;.">取得指定方法 <paramref name="signature" /> 函式指標類型的類型符號。</summary>
      <param name="signature" vsli:raw="" />
      <returns vsli:raw="The type symbol for the function pointer type.">函式指標類型的類型符號。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericMethodParameter(`1,System.Int32)">
      <summary vsli:raw="Gets the type symbol for the generic method parameter at the given zero-based &lt;paramref name=&quot;index&quot; /&gt;.">取得泛型方法參數 (位於指定以零起始的 <paramref name="index" />) 的類型符號。</summary>
      <param name="genericContext" vsli:raw="" />
      <param name="index" vsli:raw="" />
      <returns vsli:raw="The type symbol for the generic method parameter at &lt;paramref name=&quot;index&quot; /&gt;.">泛型方法方法參數 (位於 <paramref name="index" />) 的類型符號。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericTypeParameter(`1,System.Int32)">
      <summary vsli:raw="Gets the type symbol for the generic type parameter at the given zero-based &lt;paramref name=&quot;index&quot; /&gt;.">取得泛型方法參數 (位於指定以零起始的 <paramref name="index" />) 的類型符號。</summary>
      <param name="genericContext" vsli:raw="" />
      <param name="index" vsli:raw="" />
      <returns vsli:raw="The type symbol for the generic type parameter at the given zero-based &lt;paramref name=&quot;index&quot; /&gt;.">泛型方法參數 (位於指定以零起始的 <paramref name="index" />) 的類型符號。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetModifiedType(`0,`0,System.Boolean)">
      <summary vsli:raw="Gets the type symbol for a type with a custom modifier applied.">取得已套用自訂修飾詞的類型之類型符號。</summary>
      <param name="modifier" vsli:raw="The modifier type applied.">已套用修飾詞類型。</param>
      <param name="unmodifiedType" vsli:raw="The type symbol of the underlying type without modifiers applied.">未套用修飾詞的基礎類型之類型符號。</param>
      <param name="isRequired" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the modifier is required, &lt;see langword=&quot;false&quot; /&gt; if it's optional.">若需要修飾詞則為 <see langword="true" />，若為選用項目則為 <see langword="false" />。</param>
      <returns vsli:raw="The type symbol.">類型符號。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetPinnedType(`0)">
      <summary vsli:raw="Gets the type symbol for a local variable type that is marked as pinned.">取得已標記為固定的本機變數類型之類型符號。</summary>
      <param name="elementType" vsli:raw="" />
      <returns vsli:raw="The type symbol for the local variable type.">本機變數類型的類型符號。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetTypeFromSpecification(System.Reflection.Metadata.MetadataReader,`1,System.Reflection.Metadata.TypeSpecificationHandle,System.Byte)">
      <summary vsli:raw="Gets the type symbol for a type specification.">取得類型規格的類型符號。</summary>
      <param name="reader" vsli:raw="The metadata reader that was passed to the signature decoder. It may be &lt;see langword=&quot;null&quot; /&gt;.">已傳遞至簽章解碼器的中繼資料讀取器。 可以是 <see langword="null" />。</param>
      <param name="genericContext" vsli:raw="The context that was passed to the signature decoder.">已傳遞至簽章解碼器的內容。</param>
      <param name="handle" vsli:raw="The type specification handle.">類型規格控點。</param>
      <param name="rawTypeKind" vsli:raw="The kind of the type, as specified in the signature. To interpret this value, use &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)&quot; /&gt;.">簽章中所指定的類型種類。 若要解譯此值，請使用 <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />。</param>
      <returns vsli:raw="The type symbol for the type specification.">類型規格的類型符號。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISimpleTypeProvider`1">
      <typeparam name="TType" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetPrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary vsli:raw="Gets the type symbol for a primitive type.">取得基本類型的類型符號。</summary>
      <param name="typeCode" vsli:raw="" />
      <returns vsli:raw="The type symbol for &lt;paramref name=&quot;typeCode&quot; /&gt;.">以下項目的類型符號： <param name="typeCode" />執行個體時提供 SQL Server 登入。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromDefinition(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeDefinitionHandle,System.Byte)">
      <summary vsli:raw="Gets the type symbol for a type definition.">取得類型定義的類型符號。</summary>
      <param name="reader" vsli:raw="The metadata reader that was passed to the signature decoder. It may be &lt;see langword=&quot;null&quot; /&gt;.">已傳遞至簽章解碼器的中繼資料讀取器。 可以是 <see langword="null" />。</param>
      <param name="handle" vsli:raw="The type definition handle.">類型定義控點。</param>
      <param name="rawTypeKind" vsli:raw="The kind of the type, as specified in the signature. To interpret this value use &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)&quot; /&gt;.">簽章中所指定的類型種類。 若要解譯此值，請使用 <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />。</param>
      <returns vsli:raw="The type symbol.">類型符號。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromReference(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeReferenceHandle,System.Byte)">
      <summary vsli:raw="Gets the type symbol for a type reference.">取得類型參考的類型符號。</summary>
      <param name="reader" vsli:raw="The metadata reader that was passed to the signature decoder. It may be &lt;see langword=&quot;null&quot; /&gt;.">已傳遞至簽章解碼器的中繼資料讀取器。 可以是 <see langword="null" />。</param>
      <param name="handle" vsli:raw="The type definition handle.">類型定義控點。</param>
      <param name="rawTypeKind" vsli:raw="The kind of the type as specified in the signature. To interpret this value, use &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)&quot; /&gt;.">簽章中所指定的類型種類。 若要解譯此值，請使用 <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />。</param>
      <returns vsli:raw="The type symbol.">類型符號。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISZArrayTypeProvider`1">
      <typeparam name="TType" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ISZArrayTypeProvider`1.GetSZArrayType(`0)">
      <summary vsli:raw="Gets the type symbol for a single-dimensional array of the given element type with a lower bounds of zero.">取得指定項目型別之一維陣列的型別符號，其下限為零。</summary>
      <param name="elementType" vsli:raw="" />
      <returns vsli:raw="A &lt;typeparamref name=&quot;TType&quot; /&gt; instance.">
        <typeparamref name="TType" /> 執行個體。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstant">
      <summary vsli:raw="Provides information about local constants. This information is stored in debug metadata.">提供區域常數的相關資訊。 此資訊儲存在偵錯中繼資料中。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstant.Name" />
    <member name="P:System.Reflection.Metadata.LocalConstant.Signature">
      <summary vsli:raw="Gets the constant signature.">取得常數簽章。</summary>
      <returns vsli:raw="The constant signature.">常數簽章。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandle" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Reflection.Metadata.LocalConstantHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.LocalConstantHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Equality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Inequality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection" />
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalConstantHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.LocalScope">
      <summary vsli:raw="Provides information about the scope of local variables and constants. This information is stored in debug metadata.">提供本機變數和常數範圍的相關資訊。 此資訊儲存在偵錯中繼資料中。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScope.EndOffset" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetChildren" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalConstants" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalVariables" />
    <member name="P:System.Reflection.Metadata.LocalScope.ImportScope" />
    <member name="P:System.Reflection.Metadata.LocalScope.Length" />
    <member name="P:System.Reflection.Metadata.LocalScope.Method" />
    <member name="P:System.Reflection.Metadata.LocalScope.StartOffset" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandle" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Reflection.Metadata.LocalScopeHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Equality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Inequality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.Current" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#IDisposable#Dispose" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalScopeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.LocalVariable">
      <summary vsli:raw="Provides information about local variables. This information is stored in debug metadata.">提供區域變數的相關資訊。 此資訊儲存在偵錯中繼資料中。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariable.Attributes" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Index" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Name" />
    <member name="T:System.Reflection.Metadata.LocalVariableAttributes" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.DebuggerHidden" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.None" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandle" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Reflection.Metadata.LocalVariableHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.LocalVariableHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Equality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Inequality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection" />
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalVariableHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ManifestResource" />
    <member name="P:System.Reflection.Metadata.ManifestResource.Attributes">
      <summary vsli:raw="Gets the manifest resource attributes.">取得資訊清單資源的屬性。</summary>
      <returns vsli:raw="A bitwise combination of the enumeration values that specify the manifest resource attributes.">指定資訊清單資源屬性的列舉值的位元組合。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResource.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ManifestResource.Implementation">
      <summary vsli:raw="Gets the implementation entity handle.">取得實作實體控制代碼。</summary>
      <returns vsli:raw="An EntityHandle instance. If the &lt;see cref=&quot;P:System.Reflection.Metadata.EntityHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, the returned handle will have default values.">EntityHandle 實例。 如果 <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> 屬性為 <see langword="true" />，則傳回的控制碼會有預設值。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Name">
      <summary vsli:raw="Gets the resource name.">取得資源名稱。</summary>
      <returns vsli:raw="The resource name.">資源名稱。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Offset">
      <summary vsli:raw="Gets the byte offset within the referenced file at which this resource record begins.">取得此資源記錄在參考檔案檔案中，從其開始處的位元組位移。</summary>
      <returns vsli:raw="The byte offset within the referenced file at which this resource record begins.">此資源記錄開始的參考檔案內的位元組位移。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandle" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ManifestResourceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Equality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Inequality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection">
      <summary vsli:raw="Represents a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.ManifestResourceHandle&quot; /&gt; instances.">表示 <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" /> 執行個體的集合。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ManifestResourceHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MemberReference" />
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeFieldSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MemberReference.GetKind">
      <summary vsli:raw="Determines if the member reference is to a method or field.">判斷成員參考是方法或欄位。</summary>
      <returns vsli:raw="One of the enumeration values that indicates the kind of member reference.">一個列舉值，表示成員參考的類型。</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The member reference signature is invalid.">成員參考簽章無效。</exception>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Name" />
    <member name="P:System.Reflection.Metadata.MemberReference.Parent">
      <summary vsli:raw="Gets the parent entity handle.">取得父實體控制代碼。</summary>
      <returns vsli:raw="An entity handle instance. If the &lt;see cref=&quot;P:System.Reflection.Metadata.EntityHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, the returned handle will have default values.">實體控制碼實例。 如果 <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> 屬性是 <see langword="true" />，則傳回的控制碼會有預設值。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Signature">
      <summary vsli:raw="Gets a handle to the signature blob.">取得簽章 Blob 的控制代碼。</summary>
      <returns vsli:raw="A handle to the signature blob.">簽章 blob 的控制碼。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandle" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MemberReferenceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Equality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Inequality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection">
      <summary vsli:raw="Represents a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt; instances.">表示 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /> 執行個體的集合。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MemberReferenceHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MemberReferenceKind">
      <summary vsli:raw="Specifies constants that indicate whether a &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReference&quot; /&gt; references a method or field.">指定常數，以表示 <see cref="T:System.Reflection.Metadata.MemberReference" /> 是否參考方法或欄位。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Field">
      <summary vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReference&quot; /&gt; references a field.">
        <see cref="T:System.Reflection.Metadata.MemberReference" /> 參考欄位。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Method">
      <summary vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReference&quot; /&gt; references a method.">
        <see cref="T:System.Reflection.Metadata.MemberReference" /> 參考方法。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataKind" />
    <member name="F:System.Reflection.Metadata.MetadataKind.Ecma335">
      <summary vsli:raw="CLI metadata.">CLI 中繼資料。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.ManagedWindowsMetadata">
      <summary vsli:raw="Windows metadata generated by managed compilers.">由受控編譯器產生的 Windows 中繼資料。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.WindowsMetadata">
      <summary vsli:raw="Windows metadata.">Windows 中繼資料。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReader">
      <summary vsli:raw="Reads metadata as defined by the ECMA 335 CLI specification.">如 ECMA 335 CLI 規格所定義，讀取中繼資料。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; class from the metadata stored at the given memory location.">從儲存在給定記憶體位置的中繼資料，初始化 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 類別的新執行個體。</summary>
      <param name="metadata" vsli:raw="A pointer to the first byte in a block of metadata.">中繼資料區塊中第一個位元組的指標。</param>
      <param name="length" vsli:raw="The number of bytes in the block.">區塊中的位元組數目。</param>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; class from the metadata stored at the given memory location.">從儲存在給定記憶體位置的中繼資料，初始化 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 類別的新執行個體。</summary>
      <param name="metadata" vsli:raw="" />
      <param name="length" vsli:raw="" />
      <param name="options" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; class from the metadata stored at the given memory location.">從儲存在給定記憶體位置的中繼資料，初始化 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 類別的新執行個體。</summary>
      <param name="metadata" vsli:raw="" />
      <param name="length" vsli:raw="" />
      <param name="options" vsli:raw="" />
      <param name="utf8Decoder" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;length&quot; /&gt; is not positive.">
        <paramref name="length" /> 不是正數。</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;metadata&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="metadata" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The encoding of &lt;paramref name=&quot;utf8Decoder&quot; /&gt; is not &lt;see cref=&quot;T:System.Text.UTF8Encoding&quot; /&gt;.">
        <paramref name="utf8Decoder" /> 的編碼並非 <see cref="T:System.Text.UTF8Encoding" />。</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is big-endian.">目前平台為位元組由大到小。</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Bad metadata header.">不正確的中繼資料標頭。</exception>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyFiles" />
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.DebugMetadataHeader">
      <summary vsli:raw="Gets the information decoded from #Pdb stream, or &lt;see langword=&quot;null&quot; /&gt; if the stream is not present.">從 #Pdb 資料流取得已解碼資訊，如果資料流不存在則為 <see langword="null" />。</summary>
      <returns vsli:raw="The information decoded from #Pdb stream, or &lt;see langword=&quot;null&quot; /&gt; if the stream is not present.">從 #Pdb 串流解碼的資訊，如果資料流程不存在，則 <see langword="null" />。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.DeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Documents" />
    <member name="P:System.Reflection.Metadata.MetadataReader.EventDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ExportedTypes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.FieldDefinitions" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyFile(System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyReference(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobBytes(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobContent(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.StringHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetConstant(System.Reflection.Metadata.ConstantHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttribute(System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttributes(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDeclarativeSecurityAttribute(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDocument(System.Reflection.Metadata.DocumentHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetEventDefinition(System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetExportedType(System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetFieldDefinition(System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameter(System.Reflection.Metadata.GenericParameterHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameterConstraint(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGuid(System.Reflection.Metadata.GuidHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetImportScope(System.Reflection.Metadata.ImportScopeHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetInterfaceImplementation(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalConstant(System.Reflection.Metadata.LocalConstantHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScope(System.Reflection.Metadata.LocalScopeHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalVariable(System.Reflection.Metadata.LocalVariableHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetManifestResource(System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMemberReference(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDefinition(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodImplementation(System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodSpecification(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleReference(System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinition(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinitionRoot" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetParameter(System.Reflection.Metadata.ParameterHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetPropertyDefinition(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetStandaloneSignature(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.StringHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeDefinition(System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeReference(System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeSpecification(System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetUserString(System.Reflection.Metadata.UserStringHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.ImportScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.IsAssembly">
      <summary vsli:raw="Gets a value that indicates whether the metadata represents an assembly.">取得值，這個值表示中繼資料是否代表組件。</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the metadata represents an assembly; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">如果中繼資料代表元件，則 <see langword="true" />：否則，<see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalConstants" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalVariables" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ManifestResources" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MemberReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataKind">
      <summary vsli:raw="Gets the metadata kind.">取得中繼資料類型。</summary>
      <returns vsli:raw="One of the enumeration values that specifies the metadata kind.">其中一個列舉值，指定中繼資料種類。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataLength">
      <summary vsli:raw="Gets the length of the underlying data.">取得基礎資料的長度。</summary>
      <returns vsli:raw="The length of the underlying data.">基礎資料的長度。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataPointer">
      <summary vsli:raw="Gets the pointer to the underlying data.">取得基礎資料的指標。</summary>
      <returns vsli:raw="The pointer to the underlying data.">基礎資料的指標。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataVersion">
      <summary vsli:raw="Gets the version string read from metadata header.">取得從中繼資料標頭讀取的版本字串。</summary>
      <returns vsli:raw="The version string read from metadata header.">從中繼資料標頭讀取的版本字串。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Options">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderOptions&quot; /&gt; passed to the constructor.">取得傳遞至建構函式的 <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" />。</summary>
      <returns vsli:raw="A bitwise combination of the enumeration values that describes the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderOptions&quot; /&gt; enum value.">列舉值的位元組合，描述 <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" /> 的列舉值。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.PropertyDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.StringComparer">
      <summary vsli:raw="Gets the comparer used to compare strings stored in metadata.">取得用來比較儲存在中繼資料中之字串的比較子。</summary>
      <returns vsli:raw="The comparer used to compare strings stored in metadata.">用來比較中繼資料中儲存之字串的比較子。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.UTF8Decoder">
      <summary vsli:raw="Gets the decoder used by the reader to produce string instances from UTF8-encoded byte sequences.">取得讀取器用來從 UTF8 編碼位元組序列產生字串執行個體的解碼器。</summary>
      <returns vsli:raw="The decoder used by the reader to produce string instances from UTF8-encoded byte sequences.">讀取器用來從 UTF8 編碼的位元組序列產生字串實例的解碼器。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderOptions" />
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.ApplyWindowsRuntimeProjections">
      <summary vsli:raw="Windows Runtime projections are enabled (on by default).">啟用 Windows 執行階段投影 (根據預設為開啟)。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.Default">
      <summary vsli:raw="The options that are used when a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; is obtained via an overload that does not take a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderOptions&quot; /&gt; argument.">當透過不接受 <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" /> 引數的多載取得 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 時，所使用的選項。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.None">
      <summary vsli:raw="All options are disabled.">停用所有選項。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderProvider">
      <summary vsli:raw="Provides a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; for metadata stored in an array of bytes, a memory block, or a stream.">針對儲存在位元組陣列、記憶體區塊或資料流中的中繼資料提供 <see cref="T:System.Reflection.Metadata.MetadataReader" />。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.Dispose">
      <summary vsli:raw="Disposes all memory allocated by the reader.">處置所有由讀取器所配置的記憶體。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Byte*,System.Int32)">
      <summary vsli:raw="Creates a metadata provider over an image stored in memory.">透過儲存在記憶體中的映像，建立中繼資料提供者。</summary>
      <param name="start" vsli:raw="Pointer to the start of the metadata blob.">指向中繼資料 Blob 開頭的指標。</param>
      <param name="size" vsli:raw="The size of the metadata blob.">中繼資料 Blob 的大小。</param>
      <returns vsli:raw="The new metadata provider.">新的中繼資料提供者。</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is &lt;see cref=&quot;F:System.IntPtr.Zero&quot; /&gt;.">
        <paramref name="start" /> 為 <see cref="F:System.IntPtr.Zero" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative.">
        <paramref name="size" /> 為負。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Creates a provider over a byte array.">透過位元組陣列建立提供者。</summary>
      <param name="image" vsli:raw="Metadata image.">中繼資料映像。</param>
      <returns vsli:raw="The new provider.">新的提供者。</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;image&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="image" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary vsli:raw="Creates a provider for a stream of the specified size beginning at its current position.">從資料流目前的位置開始，為指定大小的資料流建立提供者。</summary>
      <param name="stream" vsli:raw="A &lt;see cref=&quot;T:System.IO.Stream&quot; /&gt; instance.">
        <see cref="T:System.IO.Stream" /> 執行個體。</param>
      <param name="options" vsli:raw="Options specifying how sections of the image are read from the stream.">指定如何從資料流讀取映像區段方法的選項。</param>
      <param name="size" vsli:raw="Size of the metadata blob in the stream. If not specified, the metadata blob is assumed to span to the end of the stream.">資料流內中繼資料 Blob 的大小。 若未指定，則假設中繼資料 Blob 會延展到資料流結尾。</param>
      <returns vsli:raw="The new provider.">新的提供者。</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;stream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="stream" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;stream&quot; /&gt; doesn't support read and seek operations.">
        <paramref name="stream" /> 不支援讀取及搜尋作業。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Size is negative or extends past the end of the stream.">大小為負數或延展超過資料流的結尾。</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream (only when &lt;see cref=&quot;F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata&quot; /&gt; is specified).">從資料流讀取時發生錯誤 (只有在指定了 <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata" /> 時)。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Byte*,System.Int32)">
      <summary vsli:raw="Creates a portable PDB metadata provider over a blob stored in memory.">透過記憶體中所儲存的 Blob，建立可攜式 PDB 中繼資料提供者。</summary>
      <param name="start" vsli:raw="Pointer to the start of the portable PDB blob.">指向可攜式 PDB Blob 開頭的指標。</param>
      <param name="size" vsli:raw="The size of the portable PDB blob.">可攜式 PDB Blob 的大小。</param>
      <returns vsli:raw="The new portable PDB metadata provider.">新的可攜式 PDB 中繼資料提供者。</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is &lt;see cref=&quot;F:System.IntPtr.Zero&quot; /&gt;.">
        <paramref name="start" /> 為 <see cref="F:System.IntPtr.Zero" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative.">
        <paramref name="size" /> 為負。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Creates a portable PDB metadata provider over a byte array.">透過位元組陣列建立可攜式 PDB 中繼資料提供者。</summary>
      <param name="image" vsli:raw="A portable PDB image.">可攜式 PDB 映像。</param>
      <returns vsli:raw="The new portable PDB metadata provider .">新的可攜式 PDB 中繼資料提供者。</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;image&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="image" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary vsli:raw="Creates a provider for a stream of the specified size beginning at its current position.">從資料流目前的位置開始，為指定大小的資料流建立提供者。</summary>
      <param name="stream" vsli:raw="The stream.">資料流。</param>
      <param name="options" vsli:raw="Options specifying how sections of the image are read from the stream.">指定如何從資料流讀取映像區段的選項。</param>
      <param name="size" vsli:raw="Size of the metadata blob in the stream. If not specified, the metadata blob is assumed to span to the end of the stream.">資料流內中繼資料 Blob 的大小。 若未指定，則假設中繼資料 Blob 會延展到資料流結尾。</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; instance.">
        <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> 執行個體。</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;stream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="stream" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;stream&quot; /&gt; doesn't support read and seek operations.">
        <paramref name="stream" /> 不支援讀取及搜尋作業。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Size is negative or extends past the end of the stream.">大小為負數或延展超過資料流的結尾。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.GetMetadataReader(System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; from a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt;.">從 <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> 取得 <see cref="T:System.Reflection.Metadata.MetadataReader" />。</summary>
      <param name="options" vsli:raw="A bitwise combination of the enumeration values that represent the configuration when reading the metadata.">列舉值的位元組合，表示讀取中繼資料時的組態。</param>
      <param name="utf8Decoder" vsli:raw="The encoding to use.">要使用的編碼方式。</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; instance.">一個 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 執行個體。</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The encoding of &lt;paramref name=&quot;utf8Decoder&quot; /&gt; is not &lt;see cref=&quot;T:System.Text.UTF8Encoding&quot; /&gt;.">
        <paramref name="utf8Decoder" /> 的編碼並非 <see cref="T:System.Text.UTF8Encoding" />。</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is big-endian.">目前平台為位元組由大到小。</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">從基礎資料流讀取時出現 IO 錯誤。</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="Provider has been disposed.">提供者已經過處置。</exception>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStreamOptions" />
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.Default">
      <summary vsli:raw="By default, the stream is disposed when &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; is disposed and sections of the PE image are read lazily.">根據預設，當處置 <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> 之後即處置資料流，且會延遲讀取 PE 映像的區段。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen">
      <summary vsli:raw="Keeps the stream open when the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; is disposed.">當處置 <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> 之後保持資料流開啟。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata">
      <summary vsli:raw="&lt;para&gt;Reads PDB metadata into memory right away.&lt;/para&gt;&lt;para&gt;The underlying file may be closed and even deleted after the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; is constructed. &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; closes the stream automatically by the time the constructor returns unless &lt;see cref=&quot;F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen&quot; /&gt; is specified.&lt;/para&gt;">立即將 PDB 中繼資料讀取至記憶體中。
建構 <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> 之後，可能會關閉甚至刪除基礎檔案。 除非指定 <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen" />，否則 <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> 會在建構函式傳回時自動關閉資料流。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringComparer">
      <summary vsli:raw="Provides string comparison helpers to query strings in metadata while avoiding allocation if possible.">提供字串比較協助程式，以在中繼資料中查詢字串，同時盡可能避免配置。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String,System.Boolean)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
      <param name="ignoreCase" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String,System.Boolean)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
      <param name="ignoreCase" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
      <param name="ignoreCase" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
      <param name="ignoreCase" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringDecoder">
      <summary vsli:raw="Provides the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; with a custom mechanism for decoding byte sequences in metadata that represent text.">為 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 提供自訂機制，以在代表文字的中繼資料中解碼位元組序列。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.#ctor(System.Text.Encoding)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataStringDecoder&quot; /&gt; class using the given encoding.">使用指定的編碼初始化 <see cref="T:System.Reflection.Metadata.MetadataStringDecoder" /> 類別的新執行個體。</summary>
      <param name="encoding" vsli:raw="The encoding to use.">要使用的編碼方式。</param>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.DefaultUTF8">
      <summary vsli:raw="Gets the default decoder used by &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; to decode UTF-8 when no decoder is provided to the constructor.">當沒有提供建構函式解碼器時，取得 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 所使用的預設解碼器來解碼 UTF-8。</summary>
      <returns vsli:raw="The default decoder used by &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; to decode UTF-8.">
        <see cref="T:System.Reflection.Metadata.MetadataReader" /> 用來解碼 UTF-8 的預設解碼器。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding">
      <summary vsli:raw="Gets the encoding used by this instance.">取得這個執行個體所使用的編碼。</summary>
      <returns vsli:raw="The encoding used by this instance.">這個實例所使用的編碼方式。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.GetString(System.Byte*,System.Int32)">
      <summary vsli:raw="Obtains strings for byte sequences in metadata. Override this to cache strings if required. Otherwise, it is implemented by forwarding straight to &lt;see cref=&quot;P:System.Reflection.Metadata.MetadataStringDecoder.Encoding&quot; /&gt; and every call will allocate a new string.">從中繼資料中的位元組序列取得字串。 如有需要可覆寫此項目，以快取字串。 否則，它會藉由直接轉送至 <see cref="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding" /> 來實作，且每次呼叫都會配置新字串。</summary>
      <param name="bytes" vsli:raw="Pointer to bytes to decode.">要解碼的位元組指標。</param>
      <param name="byteCount" vsli:raw="Number of bytes to decode.">要解碼的位元組數目。</param>
      <returns vsli:raw="The decoded string.">解碼的字串。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodBodyBlock" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.Create(System.Reflection.Metadata.BlobReader)">
      <param name="reader" vsli:raw="The blob reader to read the method body." />
    </member>
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.ExceptionRegions" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILBytes" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILContent" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILReader" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalSignature" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalVariablesInitialized" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.MaxStack" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.Size">
      <summary vsli:raw="Gets the size of the method body, including the header, IL, and exception regions.">取得方法主體的大小，包括標頭、IL 及例外狀況區域。</summary>
      <returns vsli:raw="The size of the method body.">方法主體的大小。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformation">
      <summary vsli:raw="Provides debug information associated with a method definition. This information is stored in debug metadata.">提供與方法定義建立關聯的偵錯資訊。 此資訊儲存在偵錯中繼資料中。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.Document">
      <summary vsli:raw="Gets the handle of the single document containing all sequence points of the method.">取得單一文件的控制代碼，其中包含方法的所有序列點。</summary>
      <returns vsli:raw="The handle of the single document containing all sequence points of the method, or a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.DocumentHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the method doesn't have sequence points or spans multiple documents.">單一檔的控制碼，其中包含方法的所有序列點，或如果方法沒有序列點或跨多個檔，則為其 <see cref="P:System.Reflection.Metadata.DocumentHandle.IsNil" /> 屬性的控制碼 <see langword="true" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetSequencePoints">
      <summary vsli:raw="Returns a collection of sequence points decoded from &lt;see cref=&quot;P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob&quot; /&gt;.">傳回從 <see cref="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob" /> 解碼的序列點集合。</summary>
      <returns vsli:raw="A collection of sequence points.">序列點的集合。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetStateMachineKickoffMethod">
      <summary vsli:raw="Returns the kickoff method of the state machine.">傳回狀態機器的啟動方法。</summary>
      <returns vsli:raw="The kickoff method of the state machine, if the method is a &lt;c&gt;MoveNext&lt;/c&gt; method of a state machine. Otherwise, it returns a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;.">如果方法是狀態機器的 <c>MoveNext</c> 方法，則為狀態機器的啟動方法。 否則，它會傳回其 <see cref="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" /> 屬性為 <see langword="true" /> 的控制代碼。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.LocalSignature">
      <summary vsli:raw="Returns a local signature handle.">傳回本機簽章控制代碼。</summary>
      <returns vsli:raw="A local signature handle, or a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the method doesn't define any local variables.">本機簽章控制碼，或如果方法未定義任何本機變數，則為其 <see cref="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" /> 屬性 <see langword="true" /> 的控制碼。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob">
      <summary vsli:raw="Returns a blob encoding sequence points.">傳回 Blob 編碼的序列點。</summary>
      <returns vsli:raw="A blob encoding sequence points, or a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.BlobHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the method doesn't have sequence points.">Blob 編碼順序點，或如果方法沒有序列點，則為其 <see cref="P:System.Reflection.Metadata.BlobHandle.IsNil" /> 屬性的控制碼 <see langword="true" />。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Equality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Inequality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.ToDefinitionHandle">
      <summary vsli:raw="Returns a handle to a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinition&quot; /&gt; that corresponds to this handle.">傳回對應至這個控點的 <see cref="T:System.Reflection.Metadata.MethodDefinition" /> 控點。</summary>
      <returns vsli:raw="A method definition handle that corresponds to this handle.">對應至這個控制代碼的方法定義控制代碼。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection" />
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDebugInformationHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MethodDefinition" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Attributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetImport" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetParameters" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.ImplAttributes" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Name" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.RelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Equality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Inequality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.ToDebugInformationHandle">
      <summary vsli:raw="Returns a handle to a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDebugInformation&quot; /&gt; that corresponds to this handle.">傳回對應至此控點的 <see cref="T:System.Reflection.Metadata.MethodDebugInformation" /> 控點。</summary>
      <returns vsli:raw="A method debug information handle that corresponds to this handle.">對應至這個控制代碼的方法偵錯資訊控制代碼。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection" />
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MethodImplementation" />
    <member name="M:System.Reflection.Metadata.MethodImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodBody" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodDeclaration" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.Type" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandle" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MethodImplementationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Equality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Inequality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection" />
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodImplementationHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MethodImport" />
    <member name="P:System.Reflection.Metadata.MethodImport.Attributes" />
    <member name="P:System.Reflection.Metadata.MethodImport.Module" />
    <member name="P:System.Reflection.Metadata.MethodImport.Name" />
    <member name="T:System.Reflection.Metadata.MethodSignature`1">
      <summary vsli:raw="Represents a method (definition, reference, or standalone) or property signature. In the case of properties, the signature matches that of a getter with a distinguishing &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt;.">表示方法 (定義、參考或獨立) 或屬性簽章。 針對屬性，簽章會符合具特殊 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 的 getter。</summary>
      <typeparam name="TType" vsli:raw="The method type.">方法類型。</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.MethodSignature`1.#ctor(System.Reflection.Metadata.SignatureHeader,`0,System.Int32,System.Int32,System.Collections.Immutable.ImmutableArray{`0})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.MethodSignature`1&quot; /&gt; structure using the specified header, return type, and parameter information.">使用指定的標頭、傳回型別及參數資訊，將 <see cref="T:System.Reflection.Metadata.MethodSignature`1" /> 結構的新執行個體初始化。</summary>
      <param name="header" vsli:raw="The information in the leading byte of the signature (kind, calling convention, flags).">簽章的前置位元組資訊 (種類、呼叫慣例、旗標)。</param>
      <param name="returnType" vsli:raw="The return type of the method.">方法的傳回類型。</param>
      <param name="requiredParameterCount" vsli:raw="The number of required parameters.">必要參數數目。</param>
      <param name="genericParameterCount" vsli:raw="The number of generic type parameters.">泛型型別參數數目。</param>
      <param name="parameterTypes" vsli:raw="The parameter types.">參數類型。</param>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.GenericParameterCount">
      <summary vsli:raw="Gets the number of generic type parameters for the method.">取得方法的泛型型別參數數目。</summary>
      <returns vsli:raw="The number of generic type parameters, or 0 for non-generic methods.">泛型型別參數的數目，如果是非泛型方法，則為0。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.Header">
      <summary vsli:raw="Gets the information in the leading byte of the signature (kind, calling convention, flags).">取得簽章的前置位元組資訊 (種類、呼叫慣例、旗標)。</summary>
      <returns vsli:raw="The header signature.">標頭簽章。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ParameterTypes">
      <summary vsli:raw="Gets the method's parameter types.">取得方法的參數類型。</summary>
      <returns vsli:raw="An immutable collection of parameter types.">參數類型的不可變集合。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.RequiredParameterCount">
      <summary vsli:raw="Gets the number of parameters that are required for the method.">取得方法所需的參數數目。</summary>
      <returns vsli:raw="The number of required parameters.">必要參數數目。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ReturnType">
      <summary vsli:raw="Gets the return type of the method.">取得方法的傳回型別。</summary>
      <returns vsli:raw="The return type.">傳回類型。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecification" />
    <member name="M:System.Reflection.Metadata.MethodSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodSpecification.Method">
      <summary vsli:raw="Gets a &lt;see langword=&quot;MethodDef&quot; /&gt; or &lt;see langword=&quot;MemberRef&quot; /&gt; handle specifying which generic method this instance refers to (that is, which generic method it is an instantiation of).">取得 <see langword="MethodDef" /> 或 <see langword="MemberRef" /> 控制代碼，其指定這個執行個體參考的泛型方法 (亦即，為其具現化的泛型方法)。</summary>
      <returns vsli:raw="A &lt;see langword=&quot;MethodDef&quot; /&gt; or &lt;see langword=&quot;MemberRef&quot; /&gt; handle specifying which generic method this instance refers to.">
        <see langword="MethodDef" /> 或 <see langword="MemberRef" /> 的控制碼，指定這個實例所參考的泛型方法。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSpecification.Signature">
      <summary vsli:raw="Gets a handle to the signature blob.">取得簽章 Blob 的控制代碼。</summary>
      <returns vsli:raw="A handle to the signature blob.">簽章 blob 的控制碼。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MethodSpecificationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Equality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Inequality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.ModuleDefinition" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.BaseGenerationId" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Generation" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.GenerationId" />
    <member name="M:System.Reflection.Metadata.ModuleDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Mvid" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Name" />
    <member name="T:System.Reflection.Metadata.ModuleDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ModuleDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Equality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Inequality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.ModuleReference" />
    <member name="M:System.Reflection.Metadata.ModuleReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleReference.Name" />
    <member name="T:System.Reflection.Metadata.ModuleReferenceHandle" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ModuleReferenceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Equality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Inequality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.NamespaceDefinition" />
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.ExportedTypes">
      <summary vsli:raw="Gets all exported types that reside directly in a namespace.">取得直接位於命名空間內的所有匯出類型。</summary>
      <returns vsli:raw="An immutable array of exported type handles.">匯出之類型控制碼的不可變數組。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Name">
      <summary vsli:raw="Gets the unqualified name of the namespace definition.">取得命名空間定義火的非限定名稱。</summary>
      <returns vsli:raw="The unqualified name of the namespace definition.">命名空間定義的不合格名稱。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.NamespaceDefinitions">
      <summary vsli:raw="Gets the namespace definitions that are direct children of the current namespace definition.">取得目前命名空間定義直接子系的命名空間定義。</summary>
      <returns vsli:raw="An immutable array of namespace definitions that are direct children of the current namespace definition.">命名空間定義的不可變數組，屬於目前命名空間定義的直接子系。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Parent">
      <summary vsli:raw="Gets the parent namespace.">取得父命名空間。</summary>
      <returns vsli:raw="The parent namespace.">父命名空間。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.TypeDefinitions">
      <summary vsli:raw="Gets all type definitions that reside directly in a namespace.">取得直接位於命名空間內的所有類型定義。</summary>
      <returns vsli:raw="An immutable array of type definition handles.">類型定義控制碼的不可變數組。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.NamespaceDefinitionHandle">
      <summary vsli:raw="Provides a handle to a namespace definition.">提供命名空間定義的控點。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Equality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.NamespaceDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Implicit(System.Reflection.Metadata.NamespaceDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Inequality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Parameter" />
    <member name="P:System.Reflection.Metadata.Parameter.Attributes" />
    <member name="M:System.Reflection.Metadata.Parameter.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.Parameter.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.Parameter.GetMarshallingDescriptor" />
    <member name="P:System.Reflection.Metadata.Parameter.Name" />
    <member name="P:System.Reflection.Metadata.Parameter.SequenceNumber" />
    <member name="T:System.Reflection.Metadata.ParameterHandle" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Reflection.Metadata.ParameterHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ParameterHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Equality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Inequality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection">
      <summary vsli:raw="Contains a collection of parameters of a specified method.">包含指定方法的參數集合。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ParameterHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.PEReaderExtensions" />
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader)">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; from a &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt;.">從 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 取得 <see cref="T:System.Reflection.PortableExecutable.PEReader" />。</summary>
      <param name="peReader" vsli:raw="The current &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; instance.">目前的 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 執行個體。</param>
      <returns vsli:raw="A metadata reader.">中繼資料讀取器。</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peReader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peReader" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is big-endian.">目前平台為位元組由大到小。</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">從基礎資料流讀取時出現 IO 錯誤。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary vsli:raw="Gets a metadata reader with the specified metadata reading configuration from a &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt;.">從 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 取得具有指定中繼資料讀取組態的中繼資料讀取器。</summary>
      <param name="peReader" vsli:raw="The current &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; instance.">目前的 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 執行個體。</param>
      <param name="options" vsli:raw="An enumeration value indicating the metadata reading configuration.">指出中繼資料讀取組態的列舉值。</param>
      <returns vsli:raw="A metadata reader with the specified metadata reading configuration.">具有指定中繼資料讀取組態的中繼資料讀取器。</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peReader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peReader" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is big-endian.">目前平台為位元組由大到小。</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">從基礎資料流讀取時出現 IO 錯誤。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary vsli:raw="Gets a metadata reader with the specified metadata reading configuration and encoding configuration from a &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt;.">從 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 取得具有指定中繼資料讀取組態和編碼組態的中繼資料讀取器。</summary>
      <param name="peReader" vsli:raw="The current &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; instance.">目前的 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 執行個體。</param>
      <param name="options" vsli:raw="An enumeration value indicating the metadata reading configuration.">指出中繼資料讀取組態的列舉值。</param>
      <param name="utf8Decoder" vsli:raw="A metadata string decoder with the encoding configuration.">具有編碼組態的中繼資料字串解碼器。</param>
      <returns vsli:raw="&amp;gt;A metadata reader with the specified metadata reading configuration and encoding configuration.">&gt;具有指定中繼資料讀取設定和編碼設定的中繼資料讀取器。</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peReader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peReader" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The encoding of &lt;paramref name=&quot;utf8Decoder&quot; /&gt; is not &lt;see cref=&quot;T:System.Text.UTF8Encoding&quot; /&gt;.">
        <paramref name="utf8Decoder" /> 的編碼並非 <see cref="T:System.Text.UTF8Encoding" />。</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is big-endian.">目前平台為位元組由大到小。</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">從基礎資料流讀取時出現 IO 錯誤。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMethodBody(System.Reflection.PortableExecutable.PEReader,System.Int32)">
      <summary vsli:raw="Returns a body block of a method with the specified Relative Virtual Address (RVA).">傳回具有指定相對虛擬位址 (RVA) 的方法主體區塊；</summary>
      <param name="peReader" vsli:raw="The current &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; instance.">目前的 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 執行個體。</param>
      <param name="relativeVirtualAddress" vsli:raw="The Relative Virtual Address (RVA).">相對虛擬位址 (RVA)。</param>
      <returns vsli:raw="A method block body instance.">方法區塊主體執行個體。</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peReader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peReader" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The body is not found in the metadata or is invalid.">在中繼資料中找不到主體，或該主體無效。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The section where the method is stored is not available.">沒有用於儲存方法的可用區段。</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error occurred while reading from the underlying stream.">從基礎資料流讀取時發生 IO 錯誤。</exception>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveSerializationTypeCode">
      <summary vsli:raw="Specifies constants that define the type codes used to encode types of primitive values in a &lt;see cref=&quot;T:System.Reflection.Metadata.CustomAttribute&quot; /&gt; value blob.">指定要在 <see cref="T:System.Reflection.Metadata.CustomAttribute" /> 值 Blob 中，定義用於編碼基本值類型的類型代碼。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Boolean">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; type.">
        <see cref="T:System.Boolean" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Byte">
      <summary vsli:raw="An unsigned 1-byte integer type.">不帶正負號的 1 位元整數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Char">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Char&quot; /&gt; type.">
        <see cref="T:System.Char" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Double">
      <summary vsli:raw="An 8-byte floating point type.">8 位元浮點數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int16">
      <summary vsli:raw="A signed 2-byte integer type.">帶正負號的 2 位元整數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int32">
      <summary vsli:raw="A signed 4-byte integer type.">帶正負號的 4 位元整數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int64">
      <summary vsli:raw="A signed 8-byte integer type.">帶正負號的 8 位元整數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.SByte">
      <summary vsli:raw="A signed 1-byte integer type.">帶正負號的 1 位元整數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Single">
      <summary vsli:raw="A 4-byte floating point type.">4 位元浮點數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.String">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; type.">
        <see cref="T:System.String" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt16">
      <summary vsli:raw="An unsigned 2-byte integer type.">不帶正負號的 2 位元整數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt32">
      <summary vsli:raw="An unsigned 4-byte integer type.">不帶正負號的 4 位元整數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt64">
      <summary vsli:raw="An unsigned 8-byte integer type.">不帶正負號的 8 位元整數類型。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveTypeCode">
      <summary vsli:raw="Specifies constants that define primitive types found in metadata signatures.">指定在中繼資料簽章中找到，定義基礎類型的常數。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Boolean">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; type.">
        <see cref="T:System.Boolean" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Byte">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Byte&quot; /&gt; type.">
        <see cref="T:System.Byte" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Char">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Char&quot; /&gt; type.">
        <see cref="T:System.Char" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Double">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Double&quot; /&gt; type.">
        <see cref="T:System.Double" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int16">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.Int16&quot; /&gt; type.">
        <see cref="T:System.Int16" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int32">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.Int32&quot; /&gt; type.">
        <see cref="T:System.Int32" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int64">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.Int64&quot; /&gt; type.">
        <see cref="T:System.Int64" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.IntPtr">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; type.">
        <see cref="T:System.IntPtr" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Object">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.Object&quot; /&gt; type.">
        <see cref="T:System.Object" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.SByte">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.SByte&quot; /&gt; type.">
        <see cref="T:System.SByte" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Single">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Single&quot; /&gt; type.">
        <see cref="T:System.Single" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.String">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; type.">
        <see cref="T:System.String" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference">
      <summary vsli:raw="A typed reference.">具型別參考。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt16">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.UInt16&quot; /&gt; type.">
        <see cref="T:System.UInt16" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt32">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.UInt32&quot; /&gt; type.">
        <see cref="T:System.UInt32" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt64">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.UInt64&quot; /&gt; type.">
        <see cref="T:System.UInt64" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UIntPtr">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.UIntPtr&quot; /&gt; type.">
        <see cref="T:System.UIntPtr" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Void">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Void&quot; /&gt; type.">
        <see cref="T:System.Void" /> 型別。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PropertyAccessors" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Getter" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Others" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Setter" />
    <member name="T:System.Reflection.Metadata.PropertyDefinition" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Attributes" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetDefaultValue" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Equality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Inequality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection" />
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#PropertyDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ReservedBlob`1">
      <summary vsli:raw="Represents a handle and a corresponding blob on a metadata heap that was reserved for future content update.">表示已保留供未來內容更新的中繼資料堆積控點和對應 Blob。</summary>
      <typeparam name="THandle" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Content" />
    <member name="M:System.Reflection.Metadata.ReservedBlob`1.CreateWriter">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Reflection.Metadata.BlobWriter&quot; /&gt; to be used to update the content.">傳回要用來更新內容的 <see cref="T:System.Reflection.Metadata.BlobWriter" />。</summary>
      <returns vsli:raw="A blob writer to be used to update the content.">要用來更新內容的 Blob 寫入器。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Handle">
      <summary vsli:raw="Gets the reserved blob handle.">取得保留的 Blob 控制代碼。</summary>
      <returns vsli:raw="The reserved bloc handle.">保留的封鎖控制碼。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SequencePoint" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Document" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndLine" />
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Object)">
      <param name="obj" vsli:raw="The object to compare with the current object." />
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Reflection.Metadata.SequencePoint)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.GetHashCode" />
    <member name="F:System.Reflection.Metadata.SequencePoint.HiddenLine" />
    <member name="P:System.Reflection.Metadata.SequencePoint.IsHidden" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Offset" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartLine" />
    <member name="T:System.Reflection.Metadata.SequencePointCollection" />
    <member name="T:System.Reflection.Metadata.SequencePointCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.MoveNext" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.Reset" />
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#SequencePoint}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.SerializationTypeCode">
      <summary vsli:raw="Specifies type codes used to encode the types of values in a &lt;see cref=&quot;T:System.Reflection.Metadata.CustomAttributeValue`1&quot; /&gt; blob.">指定要在 <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" /> Blob 中用於編碼值類型的類型代碼。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Boolean">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Boolean&quot; /&gt;.">等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Boolean" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Byte">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Byte&quot; /&gt;.">等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Byte" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Char">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Char&quot; /&gt;.">等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Char" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Double">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Double&quot; /&gt;.">等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Double" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Enum">
      <summary vsli:raw="The attribute argument is an Enum instance.">屬性引數是 Enum 執行個體。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int16">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Int16&quot; /&gt;.">等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int16" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int32">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Int32&quot; /&gt;.">等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int32" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int64">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Int64&quot; /&gt;.">等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int64" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Invalid">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Invalid&quot; /&gt;.">等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SByte">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.SByte&quot; /&gt;.">等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SByte" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Single">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Single&quot; /&gt;.">等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Single" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.String">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.String&quot; /&gt;.">等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.String" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SZArray">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.SZArray&quot; /&gt;.">等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SZArray" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.TaggedObject">
      <summary vsli:raw="The attribute argument is &quot;boxed&quot; (passed to a parameter, field, or property of type object) and carries type information in the attribute blob.">屬性引數為 "boxed" (傳遞至參數、欄位，或是類型物件的屬性)，且附帶屬性 Blob 中的類型資訊。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Type">
      <summary vsli:raw="The attribute argument is a &lt;see cref=&quot;T:System.Type&quot; /&gt; instance.">屬性引數是 <see cref="T:System.Type" /> 執行個體。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt16">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.UInt16&quot; /&gt;.">等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt16" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt32">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.UInt32&quot; /&gt;.">等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt32" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt64">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.UInt64&quot; /&gt;.">等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt64" /> 的值。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureAttributes">
      <summary vsli:raw="Specifies additional flags that can be applied to method signatures. The underlying values of the fields in this type correspond to the representation in the leading signature byte represented by a &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure.">指定可套用到方法簽章的其他旗標。 此類型中的欄位基礎值會對應 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 結構代表的前置簽章位元組。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis">
      <summary vsli:raw="Indicates the first explicitly declared parameter that represents the instance pointer.">表示代表執行個體指標的明確宣告參數。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Generic">
      <summary vsli:raw="A generic method.">泛型方法。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Instance">
      <summary vsli:raw="&lt;para&gt;An instance method.&lt;/para&gt;&lt;para&gt;The Ecma 335 CLI Specification refers to this flag as &lt;see langword=&quot;HAS_THIS&quot; /&gt;.&lt;/para&gt;">執行個體方法。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.None">
      <summary vsli:raw="No flags.">沒有旗標。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureCallingConvention">
      <summary vsli:raw="Specifies how arguments in a given signature are passed from the caller to the callee. The underlying values of the fields in this type correspond to the representation in the leading signature byte represented by a &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure.">指定呼叫者如何將指定簽章中的引數傳遞給被呼叫者。 此類型中的欄位基礎值會對應 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 結構代表的前置簽章位元組。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.CDecl">
      <summary vsli:raw="An unmanaged C/C++ style calling convention where the call stack is cleaned by the caller.">呼叫者已清除呼叫堆疊的 Unmanaged C/C++ 樣式呼叫慣例。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.Default">
      <summary vsli:raw="A managed calling convention with a fixed-length argument list.">具有固定長度引數清單的 Managed 呼叫慣例。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.FastCall">
      <summary vsli:raw="An unmanaged calling convention where arguments are passed in registers when possible.">引數會傳遞至其中的 Unmanaged 呼叫慣例 (如果可能的話)。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.StdCall">
      <summary vsli:raw="An unmanaged calling convention where the call stack is cleaned up by the callee.">被呼叫者已清除呼叫堆疊的 Unmanaged 呼叫慣例。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.ThisCall">
      <summary vsli:raw="An unmanaged C++ style calling convention for calling instance member functions with a fixed argument list.">使用固定引數清單來呼叫執行個體成員函式的 Unmanaged C/C++ 樣式呼叫慣例。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.VarArgs">
      <summary vsli:raw="A managed calling convention for passing extra arguments.">用於傳遞額外引數的 Managed 呼叫慣例。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureHeader">
      <summary vsli:raw="Represents the signature characteristics specified by the leading byte of signature blobs.">表示簽章 Blob 的前置位元組所指定的簽章特性。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Byte)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure using the specified byte value.">使用指定的位元組值，初始化 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 結構的新執行個體。</summary>
      <param name="rawValue" vsli:raw="The byte.">位元組。</param>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Reflection.Metadata.SignatureKind,System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.SignatureAttributes)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure using the specified signature kind, calling convention and signature attributes.">使用指定的簽章種類、呼叫慣例與簽章屬性，將 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 結構的新執行個體初始化。</summary>
      <param name="kind" vsli:raw="The signature kind.">簽章種類。</param>
      <param name="convention" vsli:raw="The calling convention.">呼叫慣例。</param>
      <param name="attributes" vsli:raw="The signature attributes.">簽章屬性。</param>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Attributes">
      <summary vsli:raw="Gets the signature attributes.">取得簽章屬性。</summary>
      <returns vsli:raw="The attributes.">屬性。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.CallingConvention">
      <summary vsli:raw="Gets the calling convention.">取得呼叫慣例。</summary>
      <returns vsli:raw="The calling convention.">呼叫慣例。</returns>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask">
      <summary vsli:raw="Gets the mask value for the calling convention or signature kind. The default &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask&quot; /&gt; value is 15 (0x0F).">取得呼叫慣例或簽章種類的遮罩值。 預設 <see cref="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask" /> 值為 15 (0x0F)。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Object)">
      <summary vsli:raw="Compares the specified object with this &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; for equality.">比對指定物件與此 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 是否相等。</summary>
      <param name="obj" vsli:raw="The object to compare.">要比較的物件。</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the objects are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">如果物件相等則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Reflection.Metadata.SignatureHeader)">
      <summary vsli:raw="Compares two &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; values for equality.">比較兩個 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 值是否相等。</summary>
      <param name="other" vsli:raw="The value to compare.">要比較的值。</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the values are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">如果值相等，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.GetHashCode">
      <summary vsli:raw="Gets a hash code for the current object.">取得目前物件的雜湊碼。</summary>
      <returns vsli:raw="A hash code for the current object.">目前物件的雜湊碼。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.HasExplicitThis">
      <summary vsli:raw="Gets a value that indicates whether this &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure has the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis&quot; /&gt; signature attribute.">取得值，指出這個 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 結構是否具有 <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" /> 簽章屬性。</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis&quot; /&gt; attribute is present; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />如果屬性存在，則為， <see langword="false" />否則為。 <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" /></returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsGeneric">
      <summary vsli:raw="Gets a value that indicates whether this &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure has the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.Generic&quot; /&gt; signature attribute.">取得值，指出這個 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 結構是否具有 <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" /> 簽章屬性。</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.Generic&quot; /&gt; attribute is present; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />如果屬性存在，則為， <see langword="false" />否則為。 <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" /></returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsInstance">
      <summary vsli:raw="Gets a value that indicates whether this &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure has the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.Instance&quot; /&gt; signature attribute.">取得值，指出這個 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 結構是否具有 <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" /> 簽章屬性。</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.Instance&quot; /&gt; attribute is present; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />如果屬性存在，則為， <see langword="false" />否則為。 <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" /></returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Kind">
      <summary vsli:raw="Gets the signature kind.">取得簽章種類。</summary>
      <returns vsli:raw="The signature kind.">簽章種類。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Equality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary vsli:raw="Compares two &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; values for equality.">比較兩個 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 值是否相等。</summary>
      <param name="left" vsli:raw="The first value to compare.">要比較的第一個值。</param>
      <param name="right" vsli:raw="The second value to compare.">要比較的第二個值。</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the values are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">如果值相等，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Inequality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary vsli:raw="Determines whether two &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; values are unequal.">判斷兩個 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 值是否不相等。</summary>
      <param name="left" vsli:raw="The first value to compare.">要比較的第一個值。</param>
      <param name="right" vsli:raw="The second value to compare.">要比較的第二個值。</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the values are unequal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">如果值相等即為 <see langword="true" />，否則為 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.RawValue">
      <summary vsli:raw="Gets the raw value of the header byte.">取得標頭位元組的未經處理值。</summary>
      <returns vsli:raw="The raw value of the header byte.">標頭位元組的原始值。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.ToString">
      <summary vsli:raw="Returns a string that represents the current object.">傳回代表目前物件的字串。</summary>
      <returns vsli:raw="A string that represents the current object.">表示目前物件的字串。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureKind">
      <summary vsli:raw="Specifies the signature kind. The underlying values of the fields in this type correspond to the representation in the leading signature byte represented by a &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure.">指定簽章種類。 此類型中的欄位基礎值會對應 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 結構代表的前置簽章位元組。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Field">
      <summary vsli:raw="A field signature.">欄位簽章。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.LocalVariables">
      <summary vsli:raw="A local variables signature.">區域變數簽章。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Method">
      <summary vsli:raw="A method reference, method definition, or standalone method signature.">方法參考、方法定義或獨立方法簽章。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.MethodSpecification">
      <summary vsli:raw="A method specification signature.">方法規格簽章。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Property">
      <summary vsli:raw="A property signature.">屬性簽章。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeCode">
      <summary vsli:raw="Specifies constants that define type codes used in signature encoding.">指定在簽章編碼中用於定義類型代碼的常數。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Array">
      <summary vsli:raw="Represents a generalized &lt;see cref=&quot;T:System.Array&quot; /&gt; in signatures.">表示簽章中的通用 <see cref="T:System.Array" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Boolean">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.Boolean&quot; /&gt; in signatures.">表示簽章中的 <see cref="T:System.Boolean" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.ByReference">
      <summary vsli:raw="Represents managed pointers (byref return values and parameters) in signatures. It is followed in the blob by the signature encoding of the underlying type.">表示簽章中的 Managed 指標 (byref 傳回值與參數)。 基礎類型的簽章編碼會在 Blob 中跟隨它。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Byte">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.Byte&quot; /&gt; in signatures.">表示簽章中的 <see cref="T:System.Byte" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Char">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.Char&quot; /&gt; in signatures.">表示簽章中的 <see cref="T:System.Char" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Double">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.Double&quot; /&gt; in signatures.">表示簽章中的 <see cref="T:System.Double" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.FunctionPointer">
      <summary vsli:raw="Represents function pointer types in signatures.">表示簽章中的函式指標類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericMethodParameter">
      <summary vsli:raw="Represents a generic method parameter used within a signature.">表示在簽章中使用的泛型方法參數。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeInstance">
      <summary vsli:raw="Represents the instantiation of a generic type in signatures.">表示簽章中泛型型別的具現化。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeParameter">
      <summary vsli:raw="Represents a generic type parameter used within a signature.">表示在簽章中使用的泛型型別參數。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int16">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.Int16&quot; /&gt; in signatures.">表示簽章中的 <see cref="T:System.Int16" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int32">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.Int32&quot; /&gt; in signatures.">表示簽章中的 <see cref="T:System.Int32" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int64">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.Int64&quot; /&gt; in signatures.">表示簽章中的 <see cref="T:System.Int64" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.IntPtr">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; in signatures.">表示簽章中的 <see cref="T:System.IntPtr" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Invalid">
      <summary vsli:raw="Represents an invalid or uninitialized type code. It will not appear in valid signatures.">表示無效或未初始化的類型代碼。 不會在有效簽章中出現。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Object">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.Object&quot; /&gt; in signatures.">表示簽章中的 <see cref="T:System.Object" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.OptionalModifier">
      <summary vsli:raw="Represents a custom modifier applied to a type within a signature that the caller can ignore.">表示呼叫者可略過的簽章中，套用到類型的 Custom 修飾詞。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pinned">
      <summary vsli:raw="Represents a local variable that is pinned by garbage collector.">表示記憶體回收行程固定的區域變數。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pointer">
      <summary vsli:raw="Represents an unmanaged pointer in signatures. It is followed in the blob by the signature encoding of the underlying type.">表示簽章中的 Unmanaged 指標。 基礎類型的簽章編碼會在 Blob 中跟隨它。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.RequiredModifier">
      <summary vsli:raw="Represents a custom modifier applied to a type within a signature that the caller must understand.">表示呼叫者必須理解的簽章中，套用到類型的 Custom 修飾詞。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SByte">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.SByte&quot; /&gt; in signatures.">表示簽章中的 <see cref="T:System.SByte" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Sentinel">
      <summary vsli:raw="Represents a marker to indicate the end of fixed arguments and the beginning of variable arguments.">表示標記，以指出固定引數的結尾與變數引數的開頭。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Single">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.Single&quot; /&gt; in signatures.">表示簽章中的 <see cref="T:System.Single" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.String">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.String&quot; /&gt; in signatures.">表示簽章中的 <see cref="T:System.String" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SZArray">
      <summary vsli:raw="Represents a single dimensional &lt;see cref=&quot;T:System.Array&quot; /&gt; with a lower bound of 0.">表示下限為 0 的 一維 <see cref="T:System.Array" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypedReference">
      <summary vsli:raw="Represents a typed reference in signatures.">表示簽章中的具型別參考。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypeHandle">
      <summary vsli:raw="Precedes a type &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; in signatures. In raw metadata, this is encoded as either ELEMENT_TYPE_CLASS (0x12) for reference types or ELEMENT_TYPE_VALUETYPE (0x11) for value types. This is collapsed to a single code because Windows Runtime projections can project from class to value type or vice-versa, and the raw code is misleading in those cases.">優先簽章中的類型 <see cref="T:System.Reflection.Metadata.EntityHandle" />。 在原始中繼資料中，這會編碼為 ELEMENT_TYPE_CLASS (0x12) (若為參考型別) 或 ELEMENT_TYPE_VALUETYPE (0x11) (若為實值型別)。 因為 Windows 執行階段投影可在類別與實值型別之間交換投影，所以這會摺疊成單一程式碼，而原始程式碼在這些情況下會產生誤導。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt16">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; in signatures.">表示簽章中的 <see cref="T:System.UInt16" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt32">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; in signatures.">表示簽章中的 <see cref="T:System.UInt32" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt64">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; in signatures.">表示簽章中的 <see cref="T:System.UInt64" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UIntPtr">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.UIntPtr&quot; /&gt; in signatures.">表示簽章中的 <see cref="T:System.UIntPtr" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Void">
      <summary vsli:raw="Represents &lt;see cref=&quot;T:System.Void&quot; /&gt; in signatures.">表示簽章中的 <see cref="T:System.Void" />。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeKind">
      <summary vsli:raw="Indicates the type definition of the signature.">指出簽章的類型定義。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Class">
      <summary vsli:raw="The type definition or reference refers to a class.">參考類別的類型定義或參考。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Unknown">
      <summary vsli:raw="It isn't known in the current context if the type reference or definition is a class or value type.">在目前的內容中，無法判斷類型參考或定義是類別或實值型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.ValueType">
      <summary vsli:raw="The type definition or reference refers to a value type.">參考實值型別的類型定義或參考。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignature" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeLocalSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetKind">
      <summary vsli:raw="Determines the kind of signature, which can be &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureKind.Method&quot; /&gt; or &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureKind.LocalVariables&quot; /&gt;.">判斷簽章的種類，它可以是 <see cref="F:System.Reflection.Metadata.SignatureKind.Method" /> 或 <see cref="F:System.Reflection.Metadata.SignatureKind.LocalVariables" />。</summary>
      <returns vsli:raw="An enumeration value that indicates the signature kind.">指出簽章種類的列舉值。</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The signature is invalid.">簽章無效。</exception>
    </member>
    <member name="P:System.Reflection.Metadata.StandaloneSignature.Signature">
      <summary vsli:raw="Gets a handle to the signature blob.">取得簽章 Blob 的控制代碼。</summary>
      <returns vsli:raw="A handle to the signature blob.">簽章 blob 的控制碼。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignatureHandle" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Equality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Inequality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignatureKind">
      <summary vsli:raw="Indicates whether a &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignature&quot; /&gt; represents a standalone method or local variable signature.">指出 <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> 表示獨立方法或區域變數簽章。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.LocalVariables">
      <summary vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReference&quot; /&gt; references a local variable signature.">
        <see cref="T:System.Reflection.Metadata.MemberReference" /> 參考區域變數簽章。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.Method">
      <summary vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignature&quot; /&gt; represents a standalone method signature.">
        <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> 表示獨立方法簽章。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StringHandle" />
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Reflection.Metadata.StringHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.StringHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.StringHandle.op_Equality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StringHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Implicit(System.Reflection.Metadata.StringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Inequality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinition" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.BaseType">
      <summary vsli:raw="Gets the base type of the type definition: either &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;.">取得型別定義的基底型別：<see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />。</summary>
      <returns vsli:raw="The base type of the type definition.">型別定義的基底型別。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclaringType">
      <summary vsli:raw="Returns the enclosing type of a specified nested type.">傳回指定巢狀型別的封入型別。</summary>
      <returns vsli:raw="The enclosing type of the specified nested type, or a handle a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the type is not nested.">指定巢狀型別的封入型別，或型別不是巢狀時，其 <see cref="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" /> 屬性為 <see langword="true" /> 的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetEvents" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetFields" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetInterfaceImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetLayout" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethodImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethods" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetNestedTypes">
      <summary vsli:raw="Returns an array of types nested in the specified type.">傳回指定型別中巢狀型別的陣列。</summary>
      <returns vsli:raw="An immutable array of type definition handles that represent types nested in the specified type.">型別定義控制代碼的不可變陣列，表示指定型別中的巢狀型別。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetProperties" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.IsNested">
      <summary vsli:raw="Gets a value that indicates whether this is a nested type.">取得值，這個值指出這是否為巢狀型別。</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if it is a nested type, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />如果它是巢狀型別，則<see langword="false" />為，否則為。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Name">
      <summary vsli:raw="Gets the name of the type.">取得型別的名稱。</summary>
      <returns vsli:raw="The name of the type.">型別的名稱。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Namespace">
      <summary vsli:raw="Gets the full name of the namespace where the type is defined.">取得型別定義所在之命名空間的完整名稱。</summary>
      <returns vsli:raw="The full name of the namespace where the type is defined, or a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.StringHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the type is nested or defined in a root namespace.">定義類型之命名空間的完整名稱，或如果類型是在根命名<see cref="P:System.Reflection.Metadata.StringHandle.IsNil" />空間中<see langword="true" />進行嵌套或定義，則為其屬性為的控制碼。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.NamespaceDefinition">
      <summary vsli:raw="Gets the definition handle of the namespace where the type is defined.">取得型別定義所在之命名空間的定義控制代碼。</summary>
      <returns vsli:raw="The definition handle of the namespace where the type is defined, or a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;  if the type is nested or defined in a root namespace.">定義類型之命名空間的定義控制碼，或如果類型是在根<see cref="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" />命名空間<see langword="true" />中進行嵌套或定義，則為其屬性為的控制碼。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Equality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Inequality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection">
      <summary vsli:raw="Contains a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; instances.">包含 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 執行個體的集合。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.TypeLayout" />
    <member name="M:System.Reflection.Metadata.TypeLayout.#ctor(System.Int32,System.Int32)">
      <param name="size" vsli:raw="" />
      <param name="packingSize" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeLayout.IsDefault" />
    <member name="P:System.Reflection.Metadata.TypeLayout.PackingSize" />
    <member name="P:System.Reflection.Metadata.TypeLayout.Size" />
    <member name="T:System.Reflection.Metadata.TypeReference" />
    <member name="P:System.Reflection.Metadata.TypeReference.Name">
      <summary vsli:raw="Gets the name of the target type.">取得目標型別的名稱。</summary>
      <returns vsli:raw="The name of the target type.">目標型別的名稱。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.Namespace">
      <summary vsli:raw="Gets the full name of the namespace where the target type is defined.">取得目標型別定義所在之命名空間的完整名稱。</summary>
      <returns vsli:raw="The full name of the namespace where the target type is defined, or a handle whose the &lt;see cref=&quot;P:System.Reflection.Metadata.StringHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the type is nested or defined in a root namespace.">定義目標型別之命名空間的完整名稱，或如果在根命名空間中嵌套或定義類型，則為 <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /> 屬性的控制碼 <see langword="true" />）。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.ResolutionScope">
      <summary vsli:raw="Gets the resolution scope in which the target type is defined and is uniquely identified by the specified &lt;see cref=&quot;P:System.Reflection.Metadata.TypeReference.Namespace&quot; /&gt; and &lt;see cref=&quot;P:System.Reflection.Metadata.TypeReference.Name&quot; /&gt;.">取得定義目標型別並由指定的 <see cref="P:System.Reflection.Metadata.TypeReference.Namespace" /> 和 <see cref="P:System.Reflection.Metadata.TypeReference.Name" /> 唯一識別的解析範圍。</summary>
      <returns vsli:raw="The resolution scope in which the target type is uniquely defined.">解析範圍，其中的目標型別是唯一定義的。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandle" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.TypeReferenceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Equality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Inequality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection">
      <summary vsli:raw="Contains a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; instances.">包含 <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 執行個體的集合。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeReferenceHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.TypeSpecification" />
    <member name="M:System.Reflection.Metadata.TypeSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.TypeSpecification.Signature" />
    <member name="T:System.Reflection.Metadata.TypeSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.TypeSpecificationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Equality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Inequality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.UserStringHandle">
      <summary vsli:raw="Represents a handle to the user string heap.">表示使用者字串堆積的控點。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Reflection.Metadata.UserStringHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.UserStringHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Equality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.UserStringHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Implicit(System.Reflection.Metadata.UserStringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Inequality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.MethodImportAttributes" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionCDecl" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionFastCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionStdCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionThisCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionWinApi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAnsi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAuto" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetUnicode" />
    <member name="F:System.Reflection.MethodImportAttributes.ExactSpelling" />
    <member name="F:System.Reflection.MethodImportAttributes.None" />
    <member name="F:System.Reflection.MethodImportAttributes.SetLastError" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharMask" />
    <member name="T:System.Reflection.MethodSemanticsAttributes" />
    <member name="F:System.Reflection.MethodSemanticsAttributes.Adder">
      <summary vsli:raw="&lt;para&gt;Used to add a handler for an event. Corresponds to the &lt;see langword=&quot;AddOn&quot; /&gt; flag in the Ecma 335 CLI specification.&lt;/para&gt;&lt;para&gt;CLS-compliant adders are named the with &lt;see langword=&quot;add_&quot; /&gt; prefix.&lt;/para&gt;">用於新增事件的處理常式。 對應至 Ecma 335 CLI 規格中的 <see langword="AddOn" /> 旗標。
符合 CLS 規範的 adder 會使用 <see langword="add_" /> 前置詞來命名。</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Getter">
      <summary vsli:raw="&lt;para&gt;Reads the value of the property.&lt;/para&gt;&lt;para&gt;CLS-compliant getters are named with get_ prefix.&lt;/para&gt;">讀取屬性的值。
符合 CLS 規範的 getter 會使用 `get_` 前置詞來命名。</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Other">
      <summary vsli:raw="Other method for a property (not a getter or setter) or an event (not an adder, remover, or raiser).">屬性 (不是 getter 或 setter) 或事件 (不是 adder、remover 或 raiser) 的其他方法。</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Raiser">
      <summary vsli:raw="&lt;para&gt;Used to indicate that an event has occurred. Corresponds to the &lt;see langword=&quot;Fire&quot; /&gt; flag in the Ecma 335 CLI specification.&lt;/para&gt;&lt;para&gt; CLS-compliant raisers are named with the &lt;see langword=&quot;raise_&quot; /&gt; prefix.&lt;/para&gt;">用來表示事件已發生。 對應至 Ecma 335 CLI 規格中的 <see langword="Fire" /> 旗標。
 符合 CLS 規範的 raiser 會使用 <see langword="raise_" /> 前置詞來命名。</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Remover">
      <summary vsli:raw="&lt;para&gt;Used to remove a handler for an event. Corresponds to the &lt;see langword=&quot;RemoveOn&quot; /&gt; flag in the Ecma 335 CLI specification.&lt;/para&gt;&lt;para&gt;CLS-compliant removers are named with the &lt;see langword=&quot;remove_&quot; /&gt; prefix.&lt;/para&gt;">用於移除事件的處理常式。 對應至 Ecma 335 CLI 規格中的 <see langword="RemoveOn" /> 旗標。
符合 CLS 規範的 remover 會使用 <see langword="remove_" /> 前置詞來命名。</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Setter">
      <summary vsli:raw="&lt;para&gt;Used to modify the value of the property.&lt;/para&gt;&lt;para&gt;CLS-compliant setters are named with the &lt;see langword=&quot;set_&quot; /&gt; prefix.&lt;/para&gt;">用來修改屬性的值。
符合 CLS 規範的 setter 會使用 <see langword="set_" /> 前置詞來命名。</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.AggressiveWSTrim" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Bit32Machine" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedHi" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedLo" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.DebugStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Dll" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.ExecutableImage" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LargeAddressAware" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LineNumsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LocalSymsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.NetRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RelocsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RemovableRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.System" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.UpSystemOnly" />
    <member name="T:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData">
      <summary vsli:raw="Provides information about a Program Debug Database (PDB) file.">提供程式偵錯資料庫 (PDB) 檔案的相關資訊。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Age">
      <summary vsli:raw="The iteration of the PDB. The first iteration is 1. The iteration is incremented each time the PDB content is augmented.">PDB 的反覆項目。 第一個反覆項目為 1。 每次擴充 PDB 內容時，反覆項目便會遞增。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Guid">
      <summary vsli:raw="The Globally Unique Identifier (GUID) of the associated PDB.">相關聯 PDB 的全域唯一識別碼 (GUID)。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Path">
      <summary vsli:raw="The path to the .pdb file that contains debug information for the PE/COFF file.">包含 PE/COFF 檔案偵錯資訊的 .pdb 檔案路徑。</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CoffHeader">
      <summary vsli:raw="Represents the header of a COFF file.">代表 COFF 檔案的標頭。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Characteristics">
      <summary vsli:raw="Gets the flags that indicate the attributes of the file.">取得指出檔案屬性的旗標。</summary>
      <returns vsli:raw="The flags that indicate the attributes of the file.">指示檔案屬性的旗標。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Machine">
      <summary vsli:raw="Gets the type of the target machine.">取得目標機器的類型。</summary>
      <returns vsli:raw="The type of the target machine.">目的電腦的類型。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSections">
      <summary vsli:raw="Gets the number of sections. This indicates the size of the section table, which immediately follows the headers.">取得區段的數目。 這指出區段表 (緊接在標頭之後) 的大小。</summary>
      <returns vsli:raw="The number of sections.">區段的數目。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSymbols">
      <summary vsli:raw="Gets the number of entries in the symbol table. This data can be used to locate the string table, which immediately follows the symbol table. This value should be zero for a PE image.">取得符號表中的項目數目。 此資料可以用來尋找字串表 (緊接在符號表之後)。 PE 映像的這個值應該為零。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.PointerToSymbolTable">
      <summary vsli:raw="Gets the file pointer to the COFF symbol table.">取得 COFF 符號表的檔案指標。</summary>
      <returns vsli:raw="The file pointer to the COFF symbol table, or zero if no COFF symbol table is present. This value should be zero for a PE image.">COFF 符號表的檔案指標，如果不存在 COFF 符號表則為零。 PE 映像的這個值應該為零。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.SizeOfOptionalHeader">
      <summary vsli:raw="Gets the size of the optional header, which is required for executable files but not for object files. This value should be zero for an object file.">取得選擇性標頭 (對可執行檔是必要的，但對物件檔案不是) 的大小。 物件檔案的這個值應該為零。</summary>
      <returns vsli:raw="The size of the optional header.">選擇性標頭的大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.TimeDateStamp">
      <summary vsli:raw="Gets a value that indicates when the file was created.">取得指出檔案建立時間的值。</summary>
      <returns vsli:raw="The low 32 bits of the number of seconds since 00:00 January 1, 1970, which indicates when the file was created.">自00:00 年1月1日起的秒數的低32位1970，表示檔案的建立時間。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CorFlags" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILLibrary" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILOnly" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.NativeEntryPoint" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Prefers32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Requires32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.StrongNameSigned" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.TrackDebugData" />
    <member name="T:System.Reflection.PortableExecutable.CorHeader" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.CodeManagerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.EntryPointTokenOrRelativeVirtualAddress" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ExportAddressTableJumpsDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.Flags" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MajorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ManagedNativeHeaderDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MetadataDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MinorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ResourcesDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.StrongNameSignatureDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.VtableFixupsDirectory" />
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" />
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.DebugDirectoryBuilder&quot; /&gt; class.">初始化 <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" /> 類別的新執行個體。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddCodeViewEntry(System.String,System.Reflection.Metadata.BlobContentId,System.UInt16)">
      <summary vsli:raw="Adds a CodeView entry.">新增 CodeView 項目。</summary>
      <param name="pdbPath" vsli:raw="The path to the PDB. It should not be empty.">PDB 的路徑。 不得為空白。</param>
      <param name="pdbContentId" vsli:raw="The unique id of the PDB content.">PDB 內容的唯一識別碼。</param>
      <param name="portablePdbVersion" vsli:raw="The version of Portable PDB format (e.g. 0x0100 for 1.0), or 0 if the PDB is not portable.">可攜式 PDB 格式的版本 (例如 1.0 版為 0x0100)，如果 PDB 無法攜帶，則為 0。</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;pdbPath&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="pdbPath" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;pdbPath&quot; /&gt; contains a NUL character.">
        <paramref name="pdbPath" /> 包含 NUL 字元。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;portablePdbVersion&quot; /&gt; is smaller than 0x0100.">
        <paramref name="portablePdbVersion" /> 小於 0x0100。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEmbeddedPortablePdbEntry(System.Reflection.Metadata.BlobBuilder,System.UInt16)">
      <summary vsli:raw="Adds an Embedded Portable PDB entry.">新增內嵌可攜式 PDB 項目。</summary>
      <param name="debugMetadata" vsli:raw="A Portable PDB metadata builder.">可攜式 PDB 中繼資料產生器。</param>
      <param name="portablePdbVersion" vsli:raw="The version of Portable PDB format (e.g. 0x0100 for 1.0).">可攜式 PDB 格式的版本 (例如 1.0 版為 0x0100)。</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;debugMetadata&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="debugMetadata" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;portablePdbVersion&quot; /&gt; is smaller than 0x0100.">
        <paramref name="portablePdbVersion" /> 小於 0x0100。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32)">
      <summary vsli:raw="Adds an entry of the specified type.">新增指定類型的項目。</summary>
      <param name="type" vsli:raw="The entry type.">項目類型。</param>
      <param name="version" vsli:raw="The entry version.">項目版本。</param>
      <param name="stamp" vsli:raw="The entry stamp.">項目戳記。</param>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry``1(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32,``0,System.Action{System.Reflection.Metadata.BlobBuilder,``0})">
      <summary vsli:raw="Adds an entry of the specified type and serializes its data.">新增指定類型的項目，並序列化其資料。</summary>
      <param name="type" vsli:raw="The entry type.">項目類型。</param>
      <param name="version" vsli:raw="The entry version.">項目版本。</param>
      <param name="stamp" vsli:raw="The entry stamp.">項目戳記。</param>
      <param name="data" vsli:raw="The data to pass to &lt;paramref name=&quot;dataSerializer&quot; /&gt;.">要傳遞至 <paramref name="dataSerializer" /> 的資料。</param>
      <param name="dataSerializer" vsli:raw="A serializer for serializing data to a &lt;see cref=&quot;T:System.Reflection.Metadata.BlobBuilder&quot; /&gt;.">將資料序列化為 <see cref="T:System.Reflection.Metadata.BlobBuilder" /> 的序列化程式。</param>
      <typeparam name="TData" vsli:raw="The type of the data passed to &lt;paramref name=&quot;dataSerializer&quot; /&gt;.">傳遞給 <paramref name="dataSerializer" /> 的資料類型。</typeparam>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddPdbChecksumEntry(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Adds PDB checksum entry.">新增 PDB 總和檢查碼項目。</summary>
      <param name="algorithmName" vsli:raw="The hash algorithm name (for example, &quot;SHA256&quot;).">雜湊演算法名稱 (例如 "SHA256")。</param>
      <param name="checksum" vsli:raw="The checksum.">總和檢查碼。</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;algorithmName&quot; /&gt; or &lt;paramref name=&quot;checksum&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="algorithmName" /> 或 <paramref name="checksum" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;algorithmName&quot; /&gt; or &lt;paramref name=&quot;checksum&quot; /&gt; is empty.">
        <paramref name="algorithmName" /> 或 <paramref name="checksum" /> 是空的。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddReproducibleEntry">
      <summary vsli:raw="Adds a reproducible entry.">新增可重現的項目。</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntry">
      <summary vsli:raw="Identifies the location, size and format of a block of debug information.">識別偵錯資訊區塊的位置、大小和格式。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryEntry.#ctor(System.UInt32,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.Int32,System.Int32,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.DebugDirectoryEntry&quot; /&gt; structure.">初始化 <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryEntry" /> 結構的新執行個體。</summary>
      <param name="stamp" vsli:raw="" />
      <param name="majorVersion" vsli:raw="" />
      <param name="minorVersion" vsli:raw="" />
      <param name="type" vsli:raw="" />
      <param name="dataSize" vsli:raw="" />
      <param name="dataRelativeVirtualAddress" vsli:raw="" />
      <param name="dataPointer" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataPointer">
      <summary vsli:raw="Gets the file pointer to the debug data.">取得偵錯資料的檔案指標。</summary>
      <returns vsli:raw="The file pointer to the debug data.">調試資料的檔案指標。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataRelativeVirtualAddress">
      <summary vsli:raw="Gets the address of the debug data when loaded, relative to the image base.">在載入時，取得相對於基底映像的偵錯資料位址。</summary>
      <returns vsli:raw="The address of the debug data relative to the image base.">相對於影像基底的 debug 資料位址。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataSize">
      <summary vsli:raw="Gets the size of the debug data (not including the debug directory itself).">取得偵錯資料的大小 (不包括偵錯目錄本身)。</summary>
      <returns vsli:raw="the size of the debug data (excluding the debug directory).">debug 資料的大小（不包括 debug 目錄）。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.IsPortableCodeView">
      <summary vsli:raw="Gets a value that indicates if the entry is a &lt;see cref=&quot;F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView&quot; /&gt; entry that points to a Portable PDB.">取得值，指出此項目是否為指向可攜式 PDB 的 <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" /> 項目。</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the entry is a &lt;see cref=&quot;F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView&quot; /&gt; entry pointing to a Portable PDB; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> 如果專案是指向便攜 PDB 的 <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" /> 專案，則為，否則，<see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MajorVersion">
      <summary vsli:raw="Gets the major version number of the debug data format.">取得偵錯資料格式的主要版本號碼。</summary>
      <returns vsli:raw="The major version number of the debug data format.">Debug 資料格式的主要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MinorVersion">
      <summary vsli:raw="Gets the minor version number of the debug data format.">取得偵錯資料格式的次要版本號碼。</summary>
      <returns vsli:raw="The minor version number of the debug data format.">Debug 資料格式的次要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Stamp">
      <summary vsli:raw="Get the time and date that the debug data was created if the PE/COFF file is not deterministic; otherwise, gets a value based on the hash of the content.">如果 PE/COFF 檔案不具決定性，請取得偵錯資料的建立時間和日期；否則，請取得以內容雜湊為基礎的值。</summary>
      <returns vsli:raw="for a non-deterministic PE/COFF file, the time and date that the debug data was created; otherwise, a value based on the hash of the content.">對於不具決定性的 PE/COFF 檔案，這是建立偵錯工具資料的時間和日期;否則，會根據內容的雜湊值。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Type">
      <summary vsli:raw="Gets the format of the debugging information.">取得偵錯資訊的格式。</summary>
      <returns vsli:raw="The format of the debugging information.">調試資訊的格式。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntryType" />
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView">
      <summary vsli:raw="Associated PDB file description. For more information, see the specification.">相關聯的 PDB 檔案描述。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Coff">
      <summary vsli:raw="The COFF debug information (line numbers, symbol table, and string table). This type of debug information is also pointed to by fields in the file headers.">COFF 偵錯資訊 (行號、符號表和字串表)。 使用檔案標頭中的欄位也可指向這類偵錯資訊。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb">
      <summary vsli:raw="&lt;para&gt;The entry points to a blob containing Embedded Portable PDB. The Embedded Portable PDB blob has the following format:&lt;/para&gt;&lt;para&gt;- blob ::= uncompressed-size data&lt;/para&gt;&lt;para&gt;- Data spans the remainder of the blob and contains a Deflate-compressed Portable PDB.&lt;/para&gt;&lt;para&gt;For more information, see the specification.&lt;/para&gt;">此項目指向包含內嵌可攜式 PDB 的 Blob。 內嵌可攜式 PDB Blob 的格式如下：- blob ::= 未壓縮大小的資料- Data 會跨越 Blob 的其餘部分，並包含 Deflate 壓縮的可攜式 PDB。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.PdbChecksum">
      <summary vsli:raw="The entry stores a crypto hash of the content of the symbol file the PE/COFF file was built with. The hash can be used to validate that a given PDB file was built with the PE/COFF file and not altered in any way. More than one entry can be present if multiple PDBs were produced during the build of the PE/COFF file (for example, private and public symbols). For more information, see the specification.">此項目會儲存建立 PE/COFF 檔案所用符號檔內容的加密雜湊。 雜湊可用來驗證指定的 PDB 檔案是否使用 PE/COFF 檔案建立，且不會因任何方式改變。 如果在建置 PE/COFF 檔案期間產生多個 PDB (例如私用和公用符號)，就會出現多個項目。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Reproducible">
      <summary vsli:raw="&lt;para&gt;The presence of this entry indicates a deterministic PE/COFF file. See the Remarks section for more information.&lt;/para&gt;&lt;para&gt;The tool that produced the deterministic PE/COFF file guarantees that the entire content of the file is based solely on documented inputs given to the tool (such as source files, resource files, and compiler options) rather than ambient environment variables (such as the current time, the operating system, and the bitness of the process running the tool).&#xA;          The value of field TimeDateStamp in COFF File Header of a deterministic PE/COFF file does not indicate the date and time when the file was produced and should not be interpreted that way. Instead, the value of the field is derived from a hash of the file content. The algorithm to calculate this value is an implementation detail of the tool that produced the file.&#xA;          The debug directory entry of type &lt;see cref=&quot;T:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Reproducible&quot; /&gt; must have all fields, except for Type zeroed.&lt;/para&gt;&lt;para&gt;For more information, see the specification.&lt;/para&gt;">此項目出現即表示有具決定性的 PE/COFF 檔案。 如需詳細資訊，請參閱＜備註＞一節。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Unknown">
      <summary vsli:raw="An unknown value that should be ignored by all tools.">所有工具都應該忽略未知值。</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DirectoryEntry" />
    <member name="M:System.Reflection.PortableExecutable.DirectoryEntry.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" vsli:raw="" />
      <param name="size" vsli:raw="" />
    </member>
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.RelativeVirtualAddress" />
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.Size" />
    <member name="T:System.Reflection.PortableExecutable.DllCharacteristics">
      <summary vsli:raw="Describes the characteristics of a dynamic link library.">描述動態連結程式庫的特性。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.AppContainer">
      <summary vsli:raw="The image must run inside an AppContainer.">映像必須在 AppContainer 內執行。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.DynamicBase">
      <summary vsli:raw="The DLL can be relocated.">DLL 可以重新放置。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.HighEntropyVirtualAddressSpace">
      <summary vsli:raw="The image can handle a high entropy 64-bit virtual address space.">映像可以處理熵 64 位元的虛擬位址空間。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoBind">
      <summary vsli:raw="Do not bind this image.">請勿繫結此映像。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoIsolation">
      <summary vsli:raw="The image understands isolation and doesn't want it.">映像了解隔離，且不想要它。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoSeh">
      <summary vsli:raw="The image does not use SEH. No SE handler may reside in this image.">映像不使用 SEH。 任何 SE 處理常式都不會保留在此映像中。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NxCompatible">
      <summary vsli:raw="The image is NX compatible.">映像與 NX 相容。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessInit">
      <summary vsli:raw="Reserved.">保留的。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessTerm">
      <summary vsli:raw="Reserved.">保留的。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.TerminalServerAware">
      <summary vsli:raw="The image is Terminal Server aware.">映像可感知終端機伺服器。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadInit">
      <summary vsli:raw="Reserved.">保留的。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadTerm">
      <summary vsli:raw="Reserved.">保留的。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.WdmDriver">
      <summary vsli:raw="The driver uses the WDM model.">驅動程式會使用 WDM 模型。</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Machine">
      <summary vsli:raw="Specifies the target machine's CPU architecture.">指定目的機器的 CPU 架構。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha">
      <summary vsli:raw="Alpha.">Alpha。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha64">
      <summary vsli:raw="ALPHA64.">ALPHA64。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.AM33">
      <summary vsli:raw="Matsushita AM33.">Matsushita AM33。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Amd64">
      <summary vsli:raw="AMD64 (K8).">AMD64 (K8)。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm">
      <summary vsli:raw="ARM little endian.">ARM 位元組由小到大。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm64">
      <summary vsli:raw="ARM64.">ARM64。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.ArmThumb2">
      <summary vsli:raw="ARM Thumb-2 little endian.">ARM Thumb-2 位元組由小到大。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Ebc">
      <summary vsli:raw="EFI Byte Code.">EFI 位元組碼。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.I386">
      <summary vsli:raw="Intel 386.">Intel 386。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.IA64">
      <summary vsli:raw="Intel 64.">Intel 64。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.M32R">
      <summary vsli:raw="M32R little-endian.">M32R 位元組由小到大。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MIPS16">
      <summary vsli:raw="MIPS.">MIPS。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu">
      <summary vsli:raw="MIPS with FPU.">MIPS (含 FPU)。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu16">
      <summary vsli:raw="MIPS16 with FPU.">MIPS16 (含 FPU)。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPC">
      <summary vsli:raw="IBM PowerPC little endian.">IBM PowerPC 位元組由小到大。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPCFP">
      <summary vsli:raw="PowerPCFP.">PowerPCFP。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3">
      <summary vsli:raw="Hitachi SH3 little endian.">Hitachi SH3 位元組由小到大。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3Dsp">
      <summary vsli:raw="Hitachi SH3 DSP.">Hitachi SH3 DSP。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3E">
      <summary vsli:raw="Hitachi SH3 little endian.">Hitachi SH3 位元組由小到大。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH4">
      <summary vsli:raw="Hitachi SH4 little endian.">Hitachi SH4 位元組由小到大。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH5">
      <summary vsli:raw="Hitachi SH5.">Hitachi SH5。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Thumb">
      <summary vsli:raw="Thumb.">Thumb。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Tricore">
      <summary vsli:raw="Infineon.">Infineon。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Unknown">
      <summary vsli:raw="The target CPU is unknown or not specified.">目標 CPU 不明或未指定。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.WceMipsV2">
      <summary vsli:raw="MIPS little-endian WCE v2.">MIPS 位元組由小到大 WCE v2。</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ManagedPEBuilder" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Reflection.Metadata.Ecma335.MetadataRootBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId},System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.ResourceSectionBuilder,System.Reflection.PortableExecutable.DebugDirectoryBuilder,System.Int32,System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.PortableExecutable.CorFlags)">
      <param name="header" />
      <param name="metadataRootBuilder" />
      <param name="deterministicIdProvider" />
      <param name="ilStream" />
      <param name="mappedFieldData" />
      <param name="managedResources" />
      <param name="nativeResources" />
      <param name="debugDirectoryBuilder" />
      <param name="strongNameSignatureSize" />
      <param name="entryPoint" />
      <param name="flags" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.GetDirectories" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.ManagedResourcesDataAlignment" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.MappedFieldDataAlignment" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" vsli:raw="" />
      <param name="location" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.Sign(System.Reflection.Metadata.BlobBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Byte[]})">
      <param name="peImage" vsli:raw="" />
      <param name="signatureProvider" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData">
      <summary vsli:raw="Represents a PDB Checksum debug directory entry.">代表 PDB 總和檢查碼偵錯目錄項目。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.AlgorithmName">
      <summary vsli:raw="The name of the crypto hash algorithm used to calculate the checksum.">用來計算總和檢查碼之雜湊演算法的名稱。</summary>
      <returns vsli:raw="A string representing the name of the crypto hash algorithm used to calculate the checksum.">字串，表示用來計算總和檢查碼的加密雜湊演算法的名稱。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.Checksum">
      <summary vsli:raw="The checksum of the PDB content.">PDB 內容的總和檢查碼。</summary>
      <returns vsli:raw="An immutable array of bytes representing the checksum of the PDB content.">不可變的位元組陣列，代表 PDB 內容的總和檢查碼。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEBuilder" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <param name="header" vsli:raw="" />
      <param name="deterministicIdProvider" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetDirectories" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetSections" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.Header" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IdProvider" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IsDeterministic" />
    <member name="T:System.Reflection.PortableExecutable.PEBuilder.Section" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Section.#ctor(System.String,System.Reflection.PortableExecutable.SectionCharacteristics)">
      <param name="name" vsli:raw="" />
      <param name="characteristics" vsli:raw="" />
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Name" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" vsli:raw="" />
      <param name="location" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder">
      <summary vsli:raw="Builds PE directories.">建置 PE 目錄。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEDirectoriesBuilder.#ctor">
      <summary vsli:raw="Initializes an instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEDirectoriesBuilder&quot; /&gt; class.">初始化 <see cref="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder" /> 類別的執行個體。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.AddressOfEntryPoint">
      <summary vsli:raw="The address of the entry point relative to the image base when the PE file is loaded into memory.">當 PE 檔案載入記憶體時，相對於基底映像的進入點位址。</summary>
      <returns vsli:raw="For program images, this is the starting address. For device drivers, this is the address of the initialization function. An entry point is optional for DLLs. When no entry point is present, this field must be zero.">對於程式映射，這是起始位址。 若為設備磁碟機，這就是初始化函式的位址。 針對 Dll，進入點是選擇性的。 當沒有任何進入點時，此欄位必須為零。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BaseRelocationTable">
      <summary vsli:raw="The base relocation table image directory entry.">基底重新配置資料表映像目錄項目。</summary>
      <returns vsli:raw="A directory entry instance.">目錄專案實例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BoundImportTable">
      <summary vsli:raw="The bound import image directory entry.">繫結匯入映像目錄項目。</summary>
      <returns vsli:raw="A directory entry instance.">目錄專案實例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CopyrightTable">
      <summary vsli:raw="The copyright/architecture image directory entry.">著作權/架構映像目錄項目。</summary>
      <returns vsli:raw="A directory entry instance.">目錄專案實例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CorHeaderTable">
      <summary vsli:raw="The COM descriptortable image directory entry.">COM 可描述映像目錄項目。</summary>
      <returns vsli:raw="A directory entry instance.">目錄專案實例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DebugTable">
      <summary vsli:raw="The debug table image directory entry.">偵錯資料表映像目錄項目。</summary>
      <returns vsli:raw="A directory entry instance.">目錄專案實例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DelayImportTable">
      <summary vsli:raw="The delay import table image directory entry.">延遲匯入資料表映像目錄項目。</summary>
      <returns vsli:raw="A directory entry instance.">目錄專案實例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExceptionTable">
      <summary vsli:raw="The exception table image directory entry.">例外狀況資料表映像目錄項目。</summary>
      <returns vsli:raw="A directory entry instance.">目錄專案實例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExportTable">
      <summary vsli:raw="The export table image directory entry.">匯出資料表映像目錄項目。</summary>
      <returns vsli:raw="A directory entry instance.">目錄專案實例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.GlobalPointerTable">
      <summary vsli:raw="The global pointer table image directory entry.">全域指標資料表映像目錄項目。</summary>
      <returns vsli:raw="A directory entry instance.">目錄專案實例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportAddressTable">
      <summary vsli:raw="The import address table (IAT) image directory entry.">匯入位址表 (IAT) 映像目錄項目。</summary>
      <returns vsli:raw="A directory entry instance.">目錄專案實例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportTable">
      <summary vsli:raw="The import table image directory entry.">匯入資料表映像目錄項目。</summary>
      <returns vsli:raw="A directory entry instance.">目錄專案實例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.LoadConfigTable">
      <summary vsli:raw="The load configuration table image directory entry.">負載組態資料表映像目錄項目。</summary>
      <returns vsli:raw="A directory entry instance.">目錄專案實例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ResourceTable">
      <summary vsli:raw="The resource table image directory entry.">資源資料表映像目錄項目。</summary>
      <returns vsli:raw="A directory entry instance.">目錄專案實例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ThreadLocalStorageTable">
      <summary vsli:raw="The thread local storage (TLS) table image directory entry.">執行緒區域 (TLS) 資料表映像目錄項目。</summary>
      <returns vsli:raw="A directory entry instance.">目錄專案實例。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeader" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.AddressOfEntryPoint">
      <summary vsli:raw="Gets the address of the entry point relative to the image base when the PE file is loaded into memory.">當 PE 檔案載入記憶體時，取得相對於基底映像的進入點位址。</summary>
      <returns vsli:raw="The address of the entry point relative to the image base.">相對於影像基底的進入點位址。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfCode">
      <summary vsli:raw="Gets the address of the beginning-of-code section relative to the image base when the image is loaded into memory.">當映像載入記憶體時，取得相對於映像基底的程式碼開頭區段位址。</summary>
      <returns vsli:raw="The address of the beginning-of-code section relative to the image base.">相對於影像基底之起始程式碼區段的位址。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfData">
      <summary vsli:raw="Gets the address of the beginning-of-data section relative to the image base when the image is loaded into memory.">當映像載入記憶體時，取得相對於映像基底的資料開頭區段位址。</summary>
      <returns vsli:raw="The address of the beginning-of-data section relative to the image base.">相對於影像基底的資料開頭區段的位址。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseRelocationTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BoundImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CertificateTableDirectory">
      <summary vsli:raw="Gets the Certificate Table entry, which points to a table of attribute certificates.">取得憑證資料表項目，它會指向屬性憑證資料表。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CheckSum">
      <summary vsli:raw="Gets the image file checksum.">取得映像檔案總和檢查碼。</summary>
      <returns vsli:raw="The image file checksum.">影像檔案總和檢查碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CopyrightTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CorHeaderTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DebugTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DelayImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DllCharacteristics" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExceptionTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment">
      <summary vsli:raw="Gets the alignment factor (in bytes) that is used to align the raw data of sections in the image file.">取得對齊因素 (以位元組為單位)，用來對齊映像檔中的區段原始資料。</summary>
      <returns vsli:raw="A power of 2 between 512 and 64K, inclusive. The default is 512.">介於512和64K （含）之間的2乘冪。 預設值為 512。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.GlobalPointerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImageBase">
      <summary vsli:raw="Gets the preferred address of the first byte of the image when it is loaded into memory.">載入記憶體時，取得映像第一個位元組的慣用位址。</summary>
      <returns vsli:raw="The preferred address, which is a multiple of 64K.">慣用的位址，也就是64K 的倍數。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportAddressTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.LoadConfigTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Magic">
      <summary vsli:raw="Gets a value that identifies the format of the image file.">取得可識別映像檔案格式的值。</summary>
      <returns vsli:raw="The format of the image file.">影像檔案的格式。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorImageVersion">
      <summary vsli:raw="Gets the major version number of the image.">取得映像的主要版本號碼。</summary>
      <returns vsli:raw="The major version number of the image.">映像的主要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorLinkerVersion">
      <summary vsli:raw="Gets the linker major version number.">取得連結器主要版本號碼。</summary>
      <returns vsli:raw="The linker major version number.">連結器主要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorOperatingSystemVersion">
      <summary vsli:raw="Gets the major version number of the required operating system.">取得所需作業系統的主要版本號碼。</summary>
      <returns vsli:raw="The major version number of the required operating system.">所需作業系統的主要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorSubsystemVersion">
      <summary vsli:raw="Gets the major version number of the subsystem.">取得子系統的主要版本號碼。</summary>
      <returns vsli:raw="The major version number of the subsystem.">子系統的主要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorImageVersion">
      <summary vsli:raw="Gets the minor version number of the image.">取得映像的次要版本號碼。</summary>
      <returns vsli:raw="The minor version number of the image.">映像的次要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorLinkerVersion">
      <summary vsli:raw="Gets the linker minor version number.">取得連結器次要版本號碼。</summary>
      <returns vsli:raw="The linker minor version number.">連結器次要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorOperatingSystemVersion">
      <summary vsli:raw="Gets the minor version number of the required operating system.">取得所需作業系統的次要版本號碼。</summary>
      <returns vsli:raw="The minor version number of the required operating system.">所需作業系統的次要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorSubsystemVersion">
      <summary vsli:raw="Gets the minor version number of the subsystem.">取得子系統的次要版本號碼。</summary>
      <returns vsli:raw="The minor version number of the subsystem.">子系統的次要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.NumberOfRvaAndSizes">
      <summary vsli:raw="Gets the number of data-directory entries in the remainder of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeader&quot; /&gt;. Each describes a location and size.">取得剩餘 <see cref="T:System.Reflection.PortableExecutable.PEHeader" /> 中的資料目錄項目數目。 每一個都描述位置和大小。</summary>
      <returns vsli:raw="The number of data-directory entries in the remainder of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeader&quot; /&gt;.">
        <see cref="T:System.Reflection.PortableExecutable.PEHeader" />其餘部分中的資料目錄專案數。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ResourceTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment">
      <summary vsli:raw="Gets the alignment (in bytes) of sections when they are loaded into memory.">取得載入記憶體時對齊的區段 (以位元組為單位)。</summary>
      <returns vsli:raw="A number greater than or equal to &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeader.FileAlignment&quot; /&gt;. The default is the page size for the architecture.">大於或等於 <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment" /> 的數位。 預設值為架構的頁面大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfCode">
      <summary vsli:raw="Gets the size of the code (text) section, or the sum of all code sections if there are multiple sections.">取得程式碼 (文字) 區段大小，或所有程式碼區段的總和 (如有多個區段)。</summary>
      <returns vsli:raw="the size of the code (text) section, or the sum of all code sections if there are multiple sections.">程式碼（文字）區段的大小，或所有程式碼區段的總和（如果有多個區段）。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeaders">
      <summary vsli:raw="Gets the combined size of an MS DOS stub, PE header, and section headers rounded up to a multiple of FileAlignment.">取得 MS DOS stub、PE 標頭和區段標頭的合併大小，四捨五入至 FileAlignment 的倍數。</summary>
      <returns vsli:raw="The combined size of an MS DOS stub, PE header, and section headers rounded up to a multiple of FileAlignment.">MS DOS stub、PE 標頭和區段標頭的合併大小，進位到 FileAlignment 的倍數。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit">
      <summary vsli:raw="Gets the size of the local heap space to commit.">取得要認可的區域堆積空間大小。</summary>
      <returns vsli:raw="the size of the local heap space to commit.">要認可的本機堆積空間大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapReserve">
      <summary vsli:raw="Gets the size of the local heap space to reserve. Only &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit&quot; /&gt; is committed; the rest is made available one page at a time until the reserve size is reached.">取得要保留的區域堆積空間大小。 僅認可 <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit" />；其餘部分一次提供一頁，直到達到保留大小為止。</summary>
      <returns vsli:raw="The size of the local heap space to reserve.">要保留的區域堆積空間大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfImage">
      <summary vsli:raw="Gets the size (in bytes) of the image, including all headers, as the image is loaded in memory.">將映像載入記憶體時，取得包括所有標頭在內的映像大小 (以位元組為單位)。</summary>
      <returns vsli:raw="The size (in bytes) of the image, which is a multiple of &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment&quot; /&gt;.">影像的大小（以位元組為單位），這是 <see cref="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment" /> 的倍數。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfInitializedData">
      <summary vsli:raw="Gets the size of the initialized data section, or the sum of all such sections if there are multiple data sections.">取得已初始化資料區段大小，或所有這類區段的總和 (如有多個資料區段)。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit">
      <summary vsli:raw="Gets the size of the stack to commit.">取得要認可的堆疊大小。</summary>
      <returns vsli:raw="The size of the stack to commit.">要認可的堆疊大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackReserve">
      <summary vsli:raw="Gets the size of the stack to reserve. Only &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit&quot; /&gt; is committed; the rest is made available one page at a time until the reserve size is reached.">取得要保留的堆疊大小。 僅認可 <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit" />；其餘部分一次提供一頁，直到達到保留大小為止。</summary>
      <returns vsli:raw="The size of the stack to reserve.">要保留的堆疊大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfUninitializedData">
      <summary vsli:raw="Gets the size of the uninitialized data section (BSS), or the sum of all such sections if there are multiple BSS sections.">取得未初始化資料區段 (BSS) 大小，或所有這類區段的總和 (如有多個 BSS 區段)。</summary>
      <returns vsli:raw="The size of the uninitialized data section (BSS) or the sum of all such sections.">未初始化資料區段（BSS）的大小，或所有這類區段的總和。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Subsystem">
      <summary vsli:raw="Gets the name of the subsystem that is required to run this image.">取得執行此映像所需的子系統名稱。</summary>
      <returns vsli:raw="The name of the subsystem that is required to run this image.">執行此映射所需的子系統名稱。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ThreadLocalStorageTableDirectory" />
    <member name="T:System.Reflection.PortableExecutable.PEHeaderBuilder">
      <summary vsli:raw="Defines the header for a portable executable (PE) file.">定義可攜式可執行檔 (PE) 的標頭。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.#ctor(System.Reflection.PortableExecutable.Machine,System.Int32,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.Subsystem,System.Reflection.PortableExecutable.DllCharacteristics,System.Reflection.PortableExecutable.Characteristics,System.UInt64,System.UInt64,System.UInt64,System.UInt64,System.Int32,System.UInt64,System.Byte,System.Byte,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
      <summary>初始化 <see cref="T:System.Reflection.PortableExecutable.PEHeader" /> 類別的新執行個體。</summary>
      <param name="machine">目標機器的 CPU 架構。</param>
      <param name="sectionAlignment">載入至記憶體時對齊區段 (以位元組為單位)。 必須大於或等於 <paramref name="fileAlignment" />。 預設值為架構的頁面大小。</param>
      <param name="majorSubsystemVersion">子系統的主要版本號碼。</param>
      <param name="minorSubsystemVersion">子系統的次要版本號碼。</param>
      <param name="subsystem">執行映像所需的子系統。</param>
      <param name="dllCharacteristics">描述動態連結程式庫特性的物件。</param>
      <param name="imageCharacteristics">描述映像特性的物件。</param>
      <param name="sizeOfStackReserve">要保留的堆疊大小。 僅認可 <paramref name="sizeOfStackCommit" />；其餘部分一次提供一頁，直到達到保留大小為止。</param>
      <param name="sizeOfStackCommit">要認可的堆疊大小。</param>
      <param name="sizeOfHeapReserve">要保留的區域堆積空間大小。 僅認可 <paramref name="sizeOfHeapCommit" />；其餘部分一次提供一頁，直到達到保留大小為止。</param>
      <param name="sizeOfHeapCommit">要認可的區域堆積空間大小。</param>
      <param name="fileAlignment">對齊因素 (以位元組為單位)，用來對齊映像檔中的區段原始資料。 此值應為介於 512 和 64K (含) 之間 2 的乘冪。 預設值為 512。 如果 <paramref name="sectionAlignment" /> 小於架構的頁面大小，則 <paramref name="fileAlignment" /> 必須符合 <paramref name="sectionAlignment" />。</param>
      <param name="imageBase">映像載入至記憶體時，其第一個位元組的慣用位址；必須是 64K 的倍數。</param>
      <param name="majorLinkerVersion">連結器主要版本號碼。</param>
      <param name="minorLinkerVersion">連結器次要版本號碼。</param>
      <param name="majorOperatingSystemVersion">所需作業系統的主要版本號碼。</param>
      <param name="minorOperatingSystemVersion">所需作業系統的次要版本號碼。</param>
      <param name="majorImageVersion">映像的主要版本號碼。</param>
      <param name="minorImageVersion">映像的次要版本號碼。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="fileAlignment" /> 不是 512 和 64K 之間 2 的乘冪。
-或-
<paramref name="sectionAlignment" /> 不是 2 的乘冪。
-或-
<paramref name="sectionAlignment" /> 小於 <paramref name="fileAlignment" />。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateExecutableHeader">
      <summary vsli:raw="Creates an executable header.">建立可執行檔標頭。</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeaderBuilder&quot; /&gt; instance representing the executable header.">表示可執行檔標頭的 <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" /> 執行個體。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateLibraryHeader">
      <summary vsli:raw="Creates a library header.">建立程式庫標頭。</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeaderBuilder&quot; /&gt; instance representing the library header.">表示程式庫標頭的 <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" /> 執行個體。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.DllCharacteristics">
      <summary vsli:raw="Returns the dynamic linker library characteristics.">傳回動態連結器程式庫特性。</summary>
      <returns vsli:raw="An object that describes the dynamic linker library characteristics.">描述動態連結器程式庫特性的物件。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.FileAlignment">
      <summary vsli:raw="The alignment factor (in bytes) that is used to align the raw data of sections in the image file. The value should be a power of 2 between 512 and 64K, inclusive. The default is 512. If the section alignment is less than the architecture's page size, then file alignment must match the section alignment.">對齊因素 (以位元組為單位)，用來對齊映像檔中的區段原始資料。 此值應為介於 512 和 64K (含) 之間 2 的乘冪。 預設值為 512。 如果對齊後的區段小於架構頁面大小，則檔案對齊必須符合區段對齊。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageBase">
      <summary vsli:raw="The preferred address of the first byte of image when loaded into memory; must be a multiple of 64K.">映像載入至記憶體時，其第一個位元組的慣用位址；必須是 64K 的倍數。</summary>
      <returns vsli:raw="A number representing the preferred address of the first byte of image when loaded into memory.">數位，代表載入記憶體時，第一個位元組影像的慣用位址。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageCharacteristics">
      <summary vsli:raw="Returns the image characteristics.">傳回映像特性。</summary>
      <returns vsli:raw="An object representing the image characteristics.">代表影像特性的物件。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Machine">
      <summary vsli:raw="The target machine's CPU architecture.">目標機器的 CPU 架構。</summary>
      <returns vsli:raw="One of the enumeration values representing the different CPU architectures.">其中一個列舉值，代表不同的 CPU 架構。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorImageVersion">
      <summary vsli:raw="The major version number of the image.">映像的主要版本號碼。</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the major version number of the image.">數位，<see cref="T:System.UInt16" /> 的大小，代表影像的主要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorLinkerVersion">
      <summary vsli:raw="The linker major version number.">連結器主要版本號碼。</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.Byte&quot; /&gt; representing the linker major version number.">數位，<see cref="T:System.Byte" /> 的大小，代表連結器的主要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorOperatingSystemVersion">
      <summary vsli:raw="The major version number of the required operating system.">所需作業系統的主要版本號碼。</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the major version number of the required operating system.">數位，代表所需作業系統主要版本號碼的 <see cref="T:System.UInt16" /> 大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorSubsystemVersion">
      <summary vsli:raw="The major version number of the subsystem.">子系統的主要版本號碼。</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the major version number of the subsystem.">數位，<see cref="T:System.UInt16" /> 的大小，表示子系統的主要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorImageVersion">
      <summary vsli:raw="The minor version number of the image.">映像的次要版本號碼。</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the minor version number of the image.">數位，代表影像次要版本號碼的 <see cref="T:System.UInt16" /> 大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorLinkerVersion">
      <summary vsli:raw="The linker minor version number.">連結器次要版本號碼。</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.Byte&quot; /&gt; representing the linker minor version number.">數位，<see cref="T:System.Byte" /> 的大小，代表連結器次要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorOperatingSystemVersion">
      <summary vsli:raw="The minor version number of the required operating system.">所需作業系統的次要版本號碼。</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the minor version number of the required operating system.">數位，代表所需作業系統次要版本號碼的 <see cref="T:System.UInt16" /> 大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorSubsystemVersion">
      <summary vsli:raw="The minor version number of the subsystem.">子系統的次要版本號碼。</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the minor version number of the subsystem.">數位，<see cref="T:System.UInt16" /> 的大小，代表子系統的次要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SectionAlignment">
      <summary vsli:raw="The alignment (in bytes) of sections when they are loaded into memory.">載入至記憶體時對齊區段 (以位元組為單位)。</summary>
      <returns vsli:raw="A number representing the alignment (in bytes) of sections when they are loaded into memory. It must be greater than or equal to the file alignment. The default is the page size for the architecture.">數位，代表載入記憶體時區段的對齊（以位元組為單位）。 必須大於或等於檔案對齊。 預設值為架構的頁面大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit">
      <summary vsli:raw="The size of the local heap space to commit.">要認可的區域堆積空間大小。</summary>
      <returns vsli:raw="A number representing the size of the local heap space to commit.">表示要認可的本機堆積空間大小的數位。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapReserve">
      <summary vsli:raw="The size of the local heap space to reserve. Only &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit&quot; /&gt; is committed; the rest is made available one page at a time until the reserve size is reached.">要保留的區域堆積空間大小。 僅認可 <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit" />；其餘部分一次提供一頁，直到達到保留大小為止。</summary>
      <returns vsli:raw="A number representing the size of the local heap space to reserve.">代表要保留之本機堆積空間大小的數位。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit">
      <summary vsli:raw="The size of the stack to commit.">要認可的堆疊大小。</summary>
      <returns vsli:raw="A number representing the size of the stack to commit.">代表要認可之堆疊大小的數位。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackReserve">
      <summary vsli:raw="The size of the stack to reserve. Only &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit&quot; /&gt; is committed; the rest is made available one page at a time until the reserve size is reached.">要保留的堆疊大小。 僅認可 <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit" />；其餘部分一次提供一頁，直到達到保留大小為止。</summary>
      <returns vsli:raw="A number representing the size of the stack to reserve.">代表要保留之堆疊大小的數位。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Subsystem">
      <summary vsli:raw="The subsystem that is required to run this image.">執行此映像所需的子系統。</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.PortableExecutable.Subsystem&quot; /&gt; instance.">
        <see cref="T:System.Reflection.PortableExecutable.Subsystem" /> 執行個體。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeaders">
      <summary vsli:raw="Defines a type that reads PE (Portable Executable) and COFF (Common Object File Format) headers from a stream.">定義可從資料流讀取 PE (可攜式執行檔) 和 COFF (通用物件檔案格式) 標頭的類型。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream)">
      <summary vsli:raw="Instantiates a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeaders&quot; /&gt; class that reads the PE headers from the current location in the specified stream.">具現化 <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> 類別的新執行個體，它會在指定資料流的目前位置讀取 PE 標頭。</summary>
      <param name="peStream" vsli:raw="A stream containing the PE image starting at the stream's current position and ending at the end of the stream.">資料流，包含從資料流目前位置開始，結束於資料流結尾的 PE 映像。</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data read from the stream has an invalid format.">從資料流讀取的資料格式無效。</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream.">在資料流中讀取時發生錯誤。</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The stream does not support seek operations.">資料流不支援搜尋作業。</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peStream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peStream" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32)">
      <summary vsli:raw="Instantiates a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeaders&quot; /&gt; class that reads the PE headers from a stream that represents a PE image of a specified size.">具現化 <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> 類別的新執行個體，它會從表示指定大小 PE 映像的資料流中讀取 PE 標頭。</summary>
      <param name="peStream" vsli:raw="A stream containing PE image of the given size starting at its current position.">資料流，包含從其目前位置開始的指定大小 PE 映像。</param>
      <param name="size" vsli:raw="The size of the PE image.">PE 映像大小。</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data read from the stream has an invalid format.">從資料流讀取的資料格式無效。</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream.">在資料流中讀取時發生錯誤。</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The stream does not support seek operations.">資料流不支援搜尋作業。</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peStream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peStream" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative or extends past the end of the stream.">
        <paramref name="size" /> 為負數或延展超過資料流的結尾。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
      <summary vsli:raw="Instantiates a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeaders&quot; /&gt; class that reads the PE headers from a stream that represents a PE image of a specified size and indicates whether the PE image has been loaded into memory.">具現化 <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> 類別的新執行個體，它會從表示指定大小 PE 映像的資料流中讀取 PE 標頭，並指出 PE 映像是否已載入至記憶體。</summary>
      <param name="peStream" vsli:raw="The stream containing PE image of the given size starting at its current position.">資料流，包含從其目前位置開始的指定大小 PE 映像。</param>
      <param name="size" vsli:raw="The size of the PE image.">PE 映像大小。</param>
      <param name="isLoadedImage" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the PE image has been loaded into memory by the OS loader; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">如果作業系統載入器已將 PE 映像載入至記憶體，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data read from the stream has invalid format.">從資料流讀取的資料格式無效。</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream.">在資料流中讀取時發生錯誤。</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The stream does not support seek operations.">資料流不支援搜尋作業。</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peStream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peStream" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative or extends past the end of the stream.">
        <paramref name="size" /> 為負數或延展超過資料流的結尾。</exception>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeader">
      <summary vsli:raw="Gets the COFF header of the image.">取得映像的 COFF 標頭。</summary>
      <returns vsli:raw="The COFF header of the image.">影像的 COFF 標頭。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeaderStartOffset">
      <summary vsli:raw="Gets the byte offset from the start of the PE image to the start of the COFF header.">取得從 PE 映像開頭到 COFF 標頭開頭的位元組位移。</summary>
      <returns vsli:raw="The byte offset from the start of the PE image to the start of the COFF header.">從 PE 映射開頭到 COFF 標頭開頭的位元組位移。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeader">
      <summary vsli:raw="Gets the COR header.">取得 COR 標頭。</summary>
      <returns vsli:raw="The COR header, or &lt;see langword=&quot;null&quot; /&gt; if the image does not have one.">COR 標頭，如果影像沒有則為 <see langword="null" />。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeaderStartOffset">
      <summary vsli:raw="Gets the byte offset from the start of the image to the COR header.">取得從映像開頭到 COR 標頭的位元組位移。</summary>
      <returns vsli:raw="The byte offset from the start of the image to the COR header, or -1 if the image does not have a COR header.">從影像開頭到 COR 標頭的位元組位移; 如果影像沒有 COR 標頭，則為-1。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.GetContainingSectionIndex(System.Int32)">
      <summary vsli:raw="Searches sections of the PE image for the section that contains the specified Relative Virtual Address.">在 PE 映像區段中搜尋包含指定相對虛擬位址的區段。</summary>
      <param name="relativeVirtualAddress" vsli:raw="The relative virtual address to search for.">要搜尋的相對虛擬位址。</param>
      <returns vsli:raw="The index of the section that contains &lt;paramref name=&quot;relativeVirtualAddress&quot; /&gt;, or -1 if there the search is unsuccessful.">包含 <paramref name="relativeVirtualAddress" /> 的區段索引；如果搜尋失敗，則為 -1。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsCoffOnly">
      <summary vsli:raw="Gets a value that indicates whether the image is Coff only.">取得值，指出是否僅為 Coff 映像。</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the image is Coff only; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">如果影像僅為 Coff，則 <see langword="true" />;否則，<see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsConsoleApplication">
      <summary vsli:raw="Gets a value that indicates whether the image represents a Windows console application.">取得值，指出映像是否表示 Windows 主控台應用程式。</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the image is a Windows console applications; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">如果映射是 Windows 主控台應用程式，則 <see langword="true" />;否則，<see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsDll">
      <summary vsli:raw="Gets a value that indicates whether the image represents a dynamic link library.">取得值，指出映像是否表示動態連結程式庫。</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the image is a DLL; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">如果映射是 DLL，則 <see langword="true" />;否則，<see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsExe">
      <summary vsli:raw="Gets a value that indicates whether the image represents an executable.">取得值，指出映像是否表示可執行檔。</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the image is an executable; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">如果映射是可執行檔，則 <see langword="true" />;否則，<see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataSize">
      <summary vsli:raw="Gets the size of the CLI metadata.">取得 CLI 中繼資料大小。</summary>
      <returns vsli:raw="the size of the CLI metadata, or 0 if the image does not contain metadata.">CLI 中繼資料的大小，如果影像不包含中繼資料，則為0。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataStartOffset">
      <summary vsli:raw="Gets the offset (in bytes) from the start of the PE image to the start of the CLI metadata.">取得從 PE 映像開頭到 CLI 中繼資料開頭的位移 (以位元組為單位)。</summary>
      <returns vsli:raw="The offset (in bytes) from the start of the PE image to the start of the CLI metadata, or -1 if the image does not contain metadata.">從 PE 映射開頭到 CLI 中繼資料開頭的位移（以位元組為單位）; 如果影像不包含中繼資料，則為-1。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeader">
      <summary vsli:raw="Gets the image's PE header.">取得映像的 PE 標頭。</summary>
      <returns vsli:raw="The image's PE header, or &lt;see langword=&quot;null&quot; /&gt; if the image is COFF only.">映射的 PE 標頭，如果影像僅為 COFF，則為 <see langword="null" />。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeaderStartOffset">
      <summary vsli:raw="Gets the byte offset of the header from the start of the image.">取得映像開頭的標頭位元組位移。</summary>
      <returns vsli:raw="The byte offset of the header from the start of the image.">從影像開頭開始的標頭位元組位移。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.SectionHeaders">
      <summary vsli:raw="Gets the PE section headers.">取得 PE 區段標頭。</summary>
      <returns vsli:raw="An array containing the PE section headers.">包含 PE 區段標頭的陣列。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.TryGetDirectoryOffset(System.Reflection.PortableExecutable.DirectoryEntry,System.Int32@)">
      <summary vsli:raw="Gets the offset (in bytes) from the start of the image to the given directory data.">取得從映像開頭到指定目錄資料的位移 (以位元組為單位)。</summary>
      <param name="directory" vsli:raw="The PE directory entry.">PE 目錄項目。</param>
      <param name="offset" vsli:raw="When the method returns, contains the offset from the start of the image to the given directory data.">當此方法傳回時，會包含從映像開頭到指定目錄資料的位移。</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the directory data is found; &lt;see langword=&quot;false&quot; /&gt; otherwise.">如果找到目錄資料，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEMagic" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32Plus" />
    <member name="T:System.Reflection.PortableExecutable.PEMemoryBlock" />
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent">
      <summary vsli:raw="Reads the contents of the entire block into an array.">將整個區塊的內容讀入到陣列。</summary>
      <returns vsli:raw="An immutable byte array.">不可變的位元組陣列。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent(System.Int32,System.Int32)">
      <summary vsli:raw="Reads the contents of a part of the block into an array.">將部分的區塊內容讀入到陣列。</summary>
      <param name="start" vsli:raw="The starting position in the block.">區塊中的開頭位置。</param>
      <param name="length" vsli:raw="The number of bytes to read.">要讀取的位元組數。</param>
      <returns vsli:raw="An immutable array of bytes.">不可變的位元組陣列。</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The specified range is not contained within the block.">區塊中不包含指定的範圍。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Reflection.Metadata.BlobReader&quot; /&gt; for a blob spanning the entire block.">針對跨越整個區塊的 Blob 建立 <see cref="T:System.Reflection.Metadata.BlobReader" />。</summary>
      <returns vsli:raw="A reader for a blob spanning the entire block.">適用於跨越整個區塊的 Blob 讀取器。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader(System.Int32,System.Int32)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Reflection.Metadata.BlobReader&quot; /&gt; for a blob spanning a part of the block.">針對跨越部分區塊的 Blob 建立 <see cref="T:System.Reflection.Metadata.BlobReader" />。</summary>
      <param name="start" vsli:raw="The starting position in the block.">區塊中的開頭位置。</param>
      <param name="length" vsli:raw="The number of bytes in the portion of the block.">部分區塊的位元組數目。</param>
      <returns vsli:raw="A reader for a blob spanning a portion of the block.">適用於跨越部分區塊的 Blob 讀取器。</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The specified range is not contained within the block.">區塊中不包含指定的範圍。</exception>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Length">
      <summary vsli:raw="Gets the length of the block.">取得區塊的長度。</summary>
      <returns vsli:raw="The length of the block.">區塊的長度。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Pointer">
      <summary vsli:raw="Gets a pointer to the first byte of the block.">取得區塊的第一個位元組指標。</summary>
      <returns vsli:raw="A pointer to the first byte of the block.">區塊的第一個位元組指標。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEReader">
      <summary vsli:raw="Provides a reader for Portable Executable format (PE) files.">提供適用於可攜式可執行檔格式 (PE) 檔案的讀取器。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32)">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image stored in memory.">透過儲存在記憶體中的 PE 映像，建立可攜式可執行檔讀取器。</summary>
      <param name="peImage" vsli:raw="A pointer to the start of the PE image.">PE 映像開頭的指標。</param>
      <param name="size" vsli:raw="The size of the PE image.">PE 映像的大小。</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peImage&quot; /&gt; is &lt;see cref=&quot;F:System.IntPtr.Zero&quot; /&gt;.">
        <paramref name="peImage" /> 為 <see cref="F:System.IntPtr.Zero" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative.">
        <paramref name="size" /> 為負。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32,System.Boolean)">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image stored in memory. A flag indicates whether the image has already been loaded into memory.">透過儲存在記憶體中的 PE 映像，建立可攜式可執行檔讀取器。 旗標，指出映像是否已載入至記憶體。</summary>
      <param name="peImage" vsli:raw="A pointer to the start of the PE image.">PE 映像開頭的指標。</param>
      <param name="size" vsli:raw="The size of the PE image.">PE 映像的大小。</param>
      <param name="isLoadedImage" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the PE image has been loaded into memory by the OS loader; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">如果作業系統載入器已將 PE 映像載入至記憶體，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peImage&quot; /&gt; is &lt;see cref=&quot;F:System.IntPtr.Zero&quot; /&gt;.">
        <paramref name="peImage" /> 為 <see cref="F:System.IntPtr.Zero" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative.">
        <paramref name="size" /> 為負。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image stored in a byte array.">透過儲存在位元組陣列中的 PE 映像，建立可攜式可執行檔讀取器。</summary>
      <param name="peImage" vsli:raw="An immutable array of bytes representing the PE image.">表示 PE 映像的不可變位元組陣列。</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peImage&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peImage" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream)">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image stored in a stream.">透過儲存在資料流中的 PE 映像，建立可攜式可執行檔讀取器。</summary>
      <param name="peStream" vsli:raw="PE image stream.">PE 映像資料流。</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peStream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peStream" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image stored in a stream beginning at its current position and ending at the end of the stream.">透過儲存在記憶體中的 PE 映像，建立可攜式可執行檔讀取器，此資料流從目前位置開始，結束於資料流結尾。</summary>
      <param name="peStream" vsli:raw="A PE image stream.">PE 映像資料流。</param>
      <param name="options" vsli:raw="Options specifying how sections of the PE image are read from the stream.">指定如何從資料流讀取 PE 映像區段的選項。</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peStream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peStream" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;options&quot; /&gt; has an invalid value.">
        <paramref name="options" /> 的值無效。</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream (only when prefetching data).">在資料流中讀取時發生錯誤 (只有在預先擷取資料時)。</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;see cref=&quot;F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata&quot; /&gt; is specified, and the PE headers of the image are invalid.">已指定 <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" />，且映像的 PE 標頭無效。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions,System.Int32)">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image of the given size beginning at the stream's current position.">透過從資料流目前位置開始的指定大小 PE 映像，建立可攜式可執行檔讀取器。</summary>
      <param name="peStream" vsli:raw="A PE image stream.">PE 映像資料流。</param>
      <param name="options" vsli:raw="Options specifying how sections of the PE image are read from the stream.">指定如何從資料流讀取 PE 映像區段的選項。</param>
      <param name="size" vsli:raw="The PE image size.">PE 映像大小。</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative or extends past the end of the stream.">
        <paramref name="size" /> 為負數或延展超過資料流的結尾。</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream (only when prefetching data).">從資料流讀取時發生錯誤 (只有在預先擷取資料時)。</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;see cref=&quot;F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata&quot; /&gt; is specified, and the PE headers of the image are invalid.">已指定 <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" />，且映像的 PE 標頭無效。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.Dispose">
      <summary vsli:raw="Disposes all memory allocated by the reader.">處置所有由讀取器所配置的記憶體。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetEntireImage">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEMemoryBlock&quot; /&gt; object containing the entire PE image.">取得包含整個 PE 映像的 <see cref="T:System.Reflection.PortableExecutable.PEMemoryBlock" /> 物件。</summary>
      <returns vsli:raw="A memory block that contains the entire PE image.">包含整個 PE 映像的記憶體區塊。</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The entire PE image is not available.">整個 PE 映像無法使用。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetMetadata">
      <summary vsli:raw="Loads a PE section that contains CLI metadata.">載入包含 CLI 中繼資料的 PE 區段。</summary>
      <returns vsli:raw="A memory block that contains the CLI metadata.">包含 CLI 中繼資料的記憶體區塊。</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image doesn't contain metadata (&lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEReader.HasMetadata&quot; /&gt; returns &lt;see langword=&quot;false&quot; /&gt;).">PE 映像不包含中繼資料 (<see cref="P:System.Reflection.PortableExecutable.PEReader.HasMetadata" /> 會傳回 <see langword="false" />)。</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The PE headers contain invalid data.">PE 標頭包含無效的資料。</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">從基礎資料流讀取時出現 IO 錯誤。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.Int32)">
      <summary vsli:raw="Loads the PE section that contains the specified relative virtual address into memory and returns a memory block that starts at that address and ends at the end of the containing section.">將包含指定相對虛擬位址的 PE 區段載入至記憶體，並傳回從該位址開始，結束於包含區段結尾的記憶體區塊。</summary>
      <param name="relativeVirtualAddress" vsli:raw="The Relative Virtual Address of the data to read.">所要讀取資料的相對虛擬位址。</param>
      <returns vsli:raw="A memory block that starts at &lt;paramref name=&quot;relativeVirtualAddress&quot; /&gt; and ends at the end of the containing section, or an empty block if &lt;paramref name=&quot;relativeVirtualAddress&quot; /&gt; doesn't represent a location in any of the PE sections of this PE image.">從 <paramref name="relativeVirtualAddress" /> 開始，結束於包含區段結尾的記憶體區塊；如果 <paramref name="relativeVirtualAddress" /> 不代表這個 PE 映像任何 PE 區段中的位置，則為空的區塊。</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The PE headers contain invalid data.">PE 標頭包含無效的資料。</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="An IO error occurred while reading from the underlying stream.">在基礎資料流中讀取時發生 IO 錯誤。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image is not available.">PE 映像無法使用。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;relativeVirtualAddress&quot; /&gt; is negative.">
        <paramref name="relativeVirtualAddress" /> 為負。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.String)">
      <summary vsli:raw="Loads the PE section with the specified name into memory and returns a memory block that spans the section.">將具有指定名稱的 PE 區段載入至記憶體，並傳回跨越該區段的記憶體區塊。</summary>
      <param name="sectionName" vsli:raw="The name of the section.">區段的名稱。</param>
      <returns vsli:raw="A memory block that spans the section, or an empty block if no section of the given &lt;paramref name=&quot;sectionName&quot; /&gt; exists in this PE image.">跨越此區段的記憶體區塊；如果這個 PE 映像中沒有任何指定 <paramref name="sectionName" /> 的區段，則為空的區塊。</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;sectionName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="sectionName" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image is not available.">PE 映像無法使用。</exception>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.HasMetadata">
      <summary vsli:raw="Gets a value that indicates if the PE image contains CLI metadata.">取得值，指出 PE 映像是否包含 CLI 中繼資料。</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the PE image contains CLI metadata; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">如果 PE 映射包含 CLI 中繼資料，則 <see langword="true" />;否則，<see langword="false" />。</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The PE headers contain invalid data.">PE 標頭包含無效的資料。</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the underlying stream.">從基礎資料流讀取時發生錯誤。</exception>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsEntireImageAvailable">
      <summary vsli:raw="Gets a value that indicates if the reader can access the entire PE image.">取得值，指出讀取器是否可以存取整個 PE 映像。</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the reader can access the entire PE image; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">如果讀取器可以存取整個 PE 映射，則 <see langword="true" />：否則，<see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsLoadedImage">
      <summary vsli:raw="Gets a value that indicates if the PE image has been loaded into memory by the OS loader.">取得值，指出作業系統載入器是否已將 PE 映像載入至記憶體。</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the PE image has been loaded into memory by the OS loader; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">如果作業系統載入器已將 PE 映像載入至記憶體，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.PEHeaders">
      <summary vsli:raw="Gets the PE headers.">取得 PE 標頭。</summary>
      <returns vsli:raw="The PE headers for this PE image.">這個 PE 映射的 PE 標頭。</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The headers contain invalid data.">標頭包含無效的資料。</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream.">在資料流中讀取時發生錯誤。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadCodeViewDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary vsli:raw="Reads the data pointed to by the specified Debug Directory entry and interprets it as CodeView.">讀取由所指定偵錯目錄項目指向的資料，並轉譯為 CodeView。</summary>
      <param name="entry" vsli:raw="A Debug Directory entry instance.">偵錯目錄項目執行個體。</param>
      <returns vsli:raw="A code view debug directory data instance.">程式碼檢視偵錯目錄資料執行個體。</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;entry&quot; /&gt; is not a CodeView entry.">
        <paramref name="entry" /> 不是 CodeView 項目。</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Bad format of the data.">錯誤的資料格式。</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">從基礎資料流讀取時出現 IO 錯誤。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image is not available.">PE 映像無法使用。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadDebugDirectory">
      <summary vsli:raw="Reads all Debug Directory table entries.">讀取所有偵錯目錄資料表項目。</summary>
      <returns vsli:raw="An array of Debug Directory table entries.">偵錯目錄資料表項目陣列。</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Bad format of the entry.">錯誤的項目格式。</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">從基礎資料流讀取時出現 IO 錯誤。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image is not available.">PE 映像無法使用。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadEmbeddedPortablePdbDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary vsli:raw="Reads the data pointed to by the specified Debug Directory entry and interprets it as an Embedded Portable PDB blob.">讀取由指定偵錯目錄項目所指向的資料，並轉譯為內嵌可攜式 PDB Blob。</summary>
      <param name="entry" vsli:raw="The Debug Directory entry whose data is to be read.">無法讀取其資料的偵錯目錄項目。</param>
      <returns vsli:raw="The provider of a metadata reader for reading a Portable PDB image.">用於讀取可攜式 PDB 映像的中繼資料讀取器提供者。</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;entry&quot; /&gt; is not a &lt;see cref=&quot;F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb&quot; /&gt; entry.">
        <paramref name="entry" /> 不是 <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb" /> 項目。</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Bad format of the data.">錯誤的資料格式。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="PE image not available.">PE 映像無法使用。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadPdbChecksumDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary vsli:raw="Reads the data pointed to by the specified Debug Directory entry and interprets it as a PDB Checksum entry.">讀取由指定偵錯目錄項目所指向的資料，並轉譯為 PDB 總和檢查碼項目。</summary>
      <param name="entry" vsli:raw="The Debug Directory entry whose data is to be read.">無法讀取其資料的偵錯目錄項目。</param>
      <returns vsli:raw="The PDB Checksum entry.">PDB 總和檢查碼項目。</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;entry&quot; /&gt; is not a PDB Checksum entry.">
        <paramref name="entry" /> 不是 PDB 總和檢查碼項目。</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Bad format of the data.">錯誤的資料格式。</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">從基礎資料流讀取時出現 IO 錯誤。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image is not available.">PE 映像無法使用。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.TryOpenAssociatedPortablePdb(System.String,System.Func{System.String,System.IO.Stream},System.Reflection.Metadata.MetadataReaderProvider@,System.String@)">
      <summary vsli:raw="Opens a Portable PDB associated with this PE image.">開啟與此 PE 映像建立關聯的可攜式 PDB。</summary>
      <param name="peImagePath" vsli:raw="The path to the PE image. The path is used to locate the PDB file located in the directory containing the PE file.">PE 映像的路徑。 路徑是用來尋找 PDB 檔案，此檔案位於包含 PE 檔案的目錄中。</param>
      <param name="pdbFileStreamProvider" vsli:raw="If specified, called to open a &lt;see cref=&quot;T:System.IO.Stream&quot; /&gt; for a given file path. The provider is expected to either return a readable and seekable &lt;see cref=&quot;T:System.IO.Stream&quot; /&gt;, or &lt;see langword=&quot;null&quot; /&gt; if the target file doesn't exist or should be ignored for some reason. The provider should throw &lt;see cref=&quot;T:System.IO.IOException&quot; /&gt; if it fails to open the file due to an unexpected IO error.">如已指定，呼叫即可開啟指定檔案路徑的 <see cref="T:System.IO.Stream" />。 提供者應會傳回可讀取和可搜尋的 <see cref="T:System.IO.Stream" />，如果目標檔案不存在，或因某些原因而忽略，則傳回 <see langword="null" />。 如果提供者因未預期的 IO 錯誤而無法開啟檔案，則應該擲回 <see cref="T:System.IO.IOException" />。</param>
      <param name="pdbReaderProvider" vsli:raw="If successful, a new instance of &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; to be used to read the Portable PDB.">如果成功，就會使用 <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> 的新執行個體來讀取可攜式 PDB。</param>
      <param name="pdbPath" vsli:raw="If successful and the PDB is found in a file, the path to the file, or &lt;see langword=&quot;null&quot; /&gt; if the PDB is embedded in the PE image itself.">如果成功，且在檔案中找到 PDB，則為檔案路徑；如果 PDB 內嵌於 PE 映像本身，則為 <see langword="null" />。</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the PE image has a PDB associated with it and the PDB has been successfully opened; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">如果 PE 映像具有與其建立關聯的 PDB，且已成功開啟此 PDB，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peImagePath&quot; /&gt; or &lt;paramref name=&quot;pdbFileStreamProvider&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peImagePath" /> 或 <paramref name="pdbFileStreamProvider" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The stream returned from &lt;paramref name=&quot;pdbFileStreamProvider&quot; /&gt; doesn't support read and seek operations.">自 <paramref name="pdbFileStreamProvider" /> 傳回的資料流不支援讀取及搜尋作業。</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="No matching PDB file was found due to an error: The PE image or the PDB is invalid.">因為發生錯誤，所以找不到相符的 PDB 檔案：PE 映像或 PDB 無效。</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="No matching PDB file was found due to an error: An IO error occurred while reading the PE image or the PDB.">因為發生錯誤，所以找不到相符的 PDB 檔案：讀取 PE 映像或 PDB 時發生 IO 錯誤。</exception>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEStreamOptions">
      <summary vsli:raw="Provides options that specify how sections of a PE image are read from a stream.">提供選項，指定從資料流讀取 PE 映像區段的方式。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.Default">
      <summary vsli:raw="By default, the stream is disposed when the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; is disposed, and sections of the PE image are read lazily.">根據預設，當處置 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 之後即會處置資料流，且會延遲讀取 PE 映像的區段。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.IsLoadedImage">
      <summary vsli:raw="Indicates that the underlying PE image has been loaded into memory by the OS loader.">指出作業系統載入器已將基礎 PE 映像載入至記憶體。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen">
      <summary vsli:raw="Keeps the stream open when the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; is disposed.">當處置 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 之後保持資料流開啟。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage">
      <summary vsli:raw="Reads the entire image into memory right away. &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; closes the stream automatically by the time the constructor returns unless &lt;see cref=&quot;F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen&quot; /&gt; is specified.">立即將整個映像讀入至記憶體。 除非指定 <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" />，否則 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 會在建構函式傳回時，自動關閉資料流。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata">
      <summary vsli:raw="&lt;para&gt;Reads the metadata section into memory right away.&lt;/para&gt;&lt;para&gt;Reading from other sections of the file is not allowed (&lt;see cref=&quot;T:System.InvalidOperationException&quot; /&gt; is thrown by the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt;).&lt;/para&gt;&lt;para&gt;&lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; closes the stream automatically by the time the constructor returns unless &lt;see cref=&quot;F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen&quot; /&gt; is specified. The underlying file may be closed and even deleted after &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; is constructed.&lt;/para&gt;">立即將中繼資料區段讀入至記憶體。不允許讀取檔案的其他區段 (<see cref="T:System.Reflection.PortableExecutable.PEReader" /> 擲回 <see cref="T:System.InvalidOperationException" />)。除非指定 <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" />，否則 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 會在建構函式傳回時，自動關閉資料流。 建構 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 之後，可能會關閉甚至刪除基礎檔案。</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ResourceSectionBuilder">
      <summary vsli:raw="Defines the base class for a PE resource section builder. Derive from &lt;see cref=&quot;T:System.Reflection.PortableExecutable.ResourceSectionBuilder&quot; /&gt; to provide serialization logic for native resources.">定義 PE 資源區段產生器的基底類別。 衍生自 <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" />，為原生資源提供序列化邏輯。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.ResourceSectionBuilder&quot; /&gt; class.">初始化 <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" /> 類別的新執行個體。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.SectionLocation)">
      <summary vsli:raw="Serializes the specified resource.">序列化指定的資源。</summary>
      <param name="builder" vsli:raw="A blob that contains the data to serialize.">包含要序列化資料的 Blob。</param>
      <param name="location" vsli:raw="The location to which to serialize &lt;paramref name=&quot;builder&quot; /&gt;.">序列化 <paramref name="builder" /> 的位置。</param>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionCharacteristics" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1024Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align128Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align16Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2048Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align256Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align32Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4096Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align512Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align64Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8192Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.AlignMask" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsCode" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsInitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsUninitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.GPRel" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerComdat" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerInfo" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerNRelocOvfl" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerOther" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerRemove" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Mem16Bit" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemDiscardable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemExecute" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemFardata" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemLocked" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotCached" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotPaged" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPreload" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemProtected" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPurgeable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemRead" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemShared" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemSysheap" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemWrite" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.NoDeferSpecExc" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeCopy" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeDSect" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeGroup" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoLoad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoPad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeOver" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeReg" />
    <member name="T:System.Reflection.PortableExecutable.SectionHeader">
      <summary vsli:raw="Provides information about the section header of a PE/COFF file.">提供 PE/COFF 檔案區段標頭的相關資訊。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.Name">
      <summary vsli:raw="Gets the name of the section.">取得區段的名稱。</summary>
      <returns vsli:raw="The name of the section.">區段的名稱。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfLineNumbers">
      <summary vsli:raw="Gets the number of line-number entries for the section.">取得區段行號項目的數量。</summary>
      <returns vsli:raw="The number of line-number entries for the section.">區段的行號專案數。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfRelocations">
      <summary vsli:raw="Gets the number of relocation entries for the section.">取得區段重新配置項目的數量。</summary>
      <returns vsli:raw="The number of relocation entries for the section. Its value is zero for PE images.">區段的重新設定項目數。 針對 PE 映射，其值為零。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToLineNumbers">
      <summary vsli:raw="Gets the file pointer to the beginning of line-number entries for the section.">取得區段行號項目開頭的檔案指標。</summary>
      <returns vsli:raw="The file pointer to the beginning of line-number entries for the section, or zero if there are no COFF line numbers.">區段的行號專案開頭的檔案指標，如果沒有 COFF 行號，則為零。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRawData">
      <summary vsli:raw="Gets the file pointer to the first page of the section within the COFF file.">取得 COFF 檔案中區段第一頁的檔案指標。</summary>
      <returns vsli:raw="The file pointer to the first page of the section within the COFF file.">COFF 檔案中區段第一頁的檔案指標。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRelocations">
      <summary vsli:raw="Gets the file pointer to the beginning of relocation entries for the section.">取得區段重新配置項目開頭的檔案指標。</summary>
      <returns vsli:raw="The file pointer to the beginning of relocation entries for the section. It is set to zero for PE images or if there are no relocations.">區段的重新設定項目開始位置的檔案指標。 PE 映射的設定為零，或如果沒有重定位，則為。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SectionCharacteristics">
      <summary vsli:raw="Gets the flags that describe the characteristics of the section.">取得描述區段特性的旗標。</summary>
      <returns vsli:raw="The flags that describe the characteristics of the section.">描述區段特性的旗標。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SizeOfRawData">
      <summary vsli:raw="Gets the size of the section (for object files) or the size of the initialized data on disk (for image files).">取得區段的大小 (物件檔案)，或磁碟初始化資料的大小 (映像檔案)。</summary>
      <returns vsli:raw="The size of the section (for object files) or the size of the initialized data on disk (for image files).">區段的大小（適用于物件檔案）或磁片上的初始化資料大小（針對影像檔案）。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualAddress">
      <summary vsli:raw="Gets the virtual addess of the section.">取得區段的虛擬位址。</summary>
      <returns vsli:raw="The virtual address of the section.">區段的虛擬位址。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualSize">
      <summary vsli:raw="Gets the total size of the section when loaded into memory.">取得載入到記憶體時的區段大小總計。</summary>
      <returns vsli:raw="The total size of the section when loaded into memory.">載入記憶體時的區段大小總計。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionLocation" />
    <member name="M:System.Reflection.PortableExecutable.SectionLocation.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" vsli:raw="" />
      <param name="pointerToRawData" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.PointerToRawData" />
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.RelativeVirtualAddress" />
    <member name="T:System.Reflection.PortableExecutable.Subsystem">
      <summary vsli:raw="Describes the subsystem requirement for the image.">描述映像的子系統需求。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiApplication">
      <summary vsli:raw="Extensible Firmware Interface (EFI) application.">可延伸韌體介面 (EFI) 應用程式。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiBootServiceDriver">
      <summary vsli:raw="EFI driver with boot services.">具備開機服務的 EFI 驅動程式。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRom">
      <summary vsli:raw="EFI ROM image.">EFI ROM 映像。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRuntimeDriver">
      <summary vsli:raw="EFI driver with run-time services.">具備執行階段服務的 EFI 驅動程式。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Native">
      <summary vsli:raw="The image doesn't require a subsystem.">映像不需要子系統。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.NativeWindows">
      <summary vsli:raw="The image is a native Win9x driver.">映像是原生的 Win9x 驅動程式。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.OS2Cui">
      <summary vsli:raw="The image runs in the OS/2 character subsystem.">映像會在 OS/2 字元子系統中執行。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.PosixCui">
      <summary vsli:raw="The image runs in the Posix character subsystem.">映像會在 Posix 字元子系統中執行。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Unknown">
      <summary vsli:raw="Unknown subsystem.">未知的子系統。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsBootApplication">
      <summary vsli:raw="Boot application.">開機應用程式。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCEGui">
      <summary vsli:raw="The image runs in the Windows CE subsystem.">映像會在 Windows CE 子系統中執行。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCui">
      <summary vsli:raw="The image runs in the Windows character subsystem.">映像會在 Windows 字元子系統中執行。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsGui">
      <summary vsli:raw="The image runs in the Windows GUI subsystem.">映像會在 Windows GUI 子系統中執行。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Xbox">
      <summary vsli:raw="Xbox system.">Xbox 系統。</summary>
    </member>
  </members>
</doc>