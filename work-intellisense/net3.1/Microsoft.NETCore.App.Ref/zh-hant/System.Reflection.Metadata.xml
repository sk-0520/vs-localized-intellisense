<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Reflection.Metadata</name>
  </assembly>
  <members>
    <member name="T:System.Reflection.AssemblyFlags" />
    <member name="F:System.Reflection.AssemblyFlags.ContentTypeMask">
      <summary>與 <see cref="T:System.Reflection.AssemblyContentType" /> 的值相對應的內容類型遮罩位元。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.DisableJitCompileOptimizer">
      <summary>已停用組件的 Just-In-Time (JIT) 編譯器最佳化。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.EnableJitCompileTracking">
      <summary>已啟用組件的 Just-In-Time (JIT) 編譯器追蹤。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.PublicKey">
      <summary>組件參考會持有完整 (未雜湊) 公開金鑰。 不適用於組件定義。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.Retargetable">
      <summary>不預期執行階段所使用參考組件的實作，會符合編譯時間見到的版本。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.WindowsRuntime">
      <summary>組件包含 Windows 執行階段程式碼。</summary>
    </member>
    <member name="T:System.Reflection.AssemblyHashAlgorithm">
      <summary>指定用於雜湊化組件檔，以及產生強式名稱的雜湊演算法。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.MD5">
      <summary>擷取 MD5 訊息摘要演算法。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.None">
      <summary>指示沒有雜湊演算法的遮罩。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha1">
      <summary>接收能修正 SHA 中未發佈缺陷的安全雜湊演算法。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha256">
      <summary>接收雜湊大小為 256 位元的安全雜湊演算法版本。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha384">
      <summary>接收雜湊大小為 384 位元的安全雜湊演算法版本。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha512">
      <summary>接收雜湊大小為 512 位元的安全雜湊演算法版本。</summary>
    </member>
    <member name="T:System.Reflection.DeclarativeSecurityAction">
      <summary>指定可以使用宣告式安全性執行的安全性動作。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Assert">
      <summary>即使堆疊中較高層的呼叫端未獲授與權限存取資源，進行呼叫的程式碼仍可以存取由目前權限物件所識別的資源。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Demand">
      <summary>檢查呼叫鏈中所有呼叫是否都已經獲授與指定權限。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Deny">
      <summary>拒絕 Demand 指定的權限而不進一步檢查。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.InheritanceDemand">
      <summary>繼承類別或覆寫方法的衍生類別必須有指定權限。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.LinkDemand">
      <summary>檢查直接呼叫端是否已獲授與指定權限。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.None">
      <summary>沒有宣告式安全性動作。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.PermitOnly">
      <summary>拒絕指定權限以外的所有權限要求，而不進一步檢查。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestMinimum">
      <summary>要求執行程式碼所需的最低權限。 這個動作只能在組件的範圍內使用。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestOptional">
      <summary>要求選擇性 (非執行所需) 的其他權限。 這項要求會隱含拒絕未特別要求的所有其他權限。 這個動作只能在組件的範圍內使用。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestRefuse">
      <summary>要求不授與呼叫程式碼可能遭到誤用的權限。 這個動作只能在組件的範圍內使用。</summary>
    </member>
    <member name="T:System.Reflection.ManifestResourceAttributes" />
    <member name="F:System.Reflection.ManifestResourceAttributes.Private">
      <summary>資源不會從組件匯出。</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.Public">
      <summary>資源會從組件匯出。</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.VisibilityMask">
      <summary>只遮罩可見度相關的屬性。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ArrayShape">
      <summary>表示陣列類型的圖形。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ArrayShape.#ctor(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <summary>初始化 <see cref="T:System.Reflection.Metadata.ArrayShape" /> 結構的新執行個體。</summary>
      <param name="rank">陣列中維度的數目。</param>
      <param name="sizes">每一個維度的大小。</param>
      <param name="lowerBounds">每一個維度的下限。</param>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.LowerBounds">
      <summary>取得所有維度的下限。 後置維度未指定下限時，長度可能會小於順位。</summary>
      <returns>較低範圍的陣列。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Rank">
      <summary>取得陣列的維度數目。</summary>
      <returns>維度的數目。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Sizes">
      <summary>取得所有維度的大小。</summary>
      <returns>大小的陣列。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyDefinition" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Flags" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetDeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.PublicKey" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Equality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Inequality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFile" />
    <member name="P:System.Reflection.Metadata.AssemblyFile.ContainsMetadata">
      <summary>取得表示檔案是否包含中繼資料的值。</summary>
      <returns>如果檔案包含中繼資料，<see langword="true" />，否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFile.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyFile.HashValue">
      <summary>取得使用 <see cref="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" /> 計算的檔案內容雜湊值。</summary>
      <returns>
        <see cref="T:System.Reflection.Metadata.BlobHandle" /> 實例，代表檔案內容的雜湊值。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFile.Name">
      <summary>取得檔案名稱，包括其副檔名。</summary>
      <returns>
        <see cref="T:System.Reflection.Metadata.StringHandle" /> 實例，代表檔案名及其副檔名。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.AssemblyFileHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Equality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Inequality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection">
      <summary>代表 <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" /> 的集合。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyFileHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.AssemblyReference" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Flags" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.HashValue" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.PublicKeyOrToken" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Equality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Inequality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection">
      <summary>組件參考的集合。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyReferenceHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.Blob" />
    <member name="M:System.Reflection.Metadata.Blob.GetBytes" />
    <member name="P:System.Reflection.Metadata.Blob.IsDefault" />
    <member name="P:System.Reflection.Metadata.Blob.Length" />
    <member name="T:System.Reflection.Metadata.BlobBuilder" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.#ctor(System.Int32)">
      <param name="capacity" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Align(System.Int32)">
      <param name="alignment" />
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.AllocateChunk(System.Int32)">
      <param name="minimalSize" />
    </member>
    <member name="T:System.Reflection.Metadata.BlobBuilder.Blobs" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.Current" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.MoveNext" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.Reset" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#Blob}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerable#GetEnumerator" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#IDisposable#Dispose" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.ChunkCapacity" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Clear" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.ContentEquals(System.Reflection.Metadata.BlobBuilder)">
      <summary>將此寫入器的目前內容與另一個比較。</summary>
      <param name="other">要與此項目比較的 <see cref="T:System.Reflection.Metadata.BlobBuilder" /> 執行個體。</param>
      <returns>如果相等則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
      <exception cref="T:System.InvalidOperationException">內容是不可寫入的；建立器已與另一個連結。</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.Count" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Free" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.FreeBytes" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.FreeChunk" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.GetBlobs">
      <summary>傳回代表建立器內容之所有 Blob 的序列。</summary>
      <returns>Blob 的序列。</returns>
      <exception cref="T:System.InvalidOperationException">內容是不可寫入的；建立器已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkPrefix(System.Reflection.Metadata.BlobBuilder)">
      <param name="prefix" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="prefix" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkSuffix(System.Reflection.Metadata.BlobBuilder)">
      <param name="suffix" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="suffix" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.PadTo(System.Int32)">
      <param name="position" />
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ReserveBytes(System.Int32)">
      <summary>保留連續的位元組區塊。</summary>
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> 為負。</exception>
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray">
      <exception cref="T:System.InvalidOperationException">內容是不可寫入的；建立器已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 和 <paramref name="byteCount" /> 指定的範圍超出緩衝區內容的界限。</exception>
      <exception cref="T:System.InvalidOperationException">內容是不可寫入的；建立器已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray">
      <exception cref="T:System.InvalidOperationException">內容是不可寫入的；建立器已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 和 <paramref name="byteCount" /> 指定的範圍超出緩衝區內容的界限。</exception>
      <exception cref="T:System.InvalidOperationException">內容是不可寫入的；建立器已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.TryWriteBytes(System.IO.Stream,System.Int32)">
      <summary>嘗試將位元組序列寫入至建立器。 表示成功寫入之位元組數目的傳回值。</summary>
      <param name="source" />
      <param name="byteCount" />
      <returns>從 <paramref name="source" /> 成功寫入的位元組數目。</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> 為負。</exception>
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBoolean(System.Boolean)">
      <summary>將 <see cref="T:System.Boolean" /> 值寫入至建立器。</summary>
      <param name="value">要寫入的值。</param>
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteByte(System.Byte)">
      <summary>將 <see cref="T:System.Byte" /> 值寫入至建立器。</summary>
      <param name="value">要寫入的值。</param>
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte*,System.Int32)">
      <summary>將緩衝區的指定位元組數目寫入至建立器。</summary>
      <param name="buffer" />
      <param name="byteCount">要寫入的位元組數。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> 為負。</exception>
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte,System.Int32)">
      <summary>將位元組值以指定的出現次數寫入建立器。</summary>
      <param name="value" />
      <param name="byteCount">要寫入之 <paramref name="value" /> 的出現次數。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> 為負。</exception>
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[])">
      <summary>將位元組陣列的內容寫入至建立器。</summary>
      <param name="buffer">要寫入的位元組陣列。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <summary>將陣列中從指定索引開始的指定位元組數目，寫入至建立器。</summary>
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount">要寫入的位元組數。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 和 <paramref name="byteCount" /> 指定的範圍超出 <paramref name="buffer" /> 的界限。</exception>
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>將不可變位元組陣列的內容寫入至建立器。</summary>
      <param name="buffer">要寫入的陣列。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <summary>將不可變陣列中從指定索引開始的指定位元組數目，寫入至建立器。</summary>
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount">要寫入的位元組數。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 和 <paramref name="byteCount" /> 指定的範圍超出 <paramref name="buffer" /> 的界限。</exception>
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedInteger(System.Int32)">
      <summary>依 ECMA-335-II 章節 23.2 的定義，實作已壓縮不帶正負號的整數編碼：Blob 和簽章。</summary>
      <param name="value">要寫入的值。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> 不能表示為已壓縮不帶正負號的整數。</exception>
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedSignedInteger(System.Int32)">
      <summary>依 ECMA-335-II 章節 23.2 的定義，實作已壓縮帶正負號的整數編碼：Blob 和簽章。</summary>
      <param name="value">要寫入的值。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> 不能表示為已壓縮帶正負號的整數。</exception>
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteConstant(System.Object)">
      <summary>在目前位置寫入常數值 (請參閱 ECMA-335 第二篇章節 22.9)。</summary>
      <param name="value">要寫入的常數值。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> 不是常數型別。</exception>
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.IO.Stream)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">內容是不可寫入的，建立器已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobBuilder)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">內容是不可寫入的，建立器已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobWriter@)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" /> 是預設值 (請參閱 <see cref="T:System.Reflection.Metadata.BlobWriter" />)。</exception>
      <exception cref="T:System.InvalidOperationException">內容是不可寫入的，建立器已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDateTime(System.DateTime)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDecimal(System.Decimal)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDouble(System.Double)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteGuid(System.Guid)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16(System.Int16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16BE(System.Int16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32(System.Int32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32BE(System.Int32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt64(System.Int64)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteReference(System.Int32,System.Boolean)">
      <summary>將參考寫入堆積 (堆積位移) 或表格 (列號)。</summary>
      <param name="reference">堆積位移或表格列號。</param>
      <param name="isSmall">設定為 <see langword="true" /> 會將參考以 16 位元整數編碼；<see langword="false" /> 會將參考以 32 位元整數編碼。</param>
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSByte(System.SByte)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSerializedString(System.String)">
      <summary>以 SerString 格式 (請參閱 ECMA-335-II 23.3 自訂屬性) 寫入字串。</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSingle(System.Single)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16(System.UInt16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16BE(System.UInt16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32(System.UInt32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32BE(System.UInt32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt64(System.UInt64)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUserString(System.String)">
      <summary>以使用者字串 (#US) 堆積格式 (請參閱 ECMA-335-II 24.2.4 #US 和 #Blob 堆積)。</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.Char[])">
      <summary>在目前位置寫入 UTF16 (字元組由小到大) 編碼的字元陣列。</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.String)">
      <summary>在目前位置寫入 UTF16 (字元組由小到大) 編碼的字串。</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF8(System.String,System.Boolean)">
      <summary>在目前位置寫入 UTF8 編碼的字串。</summary>
      <param name="value">常數值。</param>
      <param name="allowUnpairedSurrogates">設定為 <see langword="true" /> 會以指定方式編碼非成對代理字元；<see langword="false" /> 會以 U+FFFD 字元取代它們。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="T:System.Reflection.Metadata.BlobContentId" />
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Byte[])">
      <param name="id" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="id" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Guid,System.UInt32)">
      <param name="guid" />
      <param name="stamp" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Reflection.Metadata.BlobContentId)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Byte[])">
      <param name="hashCode" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="hashCode" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.GetHashCode" />
    <member name="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />
    <member name="P:System.Reflection.Metadata.BlobContentId.Guid" />
    <member name="P:System.Reflection.Metadata.BlobContentId.IsDefault" />
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Equality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Inequality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobContentId.Stamp" />
    <member name="T:System.Reflection.Metadata.BlobHandle" />
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Reflection.Metadata.BlobHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.BlobHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Equality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Implicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Inequality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.BlobReader" />
    <member name="M:System.Reflection.Metadata.BlobReader.#ctor(System.Byte*,System.Int32)">
      <summary>建立指定記憶體區塊的讀取器。</summary>
      <param name="buffer">記憶體區塊開頭的指標。</param>
      <param name="length">記憶體區塊的長度，以位元組為單位。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> 是 <see langword="null" />，且 <paramref name="length" /> 大於零。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> 為負。</exception>
      <exception cref="T:System.PlatformNotSupportedException">目前的平台不是位元組由小到大。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Align(System.Byte)">
      <summary>以滿足所給定對齊方式所需的位元組數目，將讀取器向前重新定位。</summary>
      <param name="alignment" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.CurrentPointer">
      <summary>取得讀取器目前位置的指標。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.IndexOf(System.Byte)">
      <summary>在目前位置後面的 Blob 中搜尋指定位元組。</summary>
      <param name="value">要尋找的位元組值。</param>
      <returns>相對於目前位置的索引，如果在目前位置後面的 Blob 找不到該位元組，則為 -1。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Length">
      <summary>取得基礎記憶體的長度。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Offset">
      <summary>取得或設定從 Blob 開頭開始至目前位置的位移。</summary>
      <exception cref="T:System.BadImageFormatException">位移設定在基礎讀取器界限外。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBlobHandle">
      <summary>讀取編碼為已壓縮整數的 Blob 堆積控制代碼。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBoolean" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32)">
      <summary>讀取從目前位置開始的位元組。</summary>
      <param name="byteCount">要讀取的位元組數。</param>
      <returns>位元組陣列。</returns>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> 位元無法使用。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32,System.Byte[],System.Int32)">
      <summary>從目前位置開始讀取位元組，並在指定緩衝區的指定位移處開始將它們寫入。</summary>
      <param name="byteCount">要讀取的位元組數。</param>
      <param name="buffer">所讀取位元組將會寫入的目的地緩衝區。</param>
      <param name="bufferOffset">所讀取位元組將會寫入之目的地緩衝區中的位移。</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> 位元無法使用。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadChar" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedInteger">
      <summary>讀取不帶正負號的已壓縮整數值。 請參閱《中繼資料規格》章節 II.23.2：Blob 和簽章。</summary>
      <returns>所讀取已壓縮整數的值。</returns>
      <exception cref="T:System.BadImageFormatException">目前位置的資料不是有效的已壓縮整數。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedSignedInteger">
      <summary>讀取帶正負號的已壓縮整數值。 請參閱《中繼資料規格》章節 II.23.2：Blob 和簽章。</summary>
      <returns>所讀取已壓縮整數的值。</returns>
      <exception cref="T:System.BadImageFormatException">目前位置的資料不是有效的已壓縮整數。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadConstant(System.Reflection.Metadata.ConstantTypeCode)">
      <summary>從目前位置讀取常數值 (請參閱 ECMA-335 第二篇章節 22.9)。</summary>
      <param name="typeCode" />
      <returns>Boxed 常數值。 若要避免配置物件，請直接使用 Read* 方法。</returns>
      <exception cref="T:System.BadImageFormatException">讀取 Blob 時發生錯誤。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="typeCode" /> 不是有效的 <see cref="T:System.Reflection.Metadata.ConstantTypeCode" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDateTime" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDecimal">
      <summary>讀取 <see cref="T:System.Decimal" /> 數字。</summary>
      <exception cref="T:System.BadImageFormatException">目前位置的資料不是有效的 <see cref="T:System.Decimal" /> 數字。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDouble" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadGuid" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializationTypeCode">
      <summary>讀取以序列化自訂屬性值編碼的類型代碼。</summary>
      <returns>如果編碼無效，則為 <see cref="F:System.Reflection.Metadata.SerializationTypeCode.Invalid" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializedString">
      <summary>將字串讀取成編碼為已壓縮整數，包含其長度接著其內容 (UTF8)。 Null 字串會編碼為單一 0xFF 位元組。</summary>
      <returns>字串值，或 <see langword="null" />。</returns>
      <exception cref="T:System.BadImageFormatException">編碼無效。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureHeader" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureTypeCode">
      <summary>讀取以簽章編碼的類型代碼。</summary>
      <returns>如果編碼有效，類型代碼會以序列化自訂屬性值編碼，如果編碼無效，則為 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSingle" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadTypeHandle">
      <summary>將使用簽章編碼的類型控制代碼讀取為 TypeDefOrRefOrSpecEncoded (請參閱 ECMA-335 II.23.2.8)。</summary>
      <returns>當編碼有效時為該控制代碼。 否則是 <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> 屬性為 <see langword="true" /> 的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF16(System.Int32)">
      <summary>從目前位置開始讀取 UTF16 (字元組由小到大) 編碼的字串。</summary>
      <param name="byteCount">要讀取的位元組數。</param>
      <returns>字串。</returns>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> 位元無法使用。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF8(System.Int32)">
      <summary>從目前位置開始讀取 UTF8 編碼的字串。</summary>
      <param name="byteCount">要讀取的位元組數。</param>
      <returns>字串。</returns>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> 位元無法使用。</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.RemainingBytes">
      <summary>取得從目前位置到基礎記憶體區塊結尾的剩餘位元組數目。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Reset">
      <summary>將讀取器重新定位至基礎記憶體區塊的開頭。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.StartPointer">
      <summary>取得基礎記憶體區塊開頭處位元組的指標。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedInteger(System.Int32@)">
      <summary>讀取不帶正負號的已壓縮整數值。 請參閱《中繼資料規格》章節 II.23.2：Blob 和簽章。</summary>
      <param name="value">所讀取已壓縮整數的值。</param>
      <returns>如果成功讀取該值，即為 <see langword="true" />。 如果目前位置的資料不是有效的已壓縮整數，則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedSignedInteger(System.Int32@)">
      <summary>讀取帶正負號的已壓縮整數值。 請參閱《中繼資料規格》章節 II.23.2：Blob 和簽章。</summary>
      <param name="value">所讀取已壓縮整數的值。</param>
      <returns>如果成功讀取該值，即為 <see langword="true" />。 如果目前位置的資料不是有效的已壓縮整數，則為 <see langword="false" />。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.BlobWriter" />
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[])">
      <param name="buffer" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="count" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Int32)">
      <param name="size" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Reflection.Metadata.Blob)">
      <param name="blob" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.Align(System.Int32)">
      <param name="alignment" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.Blob" />
    <member name="M:System.Reflection.Metadata.BlobWriter.Clear" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ContentEquals(System.Reflection.Metadata.BlobWriter)">
      <summary>將此寫入器的目前內容與另一個比較。</summary>
      <param name="other" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.Length" />
    <member name="P:System.Reflection.Metadata.BlobWriter.Offset" />
    <member name="M:System.Reflection.Metadata.BlobWriter.PadTo(System.Int32)">
      <param name="offset" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.RemainingBytes" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 和 <paramref name="byteCount" /> 指定的範圍超出緩衝區內容的界限。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 和 <paramref name="byteCount" /> 指定的範圍超出緩衝區內容的界限。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBoolean(System.Boolean)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteByte(System.Byte)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte*,System.Int32)">
      <param name="buffer" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> 為負。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte,System.Int32)">
      <param name="value" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> 為負。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[])">
      <param name="buffer" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 和 <paramref name="byteCount" /> 指定的範圍超出 <paramref name="buffer" /> 的界限。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="buffer" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 和 <paramref name="byteCount" /> 指定的範圍超出 <paramref name="buffer" /> 的界限。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.IO.Stream,System.Int32)">
      <param name="source" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> 為負。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Reflection.Metadata.BlobBuilder)">
      <param name="source" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedInteger(System.Int32)">
      <summary>依 ECMA-335-II 章節 23.2 的定義，實作已壓縮不帶正負號的整數編碼：Blob 和簽章。</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> 不能表示為已壓縮不帶正負號的整數。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedSignedInteger(System.Int32)">
      <summary>依 ECMA-335-II 章節 23.2 的定義，實作已壓縮帶正負號的整數編碼：Blob 和簽章。</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> 不能表示為已壓縮帶正負號的整數。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteConstant(System.Object)">
      <summary>在目前位置寫入常數值 (請參閱 ECMA-335 第二篇章節 22.9)。</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> 不是常數型別。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDateTime(System.DateTime)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDecimal(System.Decimal)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDouble(System.Double)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteGuid(System.Guid)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16(System.Int16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16BE(System.Int16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32(System.Int32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32BE(System.Int32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt64(System.Int64)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteReference(System.Int32,System.Boolean)">
      <summary>將參考寫入堆積 (堆積位移) 或表格 (列號)。</summary>
      <param name="reference">堆積位移或表格列號。</param>
      <param name="isSmall">設定為 <see langword="true" /> 會將參考以 16 位元整數編碼；<see langword="false" /> 會將參考以 32 位元整數編碼。</param>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSByte(System.SByte)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSerializedString(System.String)">
      <summary>以 SerString 格式 (請參閱 ECMA-335-II 23.3 自訂屬性) 寫入字串。</summary>
      <param name="str" />
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的；它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSingle(System.Single)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16(System.UInt16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16BE(System.UInt16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32(System.UInt32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32BE(System.UInt32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt64(System.UInt64)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)">
      <summary>以使用者字串 (#US) 堆積格式 (請參閱 ECMA-335-II 24.2.4 #US 和 #Blob 堆積)。</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">建立器是不可寫入的，它已與另一個連結。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.Char[])">
      <summary>在目前位置寫入 UTF16 (字元組由小到大) 編碼的字串。</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.String)">
      <summary>在目前位置寫入 UTF16 (字元組由小到大) 編碼的字串。</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF8(System.String,System.Boolean)">
      <summary>在目前位置寫入 UTF8 編碼的字串。</summary>
      <param name="value" />
      <param name="allowUnpairedSurrogates" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Constant" />
    <member name="P:System.Reflection.Metadata.Constant.Parent">
      <summary>取得父代控制代碼 (<see cref="T:System.Reflection.Metadata.ParameterHandle" />、<see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />)。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.TypeCode">
      <summary>取得識別常數值型別的型別代碼。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.Value">
      <summary>取得常數值。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ConstantHandle" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Reflection.Metadata.ConstantHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ConstantHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Equality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Inequality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.ConstantTypeCode">
      <summary>指定表示中繼資料常數類型的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Boolean">
      <summary>布林型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Byte">
      <summary>不帶正負號的 1 位元整數。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Char">
      <summary>字元類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Double">
      <summary>8 位元浮點數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int16">
      <summary>帶正負號的 2 位元整數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int32">
      <summary>帶正負號的 4 位元整數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int64">
      <summary>帶正負號的 8 位元整數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Invalid">
      <summary>類型無效。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.NullReference">
      <summary>null 參考。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.SByte">
      <summary>帶正負號的 1 位元整數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Single">
      <summary>4 位元浮點數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.String">
      <summary>
        <see cref="T:System.String" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt16">
      <summary>不帶正負號的 2 位元整數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt32">
      <summary>不帶正負號的 4 位元整數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt64">
      <summary>不帶正負號的 8 位元整數類型。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttribute" />
    <member name="P:System.Reflection.Metadata.CustomAttribute.Constructor">
      <summary>取得自訂屬性的建構函式 (<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />)。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttribute.DecodeValue``1(System.Reflection.Metadata.ICustomAttributeTypeProvider{``0})">
      <summary>解碼值 Blob 中編碼的引數。</summary>
      <param name="provider" />
      <typeparam name="TType" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Parent">
      <summary>取得套用屬性之中繼資料實體的控制代碼。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Value">
      <summary>取得屬性值。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandle" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.CustomAttributeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Equality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Inequality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection" />
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomAttributeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1">
      <summary>表示從自訂屬性簽章解碼的具名引數。</summary>
      <typeparam name="TType">用來表示從自訂屬性簽章解碼之數值型別的類型。</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeNamedArgument`1.#ctor(System.String,System.Reflection.Metadata.CustomAttributeNamedArgumentKind,`0,System.Object)">
      <summary>使用指定的名稱、種類、型別和值，將 <see cref="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1" /> 結構的新執行個體初始化。</summary>
      <param name="name">引數的名稱。</param>
      <param name="kind">引數種類。</param>
      <param name="type">引數型別。</param>
      <param name="value">引數的值。</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Kind">
      <summary>取得引數種類。</summary>
      <returns>引數種類。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Name">
      <summary>取得引數名稱。</summary>
      <returns>引數名稱。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Type">
      <summary>取得引數型別。</summary>
      <returns>引數類型。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Value">
      <summary>取得引數的值。</summary>
      <returns>包含引數值的物件。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgumentKind">
      <summary>指定在自訂屬性簽章中定義引數種類的常數。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Field">
      <summary>欄位引數。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Property">
      <summary>屬性引數。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1">
      <summary>表示自訂中繼資料屬性的具型別引數。</summary>
      <typeparam name="TType">引數型別。</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeTypedArgument`1.#ctor(`0,System.Object)">
      <summary>使用指定的引數類型與值，將 <see cref="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1" /> 結構的新執行個體初始化。</summary>
      <param name="type">引數型別。</param>
      <param name="value">引數值。</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Type">
      <summary>取得引數型別。</summary>
      <returns>引數型別。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Value">
      <summary>取得引數的值。</summary>
      <returns>引數值。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeValue`1">
      <summary>表示 <paramref name="TType" /> 所指定類型的自訂屬性。</summary>
      <typeparam name="TType">屬性類型。</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeValue`1.#ctor(System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeTypedArgument{`0}},System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeNamedArgument{`0}})">
      <summary>使用指定的固定引數與具名引數，將 <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" /> 結構的新執行個體初始化。</summary>
      <param name="fixedArguments">固定引數。</param>
      <param name="namedArguments">具名引數。</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.FixedArguments">
      <summary>取得自訂屬性的固定引數。</summary>
      <returns>引數的不可變數組。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.NamedArguments">
      <summary>取得自訂屬性值的具名引數。</summary>
      <returns>引數的不可變數組。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Kind" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Parent" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Value" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Equality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Inequality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomDebugInformationHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.DebugMetadataHeader" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.EntryPoint" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.Id" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.IdStartOffset">
      <summary>取得從中繼資料 Blob 開始到 <see cref="P:System.Reflection.Metadata.DebugMetadataHeader.Id" /> Blob 開頭的位移 (以位元組為單位)。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttribute" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Action" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Parent" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.PermissionSet" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Equality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Inequality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DeclarativeSecurityAttributeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.Document">
      <summary>偵錯中繼資料中的來源文件。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Hash">
      <summary>取得文件內容雜湊。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.HashAlgorithm">
      <summary>取得用來計算 <see cref="P:System.Reflection.Metadata.Document.Hash" /> (SHA1、SHA256 等) 的雜湊演算法。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Language">
      <summary>取得原始程式碼語言 (C#、VB、F# 等)。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Name">
      <summary>取得文件名稱 Blob。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandle" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Reflection.Metadata.DocumentHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.DocumentHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Equality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Inequality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection" />
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DocumentHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.DocumentNameBlobHandle">
      <summary>
        <see cref="T:System.Reflection.Metadata.BlobHandle" />，它代表可攜式 PDB 中 #Blob 堆積上的 Blob (結構化為文件名稱)。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.DocumentNameBlobHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Equality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Explicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.DocumentNameBlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Implicit(System.Reflection.Metadata.DocumentNameBlobHandle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Inequality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Shape(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <param name="rank" />
      <param name="sizes" />
      <param name="lowerBounds" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.BlobEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.BlobEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Action{System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder},System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder})">
      <param name="fixedArguments" />
      <param name="namedArguments" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder@,System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder@)">
      <param name="fixedArguments" />
      <param name="namedArguments" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.LocalVariableSignature(System.Int32)">
      <param name="variableCount" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSignature(System.Reflection.Metadata.SignatureCallingConvention,System.Int32,System.Boolean)">
      <param name="convention" />
      <param name="genericParameterCount" />
      <param name="isInstanceMethod" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSpecificationSignature(System.Int32)">
      <param name="genericArgumentCount" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetArguments(System.Int32)">
      <param name="argumentCount" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetBlob(System.Int32)">
      <param name="attributeCount" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PropertySignature(System.Boolean)">
      <param name="isInstanceProperty" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.TypeSpecificationSignature" />
    <member name="T:System.Reflection.Metadata.Ecma335.CodedIndex" />
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.CustomAttributeType(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasConstant(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomAttribute(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasDeclSecurity(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasFieldMarshal(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasSemantics(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.Implementation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberForwarded(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberRefParent(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MethodDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.ResolutionScope(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRefOrSpec(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeOrMethodDef(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.#ctor" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddCatchRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="tryStart" />
      <param name="tryEnd" />
      <param name="handlerStart" />
      <param name="handlerEnd" />
      <param name="catchType" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFaultRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="tryStart" />
      <param name="tryEnd" />
      <param name="handlerStart" />
      <param name="handlerEnd" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFilterRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="tryStart" />
      <param name="tryEnd" />
      <param name="handlerStart" />
      <param name="handlerEnd" />
      <param name="filterStart" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFinallyRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="tryStart" />
      <param name="tryEnd" />
      <param name="handlerStart" />
      <param name="handlerEnd" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ElementType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ObjectArray" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Boolean" />
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Enum(System.String)">
      <param name="enumTypeName" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveSerializationTypeCode)">
      <param name="type" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SystemType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt64" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Count(System.Int32)">
      <param name="count" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.AddModifier(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <param name="type" />
      <param name="isOptional" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry" />
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.#ctor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="handle" />
      <param name="operation" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Handle" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Operation" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueOperation" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddEvent" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddField" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddParameter" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddProperty" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.Default" />
    <member name="T:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Add(System.Reflection.Metadata.ExceptionRegionKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <param name="kind" />
      <param name="tryOffset" />
      <param name="tryLength" />
      <param name="handlerOffset" />
      <param name="handlerLength" />
      <param name="catchType" />
      <param name="filterOffset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddCatch(System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle)">
      <param name="tryOffset" />
      <param name="tryLength" />
      <param name="handlerOffset" />
      <param name="handlerLength" />
      <param name="catchType" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFault(System.Int32,System.Int32,System.Int32,System.Int32)">
      <param name="tryOffset" />
      <param name="tryLength" />
      <param name="handlerOffset" />
      <param name="handlerLength" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFilter(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <param name="tryOffset" />
      <param name="tryLength" />
      <param name="handlerOffset" />
      <param name="handlerLength" />
      <param name="filterOffset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFinally(System.Int32,System.Int32,System.Int32,System.Int32)">
      <param name="tryOffset" />
      <param name="tryLength" />
      <param name="handlerOffset" />
      <param name="handlerLength" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.HasSmallFormat" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallExceptionRegion(System.Int32,System.Int32)">
      <param name="startOffset" />
      <param name="length" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallRegionCount(System.Int32)">
      <param name="exceptionRegionCount" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions.GetTypeDefinitionId(System.Reflection.Metadata.ExportedType)">
      <param name="exportedType" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasExplicitThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.None" />
    <member name="T:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.HeapIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Blob" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Guid" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.String" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.UserString" />
    <member name="T:System.Reflection.Metadata.Ecma335.InstructionEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.Ecma335.ControlFlowBuilder)">
      <param name="codeBuilder" />
      <param name="controlFlowBuilder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="code" />
      <param name="label" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.EntityHandle)">
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.CallIndirect(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="signature" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.CodeBuilder" />
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" />
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel" />
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgument(System.Int32)">
      <param name="argumentIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgumentAddress(System.Int32)">
      <param name="argumentIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI4(System.Int32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI8(System.Int64)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR4(System.Single)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR8(System.Double)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocal(System.Int32)">
      <param name="slotIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocalAddress(System.Int32)">
      <param name="slotIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="label" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.Offset" />
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.OpCode(System.Reflection.Metadata.ILOpCode)">
      <param name="code" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreArgument(System.Int32)">
      <param name="argumentIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreLocal(System.Int32)">
      <param name="slotIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Int32)">
      <param name="token" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LabelHandle" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.Id">
      <summary>以 1 為基礎的識別碼，用來識別 <see cref="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" /> 內容中的標籤。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Equality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Inequality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralEncoder">
      <summary>提供編碼常值的方法。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder">使用指定的 Blob 建立器，來建立 <see cref="T:System.Reflection.Metadata.Ecma335.LiteralEncoder" /> 類別的新執行個體。</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Scalar">
      <summary>傳回用來編碼常值的編碼器。</summary>
      <returns>常值的編碼器。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ScalarEncoder})">
      <summary>使用指定的委派來編碼常值的類型和值。</summary>
      <param name="type">用來編碼常值類型的委派。 其為此方法第一個呼叫的委派。</param>
      <param name="scalar">用來編碼常值的委派。 其為此方法第二個呼叫的委派。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder@,System.Reflection.Metadata.Ecma335.ScalarEncoder@)">
      <summary>傳回一對編碼器，必須使用這對編碼器來依常值類型和其值出現在參數清單中的順序來加以編碼。</summary>
      <param name="type">當此方法傳回時，則為用來編碼常值類型的自訂屬性項目類型編碼器。</param>
      <param name="scalar">當此方法傳回時，則為用來編碼常值的編碼純量。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.VectorEncoder})">
      <summary>使用指定的委派來編碼向量常值的類型和項目。</summary>
      <param name="arrayType">用來編碼向量類型的委派。 其為此方法第一個呼叫的委派。</param>
      <param name="vector">用來編碼向量項目的委派。 其為此方法第二個呼叫的委派。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder@,System.Reflection.Metadata.Ecma335.VectorEncoder@)">
      <summary>傳回一對編碼器，必須使用這對編碼器來依向量常值類型和其項目出現在參數清單中的順序來加以編碼。</summary>
      <param name="arrayType">當此方法傳回時，則為用來編碼向量類型的自訂屬性陣列類型編碼器。</param>
      <param name="vector">當此方法傳回時，則為用來編碼向量項目的向量編碼器。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Vector">
      <summary>取得用來編碼向量項目的向量編碼器。</summary>
      <returns>用來編碼向量項目的向量編碼器。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.AddLiteral" />
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.AddVariable" />
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Type(System.Boolean,System.Boolean)">
      <param name="isByRef" />
      <param name="isPinned" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.TypedReference" />
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataAggregator" />
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseTableRowCounts" />
      <param name="baseHeapSizes" />
      <param name="deltaReaders" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Reflection.Metadata.MetadataReader,System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseReader" />
      <param name="deltaReaders" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.GetGenerationHandle(System.Reflection.Metadata.Handle,System.Int32@)">
      <summary>指定彙總中繼資料中實體的控制代碼，以計算在其中定義該實體中繼資料產生內該實體的控制代碼。</summary>
      <param name="handle">彙總中繼資料中實體的控制代碼。</param>
      <param name="generation">在其中定義實體的產生。</param>
      <returns>中繼資料 <paramref name="generation" /> 內實體的控制代碼。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataBuilder">
      <summary>MetadataBuilder 類別會以高效能方式來讀取及寫入組件的中繼資料。 其設計目的是要供編譯器和其他組件產生工具使用。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>建立用於中繼資料表和堆積的產生器。</summary>
      <param name="userStringHeapStartOffset">使用者字串堆積的起始位移。 除非中繼資料為 EnC 差異中繼資料，否則所有先前 EnC 產生的使用者字串堆積累計大小應為 0。</param>
      <param name="stringHeapStartOffset">字串堆積的起始位移。 除非中繼資料為 EnC 差異中繼資料，否則所有先前 EnC 產生的字串堆積累計大小應為 0。</param>
      <param name="blobHeapStartOffset">Blob 堆積的起始位移。 除非中繼資料為 EnC 差異中繼資料，否則所有先前 EnC 產生的 Blob 堆積累計大小應為 0。</param>
      <param name="guidHeapStartOffset">GUID 堆積的起始位移。 除非中繼資料為 EnC 差異中繼資料，否則所有先前 EnC 產生的 GUID 堆積累計大小應為 0。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssembly(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.AssemblyHashAlgorithm)">
      <param name="name" />
      <param name="version" />
      <param name="culture" />
      <param name="publicKey" />
      <param name="flags" />
      <param name="hashAlgorithm" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyFile(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Boolean)">
      <param name="name" />
      <param name="hashValue" />
      <param name="containsMetadata" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyReference(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.Metadata.BlobHandle)">
      <param name="name" />
      <param name="version" />
      <param name="culture" />
      <param name="publicKeyOrToken" />
      <param name="flags" />
      <param name="hashValue" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddConstant(System.Reflection.Metadata.EntityHandle,System.Object)">
      <summary>新增參數、欄位或屬性的預設值。</summary>
      <param name="parent">父實體控制代碼，可能是下列其中一項：<see cref="T:System.Reflection.Metadata.ParameterHandle" />、<see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />。</param>
      <param name="value">常數值。</param>
      <returns>已新增之常數的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>新增自訂屬性。</summary>
      <param name="parent">要附加自訂屬性的實體：<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.ParameterHandle" />、<see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />、<see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />、<see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />、<see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />、<see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />、<see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />、<see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />、<see cref="T:System.Reflection.Metadata.GenericParameterHandle" />、<see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" /> 或 <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />。</param>
      <param name="constructor">自訂屬性建構函式：<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />。</param>
      <param name="value">自訂屬性值 Blob。</param>
      <returns>已新增之自訂屬性的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomDebugInformation(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>新增自訂偵錯資訊。</summary>
      <param name="parent">要附加偵錯資訊的實體：<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.ParameterHandle" />、<see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />、<see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />、<see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />、<see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />、<see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />、<see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />、<see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />、<see cref="T:System.Reflection.Metadata.GenericParameterHandle" />、<see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />、<see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />、<see cref="T:System.Reflection.Metadata.DocumentHandle" />、<see cref="T:System.Reflection.Metadata.LocalScopeHandle" />、<see cref="T:System.Reflection.Metadata.LocalVariableHandle" />、<see cref="T:System.Reflection.Metadata.LocalConstantHandle" /> 或 <see cref="T:System.Reflection.Metadata.ImportScopeHandle" />。</param>
      <param name="kind">資訊種類。 判斷 <paramref name="value" /> Blob 的結構。</param>
      <param name="value">自訂偵錯資訊 Blob。</param>
      <returns>已新增之自訂偵錯資訊的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDeclarativeSecurityAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.DeclarativeSecurityAction,System.Reflection.Metadata.BlobHandle)">
      <summary>將宣告式安全性屬性新增至類型、方法或組件。</summary>
      <param name="parent">父實體控制代碼，可能是下列其中一項：<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />。</param>
      <param name="action">宣告式安全性動作。</param>
      <param name="permissionSet">權限集合 Blob。</param>
      <returns>已新增之宣告式安全性屬性的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDocument(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle)">
      <summary>新增文件偵錯資訊。</summary>
      <param name="name">文件名稱 Blob。</param>
      <param name="hashAlgorithm">用來計算 <paramref name="hash" /> 值之雜湊演算法的 GUID。</param>
      <param name="hash">文件內容的雜湊。</param>
      <param name="language">語言的 GUID。</param>
      <returns>已新增之文件的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncLogEntry(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="entity" />
      <param name="code" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncMapEntry(System.Reflection.Metadata.EntityHandle)">
      <param name="entity" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEvent(System.Reflection.EventAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>新增事件定義。</summary>
      <param name="attributes">事件屬性。</param>
      <param name="name">事件名稱。</param>
      <param name="type">事件的類型：<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />。</param>
      <returns>已新增之事件定義的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEventMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="declaringType" />
      <param name="eventList" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddExportedType(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <summary>新增匯出類型。</summary>
      <param name="attributes">類型屬性。</param>
      <param name="namespace">類型命名空間。</param>
      <param name="name">類型名稱。</param>
      <param name="implementation">實作實體控制代碼，可能是下列其中一項：<see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />、<see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> 或 <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />。</param>
      <param name="typeDefinitionId">類型定義識別碼。</param>
      <returns>已新增之匯出類型的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldDefinition(System.Reflection.FieldAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>新增欄位定義。</summary>
      <param name="attributes">欄位屬性。</param>
      <param name="name">欄位名稱。</param>
      <param name="signature">欄位簽章。 使用 <see cref="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature" /> 來建構 Blob。</param>
      <returns>已新增之欄位定義的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldLayout(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary>定義欄位定義的欄位配置。</summary>
      <param name="field">欄位定義控制代碼。</param>
      <param name="offset">宣告類型執行個體中欄位的位元組位移。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldRelativeVirtualAddress(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary>新增對應 (從欄位到其儲存在 PE 映像中的初始值)。</summary>
      <param name="field">欄位定義控制代碼。</param>
      <param name="offset">PE 映像中儲存對應欄位初始值的區塊內位移 (通常是在 .text 區段中)。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameter(System.Reflection.Metadata.EntityHandle,System.Reflection.GenericParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary>新增泛型參數定義。</summary>
      <param name="parent">父實體控制代碼，可能是 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />。</param>
      <param name="attributes">泛型參數屬性。</param>
      <param name="name">參數名稱。</param>
      <param name="index">以零起始的參數索引。</param>
      <returns>已新增之泛型參數的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameterConstraint(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>將類型條件約束新增至泛型參數。</summary>
      <param name="genericParameter">要限制的泛型參數。</param>
      <param name="constraint">類型條件約束，可以是下列其中一項：<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />。</param>
      <returns>已新增之泛型參數條件約束的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddImportScope(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>新增本機範圍偵錯資訊。</summary>
      <param name="parentScope">父範圍控制代碼。</param>
      <param name="imports">匯入範圍控制代碼。</param>
      <returns>已新增之匯入範圍的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddInterfaceImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>將介面實作新增至類型。</summary>
      <param name="type">實作介面的類型。</param>
      <param name="implementedInterface">所實作的介面，可以是下列其中一項：<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />。</param>
      <returns>已新增之介面實作的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalConstant(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>新增本機常數偵錯資訊。</summary>
      <param name="name">變數的名稱。</param>
      <param name="signature">LocalConstantSig Blob。</param>
      <returns>已新增之本機常數的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalScope(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalConstantHandle,System.Int32,System.Int32)">
      <summary>新增本機範圍偵錯資訊。</summary>
      <param name="method">內含方法。</param>
      <param name="importScope">相關聯之匯入範圍的控制代碼。</param>
      <param name="variableList">如果範圍宣告變數，則請將此值設定為第一個變數的控制代碼。 否則，請將此值設定為下一個範圍定義所宣告第一個變數的控制代碼。 如果沒有範圍定義任何變數，則為 <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(1)" />。</param>
      <param name="constantList">如果範圍宣告常數，則請將此值設定為第一個常數的控制代碼。 否則，請將此值設定為下一個範圍定義所宣告第一個常數的控制代碼。 如果沒有範圍定義任何常數，則為 <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(1)" />。</param>
      <param name="startOffset">範圍所涵蓋第一個指令的位移。</param>
      <param name="length">範圍的長度 (以位元組為單位)。</param>
      <returns>已新增之本機範圍的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalVariable(System.Reflection.Metadata.LocalVariableAttributes,System.Int32,System.Reflection.Metadata.StringHandle)">
      <summary>新增本機變數偵錯資訊。</summary>
      <param name="attributes">本機變數屬性。</param>
      <param name="index">本機簽章中本機變數的以零起始索引。</param>
      <param name="name">變數的名稱。</param>
      <returns>已新增之本機變數的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddManifestResource(System.Reflection.ManifestResourceAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.UInt32)">
      <summary>新增資訊清單資源。</summary>
      <param name="attributes">資訊清單資源屬性。</param>
      <param name="name">資訊清單資源的名稱。</param>
      <param name="implementation">實作實體控制代碼，可能是下列其中一項：<see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> 或 <see langword="null" />。</param>
      <param name="offset">指定此資源記錄在參考檔案檔案中，從其開始處的位元組位移。</param>
      <returns>已新增之資訊清單資源的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMarshallingDescriptor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>將封送處理資訊新增至欄位或參數。</summary>
      <param name="parent">父實體控制代碼，可能是下列其中一項：<see cref="T:System.Reflection.Metadata.ParameterHandle" /> 或 <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />。</param>
      <param name="descriptor">描述元 Blob。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMemberReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>新增 MemberRef 資料表資料列。</summary>
      <param name="parent">內含實體，可能是下列其中一項：<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、<see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />、<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />。</param>
      <param name="name">成員名稱。</param>
      <param name="signature">成員簽章。</param>
      <returns>已新增之成員參考的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDebugInformation(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>新增方法偵錯資訊。</summary>
      <param name="document">單一文件的控制代碼，該文件包含方法的所有序列點；若方法沒有序列點或跨多個文件，則為 <see langword="null" />。</param>
      <param name="sequencePoints">序列點 Blob；若方法沒有序列點，則為 <see langword="null" />。</param>
      <returns>已新增之方法偵錯資訊的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDefinition(System.Reflection.MethodAttributes,System.Reflection.MethodImplAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Int32,System.Reflection.Metadata.ParameterHandle)">
      <summary>新增方法定義。</summary>
      <param name="attributes">方法屬性。</param>
      <param name="implAttributes">方法實作屬性。</param>
      <param name="name">方法名稱。</param>
      <param name="signature">方法簽章。</param>
      <param name="bodyOffset">PE 映像中儲存方法主體 (IL 資料流) 的區塊內位移；如果方法沒有主體，則為 -1。</param>
      <param name="parameterList">如果方法宣告 Params 資料表中的參數，則請將其設定為第一個參數的控制代碼。 否則，請將此值設定為下一個方法定義所宣告第一個參數的控制代碼。 如果模組中未宣告任何參數，則為 <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(1)" />。</param>
      <returns>已新增之方法定義的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>定義類型中方法宣告的實作。</summary>
      <param name="type">類型定義</param>
      <param name="methodBody">方法主體實體控制代碼，可能是下列其中一項：<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />。</param>
      <param name="methodDeclaration">方法宣告實體控制代碼，可能是下列其中一項：<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />。</param>
      <returns>已新增之方法實作的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImport(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.MethodImportAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <summary>將匯入資訊新增至方法定義。</summary>
      <param name="method">方法定義控制代碼。</param>
      <param name="attributes">方法匯入屬性。</param>
      <param name="name">非受控方法名稱。</param>
      <param name="module">包含非受控方法的模組。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSemantics(System.Reflection.Metadata.EntityHandle,System.Reflection.MethodSemanticsAttributes,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>將方法 (getter、setter、adder 等) 與屬性或事件建立關聯。</summary>
      <param name="association">關聯實體控制代碼，可能是下列其中一項：<see cref="T:System.Reflection.Metadata.EventDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />。</param>
      <param name="semantics">方法語義屬性。</param>
      <param name="methodDefinition">方法定義。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSpecification(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>新增方法規格 (具現化)。</summary>
      <param name="method">泛型方法實體控制代碼，可能是下列其中一項：<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />。</param>
      <param name="instantiation">將方法泛型引數編碼的具現化 Blob。</param>
      <returns>已新增之方法規格的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModule(System.Int32,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="generation" />
      <param name="moduleName" />
      <param name="mvid" />
      <param name="encId" />
      <param name="encBaseId" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModuleReference(System.Reflection.Metadata.StringHandle)">
      <param name="moduleName" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddNestedType(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <summary>定義指定類型定義的巢狀關聯性。</summary>
      <param name="type">巢狀型別定義控制代碼。</param>
      <param name="enclosingType">封入類型定義控制代碼。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddParameter(System.Reflection.ParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary>新增參數定義。</summary>
      <param name="attributes">參數屬性。</param>
      <param name="name">選擇性。 參數名稱。</param>
      <param name="sequenceNumber">參數的序號。 值 0 表示擁有者方法的傳回型別；其參數會接著從 1 開始編號。</param>
      <returns>已新增之參數的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddProperty(System.Reflection.PropertyAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>新增屬性定義。</summary>
      <param name="attributes">屬性 (Property) 的屬性 (Attribute)。</param>
      <param name="name">屬性名稱。</param>
      <param name="signature">屬性的簽章。</param>
      <returns>已新增之屬性定義的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddPropertyMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="declaringType" />
      <param name="propertyList" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStandaloneSignature(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStateMachineMethod(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>新增狀態機器方法偵錯資訊。</summary>
      <param name="moveNextMethod">狀態機器之 <see langword="MoveNext" /> 方法的控制代碼 (編譯器所產生的方法)。</param>
      <param name="kickoffMethod">啟動方法的控制代碼 (使用者定義的反覆運算器/非同步方法)。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeDefinition(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>新增類型定義。</summary>
      <param name="attributes">類型屬性。</param>
      <param name="namespace">類型命名空間。</param>
      <param name="name">類型名稱。</param>
      <param name="baseType">基底類型實體控制代碼，可能是下列其中一項：<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> 或 <see langword="null" />。</param>
      <param name="fieldList">如果類型宣告欄位，則請將此值設定為第一個欄位的控制代碼。 否則，請將此值設定為下一個類型定義所宣告第一個欄位的控制代碼。 如果沒有類型定義模組中的任何欄位，則為 <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(1)" />。</param>
      <param name="methodList">如果類型宣告方法，則為第一個方法的控制代碼。 否則，即會是下一個類型定義所宣告第一個方法的控制代碼。 如果沒有類型定義模組中的任何方法，則為 <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(1)" />。</param>
      <returns>已新增之類型定義的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeLayout(System.Reflection.Metadata.TypeDefinitionHandle,System.UInt16,System.UInt32)">
      <summary>定義類型定義的類型配置。</summary>
      <param name="type">類型定義</param>
      <param name="packingSize">指定欄位應該放在類型執行個體內，放置處的位元組位址是 <paramref name="packingSize" /> 的倍數，或以該欄位類型的自然對齊方式放置，以較小者為准。 其值應為下列其中一項：0、1、2、4、8、16、32、64 或 128。 值零指出所使用的封裝大小應符合目前平台的預設值。</param>
      <param name="size">指出類型執行個體的大小下限，目的在於允許填補。 所配置記憶體數量是從配置和 <paramref name="size" /> 計算所得的大小上限。 請注意，如果這個指示詞套用到實值型別，則大小會小於 1 MB。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <summary>新增類型參考。</summary>
      <param name="resolutionScope">宣告目標類型的實體，可能是下列其中一項：<see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 或 <see langword="null" />。</param>
      <param name="namespace">類型參考命名空間。</param>
      <param name="name">類型參考名稱。</param>
      <returns>已新增之類型參考的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeSpecification(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Byte[])">
      <summary>將指定的 Blob 新增至 Blob 堆積 (如果尚未存在)。</summary>
      <param name="value">包含 Blob 的陣列。</param>
      <returns>已新增或現有 Blob 的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>將指定的 Blob 從位元組陣列新增至 Blob 堆積 (如果尚未存在)。</summary>
      <param name="value">包含 Blob 的陣列。</param>
      <returns>已新增或現有 Blob 的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Reflection.Metadata.BlobBuilder)">
      <summary>將指定的 Blob 從不可變位元組陣列新增至 Blob 堆積 (如果尚未存在)。</summary>
      <param name="value">包含 Blob 的 Blob 產生器執行個體。</param>
      <returns>已新增或現有 Blob 的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF16(System.String)">
      <summary>使用 UTF16 編碼將字串編碼為 Blob，並將其新增至 Blob 堆積 (如果尚未存在)。</summary>
      <param name="value">要加入的字串。</param>
      <returns>已新增或現有 Blob 的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF8(System.String,System.Boolean)">
      <summary>使用 UTF8 編碼將字串編碼為 Blob，並將其新增至 Blob 堆積 (如果尚未存在)。</summary>
      <param name="value">要加入的值。</param>
      <param name="allowUnpairedSurrogates">設定為 <see langword="true" /> 會以指定方式編碼非成對代理字元；設定為 <see langword="false" /> 則會以 U+FFFD 字元取代那些字元。</param>
      <returns>已新增或現有 Blob 的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddConstantBlob(System.Object)">
      <summary>將常數值編碼為 Blob，並將其新增至 Blob 堆積 (如果尚未存在)。 請使用 UTF16 來編碼字串常數。</summary>
      <param name="value">要新增的常數值。</param>
      <returns>已新增或現有 Blob 的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddDocumentName(System.String)">
      <summary>將偵錯文件名稱編碼，並將其新增至 Blob 堆積 (如果尚未存在)。</summary>
      <param name="value">要新增的文件名稱。</param>
      <returns>已新增或現有文件名稱 Blob 的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddGuid(System.Guid)">
      <summary>將指定的 GUID 新增至 GUID 堆積 (如果尚未存在)。</summary>
      <param name="guid">要新增的 GUID。</param>
      <returns>已新增或現有 GUID 的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddString(System.String)">
      <summary>將指定的字串新增至字串堆積 (如果尚未存在)。</summary>
      <param name="value">要加入的字串。</param>
      <returns>已新增或現有字串的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddUserString(System.String)">
      <summary>將指定的字串新增至使用者字串堆積 (如果尚未存在)。</summary>
      <param name="value">要加入的字串。</param>
      <returns>已新增或現有字串的控制代碼。 此值可以在 <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" /> 中使用。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCount(System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>傳回所指定資料表中目前的項目數。</summary>
      <param name="table">資料表索引。</param>
      <returns>資料表中項目數。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCounts">
      <summary>傳回每個資料表中目前的項目數。</summary>
      <returns>
        <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" /> 大小的陣列，其中每個項目都會填入相對應資料表的目前資料列計數。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveGuid">
      <summary>在 GUID 堆積上為 GUID 保留空間。</summary>
      <returns>已保留 GUID 的控制代碼，以及代表堆積上所儲存之 GUID Blob 的 <see cref="T:System.Reflection.Metadata.Blob" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveUserString(System.Int32)">
      <summary>在使用者字串堆積上為指定長度的字串保留空間。</summary>
      <param name="length">要保留的字元數。</param>
      <returns>已保留使用者字串的控制代碼，以及代表整個使用者字串 Blob (包括其長度和結束字元) 的 <see cref="T:System.Reflection.Metadata.Blob" />。 此控制代碼可以在 <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" /> 中使用。
請使用 <see cref="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)" /> 來填入 Blob 內容。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.HeapIndex,System.Int32)">
      <summary>設定指定堆積的容量。</summary>
      <param name="heap">堆積索引。</param>
      <param name="byteCount">位元組數。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>設定指定資料表的容量。</summary>
      <param name="table">資料表索引。</param>
      <param name="rowCount">表格中的列數。</param>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions">
      <summary>提供使用 ECMA-335 中繼資料資料表和堆積特定原始項目的擴充方法。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueLogEntries(System.Reflection.Metadata.MetadataReader)">
      <summary>列舉 EnC 記錄的項目。</summary>
      <param name="reader" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueMapEntries(System.Reflection.Metadata.MetadataReader)">
      <summary>列舉 EnC 對應的項目。</summary>
      <param name="reader" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>傳回從中繼資料開頭到指定堆積的位移。</summary>
      <param name="reader" />
      <param name="heapIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>傳回指定堆積的大小。</summary>
      <param name="reader" />
      <param name="heapIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.BlobHandle)">
      <summary>傳回 <see cref="T:System.Reflection.Metadata.Blob" /> 的控制代碼，該控制代碼會位在 <see cref="T:System.Reflection.Metadata.Blob" /> 堆積中所提供項目之後，或若其為最後一個項目，則為 Nil 控制代碼。</summary>
      <param name="reader" />
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.StringHandle)">
      <summary>傳回字串的控制代碼，該控制代碼會位在字串堆積中所提供項目之後，或若其為最後一個項目，則為 Nil 控制代碼。</summary>
      <param name="reader" />
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.UserStringHandle)">
      <summary>傳回 UserString 的控制代碼，該控制代碼會位在 UserString 堆積中所提供項目之後，或若其為最後一個項目，則為 Nil 控制代碼。</summary>
      <param name="reader" />
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>傳回從中繼資料開頭到指定資料表的位移。</summary>
      <param name="reader" />
      <param name="tableIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowCount(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>傳回指定資料表中的資料列數。</summary>
      <param name="reader" />
      <param name="tableIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>傳回指定資料表中的資料列大小。</summary>
      <param name="reader" />
      <param name="tableIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithEvents(System.Reflection.Metadata.MetadataReader)">
      <summary>列舉定義一或多個事件的類型。</summary>
      <param name="reader" />
      <returns>產生的序列會完全對應至 EventMap 資料表中項目，即第 N 個傳回的 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 會儲存在 EventMap 的第 N 列中。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithProperties(System.Reflection.Metadata.MetadataReader)">
      <summary>列舉定義一或多個屬性的類型。</summary>
      <param name="reader" />
      <returns>產生的序列會完全對應至屬性對應資料表中項目，即第 N 個傳回的 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 會儲存在屬性對應的第 N 列中。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)">
      <summary>簽章 Blob 中找到的類型控制代碼和原始類型種類會決定目標類型為實值型別還是參考型別。</summary>
      <param name="reader" />
      <param name="typeHandle" />
      <param name="rawTypeKind" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataRootBuilder">
      <summary>要內嵌於可攜式執行檔映像的中繼資料根建立器。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.String,System.Boolean)">
      <summary>建立中繼資料根的建立器。</summary>
      <param name="tablesAndHeaps">使用儲存於資料表的中繼資料實體，以及儲存於堆積的值填入的建立器。 實體與值會在將中繼資料根序列化時進行列舉。</param>
      <param name="metadataVersion">版本字串會寫入至中繼資料標頭。 預設值為 "v4.0.30319"。</param>
      <param name="suppressValidation">
        <see langword="true" /> 以在序列化期間隱藏中繼資料表的基本驗證；否則為 <paramref name="false" />。</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.MetadataVersion">
      <summary>中繼資料版本。</summary>
      <returns>表示中繼資料版本的字串。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Int32,System.Int32)">
      <summary>將中繼資料根內容序列化到指定的 <see cref="T:System.Reflection.Metadata.BlobBuilder" />。</summary>
      <param name="builder">要寫入到其中的建立器。</param>
      <param name="methodBodyStreamRva">方法主體資料流開頭的相對虛擬位址。 用來計算 MethodDef 資料表 RVA 欄位的最終值。</param>
      <param name="mappedFieldDataStreamRva">欄位初始資料流開頭的相對虛擬位址。 用來計算 FieldRVA 資料表 RVA 欄位的最終值。</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Sizes">
      <summary>傳回不同中繼資料結構的大小。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation">
      <summary>判斷是否要隱藏中繼資料表的基本驗證。 驗證會驗證資料表中項目已按照 ECMA 規格要求的順序新增。 其不會在中繼資料表上強制實行所有規格需求。</summary>
      <returns>
        <see langword="true" /> 隱藏中繼資料資料表的基本驗證;否則，<see langword="false" />。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataSizes">
      <summary>提供各種中繼資料結構的大小資訊。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.ExternalRowCounts">
      <summary>外部資料表資料列計數。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataSizes.GetAlignedHeapSize(System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>傳回指定堆積的對齊大小。</summary>
      <param name="index" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.HeapSizes">
      <summary>精確 (未對齊) 的堆積大小。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.RowCounts">
      <summary>資料表資料列計數。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataTokens" />
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyFileHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.BlobHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ConstantHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomAttributeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomDebugInformationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DeclarativeSecurityAttributeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentNameBlobHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Int32)">
      <summary>從權杖值建立實體控制代碼。</summary>
      <param name="token" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>從權杖值建立 <see cref="T:System.Reflection.Metadata.EntityHandle" />。</summary>
      <param name="tableIndex" />
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EventDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ExportedTypeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterConstraintHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.BlobHandle)">
      <summary>取得中繼資料堆積資料的位移，該中繼資料對應至指定的 <paramref name="handle" />。</summary>
      <param name="handle" />
      <returns>以零為基礎的位移，或若 <paramref name="handle" /> 只能在特定 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 或 <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> 的內容中解譯，則為 -1。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.GuidHandle)">
      <summary>取得中繼資料堆積資料的位移，該中繼資料對應至指定的 <paramref name="handle" />。</summary>
      <param name="handle" />
      <returns>#GUID 堆積中以 1 為基礎的索引。 與其他基本上是位元組陣列的堆積不同，#GUID 堆積是 16 位元組 GUID 的陣列。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.Handle)">
      <summary>取得中繼資料堆積資料的位移，該中繼資料對應至指定的 <paramref name="handle" />。</summary>
      <param name="handle" />
      <returns>對應堆積中的位移，或若 <paramref name="handle" /> 只能在特定 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 或 <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> 的內容中解譯，則為 -1。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary>取得中繼資料堆積資料的位移，該中繼資料對應至 <paramref name="reader" /> 內容中的指定 <paramref name="handle" />。</summary>
      <param name="reader" />
      <param name="handle" />
      <returns>以零為基礎的位移，或若 <paramref name="handle" /> 不是中繼資料堆積控制代碼，則為 -1。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.StringHandle)">
      <summary>取得中繼資料堆積資料的位移，該中繼資料對應至指定的 <paramref name="handle" />。</summary>
      <param name="handle" />
      <returns>以零為基礎的位移，或若 <paramref name="handle" /> 只能在特定 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 或 <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> 的內容中解譯，則為 -1。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.UserStringHandle)">
      <summary>取得中繼資料堆積資料的位移，該中繼資料對應至指定的 <paramref name="handle" />。</summary>
      <param name="handle" />
      <returns>以零為基礎的位移。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.EntityHandle)">
      <summary>取得對應至指定 <paramref name="handle" /> 之中繼資料資料表項目的資料列號碼。</summary>
      <param name="handle" />
      <returns>以一為基礎的資料列號碼，或若 <paramref name="handle" /> 只能在特定 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 的內容中解譯，則為 -1。
請參閱 <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary>取得對應至 <paramref name="reader" /> 內容中指定 <paramref name="handle" /> 之中繼資料資料表項目的資料列號碼。</summary>
      <param name="reader" />
      <param name="handle" />
      <returns>以一為基礎的資料列號碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.EntityHandle)">
      <summary>取得指定 <paramref name="handle" /> 的中繼資料權杖。</summary>
      <param name="handle" />
      <returns>中繼資料權杖，或若 <paramref name="handle" /> 只能在特定 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 的內容中解譯，則為 0。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.Handle)">
      <summary>取得指定 <paramref name="handle" /> 的中繼資料權杖。</summary>
      <param name="handle" />
      <returns>中繼資料權杖，或若 <paramref name="handle" /> 只能在特定 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 的內容中解譯，則為 0。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary>取得 <paramref name="reader" /> 內容中指定 <paramref name="handle" /> 的中繼資料權杖。</summary>
      <param name="reader" />
      <param name="handle" />
      <returns>中繼資料權杖。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary>取得 <paramref name="reader" /> 內容中指定 <paramref name="handle" /> 的中繼資料權杖。</summary>
      <param name="reader" />
      <param name="handle" />
      <returns>中繼資料權杖。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GuidHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Int32)">
      <summary>從權杖值建立控制代碼。</summary>
      <param name="token" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>從權杖值建立 <see cref="T:System.Reflection.Metadata.EntityHandle" />。</summary>
      <param name="tableIndex" />
      <param name="rowNumber" />
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.HeapCount">
      <summary>可出現在 Ecma335 中繼資料中的資料表數量上限。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ImportScopeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.InterfaceImplementationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalScopeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ManifestResourceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MemberReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDebugInformationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodImplementationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodSpecificationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ModuleReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.PropertyDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StandaloneSignatureHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StringHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount">
      <summary>可出現在 Ecma335 中繼資料中的資料表數量上限。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetHeapIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.HeapIndex@)">
      <summary>取得堆積的 <see cref="T:System.Reflection.Metadata.Ecma335.HeapIndex" />，其對應至指定的 <see cref="T:System.Reflection.Metadata.HandleKind" />。</summary>
      <param name="type">控制代碼類型。</param>
      <param name="index">堆積索引。</param>
      <returns>若控制代碼類型對應至 Ecma335 堆積，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetTableIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.TableIndex@)">
      <summary>取得資料表的 <see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" />，其對應至指定的 <see cref="T:System.Reflection.Metadata.HandleKind" />。</summary>
      <param name="type">控制代碼類型。</param>
      <param name="index">資料表索引。</param>
      <returns>若控制代碼類型對應至 Ecma335 或可攜式 PDB 資料表，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeSpecificationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.UserStringHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyAttributes">
      <summary>定義方法主體屬性。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.InitLocals">
      <summary>初始化方法定義為零的任何區域變數，並動態地配置本機記憶體。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.None">
      <summary>不執行本機記憶體初始化。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder">
      <summary>提供方法主體資料流的編碼器。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary>編碼方法主體並將它新增至方法主體資料流，使用提供的程式碼大小、最大堆疊大小、例外狀況區域的數目、區域變數的簽章控制代碼、方法主體屬性，以及允許以指出例外狀況區域是否應以小型格式編碼。</summary>
      <param name="codeSize">要為指令保留的位元組數目。</param>
      <param name="maxStack">堆疊大小上限。</param>
      <param name="exceptionRegionCount">例外狀況區域的數目。</param>
      <param name="hasSmallExceptionRegions">如果例外狀況區域應該以小型格式編碼，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
      <param name="localVariablesSignature">區域變數的簽章控制代碼。</param>
      <param name="attributes">方法主體屬性。</param>
      <returns>已編碼主體在方法主體資料流中的位移。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary>編碼方法主體並將它新增至方法主體資料流，使用提供的程式碼大小、最大堆疊大小、例外狀況區域的數目、區域變數的簽章控制代碼、方法主體屬性、允許指出例外狀況區域是否應以小型格式編碼，以及允許以指出方法是否應該從動態本機記憶體集區配置。</summary>
      <param name="codeSize">要為指令保留的位元組數目。</param>
      <param name="maxStack">堆疊大小上限。</param>
      <param name="exceptionRegionCount">例外狀況區域的數目。</param>
      <param name="hasSmallExceptionRegions">如果例外狀況區域應該以小型格式編碼，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
      <param name="localVariablesSignature">區域變數的簽章控制代碼。</param>
      <param name="attributes">方法主體屬性。</param>
      <param name="hasDynamicStackAllocation">如果方法是從動態本機記憶體集區配置 (包含 <see langword="true" /> 指令)，則為 <see langword="localloc" />；否則為 <see langword="false" />。</param>
      <returns>已編碼主體在方法主體資料流中的位移。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary>編碼方法主體，並將它新增到方法主體資料流。</summary>
      <param name="instructionEncoder">指令編碼器。</param>
      <param name="maxStack">堆疊大小上限。</param>
      <param name="localVariablesSignature">區域變數的簽章控制代碼。</param>
      <param name="attributes">方法主體屬性。</param>
      <returns>已編碼主體在方法主體資料流中的位移。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary>編碼方法主體並將它新增至方法主體資料流，使用提供的指令編碼器、最大堆疊大小、區域變數的簽章控制代碼、方法主體屬性，以及允許以指出方法是否應從動態本機記憶體集區配置。</summary>
      <param name="instructionEncoder">指令編碼器。</param>
      <param name="maxStack">堆疊大小上限。</param>
      <param name="localVariablesSignature">區域變數的簽章控制代碼。</param>
      <param name="attributes">方法主體屬性。</param>
      <param name="hasDynamicStackAllocation">如果方法是從動態本機記憶體集區配置 (IL 包含 <see langword="true" /> 指令)，則為 <see langword="localloc" />；否則為 <see langword="false" />。</param>
      <returns>已編碼主體在方法主體資料流中的位移。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody">
      <summary>描述方法主體。 此類別的用意是要搭配 <see cref="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder" /> 類別使用。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.ExceptionRegions">
      <summary>取得可用於將例外狀況區域編碼為方法主體的編碼器物件。</summary>
      <returns>例外狀況區域編碼器實例。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Instructions">
      <summary>取得為指令保留的 Blob。</summary>
      <returns>保留用於指示的 blob。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Offset">
      <summary>取得方法主體資料流中已編碼方法主體的位移。</summary>
      <returns>方法主體資料流程中已編碼方法主體的位移。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder">
      <summary>提供方法簽章的編碼器。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" />
      <param name="hasVarArgs" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.HasVarArgs" />
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Action{System.Reflection.Metadata.Ecma335.ReturnTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ParametersEncoder})">
      <summary>編碼所提供的傳回型別與參數。</summary>
      <param name="parameterCount">參數的數目。</param>
      <param name="returnType">第一個呼叫的方法，以編碼傳回型別。</param>
      <param name="parameters">第二個呼叫的方法，以編碼參數。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Reflection.Metadata.Ecma335.ReturnTypeEncoder@,System.Reflection.Metadata.Ecma335.ParametersEncoder@)">
      <summary>編碼所提供的傳回型別與參數，其必須依它們出現在參數清單中的順序來使用。</summary>
      <param name="parameterCount">參數的數目。</param>
      <param name="returnType">第一個呼叫的方法，以編碼傳回型別。</param>
      <param name="parameters">第二個呼叫的方法，以編碼參數。</param>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <summary>初始化 <see cref="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" /> 結構的新執行個體。</summary>
      <param name="builder">用來編碼具名引數的建立器。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Action{System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.NameEncoder},System.Action{System.Reflection.Metadata.Ecma335.LiteralEncoder})">
      <summary>編碼具名引數 (欄位或屬性)。</summary>
      <param name="isField">
        <see langword="true" /> 以編碼欄位，<see langword="false" /> 以編碼屬性。</param>
      <param name="type">要第一個呼叫的方法，以編碼引數類型。</param>
      <param name="name">第二個呼叫的方法，以編碼欄位或屬性的名稱。</param>
      <param name="literal">第三個呼叫的方法，以編碼引數的常值數值。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder@,System.Reflection.Metadata.Ecma335.NameEncoder@,System.Reflection.Metadata.Ecma335.LiteralEncoder@)">
      <summary>編碼具名引數 (欄位或屬性)，並傳回三個必須依它們出現在參數清單中之順序使用的編碼器。</summary>
      <param name="isField">
        <see langword="true" /> 以編碼欄位，<see langword="false" /> 以編碼屬性。</param>
      <param name="type">要第一個呼叫的方法，以編碼引數類型。</param>
      <param name="name">第二個呼叫的方法，以編碼欄位或屬性的名稱。</param>
      <param name="literal">第三個呼叫的方法，以編碼引數的常值數值。</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.ScalarType" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.SZArray" />
    <member name="T:System.Reflection.Metadata.Ecma335.NameEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NameEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.Name(System.String)">
      <param name="name" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ParametersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" />
      <param name="hasVarArgs" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.AddParameter" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.HasVarArgs" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.StartVarArgs" />
    <member name="T:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.TypedReference" />
    <member name="T:System.Reflection.Metadata.Ecma335.PermissionSetEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="typeName" />
      <param name="encodedArguments" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Reflection.Metadata.BlobBuilder)">
      <param name="typeName" />
      <param name="encodedArguments" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.PortablePdbBuilder">
      <summary>代表可攜式 PDB 影像的建立器。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.Collections.Immutable.ImmutableArray{System.Int32},System.Reflection.Metadata.MethodDefinitionHandle,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <summary>建立可攜式 PDB 映像的建立器。</summary>
      <param name="tablesAndHeaps">使用儲存在資料中的偵錯中繼資料實體和儲存在堆積中的值來填入的建立器。 序列化可攜式 PDB 映像時，會列舉實體與值。</param>
      <param name="typeSystemRowCounts">相關聯型別系統中繼資料包含之所有資料表的資料列計數。 陣列中的每個位置都會對應到一個資料表 (<see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" />)。 陣列的長度必須等於 <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" />。</param>
      <param name="entryPoint">進入點方法定義控制代碼。</param>
      <param name="idProvider">計算內容 (以一系列 Blob 表示) 之識別碼的函式。 如果未指定，則為預設函式 (<see cref="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />)，它會忽略內容並傳回以目前時間為基礎的內容識別碼。 您必須指定決定性函數，以產生決定性可攜式 PDB 映像。</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.FormatVersion" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.IdProvider" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.MetadataVersion" />
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <summary>將可攜式 PDB 內容序列化為指定的 <see cref="T:System.Reflection.Metadata.BlobBuilder" />。</summary>
      <param name="builder">要寫入的建立器。</param>
      <returns>序列化內容的識別碼。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.TypedReference" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Void" />
    <member name="T:System.Reflection.Metadata.Ecma335.ScalarEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ScalarEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.Constant(System.Object)">
      <summary>編碼常數常值。</summary>
      <param name="value">常數，型別為 <see cref="T:System.Boolean" />、<see cref="T:System.Byte" />、<see cref="T:System.SByte" />、<see cref="T:System.Int16" />、<see cref="T:System.UInt16" />、<see cref="T:System.Int32" />、<see cref="T:System.UInt32" />、<see cref="T:System.Int64" />、<see cref="T:System.UInt64" />、<see cref="T:System.Single" />、<see cref="T:System.Double" />、<see cref="T:System.Char" /> (編碼為二位元組 Unicode 字元)、<see cref="T:System.String" /> (編碼為 SerString)、或 <see cref="T:System.Enum" /> (編碼為基礎整數值)。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.NullArray">
      <summary>編碼型別為 <see langword="null" /> 的 <see cref="T:System.Array" /> 常值。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.SystemType(System.String)">
      <summary>編碼型別為 <see cref="T:System.Type" /> (可能為 <see langword="null" />) 的常值。</summary>
      <param name="serializedTypeName">型別的名稱，或 <see langword="null" />。</param>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2">
      <summary>將簽章 Blob 解碼。</summary>
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.#ctor(System.Reflection.Metadata.ISignatureTypeProvider{`0,`1},System.Reflection.Metadata.MetadataReader,`1)">
      <summary>建立新的 <see cref="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2" />。</summary>
      <param name="provider">當簽章解碼時，用來取得型別符號的提供者。</param>
      <param name="metadataReader">從中取得簽章的中繼資料讀取器。 如果指定的提供者允許，它可以為 <see langword="null" />。</param>
      <param name="genericContext">需要其他內容來解析泛型參數。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeFieldSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>將欄位簽章 Blob 解碼，並將讀取器前移經過簽章。</summary>
      <param name="blobReader">定位在欄位簽章的 Blob 讀取器。</param>
      <returns>已解碼的欄位類型。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeLocalSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>將區域變數簽章 Blob 解碼，並將讀取器前移經過簽章。</summary>
      <param name="blobReader">定位在區域變數簽章的 Blob 讀取器。</param>
      <returns>區域變數型別。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>將方法 (定義、參考或獨立) 或屬性簽章 Blob 解碼。</summary>
      <param name="blobReader">定位在方法簽章的 Blob 讀取器。</param>
      <returns>已解碼的方法簽章。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSpecificationSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>將方法規格簽章 Blob 解碼，並將讀取器前移經過簽章。</summary>
      <param name="blobReader">定位在有效方法規格簽章的 Blob 讀取器。</param>
      <returns>用來透過方法規格將泛型方法具現化的型別。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeType(System.Reflection.Metadata.BlobReader@,System.Boolean)">
      <summary>將內嵌在簽章中的型別解碼，並將讀取器前移經過類型。</summary>
      <param name="blobReader">定位在前置 <see cref="T:System.Reflection.Metadata.SignatureTypeCode" /> 的 Blob 讀取器。</param>
      <param name="allowTypeSpecifications">
        <see langword="true" /> 允許 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> 遵循簽章中的 (CLASS | VALUETYPE)；否則為 <see langword="false" />。</param>
      <returns>已解碼的型別。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Action{System.Reflection.Metadata.Ecma335.SignatureTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ArrayShapeEncoder})">
      <summary>編碼陣列型別。</summary>
      <param name="elementType">第一個呼叫，以編碼元素的型別。</param>
      <param name="arrayShape">第二個呼叫，以編碼陣列的形狀。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Reflection.Metadata.Ecma335.SignatureTypeEncoder@,System.Reflection.Metadata.Ecma335.ArrayShapeEncoder@)">
      <summary>編碼陣列型別。 傳回一對編碼器，必須依它們出現在參數清單中的順序來使用。</summary>
      <param name="elementType">第一個使用，以編碼元素的型別。</param>
      <param name="arrayShape">第二個使用，以編碼陣列的形狀。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Boolean" />
    <member name="P:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.CustomModifiers">
      <summary>啟動使用自訂修飾元的型別簽章。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.FunctionPointer(System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.Ecma335.FunctionPointerAttributes,System.Int32)">
      <summary>啟動函式指標簽章。</summary>
      <param name="convention">呼叫慣例。</param>
      <param name="attributes">函式指標屬性。</param>
      <param name="genericParameterCount">泛型參數計數。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericInstantiation(System.Reflection.Metadata.EntityHandle,System.Int32,System.Boolean)">
      <summary>啟動泛型具現化簽章。</summary>
      <param name="genericType">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />。</param>
      <param name="genericArgumentCount">泛型引數計數。</param>
      <param name="isValueType">
        <see langword="true" /> 以將型別標示為實值型別，<see langword="false" /> 以將它在簽章中標記為參考型別。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericMethodTypeParameter(System.Int32)">
      <summary>編碼所含泛型方法的型別參數參考。</summary>
      <param name="parameterIndex">參數索引。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericTypeParameter(System.Int32)">
      <summary>編碼所含泛型型別的型別參數參考。</summary>
      <param name="parameterIndex">參數索引。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.IntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Pointer">
      <summary>啟動指標簽章。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary>寫入簡單型別代碼。</summary>
      <param name="type">除了 <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference" /> 與 <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.Void" /> 之外的任何簡單型別代碼。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SZArray">
      <summary>啟動 SZ 陣列 (向量) 簽章。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Type(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <summary>編碼型別的參考。</summary>
      <param name="type">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />。</param>
      <param name="isValueType">
        <see langword="true" /> 以將型別標示為實值型別，<see langword="false" /> 以將它在簽章中標記為參考型別。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UIntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.VoidPointer">
      <summary>編碼 Void 指標 (void*) 來存取它所儲存的值。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.TableIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Assembly" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ClassLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Constant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.DeclSecurity" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Document" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncLog" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Event" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ExportedType" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Field" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldMarshal" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldRva" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.File" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParam" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParamConstraint" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImplMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImportScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.InterfaceImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalConstant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalVariable" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ManifestResource" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MemberRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSemantics" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSpec" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Module" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ModuleRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.NestedClass" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Param" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ParamPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Property" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StandAloneSig" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StateMachineMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeSpec" />
    <member name="T:System.Reflection.Metadata.Ecma335.VectorEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.VectorEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.Count(System.Int32)">
      <param name="count" />
    </member>
    <member name="T:System.Reflection.Metadata.EntityHandle">
      <summary>表示中繼資料實體 (例如類型參考、類型定義、類型規格、方法定義或自訂屬性)。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.EntityHandle.AssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Object)">
      <summary>傳回值，指出目前執行個體與指定的物件是否相等。</summary>
      <param name="obj">要與目前執行個體比較的物件。</param>
      <returns>如果 <paramref name="obj" /> 是 <see cref="T:System.Reflection.Metadata.EntityHandle" /> 且等於目前的執行個體，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Reflection.Metadata.EntityHandle)">
      <summary>傳回值，指出目前的執行個體與指定的 <see cref="T:System.Reflection.Metadata.EntityHandle" /> 是否相等。</summary>
      <param name="other">要與目前執行個體比較的值。</param>
      <returns>如果目前的執行個體和 <paramref name="other" /> 相等則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.GetHashCode">
      <summary>傳回這個執行個體的雜湊碼。</summary>
      <returns>這個執行個體的雜湊碼。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.EntityHandle.IsNil" />
    <member name="P:System.Reflection.Metadata.EntityHandle.Kind" />
    <member name="F:System.Reflection.Metadata.EntityHandle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Equality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Implicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Inequality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.EventAccessors" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Adder" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Others" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Raiser" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Remover" />
    <member name="T:System.Reflection.Metadata.EventDefinition" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Attributes" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Name" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Type" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.EventDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Equality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Inequality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection" />
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#EventDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ExceptionRegion" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.CatchType">
      <summary>如果區域表示 Catch 取得 TypeRef、TypeDef 或 TypeSpec 控制代碼，如果是其他狀況則取得 nil 語彙基元 (<see langword="default" />(<see cref="T:System.Reflection.Metadata.EntityHandle" />))。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.FilterOffset">
      <summary>取得篩選條件區塊開頭的 IL 位移，如果該區域不是篩選條件，則為 -1。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerLength">
      <summary>取得例外狀況處理常式的長度，以位元組為單位。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerOffset">
      <summary>取得例外狀況處理常式的起始 IL 位移。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.Kind" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryLength">
      <summary>取得 try 區塊的長度，以位元組為單位。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryOffset">
      <summary>取得 try 區塊的起始 IL 長度。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExceptionRegionKind" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Catch" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Fault" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Filter" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Finally" />
    <member name="T:System.Reflection.Metadata.ExportedType" />
    <member name="P:System.Reflection.Metadata.ExportedType.Attributes" />
    <member name="M:System.Reflection.Metadata.ExportedType.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ExportedType.Implementation">
      <summary>取得控制代碼，以解析目標型別的實作。</summary>
      <returns>
        <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />表示元件中的另一個模組。
<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />如果<see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder" />為，則<see langword="true" />表示另一個元件。
<see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />，代表宣告匯出的類型，其中會將這個的嵌套在其中。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.IsForwarder" />
    <member name="P:System.Reflection.Metadata.ExportedType.Name">
      <summary>取得目標型別的名稱，如果型別是巢狀的或定義在根命名空間中，則為 <see langword="default" />。</summary>
      <returns>
        <see cref="T:System.Reflection.Metadata.StringHandle" />結構實例。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.Namespace">
      <summary>取得包含目標型別之命名空間的完整名稱，如果型別是巢狀的或定義在根命名空間中，則為 <see langword="default" />。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.NamespaceDefinition">
      <summary>取得目標型別所定義在之命名空間的定義控制代碼，如果型別是巢狀的或定義在根命名空間中，則為 <see langword="default" />。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandle" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ExportedTypeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Equality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Inequality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection">
      <summary>表示 <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 執行個體的集合。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ExportedTypeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.FieldDefinition" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Attributes" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetMarshallingDescriptor" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetOffset">
      <summary>傳回欄位配置位移；如果未提供則為 -1。</summary>
      <returns>欄位定義位移；如果未提供則為 -1。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetRelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Name" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Equality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Inequality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection" />
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#FieldDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.GenericParameter" />
    <member name="P:System.Reflection.Metadata.GenericParameter.Attributes">
      <summary>取得指定變異數和條件約束的屬性。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameter.GetConstraints" />
    <member name="M:System.Reflection.Metadata.GenericParameter.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameter.Index">
      <summary>取得宣告的泛型型別或方法宣告內參數之以零為起始的索引。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Name">
      <summary>取得泛型參數的名稱。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Parent">
      <summary>取得 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />，代表此泛型參數的父代。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraint" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraint.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Parameter">
      <summary>取得受限制的 <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Type">
      <summary>取得控制代碼 (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />)，指定此泛型參數從中限制為衍生的型別，或此泛型參數從中限制為實作的介面。</summary>
      <returns>
        <see cref="T:System.Reflection.Metadata.EntityHandle" /> 執行個體。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Equality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Inequality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection">
      <summary>表示泛型型別參數條件約束的集合。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.GetEnumerator" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Item(System.Int32)">
      <param name="index" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterConstraintHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.GenericParameterHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Reflection.Metadata.GenericParameterHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.GenericParameterHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Equality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Inequality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection">
      <summary>表示方法或類型的泛型型別參數集合。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.GetEnumerator" />
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Item(System.Int32)">
      <param name="index" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.GuidHandle" />
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Reflection.Metadata.GuidHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.GuidHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Equality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GuidHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Implicit(System.Reflection.Metadata.GuidHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Inequality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.Handle">
      <summary>表示任何中繼資料實體 (例如類型參考、類型定義、類型規格、方法定義或自訂屬性) 或值 (字串、Blob、guid 或使用者字串)。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Handle.AssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Reflection.Metadata.Handle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Handle.IsNil" />
    <member name="P:System.Reflection.Metadata.Handle.Kind" />
    <member name="F:System.Reflection.Metadata.Handle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.Handle.op_Equality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.op_Inequality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.HandleComparer" />
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>比較兩個實體控制代碼。</summary>
      <param name="x">要比較的第一個實體控制代碼。</param>
      <param name="y">要比較的第二個實體控制代碼。</param>
      <returns>若兩個實體控制代碼相等，則為零；若它們不相等，則為非零值。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <summary>比較兩個控制代碼。</summary>
      <param name="x">要比較的第一個控制代碼。</param>
      <param name="y">要比較的第二個控制代碼。</param>
      <returns>若兩個控制代碼相等，則為零；若它們不相等，則為非零值。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.HandleComparer.Default" />
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="x" />
      <param name="y" />
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="x" />
      <param name="y" />
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.EntityHandle)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.Handle)">
      <param name="obj" />
    </member>
    <member name="T:System.Reflection.Metadata.HandleKind" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyFile" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.Blob" />
    <member name="F:System.Reflection.Metadata.HandleKind.Constant" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.DeclarativeSecurityAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.Document" />
    <member name="F:System.Reflection.Metadata.HandleKind.EventDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ExportedType" />
    <member name="F:System.Reflection.Metadata.HandleKind.FieldDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameterConstraint" />
    <member name="F:System.Reflection.Metadata.HandleKind.Guid" />
    <member name="F:System.Reflection.Metadata.HandleKind.ImportScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.InterfaceImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalConstant" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalVariable" />
    <member name="F:System.Reflection.Metadata.HandleKind.ManifestResource" />
    <member name="F:System.Reflection.Metadata.HandleKind.MemberReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.NamespaceDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.Parameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.PropertyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.StandaloneSignature" />
    <member name="F:System.Reflection.Metadata.HandleKind.String" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.UserString" />
    <member name="T:System.Reflection.Metadata.IConstructedTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetArrayType(`0,System.Reflection.Metadata.ArrayShape)">
      <summary>取得指定項目型別和圖形之一般化陣列的型別符號。</summary>
      <param name="elementType">陣列中項目的型別。</param>
      <param name="shape">陣列的圖形 (順位、大小及下限)。</param>
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetByReferenceType(`0)">
      <summary>取得指定項目型別的受控指標型別符號。</summary>
      <param name="elementType" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetGenericInstantiation(`0,System.Collections.Immutable.ImmutableArray{`0})">
      <summary>取得指定泛型型別的泛型具現化型別符號，其具有指定的型別引數。</summary>
      <param name="genericType" />
      <param name="typeArguments" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetPointerType(`0)">
      <summary>取得指定項目型別的非受控指標型別符號。</summary>
      <param name="elementType" />
    </member>
    <member name="T:System.Reflection.Metadata.ICustomAttributeTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetSystemType">
      <summary>取得 <typeparamref name="TType" /> 的 <see cref="T:System.Type" /> 表示。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetTypeFromSerializedName(System.String)">
      <summary>取得指定序列化型別名稱的型別符號。</summary>
      <param name="name">使用稱為「反映標記法」格式的序列化型別名稱 (<see cref="M:System.Type.GetType(System.String)" /> 方法可以辨識。)</param>
      <returns>
        <typeparamref name="TType" /> 執行個體。</returns>
      <exception cref="T:System.BadImageFormatException">名稱的格式不正確。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetUnderlyingEnumType(`0)">
      <summary>取得指定列舉型別符號的基礎型別。</summary>
      <param name="type">列舉型別。</param>
      <returns>表示基礎列舉型別的型別程式碼。</returns>
      <exception cref="T:System.BadImageFormatException">指定的型別符號不代表列舉。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.IsSystemType(`0)">
      <summary>驗證指定的型別是否代表 <see cref="T:System.Type" />。</summary>
      <param name="type">要驗證的型別。</param>
      <returns>若指定的型別是 <see langword="true" />，則為 <see cref="T:System.Type" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ILOpCode" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.And" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Arglist" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Box" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Break" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Call" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Calli" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Callvirt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Castclass" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ceq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ckfinite" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Constrained" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Dup" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfilter" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfinally" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Isinst" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Jmp" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_5" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_6" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_7" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_m1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelema" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldlen" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldnull" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldstr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldtoken" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldvirtftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Localloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mkrefany" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Neg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newarr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Nop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Not" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Or" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Pop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Readonly" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanytype" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanyval" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ret" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rethrow" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shl" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sizeof" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Switch" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Tail" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Throw" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unaligned" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox_any" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Volatile" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Xor" />
    <member name="T:System.Reflection.Metadata.ILOpCodeExtensions" />
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetBranchOperandSize(System.Reflection.Metadata.ILOpCode)">
      <summary>計算指定分支指令運算元的大小。</summary>
      <param name="opCode">分支作業碼。</param>
      <returns>如果 <paramref name="opCode" /> 是簡短分支，則為 1；如果是完整分支，則為 4。</returns>
      <exception cref="T:System.ArgumentException">指定的 <paramref name="opCode" /> 不是分支作業碼。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetLongBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>取得指定分支作業碼的完整形式。</summary>
      <param name="opCode">分支作業碼。</param>
      <returns>分支作業碼的完整形式。</returns>
      <exception cref="T:System.ArgumentException">指定的 <paramref name="opCode" /> 不是分支作業碼。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetShortBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>取得指定分支作業碼的簡短形式。</summary>
      <param name="opCode">分支作業碼。</param>
      <returns>分支作業碼的簡短形式。</returns>
      <exception cref="T:System.ArgumentException">指定的 <paramref name="opCode" /> 不是分支作業碼。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.IsBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>驗證所指定作業碼是否為標籤的分支。</summary>
      <param name="opCode" />
      <returns>若所指定作業碼是標籤的分支，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImageFormatLimitationException">
      <summary>嘗試寫入中繼資料時所擲回的例外狀況，超過格式規格所指定的限制。 例如，超過堆積大小限制時。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor">
      <summary>初始化 <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> 類別的新執行個體。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>使用序列化資料，初始化 <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> 類別的新執行個體。</summary>
      <param name="info">存放序列物件資料的物件。</param>
      <param name="context">關於來源或目的端的內容資訊。</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String)">
      <summary>使用指定的錯誤訊息，初始化 <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> 類別的新執行個體。</summary>
      <param name="message">解釋這個例外狀況原因的錯誤訊息。</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String,System.Exception)">
      <summary>使用指定的錯誤訊息和造成這個例外狀況的例外狀況，初始化 <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> 類別的新執行個體。</summary>
      <param name="message">解釋這個例外狀況原因的錯誤訊息。</param>
      <param name="innerException">導致目前例外狀況發生的例外狀況；如果沒有指定任何的內部例外狀況，則為 <see langword="null" />。</param>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinition" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Alias" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Kind" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetAssembly" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetNamespace" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetType" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.MoveNext">
      <exception cref="T:System.BadImageFormatException">無效的 Blob 格式。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Reset" />
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportDefinition}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionKind" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyReference" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyReferenceAlias" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportXmlNamespace" />
    <member name="T:System.Reflection.Metadata.ImportScope">
      <summary>提供可在該詞彙範圍中進行一組匯入的相關資訊。 此資訊儲存在偵錯中繼資料中。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScope.GetImports" />
    <member name="P:System.Reflection.Metadata.ImportScope.ImportsBlob" />
    <member name="P:System.Reflection.Metadata.ImportScope.Parent" />
    <member name="T:System.Reflection.Metadata.ImportScopeCollection" />
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Count" />
    <member name="T:System.Reflection.Metadata.ImportScopeCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportScopeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ImportScopeHandle" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Reflection.Metadata.ImportScopeHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ImportScopeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Equality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Inequality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementation" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementation.Interface">
      <summary>取得實作的介面 (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />)。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandle" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Equality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Inequality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#InterfaceImplementationHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ISignatureTypeProvider`2">
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetFunctionPointerType(System.Reflection.Metadata.MethodSignature{`0})">
      <summary>取得指定方法 <paramref name="signature" /> 函式指標類型的類型符號。</summary>
      <param name="signature" />
      <returns>函式指標類型的類型符號。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericMethodParameter(`1,System.Int32)">
      <summary>取得泛型方法參數 (位於指定以零起始的 <paramref name="index" />) 的類型符號。</summary>
      <param name="genericContext" />
      <param name="index" />
      <returns>泛型方法方法參數 (位於 <paramref name="index" />) 的類型符號。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericTypeParameter(`1,System.Int32)">
      <summary>取得泛型方法參數 (位於指定以零起始的 <paramref name="index" />) 的類型符號。</summary>
      <param name="genericContext" />
      <param name="index" />
      <returns>泛型方法參數 (位於指定以零起始的 <paramref name="index" />) 的類型符號。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetModifiedType(`0,`0,System.Boolean)">
      <summary>取得已套用自訂修飾詞的類型之類型符號。</summary>
      <param name="modifier">已套用修飾詞類型。</param>
      <param name="unmodifiedType">未套用修飾詞的基礎類型之類型符號。</param>
      <param name="isRequired">若需要修飾詞則為 <see langword="true" />，若為選用項目則為 <see langword="false" />。</param>
      <returns>類型符號。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetPinnedType(`0)">
      <summary>取得已標記為固定的本機變數類型之類型符號。</summary>
      <param name="elementType" />
      <returns>本機變數類型的類型符號。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetTypeFromSpecification(System.Reflection.Metadata.MetadataReader,`1,System.Reflection.Metadata.TypeSpecificationHandle,System.Byte)">
      <summary>取得類型規格的類型符號。</summary>
      <param name="reader">已傳遞至簽章解碼器的中繼資料讀取器。 可以是 <see langword="null" />。</param>
      <param name="genericContext">已傳遞至簽章解碼器的內容。</param>
      <param name="handle">類型規格控點。</param>
      <param name="rawTypeKind">簽章中所指定的類型種類。 若要解譯此值，請使用 <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />。</param>
      <returns>類型規格的類型符號。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISimpleTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetPrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary>取得基本類型的類型符號。</summary>
      <param name="typeCode" />
      <returns>以下項目的類型符號： <param name="typeCode" />執行個體時提供 SQL Server 登入。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromDefinition(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeDefinitionHandle,System.Byte)">
      <summary>取得類型定義的類型符號。</summary>
      <param name="reader">已傳遞至簽章解碼器的中繼資料讀取器。 可以是 <see langword="null" />。</param>
      <param name="handle">類型定義控點。</param>
      <param name="rawTypeKind">簽章中所指定的類型種類。 若要解譯此值，請使用 <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />。</param>
      <returns>類型符號。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromReference(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeReferenceHandle,System.Byte)">
      <summary>取得類型參考的類型符號。</summary>
      <param name="reader">已傳遞至簽章解碼器的中繼資料讀取器。 可以是 <see langword="null" />。</param>
      <param name="handle">類型定義控點。</param>
      <param name="rawTypeKind">簽章中所指定的類型種類。 若要解譯此值，請使用 <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />。</param>
      <returns>類型符號。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISZArrayTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ISZArrayTypeProvider`1.GetSZArrayType(`0)">
      <summary>取得指定項目型別之一維陣列的型別符號，其下限為零。</summary>
      <param name="elementType" />
      <returns>
        <typeparamref name="TType" /> 執行個體。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstant">
      <summary>提供區域常數的相關資訊。 此資訊儲存在偵錯中繼資料中。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstant.Name" />
    <member name="P:System.Reflection.Metadata.LocalConstant.Signature">
      <summary>取得常數簽章。</summary>
      <returns>常數簽章。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandle" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Reflection.Metadata.LocalConstantHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.LocalConstantHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Equality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Inequality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection" />
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalConstantHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.LocalScope">
      <summary>提供本機變數和常數範圍的相關資訊。 此資訊儲存在偵錯中繼資料中。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScope.EndOffset" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetChildren" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalConstants" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalVariables" />
    <member name="P:System.Reflection.Metadata.LocalScope.ImportScope" />
    <member name="P:System.Reflection.Metadata.LocalScope.Length" />
    <member name="P:System.Reflection.Metadata.LocalScope.Method" />
    <member name="P:System.Reflection.Metadata.LocalScope.StartOffset" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandle" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Reflection.Metadata.LocalScopeHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Equality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Inequality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.Current" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#IDisposable#Dispose" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalScopeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.LocalVariable">
      <summary>提供區域變數的相關資訊。 此資訊儲存在偵錯中繼資料中。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariable.Attributes" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Index" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Name" />
    <member name="T:System.Reflection.Metadata.LocalVariableAttributes" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.DebuggerHidden" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.None" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandle" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Reflection.Metadata.LocalVariableHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.LocalVariableHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Equality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Inequality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection" />
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalVariableHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ManifestResource" />
    <member name="P:System.Reflection.Metadata.ManifestResource.Attributes">
      <summary>取得資訊清單資源的屬性。</summary>
      <returns>指定資訊清單資源屬性的列舉值的位元組合。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResource.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ManifestResource.Implementation">
      <summary>取得實作實體控制代碼。</summary>
      <returns>EntityHandle 實例。 如果 <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> 屬性為 <see langword="true" />，則傳回的控制碼會有預設值。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Name">
      <summary>取得資源名稱。</summary>
      <returns>資源名稱。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Offset">
      <summary>取得此資源記錄在參考檔案檔案中，從其開始處的位元組位移。</summary>
      <returns>此資源記錄開始的參考檔案內的位元組位移。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandle" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ManifestResourceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Equality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Inequality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection">
      <summary>表示 <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" /> 執行個體的集合。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ManifestResourceHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MemberReference" />
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeFieldSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MemberReference.GetKind">
      <summary>判斷成員參考是方法或欄位。</summary>
      <returns>一個列舉值，表示成員參考的類型。</returns>
      <exception cref="T:System.BadImageFormatException">成員參考簽章無效。</exception>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Name" />
    <member name="P:System.Reflection.Metadata.MemberReference.Parent">
      <summary>取得父實體控制代碼。</summary>
      <returns>實體控制碼實例。 如果 <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> 屬性是 <see langword="true" />，則傳回的控制碼會有預設值。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Signature">
      <summary>取得簽章 Blob 的控制代碼。</summary>
      <returns>簽章 blob 的控制碼。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandle" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MemberReferenceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Equality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Inequality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection">
      <summary>表示 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /> 執行個體的集合。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MemberReferenceHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MemberReferenceKind">
      <summary>指定常數，以表示 <see cref="T:System.Reflection.Metadata.MemberReference" /> 是否參考方法或欄位。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Field">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReference" /> 參考欄位。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Method">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReference" /> 參考方法。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataKind" />
    <member name="F:System.Reflection.Metadata.MetadataKind.Ecma335">
      <summary>CLI 中繼資料。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.ManagedWindowsMetadata">
      <summary>由受控編譯器產生的 Windows 中繼資料。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.WindowsMetadata">
      <summary>Windows 中繼資料。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReader">
      <summary>如 ECMA 335 CLI 規格所定義，讀取中繼資料。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32)">
      <summary>從儲存在給定記憶體位置的中繼資料，初始化 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 類別的新執行個體。</summary>
      <param name="metadata">中繼資料區塊中第一個位元組的指標。</param>
      <param name="length">區塊中的位元組數目。</param>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary>從儲存在給定記憶體位置的中繼資料，初始化 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 類別的新執行個體。</summary>
      <param name="metadata" />
      <param name="length" />
      <param name="options" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>從儲存在給定記憶體位置的中繼資料，初始化 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 類別的新執行個體。</summary>
      <param name="metadata" />
      <param name="length" />
      <param name="options" />
      <param name="utf8Decoder" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> 不是正數。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="metadata" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="utf8Decoder" /> 的編碼並非 <see cref="T:System.Text.UTF8Encoding" />。</exception>
      <exception cref="T:System.PlatformNotSupportedException">目前平台為位元組由大到小。</exception>
      <exception cref="T:System.BadImageFormatException">不正確的中繼資料標頭。</exception>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyFiles" />
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.DebugMetadataHeader">
      <summary>從 #Pdb 資料流取得已解碼資訊，如果資料流不存在則為 <see langword="null" />。</summary>
      <returns>從 #Pdb 串流解碼的資訊，如果資料流程不存在，則 <see langword="null" />。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.DeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Documents" />
    <member name="P:System.Reflection.Metadata.MetadataReader.EventDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ExportedTypes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.FieldDefinitions" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyFile(System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyReference(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobBytes(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobContent(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.StringHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetConstant(System.Reflection.Metadata.ConstantHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttribute(System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttributes(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDeclarativeSecurityAttribute(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDocument(System.Reflection.Metadata.DocumentHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetEventDefinition(System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetExportedType(System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetFieldDefinition(System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameter(System.Reflection.Metadata.GenericParameterHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameterConstraint(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGuid(System.Reflection.Metadata.GuidHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetImportScope(System.Reflection.Metadata.ImportScopeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetInterfaceImplementation(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalConstant(System.Reflection.Metadata.LocalConstantHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScope(System.Reflection.Metadata.LocalScopeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalVariable(System.Reflection.Metadata.LocalVariableHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetManifestResource(System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMemberReference(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDefinition(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodImplementation(System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodSpecification(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleReference(System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinition(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinitionRoot" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetParameter(System.Reflection.Metadata.ParameterHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetPropertyDefinition(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetStandaloneSignature(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.StringHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeDefinition(System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeReference(System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeSpecification(System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetUserString(System.Reflection.Metadata.UserStringHandle)">
      <param name="handle" />
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.ImportScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.IsAssembly">
      <summary>取得值，這個值表示中繼資料是否代表組件。</summary>
      <returns>如果中繼資料代表元件，則 <see langword="true" />：否則，<see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalConstants" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalVariables" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ManifestResources" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MemberReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataKind">
      <summary>取得中繼資料類型。</summary>
      <returns>其中一個列舉值，指定中繼資料種類。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataLength">
      <summary>取得基礎資料的長度。</summary>
      <returns>基礎資料的長度。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataPointer">
      <summary>取得基礎資料的指標。</summary>
      <returns>基礎資料的指標。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataVersion">
      <summary>取得從中繼資料標頭讀取的版本字串。</summary>
      <returns>從中繼資料標頭讀取的版本字串。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Options">
      <summary>取得傳遞至建構函式的 <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" />。</summary>
      <returns>列舉值的位元組合，描述 <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" /> 的列舉值。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.PropertyDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.StringComparer">
      <summary>取得用來比較儲存在中繼資料中之字串的比較子。</summary>
      <returns>用來比較中繼資料中儲存之字串的比較子。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.UTF8Decoder">
      <summary>取得讀取器用來從 UTF8 編碼位元組序列產生字串執行個體的解碼器。</summary>
      <returns>讀取器用來從 UTF8 編碼的位元組序列產生字串實例的解碼器。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderOptions" />
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.ApplyWindowsRuntimeProjections">
      <summary>啟用 Windows 執行階段投影 (根據預設為開啟)。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.Default">
      <summary>當透過不接受 <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" /> 引數的多載取得 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 時，所使用的選項。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.None">
      <summary>停用所有選項。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderProvider">
      <summary>針對儲存在位元組陣列、記憶體區塊或資料流中的中繼資料提供 <see cref="T:System.Reflection.Metadata.MetadataReader" />。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.Dispose">
      <summary>處置所有由讀取器所配置的記憶體。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Byte*,System.Int32)">
      <summary>透過儲存在記憶體中的映像，建立中繼資料提供者。</summary>
      <param name="start">指向中繼資料 Blob 開頭的指標。</param>
      <param name="size">中繼資料 Blob 的大小。</param>
      <returns>新的中繼資料提供者。</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="start" /> 為 <see cref="F:System.IntPtr.Zero" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> 為負。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>透過位元組陣列建立提供者。</summary>
      <param name="image">中繼資料映像。</param>
      <returns>新的提供者。</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="image" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary>從資料流目前的位置開始，為指定大小的資料流建立提供者。</summary>
      <param name="stream">
        <see cref="T:System.IO.Stream" /> 執行個體。</param>
      <param name="options">指定如何從資料流讀取映像區段方法的選項。</param>
      <param name="size">資料流內中繼資料 Blob 的大小。 若未指定，則假設中繼資料 Blob 會延展到資料流結尾。</param>
      <returns>新的提供者。</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="stream" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="stream" /> 不支援讀取及搜尋作業。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">大小為負數或延展超過資料流的結尾。</exception>
      <exception cref="T:System.IO.IOException">從資料流讀取時發生錯誤 (只有在指定了 <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata" /> 時)。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Byte*,System.Int32)">
      <summary>透過記憶體中所儲存的 Blob，建立可攜式 PDB 中繼資料提供者。</summary>
      <param name="start">指向可攜式 PDB Blob 開頭的指標。</param>
      <param name="size">可攜式 PDB Blob 的大小。</param>
      <returns>新的可攜式 PDB 中繼資料提供者。</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="start" /> 為 <see cref="F:System.IntPtr.Zero" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> 為負。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>透過位元組陣列建立可攜式 PDB 中繼資料提供者。</summary>
      <param name="image">可攜式 PDB 映像。</param>
      <returns>新的可攜式 PDB 中繼資料提供者。</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="image" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary>從資料流目前的位置開始，為指定大小的資料流建立提供者。</summary>
      <param name="stream">資料流。</param>
      <param name="options">指定如何從資料流讀取映像區段的選項。</param>
      <param name="size">資料流內中繼資料 Blob 的大小。 若未指定，則假設中繼資料 Blob 會延展到資料流結尾。</param>
      <returns>
        <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> 執行個體。</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="stream" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="stream" /> 不支援讀取及搜尋作業。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">大小為負數或延展超過資料流的結尾。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.GetMetadataReader(System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>從 <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> 取得 <see cref="T:System.Reflection.Metadata.MetadataReader" />。</summary>
      <param name="options">列舉值的位元組合，表示讀取中繼資料時的組態。</param>
      <param name="utf8Decoder">要使用的編碼方式。</param>
      <returns>一個 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 執行個體。</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="utf8Decoder" /> 的編碼並非 <see cref="T:System.Text.UTF8Encoding" />。</exception>
      <exception cref="T:System.PlatformNotSupportedException">目前平台為位元組由大到小。</exception>
      <exception cref="T:System.IO.IOException">從基礎資料流讀取時出現 IO 錯誤。</exception>
      <exception cref="T:System.ObjectDisposedException">提供者已經過處置。</exception>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStreamOptions" />
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.Default">
      <summary>根據預設，當處置 <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> 之後即處置資料流，且會延遲讀取 PE 映像的區段。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen">
      <summary>當處置 <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> 之後保持資料流開啟。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata">
      <summary>立即將 PDB 中繼資料讀取至記憶體中。
建構 <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> 之後，可能會關閉甚至刪除基礎檔案。 除非指定 <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen" />，否則 <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> 會在建構函式傳回時自動關閉資料流。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringComparer">
      <summary>提供字串比較協助程式，以在中繼資料中查詢字串，同時盡可能避免配置。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringDecoder">
      <summary>為 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 提供自訂機制，以在代表文字的中繼資料中解碼位元組序列。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.#ctor(System.Text.Encoding)">
      <summary>使用指定的編碼初始化 <see cref="T:System.Reflection.Metadata.MetadataStringDecoder" /> 類別的新執行個體。</summary>
      <param name="encoding">要使用的編碼方式。</param>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.DefaultUTF8">
      <summary>當沒有提供建構函式解碼器時，取得 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 所使用的預設解碼器來解碼 UTF-8。</summary>
      <returns>
        <see cref="T:System.Reflection.Metadata.MetadataReader" /> 用來解碼 UTF-8 的預設解碼器。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding">
      <summary>取得這個執行個體所使用的編碼。</summary>
      <returns>這個實例所使用的編碼方式。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.GetString(System.Byte*,System.Int32)">
      <summary>從中繼資料中的位元組序列取得字串。 如有需要可覆寫此項目，以快取字串。 否則，它會藉由直接轉送至 <see cref="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding" /> 來實作，且每次呼叫都會配置新字串。</summary>
      <param name="bytes">要解碼的位元組指標。</param>
      <param name="byteCount">要解碼的位元組數目。</param>
      <returns>解碼的字串。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodBodyBlock" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.Create(System.Reflection.Metadata.BlobReader)">
      <param name="reader" />
    </member>
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.ExceptionRegions" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILBytes" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILContent" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILReader" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalSignature" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalVariablesInitialized" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.MaxStack" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.Size">
      <summary>取得方法主體的大小，包括標頭、IL 及例外狀況區域。</summary>
      <returns>方法主體的大小。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformation">
      <summary>提供與方法定義建立關聯的偵錯資訊。 此資訊儲存在偵錯中繼資料中。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.Document">
      <summary>取得單一文件的控制代碼，其中包含方法的所有序列點。</summary>
      <returns>單一檔的控制碼，其中包含方法的所有序列點，或如果方法沒有序列點或跨多個檔，則為其 <see cref="P:System.Reflection.Metadata.DocumentHandle.IsNil" /> 屬性的控制碼 <see langword="true" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetSequencePoints">
      <summary>傳回從 <see cref="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob" /> 解碼的序列點集合。</summary>
      <returns>序列點的集合。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetStateMachineKickoffMethod">
      <summary>傳回狀態機器的啟動方法。</summary>
      <returns>如果方法是狀態機器的 <c>MoveNext</c> 方法，則為狀態機器的啟動方法。 否則，它會傳回其 <see cref="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" /> 屬性為 <see langword="true" /> 的控制代碼。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.LocalSignature">
      <summary>傳回本機簽章控制代碼。</summary>
      <returns>本機簽章控制碼，或如果方法未定義任何本機變數，則為其 <see cref="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" /> 屬性 <see langword="true" /> 的控制碼。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob">
      <summary>傳回 Blob 編碼的序列點。</summary>
      <returns>Blob 編碼順序點，或如果方法沒有序列點，則為其 <see cref="P:System.Reflection.Metadata.BlobHandle.IsNil" /> 屬性的控制碼 <see langword="true" />。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Equality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Inequality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.ToDefinitionHandle">
      <summary>傳回對應至這個控點的 <see cref="T:System.Reflection.Metadata.MethodDefinition" /> 控點。</summary>
      <returns>對應至這個控制代碼的方法定義控制代碼。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection" />
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDebugInformationHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MethodDefinition" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Attributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetImport" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetParameters" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.ImplAttributes" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Name" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.RelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Equality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Inequality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.ToDebugInformationHandle">
      <summary>傳回對應至此控點的 <see cref="T:System.Reflection.Metadata.MethodDebugInformation" /> 控點。</summary>
      <returns>對應至這個控制代碼的方法偵錯資訊控制代碼。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection" />
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MethodImplementation" />
    <member name="M:System.Reflection.Metadata.MethodImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodBody" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodDeclaration" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.Type" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandle" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MethodImplementationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Equality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Inequality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection" />
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodImplementationHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MethodImport" />
    <member name="P:System.Reflection.Metadata.MethodImport.Attributes" />
    <member name="P:System.Reflection.Metadata.MethodImport.Module" />
    <member name="P:System.Reflection.Metadata.MethodImport.Name" />
    <member name="T:System.Reflection.Metadata.MethodSignature`1">
      <summary>表示方法 (定義、參考或獨立) 或屬性簽章。 針對屬性，簽章會符合具特殊 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 的 getter。</summary>
      <typeparam name="TType">方法類型。</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.MethodSignature`1.#ctor(System.Reflection.Metadata.SignatureHeader,`0,System.Int32,System.Int32,System.Collections.Immutable.ImmutableArray{`0})">
      <summary>使用指定的標頭、傳回型別及參數資訊，將 <see cref="T:System.Reflection.Metadata.MethodSignature`1" /> 結構的新執行個體初始化。</summary>
      <param name="header">簽章的前置位元組資訊 (種類、呼叫慣例、旗標)。</param>
      <param name="returnType">方法的傳回類型。</param>
      <param name="requiredParameterCount">必要參數數目。</param>
      <param name="genericParameterCount">泛型型別參數數目。</param>
      <param name="parameterTypes">參數類型。</param>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.GenericParameterCount">
      <summary>取得方法的泛型型別參數數目。</summary>
      <returns>泛型型別參數的數目，如果是非泛型方法，則為0。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.Header">
      <summary>取得簽章的前置位元組資訊 (種類、呼叫慣例、旗標)。</summary>
      <returns>標頭簽章。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ParameterTypes">
      <summary>取得方法的參數類型。</summary>
      <returns>參數類型的不可變集合。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.RequiredParameterCount">
      <summary>取得方法所需的參數數目。</summary>
      <returns>必要參數數目。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ReturnType">
      <summary>取得方法的傳回型別。</summary>
      <returns>傳回類型。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecification" />
    <member name="M:System.Reflection.Metadata.MethodSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodSpecification.Method">
      <summary>取得 <see langword="MethodDef" /> 或 <see langword="MemberRef" /> 控制代碼，其指定這個執行個體參考的泛型方法 (亦即，為其具現化的泛型方法)。</summary>
      <returns>
        <see langword="MethodDef" /> 或 <see langword="MemberRef" /> 的控制碼，指定這個實例所參考的泛型方法。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSpecification.Signature">
      <summary>取得簽章 Blob 的控制代碼。</summary>
      <returns>簽章 blob 的控制碼。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MethodSpecificationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Equality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Inequality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.ModuleDefinition" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.BaseGenerationId" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Generation" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.GenerationId" />
    <member name="M:System.Reflection.Metadata.ModuleDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Mvid" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Name" />
    <member name="T:System.Reflection.Metadata.ModuleDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ModuleDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Equality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Inequality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.ModuleReference" />
    <member name="M:System.Reflection.Metadata.ModuleReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleReference.Name" />
    <member name="T:System.Reflection.Metadata.ModuleReferenceHandle" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ModuleReferenceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Equality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Inequality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.NamespaceDefinition" />
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.ExportedTypes">
      <summary>取得直接位於命名空間內的所有匯出類型。</summary>
      <returns>匯出之類型控制碼的不可變數組。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Name">
      <summary>取得命名空間定義火的非限定名稱。</summary>
      <returns>命名空間定義的不合格名稱。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.NamespaceDefinitions">
      <summary>取得目前命名空間定義直接子系的命名空間定義。</summary>
      <returns>命名空間定義的不可變數組，屬於目前命名空間定義的直接子系。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Parent">
      <summary>取得父命名空間。</summary>
      <returns>父命名空間。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.TypeDefinitions">
      <summary>取得直接位於命名空間內的所有類型定義。</summary>
      <returns>類型定義控制碼的不可變數組。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.NamespaceDefinitionHandle">
      <summary>提供命名空間定義的控點。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Equality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.NamespaceDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Implicit(System.Reflection.Metadata.NamespaceDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Inequality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.Parameter" />
    <member name="P:System.Reflection.Metadata.Parameter.Attributes" />
    <member name="M:System.Reflection.Metadata.Parameter.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.Parameter.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.Parameter.GetMarshallingDescriptor" />
    <member name="P:System.Reflection.Metadata.Parameter.Name" />
    <member name="P:System.Reflection.Metadata.Parameter.SequenceNumber" />
    <member name="T:System.Reflection.Metadata.ParameterHandle" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Reflection.Metadata.ParameterHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ParameterHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Equality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Inequality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection">
      <summary>包含指定方法的參數集合。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ParameterHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.PEReaderExtensions" />
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader)">
      <summary>從 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 取得 <see cref="T:System.Reflection.PortableExecutable.PEReader" />。</summary>
      <param name="peReader">目前的 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 執行個體。</param>
      <returns>中繼資料讀取器。</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.PlatformNotSupportedException">目前平台為位元組由大到小。</exception>
      <exception cref="T:System.IO.IOException">從基礎資料流讀取時出現 IO 錯誤。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary>從 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 取得具有指定中繼資料讀取組態的中繼資料讀取器。</summary>
      <param name="peReader">目前的 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 執行個體。</param>
      <param name="options">指出中繼資料讀取組態的列舉值。</param>
      <returns>具有指定中繼資料讀取組態的中繼資料讀取器。</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.PlatformNotSupportedException">目前平台為位元組由大到小。</exception>
      <exception cref="T:System.IO.IOException">從基礎資料流讀取時出現 IO 錯誤。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>從 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 取得具有指定中繼資料讀取組態和編碼組態的中繼資料讀取器。</summary>
      <param name="peReader">目前的 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 執行個體。</param>
      <param name="options">指出中繼資料讀取組態的列舉值。</param>
      <param name="utf8Decoder">具有編碼組態的中繼資料字串解碼器。</param>
      <returns>&gt;具有指定中繼資料讀取設定和編碼設定的中繼資料讀取器。</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="utf8Decoder" /> 的編碼並非 <see cref="T:System.Text.UTF8Encoding" />。</exception>
      <exception cref="T:System.PlatformNotSupportedException">目前平台為位元組由大到小。</exception>
      <exception cref="T:System.IO.IOException">從基礎資料流讀取時出現 IO 錯誤。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMethodBody(System.Reflection.PortableExecutable.PEReader,System.Int32)">
      <summary>傳回具有指定相對虛擬位址 (RVA) 的方法主體區塊；</summary>
      <param name="peReader">目前的 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 執行個體。</param>
      <param name="relativeVirtualAddress">相對虛擬位址 (RVA)。</param>
      <returns>方法區塊主體執行個體。</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.BadImageFormatException">在中繼資料中找不到主體，或該主體無效。</exception>
      <exception cref="T:System.InvalidOperationException">沒有用於儲存方法的可用區段。</exception>
      <exception cref="T:System.IO.IOException">從基礎資料流讀取時發生 IO 錯誤。</exception>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveSerializationTypeCode">
      <summary>指定要在 <see cref="T:System.Reflection.Metadata.CustomAttribute" /> 值 Blob 中，定義用於編碼基本值類型的類型代碼。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Boolean">
      <summary>
        <see cref="T:System.Boolean" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Byte">
      <summary>不帶正負號的 1 位元整數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Char">
      <summary>
        <see cref="T:System.Char" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Double">
      <summary>8 位元浮點數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int16">
      <summary>帶正負號的 2 位元整數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int32">
      <summary>帶正負號的 4 位元整數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int64">
      <summary>帶正負號的 8 位元整數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.SByte">
      <summary>帶正負號的 1 位元整數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Single">
      <summary>4 位元浮點數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.String">
      <summary>
        <see cref="T:System.String" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt16">
      <summary>不帶正負號的 2 位元整數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt32">
      <summary>不帶正負號的 4 位元整數類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt64">
      <summary>不帶正負號的 8 位元整數類型。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveTypeCode">
      <summary>指定在中繼資料簽章中找到，定義基礎類型的常數。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Boolean">
      <summary>
        <see cref="T:System.Boolean" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Byte">
      <summary>
        <see cref="T:System.Byte" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Char">
      <summary>
        <see cref="T:System.Char" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Double">
      <summary>
        <see cref="T:System.Double" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int16">
      <summary>
        <see cref="T:System.Int16" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int32">
      <summary>
        <see cref="T:System.Int32" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int64">
      <summary>
        <see cref="T:System.Int64" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.IntPtr">
      <summary>
        <see cref="T:System.IntPtr" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Object">
      <summary>
        <see cref="T:System.Object" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.SByte">
      <summary>
        <see cref="T:System.SByte" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Single">
      <summary>
        <see cref="T:System.Single" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.String">
      <summary>
        <see cref="T:System.String" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference">
      <summary>具型別參考。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt16">
      <summary>
        <see cref="T:System.UInt16" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt32">
      <summary>
        <see cref="T:System.UInt32" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt64">
      <summary>
        <see cref="T:System.UInt64" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UIntPtr">
      <summary>
        <see cref="T:System.UIntPtr" /> 型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Void">
      <summary>
        <see cref="T:System.Void" /> 型別。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PropertyAccessors" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Getter" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Others" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Setter" />
    <member name="T:System.Reflection.Metadata.PropertyDefinition" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Attributes" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetDefaultValue" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Equality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Inequality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection" />
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#PropertyDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ReservedBlob`1">
      <summary>表示已保留供未來內容更新的中繼資料堆積控點和對應 Blob。</summary>
      <typeparam name="THandle" />
    </member>
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Content" />
    <member name="M:System.Reflection.Metadata.ReservedBlob`1.CreateWriter">
      <summary>傳回要用來更新內容的 <see cref="T:System.Reflection.Metadata.BlobWriter" />。</summary>
      <returns>要用來更新內容的 Blob 寫入器。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Handle">
      <summary>取得保留的 Blob 控制代碼。</summary>
      <returns>保留的封鎖控制碼。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SequencePoint" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Document" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndLine" />
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Reflection.Metadata.SequencePoint)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.GetHashCode" />
    <member name="F:System.Reflection.Metadata.SequencePoint.HiddenLine" />
    <member name="P:System.Reflection.Metadata.SequencePoint.IsHidden" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Offset" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartLine" />
    <member name="T:System.Reflection.Metadata.SequencePointCollection" />
    <member name="T:System.Reflection.Metadata.SequencePointCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.MoveNext" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.Reset" />
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#SequencePoint}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.SerializationTypeCode">
      <summary>指定要在 <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" /> Blob 中用於編碼值類型的類型代碼。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Boolean">
      <summary>等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Boolean" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Byte">
      <summary>等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Byte" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Char">
      <summary>等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Char" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Double">
      <summary>等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Double" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Enum">
      <summary>屬性引數是 Enum 執行個體。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int16">
      <summary>等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int16" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int32">
      <summary>等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int32" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int64">
      <summary>等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int64" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Invalid">
      <summary>等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SByte">
      <summary>等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SByte" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Single">
      <summary>等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Single" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.String">
      <summary>等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.String" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SZArray">
      <summary>等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SZArray" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.TaggedObject">
      <summary>屬性引數為 "boxed" (傳遞至參數、欄位，或是類型物件的屬性)，且附帶屬性 Blob 中的類型資訊。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Type">
      <summary>屬性引數是 <see cref="T:System.Type" /> 執行個體。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt16">
      <summary>等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt16" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt32">
      <summary>等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt32" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt64">
      <summary>等於 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt64" /> 的值。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureAttributes">
      <summary>指定可套用到方法簽章的其他旗標。 此類型中的欄位基礎值會對應 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 結構代表的前置簽章位元組。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis">
      <summary>表示代表執行個體指標的明確宣告參數。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Generic">
      <summary>泛型方法。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Instance">
      <summary>執行個體方法。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.None">
      <summary>沒有旗標。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureCallingConvention">
      <summary>指定呼叫者如何將指定簽章中的引數傳遞給被呼叫者。 此類型中的欄位基礎值會對應 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 結構代表的前置簽章位元組。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.CDecl">
      <summary>呼叫者已清除呼叫堆疊的 Unmanaged C/C++ 樣式呼叫慣例。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.Default">
      <summary>具有固定長度引數清單的 Managed 呼叫慣例。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.FastCall">
      <summary>引數會傳遞至其中的 Unmanaged 呼叫慣例 (如果可能的話)。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.StdCall">
      <summary>被呼叫者已清除呼叫堆疊的 Unmanaged 呼叫慣例。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.ThisCall">
      <summary>使用固定引數清單來呼叫執行個體成員函式的 Unmanaged C/C++ 樣式呼叫慣例。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.VarArgs">
      <summary>用於傳遞額外引數的 Managed 呼叫慣例。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureHeader">
      <summary>表示簽章 Blob 的前置位元組所指定的簽章特性。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Byte)">
      <summary>使用指定的位元組值，初始化 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 結構的新執行個體。</summary>
      <param name="rawValue">位元組。</param>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Reflection.Metadata.SignatureKind,System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.SignatureAttributes)">
      <summary>使用指定的簽章種類、呼叫慣例與簽章屬性，將 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 結構的新執行個體初始化。</summary>
      <param name="kind">簽章種類。</param>
      <param name="convention">呼叫慣例。</param>
      <param name="attributes">簽章屬性。</param>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Attributes">
      <summary>取得簽章屬性。</summary>
      <returns>屬性。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.CallingConvention">
      <summary>取得呼叫慣例。</summary>
      <returns>呼叫慣例。</returns>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask">
      <summary>取得呼叫慣例或簽章種類的遮罩值。 預設 <see cref="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask" /> 值為 15 (0x0F)。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Object)">
      <summary>比對指定物件與此 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 是否相等。</summary>
      <param name="obj">要比較的物件。</param>
      <returns>如果物件相等則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Reflection.Metadata.SignatureHeader)">
      <summary>比較兩個 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 值是否相等。</summary>
      <param name="other">要比較的值。</param>
      <returns>如果值相等，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.GetHashCode">
      <summary>取得目前物件的雜湊碼。</summary>
      <returns>目前物件的雜湊碼。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.HasExplicitThis">
      <summary>取得值，指出這個 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 結構是否具有 <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" /> 簽章屬性。</summary>
      <returns>
        <see langword="true" />如果屬性存在，則為， <see langword="false" />否則為。 <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" /></returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsGeneric">
      <summary>取得值，指出這個 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 結構是否具有 <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" /> 簽章屬性。</summary>
      <returns>
        <see langword="true" />如果屬性存在，則為， <see langword="false" />否則為。 <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" /></returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsInstance">
      <summary>取得值，指出這個 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 結構是否具有 <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" /> 簽章屬性。</summary>
      <returns>
        <see langword="true" />如果屬性存在，則為， <see langword="false" />否則為。 <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" /></returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Kind">
      <summary>取得簽章種類。</summary>
      <returns>簽章種類。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Equality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary>比較兩個 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 值是否相等。</summary>
      <param name="left">要比較的第一個值。</param>
      <param name="right">要比較的第二個值。</param>
      <returns>如果值相等，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Inequality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary>判斷兩個 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 值是否不相等。</summary>
      <param name="left">要比較的第一個值。</param>
      <param name="right">要比較的第二個值。</param>
      <returns>如果值相等即為 <see langword="true" />，否則為 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.RawValue">
      <summary>取得標頭位元組的未經處理值。</summary>
      <returns>標頭位元組的原始值。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.ToString">
      <summary>傳回代表目前物件的字串。</summary>
      <returns>表示目前物件的字串。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureKind">
      <summary>指定簽章種類。 此類型中的欄位基礎值會對應 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 結構代表的前置簽章位元組。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Field">
      <summary>欄位簽章。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.LocalVariables">
      <summary>區域變數簽章。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Method">
      <summary>方法參考、方法定義或獨立方法簽章。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.MethodSpecification">
      <summary>方法規格簽章。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Property">
      <summary>屬性簽章。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeCode">
      <summary>指定在簽章編碼中用於定義類型代碼的常數。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Array">
      <summary>表示簽章中的通用 <see cref="T:System.Array" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Boolean">
      <summary>表示簽章中的 <see cref="T:System.Boolean" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.ByReference">
      <summary>表示簽章中的 Managed 指標 (byref 傳回值與參數)。 基礎類型的簽章編碼會在 Blob 中跟隨它。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Byte">
      <summary>表示簽章中的 <see cref="T:System.Byte" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Char">
      <summary>表示簽章中的 <see cref="T:System.Char" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Double">
      <summary>表示簽章中的 <see cref="T:System.Double" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.FunctionPointer">
      <summary>表示簽章中的函式指標類型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericMethodParameter">
      <summary>表示在簽章中使用的泛型方法參數。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeInstance">
      <summary>表示簽章中泛型型別的具現化。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeParameter">
      <summary>表示在簽章中使用的泛型型別參數。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int16">
      <summary>表示簽章中的 <see cref="T:System.Int16" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int32">
      <summary>表示簽章中的 <see cref="T:System.Int32" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int64">
      <summary>表示簽章中的 <see cref="T:System.Int64" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.IntPtr">
      <summary>表示簽章中的 <see cref="T:System.IntPtr" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Invalid">
      <summary>表示無效或未初始化的類型代碼。 不會在有效簽章中出現。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Object">
      <summary>表示簽章中的 <see cref="T:System.Object" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.OptionalModifier">
      <summary>表示呼叫者可略過的簽章中，套用到類型的 Custom 修飾詞。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pinned">
      <summary>表示記憶體回收行程固定的區域變數。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pointer">
      <summary>表示簽章中的 Unmanaged 指標。 基礎類型的簽章編碼會在 Blob 中跟隨它。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.RequiredModifier">
      <summary>表示呼叫者必須理解的簽章中，套用到類型的 Custom 修飾詞。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SByte">
      <summary>表示簽章中的 <see cref="T:System.SByte" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Sentinel">
      <summary>表示標記，以指出固定引數的結尾與變數引數的開頭。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Single">
      <summary>表示簽章中的 <see cref="T:System.Single" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.String">
      <summary>表示簽章中的 <see cref="T:System.String" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SZArray">
      <summary>表示下限為 0 的 一維 <see cref="T:System.Array" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypedReference">
      <summary>表示簽章中的具型別參考。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypeHandle">
      <summary>優先簽章中的類型 <see cref="T:System.Reflection.Metadata.EntityHandle" />。 在原始中繼資料中，這會編碼為 ELEMENT_TYPE_CLASS (0x12) (若為參考型別) 或 ELEMENT_TYPE_VALUETYPE (0x11) (若為實值型別)。 因為 Windows 執行階段投影可在類別與實值型別之間交換投影，所以這會摺疊成單一程式碼，而原始程式碼在這些情況下會產生誤導。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt16">
      <summary>表示簽章中的 <see cref="T:System.UInt16" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt32">
      <summary>表示簽章中的 <see cref="T:System.UInt32" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt64">
      <summary>表示簽章中的 <see cref="T:System.UInt64" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UIntPtr">
      <summary>表示簽章中的 <see cref="T:System.UIntPtr" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Void">
      <summary>表示簽章中的 <see cref="T:System.Void" />。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeKind">
      <summary>指出簽章的類型定義。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Class">
      <summary>參考類別的類型定義或參考。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Unknown">
      <summary>在目前的內容中，無法判斷類型參考或定義是類別或實值型別。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.ValueType">
      <summary>參考實值型別的類型定義或參考。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignature" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeLocalSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetKind">
      <summary>判斷簽章的種類，它可以是 <see cref="F:System.Reflection.Metadata.SignatureKind.Method" /> 或 <see cref="F:System.Reflection.Metadata.SignatureKind.LocalVariables" />。</summary>
      <returns>指出簽章種類的列舉值。</returns>
      <exception cref="T:System.BadImageFormatException">簽章無效。</exception>
    </member>
    <member name="P:System.Reflection.Metadata.StandaloneSignature.Signature">
      <summary>取得簽章 Blob 的控制代碼。</summary>
      <returns>簽章 blob 的控制碼。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignatureHandle" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Equality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Inequality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignatureKind">
      <summary>指出 <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> 表示獨立方法或區域變數簽章。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.LocalVariables">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReference" /> 參考區域變數簽章。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.Method">
      <summary>
        <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> 表示獨立方法簽章。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StringHandle" />
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Reflection.Metadata.StringHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.StringHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.StringHandle.op_Equality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StringHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Implicit(System.Reflection.Metadata.StringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Inequality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinition" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.BaseType">
      <summary>取得型別定義的基底型別：<see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />。</summary>
      <returns>型別定義的基底型別。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclaringType">
      <summary>傳回指定巢狀型別的封入型別。</summary>
      <returns>指定巢狀型別的封入型別，或型別不是巢狀時，其 <see cref="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" /> 屬性為 <see langword="true" /> 的控制代碼。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetEvents" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetFields" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetInterfaceImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetLayout" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethodImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethods" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetNestedTypes">
      <summary>傳回指定型別中巢狀型別的陣列。</summary>
      <returns>型別定義控制代碼的不可變陣列，表示指定型別中的巢狀型別。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetProperties" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.IsNested">
      <summary>取得值，這個值指出這是否為巢狀型別。</summary>
      <returns>
        <see langword="true" />如果它是巢狀型別，則<see langword="false" />為，否則為。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Name">
      <summary>取得型別的名稱。</summary>
      <returns>型別的名稱。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Namespace">
      <summary>取得型別定義所在之命名空間的完整名稱。</summary>
      <returns>定義類型之命名空間的完整名稱，或如果類型是在根命名<see cref="P:System.Reflection.Metadata.StringHandle.IsNil" />空間中<see langword="true" />進行嵌套或定義，則為其屬性為的控制碼。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.NamespaceDefinition">
      <summary>取得型別定義所在之命名空間的定義控制代碼。</summary>
      <returns>定義類型之命名空間的定義控制碼，或如果類型是在根<see cref="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" />命名空間<see langword="true" />中進行嵌套或定義，則為其屬性為的控制碼。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Equality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Inequality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection">
      <summary>包含 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 執行個體的集合。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.TypeLayout" />
    <member name="M:System.Reflection.Metadata.TypeLayout.#ctor(System.Int32,System.Int32)">
      <param name="size" />
      <param name="packingSize" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeLayout.IsDefault" />
    <member name="P:System.Reflection.Metadata.TypeLayout.PackingSize" />
    <member name="P:System.Reflection.Metadata.TypeLayout.Size" />
    <member name="T:System.Reflection.Metadata.TypeReference" />
    <member name="P:System.Reflection.Metadata.TypeReference.Name">
      <summary>取得目標型別的名稱。</summary>
      <returns>目標型別的名稱。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.Namespace">
      <summary>取得目標型別定義所在之命名空間的完整名稱。</summary>
      <returns>定義目標型別之命名空間的完整名稱，或如果在根命名空間中嵌套或定義類型，則為 <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /> 屬性的控制碼 <see langword="true" />）。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.ResolutionScope">
      <summary>取得定義目標型別並由指定的 <see cref="P:System.Reflection.Metadata.TypeReference.Namespace" /> 和 <see cref="P:System.Reflection.Metadata.TypeReference.Name" /> 唯一識別的解析範圍。</summary>
      <returns>解析範圍，其中的目標型別是唯一定義的。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandle" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.TypeReferenceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Equality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Inequality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection">
      <summary>包含 <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 執行個體的集合。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeReferenceHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.TypeSpecification" />
    <member name="M:System.Reflection.Metadata.TypeSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.TypeSpecification.Signature" />
    <member name="T:System.Reflection.Metadata.TypeSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.TypeSpecificationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Equality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Inequality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.UserStringHandle">
      <summary>表示使用者字串堆積的控點。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Reflection.Metadata.UserStringHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.UserStringHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Equality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.UserStringHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Implicit(System.Reflection.Metadata.UserStringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Inequality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.MethodImportAttributes" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionCDecl" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionFastCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionStdCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionThisCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionWinApi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAnsi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAuto" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetUnicode" />
    <member name="F:System.Reflection.MethodImportAttributes.ExactSpelling" />
    <member name="F:System.Reflection.MethodImportAttributes.None" />
    <member name="F:System.Reflection.MethodImportAttributes.SetLastError" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharMask" />
    <member name="T:System.Reflection.MethodSemanticsAttributes" />
    <member name="F:System.Reflection.MethodSemanticsAttributes.Adder">
      <summary>用於新增事件的處理常式。 對應至 Ecma 335 CLI 規格中的 <see langword="AddOn" /> 旗標。
符合 CLS 規範的 adder 會使用 <see langword="add_" /> 前置詞來命名。</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Getter">
      <summary>讀取屬性的值。
符合 CLS 規範的 getter 會使用 `get_` 前置詞來命名。</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Other">
      <summary>屬性 (不是 getter 或 setter) 或事件 (不是 adder、remover 或 raiser) 的其他方法。</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Raiser">
      <summary>用來表示事件已發生。 對應至 Ecma 335 CLI 規格中的 <see langword="Fire" /> 旗標。
 符合 CLS 規範的 raiser 會使用 <see langword="raise_" /> 前置詞來命名。</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Remover">
      <summary>用於移除事件的處理常式。 對應至 Ecma 335 CLI 規格中的 <see langword="RemoveOn" /> 旗標。
符合 CLS 規範的 remover 會使用 <see langword="remove_" /> 前置詞來命名。</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Setter">
      <summary>用來修改屬性的值。
符合 CLS 規範的 setter 會使用 <see langword="set_" /> 前置詞來命名。</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.AggressiveWSTrim" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Bit32Machine" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedHi" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedLo" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.DebugStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Dll" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.ExecutableImage" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LargeAddressAware" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LineNumsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LocalSymsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.NetRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RelocsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RemovableRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.System" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.UpSystemOnly" />
    <member name="T:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData">
      <summary>提供程式偵錯資料庫 (PDB) 檔案的相關資訊。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Age">
      <summary>PDB 的反覆項目。 第一個反覆項目為 1。 每次擴充 PDB 內容時，反覆項目便會遞增。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Guid">
      <summary>相關聯 PDB 的全域唯一識別碼 (GUID)。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Path">
      <summary>包含 PE/COFF 檔案偵錯資訊的 .pdb 檔案路徑。</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CoffHeader">
      <summary>代表 COFF 檔案的標頭。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Characteristics">
      <summary>取得指出檔案屬性的旗標。</summary>
      <returns>指示檔案屬性的旗標。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Machine">
      <summary>取得目標機器的類型。</summary>
      <returns>目的電腦的類型。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSections">
      <summary>取得區段的數目。 這指出區段表 (緊接在標頭之後) 的大小。</summary>
      <returns>區段的數目。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSymbols">
      <summary>取得符號表中的項目數目。 此資料可以用來尋找字串表 (緊接在符號表之後)。 PE 映像的這個值應該為零。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.PointerToSymbolTable">
      <summary>取得 COFF 符號表的檔案指標。</summary>
      <returns>COFF 符號表的檔案指標，如果不存在 COFF 符號表則為零。 PE 映像的這個值應該為零。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.SizeOfOptionalHeader">
      <summary>取得選擇性標頭 (對可執行檔是必要的，但對物件檔案不是) 的大小。 物件檔案的這個值應該為零。</summary>
      <returns>選擇性標頭的大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.TimeDateStamp">
      <summary>取得指出檔案建立時間的值。</summary>
      <returns>自00:00 年1月1日起的秒數的低32位1970，表示檔案的建立時間。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CorFlags" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILLibrary" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILOnly" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.NativeEntryPoint" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Prefers32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Requires32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.StrongNameSigned" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.TrackDebugData" />
    <member name="T:System.Reflection.PortableExecutable.CorHeader" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.CodeManagerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.EntryPointTokenOrRelativeVirtualAddress" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ExportAddressTableJumpsDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.Flags" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MajorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ManagedNativeHeaderDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MetadataDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MinorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ResourcesDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.StrongNameSignatureDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.VtableFixupsDirectory" />
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" />
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.#ctor">
      <summary>初始化 <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" /> 類別的新執行個體。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddCodeViewEntry(System.String,System.Reflection.Metadata.BlobContentId,System.UInt16)">
      <summary>新增 CodeView 項目。</summary>
      <param name="pdbPath">PDB 的路徑。 不得為空白。</param>
      <param name="pdbContentId">PDB 內容的唯一識別碼。</param>
      <param name="portablePdbVersion">可攜式 PDB 格式的版本 (例如 1.0 版為 0x0100)，如果 PDB 無法攜帶，則為 0。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="pdbPath" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="pdbPath" /> 包含 NUL 字元。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="portablePdbVersion" /> 小於 0x0100。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEmbeddedPortablePdbEntry(System.Reflection.Metadata.BlobBuilder,System.UInt16)">
      <summary>新增內嵌可攜式 PDB 項目。</summary>
      <param name="debugMetadata">可攜式 PDB 中繼資料產生器。</param>
      <param name="portablePdbVersion">可攜式 PDB 格式的版本 (例如 1.0 版為 0x0100)。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="debugMetadata" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="portablePdbVersion" /> 小於 0x0100。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32)">
      <summary>新增指定類型的項目。</summary>
      <param name="type">項目類型。</param>
      <param name="version">項目版本。</param>
      <param name="stamp">項目戳記。</param>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry``1(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32,``0,System.Action{System.Reflection.Metadata.BlobBuilder,``0})">
      <summary>新增指定類型的項目，並序列化其資料。</summary>
      <param name="type">項目類型。</param>
      <param name="version">項目版本。</param>
      <param name="stamp">項目戳記。</param>
      <param name="data">要傳遞至 <paramref name="dataSerializer" /> 的資料。</param>
      <param name="dataSerializer">將資料序列化為 <see cref="T:System.Reflection.Metadata.BlobBuilder" /> 的序列化程式。</param>
      <typeparam name="TData">傳遞給 <paramref name="dataSerializer" /> 的資料類型。</typeparam>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddPdbChecksumEntry(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>新增 PDB 總和檢查碼項目。</summary>
      <param name="algorithmName">雜湊演算法名稱 (例如 "SHA256")。</param>
      <param name="checksum">總和檢查碼。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="algorithmName" /> 或 <paramref name="checksum" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="algorithmName" /> 或 <paramref name="checksum" /> 是空的。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddReproducibleEntry">
      <summary>新增可重現的項目。</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntry">
      <summary>識別偵錯資訊區塊的位置、大小和格式。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryEntry.#ctor(System.UInt32,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.Int32,System.Int32,System.Int32)">
      <summary>初始化 <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryEntry" /> 結構的新執行個體。</summary>
      <param name="stamp" />
      <param name="majorVersion" />
      <param name="minorVersion" />
      <param name="type" />
      <param name="dataSize" />
      <param name="dataRelativeVirtualAddress" />
      <param name="dataPointer" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataPointer">
      <summary>取得偵錯資料的檔案指標。</summary>
      <returns>調試資料的檔案指標。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataRelativeVirtualAddress">
      <summary>在載入時，取得相對於基底映像的偵錯資料位址。</summary>
      <returns>相對於影像基底的 debug 資料位址。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataSize">
      <summary>取得偵錯資料的大小 (不包括偵錯目錄本身)。</summary>
      <returns>debug 資料的大小（不包括 debug 目錄）。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.IsPortableCodeView">
      <summary>取得值，指出此項目是否為指向可攜式 PDB 的 <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" /> 項目。</summary>
      <returns>
        <see langword="true" /> 如果專案是指向便攜 PDB 的 <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" /> 專案，則為，否則，<see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MajorVersion">
      <summary>取得偵錯資料格式的主要版本號碼。</summary>
      <returns>Debug 資料格式的主要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MinorVersion">
      <summary>取得偵錯資料格式的次要版本號碼。</summary>
      <returns>Debug 資料格式的次要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Stamp">
      <summary>如果 PE/COFF 檔案不具決定性，請取得偵錯資料的建立時間和日期；否則，請取得以內容雜湊為基礎的值。</summary>
      <returns>對於不具決定性的 PE/COFF 檔案，這是建立偵錯工具資料的時間和日期;否則，會根據內容的雜湊值。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Type">
      <summary>取得偵錯資訊的格式。</summary>
      <returns>調試資訊的格式。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntryType" />
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView">
      <summary>相關聯的 PDB 檔案描述。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Coff">
      <summary>COFF 偵錯資訊 (行號、符號表和字串表)。 使用檔案標頭中的欄位也可指向這類偵錯資訊。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb">
      <summary>此項目指向包含內嵌可攜式 PDB 的 Blob。 內嵌可攜式 PDB Blob 的格式如下：- blob ::= 未壓縮大小的資料- Data 會跨越 Blob 的其餘部分，並包含 Deflate 壓縮的可攜式 PDB。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.PdbChecksum">
      <summary>此項目會儲存建立 PE/COFF 檔案所用符號檔內容的加密雜湊。 雜湊可用來驗證指定的 PDB 檔案是否使用 PE/COFF 檔案建立，且不會因任何方式改變。 如果在建置 PE/COFF 檔案期間產生多個 PDB (例如私用和公用符號)，就會出現多個項目。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Reproducible">
      <summary>此項目出現即表示有具決定性的 PE/COFF 檔案。 如需詳細資訊，請參閱＜備註＞一節。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Unknown">
      <summary>所有工具都應該忽略未知值。</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DirectoryEntry" />
    <member name="M:System.Reflection.PortableExecutable.DirectoryEntry.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" />
      <param name="size" />
    </member>
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.RelativeVirtualAddress" />
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.Size" />
    <member name="T:System.Reflection.PortableExecutable.DllCharacteristics">
      <summary>描述動態連結程式庫的特性。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.AppContainer">
      <summary>映像必須在 AppContainer 內執行。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.DynamicBase">
      <summary>DLL 可以重新放置。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.HighEntropyVirtualAddressSpace">
      <summary>映像可以處理熵 64 位元的虛擬位址空間。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoBind">
      <summary>請勿繫結此映像。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoIsolation">
      <summary>映像了解隔離，且不想要它。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoSeh">
      <summary>映像不使用 SEH。 任何 SE 處理常式都不會保留在此映像中。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NxCompatible">
      <summary>映像與 NX 相容。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessInit">
      <summary>保留的。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessTerm">
      <summary>保留的。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.TerminalServerAware">
      <summary>映像可感知終端機伺服器。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadInit">
      <summary>保留的。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadTerm">
      <summary>保留的。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.WdmDriver">
      <summary>驅動程式會使用 WDM 模型。</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Machine">
      <summary>指定目的機器的 CPU 架構。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha">
      <summary>Alpha。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha64">
      <summary>ALPHA64。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.AM33">
      <summary>Matsushita AM33。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Amd64">
      <summary>AMD64 (K8)。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm">
      <summary>ARM 位元組由小到大。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm64">
      <summary>ARM64。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.ArmThumb2">
      <summary>ARM Thumb-2 位元組由小到大。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Ebc">
      <summary>EFI 位元組碼。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.I386">
      <summary>Intel 386。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.IA64">
      <summary>Intel 64。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.M32R">
      <summary>M32R 位元組由小到大。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MIPS16">
      <summary>MIPS。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu">
      <summary>MIPS (含 FPU)。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu16">
      <summary>MIPS16 (含 FPU)。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPC">
      <summary>IBM PowerPC 位元組由小到大。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPCFP">
      <summary>PowerPCFP。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3">
      <summary>Hitachi SH3 位元組由小到大。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3Dsp">
      <summary>Hitachi SH3 DSP。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3E">
      <summary>Hitachi SH3 位元組由小到大。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH4">
      <summary>Hitachi SH4 位元組由小到大。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH5">
      <summary>Hitachi SH5。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Thumb">
      <summary>Thumb。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Tricore">
      <summary>Infineon。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Unknown">
      <summary>目標 CPU 不明或未指定。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.WceMipsV2">
      <summary>MIPS 位元組由小到大 WCE v2。</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ManagedPEBuilder" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Reflection.Metadata.Ecma335.MetadataRootBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId},System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.ResourceSectionBuilder,System.Reflection.PortableExecutable.DebugDirectoryBuilder,System.Int32,System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.PortableExecutable.CorFlags)">
      <param name="header" />
      <param name="metadataRootBuilder" />
      <param name="deterministicIdProvider" />
      <param name="ilStream" />
      <param name="mappedFieldData" />
      <param name="managedResources" />
      <param name="nativeResources" />
      <param name="debugDirectoryBuilder" />
      <param name="strongNameSignatureSize" />
      <param name="entryPoint" />
      <param name="flags" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.GetDirectories" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.ManagedResourcesDataAlignment" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.MappedFieldDataAlignment" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" />
      <param name="location" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.Sign(System.Reflection.Metadata.BlobBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Byte[]})">
      <param name="peImage" />
      <param name="signatureProvider" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData">
      <summary>代表 PDB 總和檢查碼偵錯目錄項目。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.AlgorithmName">
      <summary>用來計算總和檢查碼之雜湊演算法的名稱。</summary>
      <returns>字串，表示用來計算總和檢查碼的加密雜湊演算法的名稱。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.Checksum">
      <summary>PDB 內容的總和檢查碼。</summary>
      <returns>不可變的位元組陣列，代表 PDB 內容的總和檢查碼。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEBuilder" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <param name="header" />
      <param name="deterministicIdProvider" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetDirectories" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetSections" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.Header" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IdProvider" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IsDeterministic" />
    <member name="T:System.Reflection.PortableExecutable.PEBuilder.Section" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Section.#ctor(System.String,System.Reflection.PortableExecutable.SectionCharacteristics)">
      <param name="name" />
      <param name="characteristics" />
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Name" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" />
      <param name="location" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder">
      <summary>建置 PE 目錄。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEDirectoriesBuilder.#ctor">
      <summary>初始化 <see cref="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder" /> 類別的執行個體。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.AddressOfEntryPoint">
      <summary>當 PE 檔案載入記憶體時，相對於基底映像的進入點位址。</summary>
      <returns>對於程式映射，這是起始位址。 若為設備磁碟機，這就是初始化函式的位址。 針對 Dll，進入點是選擇性的。 當沒有任何進入點時，此欄位必須為零。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BaseRelocationTable">
      <summary>基底重新配置資料表映像目錄項目。</summary>
      <returns>目錄專案實例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BoundImportTable">
      <summary>繫結匯入映像目錄項目。</summary>
      <returns>目錄專案實例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CopyrightTable">
      <summary>著作權/架構映像目錄項目。</summary>
      <returns>目錄專案實例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CorHeaderTable">
      <summary>COM 可描述映像目錄項目。</summary>
      <returns>目錄專案實例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DebugTable">
      <summary>偵錯資料表映像目錄項目。</summary>
      <returns>目錄專案實例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DelayImportTable">
      <summary>延遲匯入資料表映像目錄項目。</summary>
      <returns>目錄專案實例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExceptionTable">
      <summary>例外狀況資料表映像目錄項目。</summary>
      <returns>目錄專案實例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExportTable">
      <summary>匯出資料表映像目錄項目。</summary>
      <returns>目錄專案實例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.GlobalPointerTable">
      <summary>全域指標資料表映像目錄項目。</summary>
      <returns>目錄專案實例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportAddressTable">
      <summary>匯入位址表 (IAT) 映像目錄項目。</summary>
      <returns>目錄專案實例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportTable">
      <summary>匯入資料表映像目錄項目。</summary>
      <returns>目錄專案實例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.LoadConfigTable">
      <summary>負載組態資料表映像目錄項目。</summary>
      <returns>目錄專案實例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ResourceTable">
      <summary>資源資料表映像目錄項目。</summary>
      <returns>目錄專案實例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ThreadLocalStorageTable">
      <summary>執行緒區域 (TLS) 資料表映像目錄項目。</summary>
      <returns>目錄專案實例。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeader" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.AddressOfEntryPoint">
      <summary>當 PE 檔案載入記憶體時，取得相對於基底映像的進入點位址。</summary>
      <returns>相對於影像基底的進入點位址。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfCode">
      <summary>當映像載入記憶體時，取得相對於映像基底的程式碼開頭區段位址。</summary>
      <returns>相對於影像基底之起始程式碼區段的位址。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfData">
      <summary>當映像載入記憶體時，取得相對於映像基底的資料開頭區段位址。</summary>
      <returns>相對於影像基底的資料開頭區段的位址。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseRelocationTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BoundImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CertificateTableDirectory">
      <summary>取得憑證資料表項目，它會指向屬性憑證資料表。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CheckSum">
      <summary>取得映像檔案總和檢查碼。</summary>
      <returns>影像檔案總和檢查碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CopyrightTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CorHeaderTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DebugTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DelayImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DllCharacteristics" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExceptionTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment">
      <summary>取得對齊因素 (以位元組為單位)，用來對齊映像檔中的區段原始資料。</summary>
      <returns>介於512和64K （含）之間的2乘冪。 預設值為 512。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.GlobalPointerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImageBase">
      <summary>載入記憶體時，取得映像第一個位元組的慣用位址。</summary>
      <returns>慣用的位址，也就是64K 的倍數。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportAddressTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.LoadConfigTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Magic">
      <summary>取得可識別映像檔案格式的值。</summary>
      <returns>影像檔案的格式。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorImageVersion">
      <summary>取得映像的主要版本號碼。</summary>
      <returns>映像的主要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorLinkerVersion">
      <summary>取得連結器主要版本號碼。</summary>
      <returns>連結器主要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorOperatingSystemVersion">
      <summary>取得所需作業系統的主要版本號碼。</summary>
      <returns>所需作業系統的主要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorSubsystemVersion">
      <summary>取得子系統的主要版本號碼。</summary>
      <returns>子系統的主要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorImageVersion">
      <summary>取得映像的次要版本號碼。</summary>
      <returns>映像的次要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorLinkerVersion">
      <summary>取得連結器次要版本號碼。</summary>
      <returns>連結器次要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorOperatingSystemVersion">
      <summary>取得所需作業系統的次要版本號碼。</summary>
      <returns>所需作業系統的次要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorSubsystemVersion">
      <summary>取得子系統的次要版本號碼。</summary>
      <returns>子系統的次要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.NumberOfRvaAndSizes">
      <summary>取得剩餘 <see cref="T:System.Reflection.PortableExecutable.PEHeader" /> 中的資料目錄項目數目。 每一個都描述位置和大小。</summary>
      <returns>
        <see cref="T:System.Reflection.PortableExecutable.PEHeader" />其餘部分中的資料目錄專案數。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ResourceTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment">
      <summary>取得載入記憶體時對齊的區段 (以位元組為單位)。</summary>
      <returns>大於或等於 <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment" /> 的數位。 預設值為架構的頁面大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfCode">
      <summary>取得程式碼 (文字) 區段大小，或所有程式碼區段的總和 (如有多個區段)。</summary>
      <returns>程式碼（文字）區段的大小，或所有程式碼區段的總和（如果有多個區段）。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeaders">
      <summary>取得 MS DOS stub、PE 標頭和區段標頭的合併大小，四捨五入至 FileAlignment 的倍數。</summary>
      <returns>MS DOS stub、PE 標頭和區段標頭的合併大小，進位到 FileAlignment 的倍數。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit">
      <summary>取得要認可的區域堆積空間大小。</summary>
      <returns>要認可的本機堆積空間大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapReserve">
      <summary>取得要保留的區域堆積空間大小。 僅認可 <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit" />；其餘部分一次提供一頁，直到達到保留大小為止。</summary>
      <returns>要保留的區域堆積空間大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfImage">
      <summary>將映像載入記憶體時，取得包括所有標頭在內的映像大小 (以位元組為單位)。</summary>
      <returns>影像的大小（以位元組為單位），這是 <see cref="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment" /> 的倍數。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfInitializedData">
      <summary>取得已初始化資料區段大小，或所有這類區段的總和 (如有多個資料區段)。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit">
      <summary>取得要認可的堆疊大小。</summary>
      <returns>要認可的堆疊大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackReserve">
      <summary>取得要保留的堆疊大小。 僅認可 <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit" />；其餘部分一次提供一頁，直到達到保留大小為止。</summary>
      <returns>要保留的堆疊大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfUninitializedData">
      <summary>取得未初始化資料區段 (BSS) 大小，或所有這類區段的總和 (如有多個 BSS 區段)。</summary>
      <returns>未初始化資料區段（BSS）的大小，或所有這類區段的總和。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Subsystem">
      <summary>取得執行此映像所需的子系統名稱。</summary>
      <returns>執行此映射所需的子系統名稱。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ThreadLocalStorageTableDirectory" />
    <member name="T:System.Reflection.PortableExecutable.PEHeaderBuilder">
      <summary>定義可攜式可執行檔 (PE) 的標頭。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.#ctor(System.Reflection.PortableExecutable.Machine,System.Int32,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.Subsystem,System.Reflection.PortableExecutable.DllCharacteristics,System.Reflection.PortableExecutable.Characteristics,System.UInt64,System.UInt64,System.UInt64,System.UInt64,System.Int32,System.UInt64,System.Byte,System.Byte,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
      <summary>初始化 <see cref="T:System.Reflection.PortableExecutable.PEHeader" /> 類別的新執行個體。</summary>
      <param name="machine">目標機器的 CPU 架構。</param>
      <param name="sectionAlignment">載入至記憶體時對齊區段 (以位元組為單位)。 必須大於或等於 <paramref name="fileAlignment" />。 預設值為架構的頁面大小。</param>
      <param name="majorSubsystemVersion">子系統的主要版本號碼。</param>
      <param name="minorSubsystemVersion">子系統的次要版本號碼。</param>
      <param name="subsystem">執行映像所需的子系統。</param>
      <param name="dllCharacteristics">描述動態連結程式庫特性的物件。</param>
      <param name="imageCharacteristics">描述映像特性的物件。</param>
      <param name="sizeOfStackReserve">要保留的堆疊大小。 僅認可 <paramref name="sizeOfStackCommit" />；其餘部分一次提供一頁，直到達到保留大小為止。</param>
      <param name="sizeOfStackCommit">要認可的堆疊大小。</param>
      <param name="sizeOfHeapReserve">要保留的區域堆積空間大小。 僅認可 <paramref name="sizeOfHeapCommit" />；其餘部分一次提供一頁，直到達到保留大小為止。</param>
      <param name="sizeOfHeapCommit">要認可的區域堆積空間大小。</param>
      <param name="fileAlignment">對齊因素 (以位元組為單位)，用來對齊映像檔中的區段原始資料。 此值應為介於 512 和 64K (含) 之間 2 的乘冪。 預設值為 512。 如果 <paramref name="sectionAlignment" /> 小於架構的頁面大小，則 <paramref name="fileAlignment" /> 必須符合 <paramref name="sectionAlignment" />。</param>
      <param name="imageBase">映像載入至記憶體時，其第一個位元組的慣用位址；必須是 64K 的倍數。</param>
      <param name="majorLinkerVersion">連結器主要版本號碼。</param>
      <param name="minorLinkerVersion">連結器次要版本號碼。</param>
      <param name="majorOperatingSystemVersion">所需作業系統的主要版本號碼。</param>
      <param name="minorOperatingSystemVersion">所需作業系統的次要版本號碼。</param>
      <param name="majorImageVersion">映像的主要版本號碼。</param>
      <param name="minorImageVersion">映像的次要版本號碼。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="fileAlignment" /> 不是 512 和 64K 之間 2 的乘冪。
-或-
<paramref name="sectionAlignment" /> 不是 2 的乘冪。
-或-
<paramref name="sectionAlignment" /> 小於 <paramref name="fileAlignment" />。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateExecutableHeader">
      <summary>建立可執行檔標頭。</summary>
      <returns>表示可執行檔標頭的 <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" /> 執行個體。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateLibraryHeader">
      <summary>建立程式庫標頭。</summary>
      <returns>表示程式庫標頭的 <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" /> 執行個體。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.DllCharacteristics">
      <summary>傳回動態連結器程式庫特性。</summary>
      <returns>描述動態連結器程式庫特性的物件。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.FileAlignment">
      <summary>對齊因素 (以位元組為單位)，用來對齊映像檔中的區段原始資料。 此值應為介於 512 和 64K (含) 之間 2 的乘冪。 預設值為 512。 如果對齊後的區段小於架構頁面大小，則檔案對齊必須符合區段對齊。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageBase">
      <summary>映像載入至記憶體時，其第一個位元組的慣用位址；必須是 64K 的倍數。</summary>
      <returns>數位，代表載入記憶體時，第一個位元組影像的慣用位址。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageCharacteristics">
      <summary>傳回映像特性。</summary>
      <returns>代表影像特性的物件。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Machine">
      <summary>目標機器的 CPU 架構。</summary>
      <returns>其中一個列舉值，代表不同的 CPU 架構。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorImageVersion">
      <summary>映像的主要版本號碼。</summary>
      <returns>數位，<see cref="T:System.UInt16" /> 的大小，代表影像的主要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorLinkerVersion">
      <summary>連結器主要版本號碼。</summary>
      <returns>數位，<see cref="T:System.Byte" /> 的大小，代表連結器的主要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorOperatingSystemVersion">
      <summary>所需作業系統的主要版本號碼。</summary>
      <returns>數位，代表所需作業系統主要版本號碼的 <see cref="T:System.UInt16" /> 大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorSubsystemVersion">
      <summary>子系統的主要版本號碼。</summary>
      <returns>數位，<see cref="T:System.UInt16" /> 的大小，表示子系統的主要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorImageVersion">
      <summary>映像的次要版本號碼。</summary>
      <returns>數位，代表影像次要版本號碼的 <see cref="T:System.UInt16" /> 大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorLinkerVersion">
      <summary>連結器次要版本號碼。</summary>
      <returns>數位，<see cref="T:System.Byte" /> 的大小，代表連結器次要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorOperatingSystemVersion">
      <summary>所需作業系統的次要版本號碼。</summary>
      <returns>數位，代表所需作業系統次要版本號碼的 <see cref="T:System.UInt16" /> 大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorSubsystemVersion">
      <summary>子系統的次要版本號碼。</summary>
      <returns>數位，<see cref="T:System.UInt16" /> 的大小，代表子系統的次要版本號碼。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SectionAlignment">
      <summary>載入至記憶體時對齊區段 (以位元組為單位)。</summary>
      <returns>數位，代表載入記憶體時區段的對齊（以位元組為單位）。 必須大於或等於檔案對齊。 預設值為架構的頁面大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit">
      <summary>要認可的區域堆積空間大小。</summary>
      <returns>表示要認可的本機堆積空間大小的數位。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapReserve">
      <summary>要保留的區域堆積空間大小。 僅認可 <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit" />；其餘部分一次提供一頁，直到達到保留大小為止。</summary>
      <returns>代表要保留之本機堆積空間大小的數位。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit">
      <summary>要認可的堆疊大小。</summary>
      <returns>代表要認可之堆疊大小的數位。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackReserve">
      <summary>要保留的堆疊大小。 僅認可 <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit" />；其餘部分一次提供一頁，直到達到保留大小為止。</summary>
      <returns>代表要保留之堆疊大小的數位。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Subsystem">
      <summary>執行此映像所需的子系統。</summary>
      <returns>
        <see cref="T:System.Reflection.PortableExecutable.Subsystem" /> 執行個體。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeaders">
      <summary>定義可從資料流讀取 PE (可攜式執行檔) 和 COFF (通用物件檔案格式) 標頭的類型。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream)">
      <summary>具現化 <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> 類別的新執行個體，它會在指定資料流的目前位置讀取 PE 標頭。</summary>
      <param name="peStream">資料流，包含從資料流目前位置開始，結束於資料流結尾的 PE 映像。</param>
      <exception cref="T:System.BadImageFormatException">從資料流讀取的資料格式無效。</exception>
      <exception cref="T:System.IO.IOException">在資料流中讀取時發生錯誤。</exception>
      <exception cref="T:System.ArgumentException">資料流不支援搜尋作業。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32)">
      <summary>具現化 <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> 類別的新執行個體，它會從表示指定大小 PE 映像的資料流中讀取 PE 標頭。</summary>
      <param name="peStream">資料流，包含從其目前位置開始的指定大小 PE 映像。</param>
      <param name="size">PE 映像大小。</param>
      <exception cref="T:System.BadImageFormatException">從資料流讀取的資料格式無效。</exception>
      <exception cref="T:System.IO.IOException">在資料流中讀取時發生錯誤。</exception>
      <exception cref="T:System.ArgumentException">資料流不支援搜尋作業。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> 為負數或延展超過資料流的結尾。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
      <summary>具現化 <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> 類別的新執行個體，它會從表示指定大小 PE 映像的資料流中讀取 PE 標頭，並指出 PE 映像是否已載入至記憶體。</summary>
      <param name="peStream">資料流，包含從其目前位置開始的指定大小 PE 映像。</param>
      <param name="size">PE 映像大小。</param>
      <param name="isLoadedImage">如果作業系統載入器已將 PE 映像載入至記憶體，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
      <exception cref="T:System.BadImageFormatException">從資料流讀取的資料格式無效。</exception>
      <exception cref="T:System.IO.IOException">在資料流中讀取時發生錯誤。</exception>
      <exception cref="T:System.ArgumentException">資料流不支援搜尋作業。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> 為負數或延展超過資料流的結尾。</exception>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeader">
      <summary>取得映像的 COFF 標頭。</summary>
      <returns>影像的 COFF 標頭。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeaderStartOffset">
      <summary>取得從 PE 映像開頭到 COFF 標頭開頭的位元組位移。</summary>
      <returns>從 PE 映射開頭到 COFF 標頭開頭的位元組位移。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeader">
      <summary>取得 COR 標頭。</summary>
      <returns>COR 標頭，如果影像沒有則為 <see langword="null" />。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeaderStartOffset">
      <summary>取得從映像開頭到 COR 標頭的位元組位移。</summary>
      <returns>從影像開頭到 COR 標頭的位元組位移; 如果影像沒有 COR 標頭，則為-1。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.GetContainingSectionIndex(System.Int32)">
      <summary>在 PE 映像區段中搜尋包含指定相對虛擬位址的區段。</summary>
      <param name="relativeVirtualAddress">要搜尋的相對虛擬位址。</param>
      <returns>包含 <paramref name="relativeVirtualAddress" /> 的區段索引；如果搜尋失敗，則為 -1。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsCoffOnly">
      <summary>取得值，指出是否僅為 Coff 映像。</summary>
      <returns>如果影像僅為 Coff，則 <see langword="true" />;否則，<see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsConsoleApplication">
      <summary>取得值，指出映像是否表示 Windows 主控台應用程式。</summary>
      <returns>如果映射是 Windows 主控台應用程式，則 <see langword="true" />;否則，<see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsDll">
      <summary>取得值，指出映像是否表示動態連結程式庫。</summary>
      <returns>如果映射是 DLL，則 <see langword="true" />;否則，<see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsExe">
      <summary>取得值，指出映像是否表示可執行檔。</summary>
      <returns>如果映射是可執行檔，則 <see langword="true" />;否則，<see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataSize">
      <summary>取得 CLI 中繼資料大小。</summary>
      <returns>CLI 中繼資料的大小，如果影像不包含中繼資料，則為0。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataStartOffset">
      <summary>取得從 PE 映像開頭到 CLI 中繼資料開頭的位移 (以位元組為單位)。</summary>
      <returns>從 PE 映射開頭到 CLI 中繼資料開頭的位移（以位元組為單位）; 如果影像不包含中繼資料，則為-1。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeader">
      <summary>取得映像的 PE 標頭。</summary>
      <returns>映射的 PE 標頭，如果影像僅為 COFF，則為 <see langword="null" />。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeaderStartOffset">
      <summary>取得映像開頭的標頭位元組位移。</summary>
      <returns>從影像開頭開始的標頭位元組位移。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.SectionHeaders">
      <summary>取得 PE 區段標頭。</summary>
      <returns>包含 PE 區段標頭的陣列。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.TryGetDirectoryOffset(System.Reflection.PortableExecutable.DirectoryEntry,System.Int32@)">
      <summary>取得從映像開頭到指定目錄資料的位移 (以位元組為單位)。</summary>
      <param name="directory">PE 目錄項目。</param>
      <param name="offset">當此方法傳回時，會包含從映像開頭到指定目錄資料的位移。</param>
      <returns>如果找到目錄資料，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEMagic" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32Plus" />
    <member name="T:System.Reflection.PortableExecutable.PEMemoryBlock" />
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent">
      <summary>將整個區塊的內容讀入到陣列。</summary>
      <returns>不可變的位元組陣列。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent(System.Int32,System.Int32)">
      <summary>將部分的區塊內容讀入到陣列。</summary>
      <param name="start">區塊中的開頭位置。</param>
      <param name="length">要讀取的位元組數。</param>
      <returns>不可變的位元組陣列。</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">區塊中不包含指定的範圍。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader">
      <summary>針對跨越整個區塊的 Blob 建立 <see cref="T:System.Reflection.Metadata.BlobReader" />。</summary>
      <returns>適用於跨越整個區塊的 Blob 讀取器。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader(System.Int32,System.Int32)">
      <summary>針對跨越部分區塊的 Blob 建立 <see cref="T:System.Reflection.Metadata.BlobReader" />。</summary>
      <param name="start">區塊中的開頭位置。</param>
      <param name="length">部分區塊的位元組數目。</param>
      <returns>適用於跨越部分區塊的 Blob 讀取器。</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">區塊中不包含指定的範圍。</exception>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Length">
      <summary>取得區塊的長度。</summary>
      <returns>區塊的長度。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Pointer">
      <summary>取得區塊的第一個位元組指標。</summary>
      <returns>區塊的第一個位元組指標。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEReader">
      <summary>提供適用於可攜式可執行檔格式 (PE) 檔案的讀取器。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32)">
      <summary>透過儲存在記憶體中的 PE 映像，建立可攜式可執行檔讀取器。</summary>
      <param name="peImage">PE 映像開頭的指標。</param>
      <param name="size">PE 映像的大小。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> 為 <see cref="F:System.IntPtr.Zero" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> 為負。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32,System.Boolean)">
      <summary>透過儲存在記憶體中的 PE 映像，建立可攜式可執行檔讀取器。 旗標，指出映像是否已載入至記憶體。</summary>
      <param name="peImage">PE 映像開頭的指標。</param>
      <param name="size">PE 映像的大小。</param>
      <param name="isLoadedImage">如果作業系統載入器已將 PE 映像載入至記憶體，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> 為 <see cref="F:System.IntPtr.Zero" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> 為負。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>透過儲存在位元組陣列中的 PE 映像，建立可攜式可執行檔讀取器。</summary>
      <param name="peImage">表示 PE 映像的不可變位元組陣列。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream)">
      <summary>透過儲存在資料流中的 PE 映像，建立可攜式可執行檔讀取器。</summary>
      <param name="peStream">PE 映像資料流。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> 為 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)">
      <summary>透過儲存在記憶體中的 PE 映像，建立可攜式可執行檔讀取器，此資料流從目前位置開始，結束於資料流結尾。</summary>
      <param name="peStream">PE 映像資料流。</param>
      <param name="options">指定如何從資料流讀取 PE 映像區段的選項。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="options" /> 的值無效。</exception>
      <exception cref="T:System.IO.IOException">在資料流中讀取時發生錯誤 (只有在預先擷取資料時)。</exception>
      <exception cref="T:System.BadImageFormatException">已指定 <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" />，且映像的 PE 標頭無效。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions,System.Int32)">
      <summary>透過從資料流目前位置開始的指定大小 PE 映像，建立可攜式可執行檔讀取器。</summary>
      <param name="peStream">PE 映像資料流。</param>
      <param name="options">指定如何從資料流讀取 PE 映像區段的選項。</param>
      <param name="size">PE 映像大小。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> 為負數或延展超過資料流的結尾。</exception>
      <exception cref="T:System.IO.IOException">從資料流讀取時發生錯誤 (只有在預先擷取資料時)。</exception>
      <exception cref="T:System.BadImageFormatException">已指定 <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" />，且映像的 PE 標頭無效。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.Dispose">
      <summary>處置所有由讀取器所配置的記憶體。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetEntireImage">
      <summary>取得包含整個 PE 映像的 <see cref="T:System.Reflection.PortableExecutable.PEMemoryBlock" /> 物件。</summary>
      <returns>包含整個 PE 映像的記憶體區塊。</returns>
      <exception cref="T:System.InvalidOperationException">整個 PE 映像無法使用。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetMetadata">
      <summary>載入包含 CLI 中繼資料的 PE 區段。</summary>
      <returns>包含 CLI 中繼資料的記憶體區塊。</returns>
      <exception cref="T:System.InvalidOperationException">PE 映像不包含中繼資料 (<see cref="P:System.Reflection.PortableExecutable.PEReader.HasMetadata" /> 會傳回 <see langword="false" />)。</exception>
      <exception cref="T:System.BadImageFormatException">PE 標頭包含無效的資料。</exception>
      <exception cref="T:System.IO.IOException">從基礎資料流讀取時出現 IO 錯誤。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.Int32)">
      <summary>將包含指定相對虛擬位址的 PE 區段載入至記憶體，並傳回從該位址開始，結束於包含區段結尾的記憶體區塊。</summary>
      <param name="relativeVirtualAddress">所要讀取資料的相對虛擬位址。</param>
      <returns>從 <paramref name="relativeVirtualAddress" /> 開始，結束於包含區段結尾的記憶體區塊；如果 <paramref name="relativeVirtualAddress" /> 不代表這個 PE 映像任何 PE 區段中的位置，則為空的區塊。</returns>
      <exception cref="T:System.BadImageFormatException">PE 標頭包含無效的資料。</exception>
      <exception cref="T:System.IO.IOException">在基礎資料流中讀取時發生 IO 錯誤。</exception>
      <exception cref="T:System.InvalidOperationException">PE 映像無法使用。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="relativeVirtualAddress" /> 為負。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.String)">
      <summary>將具有指定名稱的 PE 區段載入至記憶體，並傳回跨越該區段的記憶體區塊。</summary>
      <param name="sectionName">區段的名稱。</param>
      <returns>跨越此區段的記憶體區塊；如果這個 PE 映像中沒有任何指定 <paramref name="sectionName" /> 的區段，則為空的區塊。</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="sectionName" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">PE 映像無法使用。</exception>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.HasMetadata">
      <summary>取得值，指出 PE 映像是否包含 CLI 中繼資料。</summary>
      <returns>如果 PE 映射包含 CLI 中繼資料，則 <see langword="true" />;否則，<see langword="false" />。</returns>
      <exception cref="T:System.BadImageFormatException">PE 標頭包含無效的資料。</exception>
      <exception cref="T:System.IO.IOException">從基礎資料流讀取時發生錯誤。</exception>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsEntireImageAvailable">
      <summary>取得值，指出讀取器是否可以存取整個 PE 映像。</summary>
      <returns>如果讀取器可以存取整個 PE 映射，則 <see langword="true" />：否則，<see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsLoadedImage">
      <summary>取得值，指出作業系統載入器是否已將 PE 映像載入至記憶體。</summary>
      <returns>如果作業系統載入器已將 PE 映像載入至記憶體，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.PEHeaders">
      <summary>取得 PE 標頭。</summary>
      <returns>這個 PE 映射的 PE 標頭。</returns>
      <exception cref="T:System.BadImageFormatException">標頭包含無效的資料。</exception>
      <exception cref="T:System.IO.IOException">在資料流中讀取時發生錯誤。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadCodeViewDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>讀取由所指定偵錯目錄項目指向的資料，並轉譯為 CodeView。</summary>
      <param name="entry">偵錯目錄項目執行個體。</param>
      <returns>程式碼檢視偵錯目錄資料執行個體。</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> 不是 CodeView 項目。</exception>
      <exception cref="T:System.BadImageFormatException">錯誤的資料格式。</exception>
      <exception cref="T:System.IO.IOException">從基礎資料流讀取時出現 IO 錯誤。</exception>
      <exception cref="T:System.InvalidOperationException">PE 映像無法使用。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadDebugDirectory">
      <summary>讀取所有偵錯目錄資料表項目。</summary>
      <returns>偵錯目錄資料表項目陣列。</returns>
      <exception cref="T:System.BadImageFormatException">錯誤的項目格式。</exception>
      <exception cref="T:System.IO.IOException">從基礎資料流讀取時出現 IO 錯誤。</exception>
      <exception cref="T:System.InvalidOperationException">PE 映像無法使用。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadEmbeddedPortablePdbDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>讀取由指定偵錯目錄項目所指向的資料，並轉譯為內嵌可攜式 PDB Blob。</summary>
      <param name="entry">無法讀取其資料的偵錯目錄項目。</param>
      <returns>用於讀取可攜式 PDB 映像的中繼資料讀取器提供者。</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> 不是 <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb" /> 項目。</exception>
      <exception cref="T:System.BadImageFormatException">錯誤的資料格式。</exception>
      <exception cref="T:System.InvalidOperationException">PE 映像無法使用。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadPdbChecksumDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>讀取由指定偵錯目錄項目所指向的資料，並轉譯為 PDB 總和檢查碼項目。</summary>
      <param name="entry">無法讀取其資料的偵錯目錄項目。</param>
      <returns>PDB 總和檢查碼項目。</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> 不是 PDB 總和檢查碼項目。</exception>
      <exception cref="T:System.BadImageFormatException">錯誤的資料格式。</exception>
      <exception cref="T:System.IO.IOException">從基礎資料流讀取時出現 IO 錯誤。</exception>
      <exception cref="T:System.InvalidOperationException">PE 映像無法使用。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.TryOpenAssociatedPortablePdb(System.String,System.Func{System.String,System.IO.Stream},System.Reflection.Metadata.MetadataReaderProvider@,System.String@)">
      <summary>開啟與此 PE 映像建立關聯的可攜式 PDB。</summary>
      <param name="peImagePath">PE 映像的路徑。 路徑是用來尋找 PDB 檔案，此檔案位於包含 PE 檔案的目錄中。</param>
      <param name="pdbFileStreamProvider">如已指定，呼叫即可開啟指定檔案路徑的 <see cref="T:System.IO.Stream" />。 提供者應會傳回可讀取和可搜尋的 <see cref="T:System.IO.Stream" />，如果目標檔案不存在，或因某些原因而忽略，則傳回 <see langword="null" />。 如果提供者因未預期的 IO 錯誤而無法開啟檔案，則應該擲回 <see cref="T:System.IO.IOException" />。</param>
      <param name="pdbReaderProvider">如果成功，就會使用 <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> 的新執行個體來讀取可攜式 PDB。</param>
      <param name="pdbPath">如果成功，且在檔案中找到 PDB，則為檔案路徑；如果 PDB 內嵌於 PE 映像本身，則為 <see langword="null" />。</param>
      <returns>如果 PE 映像具有與其建立關聯的 PDB，且已成功開啟此 PDB，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImagePath" /> 或 <paramref name="pdbFileStreamProvider" /> 為 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">自 <paramref name="pdbFileStreamProvider" /> 傳回的資料流不支援讀取及搜尋作業。</exception>
      <exception cref="T:System.BadImageFormatException">因為發生錯誤，所以找不到相符的 PDB 檔案：PE 映像或 PDB 無效。</exception>
      <exception cref="T:System.IO.IOException">因為發生錯誤，所以找不到相符的 PDB 檔案：讀取 PE 映像或 PDB 時發生 IO 錯誤。</exception>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEStreamOptions">
      <summary>提供選項，指定從資料流讀取 PE 映像區段的方式。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.Default">
      <summary>根據預設，當處置 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 之後即會處置資料流，且會延遲讀取 PE 映像的區段。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.IsLoadedImage">
      <summary>指出作業系統載入器已將基礎 PE 映像載入至記憶體。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen">
      <summary>當處置 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 之後保持資料流開啟。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage">
      <summary>立即將整個映像讀入至記憶體。 除非指定 <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" />，否則 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 會在建構函式傳回時，自動關閉資料流。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata">
      <summary>立即將中繼資料區段讀入至記憶體。不允許讀取檔案的其他區段 (<see cref="T:System.Reflection.PortableExecutable.PEReader" /> 擲回 <see cref="T:System.InvalidOperationException" />)。除非指定 <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" />，否則 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 會在建構函式傳回時，自動關閉資料流。 建構 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 之後，可能會關閉甚至刪除基礎檔案。</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ResourceSectionBuilder">
      <summary>定義 PE 資源區段產生器的基底類別。 衍生自 <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" />，為原生資源提供序列化邏輯。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.#ctor">
      <summary>初始化 <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" /> 類別的新執行個體。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.SectionLocation)">
      <summary>序列化指定的資源。</summary>
      <param name="builder">包含要序列化資料的 Blob。</param>
      <param name="location">序列化 <paramref name="builder" /> 的位置。</param>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionCharacteristics" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1024Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align128Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align16Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2048Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align256Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align32Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4096Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align512Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align64Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8192Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.AlignMask" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsCode" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsInitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsUninitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.GPRel" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerComdat" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerInfo" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerNRelocOvfl" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerOther" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerRemove" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Mem16Bit" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemDiscardable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemExecute" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemFardata" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemLocked" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotCached" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotPaged" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPreload" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemProtected" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPurgeable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemRead" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemShared" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemSysheap" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemWrite" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.NoDeferSpecExc" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeCopy" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeDSect" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeGroup" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoLoad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoPad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeOver" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeReg" />
    <member name="T:System.Reflection.PortableExecutable.SectionHeader">
      <summary>提供 PE/COFF 檔案區段標頭的相關資訊。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.Name">
      <summary>取得區段的名稱。</summary>
      <returns>區段的名稱。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfLineNumbers">
      <summary>取得區段行號項目的數量。</summary>
      <returns>區段的行號專案數。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfRelocations">
      <summary>取得區段重新配置項目的數量。</summary>
      <returns>區段的重新設定項目數。 針對 PE 映射，其值為零。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToLineNumbers">
      <summary>取得區段行號項目開頭的檔案指標。</summary>
      <returns>區段的行號專案開頭的檔案指標，如果沒有 COFF 行號，則為零。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRawData">
      <summary>取得 COFF 檔案中區段第一頁的檔案指標。</summary>
      <returns>COFF 檔案中區段第一頁的檔案指標。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRelocations">
      <summary>取得區段重新配置項目開頭的檔案指標。</summary>
      <returns>區段的重新設定項目開始位置的檔案指標。 PE 映射的設定為零，或如果沒有重定位，則為。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SectionCharacteristics">
      <summary>取得描述區段特性的旗標。</summary>
      <returns>描述區段特性的旗標。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SizeOfRawData">
      <summary>取得區段的大小 (物件檔案)，或磁碟初始化資料的大小 (映像檔案)。</summary>
      <returns>區段的大小（適用于物件檔案）或磁片上的初始化資料大小（針對影像檔案）。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualAddress">
      <summary>取得區段的虛擬位址。</summary>
      <returns>區段的虛擬位址。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualSize">
      <summary>取得載入到記憶體時的區段大小總計。</summary>
      <returns>載入記憶體時的區段大小總計。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionLocation" />
    <member name="M:System.Reflection.PortableExecutable.SectionLocation.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" />
      <param name="pointerToRawData" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.PointerToRawData" />
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.RelativeVirtualAddress" />
    <member name="T:System.Reflection.PortableExecutable.Subsystem">
      <summary>描述映像的子系統需求。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiApplication">
      <summary>可延伸韌體介面 (EFI) 應用程式。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiBootServiceDriver">
      <summary>具備開機服務的 EFI 驅動程式。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRom">
      <summary>EFI ROM 映像。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRuntimeDriver">
      <summary>具備執行階段服務的 EFI 驅動程式。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Native">
      <summary>映像不需要子系統。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.NativeWindows">
      <summary>映像是原生的 Win9x 驅動程式。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.OS2Cui">
      <summary>映像會在 OS/2 字元子系統中執行。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.PosixCui">
      <summary>映像會在 Posix 字元子系統中執行。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Unknown">
      <summary>未知的子系統。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsBootApplication">
      <summary>開機應用程式。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCEGui">
      <summary>映像會在 Windows CE 子系統中執行。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCui">
      <summary>映像會在 Windows 字元子系統中執行。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsGui">
      <summary>映像會在 Windows GUI 子系統中執行。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Xbox">
      <summary>Xbox 系統。</summary>
    </member>
  </members>
</doc>