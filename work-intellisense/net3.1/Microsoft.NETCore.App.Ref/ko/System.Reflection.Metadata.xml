<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:vsli="https://github.com/sk-0520/vs-localized-intellisense/tree/master/schema/2024">
  <assembly>
    <name>System.Reflection.Metadata</name>
  </assembly>
  <members>
    <member name="T:System.Reflection.AssemblyFlags" />
    <member name="F:System.Reflection.AssemblyFlags.ContentTypeMask">
      <summary vsli:raw="Content type masked bits that correspond to values of &lt;see cref=&quot;T:System.Reflection.AssemblyContentType&quot; /&gt;.">
        <see cref="T:System.Reflection.AssemblyContentType" /> 값에 해당하는 콘텐츠 형식이 마스크된 비트입니다.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.DisableJitCompileOptimizer">
      <summary vsli:raw="Just-In-Time (JIT) compiler optimization is disabled for the assembly.">어셈블리에 대해 JIT(Just-In-Time) 컴파일러 최적화가 사용되지 않도록 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.EnableJitCompileTracking">
      <summary vsli:raw="Just-In-Time (JIT) compiler tracking is enabled for the assembly.">어셈블리에 대해 JIT(Just-In-Time) 컴파일러 추적이 사용되도록 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.PublicKey">
      <summary vsli:raw="The assembly reference holds the full (unhashed) public key. Not applicable on assembly definition.">어셈블리 참조에는 해시되지 않은 전체 공개 키가 포함되어 있습니다. 어셈블리 정의에는 적용되지 않습니다.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.Retargetable">
      <summary vsli:raw="The implementation of the referenced assembly used at runtime is not expected to match the version seen at compile time.">런타임에 사용되는 참조된 어셈블리의 구현은 컴파일 시간에 표시되는 버전과 일치하지 않을 것으로 예상됩니다.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.WindowsRuntime">
      <summary vsli:raw="The assembly contains Windows Runtime code.">어셈블리는 Windows 런타임 코드를 포함합니다.</summary>
    </member>
    <member name="T:System.Reflection.AssemblyHashAlgorithm">
      <summary vsli:raw="Specifies the hash algorithms used for hashing assembly files and for generating the strong name.">어셈블리 파일을 해시하고 강력한 이름을 생성하는 데 사용한 해시 알고리즘을 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.MD5">
      <summary vsli:raw="&lt;para&gt;Retrieves the MD5 message-digest algorithm.&lt;/para&gt;&lt;para&gt;Due to collision problems with MD5, Microsoft recommends SHA256.&lt;/para&gt;&lt;para&gt;MD5 was developed by Rivest in 1991. It is basically MD4 with safety-belts and, while it is slightly slower than MD4, it helps provide more security. The algorithm consists of four distinct rounds, which has a slightly different design from that of MD4. Message-digest size, as well as padding requirements, remain the same.&lt;/para&gt;">MD5 메시지 다이제스트 알고리즘을 검색합니다.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.None">
      <summary vsli:raw="&lt;para&gt;A mask indicating that there is no hash algorithm.&lt;/para&gt;&lt;para&gt;If you specify &lt;see cref=&quot;F:System.Reflection.AssemblyHashAlgorithm.None&quot; /&gt; for a multi-module assembly, the common language runtime defaults to the SHA1 algorithm, since multi-module assemblies need to generate a hash.&lt;/para&gt;">해시 알고리즘이 없음을 나타내는 마스크입니다.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha1">
      <summary vsli:raw="&lt;para&gt;Retrieves a revision of the Secure Hash Algorithm that corrects an unpublished flaw in SHA.&lt;/para&gt;&lt;para&gt;Due to collision problems with SHA1, Microsoft recommends SHA256.&lt;/para&gt;">SHA의 게시되지 않은 결함을 수정하는 수정 버전의 SHA를 검색합니다.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha256">
      <summary vsli:raw="Retrieves a version of the Secure Hash Algorithm with a hash size of 256 bits.">해시 크기가 256비트인 SHA(Secure Hash Algorithm) 버전을 검색합니다.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha384">
      <summary vsli:raw="Retrieves a version of the Secure Hash Algorithm with a hash size of 384 bits.">해시 크기가 384비트인 SHA(Secure Hash Algorithm) 버전을 검색합니다.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha512">
      <summary vsli:raw="Retrieves a version of the Secure Hash Algorithm with a hash size of 512 bits.">해시 크기가 512비트인 SHA(Secure Hash Algorithm) 버전을 검색합니다.</summary>
    </member>
    <member name="T:System.Reflection.DeclarativeSecurityAction">
      <summary vsli:raw="Specifies the security actions that can be performed using declarative security.">선언적 보안을 사용하여 수행할 수 있는 보안 작업을 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Assert">
      <summary vsli:raw="The calling code can access the resource identified by the current permission object, even if callers higher in the stack have not been granted permission to access the resource.">스택의 상위 호출자에게 리소스에 대한 액세스 권한이 없더라도 호출 코드를 사용하여 현재 권한 개체로 식별되는 리소스에 액세스할 수 있습니다.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Demand">
      <summary vsli:raw="Check that all callers in the call chain have been granted the specified permission.">호출 체인의 모든 호출자에게 지정된 사용 권한이 부여되었는지 확인합니다.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Deny">
      <summary vsli:raw="Without further checks refuse Demand for the specified permission.">추가 검사가 없으면 지정된 사용 권한에 대한 요구가 거부됩니다.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.InheritanceDemand">
      <summary vsli:raw="The derived class inheriting the class or overriding a method is required to have the specified permission.">클래스를 상속하거나 메서드를 재정의하는 파생 클래스에 지정된 사용 권한이 있어야 합니다.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.LinkDemand">
      <summary vsli:raw="Check that the immediate caller has been granted the specified permission.">직접 실행 호출자에게 지정된 사용 권한이 부여되었는지 확인합니다.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.None">
      <summary vsli:raw="No declarative security action.">선언적 보안 동작이 없습니다.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.PermitOnly">
      <summary vsli:raw="Without further checks, refuse the demand for all permissions other than those specified.">추가 검사가 없으면 지정된 권한 이외의 모든 사용 권한에 대한 수요가 거부됩니다.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestMinimum">
      <summary vsli:raw="Request the minimum permissions required for code to run. This action can only be used within the scope of the assembly.">코드를 실행하는 데 필요한 최소 사용 권한을 요청합니다. 이 작업은 어셈블리 범위 내에서만 사용할 수 있습니다.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestOptional">
      <summary vsli:raw="Request additional permissions that are optional (not required to run). This request implicitly refuses all other permissions not specifically requested. This action can only be used within the scope of the assembly.">선택적인 추가 사용 권한을 요청합니다(실행하는 데 필수는 아님). 이 요청은 특별히 요청되지 않은 다른 모든 사용 권한을 암시적으로 거부합니다. 이 작업은 어셈블리 범위 내에서만 사용할 수 있습니다.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestRefuse">
      <summary vsli:raw="Request that permissions that might be misused not be granted to the calling code. This action can only be used within the scope of the assembly.">잘못 사용될 수 있는 사용 권한을 호출 코드에 부여하지 않도록 하는 요청입니다. 이 작업은 어셈블리 범위 내에서만 사용할 수 있습니다.</summary>
    </member>
    <member name="T:System.Reflection.ManifestResourceAttributes" />
    <member name="F:System.Reflection.ManifestResourceAttributes.Private">
      <summary vsli:raw="The resource is not exported from the assembly.">어셈블리에서 리소스를 내보내지 않습니다.</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.Public">
      <summary vsli:raw="The resource is exported from the assembly.">어셈블리에서 리소스를 내보냅니다.</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.VisibilityMask">
      <summary vsli:raw="Masks just the visibility-related attributes.">표시 유형 관련 특성만 마스크합니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ArrayShape">
      <summary vsli:raw="Represents the shape of an array type.">배열 형식의 도형을 나타냅니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ArrayShape.#ctor(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.ArrayShape&quot; /&gt; structure.">
        <see cref="T:System.Reflection.Metadata.ArrayShape" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
      <param name="rank" vsli:raw="The number of dimensions in the array.">배열의 차수입니다.</param>
      <param name="sizes" vsli:raw="The size of each dimension.">각 차원의 크기입니다.</param>
      <param name="lowerBounds" vsli:raw="The lower-bound of each dimension.">각 차원의 낮은 경계입니다.</param>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.LowerBounds">
      <summary vsli:raw="Gets the lower-bounds of all dimensions. Length may be smaller than rank, in which case the trailing dimensions have unspecified lower bounds.">모든 차원의 낮은 경계를 가져옵니다. 길이가 순위보다 작을 수 있습니다. 이 경우에 후행 차원이 낮은 경계를 지정합니다.</summary>
      <returns vsli:raw="An array of lower-bounds.">하위 범위의 배열입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Rank">
      <summary vsli:raw="Gets the number of dimensions in the array.">배열의 차수를 가져옵니다.</summary>
      <returns vsli:raw="The number of dimensions.">차원의 수입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Sizes">
      <summary vsli:raw="Gets the sizes of all dimensions.">모든 차원의 크기를 가져옵니다.</summary>
      <returns vsli:raw="An array of sizes.">크기의 배열입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyDefinition" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Flags" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetDeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.PublicKey" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Equality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Inequality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFile" />
    <member name="P:System.Reflection.Metadata.AssemblyFile.ContainsMetadata">
      <summary vsli:raw="Gets a value that indicates whether the file contains metadata.">파일에 메타데이터가 있는지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the file contains metadata, &lt;see langword=&quot;false&quot; /&gt; otherwise.">파일에 메타 데이터가 포함 되어 있으면이 고, 그렇지 않으면 <see langword="false" /><see langword="true" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFile.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyFile.HashValue">
      <summary vsli:raw="Gets the hash value of the file content calculated using &lt;see cref=&quot;P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm&quot; /&gt;.">
        <see cref="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" />을 사용하여 계산된 파일 콘텐츠의 해시 값을 가져옵니다.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.BlobHandle&quot; /&gt; instance representing the hash value of the file content.">파일 콘텐츠의 해시 값을 나타내는 <see cref="T:System.Reflection.Metadata.BlobHandle" /> 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFile.Name">
      <summary vsli:raw="Gets the file name, including its extension.">해당 확장명을 포함하는 파일 이름을 가져옵니다.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.StringHandle&quot; /&gt; instance representing the file name with its extension.">확장명이 있는 파일 이름을 나타내는 <see cref="T:System.Reflection.Metadata.StringHandle" /> 인스턴스입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.AssemblyFileHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Equality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Inequality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection">
      <summary vsli:raw="Represents a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />의 컬렉션을 나타냅니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyFileHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.AssemblyReference" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Flags" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.HashValue" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.PublicKeyOrToken" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Equality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Inequality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection">
      <summary vsli:raw="A collection of assembly references.">어셈블리 참조의 컬렉션입니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyReferenceHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.Blob" />
    <member name="M:System.Reflection.Metadata.Blob.GetBytes" />
    <member name="P:System.Reflection.Metadata.Blob.IsDefault" />
    <member name="P:System.Reflection.Metadata.Blob.Length" />
    <member name="T:System.Reflection.Metadata.BlobBuilder" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.#ctor(System.Int32)">
      <param name="capacity" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Align(System.Int32)">
      <param name="alignment" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.AllocateChunk(System.Int32)">
      <param name="minimalSize" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.BlobBuilder.Blobs" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.Current" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.MoveNext" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.Reset" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#Blob}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerable#GetEnumerator" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#IDisposable#Dispose" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.ChunkCapacity" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Clear" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.ContentEquals(System.Reflection.Metadata.BlobBuilder)">
      <summary vsli:raw="Compares the current content of this writer with another one.">이 작성기의 현재 내용을 다른 내용과 비교합니다.</summary>
      <param name="other" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.BlobBuilder&quot; /&gt; instance to compare with this one.">이 인스턴스와 비교할 <see cref="T:System.Reflection.Metadata.BlobBuilder" /> 인스턴스입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">콘텐츠를 사용할 수 없습니다. 작성기가 다른 콘텐츠와 연결되어 있습니다.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.Count" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Free" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.FreeBytes" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.FreeChunk" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.GetBlobs">
      <summary vsli:raw="Returns a sequence of all blobs that represent the content of the builder.">작성기의 콘텐츠를 나타내는 모든 Blob의 시퀀스를 반환합니다.</summary>
      <returns vsli:raw="A sequence of blobs.">Blob의 시퀀스입니다.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">콘텐츠를 사용할 수 없습니다. 작성기가 다른 콘텐츠와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkPrefix(System.Reflection.Metadata.BlobBuilder)">
      <param name="prefix" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;prefix&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="prefix" />가 <see langword="null" />입니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkSuffix(System.Reflection.Metadata.BlobBuilder)">
      <param name="suffix" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;suffix&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="suffix" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.PadTo(System.Int32)">
      <param name="position" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ReserveBytes(System.Int32)">
      <summary vsli:raw="Reserves a contiguous block of bytes.">바이트의 연속 블록을 예약합니다.</summary>
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" />가 음수입니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray">
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">콘텐츠를 사용할 수 없습니다. 작성기가 다른 콘텐츠와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray(System.Int32,System.Int32)">
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the buffer content.">
        <paramref name="start" /> 및 <paramref name="byteCount" />에 의해 지정된 범위가 버퍼 콘텐츠 경계를 벗어납니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">콘텐츠를 사용할 수 없습니다. 작성기가 다른 콘텐츠와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray">
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">콘텐츠를 사용할 수 없습니다. 작성기가 다른 콘텐츠와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the buffer content.">
        <paramref name="start" /> 및 <paramref name="byteCount" />에 의해 지정된 범위가 버퍼 콘텐츠 경계를 벗어납니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">콘텐츠를 사용할 수 없습니다. 작성기가 다른 콘텐츠와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.TryWriteBytes(System.IO.Stream,System.Int32)">
      <summary vsli:raw="Attempts to write a sequence of bytes to the builder. A return value indicates the number of bytes successfully written.">작성기에 바이트 시퀀스를 작성하려고 합니다. 반환 값은 성공적으로 작성된 바이트 수를 나타냅니다.</summary>
      <param name="source" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <returns vsli:raw="The number of bytes successfully written from &lt;paramref name=&quot;source&quot; /&gt;.">
        <paramref name="source" />에서 성공적으로 기록된 바이트 수입니다.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="source" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" />가 음수입니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBoolean(System.Boolean)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Boolean&quot; /&gt; value to the builder.">작성기에 <see cref="T:System.Boolean" /> 값을 씁니다.</summary>
      <param name="value" vsli:raw="The value to write.">작성할 값입니다.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteByte(System.Byte)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Byte&quot; /&gt; value to the builder.">작성기에 <see cref="T:System.Byte" /> 값을 씁니다.</summary>
      <param name="value" vsli:raw="The value to write.">작성할 값입니다.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte*,System.Int32)">
      <summary vsli:raw="Writes a specified number of bytes from a buffer to the builder.">버퍼에서 지정된 바이트 수를 작성기에 씁니다.</summary>
      <param name="buffer" vsli:raw="" />
      <param name="byteCount" vsli:raw="The number of bytes to write.">쓸 바이트 수입니다.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" />가 음수입니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable, it has been linked with another one.">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte,System.Int32)">
      <summary vsli:raw="Writes a specified number of occurrences of a byte value to the builder.">지정된 바이트 값의 발생 횟수를 작성기에 씁니다.</summary>
      <param name="value" vsli:raw="" />
      <param name="byteCount" vsli:raw="The number of occurences of &lt;paramref name=&quot;value&quot; /&gt; to write.">기록할 <paramref name="value" />의 발생 횟수입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" />가 음수입니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable, it has been linked with another one.">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[])">
      <summary vsli:raw="Writes the contents of a byte array to the builder.">바이트 배열의 내용을 작성기에 씁니다.</summary>
      <param name="buffer" vsli:raw="The byte array to write.">쓸 바이트 배열입니다.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <summary vsli:raw="Writes a specified number of bytes starting at a specified index in a byte array to the builder.">바이트 배열의 지정된 인덱스에서 시작하는 지정된 바이트 수를 작성기에 씁니다.</summary>
      <param name="buffer" vsli:raw="" />
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="The number of bytes to write.">쓸 바이트 수입니다.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" />가 <see langword="null" />입니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of &lt;paramref name=&quot;buffer&quot; /&gt;.">
        <paramref name="start" /> 및 <paramref name="byteCount" />에 의해 지정된 범위가 <paramref name="buffer" />의 경계를 벗어납니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Writes the contents of an immutable byte array to the builder.">변경할 수 없는 바이트 배열의 내용을 작성기에 씁니다.</summary>
      <param name="buffer" vsli:raw="The array to write.">쓸 배열입니다.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <summary vsli:raw="Writes a specified number of bytes starting at a specified index of an immutable array to the builder.">변경할 수 없는 배열의 지정된 인덱스에서 시작하는 지정된 바이트 수를 작성기에 씁니다.</summary>
      <param name="buffer" vsli:raw="" />
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="The number of bytes to write.">쓸 바이트 수입니다.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the &lt;paramref name=&quot;buffer&quot; /&gt;.">
        <paramref name="start" /> 및 <paramref name="byteCount" />에 의해 지정된 범위가 <paramref name="buffer" />의 경계를 벗어납니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedInteger(System.Int32)">
      <summary vsli:raw="Implements compressed unsigned integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.">ECMA-335-II 장 23.2에 정의된 대로 압축된 부호 없는 정수 인코딩을 구현합니다. Blob 및 서명.</summary>
      <param name="value" vsli:raw="The value to write.">작성할 값입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; can't be represented as a compressed unsigned integer.">
        <paramref name="value" />는 압축된 부호 없는 정수로 표시될 수 없습니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedSignedInteger(System.Int32)">
      <summary vsli:raw="Implements compressed signed integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.">ECMA-335-II 장 23.2에 정의된 대로 압축된 부호 있는 정수 인코딩을 구현합니다. Blob 및 서명.</summary>
      <param name="value" vsli:raw="The value to write.">작성할 값입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; can't be represented as a compressed signed integer.">
        <paramref name="value" />는 압축된 부호 있는 정수로 표시될 수 없습니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteConstant(System.Object)">
      <summary vsli:raw="Writes a constant value (see ECMA-335 Partition II section 22.9) at the current position.">현재 위치에서 상수 값(ECMA-335 Partition II 섹션 22.9 참조)을 씁니다.</summary>
      <param name="value" vsli:raw="The constant value to write.">작성할 상수 값입니다.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is not of a constant type.">
        <paramref name="value" />는 상수 유형이 아닙니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.IO.Stream)">
      <param name="destination" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="destination" />가 <see langword="null" />입니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available, the builder has been linked with another one.">콘텐츠를 사용할 수 없습니다. 작성기가 다른 콘텐츠와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobBuilder)">
      <param name="destination" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="destination" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available, the builder has been linked with another one.">콘텐츠를 사용할 수 없습니다. 작성기가 다른 콘텐츠와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobWriter@)">
      <param name="destination" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is default (&lt;see cref=&quot;T:System.Reflection.Metadata.BlobWriter&quot; /&gt;).">
        <paramref name="destination" />은 기본값(<see cref="T:System.Reflection.Metadata.BlobWriter" />)입니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available, the builder has been linked with another one.">콘텐츠를 사용할 수 없습니다. 작성기가 다른 콘텐츠와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDateTime(System.DateTime)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDecimal(System.Decimal)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDouble(System.Double)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteGuid(System.Guid)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16(System.Int16)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16BE(System.Int16)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32(System.Int32)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32BE(System.Int32)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt64(System.Int64)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteReference(System.Int32,System.Boolean)">
      <summary vsli:raw="Writes a reference to a heap (heap offset) or a table (row number).">힙(힙 오프셋) 또는 테이블(행 번호)에 대한 참조를 씁니다.</summary>
      <param name="reference" vsli:raw="Heap offset or table row number.">힙 오프셋 또는 테이블 행 번호.</param>
      <param name="isSmall" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode the reference as a 16-bit integer; &lt;see langword=&quot;false&quot; /&gt; to encode it as a 32-bit integer.">
        <see langword="true" />를 사용하여 참조를 16비트 정수로 인코딩하고, <see langword="false" />를 사용하여 32비트 정수로 인코딩합니다.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSByte(System.SByte)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSerializedString(System.String)">
      <summary vsli:raw="Writes a string in SerString format (see ECMA-335-II 23.3 Custom attributes).">SerString 형식으로 문자열을 씁니다(ECMA-335-II 23.3 사용자 지정 특성 참조).</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSingle(System.Single)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16(System.UInt16)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16BE(System.UInt16)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32(System.UInt32)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32BE(System.UInt32)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt64(System.UInt64)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUserString(System.String)">
      <summary vsli:raw="Writes a string in User String (#US) heap format (see ECMA-335-II 24.2.4 #US and #Blob heaps).">사용자 문자열(#US) 힙 형식으로 문자열을 씁니다(ECMA-335-II 24.2.4 #US 및 #Blob 힙 참조).</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.Char[])">
      <summary vsli:raw="Writes a UTF16 (little-endian) encoded character array at the current position.">현재 위치에서 UTF16(little endian) 인코딩된 문자 배열을 씁니다.</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.String)">
      <summary vsli:raw="Writes UTF16 (little-endian) encoded string at the current position.">현재 위치에서 UTF16(little endian) 인코딩된 문자열을 씁니다.</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF8(System.String,System.Boolean)">
      <summary vsli:raw="Writes a UTF8 encoded string at the current position.">현재 위치에서 UTF8 인코딩된 문자열을 씁니다.</summary>
      <param name="value" vsli:raw="Constant value.">상수 값입니다.</param>
      <param name="allowUnpairedSurrogates" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode unpaired surrogates as specified; &lt;see langword=&quot;false&quot; /&gt; to replace them with a U+FFFD character.">
        <see langword="true" />를 사용하여 지정된 대로 짝이 없는 서로게이트를 인코딩합니다. <see langword="false" />를 사용하여 U+FFFD 문자로 바꿉니다.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" />가 <see langword="null" />입니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.BlobContentId" />
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Byte[])">
      <param name="id" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="id" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Guid,System.UInt32)">
      <param name="guid" vsli:raw="" />
      <param name="stamp" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Reflection.Metadata.BlobContentId)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Byte[])">
      <param name="hashCode" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="hashCode" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.GetHashCode" />
    <member name="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />
    <member name="P:System.Reflection.Metadata.BlobContentId.Guid" />
    <member name="P:System.Reflection.Metadata.BlobContentId.IsDefault" />
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Equality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Inequality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobContentId.Stamp" />
    <member name="T:System.Reflection.Metadata.BlobHandle" />
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Reflection.Metadata.BlobHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.BlobHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Equality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Implicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Inequality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.BlobReader" />
    <member name="M:System.Reflection.Metadata.BlobReader.#ctor(System.Byte*,System.Int32)">
      <summary vsli:raw="Creates a reader of the specified memory block.">지정된 메모리 블록의 reader를 만듭니다.</summary>
      <param name="buffer" vsli:raw="A pointer to the start of the memory block.">메모리 블록의 시작에 대한 포인터.</param>
      <param name="length" vsli:raw="Length in bytes of the memory block.">메모리 블록의 길이(바이트)입니다.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;length&quot; /&gt; is greater than zero.">
        <paramref name="buffer" />는 <see langword="null" />이고 <paramref name="length" />가 0보다 큽니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;length&quot; /&gt; is negative.">
        <paramref name="length" />가 음수입니다.</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is not little-endian.">현재 플랫폼은 little-endian이 아닙니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Align(System.Byte)">
      <summary vsli:raw="Repositions the reader forward by the number of bytes required to satisfy the given alignment.">지정된 맞춤을 충족하는 데 필요한 바이트 수 만큼 reader를 앞으로 다시 배치합니다.</summary>
      <param name="alignment" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.CurrentPointer">
      <summary vsli:raw="Gets a pointer to the byte at the current position of the reader.">reader의 현재 위치에 있는 바이트에 대한 포인터를 가져옵니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.IndexOf(System.Byte)">
      <summary vsli:raw="Searches for a specified byte in the blob following the current position.">현재 위치에 따라 Blob에서 지정된 바이트를 검색합니다.</summary>
      <param name="value" vsli:raw="The byte value to find.">찾을 바이트 값입니다.</param>
      <returns vsli:raw="The index relative to the current position, or -1 if the byte is not found in the blob following the current position.">현재 위치를 기준으로 한 인덱스 또는 현재 위치 다음의 Blob에서 바이트가 없으면 -1입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Length">
      <summary vsli:raw="Gets the total length of the underlying memory block.">기본 메모리 블록의 총 길이를 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Offset">
      <summary vsli:raw="Gets or sets the offset from the start of the blob to the current position.">Blob의 시작에서 현재 위치까지 오프셋을 가져오거나 설정합니다.</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The offset is set outside the bounds of the underlying reader.">오프셋은 기본 reader의 경계 외부에 설정됩니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBlobHandle">
      <summary vsli:raw="Reads a Blob heap handle encoded as a compressed integer.">압축된 정수로 인코딩된 Blob 힙 핸들을 읽습니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBoolean" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32)">
      <summary vsli:raw="Reads bytes starting at the current position.">현재 위치에서 시작하는 바이트를 읽습니다.</summary>
      <param name="byteCount" vsli:raw="The number of bytes to read.">읽을 바이트 수입니다.</param>
      <returns vsli:raw="The byte array.">바이트 배열입니다.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; bytes not available.">
        <paramref name="byteCount" /> 바이트를 사용할 수 없습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32,System.Byte[],System.Int32)">
      <summary vsli:raw="Reads bytes starting at the current position and writes them to the specified buffer starting at the specified offset.">현재 위치에서 시작하는 바이트를 읽고 지정된 오프셋에서 시작하는 지정된 버퍼에 씁니다.</summary>
      <param name="byteCount" vsli:raw="The number of bytes to read.">읽을 바이트 수입니다.</param>
      <param name="buffer" vsli:raw="The destination buffer the bytes read will be written to.">바이트 읽기가 기록될 대상 버퍼입니다.</param>
      <param name="bufferOffset" vsli:raw="The offset in the destination buffer where the bytes read will be written.">바이트 읽기가 기록될 대상 버퍼의 오프셋입니다.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; bytes not available.">
        <paramref name="byteCount" /> 바이트를 사용할 수 없습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadChar" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedInteger">
      <summary vsli:raw="Reads an unsigned compressed integer value. See Metadata Specification section II.23.2: Blobs and signatures.">부호 없는 압축된 정수 값을 읽습니다. 메타데이터 사양 섹션 II.23.2 참조: Blob 및 서명.</summary>
      <returns vsli:raw="The value of the compressed integer that was read.">읽은 압축된 정수 값입니다.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data at the current position was not a valid compressed integer.">현재 위치의 데이터는 유효한 압축 정수가 아닙니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedSignedInteger">
      <summary vsli:raw="Reads a signed compressed integer value. See Metadata Specification section II.23.2: Blobs and signatures.">부호 있는 압축된 정수 값을 읽습니다. 메타데이터 사양 섹션 II.23.2 참조: Blob 및 서명.</summary>
      <returns vsli:raw="The value of the compressed integer that was read.">읽은 압축된 정수 값입니다.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data at the current position was not a valid compressed integer.">현재 위치의 데이터는 유효한 압축 정수가 아닙니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadConstant(System.Reflection.Metadata.ConstantTypeCode)">
      <summary vsli:raw="Reads a constant value (see ECMA-335 Partition II section 22.9) from the current position.">현재 위치에서 상수 값(ECMA-335 Partition II 섹션 22.9 참조)을 읽습니다.</summary>
      <param name="typeCode" vsli:raw="" />
      <returns vsli:raw="A boxed constant value. To avoid allocating the object use Read* methods directly.">boxed 상수 값입니다. 개체 할당을 방지하려면 읽기* 메서드를 직접 사용합니다.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Error while reading from the blob.">Blob에서 읽는 동안 오류가 발생했습니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;typeCode&quot; /&gt; is not a valid &lt;see cref=&quot;T:System.Reflection.Metadata.ConstantTypeCode&quot; /&gt;.">
        <paramref name="typeCode" />은 유효한 <see cref="T:System.Reflection.Metadata.ConstantTypeCode" />이 아닙니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDateTime" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDecimal">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Decimal&quot; /&gt; number.">
        <see cref="T:System.Decimal" /> 번호를 읽습니다.</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data at the current position was not a valid &lt;see cref=&quot;T:System.Decimal&quot; /&gt; number.">현재 위치의 데이터는 유효한 <see cref="T:System.Decimal" /> 번호가 아닙니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDouble" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadGuid" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializationTypeCode">
      <summary vsli:raw="Reads a type code encoded in a serialized custom attribute value.">직렬화된 사용자 지정 특성 값으로 인코딩된 형식 코드를 읽습니다.</summary>
      <returns vsli:raw="&lt;see cref=&quot;F:System.Reflection.Metadata.SerializationTypeCode.Invalid&quot; /&gt; if the encoding is invalid.">인코딩이 유효하지 않은 경우 <see cref="F:System.Reflection.Metadata.SerializationTypeCode.Invalid" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializedString">
      <summary vsli:raw="Reads a string encoded as a compressed integer containing its length followed by its contents in UTF8. Null strings are encoded as a single 0xFF byte.">UTF8의 해당 내용 다음에 길이를 포함하는 압축된 정수로 인코딩된 문자열을 읽습니다. Null 문자열은 단일 0xFF 바이트로 인코딩됩니다.</summary>
      <returns vsli:raw="A string value, or &lt;see langword=&quot;null&quot; /&gt;.">문자열 값 또는 <see langword="null" />입니다.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The encoding is invalid.">인코딩이 잘못되었습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureHeader" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureTypeCode">
      <summary vsli:raw="Reads a type code encoded in a signature.">서명으로 인코딩된 형식 코드를 읽습니다.</summary>
      <returns vsli:raw="The type code encoded in the serialized custom attribute value if the encoding is valid, or &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Invalid&quot; /&gt; if the encoding is invalid.">인코딩이 유효한 경우 직렬화된 사용자 지정 특성 값으로 인코딩된 형식 코드이거나 인코딩이 유효하지 않은 경우 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSingle" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadTypeHandle">
      <summary vsli:raw="Reads a type handle encoded in a signature as TypeDefOrRefOrSpecEncoded (see ECMA-335 II.23.2.8).">서명에 TypeDefOrRefOrSpecEncoded로 인코딩된 형식 핸들을 읽습니다(ECMA-335 II.23.2.8 참조).</summary>
      <returns vsli:raw="The handle when the encoding is valid. Otherwise, a handle where the &lt;see cref=&quot;P:System.Reflection.Metadata.EntityHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;.">인코딩이 유효한 경우 핸들입니다. 그렇지 않으면 <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> 속성이 <see langword="true" />인 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF16(System.Int32)">
      <summary vsli:raw="Reads a UTF16 (little-endian) encoded string starting at the current position.">현재 위치에서 시작하는 UTF16(little endian) 인코딩된 문자열을 읽습니다.</summary>
      <param name="byteCount" vsli:raw="The number of bytes to read.">읽을 바이트 수입니다.</param>
      <returns vsli:raw="The string.">문자열입니다.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; bytes not available.">
        <paramref name="byteCount" /> 바이트를 사용할 수 없습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF8(System.Int32)">
      <summary vsli:raw="Reads a UTF8 encoded string starting at the current position.">현재 위치에서 시작하는 UTF8 인코딩된 문자열을 읽습니다.</summary>
      <param name="byteCount" vsli:raw="The number of bytes to read.">읽을 바이트 수입니다.</param>
      <returns vsli:raw="The string.">문자열입니다.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; bytes not available.">
        <paramref name="byteCount" /> 바이트를 사용할 수 없습니다.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.RemainingBytes">
      <summary vsli:raw="Gets the number of bytes remaining from current position to the end of the underlying memory block.">현재 위치에서 기본 메모리 블록의 끝까지 남아 있는 바이트 수를 가져옵니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Reset">
      <summary vsli:raw="Repositions the reader to the start of the underlying memory block.">reader를 기본 메모리 블록의 시작 부분에 다시 배치합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.StartPointer">
      <summary vsli:raw="Gets a pointer to the byte at the start of the underlying memory block.">기본 메모리 블록의 시작 부분에 있는 바이트에 대한 포인터를 가져옵니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedInteger(System.Int32@)">
      <summary vsli:raw="Reads an unsigned compressed integer value. See Metadata Specification section II.23.2: Blobs and signatures.">부호 없는 압축된 정수 값을 읽습니다. 메타데이터 사양 섹션 II.23.2 참조: Blob 및 서명.</summary>
      <param name="value" vsli:raw="The value of the compressed integer that was read.">읽은 압축된 정수 값입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the value was read successfully. &lt;see langword=&quot;false&quot; /&gt; if the data at the current position was not a valid compressed integer.">값을 성공적으로 읽은 경우 <see langword="true" />입니다. 현재 위치의 데이터가 유효한 압축 정수가 아닌 경우 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedSignedInteger(System.Int32@)">
      <summary vsli:raw="Reads a signed compressed integer value. See Metadata Specification section II.23.2: Blobs and signatures.">부호 있는 압축된 정수 값을 읽습니다. 메타데이터 사양 섹션 II.23.2 참조: Blob 및 서명.</summary>
      <param name="value" vsli:raw="The value of the compressed integer that was read.">읽은 압축된 정수 값입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the value was read successfully. &lt;see langword=&quot;false&quot; /&gt; if the data at the current position was not a valid compressed integer.">값을 성공적으로 읽은 경우 <see langword="true" />입니다. 현재 위치의 데이터가 유효한 압축 정수가 아닌 경우 <see langword="false" />입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.BlobWriter" />
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[])">
      <param name="buffer" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" vsli:raw="" />
      <param name="start" vsli:raw="" />
      <param name="count" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Int32)">
      <param name="size" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Reflection.Metadata.Blob)">
      <param name="blob" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.Align(System.Int32)">
      <param name="alignment" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.Blob" />
    <member name="M:System.Reflection.Metadata.BlobWriter.Clear" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ContentEquals(System.Reflection.Metadata.BlobWriter)">
      <summary vsli:raw="Compares the current content of this writer with another one.">이 작성기의 현재 내용을 다른 내용과 비교합니다.</summary>
      <param name="other" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.Length" />
    <member name="P:System.Reflection.Metadata.BlobWriter.Offset" />
    <member name="M:System.Reflection.Metadata.BlobWriter.PadTo(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.RemainingBytes" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray(System.Int32,System.Int32)">
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the buffer content.">
        <paramref name="start" /> 및 <paramref name="byteCount" />에 의해 지정된 범위가 버퍼 콘텐츠 경계를 벗어납니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the buffer content.">
        <paramref name="start" /> 및 <paramref name="byteCount" />에 의해 지정된 범위가 버퍼 콘텐츠 경계를 벗어납니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBoolean(System.Boolean)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteByte(System.Byte)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte*,System.Int32)">
      <param name="buffer" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" />가 <see langword="null" />입니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" />가 음수입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte,System.Int32)">
      <param name="value" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" />가 음수입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[])">
      <param name="buffer" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" />가 <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" vsli:raw="" />
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the &lt;paramref name=&quot;buffer&quot; /&gt;.">
        <paramref name="start" /> 및 <paramref name="byteCount" />에 의해 지정된 범위가 <paramref name="buffer" />의 경계를 벗어납니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="buffer" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" />가 <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <param name="buffer" vsli:raw="" />
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" />가 <see langword="null" />입니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the &lt;paramref name=&quot;buffer&quot; /&gt;.">
        <paramref name="start" /> 및 <paramref name="byteCount" />에 의해 지정된 범위가 <paramref name="buffer" />의 경계를 벗어납니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.IO.Stream,System.Int32)">
      <param name="source" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="source" />가 <see langword="null" />입니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" />가 음수입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Reflection.Metadata.BlobBuilder)">
      <param name="source" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="source" />가 <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedInteger(System.Int32)">
      <summary vsli:raw="Implements compressed unsigned integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.">ECMA-335-II 장 23.2에 정의된 대로 압축된 부호 없는 정수 인코딩을 구현합니다. Blob 및 서명.</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; can't be represented as a compressed unsigned integer.">
        <paramref name="value" />는 압축된 부호 없는 정수로 표시될 수 없습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedSignedInteger(System.Int32)">
      <summary vsli:raw="Implements compressed signed integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.">ECMA-335-II 장 23.2에 정의된 대로 압축된 부호 있는 정수 인코딩을 구현합니다. Blob 및 서명.</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; can't be represented as a compressed signed integer.">
        <paramref name="value" />는 압축된 부호 있는 정수로 표시될 수 없습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteConstant(System.Object)">
      <summary vsli:raw="Writes a constant value (see ECMA-335 Partition II section 22.9) at the current position.">현재 위치에서 상수 값(ECMA-335 Partition II 섹션 22.9 참조)을 씁니다.</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is not of a constant type.">
        <paramref name="value" />는 상수 유형이 아닙니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDateTime(System.DateTime)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDecimal(System.Decimal)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDouble(System.Double)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteGuid(System.Guid)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16(System.Int16)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16BE(System.Int16)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32(System.Int32)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32BE(System.Int32)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt64(System.Int64)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteReference(System.Int32,System.Boolean)">
      <summary vsli:raw="Writes a reference to a heap (heap offset) or a table (row number).">힙(힙 오프셋) 또는 테이블(행 번호)에 대한 참조를 씁니다.</summary>
      <param name="reference" vsli:raw="Heap offset or table row number.">힙 오프셋 또는 테이블 행 번호.</param>
      <param name="isSmall" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode the reference as 16-bit integer, &lt;see langword=&quot;false&quot; /&gt; to encode as 32-bit integer.">
        <see langword="true" />를 사용하여 참조를 16비트 정수로 인코딩하고, <see langword="false" />를 사용하여 32비트 정수로 인코딩합니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSByte(System.SByte)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSerializedString(System.String)">
      <summary vsli:raw="Writes a string in SerString format (see ECMA-335-II 23.3 Custom attributes).">SerString 형식으로 문자열을 씁니다(ECMA-335-II 23.3 사용자 지정 특성 참조).</summary>
      <param name="str" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">작성기는 쓸 수 없습니다. 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSingle(System.Single)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16(System.UInt16)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16BE(System.UInt16)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32(System.UInt32)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32BE(System.UInt32)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt64(System.UInt64)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)">
      <summary vsli:raw="Writes a string in User String (#US) heap format (see ECMA-335-II 24.2.4 #US and #Blob heaps).">사용자 문자열(#US) 힙 형식으로 문자열을 씁니다(ECMA-335-II 24.2.4 #US 및 #Blob 힙 참조).</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">작성기는 쓸 수 없으며 다른 작성기와 연결되어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.Char[])">
      <summary vsli:raw="Writes a UTF16 (little-endian) encoded string at the current position.">현재 위치에서 UTF16(little endian) 인코딩된 문자열을 씁니다.</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" />가 <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.String)">
      <summary vsli:raw="Writes a UTF16 (little-endian) encoded string at the current position.">현재 위치에서 UTF16(little endian) 인코딩된 문자열을 씁니다.</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" />가 <see langword="null" />입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF8(System.String,System.Boolean)">
      <summary vsli:raw="Writes a UTF8 encoded string at the current position.">현재 위치에서 UTF8 인코딩된 문자열을 씁니다.</summary>
      <param name="value" vsli:raw="" />
      <param name="allowUnpairedSurrogates" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" />가 <see langword="null" />인 경우</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Constant" />
    <member name="P:System.Reflection.Metadata.Constant.Parent">
      <summary vsli:raw="Gets the parent handle (&lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;).">부모 핸들(<see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />)을 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.TypeCode">
      <summary vsli:raw="Gets a type code that identifies the type of the constant value.">상수 값의 형식을 식별하는 형식 코드를 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.Value">
      <summary vsli:raw="Gets the constant value.">상수 값을 가져옵니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ConstantHandle" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Reflection.Metadata.ConstantHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ConstantHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Equality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Inequality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.ConstantTypeCode">
      <summary vsli:raw="Specifies values that represent types of metadata constants.">메타데이터 상수의 형식을 나타내는 값을 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Boolean">
      <summary vsli:raw="A Boolean type.">Boolean 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Byte">
      <summary vsli:raw="An unsigned 1-byte integer.">부호 없는 1바이트 정수입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Char">
      <summary vsli:raw="A character type.">문자 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Double">
      <summary vsli:raw="An 8-byte floating point type.">8바이트 부동 소수점 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int16">
      <summary vsli:raw="A signed 2-byte integer type.">부호 있는 2바이트 정수 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int32">
      <summary vsli:raw="A signed 4-byte integer type.">부호 있는 4바이트 정수 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int64">
      <summary vsli:raw="A signed 8-byte integer type.">부호 있는 8바이트 정수 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Invalid">
      <summary vsli:raw="An invalid type.">잘못된 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.NullReference">
      <summary vsli:raw="A null reference.">null 참조입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.SByte">
      <summary vsli:raw="A signed 1-byte integer type.">부호 있는 1바이트 정수 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Single">
      <summary vsli:raw="A 4-byte floating point type.">4바이트 부동 소수점 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.String">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; type.">
        <see cref="T:System.String" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt16">
      <summary vsli:raw="An unsigned 2-byte integer type.">부호 없는 2바이트 정수 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt32">
      <summary vsli:raw="An unsigned 4-byte integer type.">부호 없는 4바이트 정수 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt64">
      <summary vsli:raw="An unsigned 8-byte integer type.">부호 없는 8바이트 정수 형식입니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttribute" />
    <member name="P:System.Reflection.Metadata.CustomAttribute.Constructor">
      <summary vsli:raw="Gets the constructor (the &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;) of the custom attribute type.">사용자 지정 특성 유형의 생성자(<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />)를 가져옵니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttribute.DecodeValue``1(System.Reflection.Metadata.ICustomAttributeTypeProvider{``0})">
      <summary vsli:raw="Decodes the arguments encoded in the value blob.">값 Blob에 인코딩된 인수를 디코딩합니다.</summary>
      <param name="provider" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Parent">
      <summary vsli:raw="Gets the handle of the metadata entity the attribute is applied to.">특성이 적용되는 메타데이터 엔터티의 핸들을 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Value">
      <summary vsli:raw="Gets the value of the attribute.">특성 값을 얻습니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandle" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.CustomAttributeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Equality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Inequality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection" />
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomAttributeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1">
      <summary vsli:raw="Represents a named argument decoded from a custom attribute signature.">사용자 지정 특성 서명에서 디코딩된 명명된 인수를 나타냅니다.</summary>
      <typeparam name="TType" vsli:raw="The type used to represent types of values decoded from the custom attribute signature.">사용자 지정 특성 시그니처에서 디코딩된 값의 형식을 나타내는 데 사용 되는 형식입니다.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeNamedArgument`1.#ctor(System.String,System.Reflection.Metadata.CustomAttributeNamedArgumentKind,`0,System.Object)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.CustomAttributeNamedArgument`1&quot; /&gt; structure using the specified name, kind, type, and value.">지정된 이름, 종류, 형식 및 값을 사용하여 <see cref="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
      <param name="name" vsli:raw="The name of the argument.">인수의 이름입니다.</param>
      <param name="kind" vsli:raw="The kind of the argument.">인수의 종류입니다.</param>
      <param name="type" vsli:raw="The type of the argument.">인수 형식입니다.</param>
      <param name="value" vsli:raw="The value of the argument.">인수 값입니다.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Kind">
      <summary vsli:raw="Gets the kind of argument.">인수의 종류를 가져옵니다.</summary>
      <returns vsli:raw="The argument kind.">인수 종류입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Name">
      <summary vsli:raw="Gets the name of the argument.">인수의 이름을 가져옵니다.</summary>
      <returns vsli:raw="The argument name.">인수 이름입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Type">
      <summary vsli:raw="Gets the type of the argument.">인수의 형식을 가져옵니다.</summary>
      <returns vsli:raw="The argument type.">인수 형식입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Value">
      <summary vsli:raw="Gets the value of the argument.">인수 값을 가져옵니다.</summary>
      <returns vsli:raw="An object containing the argument value.">인수 값을 포함 하는 개체입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgumentKind">
      <summary vsli:raw="Specifies constants that define the kinds of arguments in a custom attribute signature.">사용자 지정 특성 서명에서 인수의 종류를 정의하는 상수를 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Field">
      <summary vsli:raw="A field argument.">필드 인수입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Property">
      <summary vsli:raw="A property argument.">속성 인수입니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1">
      <summary vsli:raw="Represents a typed argument for a custom metadata attribute.">사용자 지정 메타데이터 특성에 대해 형식 인수를 나타냅니다.</summary>
      <typeparam name="TType" vsli:raw="The type of the argument.">인수 형식입니다.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeTypedArgument`1.#ctor(`0,System.Object)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.CustomAttributeTypedArgument`1&quot; /&gt; structure using the specified argument type and value.">지정된 인수 형식 및 값을 사용하여 <see cref="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
      <param name="type" vsli:raw="The type of the argument.">인수 형식입니다.</param>
      <param name="value" vsli:raw="The argument value.">인수 값입니다.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Type">
      <summary vsli:raw="Gets the type of the argument.">인수의 형식을 가져옵니다.</summary>
      <returns vsli:raw="The argument type.">인수 형식입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Value">
      <summary vsli:raw="Gets the value of the argument.">인수 값을 가져옵니다.</summary>
      <returns vsli:raw="The argument value.">인수 값입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeValue`1">
      <summary vsli:raw="Represents a custom attribute of the type specified by &lt;paramref name=&quot;TType&quot; /&gt;.">
        <paramref name="TType" />에서 지정된 형식의 사용자 지정 특성을 나타냅니다.</summary>
      <typeparam name="TType" vsli:raw="The attribute type.">특성 유형입니다.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeValue`1.#ctor(System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeTypedArgument{`0}},System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeNamedArgument{`0}})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.CustomAttributeValue`1&quot; /&gt; structure using the specified fixed arguments and named arguments.">지정된 고정 인수 및 명명된 인수를 사용하여 <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
      <param name="fixedArguments" vsli:raw="The fixed arguments.">고정 인수입니다.</param>
      <param name="namedArguments" vsli:raw="The named arguments.">명명된 인수입니다.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.FixedArguments">
      <summary vsli:raw="Gets the fixed arguments for the custom attribute.">사용자 지정 특성에 대한 고정 인수를 가져옵니다.</summary>
      <returns vsli:raw="An immutable array of arguments.">변경할 수 없는 인수 배열입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.NamedArguments">
      <summary vsli:raw="Gets the named arguments for the custom attribute value.">사용자 지정 특성 값에 대한 명명된 인수를 가져옵니다.</summary>
      <returns vsli:raw="An immutable array of arguments.">변경할 수 없는 인수 배열입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Kind" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Parent" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Value" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Equality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Inequality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomDebugInformationHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.DebugMetadataHeader" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.EntryPoint" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.Id" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.IdStartOffset">
      <summary vsli:raw="Gets the offset (in bytes) from the start of the metadata blob to the start of the &lt;see cref=&quot;P:System.Reflection.Metadata.DebugMetadataHeader.Id&quot; /&gt; blob.">메타데이터 Blob 시작에서 <see cref="P:System.Reflection.Metadata.DebugMetadataHeader.Id" /> Blob의 시작으로 오프셋(바이트)을 가져옵니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttribute" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Action" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Parent" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.PermissionSet" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Equality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Inequality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DeclarativeSecurityAttributeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.Document">
      <summary vsli:raw="The source document in the debug metadata.">디버그 메타데이터의 소스 문서입니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Hash">
      <summary vsli:raw="Gets the document content hash.">문서 콘텐츠 해시를 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.HashAlgorithm">
      <summary vsli:raw="Gets the hash algorithm used to calculate the &lt;see cref=&quot;P:System.Reflection.Metadata.Document.Hash&quot; /&gt; (SHA1, SHA256, etc.).">
        <see cref="P:System.Reflection.Metadata.Document.Hash" />(SHA1, SHA256 등)를 계산하는 데 사용되는 해시 알고리즘을 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Language">
      <summary vsli:raw="Gets the source code language (C#, VB, F#, etc.).">소스 코드 언어(C#, VB, F# 등)를 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Name">
      <summary vsli:raw="Gets the document name blob.">문서 이름 Blob을 가져옵니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandle" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Reflection.Metadata.DocumentHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.DocumentHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Equality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Inequality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection" />
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DocumentHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.DocumentNameBlobHandle">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.BlobHandle&quot; /&gt; representing a blob on #Blob heap in Portable PDB structured as Document Name.">문서 이름으로 구조화된 이식 가능한 PDB에서 #Blob 힙의 blob을 나타내는 <see cref="T:System.Reflection.Metadata.BlobHandle" />입니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.DocumentNameBlobHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Equality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Explicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.DocumentNameBlobHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Implicit(System.Reflection.Metadata.DocumentNameBlobHandle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Inequality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Shape(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <param name="rank" vsli:raw="The number of dimensions in the array (shall be 1 or more)." />
      <param name="sizes" vsli:raw="Dimension sizes. The array may be shorter than &lt;paramref name=&quot;rank&quot; /&gt; but not longer." />
      <param name="lowerBounds" vsli:raw="Dimension lower bounds, or default(&lt;see cref=&quot;T:System.Collections.Immutable.ImmutableArray`1&quot; /&gt;) to set all &lt;paramref name=&quot;rank&quot; /&gt; lower bounds to 0.&#xA; The array may be shorter than &lt;paramref name=&quot;rank&quot; /&gt; but not longer." />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.BlobEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.BlobEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Action{System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder},System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder})">
      <param name="fixedArguments" vsli:raw="Called first, to encode fixed arguments." />
      <param name="namedArguments" vsli:raw="Called second, to encode named arguments." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder@,System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder@)">
      <param name="fixedArguments" vsli:raw="Use first, to encode fixed arguments." />
      <param name="namedArguments" vsli:raw="Use second, to encode named arguments." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.LocalVariableSignature(System.Int32)">
      <param name="variableCount" vsli:raw="Number of local variables." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSignature(System.Reflection.Metadata.SignatureCallingConvention,System.Int32,System.Boolean)">
      <param name="convention" vsli:raw="Calling convention." />
      <param name="genericParameterCount" vsli:raw="Number of generic parameters." />
      <param name="isInstanceMethod" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode an instance method signature, &lt;see langword=&quot;false&quot; /&gt; to encode a static method signature." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSpecificationSignature(System.Int32)">
      <param name="genericArgumentCount" vsli:raw="Number of generic arguments." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetArguments(System.Int32)">
      <param name="argumentCount" vsli:raw="Number of arguments in the set." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetBlob(System.Int32)">
      <param name="attributeCount" vsli:raw="Number of attributes in the set." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PropertySignature(System.Boolean)">
      <param name="isInstanceProperty" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode an instance property signature, &lt;see langword=&quot;false&quot; /&gt; to encode a static property signature." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.TypeSpecificationSignature" />
    <member name="T:System.Reflection.Metadata.Ecma335.CodedIndex" />
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.CustomAttributeType(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasConstant(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomAttribute(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.InterfaceImplementationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignatureHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ManifestResourceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterConstraintHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MethodSpecificationHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.InterfaceImplementationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignatureHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ManifestResourceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterConstraintHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DocumentHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalScopeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalVariableHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalConstantHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.ImportScopeHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasDeclSecurity(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasFieldMarshal(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasSemantics(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.Implementation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberForwarded(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinition&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinition&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberRefParent(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MethodDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.ResolutionScope(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRefOrSpec(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeOrMethodDef(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;." />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.#ctor" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddCatchRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="tryStart" vsli:raw="Label marking the first instruction of the try block." />
      <param name="tryEnd" vsli:raw="Label marking the instruction immediately following the try block." />
      <param name="handlerStart" vsli:raw="Label marking the first instruction of the handler." />
      <param name="handlerEnd" vsli:raw="Label marking the instruction immediately following the handler." />
      <param name="catchType" vsli:raw="The type of exception to be caught: &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFaultRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="tryStart" vsli:raw="Label marking the first instruction of the try block." />
      <param name="tryEnd" vsli:raw="Label marking the instruction immediately following the try block." />
      <param name="handlerStart" vsli:raw="Label marking the first instruction of the handler." />
      <param name="handlerEnd" vsli:raw="Label marking the instruction immediately following the handler." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFilterRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="tryStart" vsli:raw="Label marking the first instruction of the try block." />
      <param name="tryEnd" vsli:raw="Label marking the instruction immediately following the try block." />
      <param name="handlerStart" vsli:raw="Label marking the first instruction of the handler." />
      <param name="handlerEnd" vsli:raw="Label marking the instruction immediately following the handler." />
      <param name="filterStart" vsli:raw="Label marking the first instruction of the filter block." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFinallyRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="tryStart" vsli:raw="Label marking the first instruction of the try block." />
      <param name="tryEnd" vsli:raw="Label marking the instruction immediately following the try block." />
      <param name="handlerStart" vsli:raw="Label marking the first instruction of the handler." />
      <param name="handlerEnd" vsli:raw="Label marking the instruction immediately following the handler." />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ElementType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ObjectArray" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Boolean" />
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Enum(System.String)">
      <param name="enumTypeName" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveSerializationTypeCode)">
      <param name="type" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SystemType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt64" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Count(System.Int32)">
      <param name="count" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.AddModifier(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <param name="type" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;." />
      <param name="isOptional" vsli:raw="Is optional modifier." />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry" />
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.#ctor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="handle" vsli:raw="" />
      <param name="operation" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Handle" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Operation" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueOperation" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddEvent" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddField" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddParameter" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddProperty" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.Default" />
    <member name="T:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Add(System.Reflection.Metadata.ExceptionRegionKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <param name="kind" vsli:raw="Clause kind." />
      <param name="tryOffset" vsli:raw="Try block start offset." />
      <param name="tryLength" vsli:raw="Try block length." />
      <param name="handlerOffset" vsli:raw="Handler start offset." />
      <param name="handlerLength" vsli:raw="Handler length." />
      <param name="catchType" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, or nil if &lt;paramref name=&quot;kind&quot; /&gt; is not &lt;see cref=&quot;F:System.Reflection.Metadata.ExceptionRegionKind.Catch&quot; /&gt;." />
      <param name="filterOffset" vsli:raw="Offset of the filter block, or 0 if the &lt;paramref name=&quot;kind&quot; /&gt; is not &lt;see cref=&quot;F:System.Reflection.Metadata.ExceptionRegionKind.Filter&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddCatch(System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle)">
      <param name="tryOffset" vsli:raw="Try block start offset." />
      <param name="tryLength" vsli:raw="Try block length." />
      <param name="handlerOffset" vsli:raw="Handler start offset." />
      <param name="handlerLength" vsli:raw="Handler length." />
      <param name="catchType" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFault(System.Int32,System.Int32,System.Int32,System.Int32)">
      <param name="tryOffset" vsli:raw="Try block start offset." />
      <param name="tryLength" vsli:raw="Try block length." />
      <param name="handlerOffset" vsli:raw="Handler start offset." />
      <param name="handlerLength" vsli:raw="Handler length." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFilter(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <param name="tryOffset" vsli:raw="Try block start offset." />
      <param name="tryLength" vsli:raw="Try block length." />
      <param name="handlerOffset" vsli:raw="Handler start offset." />
      <param name="handlerLength" vsli:raw="Handler length." />
      <param name="filterOffset" vsli:raw="Offset of the filter block." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFinally(System.Int32,System.Int32,System.Int32,System.Int32)">
      <param name="tryOffset" vsli:raw="Try block start offset." />
      <param name="tryLength" vsli:raw="Try block length." />
      <param name="handlerOffset" vsli:raw="Handler start offset." />
      <param name="handlerLength" vsli:raw="Handler length." />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.HasSmallFormat" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallExceptionRegion(System.Int32,System.Int32)">
      <param name="startOffset" vsli:raw="Start offset of the region." />
      <param name="length" vsli:raw="Length of the region." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallRegionCount(System.Int32)">
      <param name="exceptionRegionCount" vsli:raw="Number of exception regions." />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions.GetTypeDefinitionId(System.Reflection.Metadata.ExportedType)">
      <param name="exportedType" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasExplicitThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.None" />
    <member name="T:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.HeapIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Blob" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Guid" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.String" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.UserString" />
    <member name="T:System.Reflection.Metadata.Ecma335.InstructionEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.Ecma335.ControlFlowBuilder)">
      <param name="codeBuilder" vsli:raw="Builder to write encoded instructions to." />
      <param name="controlFlowBuilder" vsli:raw="Builder tracking labels, branches and exception handlers.&#xA; Must be specified to be able to use some of the control-flow factory methods of &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.InstructionEncoder&quot; /&gt;, such as &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)&quot; /&gt;, &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel&quot; /&gt;, &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)&quot; /&gt; etc." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="code" vsli:raw="Branch instruction to encode." />
      <param name="label" vsli:raw="Label of the target location in instruction stream." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.EntityHandle)">
      <param name="methodHandle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="methodHandle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="methodHandle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="methodHandle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.CallIndirect(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="signature" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.CodeBuilder" />
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" />
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel" />
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgument(System.Int32)">
      <param name="argumentIndex" vsli:raw="Index of the argument." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgumentAddress(System.Int32)">
      <param name="argumentIndex" vsli:raw="Index of the argument." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI4(System.Int32)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI8(System.Int64)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR4(System.Single)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR8(System.Double)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocal(System.Int32)">
      <param name="slotIndex" vsli:raw="Index of the local variable slot." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocalAddress(System.Int32)">
      <param name="slotIndex" vsli:raw="Index of the local variable slot." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="label" vsli:raw="Label to mark." />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.Offset" />
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.OpCode(System.Reflection.Metadata.ILOpCode)">
      <param name="code" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreArgument(System.Int32)">
      <param name="argumentIndex" vsli:raw="Index of the argument." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreLocal(System.Int32)">
      <param name="slotIndex" vsli:raw="Index of the local variable slot." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Int32)">
      <param name="token" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LabelHandle" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.Id">
      <summary vsli:raw="1-based id identifying the label within the context of a &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />의 컨텍스트 내에서 레이블을 식별하는, 1부터 시작되는 ID입니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Equality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Inequality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralEncoder">
      <summary vsli:raw="Provides methods for encoding literals.">리터럴을 인코딩하기 위한 메서드를 제공합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="Creates a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.LiteralEncoder&quot; /&gt; class with the specified blob builder.">지정된 BLOB 빌더를 사용하여 <see cref="T:System.Reflection.Metadata.Ecma335.LiteralEncoder" /> 클래스의 새 인스턴스를 만듭니다.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Scalar">
      <summary vsli:raw="Returns the encoder used to encode the literal value.">리터럴 값을 인코딩하는 데 사용되는 인코더를 반환합니다.</summary>
      <returns vsli:raw="The encoder of the literal value.">리터럴 값의 인코더입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ScalarEncoder})">
      <summary vsli:raw="Encodes the type and the value of a literal using the specified delegates.">지정된 대리자를 사용하여 리터럴의 형식 및 값을 인코딩합니다.</summary>
      <param name="type" vsli:raw="A delegate used to encode the type of the literal. Called first by this method.">리터럴의 형식을 인코딩하는 데 사용되는 대리자입니다. 이 메서드에서 처음 호출됩니다.</param>
      <param name="scalar" vsli:raw="A delegate used to encode the value of the literal. Called second by this method.">리터럴의 값을 인코딩하는 데 사용되는 대리자입니다. 이 메서드에서 두 번째로 호출됩니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder@,System.Reflection.Metadata.Ecma335.ScalarEncoder@)">
      <summary vsli:raw="Returns a pair of encoders that must be used to encode the type and value of a literal in the order they appear in the parameter list.">매개 변수 목록에 나타나는 순서대로 리터럴의 형식과 값을 인코딩하는 데 사용해야 하는 인코더 쌍을 반환합니다.</summary>
      <param name="type" vsli:raw="When this method returns, a custom attribute element type encoder used to encode the type of the literal.">이 메서드가 반환될 때 리터럴의 형식을 인코딩하는 데 사용되는 사용자 지정 특성 요소 형식 인코더입니다.</param>
      <param name="scalar" vsli:raw="When this method returns, a scalar encoded used to encode the value of the literal.">이 메서드가 반환될 때 리터럴의 값을 인코딩하는 데 사용되는 스칼라 인코더입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.VectorEncoder})">
      <summary vsli:raw="Encodes the type and the items of a vector literal using the specified delegates.">지정된 대리자를 사용하여 벡터의 형식 및 항목을 인코딩합니다.</summary>
      <param name="arrayType" vsli:raw="A delegate used to encode the type of the vector. Called first by this method.">벡터의 형식을 인코딩하는 데 사용되는 대리자입니다. 이 메서드에서 처음 호출됩니다.</param>
      <param name="vector" vsli:raw="A delegate used to encode the items of the vector. Called second by this method.">벡터의 항목을 인코딩하는 데 사용되는 대리자입니다. 이 메서드에서 두 번째로 호출됩니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder@,System.Reflection.Metadata.Ecma335.VectorEncoder@)">
      <summary vsli:raw="Returns a pair of encoders that must be used to encode the type and the items of a vector literal in the order they appear in the parameter list.">매개 변수 목록에 나타나는 순서대로 벡터 리터럴의 형식과 항목을 인코딩하는 데 사용해야 하는 인코더 쌍을 반환합니다.</summary>
      <param name="arrayType" vsli:raw="When this method returns, a custom attribute array type encoder used to encode the type of the vector.">이 메서드가 반환될 때 벡터의 형식을 인코딩하는 데 사용되는 사용자 지정 특성 배열 형식 인코더입니다.</param>
      <param name="vector" vsli:raw="When this method returns, a vector encoder used to encode the items of the vector.">이 메서드가 반환될 때 벡터의 항목을 인코딩하는 데 사용되는 벡터 인코더입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Vector">
      <summary vsli:raw="Gets a vector encoder used to encode the items of a vector.">벡터의 항목을 인코딩하는 데 사용되는 벡터 인코더를 가져옵니다.</summary>
      <returns vsli:raw="A vector encoder used to encode the items of a vector.">벡터의 항목을 인코딩하는 데 사용되는 벡터 인코더입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.AddLiteral" />
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.AddVariable" />
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Type(System.Boolean,System.Boolean)">
      <param name="isByRef" vsli:raw="" />
      <param name="isPinned" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.TypedReference" />
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataAggregator" />
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseTableRowCounts" vsli:raw="" />
      <param name="baseHeapSizes" vsli:raw="" />
      <param name="deltaReaders" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Reflection.Metadata.MetadataReader,System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseReader" vsli:raw="" />
      <param name="deltaReaders" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.GetGenerationHandle(System.Reflection.Metadata.Handle,System.Int32@)">
      <summary vsli:raw="Calculates the handle of the entity within the metadata generation it is defined in, given a handle of an entity in an aggregate metadata.">집계 메타데이터 내의 엔터티 핸들을 토대로, 엔터티가 정의되는 메타데이터 생성 내의 엔터티 핸들을 계산합니다.</summary>
      <param name="handle" vsli:raw="Handle of an entity in an aggregate metadata.">집계 메타데이터의 엔터티 핸들입니다.</param>
      <param name="generation" vsli:raw="The generation the entity is defined in.">엔터티가 정의되는 생성입니다.</param>
      <returns vsli:raw="Handle of the entity within the metadata &lt;paramref name=&quot;generation&quot; /&gt;.">메타데이터 <paramref name="generation" />의 엔터티 핸들입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataBuilder">
      <summary vsli:raw="The MetadataBuilder class writes metadata for an assembly in a highly performant manner. It is designed for use by compilers and other assembly generation tools.">MetadataBuilder 클래스는 고성능 방식으로 어셈블리에 대한 메타데이터를 읽고 씁니다. 컴파일러 및 기타 어셈블리 생성 도구에서 사용하도록 설계되었습니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary vsli:raw="Creates a builder for metadata tables and heaps.">메타데이터 테이블 및 힙에 대한 작성기를 만듭니다.</summary>
      <param name="userStringHeapStartOffset" vsli:raw="The start offset of the User String heap. The cumulative size of User String heaps of all previous EnC generations should be 0 unless the metadata is EnC delta metadata.">사용자 문자열 힙의 시작 오프셋입니다. 메타데이터가 EnC 델타 메타데이터가 아닌 한, 모든 이전 EnC 생성의 사용자 문자열 힙 누적 크기는 0이어야 합니다.</param>
      <param name="stringHeapStartOffset" vsli:raw="The start offset of the String heap. The cumulative size of String heaps of all previous EnC generations should be 0 unless the metadata is EnC delta metadata.">문자열 힙의 시작 오프셋입니다. 메타데이터가 EnC 델타 메타데이터가 아닌 한, 모든 이전 EnC 생성의 문자열 힙 누적 크기는 0이어야 합니다.</param>
      <param name="blobHeapStartOffset" vsli:raw="The start offset of the Blob heap. The cumulative size of Blob heaps of all previous EnC generations should be 0 unless the metadata is EnC delta metadata.">Blob 힙의 시작 오프셋입니다. 메타데이터가 EnC 델타 메타데이터가 아닌 한, 모든 이전 EnC 생성의 Blob 힙 누적 크기는 0이어야 합니다.</param>
      <param name="guidHeapStartOffset" vsli:raw="The start offset of the Guid heap. The cumulative size of Guid heaps of all previous EnC generations should be 0 unless the metadata is EnC delta metadata.">GUID 힙의 시작 오프셋입니다. 메타데이터가 EnC 델타 메타데이터가 아닌 한, 모든 이전 EnC 생성의 GUID 힙 누적 크기는 0이어야 합니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssembly(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.AssemblyHashAlgorithm)">
      <param name="name" vsli:raw="" />
      <param name="version" vsli:raw="" />
      <param name="culture" vsli:raw="" />
      <param name="publicKey" vsli:raw="" />
      <param name="flags" vsli:raw="" />
      <param name="hashAlgorithm" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyFile(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Boolean)">
      <param name="name" vsli:raw="" />
      <param name="hashValue" vsli:raw="" />
      <param name="containsMetadata" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyReference(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.Metadata.BlobHandle)">
      <param name="name" vsli:raw="" />
      <param name="version" vsli:raw="" />
      <param name="culture" vsli:raw="" />
      <param name="publicKeyOrToken" vsli:raw="" />
      <param name="flags" vsli:raw="" />
      <param name="hashValue" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddConstant(System.Reflection.Metadata.EntityHandle,System.Object)">
      <summary vsli:raw="Adds a default value for a parameter, field or property.">매개 변수, 필드 또는 속성의 기본값을 추가합니다.</summary>
      <param name="parent" vsli:raw="The parent entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;.">부모 엔터티 핸들이며 <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" /> 중 하나일 수 있습니다.</param>
      <param name="value" vsli:raw="The constant value.">상수 값입니다.</param>
      <returns vsli:raw="A handle to the added constant.">추가된 상수에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a custom attribute.">사용자 지정 특성을 추가합니다.</summary>
      <param name="parent" vsli:raw="An entity to attach the custom attribute to: a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.InterfaceImplementationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignatureHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ManifestResourceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterConstraintHandle&quot; /&gt;, or a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodSpecificationHandle&quot; /&gt;.">사용자 지정 특성을 추가할 엔터티: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" /> 또는 <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />입니다.</param>
      <param name="constructor" vsli:raw="A custom attribute constructor: a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;.">사용자 지정 특성 생성자: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />입니다.</param>
      <param name="value" vsli:raw="A custom attribute value blob.">사용자 지정 특성 값 Blob입니다.</param>
      <returns vsli:raw="A handle to the added custom attribute.">추가된 사용자 지정 특성에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomDebugInformation(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds custom debug information.">사용자 지정 디버그 정보를 추가합니다.</summary>
      <param name="parent" vsli:raw="An entity to attach the debug information to: a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.InterfaceImplementationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignatureHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ManifestResourceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterConstraintHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DocumentHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalScopeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalVariableHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalConstantHandle&quot; /&gt;, or a &lt;see cref=&quot;T:System.Reflection.Metadata.ImportScopeHandle&quot; /&gt;.">디버그 정보를 연결할 엔터티: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />, <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.DocumentHandle" />, <see cref="T:System.Reflection.Metadata.LocalScopeHandle" />, <see cref="T:System.Reflection.Metadata.LocalVariableHandle" />, <see cref="T:System.Reflection.Metadata.LocalConstantHandle" /> 또는 <see cref="T:System.Reflection.Metadata.ImportScopeHandle" />입니다.</param>
      <param name="kind" vsli:raw="The information kind. Determines the structure of the &lt;paramref name=&quot;value&quot; /&gt; blob.">정보 종류입니다. <paramref name="value" /> Blob의 구조를 결정합니다.</param>
      <param name="value" vsli:raw="The custom debug information blob.">사용자 지정 디버그 정보 Blob입니다.</param>
      <returns vsli:raw="A handle to the added custom debug information.">추가된 사용자 지정 디버그 정보에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDeclarativeSecurityAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.DeclarativeSecurityAction,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a declarative security attribute to a type, method, or assembly.">형식, 메서드 또는 어셈블리에 선언적 보안 특성을 추가합니다.</summary>
      <param name="parent" vsli:raw="The parent entity handle, which can be one of the following: a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, or a &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;.">부모 엔터티 핸들이며 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" /> 중 하나일 수 있습니다.</param>
      <param name="action" vsli:raw="A declarative security action.">선언적 보안 작업입니다.</param>
      <param name="permissionSet" vsli:raw="The permission set blob.">권한 집합 Blob입니다.</param>
      <returns vsli:raw="A handle to the added declarative security attribute.">추가된 선언적 보안 특성에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDocument(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle)">
      <summary vsli:raw="Adds document debug information.">문서 디버그 정보를 추가합니다.</summary>
      <param name="name" vsli:raw="The document name blob.">문서 이름 Blob입니다.</param>
      <param name="hashAlgorithm" vsli:raw="THe GUID of the hash algorithm used to calculate the value of &lt;paramref name=&quot;hash&quot; /&gt;.">
        <paramref name="hash" /> 값을 계산하는 데 사용되는 해시 알고리즘의 GUID입니다.</param>
      <param name="hash" vsli:raw="The hash of the document content.">문서 콘텐츠의 해시입니다.</param>
      <param name="language" vsli:raw="The GUID of the language.">언어의 GUID입니다.</param>
      <returns vsli:raw="A handle to the added document.">추가된 문서에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncLogEntry(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="entity" vsli:raw="" />
      <param name="code" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncMapEntry(System.Reflection.Metadata.EntityHandle)">
      <param name="entity" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEvent(System.Reflection.EventAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Adds an event definition.">이벤트 정의를 추가합니다.</summary>
      <param name="attributes" vsli:raw="The event attributes.">이벤트 특성입니다.</param>
      <param name="name" vsli:raw="The event name.">이벤트 이름입니다.</param>
      <param name="type" vsli:raw="The type of the event: a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">이벤트 유형: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 또는 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />입니다.</param>
      <returns vsli:raw="A handle to the added event definition.">추가된 이벤트 정의에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEventMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="declaringType" vsli:raw="" />
      <param name="eventList" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddExportedType(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <summary vsli:raw="Adds an exported type.">내보낸 형식을 추가합니다.</summary>
      <param name="attributes" vsli:raw="The type attributes.">형식 특성입니다.</param>
      <param name="namespace" vsli:raw="The type namespace.">형식 네임스페이스입니다.</param>
      <param name="name" vsli:raw="The type name.">형식 이름입니다.</param>
      <param name="implementation" vsli:raw="The implementation entity handle, which can be one of the following: an &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;.">구현 엔터티 핸들이며 <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> 또는 <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> 중 하나일 수 있습니다.</param>
      <param name="typeDefinitionId" vsli:raw="The type definition ID.">형식 정의 ID입니다.</param>
      <returns vsli:raw="A handle to the added exported type.">추가된 내보낸 형식에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldDefinition(System.Reflection.FieldAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a field definition.">필드 정의를 추가합니다.</summary>
      <param name="attributes" vsli:raw="The field attributes.">필드 특성입니다.</param>
      <param name="name" vsli:raw="The field name.">필드 이름입니다.</param>
      <param name="signature" vsli:raw="The field signature. Use &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature&quot; /&gt; to construct the blob.">필드 시그니처입니다. <see cref="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature" />를 사용하여 Blob을 생성합니다.</param>
      <returns vsli:raw="A handle to the added field definition.">추가된 필드 정의에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldLayout(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary vsli:raw="Defines a field layout of a field definition.">필드 정의의 필드 레이아웃을 정의합니다.</summary>
      <param name="field" vsli:raw="The field definition handle.">필드 정의 핸들입니다.</param>
      <param name="offset" vsli:raw="The byte offset of the field within the declaring type instance.">선언 형식 인스턴스 내에 있는 필드의 바이트 오프셋입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldRelativeVirtualAddress(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary vsli:raw="Adds a mapping from a field to its initial value stored in the PE image.">PE 이미지에 저장된 초기 값에 필드의 매핑을 추가합니다.</summary>
      <param name="field" vsli:raw="The field definition handle.">필드 정의 핸들입니다.</param>
      <param name="offset" vsli:raw="The offset within the block in the PE image that stores initial values of mapped fields (usually in the .text section).">매핑된 필드의 초기 값을 저장하는 PE 이미지의 블록 내 오프셋입니다(일반적으로 .text 섹션에 있음).</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameter(System.Reflection.Metadata.EntityHandle,System.Reflection.GenericParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary vsli:raw="Adds a generic parameter definition.">제네릭 매개 변수 정의를 추가합니다.</summary>
      <param name="parent" vsli:raw="The parent entity handle, which can be either a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;.">부모 엔터티 핸들이며 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 중 하나일 수 있습니다.</param>
      <param name="attributes" vsli:raw="The generic parameter attributes.">제네릭 매개 변수 특성입니다.</param>
      <param name="name" vsli:raw="The parameter name.">매개 변수 이름입니다.</param>
      <param name="index" vsli:raw="The zero-based parameter index.">0부터 시작하는 매개 변수 인덱스입니다.</param>
      <returns vsli:raw="A handle to the added generic parameter.">추가된 제네릭 매개 변수에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameterConstraint(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Adds a type constraint to a generic parameter.">제네릭 매개 변수에 형식 제약 조건을 추가합니다.</summary>
      <param name="genericParameter" vsli:raw="The generic parameter to constrain.">제한할 제네릭 매개 변수입니다.</param>
      <param name="constraint" vsli:raw="The type constraint, which can be one of the following: a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">형식 제약 조건이며 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 또는 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> 중 하나일 수 있습니다.</param>
      <returns vsli:raw="A handle to the added generic parameter constraint.">추가된 제네릭 매개 변수 제약 조건에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddImportScope(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds local scope debug information.">로컬 범위 디버그 정보를 추가합니다.</summary>
      <param name="parentScope" vsli:raw="The parent scope handle.">부모 범위 핸들입니다.</param>
      <param name="imports" vsli:raw="The import scope handle.">가져오기 범위 핸들입니다.</param>
      <returns vsli:raw="A handle to the added import scope.">추가된 가져오기 범위에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddInterfaceImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Adds an interface implementation to a type.">형식에 인터페이스 구현을 추가합니다.</summary>
      <param name="type" vsli:raw="The type implementing the interface.">인터페이스를 구현하는 형식입니다.</param>
      <param name="implementedInterface" vsli:raw="The interface being implemented, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">구현되는 인터페이스이며 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 또는 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> 중 하나일 수 있습니다.</param>
      <returns vsli:raw="A handle to the added interface implementation.">추가된 인터페이스 구현에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalConstant(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds local constant debug information.">지역 상수 디버그 정보를 추가합니다.</summary>
      <param name="name" vsli:raw="The name of the variable.">변수의 이름입니다.</param>
      <param name="signature" vsli:raw="The LocalConstantSig blob.">LocalConstantSig Blob입니다.</param>
      <returns vsli:raw="A handle to the added local constant.">추가된 지역 상수에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalScope(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalConstantHandle,System.Int32,System.Int32)">
      <summary vsli:raw="Adds local scope debug information.">로컬 범위 디버그 정보를 추가합니다.</summary>
      <param name="method" vsli:raw="The containing method.">포함하는 메서드입니다.</param>
      <param name="importScope" vsli:raw="The handle of the associated import scope.">연결된 가져오기 범위의 핸들입니다.</param>
      <param name="variableList" vsli:raw="If the scope declares variables, set this to the handle of the first one. Otherwise, set this to the handle of the first variable declared by the next scope definition. If no scope defines any variables, &lt;see langword=&quot;System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(1)&quot; /&gt;.">범위가 변수를 선언하는 경우 이를 첫 번째 변수의 핸들로 설정합니다. 그렇지 않으면 이를 다음 범위 정의에 의해 선언된 첫 번째 변수의 핸들로 설정합니다. 범위가 변수를 정의하지 않으면 <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(1)" />입니다.</param>
      <param name="constantList" vsli:raw="If the scope declares constants, set this the handle of the first one. Otherwise, set this to the handle of the first constant declared by the next scope definition. If no scope defines any constants, &lt;see langword=&quot;System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(1)&quot; /&gt;.">범위가 상수를 선언하는 경우 이를 첫 번째 상수의 핸들로 설정합니다. 그렇지 않으면 이를 다음 범위 정의에 의해 선언된 첫 번째 상수의 핸들로 설정합니다. 범위가 상수를 정의하지 않으면 <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(1)" />입니다.</param>
      <param name="startOffset" vsli:raw="The offset of the first instruction covered by the scope.">범위에 포함된 첫 번째 명령의 오프셋입니다.</param>
      <param name="length" vsli:raw="The length (in bytes) of the scope.">범위의 길이(바이트)입니다.</param>
      <returns vsli:raw="A handle to the added local scope.">추가된 로컬 범위에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalVariable(System.Reflection.Metadata.LocalVariableAttributes,System.Int32,System.Reflection.Metadata.StringHandle)">
      <summary vsli:raw="Adds local variable debug information.">지역 변수 디버그 정보를 추가합니다.</summary>
      <param name="attributes" vsli:raw="The local variable attributes.">지역 변수 특성입니다.</param>
      <param name="index" vsli:raw="The zero-base index of the local variable in the local signature.">로컬 시그니처의 지역 변수에 대한 0부터 시작하는 인덱스입니다.</param>
      <param name="name" vsli:raw="The name of the variable.">변수의 이름입니다.</param>
      <returns vsli:raw="A handle to the added local variable.">추가된 지역 변수에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddManifestResource(System.Reflection.ManifestResourceAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.UInt32)">
      <summary vsli:raw="Adds a manifest resource.">매니페스트 리소스를 추가합니다.</summary>
      <param name="attributes" vsli:raw="The manifest resource attributes.">매니페스트 리소스 특성입니다.</param>
      <param name="name" vsli:raw="The name of the manifest resource.">매니페스트 리소스의 이름입니다.</param>
      <param name="implementation" vsli:raw="The implementation entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, or &lt;see langword=&quot;null&quot; /&gt;.">구현 엔터티 핸들이며 <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> 또는 <see langword="null" /> 중 하나일 수 있습니다.</param>
      <param name="offset" vsli:raw="Specifies the byte offset within the referenced file at which this resource record begins.">이 리소스 레코드가 시작되는 참조된 파일 내의 바이트 오프셋을 지정합니다.</param>
      <returns vsli:raw="A handle to the added manifest resource.">추가된 매니페스트 리소스에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMarshallingDescriptor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds marshalling information to a field or a parameter.">필드 또는 매개 변수에 마샬링 정보를 추가합니다.</summary>
      <param name="parent" vsli:raw="The parent entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;.">부모 엔터티 핸들이며 <see cref="T:System.Reflection.Metadata.ParameterHandle" /> 또는 <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> 중 하나일 수 있습니다.</param>
      <param name="descriptor" vsli:raw="The descriptor blob.">설명자 Blob입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMemberReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a MemberRef table row.">MemberRef 테이블 행을 추가합니다.</summary>
      <param name="parent" vsli:raw="The containing entity, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">포함하는 엔터티이며 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> 중 하나일 수 있습니다.</param>
      <param name="name" vsli:raw="The member name.">멤버 이름입니다.</param>
      <param name="signature" vsli:raw="The member signature.">멤버 시그니처입니다.</param>
      <returns vsli:raw="A handle to the added member reference.">추가된 멤버 참조에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDebugInformation(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds method debug information.">메서드 디버그 정보를 추가합니다.</summary>
      <param name="document" vsli:raw="The handle of a single document containing all sequence points of the method, or &lt;see langword=&quot;null&quot; /&gt; if the method doesn't have sequence points or spans multiple documents.">메서드의 모든 시퀀스 위치를 포함하는 단일 문서의 핸들이거나, 메서드에 시퀀스 위치가 없거나 메서드가 여러 문서에 걸쳐 있는 경우 <see langword="null" />입니다.</param>
      <param name="sequencePoints" vsli:raw="The sequence Points blob, or &lt;see langword=&quot;null&quot; /&gt; if the method doesn't have sequence points.">시퀀스 위치 Blob이거나, 메서드에 시퀀스 위치가 없는 경우 <see langword="null" />입니다.</param>
      <returns vsli:raw="A handle to the added method debug information.">추가된 메서드 디버그 정보에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDefinition(System.Reflection.MethodAttributes,System.Reflection.MethodImplAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Int32,System.Reflection.Metadata.ParameterHandle)">
      <summary vsli:raw="Adds a method definition.">메서드 정의를 추가합니다.</summary>
      <param name="attributes" vsli:raw="The method attributes.">메서드 특성입니다.</param>
      <param name="implAttributes" vsli:raw="The method implementation attributes.">메서드 구현 특성입니다.</param>
      <param name="name" vsli:raw="The method name.">메서드 이름입니다.</param>
      <param name="signature" vsli:raw="The method signature.">메서드 시그니처입니다.</param>
      <param name="bodyOffset" vsli:raw="Offset within the block in the PE image that stores method bodies (the IL stream), or -1 if the method doesn't have a body.">메서드 본문(IL 스트림)을 저장하는 PE 이미지의 블록 내 오프셋이거나, 메서드에 본문이 없는 경우 -1입니다.</param>
      <param name="parameterList" vsli:raw="If the method declares parameters in the Params table, set this to the handle of the first one. Otherwise, set this to the handle of the first parameter declared by the next method definition. If no parameters are declared in the module, &lt;see langword=&quot;System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(1)&quot; /&gt;.">메서드가 Params 테이블에 매개 변수를 선언하는 경우 이를 첫 번째 매개 변수의 핸들로 설정합니다. 그렇지 않으면 이를 다음 메서드 정의에 의해 선언된 첫 번째 매개 변수의 핸들로 설정합니다. 모듈에 선언된 매개 변수가 없으면 <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(1)" />입니다.</param>
      <returns vsli:raw="A handle to the added method definition.">추가된 메서드 정의에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Defines an implementation for a method declaration within a type.">형식 내의 메서드 선언에 대한 구현을 정의합니다.</summary>
      <param name="type" vsli:raw="The type definition.">형식 정의입니다.</param>
      <param name="methodBody" vsli:raw="The method body entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;.">메서드 본문 엔터티 핸들이며 <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /> 중 하나일 수 있습니다.</param>
      <param name="methodDeclaration" vsli:raw="The method declaration entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;.">메서드 선언 엔터티 핸들이며 <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /> 중 하나일 수 있습니다.</param>
      <returns vsli:raw="A handle to the added method implementation.">추가된 메서드 구현에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImport(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.MethodImportAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <summary vsli:raw="Adds import information to a method definition.">메서드 정의에 가져오기 정보를 추가합니다.</summary>
      <param name="method" vsli:raw="The method definition handle.">메서드 정의 핸들입니다.</param>
      <param name="attributes" vsli:raw="The method import attributes.">메서드 가져오기 특성입니다.</param>
      <param name="name" vsli:raw="The unmanaged method name.">관리되지 않는 메서드 이름입니다.</param>
      <param name="module" vsli:raw="The module containing the unmanaged method.">관리되지 않는 메서드를 포함하는 모듈입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSemantics(System.Reflection.Metadata.EntityHandle,System.Reflection.MethodSemanticsAttributes,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary vsli:raw="Associates a method (a getter, a setter, an adder, etc.) with a property or an event.">메서드(getter, setter, adder 등)를 속성 또는 이벤트와 연결합니다.</summary>
      <param name="association" vsli:raw="The association entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;.">연결 엔터티 핸들이며 <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" /> 중 하나일 수 있습니다.</param>
      <param name="semantics" vsli:raw="The method semantics attributes.">메서드 의미 체계 특성입니다.</param>
      <param name="methodDefinition" vsli:raw="The method definition.">메서드 정의입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSpecification(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a method specification (an instantiation).">메서드 사양(인스턴스화)을 추가합니다.</summary>
      <param name="method" vsli:raw="The generic method entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;.">제네릭 메서드 엔터티 핸들이며 <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /> 중 하나일 수 있습니다.</param>
      <param name="instantiation" vsli:raw="The instantiation blob encoding the generic arguments of the method.">메서드의 제네릭 인수를 인코딩하는 인스턴스화 Blob입니다.</param>
      <returns vsli:raw="A handle to the added method specification.">추가된 메서드 사양에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModule(System.Int32,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="generation" vsli:raw="" />
      <param name="moduleName" vsli:raw="" />
      <param name="mvid" vsli:raw="" />
      <param name="encId" vsli:raw="" />
      <param name="encBaseId" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModuleReference(System.Reflection.Metadata.StringHandle)">
      <param name="moduleName" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddNestedType(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <summary vsli:raw="Defines a nesting relationship to specified type definitions.">지정된 형식 정의에 대한 중첩 관계를 정의합니다.</summary>
      <param name="type" vsli:raw="The nested type definition handle.">중첩 형식 정의 핸들입니다.</param>
      <param name="enclosingType" vsli:raw="The enclosing type definition handle.">바깥쪽 형식 정의 핸들입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddParameter(System.Reflection.ParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary vsli:raw="Adds a parameter definition.">매개 변수 정의를 추가합니다.</summary>
      <param name="attributes" vsli:raw="The parameter attributes.">매개 변수 특성입니다.</param>
      <param name="name" vsli:raw="Optional. The parameter name.">선택 사항입니다. 매개 변수 이름입니다.</param>
      <param name="sequenceNumber" vsli:raw="The sequence number of the parameter. A value of 0 refers to the owner method's return type; its parameters are then numbered from 1 onward.">매개 변수의 시퀀스 번호입니다. 값 0은 소유자 메서드의 반환 형식을 나타냅니다. 해당 매개 변수의 번호는 1부터 시작합니다.</param>
      <returns vsli:raw="A handle to the added parameter.">추가된 매개 변수에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddProperty(System.Reflection.PropertyAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a property definition.">속성 정의를 추가합니다.</summary>
      <param name="attributes" vsli:raw="The property attributes.">속성 특성입니다.</param>
      <param name="name" vsli:raw="The property name.">속성 이름입니다.</param>
      <param name="signature" vsli:raw="The signature of the property.">속성의 시그니처입니다.</param>
      <returns vsli:raw="A handle to the added property definition.">추가된 속성 정의에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddPropertyMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="declaringType" vsli:raw="" />
      <param name="propertyList" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStandaloneSignature(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStateMachineMethod(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary vsli:raw="Adds state machine method debug information.">상태 시스템 메서드 디버그 정보를 추가합니다.</summary>
      <param name="moveNextMethod" vsli:raw="The handle of the &lt;see langword=&quot;MoveNext&quot; /&gt; method of the state machine (the compiler-generated method).">상태 시스템 <see langword="MoveNext" /> 메서드(컴파일러 생성 메서드)의 핸들입니다.</param>
      <param name="kickoffMethod" vsli:raw="The handle of the kickoff method (the user defined iterator/async method).">킥오프 메서드(사용자 정의 반복기/비동기 메서드)의 핸들입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeDefinition(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary vsli:raw="Adds a type definition.">형식 정의를 추가합니다.</summary>
      <param name="attributes" vsli:raw="The type attributes.">형식 특성입니다.</param>
      <param name="namespace" vsli:raw="The type namespace.">형식 네임스페이스입니다.</param>
      <param name="name" vsli:raw="The type name.">형식 이름입니다.</param>
      <param name="baseType" vsli:raw="The base type entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, or &lt;see langword=&quot;null&quot; /&gt;.">기본 형식 엔터티 핸들이며 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> 또는 <see langword="null" /> 중 하나일 수 있습니다.</param>
      <param name="fieldList" vsli:raw="If the type declares fields, set this to the handle of the first one. Otherwise, set this to the handle of the first field declared by the next type definition. If no type defines any fields in the module, &lt;see langword=&quot;System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(1)&quot; /&gt;.">형식이 필드를 선언하는 경우 이를 첫 번째 필드의 핸들로 설정합니다. 그렇지 않으면 이를 다음 형식 정의에 의해 선언된 첫 번째 필드의 핸들로 설정합니다. 모듈에 필드를 정의하는 형식이 없으면 <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(1)" />입니다.</param>
      <param name="methodList" vsli:raw="If the type declares methods, the handle of the first one. Otherwise, the handle of the first method declared by the next type definition. If no type defines any methods in the module, &lt;see langword=&quot;System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(1)&quot; /&gt;.">형식이 메서드를 선언하는 경우 첫 번째 메서드의 핸들입니다. 그렇지 않으면 다음 형식 정의에 의해 선언된 첫 번째 메서드의 핸들입니다. 모듈에 메서드를 정의하는 형식이 없으면 <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(1)" />입니다.</param>
      <returns vsli:raw="A handle to the added type definition.">추가된 형식 정의에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeLayout(System.Reflection.Metadata.TypeDefinitionHandle,System.UInt16,System.UInt32)">
      <summary vsli:raw="Defines a type layout of a type definition.">형식 정의의 형식 레이아웃을 정의합니다.</summary>
      <param name="type" vsli:raw="The type definition.">형식 정의입니다.</param>
      <param name="packingSize" vsli:raw="Specifies that fields should be placed within the type instance at byte addresses which are a multiple of &lt;paramref name=&quot;packingSize&quot; /&gt;, or at natural alignment for that field type, whichever is smaller. Its value should be one of the following: 0, 1, 2, 4, 8, 16, 32, 64, or 128. A value of zero indicates that the packing size used should match the default for the current platform.">필드가 형식 인스턴스 내 바이트 주소(<paramref name="packingSize" />의 배수와 해당 필드 형식의 일반 맞춤 중 더 작은 값)에 배치되도록 지정합니다. 값은 0, 1, 2, 4, 8, 16, 32, 64 또는 128 중 하나여야 합니다. 값이 0이면 사용된 압축 크기가 현재 플랫폼의 기본값과 일치해야 함을 나타냅니다.</param>
      <param name="size" vsli:raw="Indicates a minimum size of the type instance and is intended to allow for padding. The amount of memory allocated is the maximum of the size calculated from the layout and &lt;paramref name=&quot;size&quot; /&gt;. Note that if this directive applies to a value type, then the size will be less than 1 MB.">형식 인스턴스의 최소 크기를 나타내며 패딩을 허용하기 위한 것입니다. 할당된 메모리의 양은 레이아웃과 <paramref name="size" />에서 계산된 크기의 최댓값입니다. 이 지시문이 값 형식에 적용되는 경우 크기는 1MB보다 작습니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <summary vsli:raw="Adds a type reference.">형식 참조를 추가합니다.</summary>
      <param name="resolutionScope" vsli:raw="The entity declaring the target type, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, or &lt;see langword=&quot;null&quot; /&gt;.">대상 형식을 선언하는 엔터티이며 <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 또는 <see langword="null" /> 중 하나일 수 있습니다.</param>
      <param name="namespace" vsli:raw="The type reference namespace.">형식 참조 네임스페이스입니다.</param>
      <param name="name" vsli:raw="The type reference name.">형식 참조 이름입니다.</param>
      <returns vsli:raw="A handle to the added type reference.">추가된 형식 참조에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeSpecification(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Byte[])">
      <summary vsli:raw="Adds the specified blob to the Blob heap, if it's not there already.">Blob 힙에 지정된 Blob을 추가합니다(아직 없는 경우).</summary>
      <param name="value" vsli:raw="The array containing the blob.">Blob을 포함하는 배열입니다.</param>
      <returns vsli:raw="A handle to the added or existing blob.">추가된 Blob 또는 기존 Blob에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Adds the specified blob from a byte array to the Blob heap, if it's not there already.">Blob 힙에 바이트 배열의 지정된 Blob을 추가합니다(아직 없는 경우).</summary>
      <param name="value" vsli:raw="The array containing the blob.">Blob을 포함하는 배열입니다.</param>
      <returns vsli:raw="A handle to the added or existing blob.">추가된 Blob 또는 기존 Blob에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Reflection.Metadata.BlobBuilder)">
      <summary vsli:raw="Adds the specified blob from an immutable byte array to the Blob heap, if it's not there already.">Blob 힙에 변경이 불가능한 바이트 배열의 지정된 Blob을 추가합니다(아직 없는 경우).</summary>
      <param name="value" vsli:raw="The blob builder instance containing the blob.">Blob을 포함하는 Blob 작성기 인스턴스입니다.</param>
      <returns vsli:raw="A handle to the added or existing blob.">추가된 Blob 또는 기존 Blob에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF16(System.String)">
      <summary vsli:raw="Encodes a string using UTF16 encoding to a blob and adds it to the Blob heap, if it's not there already.">UTF16 인코딩을 사용하여 문자열을 Blob으로 인코딩하고 Blob 힙에 추가합니다(아직 없는 경우).</summary>
      <param name="value" vsli:raw="The string to add.">추가할 문자열입니다.</param>
      <returns vsli:raw="A handle to the added or existing blob.">추가된 Blob 또는 기존 Blob에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF8(System.String,System.Boolean)">
      <summary vsli:raw="Encodes a string using UTF8 encoding to a blob and adds it to the Blob heap, if it's not there already.">UTF8 인코딩을 사용하여 문자열을 Blob으로 인코딩하고 Blob 힙에 추가합니다(아직 없는 경우).</summary>
      <param name="value" vsli:raw="The value to add.">추가할 값입니다.</param>
      <param name="allowUnpairedSurrogates" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode the unpaired surrogates as specified; &lt;see langword=&quot;false&quot; /&gt; to replace them with the U+FFFD character.">
        <see langword="true" />이면 쌍을 이루지 않는 서로게이트를 지정된 대로 인코딩하고, <see langword="false" />이면 해당 서로게이트를 U+FFFD 문자로 바꿉니다.</param>
      <returns vsli:raw="A handle to the added or existing blob.">추가된 Blob 또는 기존 Blob에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddConstantBlob(System.Object)">
      <summary vsli:raw="Encodes a constant value to a blob and adds it to the Blob heap, if it's not there already. Uses UTF16 to encode string constants.">상수 값을 Blob으로 인코딩하고 Blob 힙에 추가합니다(아직 없는 경우). UTF16을 사용하여 문자열 상수를 인코딩합니다.</summary>
      <param name="value" vsli:raw="The constant value to add.">추가할 상수 값입니다.</param>
      <returns vsli:raw="A handle to the added or existing blob.">추가된 Blob 또는 기존 Blob에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddDocumentName(System.String)">
      <summary vsli:raw="Encodes a debug document name and adds it to the Blob heap, if it's not there already.">디버그 문서 이름을 인코딩하고 Blob 힙에 추가합니다(아직 없는 경우).</summary>
      <param name="value" vsli:raw="The document name to add.">추가할 문서 이름입니다.</param>
      <returns vsli:raw="A handle to the added or existing document name blob.">추가된 문서 이름 Blob 또는 기존 문서 이름 Blob에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddGuid(System.Guid)">
      <summary vsli:raw="Adds the specified Guid to the Guid heap, if it's not there already.">GUID 힙에 지정된 GUID를 추가합니다(아직 없는 경우).</summary>
      <param name="guid" vsli:raw="The Guid to add.">추가할 GUID입니다.</param>
      <returns vsli:raw="A handle to the added or existing Guid.">추가된 GUID 또는 기존 GUID에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddString(System.String)">
      <summary vsli:raw="Adds the specified string to the string heap, if it's not there already.">문자열 힙에 지정된 문자열을 추가합니다(아직 없는 경우).</summary>
      <param name="value" vsli:raw="The string to add.">추가할 문자열입니다.</param>
      <returns vsli:raw="A handle to the added or existing string.">추가된 문자열 또는 기존 문자열에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddUserString(System.String)">
      <summary vsli:raw="Adds the specified string to the user string heap, if it's not there already.">사용자 문자열 힙에 지정된 문자열을 추가합니다(아직 없는 경우).</summary>
      <param name="value" vsli:raw="The string to add.">추가할 문자열입니다.</param>
      <returns vsli:raw="A handle to the added or existing string. This value may be used in &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)&quot; /&gt;.">추가된 문자열 또는 기존 문자열에 대한 핸들입니다. 이 값은 <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" />에서 사용할 수 있습니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCount(System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary vsli:raw="Returns the current number of items in the specified table.">지정된 테이블의 현재 항목 수를 반환합니다.</summary>
      <param name="table" vsli:raw="The table index.">테이블 인덱스입니다.</param>
      <returns vsli:raw="The number of items in the table.">테이블의 항목 수입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCounts">
      <summary vsli:raw="Returns the current number of items in each table.">각 테이블의 현재 항목 수를 반환합니다.</summary>
      <returns vsli:raw="An array of size &lt;see cref=&quot;F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount&quot; /&gt;, with each item filled with the current row count of the corresponding table.">
        <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" /> 크기의 배열이며, 각 항목은 해당 테이블의 현재 행 수로 채워집니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveGuid">
      <summary vsli:raw="Reserves space on the Guid heap for a GUID.">GUID 힙에 GUID를 위한 공간을 예약합니다.</summary>
      <returns vsli:raw="A handle to the reserved Guid and a &lt;see cref=&quot;T:System.Reflection.Metadata.Blob&quot; /&gt; representing the GUID blob as stored on the heap.">예약된 GUID 및 힙에 저장된 GUID Blob을 나타내는 <see cref="T:System.Reflection.Metadata.Blob" />에 대한 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveUserString(System.Int32)">
      <summary vsli:raw="Reserves space on the user string heap for a string of the specified length.">사용자 문자열 힙에 지정된 길이의 문자열을 위한 공간을 예약합니다.</summary>
      <param name="length" vsli:raw="The number of characters to reserve.">예약할 문자 수입니다.</param>
      <returns vsli:raw="A handle to the reserved user string and a &lt;see cref=&quot;T:System.Reflection.Metadata.Blob&quot; /&gt; representing the entire User String blob (including its length and terminal character). The handle may be used in &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)&quot; /&gt;.&#xA; Use &lt;see cref=&quot;M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)&quot; /&gt; to fill in the blob content.">예약된 사용자 문자열 및 전체 사용자 문자열 Blob(길이 및 터미널 문자 포함)을 나타내는 <see cref="T:System.Reflection.Metadata.Blob" />에 대한 핸들입니다. 이 핸들은 <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" />에서 사용할 수 있습니다.
<see cref="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)" />을 사용하여 Blob 콘텐츠를 채웁니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.HeapIndex,System.Int32)">
      <summary vsli:raw="Sets the capacity of the specified heap.">지정된 힙의 용량을 설정합니다.</summary>
      <param name="heap" vsli:raw="The heap index.">힙 인덱스입니다.</param>
      <param name="byteCount" vsli:raw="The number of bytes.">바이트 수입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary vsli:raw="Sets the capacity of the specified table.">지정된 테이블의 용량을 설정합니다.</summary>
      <param name="table" vsli:raw="The table index.">테이블 인덱스입니다.</param>
      <param name="rowCount" vsli:raw="The number of rows in the table.">표의 행 수입니다.</param>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions">
      <summary vsli:raw="Provides extension methods for working with certain raw elements of the ECMA-335 metadata tables and heaps.">ECMA-335 메타데이터 테이블 및 힙의 특정 원시 요소로 작업하도록 확장 메서드를 제공합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueLogEntries(System.Reflection.Metadata.MetadataReader)">
      <summary vsli:raw="Enumerates entries of EnC log.">EnC 로그의 항목을 열거합니다.</summary>
      <param name="reader" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueMapEntries(System.Reflection.Metadata.MetadataReader)">
      <summary vsli:raw="Enumerates entries of EnC map.">EnC 지도의 항목을 열거합니다.</summary>
      <param name="reader" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary vsli:raw="Returns the offset from the start of metadata to the specified heap.">메타데이터 시작에서 지정된 힙으로 오프셋을 반환합니다.</summary>
      <param name="reader" vsli:raw="" />
      <param name="heapIndex" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary vsli:raw="Returns the size of the specified heap.">지정된 힙의 크기를 반환합니다.</summary>
      <param name="reader" vsli:raw="" />
      <param name="heapIndex" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Returns the handle to the &lt;see cref=&quot;T:System.Reflection.Metadata.Blob&quot; /&gt; that follows the given one in the &lt;see cref=&quot;T:System.Reflection.Metadata.Blob&quot; /&gt; heap or a nil handle if it is the last one.">해당 항목이 마지막인 경우 nil 핸들 또는 <see cref="T:System.Reflection.Metadata.Blob" /> 힙의 지정된 항목 뒤에 오는 <see cref="T:System.Reflection.Metadata.Blob" />에 핸들을 반환합니다.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.StringHandle)">
      <summary vsli:raw="Returns the a handle to the string that follows the given one in the string heap, or a nil handle if it is the last one.">해당 항목이 마지막인 경우 nil 핸들 또는 문자열 힙의 지정된 항목 뒤에 오는 문자열에 핸들을 반환합니다.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.UserStringHandle)">
      <summary vsli:raw="Returns the a handle to the UserString that follows the given one in the UserString heap or a nil handle if it is the last one.">해당 항목이 마지막인 경우 nil 핸들 또는 UserString 힙의 지정된 항목 뒤에 오는 UserString에 핸들을 반환합니다.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary vsli:raw="Returns the offset from the start of metadata to the specified table.">메타데이터의 시작부터 지정된 테이블로 오프셋을 반환합니다.</summary>
      <param name="reader" vsli:raw="" />
      <param name="tableIndex" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowCount(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary vsli:raw="Returns the number of rows in the specified table.">지정된 테이블의 행 수를 반환합니다.</summary>
      <param name="reader" vsli:raw="" />
      <param name="tableIndex" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary vsli:raw="Returns the size of a row in the specified table.">지정된 테이블의 행 크기를 반환합니다.</summary>
      <param name="reader" vsli:raw="" />
      <param name="tableIndex" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithEvents(System.Reflection.Metadata.MetadataReader)">
      <summary vsli:raw="Enumerate types that define one or more events.">하나 이상의 이벤트를 정의하는 형식을 열거합니다.</summary>
      <param name="reader" vsli:raw="" />
      <returns vsli:raw="The resulting sequence corresponds exactly to entries in EventMap table, i.e. n-th returned &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; is stored in n-th row of EventMap.">결과 시퀀스는 EventMap 테이블의 항목과 정확하게 일치합니다. 즉, n번째 반환된 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />은(는) EventMap의 n번째 행에 저장됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithProperties(System.Reflection.Metadata.MetadataReader)">
      <summary vsli:raw="Enumerate types that define one or more properties.">하나 이상의 속성을 정의하는 형식을 열거합니다.</summary>
      <param name="reader" vsli:raw="" />
      <returns vsli:raw="The resulting sequence corresponds exactly to entries in the property map table, that is, the n-th returned &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; is stored in n-th row of the property map.">결과 시퀀스는 속성 맵 테이블의 항목과 정확하게 일치합니다. 즉, n번째 반환된 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />은(는) 속성 맵의 n번째 행에 저장됩니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)">
      <summary vsli:raw="Given a type handle and a raw type kind found in a signature blob determines whether the target type is a value type or a reference type.">서명 BLOB에 있는 형식 핸들과 원시 형식 종류를 고려하여, 대상 형식이 값 형식 또는 참조 형식인지를 결정합니다.</summary>
      <param name="reader" vsli:raw="" />
      <param name="typeHandle" vsli:raw="" />
      <param name="rawTypeKind" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataRootBuilder">
      <summary vsli:raw="Builder of a Metadata Root to be embedded in a Portable Executable image.">이식 가능한 실행 가능 이미지에 포함된 메타데이터 루트의 작성기입니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.String,System.Boolean)">
      <summary vsli:raw="Creates a builder of a metadata root.">메타데이터 루트의 작성기를 만듭니다.</summary>
      <param name="tablesAndHeaps" vsli:raw="Builder populated with metadata entities stored in tables and values stored in heaps. The entities and values will be enumerated when serializing the metadata root.">테이블에 저장된 메타데이터 엔터티와 힙에 저장된 값이 들어간 작성기입니다. 메타데이터 루트를 직렬화할 때 엔터티와 값이 열거됩니다.</param>
      <param name="metadataVersion" vsli:raw="The version string written to the metadata header. The default value is &quot;v4.0.30319&quot;.">메타데이터 헤더에 쓰인 버전 문자열입니다. 기본 값은 "v4.0.30319"입니다.</param>
      <param name="suppressValidation" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to suppress basic validation of metadata tables during serialization; otherwise, &lt;paramref name=&quot;false&quot; /&gt;.">직렬화 중에 메타데이터 테이블의 기본 유효성 검사를 표시하지 않으려면 <see langword="true" />, 그렇지 않으면 <paramref name="false" />입니다.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.MetadataVersion">
      <summary vsli:raw="The metadata version.">메타데이터 버전입니다.</summary>
      <returns vsli:raw="A string that represents the metadata version.">메타 데이터 버전을 나타내는 문자열입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Int32,System.Int32)">
      <summary vsli:raw="Serializes metadata root content into the given &lt;see cref=&quot;T:System.Reflection.Metadata.BlobBuilder&quot; /&gt;.">메타데이터 루트 콘텐츠를 주어진 <see cref="T:System.Reflection.Metadata.BlobBuilder" />로 직렬화합니다.</summary>
      <param name="builder" vsli:raw="Builder to write to.">쓰기를 할 작성기입니다.</param>
      <param name="methodBodyStreamRva" vsli:raw="The relative virtual address of the start of the method body stream. Used to calculate the final value of RVA fields of MethodDef table.">메서드 본문 스트림 시작 지점의 상대 가상 주소입니다. MethodDef 테이블의 RVA 필드의 최종 값을 계산하는데 사용합니다.</param>
      <param name="mappedFieldDataStreamRva" vsli:raw="The relative virtual address of the start of the field init data stream. Used to calculate the final value of RVA fields of FieldRVA table.">필드 초기화 데이터 스트림 시작 지점의 상대 가상 주소입니다. FieldRVA 테이블의 RVA 필드의 최종 값을 계산하는데 사용합니다.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Sizes">
      <summary vsli:raw="Returns sizes of various metadata structures.">다양한 메타데이터 구조의 크기를 반환합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation">
      <summary vsli:raw="Determines if basic validation of metadata tables should be suppressed. The validation verifies that entries in the tables were added in order required by the ECMA specification. It does not enforce all specification requirements on metadata tables.">메타데이터 테이블의 기본 유효성 검사를 표시하지 않을 지 결정합니다. 유효성 검사는 테이블의 항목이 ECMA 사양이 요구하는 순서대로 추가되었는지 확인합니다. 모든 사양 요구 사항이 메타데이터 테이블에 적용되는 것은 아닙니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to suppress basic validation of metadata tables; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">메타 데이터 테이블의 기본 유효성 검사를 표시 하지 <see langword="true" /> 그렇지 않으면 <see langword="false" />합니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataSizes">
      <summary vsli:raw="Provides information on sizes of various metadata structures.">다양한 메타데이터 구조의 크기 정보를 제공합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.ExternalRowCounts">
      <summary vsli:raw="External table row count.">외부 테이블 행 개수입니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataSizes.GetAlignedHeapSize(System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary vsli:raw="Returns aligned size of the specified heap.">지정된 힙의 맞춤 크기를 반환합니다.</summary>
      <param name="index" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.HeapSizes">
      <summary vsli:raw="Exact (unaligned) heap sizes.">정확한 (맞추지 않은) 힙 사이즈.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.RowCounts">
      <summary vsli:raw="Table row counts.">테이블 행 개수</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataTokens" />
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyFileHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyReferenceHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.BlobHandle(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ConstantHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomAttributeHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomDebugInformationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DeclarativeSecurityAttributeHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentNameBlobHandle(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Int32)">
      <summary vsli:raw="Creates an entity handle from a token value.">토큰 값에서 엔터티 핸들을 만듭니다.</summary>
      <param name="token" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; from a token value.">토큰 값에서 <see cref="T:System.Reflection.Metadata.EntityHandle" />을(를) 만듭니다.</summary>
      <param name="tableIndex" vsli:raw="" />
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EventDefinitionHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ExportedTypeHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterConstraintHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">지정된 <paramref name="handle" />에 해당하는 메타데이터 힙 데이터의 오프셋을 가져옵니다.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Zero based offset, or -1 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.MetadataBuilder&quot; /&gt;.">
        <paramref name="handle" />이(가) 특정한 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 또는 <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" />의 컨텍스트에서만 해석될 경우, 0으로 시작하는 오프셋 혹은 -1입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.GuidHandle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">지정된 <paramref name="handle" />에 해당하는 메타데이터 힙 데이터의 오프셋을 가져옵니다.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="1-based index into the #Guid heap. Unlike other heaps, which are essentially byte arrays, the #Guid heap is an array of 16-byte GUIDs.">#Guid 힙에 대한 1부터 시작하는 인덱스입니다. 기본적으로 바이트 배열인 다른 힙과 달리 #Guid 힙은 16바이트 GUID 배열입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">지정된 <paramref name="handle" />에 해당하는 메타데이터 힙 데이터의 오프셋을 가져옵니다.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="An offset in the corresponding heap, or -1 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.MetadataBuilder&quot; /&gt;.">
        <paramref name="handle" />이(가) 특정한 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 또는 <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" />의 컨텍스트에서만 해석될 경우, 힙에 해당하는 오프셋 혹은 -1입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt; in the context of &lt;paramref name=&quot;reader&quot; /&gt;.">
        <paramref name="reader" />의 컨텍스트에서 지정된 <paramref name="handle" />에 해당하는 메타데이터 힙 데이터의 오프셋을 가져옵니다.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Zero based offset, or -1 if &lt;paramref name=&quot;handle&quot; /&gt; isn't a metadata heap handle.">
        <paramref name="handle" />이 메타데이터 힙 핸들이 아닐 경우, 0으로 시작하는 오프셋 혹은 -1입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.StringHandle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">지정된 <paramref name="handle" />에 해당하는 메타데이터 힙 데이터의 오프셋을 가져옵니다.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Zero-based offset, or -1 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.MetadataBuilder&quot; /&gt;.">
        <paramref name="handle" />이(가) 특정한 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 또는 <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" />의 컨텍스트에서만 해석될 경우, 0으로 시작하는 오프셋 혹은 -1입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.UserStringHandle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">지정된 <paramref name="handle" />에 해당하는 메타데이터 힙 데이터의 오프셋을 가져옵니다.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Zero-based offset.">0으로 시작하는 오프셋입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Gets the row number of a metadata table entry that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">지정된 <paramref name="handle" />에 해당하는 메타데이터 테이블 항목의 행 번호를 가져옵니다.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="One based row number, or -1 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt;.&#xA; See &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)&quot; /&gt;.">
        <paramref name="handle" />이(가) 특정한 <see cref="T:System.Reflection.Metadata.MetadataReader" />의 컨텍스트에서만 해석될 경우, 1부터 시작하는 행 번호 혹은 -1입니다.
<see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)" />을 참조하세요.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Gets the row number of a metadata table entry that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt; in the context of &lt;paramref name=&quot;reader&quot; /&gt;.">
        <paramref name="reader" />의 컨텍스트에서 지정된 <paramref name="handle" />에 해당하는 메타데이터 테이블 항목의 행 번호를 가져옵니다.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="One based row number.">1부터 시작하는 행 번호입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Gets the metadata token of the specified &lt;paramref name=&quot;handle&quot; /&gt;.">지정된 <paramref name="handle" />의 메타데이터 토큰을 가져옵니다.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Metadata token, or 0 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt;.">
        <paramref name="handle" />이(가) 특정한 <see cref="T:System.Reflection.Metadata.MetadataReader" />의 컨텍스트에서만 해석될 경우, 메타데이터 토큰 혹은 0입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Gets the metadata token of the specified &lt;paramref name=&quot;handle&quot; /&gt;.">지정된 <paramref name="handle" />의 메타데이터 토큰을 가져옵니다.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Metadata token, or 0 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt;.">
        <paramref name="handle" />이(가) 특정한 <see cref="T:System.Reflection.Metadata.MetadataReader" />의 컨텍스트에서만 해석될 경우, 메타데이터 토큰 혹은 0입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Gets the metadata token of the specified &lt;paramref name=&quot;handle&quot; /&gt; in the context of &lt;paramref name=&quot;reader&quot; /&gt;.">
        <paramref name="reader" />의 컨텍스트에서 지정된 <paramref name="handle" />의 메타데이터 토큰을 가져옵니다.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Metadata token.">메타데이터 토큰입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Gets the metadata token of the specified &lt;paramref name=&quot;handle&quot; /&gt; in the context of &lt;paramref name=&quot;reader&quot; /&gt;.">
        <paramref name="reader" />의 컨텍스트에서 지정된 <paramref name="handle" />의 메타데이터 토큰을 가져옵니다.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Metadata token.">메타데이터 토큰입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GuidHandle(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Int32)">
      <summary vsli:raw="Creates a handle from a token value.">토큰 값에서 핸들을 만듭니다.</summary>
      <param name="token" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; from a token value.">토큰 값에서 <see cref="T:System.Reflection.Metadata.EntityHandle" />을(를) 만듭니다.</summary>
      <param name="tableIndex" vsli:raw="" />
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.HeapCount">
      <summary vsli:raw="Maximum number of tables that can be present in Ecma335 metadata.">Ecma335 메타데이터에 있을 수 있는 최대 테이블 수입니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ImportScopeHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.InterfaceImplementationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalScopeHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ManifestResourceHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MemberReferenceHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDebugInformationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodImplementationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodSpecificationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ModuleReferenceHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.PropertyDefinitionHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StandaloneSignatureHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StringHandle(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount">
      <summary vsli:raw="Maximum number of tables that can be present in Ecma335 metadata.">Ecma335 메타데이터에 있을 수 있는 최대 테이블 수입니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetHeapIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.HeapIndex@)">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.HeapIndex&quot; /&gt; of the heap corresponding to the specified &lt;see cref=&quot;T:System.Reflection.Metadata.HandleKind&quot; /&gt;.">지정된 <see cref="T:System.Reflection.Metadata.HandleKind" />에 해당하는 힙의 <see cref="T:System.Reflection.Metadata.Ecma335.HeapIndex" />을(를) 가져옵니다.</summary>
      <param name="type" vsli:raw="Handle type.">핸들 형식입니다.</param>
      <param name="index" vsli:raw="Heap index.">힙 인덱스입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the handle type corresponds to an Ecma335 heap; &lt;see langword=&quot;false&quot; /&gt; otherwise.">핸들 형식이 Ecma335 힙에 해당하는 경우 <see langword="true" />이며, 그렇지 않은 경우 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetTableIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.TableIndex@)">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.TableIndex&quot; /&gt; of the table corresponding to the specified &lt;see cref=&quot;T:System.Reflection.Metadata.HandleKind&quot; /&gt;.">지정된 <see cref="T:System.Reflection.Metadata.HandleKind" />에 해당하는 테이블의 <see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" />을(를) 가져옵니다.</summary>
      <param name="type" vsli:raw="Handle type.">핸들 형식입니다.</param>
      <param name="index" vsli:raw="Table index.">테이블 인덱스입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the handle type corresponds to an Ecma335 or Portable PDB table; &lt;see langword=&quot;false&quot; /&gt; otherwise.">핸들 형식이 Ecma335이나 이식 가능 PDB 테이블에 해당하는 경우 <see langword="true" />이며, 그렇지 않은 경우 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeDefinitionHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeReferenceHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeSpecificationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.UserStringHandle(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyAttributes">
      <summary vsli:raw="Defines method body attributes.">메서드 본문 특성을 정의합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.InitLocals">
      <summary vsli:raw="Initializes any locals the method defines to zero and dynamically allocates local memory.">로컬 메모리를 비우고 동적으로 할당하려면 메서드가 정의하는 로컬 항목을 초기화합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.None">
      <summary vsli:raw="Performs no local memory initialization.">로컬 메모리 초기화를 수행하지 않습니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder">
      <summary vsli:raw="Provides an encoder for a method body stream.">메서드 본문 스트림에 인코더를 제공합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary vsli:raw="Encodes a method body and adds it to the method body stream, using the provided code size, maximum stack size, number of exception regions, local variables' signature handle, method body attributes and allowing to indicate whether the exception regions should be encoded in small format or not.">메서드 본문을 인코딩하고 제공된 코드 크기, 최대 스택 크기, 예외 영역의 수, 지역 변수의 시그니처 핸들, 메서드 본문 특성을 사용하여 메서드 본문 스트림에 추가하고 예외 영역을 작은 형식으로 인코딩할지 여부를 나타낼 수 있습니다.</summary>
      <param name="codeSize" vsli:raw="The number of bytes to be reserved for instructions.">명령에 예약될 바이트 수입니다.</param>
      <param name="maxStack" vsli:raw="The maximum stack size.">최대 스택 크기입니다.</param>
      <param name="exceptionRegionCount" vsli:raw="The number of exception regions.">예외 영역의 수입니다.</param>
      <param name="hasSmallExceptionRegions" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the exception regions should be encoded in small format; &lt;see langword=&quot;false&quot; /&gt; otherwise.">예외 영역을 작은 형식으로 인코딩해야 하는 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
      <param name="localVariablesSignature" vsli:raw="The local variables' signature handle.">지역 변수의 시그니처 핸들입니다.</param>
      <param name="attributes" vsli:raw="The method body attributes.">메서드 본문 특성입니다.</param>
      <returns vsli:raw="The offset of the encoded body within the method body stream.">메서드 본문 스트림 내에서 인코딩된 본문의 오프셋입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary vsli:raw="Encodes a method body and adds it to the method body stream, using the provided code size, maximum stack size, number of exception regions, local variables' signature handle, method body attributes, allowing to indicate whether the exception regions should be encoded in small format or not, and allowing to indicate whether the method should allocate from the dynamic local memory pool or not.">메서드 본문을 인코딩하고 제공된 코드 크기, 최대 스택 크기, 예외 영역의 수, 지역 변수의 시그니처 핸들, 메서드 본문 특성을 사용하여 메서드 본문 스트림에 추가하고 예외 영역을 작은 형식으로 인코딩할지 여부를 나타내고, 메서드를 동적 로컬 메모리 풀에서 할당할지 여부를 나타낼 수 있습니다.</summary>
      <param name="codeSize" vsli:raw="The number of bytes to be reserved for instructions.">명령에 예약될 바이트 수입니다.</param>
      <param name="maxStack" vsli:raw="The maximum stack size.">최대 스택 크기입니다.</param>
      <param name="exceptionRegionCount" vsli:raw="The number of exception regions.">예외 영역의 수입니다.</param>
      <param name="hasSmallExceptionRegions" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the exception regions should be encoded in small format; &lt;see langword=&quot;false&quot; /&gt; otherwise.">예외 영역을 작은 형식으로 인코딩해야 하는 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
      <param name="localVariablesSignature" vsli:raw="The local variables' signature handle.">지역 변수의 시그니처 핸들입니다.</param>
      <param name="attributes" vsli:raw="The method body attributes.">메서드 본문 특성입니다.</param>
      <param name="hasDynamicStackAllocation" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method allocates from the dynamic local memory pool (the &lt;see langword=&quot;localloc&quot; /&gt; instruction); &lt;see langword=&quot;false&quot; /&gt; otherwise.">메서드가 동적 로컬 메모리 풀에서 할당되는 경우(<see langword="true" /> 명령) <see langword="localloc" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
      <returns vsli:raw="The offset of the encoded body within the method body stream.">메서드 본문 스트림 내에서 인코딩된 본문의 오프셋입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary vsli:raw="Encodes a method body and adds it to the method body stream.">메서드 본문을 인코딩하여 메서드 본문 스트림에 추가합니다.</summary>
      <param name="instructionEncoder" vsli:raw="The instruction encoder.">명령 인코더입니다.</param>
      <param name="maxStack" vsli:raw="The maximum stack size.">최대 스택 크기입니다.</param>
      <param name="localVariablesSignature" vsli:raw="The local variables' signature handle.">지역 변수의 시그니처 핸들입니다.</param>
      <param name="attributes" vsli:raw="The method body attributes.">메서드 본문 특성입니다.</param>
      <returns vsli:raw="The offset of the encoded body within the method body stream.">메서드 본문 스트림 내에서 인코딩된 본문의 오프셋입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary vsli:raw="Encodes a method body and adds it to the method body stream, using the provided instruction encoder, maximum stack size, local variables' signature handle, method body attributes, and allowing to indicate whether the method should allocate from the dynamic local memory pool or not.">메서드 본문을 인코딩하고 제공된 명령 인코더, 최대 스택 크기, 지역 변수의 시그니처 핸들, 메서드 본문 특성을 사용하여 메서드 본문 스트림에 추가하고 메서드를 동적 로컬 메모리 풀에서 할당할지 여부를 나타낼 수 있습니다.</summary>
      <param name="instructionEncoder" vsli:raw="The instruction encoder.">명령 인코더입니다.</param>
      <param name="maxStack" vsli:raw="The maximum stack size.">최대 스택 크기입니다.</param>
      <param name="localVariablesSignature" vsli:raw="The local variables' signature handle.">지역 변수의 시그니처 핸들입니다.</param>
      <param name="attributes" vsli:raw="The method body attributes.">메서드 본문 특성입니다.</param>
      <param name="hasDynamicStackAllocation" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method allocates from the dynamic local memory pool (the IL contains the &lt;see langword=&quot;localloc&quot; /&gt; instruction); &lt;see langword=&quot;false&quot; /&gt; otherwise.">메서드가 동적 로컬 메모리 풀에서 할당되는 경우(IL에 <see langword="true" /> 명령이 포함된 경우) <see langword="localloc" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
      <returns vsli:raw="The offset of the encoded body within the method body stream.">메서드 본문 스트림 내에서 인코딩된 본문의 오프셋입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody">
      <summary vsli:raw="Describes a method body. This class is meant to used along with the &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder&quot; /&gt; class.">메서드 본문을 설명합니다. 이 클래스는 <see cref="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder" /> 클래스와 함께 사용하기 위한 것입니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.ExceptionRegions">
      <summary vsli:raw="Gets an encoder object that can be used to encode exception regions to the method body.">예외 영역을 메서드 본문으로 인코딩하는 데 사용할 수 있는 인코더 개체를 가져옵니다.</summary>
      <returns vsli:raw="An exception region encoder instance.">예외 영역 인코더 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Instructions">
      <summary vsli:raw="Gets a blob reserved for instructions.">명령에 예약된 blob을 가져옵니다.</summary>
      <returns vsli:raw="A blob reserved for instructions.">지침을 위해 예약 된 blob입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Offset">
      <summary vsli:raw="Gets the offset of the encoded method body in the method body stream.">메서드 본문 스트림에 인코딩된 메서드 본문의 오프셋을 가져옵니다.</summary>
      <returns vsli:raw="The offset of the encoded method body in the method body stream.">메서드 본문 스트림에 인코딩된 메서드 본문의 오프셋입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder">
      <summary vsli:raw="Provides an encoder for method signatures.">메서드 시그니처에 인코더를 제공합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" vsli:raw="" />
      <param name="hasVarArgs" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.HasVarArgs" />
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Action{System.Reflection.Metadata.Ecma335.ReturnTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ParametersEncoder})">
      <summary vsli:raw="Encodes the provided return type and parameters.">제공된 반환 형식 및 매개 변수를 인코딩합니다.</summary>
      <param name="parameterCount" vsli:raw="The number of parameters.">매개 변수 수입니다.</param>
      <param name="returnType" vsli:raw="The method that is called first to encode the return type.">반환 형식을 인코딩하기 위해 맨 먼저 호출되는 메서드입니다.</param>
      <param name="parameters" vsli:raw="The method that is called second to encode the parameters.">매개 변수를 인코딩하기 위해 두 번째 호출되는 메서드입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Reflection.Metadata.Ecma335.ReturnTypeEncoder@,System.Reflection.Metadata.Ecma335.ParametersEncoder@)">
      <summary vsli:raw="Encodes the provided return type and parameters, which must be used in the order they appear in the parameter list.">매개 변수 목록에 나타나는 순서대로 사용해야 하는 제공된 반환 형식 및 매개 변수를 인코딩합니다.</summary>
      <param name="parameterCount" vsli:raw="The number of parameters.">매개 변수 수입니다.</param>
      <param name="returnType" vsli:raw="The method that is called first to encode the return types.">반환 형식을 인코딩하기 위해 맨 먼저 호출되는 메서드입니다.</param>
      <param name="parameters" vsli:raw="The method that is called second to encode the parameters.">매개 변수를 인코딩하기 위해 두 번째 호출되는 메서드입니다.</param>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder&quot; /&gt; structure.">
        <see cref="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
      <param name="builder" vsli:raw="A builder for encoding the named argument.">명명된 인수를 인코딩하는 데 사용되는 작성기입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Action{System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.NameEncoder},System.Action{System.Reflection.Metadata.Ecma335.LiteralEncoder})">
      <summary vsli:raw="Encodes a named argument (a field or property).">명명된 인수(필드 또는 속성)를 인코딩합니다.</summary>
      <param name="isField" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode a field, &lt;see langword=&quot;false&quot; /&gt; to encode a property.">필드를 인코딩하려면 <see langword="true" />이고, 속성을 인코딩하려면 <see langword="false" />입니다.</param>
      <param name="type" vsli:raw="The method to call first to encode the type of the argument.">인수 형식을 인코딩하기 위해 가장 먼저 호출할 메서드입니다.</param>
      <param name="name" vsli:raw="The method to call second to encode the name of the field or property.">필드 또는 속성의 이름을 인코딩하기 위해 두 번째 호출할 메서드입니다.</param>
      <param name="literal" vsli:raw="The method to call third to encode the literal value of the argument.">인수의 리터럴 값을 인코딩하기 위해 세 번째 호출할 메서드입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder@,System.Reflection.Metadata.Ecma335.NameEncoder@,System.Reflection.Metadata.Ecma335.LiteralEncoder@)">
      <summary vsli:raw="Encodes a named argument (a field or property) and returns three encoders that must be used in the order they appear in the parameter list.">명명된 인수(필드 또는 속성)를 인코딩하고 매개 변수 목록에 나타나는 순서대로 사용되어야 하는 세 인코더를 반환합니다.</summary>
      <param name="isField" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode a field, &lt;see langword=&quot;false&quot; /&gt; to encode a property.">필드를 인코딩하려면 <see langword="true" />이고, 속성을 인코딩하려면 <see langword="false" />입니다.</param>
      <param name="type" vsli:raw="The method to call first to encode the type of the argument.">인수 형식을 인코딩하기 위해 가장 먼저 호출할 메서드입니다.</param>
      <param name="name" vsli:raw="The method to call second to encode the name of the field or property.">필드 또는 속성의 이름을 인코딩하기 위해 두 번째 호출할 메서드입니다.</param>
      <param name="literal" vsli:raw="The method to call third to encode the literal value of the argument.">인수의 리터럴 값을 인코딩하기 위해 세 번째 호출할 메서드입니다.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.ScalarType" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.SZArray" />
    <member name="T:System.Reflection.Metadata.Ecma335.NameEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NameEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.Name(System.String)">
      <param name="name" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ParametersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" vsli:raw="" />
      <param name="hasVarArgs" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.AddParameter" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.HasVarArgs" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.StartVarArgs" />
    <member name="T:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.TypedReference" />
    <member name="T:System.Reflection.Metadata.Ecma335.PermissionSetEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="typeName" vsli:raw="" />
      <param name="encodedArguments" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Reflection.Metadata.BlobBuilder)">
      <param name="typeName" vsli:raw="" />
      <param name="encodedArguments" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.PortablePdbBuilder">
      <summary vsli:raw="Represents the builder of a Portable PDB image.">이식 가능한 PDB 이미지의 작성기를 나타냅니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.Collections.Immutable.ImmutableArray{System.Int32},System.Reflection.Metadata.MethodDefinitionHandle,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <summary vsli:raw="Creates a builder of a Portable PDB image.">이식 가능한 PDB 이미지의 작성기를 만듭니다.</summary>
      <param name="tablesAndHeaps" vsli:raw="A builder populated with debug metadata entities stored in tables and values stored in heaps. The entities and values are enumerated when serializing the Portable PDB image.">테이블에 저장된 디버그 메타데이터 엔터티와 힙에 저장된 값으로 채워진 작성기입니다. 이식 가능한 PDB 이미지를 직렬화할 때 엔터티와 값이 열거됩니다.</param>
      <param name="typeSystemRowCounts" vsli:raw="The row counts of all tables that the associated type system metadata contain. Each slot in the array corresponds to a table (&lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.TableIndex&quot; /&gt;). The length of the array must be equal &lt;see cref=&quot;F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount&quot; /&gt;.">연결된 형식 시스템 메타데이터에 포함된 모든 테이블의 행 수입니다. 배열의 각 슬롯은 테이블(<see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" />)에 해당합니다. 배열의 길이는 <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" />와(과) 동일해야 합니다.</param>
      <param name="entryPoint" vsli:raw="An entry point method definition handle.">진입점 메서드 정의 핸들입니다.</param>
      <param name="idProvider" vsli:raw="A function that calculates the ID of content represented as a sequence of blobs. If not specified, a default function that ignores the content and returns a content ID based on the current time is used (&lt;see cref=&quot;M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider&quot; /&gt;). You must specify a deterministic function to produce a deterministic Portable PDB image.">Blob 시퀀스로 표시되는 콘텐츠의 ID를 계산하는 함수입니다. 지정하지 않으면 콘텐츠를 무시하고 현재 시간을 기준으로 콘텐츠 ID를 반환하는 기본 함수가 사용됩니다(<see cref="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />). 결정적 이식 가능 PDB 이미지를 생성하려면 결정 함수를 지정해야 합니다.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.FormatVersion" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.IdProvider" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.MetadataVersion" />
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <summary vsli:raw="Serializes portable PDB content into the given &lt;see cref=&quot;T:System.Reflection.Metadata.BlobBuilder&quot; /&gt;.">이식 가능한 PDB 콘텐츠를 지정된 <see cref="T:System.Reflection.Metadata.BlobBuilder" />(으)로 직렬화합니다.</summary>
      <param name="builder" vsli:raw="The builder to write to.">쓸 작성기입니다.</param>
      <returns vsli:raw="The ID of the serialized content.">직렬화된 콘텐츠의 ID입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.TypedReference" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Void" />
    <member name="T:System.Reflection.Metadata.Ecma335.ScalarEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ScalarEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.Constant(System.Object)">
      <summary vsli:raw="Encodes a constant literal.">상수 리터럴을 인코딩합니다.</summary>
      <param name="value" vsli:raw="A constant of type &lt;see cref=&quot;T:System.Boolean&quot; /&gt;, &lt;see cref=&quot;T:System.Byte&quot; /&gt;, &lt;see cref=&quot;T:System.SByte&quot; /&gt;, &lt;see cref=&quot;T:System.Int16&quot; /&gt;, &lt;see cref=&quot;T:System.UInt16&quot; /&gt;, &lt;see cref=&quot;T:System.Int32&quot; /&gt;, &lt;see cref=&quot;T:System.UInt32&quot; /&gt;, &lt;see cref=&quot;T:System.Int64&quot; /&gt;, &lt;see cref=&quot;T:System.UInt64&quot; /&gt;, &lt;see cref=&quot;T:System.Single&quot; /&gt;, &lt;see cref=&quot;T:System.Double&quot; /&gt;, &lt;see cref=&quot;T:System.Char&quot; /&gt; (encoded as a two-byte Unicode character), &lt;see cref=&quot;T:System.String&quot; /&gt; (encoded as SerString), or &lt;see cref=&quot;T:System.Enum&quot; /&gt; (encoded as the underlying integer value).">
        <see cref="T:System.Boolean" />, <see cref="T:System.Byte" />, <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.UInt16" />, <see cref="T:System.Int32" />, <see cref="T:System.UInt32" />, <see cref="T:System.Int64" />, <see cref="T:System.UInt64" />, <see cref="T:System.Single" />, <see cref="T:System.Double" />, <see cref="T:System.Char" />(2바이트 유니코드 문자로 인코딩됨), <see cref="T:System.String" />(SerString으로 인코딩됨) 또는 <see cref="T:System.Enum" />(기본 정수 값으로 인코딩됨) 형식의 상수입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.NullArray">
      <summary vsli:raw="Encodes a &lt;see langword=&quot;null&quot; /&gt; literal of type &lt;see cref=&quot;T:System.Array&quot; /&gt;.">
        <see langword="null" /> 형식의 <see cref="T:System.Array" /> 리터럴을 인코딩합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.SystemType(System.String)">
      <summary vsli:raw="Encodes a literal of type &lt;see cref=&quot;T:System.Type&quot; /&gt; (which can possibly be &lt;see langword=&quot;null&quot; /&gt;).">
        <see cref="T:System.Type" /> 형식 리터럴(<see langword="null" />일 수 있음)을 인코딩합니다.</summary>
      <param name="serializedTypeName" vsli:raw="The name of the type, or &lt;see langword=&quot;null&quot; /&gt;.">형식의 이름이거나 <see langword="null" />입니다.</param>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2">
      <summary vsli:raw="Decodes signature blobs.">시그니처 blob을 디코딩합니다.</summary>
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.#ctor(System.Reflection.Metadata.ISignatureTypeProvider{`0,`1},System.Reflection.Metadata.MetadataReader,`1)">
      <summary vsli:raw="Creates a new &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2&quot; /&gt;.">새 <see cref="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2" />를 만듭니다.</summary>
      <param name="provider" vsli:raw="The provider used to obtain type symbols as the signature is decoded.">시그니처를 디코딩할 때 형식 기호를 가져오는 데 사용되는 공급자입니다.</param>
      <param name="metadataReader" vsli:raw="The metadata reader from which the signature was obtained. It may be &lt;see langword=&quot;null&quot; /&gt; if the given provider allows it.">시그니처를 가져온 메타데이터 판독기입니다. 지정된 공급자가 허용하는 경우 <see langword="null" />일 수 있습니다.</param>
      <param name="genericContext" vsli:raw="Additional context needed to resolve generic parameters.">제네릭 매개 변수를 확인하는 데 필요한 추가 컨텍스트입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeFieldSignature(System.Reflection.Metadata.BlobReader@)">
      <summary vsli:raw="Decodes a field signature blob and advances the reader past the signature.">필드 시그니처 blob을 디코딩하고 시그니처를 지나 판독기를 앞으로 이동합니다.</summary>
      <param name="blobReader" vsli:raw="The blob reader positioned at a field signature.">필드 시그니처에 배치되는 blob 판독기입니다.</param>
      <returns vsli:raw="The decoded field type.">디코딩된 필드 형식입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeLocalSignature(System.Reflection.Metadata.BlobReader@)">
      <summary vsli:raw="Decodes a local variable signature blob and advances the reader past the signature.">지역 변수 시그니처 blob을 디코딩하고 시그니처를 지나 판독기를 앞으로 이동합니다.</summary>
      <param name="blobReader" vsli:raw="The blob reader positioned at a local variable signature.">지역 변수 시그니처에 배치되는 blob 판독기입니다.</param>
      <returns vsli:raw="The local variable types.">지역 변수 형식입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSignature(System.Reflection.Metadata.BlobReader@)">
      <summary vsli:raw="Decodes a method (definition, reference, or standalone) or a property signature blob.">메서드(정의, 참조 또는 독립 실행형) 또는 속성 시그니처 blob을 디코딩합니다.</summary>
      <param name="blobReader" vsli:raw="A blob reader positioned at a method signature.">메서드 시그니처에 배치되는 blob 판독기입니다.</param>
      <returns vsli:raw="The decoded method signature.">디코딩된 메서드 시그니처입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSpecificationSignature(System.Reflection.Metadata.BlobReader@)">
      <summary vsli:raw="Decodes a method specification signature blob and advances the reader past the signature.">메서드 사양 시그니처 blob을 디코딩하고 시그니처를 지나 판독기를 앞으로 이동합니다.</summary>
      <param name="blobReader" vsli:raw="A blob reader positioned at a valid method specification signature.">유효한 메서드 사양 시그니처에 배치되는 blob 판독기입니다.</param>
      <returns vsli:raw="The types used to instantiate a generic method via the method specification.">메서드 사양을 통해 제네릭 메서드를 인스턴스화하는 데 사용되는 형식입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeType(System.Reflection.Metadata.BlobReader@,System.Boolean)">
      <summary vsli:raw="Decodes a type embedded in a signature and advances the reader past the type.">시그니처에 포함된 형식을 디코딩하고 형식을 지나 판독기를 앞으로 이동합니다.</summary>
      <param name="blobReader" vsli:raw="The blob reader positioned at the leading &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureTypeCode&quot; /&gt;.">선행 <see cref="T:System.Reflection.Metadata.SignatureTypeCode" />에 배치되는 blob 판독기입니다.</param>
      <param name="allowTypeSpecifications" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to allow a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt; to follow a (CLASS | VALUETYPE) in the signature; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />이 시그니처에서 (CLASS | VALUETYPE) 뒤에 오도록 허용하려면 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
      <returns vsli:raw="The decoded type.">디코딩된 형식입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Metadata.BlobBuilder&quot; /&gt; where the signature will be written." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Action{System.Reflection.Metadata.Ecma335.SignatureTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ArrayShapeEncoder})">
      <summary vsli:raw="Encodes an array type.">배열 형식을 인코딩합니다.</summary>
      <param name="elementType" vsli:raw="Called first, to encode the type of the element.">요소의 형식을 인코딩하기 위해 가장 먼저 호출됩니다.</param>
      <param name="arrayShape" vsli:raw="Called second, to encode the shape of the array.">배열의 모양을 인코딩하기 위해 두 번째 호출됩니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Reflection.Metadata.Ecma335.SignatureTypeEncoder@,System.Reflection.Metadata.Ecma335.ArrayShapeEncoder@)">
      <summary vsli:raw="Encodes an array type. Returns a pair of encoders that must be used in the order they appear in the parameter list.">배열 형식을 인코딩합니다. 매개 변수 목록에 나타나는 순서대로 사용해야 하는 인코더 쌍을 반환합니다.</summary>
      <param name="elementType" vsli:raw="Use first, to encode the type of the element.">요소의 형식을 인코딩하기 위해 가장 먼저 사용합니다.</param>
      <param name="arrayShape" vsli:raw="Use second, to encode the shape of the array.">배열의 모양을 인코딩하기 위해 두 번째 사용합니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Boolean" />
    <member name="P:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.CustomModifiers">
      <summary vsli:raw="Starts a signature of a type with custom modifiers.">사용자 지정 한정자를 사용하여 형식의 시그니처를 시작합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.FunctionPointer(System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.Ecma335.FunctionPointerAttributes,System.Int32)">
      <summary vsli:raw="Starts a function pointer signature.">함수 포인터 시그니처를 시작합니다.</summary>
      <param name="convention" vsli:raw="Calling convention.">호출 규칙입니다.</param>
      <param name="attributes" vsli:raw="Function pointer attributes.">함수 포인터 특성입니다.</param>
      <param name="genericParameterCount" vsli:raw="Generic parameter count.">제네릭 매개 변수 개수입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericInstantiation(System.Reflection.Metadata.EntityHandle,System.Int32,System.Boolean)">
      <summary vsli:raw="Starts a generic instantiation signature.">제네릭 인스턴스화 시그니처를 시작합니다.</summary>
      <param name="genericType" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /></param>
      <param name="genericArgumentCount" vsli:raw="Generic argument count.">제네릭 인수 개수입니다.</param>
      <param name="isValueType" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to mark the type as value type, &lt;see langword=&quot;false&quot; /&gt; to mark it as a reference type in the signature.">형식을 값 형식으로 표시하려면 <see langword="true" />이고, 시그니처의 참조 형식으로 표시하려면 <see langword="false" />입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericMethodTypeParameter(System.Int32)">
      <summary vsli:raw="Encodes a reference to type parameter of a containing generic method.">포함하는 제네릭 메서드의 형식 매개 변수에 대한 참조를 인코딩합니다.</summary>
      <param name="parameterIndex" vsli:raw="Parameter index.">매개 변수 인덱스입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericTypeParameter(System.Int32)">
      <summary vsli:raw="Encodes a reference to type parameter of a containing generic type.">포함하는 제네릭 형식의 형식 매개 변수에 대한 참조를 인코딩합니다.</summary>
      <param name="parameterIndex" vsli:raw="Parameter index.">매개 변수 인덱스입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.IntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Pointer">
      <summary vsli:raw="Starts pointer signature.">포인터 시그니처를 시작합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary vsli:raw="Writes primitive type code.">기본 형식 코드를 작성합니다.</summary>
      <param name="type" vsli:raw="Any primitive type code except for &lt;see cref=&quot;F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference&quot; /&gt; and &lt;see cref=&quot;F:System.Reflection.Metadata.PrimitiveTypeCode.Void&quot; /&gt;.">
        <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference" /> 및 <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.Void" />를 제외한 모든 기본 형식 코드입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SZArray">
      <summary vsli:raw="Starts SZ array (vector) signature.">SZ 배열(벡터) 시그니처를 시작합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Type(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <summary vsli:raw="Encodes a reference to a type.">형식에 대한 참조를 인코딩합니다.</summary>
      <param name="type" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /></param>
      <param name="isValueType" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to mark the type as value type, &lt;see langword=&quot;false&quot; /&gt; to mark it as a reference type in the signature.">형식을 값 형식으로 표시하려면 <see langword="true" />이고, 시그니처의 참조 형식으로 표시하려면 <see langword="false" />입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UIntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.VoidPointer">
      <summary vsli:raw="Encodes a void pointer (&lt;c&gt;void*&lt;/c&gt;).">void 포인터를 인코딩합니다(void*)를 사용하여 저장하는 값에 액세스할 수 있습니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.TableIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Assembly" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ClassLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Constant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.DeclSecurity" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Document" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncLog" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Event" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ExportedType" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Field" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldMarshal" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldRva" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.File" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParam" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParamConstraint" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImplMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImportScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.InterfaceImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalConstant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalVariable" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ManifestResource" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MemberRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSemantics" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSpec" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Module" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ModuleRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.NestedClass" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Param" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ParamPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Property" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StandAloneSig" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StateMachineMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeSpec" />
    <member name="T:System.Reflection.Metadata.Ecma335.VectorEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.VectorEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.Count(System.Int32)">
      <param name="count" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.EntityHandle">
      <summary vsli:raw="Represents a metadata entity (such as a type reference, type definition, type specification, method definition, or custom attribute).">메타데이터 엔터티(예: 형식 참조, 형식 정의, 형식 사양, 메서드 정의, 사용자 지정 특성)을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.EntityHandle.AssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Object)">
      <summary vsli:raw="Returns a value that indicates whether the current instance and the specified object are equal.">현재 인스턴스와 지정된 개체가 같은지 여부를 나타내는 값을 반환합니다.</summary>
      <param name="obj" vsli:raw="The object to compare with the current instance.">현재 인스턴스와 비교할 개체입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is an &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; and is equal to the current instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <paramref name="obj" />가 <see cref="T:System.Reflection.Metadata.EntityHandle" />과 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Returns a value that indicates whether the current instance and the specified &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; are equal.">현재 인스턴스와 지정된 <see cref="T:System.Reflection.Metadata.EntityHandle" />이 같은지 여부를 나타내는 값을 반환합니다.</summary>
      <param name="other" vsli:raw="The value to compare with the current instance.">현재 인스턴스와 비교할 값입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current instance and &lt;paramref name=&quot;other&quot; /&gt; are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">현재 인스턴스와 <paramref name="other" />가 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.GetHashCode">
      <summary vsli:raw="Returns the hash code for this instance.">이 인스턴스의 해시 코드를 반환합니다.</summary>
      <returns vsli:raw="The hash code for this instance.">이 인스턴스의 해시 코드입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.EntityHandle.IsNil" />
    <member name="P:System.Reflection.Metadata.EntityHandle.Kind" />
    <member name="F:System.Reflection.Metadata.EntityHandle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Equality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Implicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Inequality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.EventAccessors" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Adder" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Others" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Raiser" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Remover" />
    <member name="T:System.Reflection.Metadata.EventDefinition" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Attributes" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Name" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Type" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.EventDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Equality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Inequality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection" />
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#EventDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ExceptionRegion" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.CatchType">
      <summary vsli:raw="Gets a TypeRef, TypeDef, or TypeSpec handle if the region represents a catch, or a nil token otherwise (&lt;see langword=&quot;default&quot; /&gt;(&lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt;)).">지역이 catch 또는 nil 토큰을 나타내는 경우 TypeRef, TypeDef 또는 TypeSpec 핸들을 가져오고 그렇지 않으면 (<see langword="default" />(<see cref="T:System.Reflection.Metadata.EntityHandle" />))를 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.FilterOffset">
      <summary vsli:raw="Gets the IL offset of the start of the filter block, or -1 if the region is not a filter.">필터 블록 시작의 IL 오프셋을 가져오거나 지역이 필터가 아닌 경우 -1을 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerLength">
      <summary vsli:raw="Gets the length in bytes of the exception handler.">예외 처리기의 길이(바이트)를 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerOffset">
      <summary vsli:raw="Gets the starting IL offset of the exception handler.">예외 처리기의 시작 IL 오프셋을 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.Kind" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryLength">
      <summary vsli:raw="Gets the length in bytes of the try block.">try 블록의 길이(바이트 단위)를 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryOffset">
      <summary vsli:raw="Gets the starting IL offset of the try block.">try 블록의 시작 IL 오프셋을 가져옵니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExceptionRegionKind" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Catch" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Fault" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Filter" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Finally" />
    <member name="T:System.Reflection.Metadata.ExportedType" />
    <member name="P:System.Reflection.Metadata.ExportedType.Attributes" />
    <member name="M:System.Reflection.Metadata.ExportedType.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ExportedType.Implementation">
      <summary vsli:raw="Gets a handle to resolve the implementation of the target type.">대상 형식의 구현을 해결하기 위한 핸들을 가져옵니다.</summary>
      <returns vsli:raw="&lt;list type=&quot;bullet&quot;&gt;&lt;item&gt;&lt;description&gt;&lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt; representing another module in the assembly.&lt;/description&gt;&lt;/item&gt;&lt;item&gt;&lt;description&gt;&lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt; representing another assembly if &lt;see cref=&quot;P:System.Reflection.Metadata.ExportedType.IsForwarder&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.&lt;/description&gt;&lt;/item&gt;&lt;item&gt;&lt;description&gt;&lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt; representing the declaring exported type in which this was is nested.&lt;/description&gt;&lt;/item&gt;&lt;/list&gt;">
        <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />어셈블리의 다른 모듈을 나타냅니다.
<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />가 인 경우 <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder" /> 다른 어셈블리 <see langword="true" />를 나타내는입니다.
<see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />이가 중첩 된 선언 내보낸 형식을 나타내는입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.IsForwarder" />
    <member name="P:System.Reflection.Metadata.ExportedType.Name">
      <summary vsli:raw="Gets the name of the target type, or &lt;see langword=&quot;default&quot; /&gt; if the type is nested or defined in a root namespace.">대상 형식의 이름을 가져오거나, 형식이 루트 네임스페이스에 중첩되거나 정의된 경우 <see langword="default" />를 가져옵니다.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.StringHandle&quot; /&gt; struct instance.">
        <see cref="T:System.Reflection.Metadata.StringHandle" /> 구조체 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.Namespace">
      <summary vsli:raw="Gets the full name of the namespace that contains the target type, or &lt;see langword=&quot;default&quot; /&gt; if the type is nested or defined in a root namespace.">대상 형식을 포함하는 네임스페이스 전체 이름을 가져오거나, 형식이 루트 네임스페이스에 중첩되거나 정의된 경우 <see langword="default" />를 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.NamespaceDefinition">
      <summary vsli:raw="Gets the definition handle of the namespace where the target type is defined, or &lt;see langword=&quot;default&quot; /&gt; if the type is nested or defined in a root namespace.">대상 형식이 정의된 네임스페이스 정의 핸들을 가져오거나, 형식이 루트 네임스페이스에 중첩되거나 정의된 경우 <see langword="default" />를 가져옵니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandle" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ExportedTypeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Equality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Inequality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection">
      <summary vsli:raw="Represents a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; instances.">
        <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 인스턴스의 컬렉션을 나타냅니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ExportedTypeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.FieldDefinition" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Attributes" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetMarshallingDescriptor" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetOffset">
      <summary vsli:raw="Returns the field layout offset, or -1 if it is not available.">필드 레이아웃 오프셋을 반환하거나, 사용할 수 없는 경우 -1을 반환합니다.</summary>
      <returns vsli:raw="The field definition offset, or -1 if it is not available.">필드 정의 오프셋이거나, 사용할 수 없는 경우 -1입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetRelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Name" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Equality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Inequality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection" />
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#FieldDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.GenericParameter" />
    <member name="P:System.Reflection.Metadata.GenericParameter.Attributes">
      <summary vsli:raw="Gets the attributes specifying variance and constraints.">분산 및 제약 조건을 지정하는 특성을 가져옵니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameter.GetConstraints" />
    <member name="M:System.Reflection.Metadata.GenericParameter.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameter.Index">
      <summary vsli:raw="Gets the zero-based index of the parameter within the declaring generic type or method declaration.">선언 제네릭 형식 또는 메서드 선언 내에서 매개 변수의 0부터 시작하는 인덱스를 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Name">
      <summary vsli:raw="Gets the name of the generic parameter.">제네릭 매개 변수의 이름을 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Parent">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; that represents the parent of this generic parameter.">이 제네릭 매개 변수의 부모를 나타내는 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 또는 <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />을 가져옵니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraint" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraint.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Parameter">
      <summary vsli:raw="Gets the constrained &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterHandle&quot; /&gt;.">제한된 <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />을 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Type">
      <summary vsli:raw="Gets a handle (&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;) &#xA;            specifying from which type this generic parameter is constrained to derive,&#xA;            or which interface this generic parameter is constrained to implement.">이 제네릭 매개 변수가 파생되도록 제한하는 형식 또는 이 제네릭 매개 변수가 구현하도록 제한되는 형식을 지정하는 핸들(<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 또는 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />)을 가져옵니다.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; instance.">
        <see cref="T:System.Reflection.Metadata.EntityHandle" /> 인스턴스입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Equality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Inequality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection">
      <summary vsli:raw="Represents a collection of constraints of a generic type parameter.">제네릭 형식 매개 변수에 대한 제약 조건의 컬렉션을 나타냅니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.GetEnumerator" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Item(System.Int32)">
      <param name="index" vsli:raw="The zero-based index of the element to get." />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterConstraintHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.GenericParameterHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Reflection.Metadata.GenericParameterHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.GenericParameterHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Equality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Inequality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection">
      <summary vsli:raw="Represents a collection of generic type parameters of a method or type.">메서드나 형식의 제네릭 형식 매개 변수 컬렉션을 나타냅니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.GetEnumerator" />
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Item(System.Int32)">
      <param name="index" vsli:raw="The zero-based index of the element to get." />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.GuidHandle" />
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Reflection.Metadata.GuidHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.GuidHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Equality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GuidHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Implicit(System.Reflection.Metadata.GuidHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Inequality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Handle">
      <summary vsli:raw="Represents any metadata entity (such as a type reference, a type definition, a type specification, a method definition, or a custom attribute) or value (a string, blob, guid, or user string).">메타데이터 엔터티(형식 참조, 형식 정의, 형식 사양, 메서드 정의, 사용자 지정 특성 등) 또는 값(문자열, Blob, guid, 사용자 문자열 등)을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Handle.AssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Reflection.Metadata.Handle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Handle.IsNil" />
    <member name="P:System.Reflection.Metadata.Handle.Kind" />
    <member name="F:System.Reflection.Metadata.Handle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.Handle.op_Equality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.op_Inequality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.HandleComparer" />
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Compares two entity handles.">두 엔터티 핸들을 비교합니다.</summary>
      <param name="x" vsli:raw="The first entity handle to compare.">비교할 첫 번째 엔터티 핸들입니다.</param>
      <param name="y" vsli:raw="The second entity handle to compare.">비교할 두 번째 엔터티 핸들입니다.</param>
      <returns vsli:raw="Zero if the two entity handles are equal, and a non-zero value of they are not.">두 엔터티 핸들이 같으면 0이고, 같지 않으면 0이 아닌 값입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Compares two handles.">두 핸들을 비교합니다.</summary>
      <param name="x" vsli:raw="The first handle to compare.">비교할 첫 번째 핸들입니다.</param>
      <param name="y" vsli:raw="The second handle to compare.">비교할 두 번째 핸들입니다.</param>
      <returns vsli:raw="Zero if the two handles are equal, and a non-zero value if they are not.">두 핸들이 같으면 0이고, 같지 않으면 0이 아닌 값입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.HandleComparer.Default" />
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="x" vsli:raw="The first object of type &lt;paramref name=&quot;T&quot; /&gt; to compare." />
      <param name="y" vsli:raw="The second object of type &lt;paramref name=&quot;T&quot; /&gt; to compare." />
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="x" vsli:raw="The first object of type &lt;paramref name=&quot;T&quot; /&gt; to compare." />
      <param name="y" vsli:raw="The second object of type &lt;paramref name=&quot;T&quot; /&gt; to compare." />
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.EntityHandle)">
      <param name="obj" vsli:raw="The &lt;see cref=&quot;T:System.Object&quot; /&gt; for which a hash code is to be returned." />
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.Handle)">
      <param name="obj" vsli:raw="The &lt;see cref=&quot;T:System.Object&quot; /&gt; for which a hash code is to be returned." />
    </member>
    <member name="T:System.Reflection.Metadata.HandleKind" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyFile" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.Blob" />
    <member name="F:System.Reflection.Metadata.HandleKind.Constant" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.DeclarativeSecurityAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.Document" />
    <member name="F:System.Reflection.Metadata.HandleKind.EventDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ExportedType" />
    <member name="F:System.Reflection.Metadata.HandleKind.FieldDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameterConstraint" />
    <member name="F:System.Reflection.Metadata.HandleKind.Guid" />
    <member name="F:System.Reflection.Metadata.HandleKind.ImportScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.InterfaceImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalConstant" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalVariable" />
    <member name="F:System.Reflection.Metadata.HandleKind.ManifestResource" />
    <member name="F:System.Reflection.Metadata.HandleKind.MemberReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.NamespaceDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.Parameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.PropertyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.StandaloneSignature" />
    <member name="F:System.Reflection.Metadata.HandleKind.String" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.UserString" />
    <member name="T:System.Reflection.Metadata.IConstructedTypeProvider`1">
      <typeparam name="TType" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetArrayType(`0,System.Reflection.Metadata.ArrayShape)">
      <summary vsli:raw="Gets the type symbol for a generalized array of the given element type and shape.">특정 요소 형식 및 셰이프의 일반화된 배열에 대한 형식 기호를 가져옵니다.</summary>
      <param name="elementType" vsli:raw="The type of the elements in the array.">배열에 있는 요소의 형식입니다.</param>
      <param name="shape" vsli:raw="The shape (rank, sizes, and lower bounds) of the array.">배열의 셰이프(순위, 크기 및 하한값)입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetByReferenceType(`0)">
      <summary vsli:raw="Gets the type symbol for a managed pointer to the given element type.">특정 요소 형식의 관리형 포인터에 대한 형식 기호를 가져옵니다.</summary>
      <param name="elementType" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetGenericInstantiation(`0,System.Collections.Immutable.ImmutableArray{`0})">
      <summary vsli:raw="Gets the type symbol for a generic instantiation of the given generic type with the given type arguments.">특정 형식 인수를 사용하는 특정 제네릭 형식의 제네릭 인스턴스화에 대한 형식 기호를 가져옵니다.</summary>
      <param name="genericType" vsli:raw="" />
      <param name="typeArguments" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetPointerType(`0)">
      <summary vsli:raw="Gets the type symbol for an unmanaged pointer to the given element type.">특정 요소 형식의 비관리형 포인터에 대한 형식 기호를 가져옵니다.</summary>
      <param name="elementType" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.ICustomAttributeTypeProvider`1">
      <typeparam name="TType" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetSystemType">
      <summary vsli:raw="Gets the &lt;typeparamref name=&quot;TType&quot; /&gt; representation for &lt;see cref=&quot;T:System.Type&quot; /&gt;.">
        <typeparamref name="TType" />에 대한 <see cref="T:System.Type" /> 표현을 가져옵니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetTypeFromSerializedName(System.String)">
      <summary vsli:raw="Gets the type symbol for the given serialized type name.">지정된 직렬화 형식 이름의 형식 기호를 가져옵니다.</summary>
      <param name="name" vsli:raw="The serialized type name in so-called &quot;reflection notation&quot; format (as understood by the &lt;see cref=&quot;M:System.Type.GetType(System.String)&quot; /&gt; method.)">소위 말하는 "리플렉션 표기법" 형식의 직렬화된 형식입니다(<see cref="M:System.Type.GetType(System.String)" /> 메서드가 이해한 바에 따르면).</param>
      <returns vsli:raw="A &lt;typeparamref name=&quot;TType&quot; /&gt; instance.">
        <typeparamref name="TType" /> 인스턴스입니다.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The name is malformed.">이름의 형식이 잘못되었습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetUnderlyingEnumType(`0)">
      <summary vsli:raw="Gets the underlying type of the given enum type symbol.">지정된 열거형 형식 기호의 기본 형식을 가져옵니다.</summary>
      <param name="type" vsli:raw="An enum type.">열거형 형식입니다.</param>
      <returns vsli:raw="A type code that indicates the underlying type of the enumeration.">열거형의 기본 형식을 나타내는 형식 코드입니다.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The given type symbol does not represent an enum.">지정된 형식 기호가 열거형을 나타내지 않습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.IsSystemType(`0)">
      <summary vsli:raw="Verifies if the given type represents &lt;see cref=&quot;T:System.Type&quot; /&gt;.">지정된 형식이 <see cref="T:System.Type" />을 나타내는지 확인합니다.</summary>
      <param name="type" vsli:raw="The type to verify.">확인할 형식입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the given type is a &lt;see cref=&quot;T:System.Type&quot; /&gt;, &lt;see langword=&quot;false&quot; /&gt; otherwise.">지정된 형식이 <see langword="true" />이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ILOpCode" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.And" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Arglist" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Box" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Break" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Call" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Calli" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Callvirt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Castclass" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ceq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ckfinite" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Constrained" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Dup" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfilter" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfinally" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Isinst" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Jmp" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_5" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_6" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_7" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_m1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelema" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldlen" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldnull" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldstr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldtoken" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldvirtftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Localloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mkrefany" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Neg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newarr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Nop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Not" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Or" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Pop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Readonly" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanytype" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanyval" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ret" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rethrow" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shl" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sizeof" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Switch" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Tail" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Throw" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unaligned" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox_any" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Volatile" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Xor" />
    <member name="T:System.Reflection.Metadata.ILOpCodeExtensions" />
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetBranchOperandSize(System.Reflection.Metadata.ILOpCode)">
      <summary vsli:raw="Calculates the size of the specified branch instruction operand.">지정된 분기 명령 피연산자의 크기를 계산합니다.</summary>
      <param name="opCode" vsli:raw="The branch op-code.">분기 작업 코드입니다.</param>
      <returns vsli:raw="1 if &lt;paramref name=&quot;opCode&quot; /&gt; is a short branch, or 4 if it is a long branch.">
        <paramref name="opCode" />가 짧은 분기이면 1이고, 긴 분기이면 4입니다.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The specified &lt;paramref name=&quot;opCode&quot; /&gt; is not a branch op-code.">지정된 <paramref name="opCode" />는 분기 작업 코드가 아닙니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetLongBranch(System.Reflection.Metadata.ILOpCode)">
      <summary vsli:raw="Gets a long form of the specified branch op-code.">긴 형식의 지정된 분기 작업 코드를 가져옵니다.</summary>
      <param name="opCode" vsli:raw="The branch op-code.">분기 작업 코드입니다.</param>
      <returns vsli:raw="The long form of the branch op-code.">긴 형식의 분기 작업 코드입니다.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The specified &lt;paramref name=&quot;opCode&quot; /&gt; is not a branch op-code.">지정된 <paramref name="opCode" />는 분기 작업 코드가 아닙니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetShortBranch(System.Reflection.Metadata.ILOpCode)">
      <summary vsli:raw="Gets a short form of the specified branch op-code.">짧은 형식의 지정된 분기 작업 코드를 가져옵니다.</summary>
      <param name="opCode" vsli:raw="The branch op-code.">분기 작업 코드입니다.</param>
      <returns vsli:raw="The short form of the branch op-code.">짧은 형식의 분기 작업 코드입니다.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The specified &lt;paramref name=&quot;opCode&quot; /&gt; is not a branch op-code.">지정된 <paramref name="opCode" />는 분기 작업 코드가 아닙니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.IsBranch(System.Reflection.Metadata.ILOpCode)">
      <summary vsli:raw="Verifies if the specified op-code is a branch to a label.">지정된 작업이 레이블의 분기인지 확인합니다.</summary>
      <param name="opCode" vsli:raw="" />
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the specified op-code is a branch to a label, &lt;see langword=&quot;false&quot; /&gt; otherwise.">지정된 작업 코드가 레이블의 분기이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImageFormatLimitationException">
      <summary vsli:raw="The exception that is thrown when an attempt to write metadata exceeds a limit given by the format specification. For example, when the heap size limit is exceeded.">메타데이터 쓰기 시도가 형식 사양에 지정된 제한을 초과하는 경우에 throw되는 예외입니다. 예를 들어 힙 크기 제한을 초과하는 경우입니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.ImageFormatLimitationException&quot; /&gt; class.">
        <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.ImageFormatLimitationException&quot; /&gt; class with serialized data.">serialize된 데이터를 사용하여 <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="info" vsli:raw="The object that holds the serialized object data.">serialize된 개체 데이터를 보유하는 개체입니다.</param>
      <param name="context" vsli:raw="The contextual information about the source or destination.">원본 또는 대상에 대한 컨텍스트 정보입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.ImageFormatLimitationException&quot; /&gt; class with a specified error message.">지정된 오류 메시지를 사용하여 <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for this exception.">이 예외의 원인을 설명하는 오류 메시지입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.ImageFormatLimitationException&quot; /&gt; class with a specified error message and the exception that is the cause of this exception.">지정된 오류 메시지와 이 예외를 발생시킨 예외를 사용하여 <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for this exception.">이 예외의 원인을 설명하는 오류 메시지입니다.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception, or &lt;see langword=&quot;null&quot; /&gt; if no inner exception is specified.">현재 예외의 원인이 되는 예외이거나, 내부 예외를 지정하지 않았으면 <see langword="null" />입니다.</param>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinition" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Alias" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Kind" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetAssembly" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetNamespace" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetType" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.MoveNext">
      <exception cref="T:System.BadImageFormatException" vsli:raw="Invalid blob format.">잘못된 Blob 형식입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Reset" />
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportDefinition}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionKind" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyReference" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyReferenceAlias" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportXmlNamespace" />
    <member name="T:System.Reflection.Metadata.ImportScope">
      <summary vsli:raw="Provides information about the lexical scope within which a group of imports are available. This information is stored in debug metadata.">가져오기 그룹을 사용할 수 있는 어휘 범위에 대한 정보를 제공합니다. 이 정보는 디버그 메타데이터에 저장됩니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScope.GetImports" />
    <member name="P:System.Reflection.Metadata.ImportScope.ImportsBlob" />
    <member name="P:System.Reflection.Metadata.ImportScope.Parent" />
    <member name="T:System.Reflection.Metadata.ImportScopeCollection" />
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Count" />
    <member name="T:System.Reflection.Metadata.ImportScopeCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportScopeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ImportScopeHandle" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Reflection.Metadata.ImportScopeHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ImportScopeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Equality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Inequality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementation" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementation.Interface">
      <summary vsli:raw="Gets the interface that is implemented (&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;).">구현된 인터페이스(<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 또는 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />)를 가져옵니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandle" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Equality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Inequality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#InterfaceImplementationHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ISignatureTypeProvider`2">
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetFunctionPointerType(System.Reflection.Metadata.MethodSignature{`0})">
      <summary vsli:raw="Gets the type symbol for the function pointer type of the given method &lt;paramref name=&quot;signature&quot; /&gt;.">지정된 메서드 <paramref name="signature" />의 함수 포인터 형식에 대한 형식 기호를 가져옵니다.</summary>
      <param name="signature" vsli:raw="" />
      <returns vsli:raw="The type symbol for the function pointer type.">함수 포인터 형식에 대한 형식 기호입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericMethodParameter(`1,System.Int32)">
      <summary vsli:raw="Gets the type symbol for the generic method parameter at the given zero-based &lt;paramref name=&quot;index&quot; /&gt;.">지정된 0 기반 <paramref name="index" />에서 제네릭 메서드 매개 변수에 대한 형식 기호를 가져옵니다.</summary>
      <param name="genericContext" vsli:raw="" />
      <param name="index" vsli:raw="" />
      <returns vsli:raw="The type symbol for the generic method parameter at &lt;paramref name=&quot;index&quot; /&gt;.">
        <paramref name="index" />의 제네릭 메서드 매개 변수에 대한 형식 기호입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericTypeParameter(`1,System.Int32)">
      <summary vsli:raw="Gets the type symbol for the generic type parameter at the given zero-based &lt;paramref name=&quot;index&quot; /&gt;.">지정된 0 기반 <paramref name="index" />에서 제네릭 형식 매개 변수에 대한 형식 기호를 가져옵니다.</summary>
      <param name="genericContext" vsli:raw="" />
      <param name="index" vsli:raw="" />
      <returns vsli:raw="The type symbol for the generic type parameter at the given zero-based &lt;paramref name=&quot;index&quot; /&gt;.">지정된 0 기반 <paramref name="index" />에서 제네릭 형식 매개 변수에 대한 형식 기호입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetModifiedType(`0,`0,System.Boolean)">
      <summary vsli:raw="Gets the type symbol for a type with a custom modifier applied.">사용자 지정 한정자가 적용된 형식의 형식 기호를 가져옵니다.</summary>
      <param name="modifier" vsli:raw="The modifier type applied.">적용되는 한정자 형식입니다.</param>
      <param name="unmodifiedType" vsli:raw="The type symbol of the underlying type without modifiers applied.">한정자가 적용되지 않는 기본 형식의 형식 기호입니다.</param>
      <param name="isRequired" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the modifier is required, &lt;see langword=&quot;false&quot; /&gt; if it's optional.">수정자가 필요한 경우에는 <see langword="true" />이고, 선택 사항인 경우에는 <see langword="false" />입니다.</param>
      <returns vsli:raw="The type symbol.">형식 기호.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetPinnedType(`0)">
      <summary vsli:raw="Gets the type symbol for a local variable type that is marked as pinned.">고정된 것으로 표시된 로컬 변수 형식에 대한 형식 기호를 가져옵니다.</summary>
      <param name="elementType" vsli:raw="" />
      <returns vsli:raw="The type symbol for the local variable type.">로컬 변수 형식에 대한 형식 기호입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetTypeFromSpecification(System.Reflection.Metadata.MetadataReader,`1,System.Reflection.Metadata.TypeSpecificationHandle,System.Byte)">
      <summary vsli:raw="Gets the type symbol for a type specification.">형식 사양에 대한 형식 기호를 가져옵니다.</summary>
      <param name="reader" vsli:raw="The metadata reader that was passed to the signature decoder. It may be &lt;see langword=&quot;null&quot; /&gt;.">서명 디코더에 전달된 메타데이터 reader입니다. <see langword="null" />일 수 있습니다.</param>
      <param name="genericContext" vsli:raw="The context that was passed to the signature decoder.">서명 디코더에 전달된 컨텍스트.</param>
      <param name="handle" vsli:raw="The type specification handle.">형식 사양 핸들.</param>
      <param name="rawTypeKind" vsli:raw="The kind of the type, as specified in the signature. To interpret this value, use &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)&quot; /&gt;.">서명에 지정된 형식의 종류입니다. 이 값을 해석하려면 <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />를 사용합니다.</param>
      <returns vsli:raw="The type symbol for the type specification.">형식 사양에 대한 형식 기호입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISimpleTypeProvider`1">
      <typeparam name="TType" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetPrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary vsli:raw="Gets the type symbol for a primitive type.">기본 형식에 대한 형식 기호를 가져옵니다.</summary>
      <param name="typeCode" vsli:raw="" />
      <returns vsli:raw="The type symbol for &lt;paramref name=&quot;typeCode&quot; /&gt;.">다음에 대한 형식 기호 <param name="typeCode" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromDefinition(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeDefinitionHandle,System.Byte)">
      <summary vsli:raw="Gets the type symbol for a type definition.">형식 정의에 대한 형식 기호를 가져옵니다.</summary>
      <param name="reader" vsli:raw="The metadata reader that was passed to the signature decoder. It may be &lt;see langword=&quot;null&quot; /&gt;.">서명 디코더에 전달된 메타데이터 reader입니다. <see langword="null" />일 수 있습니다.</param>
      <param name="handle" vsli:raw="The type definition handle.">형식 정의 핸들.</param>
      <param name="rawTypeKind" vsli:raw="The kind of the type, as specified in the signature. To interpret this value use &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)&quot; /&gt;.">서명에 지정된 형식의 종류입니다. 이 값을 해석하려면 <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />를 사용합니다.</param>
      <returns vsli:raw="The type symbol.">형식 기호.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromReference(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeReferenceHandle,System.Byte)">
      <summary vsli:raw="Gets the type symbol for a type reference.">형식 참조에 대한 형식 기호를 가져옵니다.</summary>
      <param name="reader" vsli:raw="The metadata reader that was passed to the signature decoder. It may be &lt;see langword=&quot;null&quot; /&gt;.">서명 디코더에 전달된 메타데이터 reader입니다. <see langword="null" />일 수 있습니다.</param>
      <param name="handle" vsli:raw="The type definition handle.">형식 정의 핸들.</param>
      <param name="rawTypeKind" vsli:raw="The kind of the type as specified in the signature. To interpret this value, use &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)&quot; /&gt;.">서명에 지정된 형식의 종류입니다. 이 값을 해석하려면 <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />를 사용합니다.</param>
      <returns vsli:raw="The type symbol.">형식 기호.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISZArrayTypeProvider`1">
      <typeparam name="TType" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ISZArrayTypeProvider`1.GetSZArrayType(`0)">
      <summary vsli:raw="Gets the type symbol for a single-dimensional array of the given element type with a lower bounds of zero.">하한값이 0인 특정 요소 형식의 1차원 배열에 대한 형식 기호를 가져옵니다.</summary>
      <param name="elementType" vsli:raw="" />
      <returns vsli:raw="A &lt;typeparamref name=&quot;TType&quot; /&gt; instance.">
        <typeparamref name="TType" /> 인스턴스입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstant">
      <summary vsli:raw="Provides information about local constants. This information is stored in debug metadata.">지역 상수에 대한 정보를 제공합니다. 이 정보는 디버그 메타데이터에 저장됩니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstant.Name" />
    <member name="P:System.Reflection.Metadata.LocalConstant.Signature">
      <summary vsli:raw="Gets the constant signature.">상수 시그니처를 가져옵니다.</summary>
      <returns vsli:raw="The constant signature.">상수 시그니처입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandle" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Reflection.Metadata.LocalConstantHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.LocalConstantHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Equality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Inequality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection" />
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalConstantHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.LocalScope">
      <summary vsli:raw="Provides information about the scope of local variables and constants. This information is stored in debug metadata.">지역 변수 및 상수의 범위에 대한 정보를 제공합니다. 이 정보는 디버그 메타데이터에 저장됩니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScope.EndOffset" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetChildren" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalConstants" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalVariables" />
    <member name="P:System.Reflection.Metadata.LocalScope.ImportScope" />
    <member name="P:System.Reflection.Metadata.LocalScope.Length" />
    <member name="P:System.Reflection.Metadata.LocalScope.Method" />
    <member name="P:System.Reflection.Metadata.LocalScope.StartOffset" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandle" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Reflection.Metadata.LocalScopeHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Equality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Inequality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.Current" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#IDisposable#Dispose" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalScopeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.LocalVariable">
      <summary vsli:raw="Provides information about local variables. This information is stored in debug metadata.">지역 변수에 대한 정보를 제공합니다. 이 정보는 디버그 메타데이터에 저장됩니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariable.Attributes" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Index" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Name" />
    <member name="T:System.Reflection.Metadata.LocalVariableAttributes" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.DebuggerHidden" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.None" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandle" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Reflection.Metadata.LocalVariableHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.LocalVariableHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Equality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Inequality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection" />
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalVariableHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ManifestResource" />
    <member name="P:System.Reflection.Metadata.ManifestResource.Attributes">
      <summary vsli:raw="Gets the manifest resource attributes.">매니페스트 리소스 특성을 가져옵니다.</summary>
      <returns vsli:raw="A bitwise combination of the enumeration values that specify the manifest resource attributes.">매니페스트 리소스 특성을 지정 하는 열거형 값의 비트 조합입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResource.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ManifestResource.Implementation">
      <summary vsli:raw="Gets the implementation entity handle.">구현 엔터티 핸들을 가져옵니다.</summary>
      <returns vsli:raw="An EntityHandle instance. If the &lt;see cref=&quot;P:System.Reflection.Metadata.EntityHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, the returned handle will have default values.">EntityHandle 인스턴스입니다. <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> 속성이 <see langword="true" />이면 반환 된 핸들에 기본값이 포함 됩니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Name">
      <summary vsli:raw="Gets the resource name.">리소스 이름을 가져옵니다.</summary>
      <returns vsli:raw="The resource name.">리소스 이름입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Offset">
      <summary vsli:raw="Gets the byte offset within the referenced file at which this resource record begins.">이 리소스 레코드가 시작되는 참조된 파일 내의 바이트 오프셋을 가져옵니다.</summary>
      <returns vsli:raw="The byte offset within the referenced file at which this resource record begins.">참조 된 파일 내에서이 리소스 레코드가 시작 되는 바이트 오프셋입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandle" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ManifestResourceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Equality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Inequality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection">
      <summary vsli:raw="Represents a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.ManifestResourceHandle&quot; /&gt; instances.">
        <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" /> 인스턴스의 컬렉션을 나타냅니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ManifestResourceHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MemberReference" />
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeFieldSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MemberReference.GetKind">
      <summary vsli:raw="Determines if the member reference is to a method or field.">멤버 참조가 메서드 또는 필드인지 여부를 확인합니다.</summary>
      <returns vsli:raw="One of the enumeration values that indicates the kind of member reference.">멤버 참조의 종류를 나타내는 열거형 값 중 하나입니다.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The member reference signature is invalid.">멤버 참조 서명이 올바르지 않습니다.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Name" />
    <member name="P:System.Reflection.Metadata.MemberReference.Parent">
      <summary vsli:raw="Gets the parent entity handle.">부모 엔터티 핸들을 가져옵니다.</summary>
      <returns vsli:raw="An entity handle instance. If the &lt;see cref=&quot;P:System.Reflection.Metadata.EntityHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, the returned handle will have default values.">엔터티 핸들 인스턴스입니다. <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> 속성이 <see langword="true" />이면 반환 된 핸들에 기본값이 포함 됩니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Signature">
      <summary vsli:raw="Gets a handle to the signature blob.">시그니처 Blob에 대한 핸들을 가져옵니다.</summary>
      <returns vsli:raw="A handle to the signature blob.">서명 blob에 대 한 핸들입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandle" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MemberReferenceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Equality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Inequality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection">
      <summary vsli:raw="Represents a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt; instances.">
        <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /> 인스턴스의 컬렉션을 나타냅니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MemberReferenceHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MemberReferenceKind">
      <summary vsli:raw="Specifies constants that indicate whether a &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReference&quot; /&gt; references a method or field.">
        <see cref="T:System.Reflection.Metadata.MemberReference" />가 메서드 또는 필드를 참조하는지를 나타내는 상수를 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Field">
      <summary vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReference&quot; /&gt; references a field.">
        <see cref="T:System.Reflection.Metadata.MemberReference" />는 필드를 참조합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Method">
      <summary vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReference&quot; /&gt; references a method.">
        <see cref="T:System.Reflection.Metadata.MemberReference" />는 메서드를 참조합니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataKind" />
    <member name="F:System.Reflection.Metadata.MetadataKind.Ecma335">
      <summary vsli:raw="CLI metadata.">CLI 메타데이터입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.ManagedWindowsMetadata">
      <summary vsli:raw="Windows metadata generated by managed compilers.">관리 컴파일러에서 생성된 Windows 메타데이터입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.WindowsMetadata">
      <summary vsli:raw="Windows metadata.">Windows 메타데이터입니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReader">
      <summary vsli:raw="Reads metadata as defined by the ECMA 335 CLI specification.">ECMA 335 CLI 사양에 정의된 대로 메타데이터를 읽습니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; class from the metadata stored at the given memory location.">지정된 메모리 위치에 저장된 메타데이터에서 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="metadata" vsli:raw="A pointer to the first byte in a block of metadata.">메타데이터 블록의 첫 번째 바이트에 대한 포인터입니다.</param>
      <param name="length" vsli:raw="The number of bytes in the block.">블록의 바이트 수입니다.</param>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; class from the metadata stored at the given memory location.">지정된 메모리 위치에 저장된 메타데이터에서 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="metadata" vsli:raw="" />
      <param name="length" vsli:raw="" />
      <param name="options" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; class from the metadata stored at the given memory location.">지정된 메모리 위치에 저장된 메타데이터에서 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="metadata" vsli:raw="" />
      <param name="length" vsli:raw="" />
      <param name="options" vsli:raw="" />
      <param name="utf8Decoder" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;length&quot; /&gt; is not positive.">
        <paramref name="length" />가 양수가 아닙니다.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;metadata&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="metadata" />가 <see langword="null" />입니다.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The encoding of &lt;paramref name=&quot;utf8Decoder&quot; /&gt; is not &lt;see cref=&quot;T:System.Text.UTF8Encoding&quot; /&gt;.">
        <paramref name="utf8Decoder" />의 인코딩은 <see cref="T:System.Text.UTF8Encoding" />이 아닙니다.</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is big-endian.">현재 플랫폼은 big-endian입니다.</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Bad metadata header.">잘못된 메타데이터 헤더입니다.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyFiles" />
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.DebugMetadataHeader">
      <summary vsli:raw="Gets the information decoded from #Pdb stream, or &lt;see langword=&quot;null&quot; /&gt; if the stream is not present.">#Pdb 스트림에서 디코딩된 정보를 가져오거나 스트림이 없는 경우 <see langword="null" />을 가져옵니다.</summary>
      <returns vsli:raw="The information decoded from #Pdb stream, or &lt;see langword=&quot;null&quot; /&gt; if the stream is not present.">#Pdb 스트림에서 디코딩된 정보 이거나, 스트림이 없는 경우 <see langword="null" />입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.DeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Documents" />
    <member name="P:System.Reflection.Metadata.MetadataReader.EventDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ExportedTypes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.FieldDefinitions" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyFile(System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyReference(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobBytes(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobContent(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.StringHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetConstant(System.Reflection.Metadata.ConstantHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttribute(System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttributes(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDeclarativeSecurityAttribute(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDocument(System.Reflection.Metadata.DocumentHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetEventDefinition(System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetExportedType(System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetFieldDefinition(System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameter(System.Reflection.Metadata.GenericParameterHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameterConstraint(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGuid(System.Reflection.Metadata.GuidHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetImportScope(System.Reflection.Metadata.ImportScopeHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetInterfaceImplementation(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalConstant(System.Reflection.Metadata.LocalConstantHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScope(System.Reflection.Metadata.LocalScopeHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalVariable(System.Reflection.Metadata.LocalVariableHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetManifestResource(System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMemberReference(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDefinition(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodImplementation(System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodSpecification(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleReference(System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinition(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinitionRoot" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetParameter(System.Reflection.Metadata.ParameterHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetPropertyDefinition(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetStandaloneSignature(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.StringHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeDefinition(System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeReference(System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeSpecification(System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetUserString(System.Reflection.Metadata.UserStringHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.ImportScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.IsAssembly">
      <summary vsli:raw="Gets a value that indicates whether the metadata represents an assembly.">메타데이터가 어셈블리를 나타내는지 여부를 지정하는 값을 가져옵니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the metadata represents an assembly; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">메타 데이터가 어셈블리를 나타내는지 여부를 <see langword="true" /> 합니다. 그렇지 않으면 <see langword="false" />합니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalConstants" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalVariables" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ManifestResources" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MemberReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataKind">
      <summary vsli:raw="Gets the metadata kind.">메타데이터 종류를 가져옵니다.</summary>
      <returns vsli:raw="One of the enumeration values that specifies the metadata kind.">메타 데이터 종류를 지정 하는 열거형 값 중 하나입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataLength">
      <summary vsli:raw="Gets the length of the underlying data.">기본 데이터의 길이를 가져옵니다.</summary>
      <returns vsli:raw="The length of the underlying data.">기본 데이터의 길이입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataPointer">
      <summary vsli:raw="Gets the pointer to the underlying data.">기본 데이터에 대한 포인터를 가져옵니다.</summary>
      <returns vsli:raw="The pointer to the underlying data.">기본 데이터에 대 한 포인터입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataVersion">
      <summary vsli:raw="Gets the version string read from metadata header.">메타데이터 헤더에서 읽은 버전 문자열을 가져옵니다.</summary>
      <returns vsli:raw="The version string read from metadata header.">메타 데이터 헤더에서 읽은 버전 문자열입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Options">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderOptions&quot; /&gt; passed to the constructor.">생성자에 전달된 <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" />를 가져옵니다.</summary>
      <returns vsli:raw="A bitwise combination of the enumeration values that describes the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderOptions&quot; /&gt; enum value.">
        <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" /> 열거형 값을 설명 하는 열거형 값의 비트 조합입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.PropertyDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.StringComparer">
      <summary vsli:raw="Gets the comparer used to compare strings stored in metadata.">메타데이터에 저장된 문자열을 비교하는 데 사용되는 비교자를 가져옵니다.</summary>
      <returns vsli:raw="The comparer used to compare strings stored in metadata.">메타 데이터에 저장 된 문자열을 비교 하는 데 사용 되는 비교자입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.UTF8Decoder">
      <summary vsli:raw="Gets the decoder used by the reader to produce string instances from UTF8-encoded byte sequences.">UTF8로 인코딩된 바이트 시퀀스에서 문자열 인스턴스를 생성하기 위해 reader에서 사용하는 디코더를 가져옵니다.</summary>
      <returns vsli:raw="The decoder used by the reader to produce string instances from UTF8-encoded byte sequences.">판독기가 UTF8 인코딩된 바이트 시퀀스에서 문자열 인스턴스를 생성 하는 데 사용 하는 디코더입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderOptions" />
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.ApplyWindowsRuntimeProjections">
      <summary vsli:raw="Windows Runtime projections are enabled (on by default).">Windows 런타임 프로젝션은 기본적으로 설정되어 있습니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.Default">
      <summary vsli:raw="The options that are used when a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; is obtained via an overload that does not take a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderOptions&quot; /&gt; argument.">
        <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" /> 인수를 사용하지 않는 오버로드를 통해 <see cref="T:System.Reflection.Metadata.MetadataReader" />를 가져올 때 사용되는 옵션입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.None">
      <summary vsli:raw="All options are disabled.">모든 옵션을 사용할 수 없습니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderProvider">
      <summary vsli:raw="Provides a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; for metadata stored in an array of bytes, a memory block, or a stream.">바이트 배열, 메모리 블록 또는 스트림으로 저장된 메타데이터에 대한 <see cref="T:System.Reflection.Metadata.MetadataReader" />를 제공합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.Dispose">
      <summary vsli:raw="Disposes all memory allocated by the reader.">reader에 의해 할당된 모든 메로리를 삭제합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Byte*,System.Int32)">
      <summary vsli:raw="Creates a metadata provider over an image stored in memory.">메모리에 저장된 이미지를 통해 메타데이터 공급자를 만듭니다.</summary>
      <param name="start" vsli:raw="Pointer to the start of the metadata blob.">메타데이터 Blob의 시작 부분에 대한 포인터.</param>
      <param name="size" vsli:raw="The size of the metadata blob.">메타데이터 Blob의 크기.</param>
      <returns vsli:raw="The new metadata provider.">새 메타데이터 공급자.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is &lt;see cref=&quot;F:System.IntPtr.Zero&quot; /&gt;.">
        <paramref name="start" />가 <see cref="F:System.IntPtr.Zero" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative.">
        <paramref name="size" />가 음수입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Creates a provider over a byte array.">바이트 배열을 통해 공급자를 만듭니다.</summary>
      <param name="image" vsli:raw="Metadata image.">메타데이터 이미지.</param>
      <returns vsli:raw="The new provider.">새 공급자.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;image&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="image" />가 <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary vsli:raw="Creates a provider for a stream of the specified size beginning at its current position.">현재 위치에서 시작하는 지정된 크기의 스트림에 대한 공급자를 만듭니다.</summary>
      <param name="stream" vsli:raw="A &lt;see cref=&quot;T:System.IO.Stream&quot; /&gt; instance.">
        <see cref="T:System.IO.Stream" /> 인스턴스입니다.</param>
      <param name="options" vsli:raw="Options specifying how sections of the image are read from the stream.">스트림에서 이미지의 섹션을 읽는 방법을 지정하는 옵션입니다.</param>
      <param name="size" vsli:raw="Size of the metadata blob in the stream. If not specified, the metadata blob is assumed to span to the end of the stream.">스트림의 메타데이터 Blob의 크기. 지정되지 않은 경우 메타데이터 Blob은 스트림의 맨 끝까지 확장되는 것으로 간주됩니다.</param>
      <returns vsli:raw="The new provider.">새 공급자.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;stream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="stream" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;stream&quot; /&gt; doesn't support read and seek operations.">
        <paramref name="stream" />은 읽기 및 검색 작업을 지원하지 않습니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Size is negative or extends past the end of the stream.">크기가 음수이거나 스트림의 끝을 넘어 확장됩니다.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream (only when &lt;see cref=&quot;F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata&quot; /&gt; is specified).">스트림에서 읽는 중 오류가 발생했습니다(<see cref="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata" />가 지정된 경우에만).</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Byte*,System.Int32)">
      <summary vsli:raw="Creates a portable PDB metadata provider over a blob stored in memory.">메모리에 저정된 Blob을 통해 이식 가능한 PDB 메타데이터 공급자를 만듭니다.</summary>
      <param name="start" vsli:raw="Pointer to the start of the portable PDB blob.">이식 가능한 PDB Blob의 시작 부분에 대한 포인터입니다.</param>
      <param name="size" vsli:raw="The size of the portable PDB blob.">이식 가능한 PDB Blob의 크기.</param>
      <returns vsli:raw="The new portable PDB metadata provider.">새 이식 가능한 PDB 메타데이터 공급자.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is &lt;see cref=&quot;F:System.IntPtr.Zero&quot; /&gt;.">
        <paramref name="start" />가 <see cref="F:System.IntPtr.Zero" />입니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative.">
        <paramref name="size" />가 음수입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Creates a portable PDB metadata provider over a byte array.">바이트 배열을 통해 이식 가능한 PDB 메타데이터 공급자를 만듭니다.</summary>
      <param name="image" vsli:raw="A portable PDB image.">이식 가능한 PDB 이미지.</param>
      <returns vsli:raw="The new portable PDB metadata provider .">새 이식 가능한 PDB 메타데이터 공급자.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;image&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="image" />가 <see langword="null" />입니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary vsli:raw="Creates a provider for a stream of the specified size beginning at its current position.">현재 위치에서 시작하는 지정된 크기의 스트림에 대한 공급자를 만듭니다.</summary>
      <param name="stream" vsli:raw="The stream.">스트림입니다.</param>
      <param name="options" vsli:raw="Options specifying how sections of the image are read from the stream.">스트림에서 이미지의 섹션을 읽는 방법을 지정하는 옵션입니다.</param>
      <param name="size" vsli:raw="Size of the metadata blob in the stream. If not specified, the metadata blob is assumed to span to the end of the stream.">스트림의 메타데이터 Blob의 크기. 지정되지 않은 경우 메타데이터 Blob은 스트림의 맨 끝까지 확장되는 것으로 간주됩니다.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; instance.">
        <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> 인스턴스입니다.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;stream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="stream" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;stream&quot; /&gt; doesn't support read and seek operations.">
        <paramref name="stream" />은 읽기 및 검색 작업을 지원하지 않습니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Size is negative or extends past the end of the stream.">크기가 음수이거나 스트림의 끝을 넘어 확장됩니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.GetMetadataReader(System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; from a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />에서 <see cref="T:System.Reflection.Metadata.MetadataReader" />를 가져옵니다.</summary>
      <param name="options" vsli:raw="A bitwise combination of the enumeration values that represent the configuration when reading the metadata.">메타데이터를 읽을 때 구성을 나타내는 열거형 값의 비트 조합입니다.</param>
      <param name="utf8Decoder" vsli:raw="The encoding to use.">사용할 인코딩입니다.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; instance.">
        <see cref="T:System.Reflection.Metadata.MetadataReader" /> 인스턴스.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The encoding of &lt;paramref name=&quot;utf8Decoder&quot; /&gt; is not &lt;see cref=&quot;T:System.Text.UTF8Encoding&quot; /&gt;.">
        <paramref name="utf8Decoder" />의 인코딩은 <see cref="T:System.Text.UTF8Encoding" />이 아닙니다.</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is big-endian.">현재 플랫폼은 big-endian입니다.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">기본 스트림에서 읽는 동안 IO 오류가 발생했습니다.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="Provider has been disposed.">공급자가 삭제되었습니다.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStreamOptions" />
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.Default">
      <summary vsli:raw="By default, the stream is disposed when &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; is disposed and sections of the PE image are read lazily.">기본적으로 스트림은 <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />가 삭제되고 PE 이미지의 섹션이 느리게 읽혀질 때 삭제됩니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen">
      <summary vsli:raw="Keeps the stream open when the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; is disposed.">
        <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />가 삭제될 때 스트림을 열린 상태로 유지합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata">
      <summary vsli:raw="&lt;para&gt;Reads PDB metadata into memory right away.&lt;/para&gt;&lt;para&gt;The underlying file may be closed and even deleted after the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; is constructed. &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; closes the stream automatically by the time the constructor returns unless &lt;see cref=&quot;F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen&quot; /&gt; is specified.&lt;/para&gt;">PDB 메타데이터를 즉시 메모리로 읽습니다.
기본 파일은 닫히며 <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />가 생성된 후에도 삭제될 수 있습니다. <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />는 <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen" />을 지정하지 않을 경우 생성자가 반환될 때 자동으로 스트림을 닫습니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringComparer">
      <summary vsli:raw="Provides string comparison helpers to query strings in metadata while avoiding allocation if possible.">가능하면 할당을 방지하면서 메타데이터의 문자열을 쿼리하기 위한 문자열 비교 도우미를 제공합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String,System.Boolean)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
      <param name="ignoreCase" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String,System.Boolean)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
      <param name="ignoreCase" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
      <param name="ignoreCase" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
      <param name="ignoreCase" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringDecoder">
      <summary vsli:raw="Provides the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; with a custom mechanism for decoding byte sequences in metadata that represent text.">텍스트를 나타내는 메타데이터의 바이트 시퀀스를 디코딩하는 사용자 지정 메커니즘을 <see cref="T:System.Reflection.Metadata.MetadataReader" />에 제공합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.#ctor(System.Text.Encoding)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataStringDecoder&quot; /&gt; class using the given encoding.">지정된 인코딩을 사용하여 <see cref="T:System.Reflection.Metadata.MetadataStringDecoder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="encoding" vsli:raw="The encoding to use.">사용할 인코딩입니다.</param>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.DefaultUTF8">
      <summary vsli:raw="Gets the default decoder used by &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; to decode UTF-8 when no decoder is provided to the constructor.">생성자에게 제공된 디코더가 없는 경우 <see cref="T:System.Reflection.Metadata.MetadataReader" />에서 UTF-8을 디코딩하는 데 사용하는 기본 디코더를 가져옵니다.</summary>
      <returns vsli:raw="The default decoder used by &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; to decode UTF-8.">
        <see cref="T:System.Reflection.Metadata.MetadataReader" />에서 u t f-8을 디코딩하는 데 사용 하는 기본 디코더입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding">
      <summary vsli:raw="Gets the encoding used by this instance.">이 인스턴스에서 사용되는 인코딩을 가져옵니다.</summary>
      <returns vsli:raw="The encoding used by this instance.">이 인스턴스에서 사용 하는 인코딩입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.GetString(System.Byte*,System.Int32)">
      <summary vsli:raw="Obtains strings for byte sequences in metadata. Override this to cache strings if required. Otherwise, it is implemented by forwarding straight to &lt;see cref=&quot;P:System.Reflection.Metadata.MetadataStringDecoder.Encoding&quot; /&gt; and every call will allocate a new string.">메타데이터의 바이트 시퀀스에 대한 문자열을 가져옵니다. 필요한 경우 이 항목을 캐시 문자열로 재정의합니다. 그렇지 않으면 <see cref="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding" />으로 바로 전달되어 구현되고 모든 호출에 새 문자열이 할당됩니다.</summary>
      <param name="bytes" vsli:raw="Pointer to bytes to decode.">디코딩할 바이트에 대한 포인터입니다.</param>
      <param name="byteCount" vsli:raw="Number of bytes to decode.">디코딩할 바이트 수입니다.</param>
      <returns vsli:raw="The decoded string.">디코딩된 문자열입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodBodyBlock" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.Create(System.Reflection.Metadata.BlobReader)">
      <param name="reader" vsli:raw="The blob reader to read the method body." />
    </member>
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.ExceptionRegions" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILBytes" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILContent" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILReader" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalSignature" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalVariablesInitialized" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.MaxStack" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.Size">
      <summary vsli:raw="Gets the size of the method body, including the header, IL, and exception regions.">헤더, IL 및 예외 영역을 포함하여 메서드 본문의 크기를 가져옵니다.</summary>
      <returns vsli:raw="The size of the method body.">메서드 본문의 크기입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformation">
      <summary vsli:raw="Provides debug information associated with a method definition. This information is stored in debug metadata.">메서드 정의와 연결된 디버그 정보를 제공합니다. 이 정보는 디버그 메타데이터에 저장됩니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.Document">
      <summary vsli:raw="Gets the handle of the single document containing all sequence points of the method.">메서드의 모든 시퀀스 위치를 포함하는 단일 문서의 핸들을 가져옵니다.</summary>
      <returns vsli:raw="The handle of the single document containing all sequence points of the method, or a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.DocumentHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the method doesn't have sequence points or spans multiple documents.">메서드의 모든 시퀀스 위치를 포함 하는 단일 문서의 핸들 또는 메서드에 시퀀스 지점이 없거나 여러 문서에 걸쳐 있는 경우 해당 <see cref="P:System.Reflection.Metadata.DocumentHandle.IsNil" /> 속성이 <see langword="true" /> 되는 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetSequencePoints">
      <summary vsli:raw="Returns a collection of sequence points decoded from &lt;see cref=&quot;P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob&quot; /&gt;.">
        <see cref="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob" />에서 디코딩된 시퀀스 위치 컬렉션을 반환합니다.</summary>
      <returns vsli:raw="A collection of sequence points.">시퀀스 위치 컬렉션입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetStateMachineKickoffMethod">
      <summary vsli:raw="Returns the kickoff method of the state machine.">상태 머신의 킥오프 메서드를 반환합니다.</summary>
      <returns vsli:raw="The kickoff method of the state machine, if the method is a &lt;c&gt;MoveNext&lt;/c&gt; method of a state machine. Otherwise, it returns a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;.">메서드가 상태 머신의 <c>MoveNext</c> 메서드인 경우 상태 시스템의 킥오프 메서드입니다. 그렇지 않으면 <see cref="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" /> 속성이 <see langword="true" />인 핸들을 반환합니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.LocalSignature">
      <summary vsli:raw="Returns a local signature handle.">로컬 서명 핸들을 반환합니다.</summary>
      <returns vsli:raw="A local signature handle, or a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the method doesn't define any local variables.">메서드에서 지역 변수를 정의 하지 않을 경우 <see cref="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" /> 속성이 <see langword="true" /> 되는 로컬 서명 핸들 또는 핸들입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob">
      <summary vsli:raw="Returns a blob encoding sequence points.">Blob 인코딩 시퀀스 위치를 반환합니다.</summary>
      <returns vsli:raw="A blob encoding sequence points, or a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.BlobHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the method doesn't have sequence points.">Blob 인코딩 시퀀스 위치 이거나, 메서드에 시퀀스 위치가 없는 경우 <see cref="P:System.Reflection.Metadata.BlobHandle.IsNil" /> 속성이 <see langword="true" /> 되는 핸들입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Equality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Inequality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.ToDefinitionHandle">
      <summary vsli:raw="Returns a handle to a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinition&quot; /&gt; that corresponds to this handle.">이 핸들에 해당하는 <see cref="T:System.Reflection.Metadata.MethodDefinition" />에 대한 핸들을 반환합니다.</summary>
      <returns vsli:raw="A method definition handle that corresponds to this handle.">이 핸들에 해당하는 메서드 정의 핸들입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection" />
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDebugInformationHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MethodDefinition" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Attributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetImport" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetParameters" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.ImplAttributes" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Name" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.RelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Equality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Inequality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.ToDebugInformationHandle">
      <summary vsli:raw="Returns a handle to a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDebugInformation&quot; /&gt; that corresponds to this handle.">이 핸들에 해당하는 <see cref="T:System.Reflection.Metadata.MethodDebugInformation" />에 대한 핸들을 반환합니다.</summary>
      <returns vsli:raw="A method debug information handle that corresponds to this handle.">이 핸들에 해당하는 메서드 디버그 정보 핸들입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection" />
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MethodImplementation" />
    <member name="M:System.Reflection.Metadata.MethodImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodBody" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodDeclaration" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.Type" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandle" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MethodImplementationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Equality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Inequality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection" />
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodImplementationHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MethodImport" />
    <member name="P:System.Reflection.Metadata.MethodImport.Attributes" />
    <member name="P:System.Reflection.Metadata.MethodImport.Module" />
    <member name="P:System.Reflection.Metadata.MethodImport.Name" />
    <member name="T:System.Reflection.Metadata.MethodSignature`1">
      <summary vsli:raw="Represents a method (definition, reference, or standalone) or property signature. In the case of properties, the signature matches that of a getter with a distinguishing &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt;.">메서드(정의, 참조 또는 독립 실행형) 또는 속성 서명을 나타냅니다. 속성의 경우 서명은 구분된 <see cref="T:System.Reflection.Metadata.SignatureHeader" />을 포함하여 getter의 속성과 일치합니다.</summary>
      <typeparam name="TType" vsli:raw="The method type.">메서드 형식입니다.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.MethodSignature`1.#ctor(System.Reflection.Metadata.SignatureHeader,`0,System.Int32,System.Int32,System.Collections.Immutable.ImmutableArray{`0})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.MethodSignature`1&quot; /&gt; structure using the specified header, return type, and parameter information.">지정된 헤더, 반환 형식 및 매개 변수 정보를 사용하여 <see cref="T:System.Reflection.Metadata.MethodSignature`1" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
      <param name="header" vsli:raw="The information in the leading byte of the signature (kind, calling convention, flags).">서명의 선행 바이트에 있는 정보입니다(종류, 호출 규칙, 플래그).</param>
      <param name="returnType" vsli:raw="The return type of the method.">메서드의 반환 형식입니다.</param>
      <param name="requiredParameterCount" vsli:raw="The number of required parameters.">필수 매개 변수의 수입니다.</param>
      <param name="genericParameterCount" vsli:raw="The number of generic type parameters.">제네릭 형식 매개 변수의 수입니다.</param>
      <param name="parameterTypes" vsli:raw="The parameter types.">매개 변수 형식입니다.</param>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.GenericParameterCount">
      <summary vsli:raw="Gets the number of generic type parameters for the method.">메서드에 대한 제네릭 형식 매개 변수의 수를 가져옵니다.</summary>
      <returns vsli:raw="The number of generic type parameters, or 0 for non-generic methods.">제네릭 형식 매개 변수의 수 이거나 제네릭이 아닌 메서드의 경우 0입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.Header">
      <summary vsli:raw="Gets the information in the leading byte of the signature (kind, calling convention, flags).">서명의 선행 바이트에 있는 정보를 가져옵니다(종류, 호출 규칙, 플래그).</summary>
      <returns vsli:raw="The header signature.">헤더 서명입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ParameterTypes">
      <summary vsli:raw="Gets the method's parameter types.">메서드의 매개 변수 형식을 가져옵니다.</summary>
      <returns vsli:raw="An immutable collection of parameter types.">매개 변수 형식에 대 한 변경할 수 없는 컬렉션입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.RequiredParameterCount">
      <summary vsli:raw="Gets the number of parameters that are required for the method.">메서드에 필요한 매개 변수의 수를 가져옵니다.</summary>
      <returns vsli:raw="The number of required parameters.">필수 매개 변수의 수입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ReturnType">
      <summary vsli:raw="Gets the return type of the method.">메서드의 반환 형식을 가져옵니다.</summary>
      <returns vsli:raw="The return type.">반환 형식입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecification" />
    <member name="M:System.Reflection.Metadata.MethodSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodSpecification.Method">
      <summary vsli:raw="Gets a &lt;see langword=&quot;MethodDef&quot; /&gt; or &lt;see langword=&quot;MemberRef&quot; /&gt; handle specifying which generic method this instance refers to (that is, which generic method it is an instantiation of).">이 인스턴스가 참조하는 제네릭 메서드(즉, 인스턴스화인 제네릭 메서드)를 지정하는 <see langword="MethodDef" /> 또는 <see langword="MemberRef" /> 핸들을 가져옵니다.</summary>
      <returns vsli:raw="A &lt;see langword=&quot;MethodDef&quot; /&gt; or &lt;see langword=&quot;MemberRef&quot; /&gt; handle specifying which generic method this instance refers to.">이 인스턴스가 참조 하는 제네릭 메서드를 지정 하는 <see langword="MethodDef" /> 또는 <see langword="MemberRef" /> 핸들입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSpecification.Signature">
      <summary vsli:raw="Gets a handle to the signature blob.">시그니처 Blob에 대한 핸들을 가져옵니다.</summary>
      <returns vsli:raw="A handle to the signature blob.">서명 blob에 대 한 핸들입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MethodSpecificationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Equality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Inequality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.ModuleDefinition" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.BaseGenerationId" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Generation" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.GenerationId" />
    <member name="M:System.Reflection.Metadata.ModuleDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Mvid" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Name" />
    <member name="T:System.Reflection.Metadata.ModuleDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ModuleDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Equality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Inequality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.ModuleReference" />
    <member name="M:System.Reflection.Metadata.ModuleReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleReference.Name" />
    <member name="T:System.Reflection.Metadata.ModuleReferenceHandle" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ModuleReferenceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Equality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Inequality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.NamespaceDefinition" />
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.ExportedTypes">
      <summary vsli:raw="Gets all exported types that reside directly in a namespace.">네임스페이스에 직접 상주하는 모든 내보낸 형식을 가져옵니다.</summary>
      <returns vsli:raw="An immutable array of exported type handles.">내보낸 형식 핸들의 변경할 수 없는 배열입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Name">
      <summary vsli:raw="Gets the unqualified name of the namespace definition.">네임스페이스 정의의 정규화되지 않은 이름을 가져옵니다.</summary>
      <returns vsli:raw="The unqualified name of the namespace definition.">네임 스페이스 정의의 정규화 되지 않은 이름입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.NamespaceDefinitions">
      <summary vsli:raw="Gets the namespace definitions that are direct children of the current namespace definition.">현재 네임스페이스 정의의 직접 자식인 네임스페이스 정의를 가져옵니다.</summary>
      <returns vsli:raw="An immutable array of namespace definitions that are direct children of the current namespace definition.">현재 네임 스페이스 정의의 직계 자식인 네임 스페이스 정의의 변경할 수 없는 배열입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Parent">
      <summary vsli:raw="Gets the parent namespace.">부모 네임스페이스를 가져옵니다.</summary>
      <returns vsli:raw="The parent namespace.">부모 네임 스페이스입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.TypeDefinitions">
      <summary vsli:raw="Gets all type definitions that reside directly in a namespace.">네임스페이스에 직접 상주하는 모든 형식 정의를 가져옵니다.</summary>
      <returns vsli:raw="An immutable array of type definition handles.">형식 정의 핸들의 변경할 수 없는 배열입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.NamespaceDefinitionHandle">
      <summary vsli:raw="Provides a handle to a namespace definition.">네임스페이스 정의에 대한 핸들을 제공합니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Equality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.NamespaceDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Implicit(System.Reflection.Metadata.NamespaceDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Inequality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Parameter" />
    <member name="P:System.Reflection.Metadata.Parameter.Attributes" />
    <member name="M:System.Reflection.Metadata.Parameter.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.Parameter.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.Parameter.GetMarshallingDescriptor" />
    <member name="P:System.Reflection.Metadata.Parameter.Name" />
    <member name="P:System.Reflection.Metadata.Parameter.SequenceNumber" />
    <member name="T:System.Reflection.Metadata.ParameterHandle" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Reflection.Metadata.ParameterHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ParameterHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Equality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Inequality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection">
      <summary vsli:raw="Contains a collection of parameters of a specified method.">지정된 메서드의 매개 변수 컬렉션을 포함합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ParameterHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.PEReaderExtensions" />
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader)">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; from a &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.MetadataReader" />에서 <see cref="T:System.Reflection.PortableExecutable.PEReader" />를 가져옵니다.</summary>
      <param name="peReader" vsli:raw="The current &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; instance.">현재 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 인스턴스입니다.</param>
      <returns vsli:raw="A metadata reader.">메타데이터 판독기입니다.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peReader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peReader" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is big-endian.">현재 플랫폼은 big-endian입니다.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">기본 스트림에서 읽는 동안 IO 오류가 발생했습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary vsli:raw="Gets a metadata reader with the specified metadata reading configuration from a &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt;.">
        <see cref="T:System.Reflection.PortableExecutable.PEReader" />에서 지정된 메타데이터 읽기 구성을 사용하여 메타데이터 판독기를 가져옵니다.</summary>
      <param name="peReader" vsli:raw="The current &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; instance.">현재 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 인스턴스입니다.</param>
      <param name="options" vsli:raw="An enumeration value indicating the metadata reading configuration.">메타데이터 읽기 구성을 나타내는 열거형 값입니다.</param>
      <returns vsli:raw="A metadata reader with the specified metadata reading configuration.">지정된 메타데이터 읽기 구성을 사용하는 메타데이터 판독기입니다.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peReader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peReader" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is big-endian.">현재 플랫폼은 big-endian입니다.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">기본 스트림에서 읽는 동안 IO 오류가 발생했습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary vsli:raw="Gets a metadata reader with the specified metadata reading configuration and encoding configuration from a &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt;.">
        <see cref="T:System.Reflection.PortableExecutable.PEReader" />에서 지정된 메타데이터 읽기 구성 및 인코딩 구성을 사용하여 메타데이터 판독기를 가져옵니다.</summary>
      <param name="peReader" vsli:raw="The current &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; instance.">현재 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 인스턴스입니다.</param>
      <param name="options" vsli:raw="An enumeration value indicating the metadata reading configuration.">메타데이터 읽기 구성을 나타내는 열거형 값입니다.</param>
      <param name="utf8Decoder" vsli:raw="A metadata string decoder with the encoding configuration.">인코딩 구성을 사용하는 메타데이터 문자열 디코더입니다.</param>
      <returns vsli:raw="&amp;gt;A metadata reader with the specified metadata reading configuration and encoding configuration.">&gt;지정된 메타데이터 읽기 구성 및 인코딩 구성을 사용하는 메타데이터 판독기입니다.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peReader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peReader" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The encoding of &lt;paramref name=&quot;utf8Decoder&quot; /&gt; is not &lt;see cref=&quot;T:System.Text.UTF8Encoding&quot; /&gt;.">
        <paramref name="utf8Decoder" />의 인코딩은 <see cref="T:System.Text.UTF8Encoding" />이 아닙니다.</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is big-endian.">현재 플랫폼은 big-endian입니다.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">기본 스트림에서 읽는 동안 IO 오류가 발생했습니다.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMethodBody(System.Reflection.PortableExecutable.PEReader,System.Int32)">
      <summary vsli:raw="Returns a body block of a method with the specified Relative Virtual Address (RVA).">RVA(Relevant Virtual Address)가 지정된 메서드의 본문 블록을 반환합니다.</summary>
      <param name="peReader" vsli:raw="The current &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; instance.">현재 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 인스턴스입니다.</param>
      <param name="relativeVirtualAddress" vsli:raw="The Relative Virtual Address (RVA).">RVA(Relevant Virtual Address)입니다.</param>
      <returns vsli:raw="A method block body instance.">메서드 블록 본문 인스턴스입니다.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peReader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peReader" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The body is not found in the metadata or is invalid.">메타데이터에 본문이 없거나 본문이 잘못되었습니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The section where the method is stored is not available.">메서드가 저장되는 섹션을 사용할 수 없습니다.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error occurred while reading from the underlying stream.">기본 스트림에서 읽는 동안 IO 오류가 발생했습니다.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveSerializationTypeCode">
      <summary vsli:raw="Specifies constants that define the type codes used to encode types of primitive values in a &lt;see cref=&quot;T:System.Reflection.Metadata.CustomAttribute&quot; /&gt; value blob.">
        <see cref="T:System.Reflection.Metadata.CustomAttribute" /> 값 Blob에서 기본 값의 형식을 인코딩하는 데 사용되는 형식 코드를 정의하는 상수를 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Boolean">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; type.">
        <see cref="T:System.Boolean" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Byte">
      <summary vsli:raw="An unsigned 1-byte integer type.">부호 없는 1바이트 정수 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Char">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Char&quot; /&gt; type.">
        <see cref="T:System.Char" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Double">
      <summary vsli:raw="An 8-byte floating point type.">8바이트 부동 소수점 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int16">
      <summary vsli:raw="A signed 2-byte integer type.">부호 있는 2바이트 정수 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int32">
      <summary vsli:raw="A signed 4-byte integer type.">부호 있는 4바이트 정수 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int64">
      <summary vsli:raw="A signed 8-byte integer type.">부호 있는 8바이트 정수 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.SByte">
      <summary vsli:raw="A signed 1-byte integer type.">부호 있는 1바이트 정수 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Single">
      <summary vsli:raw="A 4-byte floating point type.">4바이트 부동 소수점 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.String">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; type.">
        <see cref="T:System.String" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt16">
      <summary vsli:raw="An unsigned 2-byte integer type.">부호 없는 2바이트 정수 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt32">
      <summary vsli:raw="An unsigned 4-byte integer type.">부호 없는 4바이트 정수 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt64">
      <summary vsli:raw="An unsigned 8-byte integer type.">부호 없는 8바이트 정수 형식입니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveTypeCode">
      <summary vsli:raw="Specifies constants that define primitive types found in metadata signatures.">메타데이터 서명에 있는 기본 형식을 정의하는 상수를 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Boolean">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; type.">
        <see cref="T:System.Boolean" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Byte">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Byte&quot; /&gt; type.">
        <see cref="T:System.Byte" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Char">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Char&quot; /&gt; type.">
        <see cref="T:System.Char" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Double">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Double&quot; /&gt; type.">
        <see cref="T:System.Double" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int16">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.Int16&quot; /&gt; type.">
        <see cref="T:System.Int16" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int32">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.Int32&quot; /&gt; type.">
        <see cref="T:System.Int32" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int64">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.Int64&quot; /&gt; type.">
        <see cref="T:System.Int64" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.IntPtr">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; type.">
        <see cref="T:System.IntPtr" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Object">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.Object&quot; /&gt; type.">
        <see cref="T:System.Object" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.SByte">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.SByte&quot; /&gt; type.">
        <see cref="T:System.SByte" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Single">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Single&quot; /&gt; type.">
        <see cref="T:System.Single" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.String">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; type.">
        <see cref="T:System.String" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference">
      <summary vsli:raw="A typed reference.">형식화된 참조입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt16">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.UInt16&quot; /&gt; type.">
        <see cref="T:System.UInt16" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt32">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.UInt32&quot; /&gt; type.">
        <see cref="T:System.UInt32" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt64">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.UInt64&quot; /&gt; type.">
        <see cref="T:System.UInt64" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UIntPtr">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.UIntPtr&quot; /&gt; type.">
        <see cref="T:System.UIntPtr" /> 형식입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Void">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Void&quot; /&gt; type.">
        <see cref="T:System.Void" /> 형식입니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PropertyAccessors" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Getter" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Others" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Setter" />
    <member name="T:System.Reflection.Metadata.PropertyDefinition" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Attributes" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetDefaultValue" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Equality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Inequality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection" />
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#PropertyDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ReservedBlob`1">
      <summary vsli:raw="Represents a handle and a corresponding blob on a metadata heap that was reserved for future content update.">후속 콘텐츠 업데이트를 위해 예약된 메타데이터 힙의 핸들 및 해당 blob을 나타냅니다.</summary>
      <typeparam name="THandle" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Content" />
    <member name="M:System.Reflection.Metadata.ReservedBlob`1.CreateWriter">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Reflection.Metadata.BlobWriter&quot; /&gt; to be used to update the content.">콘텐츠를 업데이트하는 데 사용되는 <see cref="T:System.Reflection.Metadata.BlobWriter" />를 반환합니다.</summary>
      <returns vsli:raw="A blob writer to be used to update the content.">콘텐츠를 업데이트하는 데 사용되는 Blob 작성기를 반환합니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Handle">
      <summary vsli:raw="Gets the reserved blob handle.">예약된 Blob 핸들을 가져옵니다.</summary>
      <returns vsli:raw="The reserved bloc handle.">예약 된 lsas 핸들입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SequencePoint" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Document" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndLine" />
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Object)">
      <param name="obj" vsli:raw="The object to compare with the current object." />
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Reflection.Metadata.SequencePoint)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.GetHashCode" />
    <member name="F:System.Reflection.Metadata.SequencePoint.HiddenLine" />
    <member name="P:System.Reflection.Metadata.SequencePoint.IsHidden" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Offset" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartLine" />
    <member name="T:System.Reflection.Metadata.SequencePointCollection" />
    <member name="T:System.Reflection.Metadata.SequencePointCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.MoveNext" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.Reset" />
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#SequencePoint}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.SerializationTypeCode">
      <summary vsli:raw="Specifies type codes used to encode the types of values in a &lt;see cref=&quot;T:System.Reflection.Metadata.CustomAttributeValue`1&quot; /&gt; blob.">
        <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" /> Blob에서 값의 형식을 인코딩하는 데 사용되는 형식 코드를 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Boolean">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Boolean&quot; /&gt;.">
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Boolean" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Byte">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Byte&quot; /&gt;.">
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Byte" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Char">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Char&quot; /&gt;.">
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Char" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Double">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Double&quot; /&gt;.">
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Double" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Enum">
      <summary vsli:raw="The attribute argument is an Enum instance.">특성 인수는 Enum 인스턴스입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int16">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Int16&quot; /&gt;.">
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int16" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int32">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Int32&quot; /&gt;.">
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int32" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int64">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Int64&quot; /&gt;.">
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int64" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Invalid">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Invalid&quot; /&gt;.">
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SByte">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.SByte&quot; /&gt;.">
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SByte" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Single">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Single&quot; /&gt;.">
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Single" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.String">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.String&quot; /&gt;.">
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.String" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SZArray">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.SZArray&quot; /&gt;.">
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SZArray" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.TaggedObject">
      <summary vsli:raw="The attribute argument is &quot;boxed&quot; (passed to a parameter, field, or property of type object) and carries type information in the attribute blob.">특성 인수는 "boxed"(매개 변수, 필드 또는 형식 개체의 속성에 전달됨)되고 특성 Blob에서 형식 정보를 제공합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Type">
      <summary vsli:raw="The attribute argument is a &lt;see cref=&quot;T:System.Type&quot; /&gt; instance.">특성 인수는 <see cref="T:System.Type" /> 인스턴스입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt16">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.UInt16&quot; /&gt;.">
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt16" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt32">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.UInt32&quot; /&gt;.">
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt32" />에 해당하는 값입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt64">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.UInt64&quot; /&gt;.">
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt64" />에 해당하는 값입니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureAttributes">
      <summary vsli:raw="Specifies additional flags that can be applied to method signatures. The underlying values of the fields in this type correspond to the representation in the leading signature byte represented by a &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure.">메서드 서명에 적용할 수 있는 추가 플래그를 지정합니다. 이 형식에서 필드의 기본 값은 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 구조체에서 나타내는 선행 서명 바이트의 표현에 해당합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis">
      <summary vsli:raw="Indicates the first explicitly declared parameter that represents the instance pointer.">인스턴스 포인터를 나타내는 명시적으로 선언된 첫 번째 매개 변수를 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Generic">
      <summary vsli:raw="A generic method.">제네릭 메서드</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Instance">
      <summary vsli:raw="&lt;para&gt;An instance method.&lt;/para&gt;&lt;para&gt;The Ecma 335 CLI Specification refers to this flag as &lt;see langword=&quot;HAS_THIS&quot; /&gt;.&lt;/para&gt;">인스턴스 메서드</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.None">
      <summary vsli:raw="No flags.">플래그가 없습니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureCallingConvention">
      <summary vsli:raw="Specifies how arguments in a given signature are passed from the caller to the callee. The underlying values of the fields in this type correspond to the representation in the leading signature byte represented by a &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure.">지정된 서명의 인수를 호출자에서 호출 수신자로 전달하는 방법을 지정합니다. 이 형식에서 필드의 기본 값은 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 구조체에서 나타내는 선행 서명 바이트의 표현에 해당합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.CDecl">
      <summary vsli:raw="An unmanaged C/C++ style calling convention where the call stack is cleaned by the caller.">호출 스택이 호출자에 의해 정리되는 관리되지 않는 C/C++ 스타일 호출 규칙입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.Default">
      <summary vsli:raw="A managed calling convention with a fixed-length argument list.">고정 길이 인수 목록을 포함하는 관리되는 호출 규칙입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.FastCall">
      <summary vsli:raw="An unmanaged calling convention where arguments are passed in registers when possible.">가능한 경우 인수를 레지스터로 전달하는 관리되지 않는 호출 규칙입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.StdCall">
      <summary vsli:raw="An unmanaged calling convention where the call stack is cleaned up by the callee.">호출 스택이 호출 수신자에 의해 정리되는 관리되지 않는 호출 규칙입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.ThisCall">
      <summary vsli:raw="An unmanaged C++ style calling convention for calling instance member functions with a fixed argument list.">고정 인수 목록을 사용하여 인스턴스 멤버 함수를 호출하기 위한 관리되지 않는 C++ 스타일 호출 규칙입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.VarArgs">
      <summary vsli:raw="A managed calling convention for passing extra arguments.">추가 인수를 전달하기 위한 관리되는 호출 규칙입니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureHeader">
      <summary vsli:raw="Represents the signature characteristics specified by the leading byte of signature blobs.">서명 Blob의 선행 바이트에 의해 지정된 서명 특징을 나타냅니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Byte)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure using the specified byte value.">지정된 바이트 값을 사용하여 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
      <param name="rawValue" vsli:raw="The byte.">바이트</param>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Reflection.Metadata.SignatureKind,System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.SignatureAttributes)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure using the specified signature kind, calling convention and signature attributes.">지정된 서명 종류, 호출 규칙 및 서명 특성을 사용하여 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
      <param name="kind" vsli:raw="The signature kind.">시그니처 종류</param>
      <param name="convention" vsli:raw="The calling convention.">호출 규칙.</param>
      <param name="attributes" vsli:raw="The signature attributes.">서명 특성</param>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Attributes">
      <summary vsli:raw="Gets the signature attributes.">서명 특성을 가져옵니다.</summary>
      <returns vsli:raw="The attributes.">특성입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.CallingConvention">
      <summary vsli:raw="Gets the calling convention.">호출 규칙을 가져옵니다.</summary>
      <returns vsli:raw="The calling convention.">호출 규칙.</returns>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask">
      <summary vsli:raw="Gets the mask value for the calling convention or signature kind. The default &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask&quot; /&gt; value is 15 (0x0F).">호출 규칙 또는 서명 종류에 대한 마스크 값을 가져옵니다. 기본 <see cref="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask" /> 값은 15 (0x0F)입니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Object)">
      <summary vsli:raw="Compares the specified object with this &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; for equality.">지정된 개체와 이 <see cref="T:System.Reflection.Metadata.SignatureHeader" />가 같은지 비교합니다.</summary>
      <param name="obj" vsli:raw="The object to compare.">비교할 개체입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the objects are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">개체가 동일하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Reflection.Metadata.SignatureHeader)">
      <summary vsli:raw="Compares two &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; values for equality.">두 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 값이 같은지 여부를 비교합니다.</summary>
      <param name="other" vsli:raw="The value to compare.">비교할 값입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the values are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">값이 동일하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.GetHashCode">
      <summary vsli:raw="Gets a hash code for the current object.">현재 개체의 해시 코드를 가져옵니다.</summary>
      <returns vsli:raw="A hash code for the current object.">현재 개체의 해시 코드입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.HasExplicitThis">
      <summary vsli:raw="Gets a value that indicates whether this &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure has the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis&quot; /&gt; signature attribute.">이 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 구조체에 <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" /> 서명 특성이 있는지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis&quot; /&gt; attribute is present; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />특성이 있으면이 고, <see langword="false" />그렇지 않으면입니다. <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" /></returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsGeneric">
      <summary vsli:raw="Gets a value that indicates whether this &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure has the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.Generic&quot; /&gt; signature attribute.">이 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 구조체에 <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" /> 서명 특성이 있는지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.Generic&quot; /&gt; attribute is present; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />특성이 있으면이 고, <see langword="false" />그렇지 않으면입니다. <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" /></returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsInstance">
      <summary vsli:raw="Gets a value that indicates whether this &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure has the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.Instance&quot; /&gt; signature attribute.">이 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 구조체에 <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" /> 서명 특성이 있는지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.Instance&quot; /&gt; attribute is present; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />특성이 있으면이 고, <see langword="false" />그렇지 않으면입니다. <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" /></returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Kind">
      <summary vsli:raw="Gets the signature kind.">시그니처 종류를 가져옵니다.</summary>
      <returns vsli:raw="The signature kind.">시그니처 종류</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Equality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary vsli:raw="Compares two &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; values for equality.">두 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 값이 같은지 여부를 비교합니다.</summary>
      <param name="left" vsli:raw="The first value to compare.">비교할 첫 번째 값입니다.</param>
      <param name="right" vsli:raw="The second value to compare.">비교할 두 번째 값입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the values are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">값이 동일하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Inequality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary vsli:raw="Determines whether two &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; values are unequal.">두 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 값이 서로 같지 않은지 확인합니다.</summary>
      <param name="left" vsli:raw="The first value to compare.">비교할 첫 번째 값입니다.</param>
      <param name="right" vsli:raw="The second value to compare.">비교할 두 번째 값입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the values are unequal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">값이 같지 않으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.RawValue">
      <summary vsli:raw="Gets the raw value of the header byte.">헤더 바이트의 원시 값을 가져옵니다.</summary>
      <returns vsli:raw="The raw value of the header byte.">헤더 바이트의 원시 값입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.ToString">
      <summary vsli:raw="Returns a string that represents the current object.">현재 개체를 나타내는 문자열을 반환합니다.</summary>
      <returns vsli:raw="A string that represents the current object.">현재 개체를 나타내는 문자열입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureKind">
      <summary vsli:raw="Specifies the signature kind. The underlying values of the fields in this type correspond to the representation in the leading signature byte represented by a &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure.">서명 종류를 지정합니다. 이 형식에서 필드의 기본 값은 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 구조체에서 나타내는 선행 서명 바이트의 표현에 해당합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Field">
      <summary vsli:raw="A field signature.">필드 시그니처입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.LocalVariables">
      <summary vsli:raw="A local variables signature.">지역 변수 서명입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Method">
      <summary vsli:raw="A method reference, method definition, or standalone method signature.">메서드 참조, 메서드 정의 또는 독립 실행형 메서드 서명입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.MethodSpecification">
      <summary vsli:raw="A method specification signature.">메서드 사양 서명입니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Property">
      <summary vsli:raw="A property signature.">속성 서명입니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeCode">
      <summary vsli:raw="Specifies constants that define type codes used in signature encoding.">서명 인코딩에서 사용되는 형식 코드를 정의하는 상수를 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Array">
      <summary vsli:raw="Represents a generalized &lt;see cref=&quot;T:System.Array&quot; /&gt; in signatures.">서명에서 일반화된 <see cref="T:System.Array" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Boolean">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.Boolean&quot; /&gt; in signatures.">서명에서 <see cref="T:System.Boolean" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.ByReference">
      <summary vsli:raw="Represents managed pointers (byref return values and parameters) in signatures. It is followed in the blob by the signature encoding of the underlying type.">서명에서 관리되는 포인터를(byref 반환 값 및 매개 변수)를 나타냅니다. 기본 형식을 인코딩하는 서명별로 Blob에서 이어집니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Byte">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.Byte&quot; /&gt; in signatures.">서명에서 <see cref="T:System.Byte" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Char">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.Char&quot; /&gt; in signatures.">서명에서 <see cref="T:System.Char" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Double">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.Double&quot; /&gt; in signatures.">서명에서 <see cref="T:System.Double" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.FunctionPointer">
      <summary vsli:raw="Represents function pointer types in signatures.">서명에서 함수 포인터 형식을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericMethodParameter">
      <summary vsli:raw="Represents a generic method parameter used within a signature.">서명 내에서 사용되는 제네릭 메서드 매개 변수를 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeInstance">
      <summary vsli:raw="Represents the instantiation of a generic type in signatures.">서명에서 제네릭 형식의 인스턴스화를 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeParameter">
      <summary vsli:raw="Represents a generic type parameter used within a signature.">서명 내에서 사용되는 제네릭 형식 매개 변수를 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int16">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.Int16&quot; /&gt; in signatures.">서명에서 <see cref="T:System.Int16" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int32">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.Int32&quot; /&gt; in signatures.">서명에서 <see cref="T:System.Int32" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int64">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.Int64&quot; /&gt; in signatures.">서명에서 <see cref="T:System.Int64" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.IntPtr">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; in signatures.">서명에서 <see cref="T:System.IntPtr" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Invalid">
      <summary vsli:raw="Represents an invalid or uninitialized type code. It will not appear in valid signatures.">잘못되었거나 초기화되지 않은 형식 코드를 나타냅니다. 유효한 서명에서 나타나지 않습니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Object">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.Object&quot; /&gt; in signatures.">서명에서 <see cref="T:System.Object" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.OptionalModifier">
      <summary vsli:raw="Represents a custom modifier applied to a type within a signature that the caller can ignore.">호출자가 무시할 수 있는 서명 내의 형식에 적용되는 사용자 지정 한정자를 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pinned">
      <summary vsli:raw="Represents a local variable that is pinned by garbage collector.">가비지 수집기에서 고정한 지역 변수를 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pointer">
      <summary vsli:raw="Represents an unmanaged pointer in signatures. It is followed in the blob by the signature encoding of the underlying type.">서명에서 관리되지 않는 포인터를 나타냅니다. 기본 형식을 인코딩하는 서명별로 Blob에서 이어집니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.RequiredModifier">
      <summary vsli:raw="Represents a custom modifier applied to a type within a signature that the caller must understand.">호출자가 이해해야 하는 서명 내의 형식에 적용되는 사용자 지정 한정자를 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SByte">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.SByte&quot; /&gt; in signatures.">서명에서 <see cref="T:System.SByte" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Sentinel">
      <summary vsli:raw="Represents a marker to indicate the end of fixed arguments and the beginning of variable arguments.">고정 인수의 끝과 가변 인수의 시작을 나타내는 표식을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Single">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.Single&quot; /&gt; in signatures.">서명에서 <see cref="T:System.Single" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.String">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.String&quot; /&gt; in signatures.">서명에서 <see cref="T:System.String" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SZArray">
      <summary vsli:raw="Represents a single dimensional &lt;see cref=&quot;T:System.Array&quot; /&gt; with a lower bound of 0.">낮은 경계가 0인 단일 차원 <see cref="T:System.Array" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypedReference">
      <summary vsli:raw="Represents a typed reference in signatures.">서명에서 형식화된 참조를 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypeHandle">
      <summary vsli:raw="Precedes a type &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; in signatures. In raw metadata, this is encoded as either ELEMENT_TYPE_CLASS (0x12) for reference types or ELEMENT_TYPE_VALUETYPE (0x11) for value types. This is collapsed to a single code because Windows Runtime projections can project from class to value type or vice-versa, and the raw code is misleading in those cases.">서명에서 <see cref="T:System.Reflection.Metadata.EntityHandle" /> 형식의 앞에 옵니다. 원시 메타데이터에서는 참조 형식의 경우 ELEMENT_TYPE_CLASS(0x12)로 인코딩되거나 값 형식의 경우 ELEMENT_TYPE_VALUETYPE(0x11)으로 인코딩됩니다. Windows 런타임 프로젝션이 클래스에서 값 형식 또는 반대로 투사되므로 이 값은 단일 코드로 축소되며, 이 경우에 원시 코드는 잘못 출력됩니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt16">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; in signatures.">서명에서 <see cref="T:System.UInt16" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt32">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; in signatures.">서명에서 <see cref="T:System.UInt32" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt64">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; in signatures.">서명에서 <see cref="T:System.UInt64" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UIntPtr">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.UIntPtr&quot; /&gt; in signatures.">서명에서 <see cref="T:System.UIntPtr" />을 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Void">
      <summary vsli:raw="Represents &lt;see cref=&quot;T:System.Void&quot; /&gt; in signatures.">서명에서 <see cref="T:System.Void" />을 나타냅니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeKind">
      <summary vsli:raw="Indicates the type definition of the signature.">서명의 형식 정의를 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Class">
      <summary vsli:raw="The type definition or reference refers to a class.">형식 정의 또는 참조는 클래스를 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Unknown">
      <summary vsli:raw="It isn't known in the current context if the type reference or definition is a class or value type.">형식 참조 또는 정의가 클래스 또는 값 형식이면 현재 컨텍스트에서 알려져 있지 않습니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.ValueType">
      <summary vsli:raw="The type definition or reference refers to a value type.">형식 정의 또는 참조는 값 형식을 나타냅니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignature" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeLocalSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetKind">
      <summary vsli:raw="Determines the kind of signature, which can be &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureKind.Method&quot; /&gt; or &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureKind.LocalVariables&quot; /&gt;.">서명의 종류를 결정합니다. <see cref="F:System.Reflection.Metadata.SignatureKind.Method" /> 또는 <see cref="F:System.Reflection.Metadata.SignatureKind.LocalVariables" />입니다.</summary>
      <returns vsli:raw="An enumeration value that indicates the signature kind.">서명 종류를 나타내는 열거형 값입니다.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The signature is invalid.">서명이 잘못되었습니다.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.StandaloneSignature.Signature">
      <summary vsli:raw="Gets a handle to the signature blob.">시그니처 Blob에 대한 핸들을 가져옵니다.</summary>
      <returns vsli:raw="A handle to the signature blob.">서명 blob에 대 한 핸들입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignatureHandle" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Equality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Inequality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignatureKind">
      <summary vsli:raw="Indicates whether a &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignature&quot; /&gt; represents a standalone method or local variable signature.">
        <see cref="T:System.Reflection.Metadata.StandaloneSignature" />가 독립 실행형 메서드 또는 지역 변수 시그니처를 나타내는지를 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.LocalVariables">
      <summary vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReference&quot; /&gt; references a local variable signature.">
        <see cref="T:System.Reflection.Metadata.MemberReference" />는 지역 변수 서명을 참조합니다.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.Method">
      <summary vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignature&quot; /&gt; represents a standalone method signature.">
        <see cref="T:System.Reflection.Metadata.StandaloneSignature" />는 독립 실행형 메서드 서명을 나타냅니다.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StringHandle" />
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Reflection.Metadata.StringHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.StringHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.StringHandle.op_Equality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StringHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Implicit(System.Reflection.Metadata.StringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Inequality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinition" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.BaseType">
      <summary vsli:raw="Gets the base type of the type definition: either &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;.">형식 정의의 기본 형식을 가져옵니다. <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 또는 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />입니다.</summary>
      <returns vsli:raw="The base type of the type definition.">형식 정의의 기본 형식입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclaringType">
      <summary vsli:raw="Returns the enclosing type of a specified nested type.">지정된 중첩 형식의 바깥쪽 형식을 반환합니다.</summary>
      <returns vsli:raw="The enclosing type of the specified nested type, or a handle a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the type is not nested.">지정된 중첩 형식의 바깥쪽 형식이거나, 형식이 중첩되지 않는 경우 <see cref="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" /> 속성이 <see langword="true" />인 핸들입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetEvents" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetFields" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetInterfaceImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetLayout" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethodImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethods" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetNestedTypes">
      <summary vsli:raw="Returns an array of types nested in the specified type.">지정된 형식으로 중첩된 형식 배열을 반환합니다.</summary>
      <returns vsli:raw="An immutable array of type definition handles that represent types nested in the specified type.">지정된 형식으로 중첩된 형식을 나타내는 변경할 수 없는 형식 정의 핸들 배열입니다.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetProperties" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.IsNested">
      <summary vsli:raw="Gets a value that indicates whether this is a nested type.">중첩된 형식인지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if it is a nested type, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />중첩 형식이 면이 고, <see langword="false" /> 그렇지 않으면입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Name">
      <summary vsli:raw="Gets the name of the type.">형식의 이름을 가져옵니다.</summary>
      <returns vsli:raw="The name of the type.">형식의 이름입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Namespace">
      <summary vsli:raw="Gets the full name of the namespace where the type is defined.">형식이 정의된 네임스페이스의 전체 이름을 가져옵니다.</summary>
      <returns vsli:raw="The full name of the namespace where the type is defined, or a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.StringHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the type is nested or defined in a root namespace.">형식이 정의 된 네임 스페이스의 전체 이름 이거나, 형식이 중첩 되거나 루트 네임 스페이스 <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /> 에서 정의 <see langword="true" /> 된 경우 해당 속성이 인 핸들입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.NamespaceDefinition">
      <summary vsli:raw="Gets the definition handle of the namespace where the type is defined.">형식이 정의된 네임스페이스의 정의 핸들을 가져옵니다.</summary>
      <returns vsli:raw="The definition handle of the namespace where the type is defined, or a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;  if the type is nested or defined in a root namespace.">형식이 정의 된 네임 스페이스의 정의 핸들 이거나, 형식이 중첩 되거나 루트 네임 스페이스 <see cref="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" /> 에서 정의 <see langword="true" /> 된 경우 해당 속성이 인 핸들입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Equality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Inequality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection">
      <summary vsli:raw="Contains a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; instances.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 인스턴스 컬렉션을 포함합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.TypeLayout" />
    <member name="M:System.Reflection.Metadata.TypeLayout.#ctor(System.Int32,System.Int32)">
      <param name="size" vsli:raw="" />
      <param name="packingSize" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeLayout.IsDefault" />
    <member name="P:System.Reflection.Metadata.TypeLayout.PackingSize" />
    <member name="P:System.Reflection.Metadata.TypeLayout.Size" />
    <member name="T:System.Reflection.Metadata.TypeReference" />
    <member name="P:System.Reflection.Metadata.TypeReference.Name">
      <summary vsli:raw="Gets the name of the target type.">대상 형식의 이름을 가져옵니다.</summary>
      <returns vsli:raw="The name of the target type.">대상 형식의 이름입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.Namespace">
      <summary vsli:raw="Gets the full name of the namespace where the target type is defined.">대상 형식이 정의된 네임스페이스의 전체 이름을 가져옵니다.</summary>
      <returns vsli:raw="The full name of the namespace where the target type is defined, or a handle whose the &lt;see cref=&quot;P:System.Reflection.Metadata.StringHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the type is nested or defined in a root namespace.">대상 형식이 정의 된 네임 스페이스의 전체 이름 이거나, 형식이 중첩 되거나 루트 네임 스페이스에서 정의 된 경우 <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /> 속성이 <see langword="true" /> 되는 핸들입니다.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.ResolutionScope">
      <summary vsli:raw="Gets the resolution scope in which the target type is defined and is uniquely identified by the specified &lt;see cref=&quot;P:System.Reflection.Metadata.TypeReference.Namespace&quot; /&gt; and &lt;see cref=&quot;P:System.Reflection.Metadata.TypeReference.Name&quot; /&gt;.">지정된 <see cref="P:System.Reflection.Metadata.TypeReference.Namespace" /> 및 <see cref="P:System.Reflection.Metadata.TypeReference.Name" />에 의해 대상 형식이 정의되고 고유하게 식별되는 결정 범위를 가져옵니다.</summary>
      <returns vsli:raw="The resolution scope in which the target type is uniquely defined.">대상 형식이 고유 하 게 정의 되는 해상도 범위입니다.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandle" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.TypeReferenceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Equality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Inequality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection">
      <summary vsli:raw="Contains a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; instances.">
        <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 인스턴스 컬렉션을 포함합니다.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeReferenceHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.TypeSpecification" />
    <member name="M:System.Reflection.Metadata.TypeSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.TypeSpecification.Signature" />
    <member name="T:System.Reflection.Metadata.TypeSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.TypeSpecificationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Equality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Inequality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.UserStringHandle">
      <summary vsli:raw="Represents a handle to the user string heap.">사용자 문자열 힙에 대한 핸들을 나타냅니다.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Reflection.Metadata.UserStringHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.UserStringHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Equality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.UserStringHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Implicit(System.Reflection.Metadata.UserStringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Inequality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.MethodImportAttributes" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionCDecl" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionFastCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionStdCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionThisCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionWinApi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAnsi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAuto" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetUnicode" />
    <member name="F:System.Reflection.MethodImportAttributes.ExactSpelling" />
    <member name="F:System.Reflection.MethodImportAttributes.None" />
    <member name="F:System.Reflection.MethodImportAttributes.SetLastError" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharMask" />
    <member name="T:System.Reflection.MethodSemanticsAttributes" />
    <member name="F:System.Reflection.MethodSemanticsAttributes.Adder">
      <summary vsli:raw="&lt;para&gt;Used to add a handler for an event. Corresponds to the &lt;see langword=&quot;AddOn&quot; /&gt; flag in the Ecma 335 CLI specification.&lt;/para&gt;&lt;para&gt;CLS-compliant adders are named the with &lt;see langword=&quot;add_&quot; /&gt; prefix.&lt;/para&gt;">이벤트에 대한 처리기를 추가하는 데 사용됩니다. Ecma 335 CLI 사양에서 <see langword="AddOn" /> 플래그에 해당합니다.
<see langword="add_" /> 접두사를 사용하여 CLS 규격 adder의 이름을 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Getter">
      <summary vsli:raw="&lt;para&gt;Reads the value of the property.&lt;/para&gt;&lt;para&gt;CLS-compliant getters are named with get_ prefix.&lt;/para&gt;">속성의 값을 읽습니다.
`get_` 접두사를 사용하여 CLS 규격 getter의 이름을 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Other">
      <summary vsli:raw="Other method for a property (not a getter or setter) or an event (not an adder, remover, or raiser).">속성(getter 또는 setter 아님) 또는 이벤트(adder, remover 또는 raiser 아님)에 대한 기타 메서드입니다.</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Raiser">
      <summary vsli:raw="&lt;para&gt;Used to indicate that an event has occurred. Corresponds to the &lt;see langword=&quot;Fire&quot; /&gt; flag in the Ecma 335 CLI specification.&lt;/para&gt;&lt;para&gt; CLS-compliant raisers are named with the &lt;see langword=&quot;raise_&quot; /&gt; prefix.&lt;/para&gt;">이벤트가 발생했음을 나타내는 데 사용됩니다. Ecma 335 CLI 사양에서 <see langword="Fire" /> 플래그에 해당합니다.
 <see langword="raise_" /> 접두사를 사용하여 CLS 규격 raiser의 이름을 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Remover">
      <summary vsli:raw="&lt;para&gt;Used to remove a handler for an event. Corresponds to the &lt;see langword=&quot;RemoveOn&quot; /&gt; flag in the Ecma 335 CLI specification.&lt;/para&gt;&lt;para&gt;CLS-compliant removers are named with the &lt;see langword=&quot;remove_&quot; /&gt; prefix.&lt;/para&gt;">이벤트에 대한 처리기를 제거하는 데 사용됩니다. Ecma 335 CLI 사양에서 <see langword="RemoveOn" /> 플래그에 해당합니다.
<see langword="remove_" /> 접두사를 사용하여 CLS 규격 remover의 이름을 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Setter">
      <summary vsli:raw="&lt;para&gt;Used to modify the value of the property.&lt;/para&gt;&lt;para&gt;CLS-compliant setters are named with the &lt;see langword=&quot;set_&quot; /&gt; prefix.&lt;/para&gt;">속성 값을 수정하는 데 사용됩니다.
<see langword="set_" /> 접두사를 사용하여 CLS 규격 setter의 이름을 지정합니다.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.AggressiveWSTrim" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Bit32Machine" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedHi" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedLo" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.DebugStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Dll" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.ExecutableImage" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LargeAddressAware" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LineNumsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LocalSymsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.NetRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RelocsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RemovableRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.System" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.UpSystemOnly" />
    <member name="T:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData">
      <summary vsli:raw="Provides information about a Program Debug Database (PDB) file.">PDB(프로그램 디버그 데이터베이스) 파일에 대한 정보를 제공합니다.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Age">
      <summary vsli:raw="The iteration of the PDB. The first iteration is 1. The iteration is incremented each time the PDB content is augmented.">PDB의 반복입니다. 첫 번째 반복은 1입니다. 반복은 PDB 콘텐츠가 확대될 때마다 증가합니다.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Guid">
      <summary vsli:raw="The Globally Unique Identifier (GUID) of the associated PDB.">연결된 PDB의 GUID(Globally Unique Identifier)입니다.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Path">
      <summary vsli:raw="The path to the .pdb file that contains debug information for the PE/COFF file.">PE/COFF 파일에 대한 디버그 정보를 포함하는 .pdb 파일의 경로입니다.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CoffHeader">
      <summary vsli:raw="Represents the header of a COFF file.">COFF 파일의 헤더를 나타냅니다.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Characteristics">
      <summary vsli:raw="Gets the flags that indicate the attributes of the file.">파일의 특성을 나타내는 플래그를 가져옵니다.</summary>
      <returns vsli:raw="The flags that indicate the attributes of the file.">파일의 특성을 나타내는 플래그입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Machine">
      <summary vsli:raw="Gets the type of the target machine.">대상 머신의 형식을 가져옵니다.</summary>
      <returns vsli:raw="The type of the target machine.">대상 컴퓨터의 유형입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSections">
      <summary vsli:raw="Gets the number of sections. This indicates the size of the section table, which immediately follows the headers.">섹션 수를 가져옵니다. 헤더 바로 다음에 오는 섹션 테이블의 크기를 나타냅니다.</summary>
      <returns vsli:raw="The number of sections.">섹션 수입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSymbols">
      <summary vsli:raw="Gets the number of entries in the symbol table. This data can be used to locate the string table, which immediately follows the symbol table. This value should be zero for a PE image.">기호 테이블의 항목 수를 가져옵니다. 이 데이터를 사용하여 기호 테이블 바로 뒤에 오는 문자열 테이블을 찾을 수 있습니다. PE 이미지의 경우 이 값이 0이어야 합니다.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.PointerToSymbolTable">
      <summary vsli:raw="Gets the file pointer to the COFF symbol table.">COFF 기호 테이블에 대한 파일 포인터를 가져옵니다.</summary>
      <returns vsli:raw="The file pointer to the COFF symbol table, or zero if no COFF symbol table is present. This value should be zero for a PE image.">COFF 기호 테이블에 대 한 파일 포인터 이거나, COFF 기호 테이블이 없는 경우 0입니다. PE 이미지의 경우 이 값이 0이어야 합니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.SizeOfOptionalHeader">
      <summary vsli:raw="Gets the size of the optional header, which is required for executable files but not for object files. This value should be zero for an object file.">실행 파일에는 필요하지만 개체 파일에는 필요하지 않은 선택적 헤더의 크기를 가져옵니다. 개체 파일의 경우 이 값이 0이어야 합니다.</summary>
      <returns vsli:raw="The size of the optional header.">선택적 헤더의 크기입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.TimeDateStamp">
      <summary vsli:raw="Gets a value that indicates when the file was created.">파일이 만들어진 시기를 나타내는 값을 가져옵니다.</summary>
      <returns vsli:raw="The low 32 bits of the number of seconds since 00:00 January 1, 1970, which indicates when the file was created.">32 이후의 시간 (초) (00:00 1970 1 월 1 일)의 하위 비트 (파일 생성 시기를 나타냄)입니다.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CorFlags" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILLibrary" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILOnly" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.NativeEntryPoint" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Prefers32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Requires32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.StrongNameSigned" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.TrackDebugData" />
    <member name="T:System.Reflection.PortableExecutable.CorHeader" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.CodeManagerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.EntryPointTokenOrRelativeVirtualAddress" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ExportAddressTableJumpsDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.Flags" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MajorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ManagedNativeHeaderDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MetadataDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MinorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ResourcesDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.StrongNameSignatureDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.VtableFixupsDirectory" />
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" />
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.DebugDirectoryBuilder&quot; /&gt; class.">
        <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddCodeViewEntry(System.String,System.Reflection.Metadata.BlobContentId,System.UInt16)">
      <summary vsli:raw="Adds a CodeView entry.">CodeView 항목을 추가합니다.</summary>
      <param name="pdbPath" vsli:raw="The path to the PDB. It should not be empty.">PDB의 경로입니다. 비워 둘 수 없습니다.</param>
      <param name="pdbContentId" vsli:raw="The unique id of the PDB content.">PDB 콘텐츠의 고유 ID입니다.</param>
      <param name="portablePdbVersion" vsli:raw="The version of Portable PDB format (e.g. 0x0100 for 1.0), or 0 if the PDB is not portable.">이식 가능한 PDB 형식의 버전(예: 1.0의 경우 0x0100) 또는 0(PDB를 이식할 수 없는 경우)입니다.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;pdbPath&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="pdbPath" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;pdbPath&quot; /&gt; contains a NUL character.">
        <paramref name="pdbPath" />는 NUL 문자를 포함합니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;portablePdbVersion&quot; /&gt; is smaller than 0x0100.">
        <paramref name="portablePdbVersion" />이 0x0100보다 작습니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEmbeddedPortablePdbEntry(System.Reflection.Metadata.BlobBuilder,System.UInt16)">
      <summary vsli:raw="Adds an Embedded Portable PDB entry.">Embedded Portable PDB 항목을 추가합니다.</summary>
      <param name="debugMetadata" vsli:raw="A Portable PDB metadata builder.">이식 가능한 PDB 메타데이터 작성기입니다.</param>
      <param name="portablePdbVersion" vsli:raw="The version of Portable PDB format (e.g. 0x0100 for 1.0).">이식 가능한 PDB 형식의 버전입니다(예: 1.0의 경우 0x0100).</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;debugMetadata&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="debugMetadata" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;portablePdbVersion&quot; /&gt; is smaller than 0x0100.">
        <paramref name="portablePdbVersion" />이 0x0100보다 작습니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32)">
      <summary vsli:raw="Adds an entry of the specified type.">지정된 형식의 항목을 추가합니다.</summary>
      <param name="type" vsli:raw="The entry type.">항목 유형입니다.</param>
      <param name="version" vsli:raw="The entry version.">항목 버전입니다.</param>
      <param name="stamp" vsli:raw="The entry stamp.">항목 스탬프입니다.</param>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry``1(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32,``0,System.Action{System.Reflection.Metadata.BlobBuilder,``0})">
      <summary vsli:raw="Adds an entry of the specified type and serializes its data.">지정된 형식의 항목을 추가하고 해당 데이터를 직렬화합니다.</summary>
      <param name="type" vsli:raw="The entry type.">항목 유형입니다.</param>
      <param name="version" vsli:raw="The entry version.">항목 버전입니다.</param>
      <param name="stamp" vsli:raw="The entry stamp.">항목 스탬프입니다.</param>
      <param name="data" vsli:raw="The data to pass to &lt;paramref name=&quot;dataSerializer&quot; /&gt;.">
        <paramref name="dataSerializer" />로 전달할 데이터입니다.</param>
      <param name="dataSerializer" vsli:raw="A serializer for serializing data to a &lt;see cref=&quot;T:System.Reflection.Metadata.BlobBuilder&quot; /&gt;.">데이터를 <see cref="T:System.Reflection.Metadata.BlobBuilder" />에 직렬화할 직렬 변환기입니다.</param>
      <typeparam name="TData" vsli:raw="The type of the data passed to &lt;paramref name=&quot;dataSerializer&quot; /&gt;.">
        <paramref name="dataSerializer" />전달 되는 데이터의 형식입니다.</typeparam>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddPdbChecksumEntry(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Adds PDB checksum entry.">PDB 체크섬 항목을 추가합니다.</summary>
      <param name="algorithmName" vsli:raw="The hash algorithm name (for example, &quot;SHA256&quot;).">해시 알고리즘 이름입니다(예: "SHA256").</param>
      <param name="checksum" vsli:raw="The checksum.">체크섬입니다.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;algorithmName&quot; /&gt; or &lt;paramref name=&quot;checksum&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="algorithmName" /> 또는 <paramref name="checksum" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;algorithmName&quot; /&gt; or &lt;paramref name=&quot;checksum&quot; /&gt; is empty.">
        <paramref name="algorithmName" /> 또는 <paramref name="checksum" /> 비어 있습니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddReproducibleEntry">
      <summary vsli:raw="Adds a reproducible entry.">재현 가능한 항목을 추가합니다.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntry">
      <summary vsli:raw="Identifies the location, size and format of a block of debug information.">디버그 정보 블록의 위치, 크기 및 형식을 식별합니다.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryEntry.#ctor(System.UInt32,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.Int32,System.Int32,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.DebugDirectoryEntry&quot; /&gt; structure.">
        <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryEntry" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
      <param name="stamp" vsli:raw="" />
      <param name="majorVersion" vsli:raw="" />
      <param name="minorVersion" vsli:raw="" />
      <param name="type" vsli:raw="" />
      <param name="dataSize" vsli:raw="" />
      <param name="dataRelativeVirtualAddress" vsli:raw="" />
      <param name="dataPointer" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataPointer">
      <summary vsli:raw="Gets the file pointer to the debug data.">디버그 데이터에 대한 파일 포인터를 가져옵니다.</summary>
      <returns vsli:raw="The file pointer to the debug data.">디버그 데이터에 대 한 파일 포인터입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataRelativeVirtualAddress">
      <summary vsli:raw="Gets the address of the debug data when loaded, relative to the image base.">이미지 기준에 따라 로드되는 디버그 데이터의 주소를 가져옵니다.</summary>
      <returns vsli:raw="The address of the debug data relative to the image base.">이미지 베이스를 기준으로 하는 디버그 데이터의 주소입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataSize">
      <summary vsli:raw="Gets the size of the debug data (not including the debug directory itself).">디버그 데이터의 크기(디버그 디렉터리 제외)를 가져옵니다.</summary>
      <returns vsli:raw="the size of the debug data (excluding the debug directory).">디버그 디렉터리를 제외 하 고 디버그 데이터의 크기입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.IsPortableCodeView">
      <summary vsli:raw="Gets a value that indicates if the entry is a &lt;see cref=&quot;F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView&quot; /&gt; entry that points to a Portable PDB.">항목이 이식 가능한 PDB를 가리키는 <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" /> 항목인지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the entry is a &lt;see cref=&quot;F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView&quot; /&gt; entry pointing to a Portable PDB; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">항목이 이식 가능한 PDB를 가리키는 <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" /> 항목인 경우 <see langword="true" /> 합니다. 그렇지 않으면 <see langword="false" />합니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MajorVersion">
      <summary vsli:raw="Gets the major version number of the debug data format.">디버그 데이터 형식의 주 버전 번호를 가져옵니다.</summary>
      <returns vsli:raw="The major version number of the debug data format.">디버그 데이터 형식의 주 버전 번호입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MinorVersion">
      <summary vsli:raw="Gets the minor version number of the debug data format.">디버그 데이터 형식의 부 버전 번호를 가져옵니다.</summary>
      <returns vsli:raw="The minor version number of the debug data format.">디버그 데이터 형식의 부 버전 번호입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Stamp">
      <summary vsli:raw="Get the time and date that the debug data was created if the PE/COFF file is not deterministic; otherwise, gets a value based on the hash of the content.">PE/COFF 파일이 결정적이지 않으면 디버그 데이터를 만든 날짜 및 시간을 가져오고, 그렇지 않으면 콘텐츠의 해시를 기반으로 값을 가져옵니다.</summary>
      <returns vsli:raw="for a non-deterministic PE/COFF file, the time and date that the debug data was created; otherwise, a value based on the hash of the content.">명확 하지 않은 PE/COFF 파일의 경우 디버그 데이터를 만든 시간 및 날짜입니다. 그렇지 않으면 콘텐츠의 해시를 기반으로 하는 값입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Type">
      <summary vsli:raw="Gets the format of the debugging information.">디버깅 정보의 형식을 가져옵니다.</summary>
      <returns vsli:raw="The format of the debugging information.">디버깅 정보의 형식입니다.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntryType" />
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView">
      <summary vsli:raw="Associated PDB file description. For more information, see the specification.">연결된 PDB 파일 설명입니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Coff">
      <summary vsli:raw="The COFF debug information (line numbers, symbol table, and string table). This type of debug information is also pointed to by fields in the file headers.">COFF 디버그 정보(줄 번호, 기호 테이블, 문자열 테이블)입니다. 파일 헤더의 필드에서도 이 형식의 디버그 정보를 가리킵니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb">
      <summary vsli:raw="&lt;para&gt;The entry points to a blob containing Embedded Portable PDB. The Embedded Portable PDB blob has the following format:&lt;/para&gt;&lt;para&gt;- blob ::= uncompressed-size data&lt;/para&gt;&lt;para&gt;- Data spans the remainder of the blob and contains a Deflate-compressed Portable PDB.&lt;/para&gt;&lt;para&gt;For more information, see the specification.&lt;/para&gt;">항목은 Embedded Portable PDB를 포함하는 blob을 가리킵니다. Embedded Portable PDB blob의 형식은 다음과 같습니다.- blob ::= uncompressed-size data- 데이터는 blob의 나머지 부분으로 확장되며 Deflate로 압축된 이식 가능한 PDB를 포함합니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.PdbChecksum">
      <summary vsli:raw="The entry stores a crypto hash of the content of the symbol file the PE/COFF file was built with. The hash can be used to validate that a given PDB file was built with the PE/COFF file and not altered in any way. More than one entry can be present if multiple PDBs were produced during the build of the PE/COFF file (for example, private and public symbols). For more information, see the specification.">항목은 PE/COFF 파일을 빌드하는 데 사용된 기호 파일 콘텐츠의 암호화 해시를 저장합니다. 해시를 사용하여 지정된 PDB 파일이 PE/COFF 파일을 사용하여 빌드되고 어떤 식으로도 변경되지 않았는지 확인할 수 있습니다. PE/COFF 파일(예: 프라이빗 및 퍼블릭 기호)을 빌드하는 동안 여러 PDB가 생성된 경우 두 개 이상의 항목이 존재할 수 있습니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Reproducible">
      <summary vsli:raw="&lt;para&gt;The presence of this entry indicates a deterministic PE/COFF file. See the Remarks section for more information.&lt;/para&gt;&lt;para&gt;The tool that produced the deterministic PE/COFF file guarantees that the entire content of the file is based solely on documented inputs given to the tool (such as source files, resource files, and compiler options) rather than ambient environment variables (such as the current time, the operating system, and the bitness of the process running the tool).&#xA;          The value of field TimeDateStamp in COFF File Header of a deterministic PE/COFF file does not indicate the date and time when the file was produced and should not be interpreted that way. Instead, the value of the field is derived from a hash of the file content. The algorithm to calculate this value is an implementation detail of the tool that produced the file.&#xA;          The debug directory entry of type &lt;see cref=&quot;T:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Reproducible&quot; /&gt; must have all fields, except for Type zeroed.&lt;/para&gt;&lt;para&gt;For more information, see the specification.&lt;/para&gt;">이 항목이 있으면 결정적 PE/COFF 파일을 나타냅니다. 자세한 내용은 설명 부분을 참조하세요.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Unknown">
      <summary vsli:raw="An unknown value that should be ignored by all tools.">모든 도구에서 무시해야 하는 알 수 없는 값입니다.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DirectoryEntry" />
    <member name="M:System.Reflection.PortableExecutable.DirectoryEntry.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" vsli:raw="" />
      <param name="size" vsli:raw="" />
    </member>
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.RelativeVirtualAddress" />
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.Size" />
    <member name="T:System.Reflection.PortableExecutable.DllCharacteristics">
      <summary vsli:raw="Describes the characteristics of a dynamic link library.">동적 연결 라이브러리의 특징을 설명합니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.AppContainer">
      <summary vsli:raw="The image must run inside an AppContainer.">이미지는 AppContainer 내에서 실행되어야 합니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.DynamicBase">
      <summary vsli:raw="The DLL can be relocated.">DLL을 다시 배치할 수 있습니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.HighEntropyVirtualAddressSpace">
      <summary vsli:raw="The image can handle a high entropy 64-bit virtual address space.">이미지는 높은 엔트로피 64비트 가상 주소 공간을 처리할 수 있습니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoBind">
      <summary vsli:raw="Do not bind this image.">이 이미지를 바인딩하지 않습니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoIsolation">
      <summary vsli:raw="The image understands isolation and doesn't want it.">이미지는 격리를 이해하지만 원하지 않습니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoSeh">
      <summary vsli:raw="The image does not use SEH. No SE handler may reside in this image.">이미지에서는 SEH를 사용하지 않습니다. 이 이미지에는 SE 처리기가 없습니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NxCompatible">
      <summary vsli:raw="The image is NX compatible.">이미지가 NX와 호환됩니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessInit">
      <summary vsli:raw="Reserved.">예약되어 있습니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessTerm">
      <summary vsli:raw="Reserved.">예약되어 있습니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.TerminalServerAware">
      <summary vsli:raw="The image is Terminal Server aware.">이미지가 터미널 서버를 인식합니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadInit">
      <summary vsli:raw="Reserved.">예약되어 있습니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadTerm">
      <summary vsli:raw="Reserved.">예약되어 있습니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.WdmDriver">
      <summary vsli:raw="The driver uses the WDM model.">드라이버는 WDM 모델을 사용합니다.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Machine">
      <summary vsli:raw="Specifies the target machine's CPU architecture.">대상 머신의 CPU 아키텍처를 지정합니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha">
      <summary vsli:raw="Alpha.">Alpha.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha64">
      <summary vsli:raw="ALPHA64.">ALPHA64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.AM33">
      <summary vsli:raw="Matsushita AM33.">Matsushita AM33.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Amd64">
      <summary vsli:raw="AMD64 (K8).">AMD64(K8).</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm">
      <summary vsli:raw="ARM little endian.">ARM little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm64">
      <summary vsli:raw="ARM64.">ARM64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.ArmThumb2">
      <summary vsli:raw="ARM Thumb-2 little endian.">ARM Thumb-2 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Ebc">
      <summary vsli:raw="EFI Byte Code.">EFI 바이트 코드.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.I386">
      <summary vsli:raw="Intel 386.">Intel 386.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.IA64">
      <summary vsli:raw="Intel 64.">Intel 64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.M32R">
      <summary vsli:raw="M32R little-endian.">M32R little-endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MIPS16">
      <summary vsli:raw="MIPS.">MIPS.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu">
      <summary vsli:raw="MIPS with FPU.">FPU를 포함하는 MIPS.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu16">
      <summary vsli:raw="MIPS16 with FPU.">FPU를 포함하는 MIPS16.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPC">
      <summary vsli:raw="IBM PowerPC little endian.">IBM PowerPC little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPCFP">
      <summary vsli:raw="PowerPCFP.">PowerPCFP.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3">
      <summary vsli:raw="Hitachi SH3 little endian.">Hitachi SH3 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3Dsp">
      <summary vsli:raw="Hitachi SH3 DSP.">Hitachi SH3 DSP.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3E">
      <summary vsli:raw="Hitachi SH3 little endian.">Hitachi SH3 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH4">
      <summary vsli:raw="Hitachi SH4 little endian.">Hitachi SH4 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH5">
      <summary vsli:raw="Hitachi SH5.">Hitachi SH5.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Thumb">
      <summary vsli:raw="Thumb.">Thumb.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Tricore">
      <summary vsli:raw="Infineon.">Infineon.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Unknown">
      <summary vsli:raw="The target CPU is unknown or not specified.">대상 CPU를 알 수 없거나 지정하지 않았습니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.WceMipsV2">
      <summary vsli:raw="MIPS little-endian WCE v2.">MIPS little-endian WCE v2.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ManagedPEBuilder" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Reflection.Metadata.Ecma335.MetadataRootBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId},System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.ResourceSectionBuilder,System.Reflection.PortableExecutable.DebugDirectoryBuilder,System.Int32,System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.PortableExecutable.CorFlags)">
      <param name="header" />
      <param name="metadataRootBuilder" />
      <param name="deterministicIdProvider" />
      <param name="ilStream" />
      <param name="mappedFieldData" />
      <param name="managedResources" />
      <param name="nativeResources" />
      <param name="debugDirectoryBuilder" />
      <param name="strongNameSignatureSize" />
      <param name="entryPoint" />
      <param name="flags" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.GetDirectories" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.ManagedResourcesDataAlignment" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.MappedFieldDataAlignment" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" vsli:raw="" />
      <param name="location" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.Sign(System.Reflection.Metadata.BlobBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Byte[]})">
      <param name="peImage" vsli:raw="" />
      <param name="signatureProvider" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData">
      <summary vsli:raw="Represents a PDB Checksum debug directory entry.">PDB 체크섬 디버그 디렉터리 항목을 나타냅니다.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.AlgorithmName">
      <summary vsli:raw="The name of the crypto hash algorithm used to calculate the checksum.">체크섬을 계산하는 데 사용되는 암호화 해시 알고리즘의 이름입니다.</summary>
      <returns vsli:raw="A string representing the name of the crypto hash algorithm used to calculate the checksum.">체크섬을 계산 하는 데 사용 되는 암호화 해시 알고리즘의 이름을 나타내는 문자열입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.Checksum">
      <summary vsli:raw="The checksum of the PDB content.">PDB 콘텐츠의 체크섬입니다.</summary>
      <returns vsli:raw="An immutable array of bytes representing the checksum of the PDB content.">PDB 콘텐츠의 체크섬을 나타내는 변경할 수 없는 바이트 배열입니다.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEBuilder" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <param name="header" vsli:raw="" />
      <param name="deterministicIdProvider" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetDirectories" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetSections" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.Header" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IdProvider" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IsDeterministic" />
    <member name="T:System.Reflection.PortableExecutable.PEBuilder.Section" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Section.#ctor(System.String,System.Reflection.PortableExecutable.SectionCharacteristics)">
      <param name="name" vsli:raw="" />
      <param name="characteristics" vsli:raw="" />
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Name" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" vsli:raw="" />
      <param name="location" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder">
      <summary vsli:raw="Builds PE directories.">PE 디렉터리를 빌드합니다.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEDirectoriesBuilder.#ctor">
      <summary vsli:raw="Initializes an instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEDirectoriesBuilder&quot; /&gt; class.">
        <see cref="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder" /> 클래스의 인스턴스를 초기화합니다.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.AddressOfEntryPoint">
      <summary vsli:raw="The address of the entry point relative to the image base when the PE file is loaded into memory.">PE 파일이 메모리로 로드될 때 이미지 기준에 따라 진입점의 주소입니다.</summary>
      <returns vsli:raw="For program images, this is the starting address. For device drivers, this is the address of the initialization function. An entry point is optional for DLLs. When no entry point is present, this field must be zero.">프로그램 이미지의 경우 시작 주소입니다. 장치 드라이버의 경우 초기화 함수의 주소입니다. Dll에 대 한 진입점은 선택적 요소입니다. 진입점이 없으면이 필드는 0 이어야 합니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BaseRelocationTable">
      <summary vsli:raw="The base relocation table image directory entry.">기본 재배치 테이블 이미지 디렉터리 항목입니다.</summary>
      <returns vsli:raw="A directory entry instance.">디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BoundImportTable">
      <summary vsli:raw="The bound import image directory entry.">바인딩된 가져오기 이미지 디렉터리 항목입니다.</summary>
      <returns vsli:raw="A directory entry instance.">디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CopyrightTable">
      <summary vsli:raw="The copyright/architecture image directory entry.">저작권/아키텍처 이미지 디렉터리 항목입니다.</summary>
      <returns vsli:raw="A directory entry instance.">디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CorHeaderTable">
      <summary vsli:raw="The COM descriptortable image directory entry.">COM descriptortable 이미지 디렉터리 항목입니다.</summary>
      <returns vsli:raw="A directory entry instance.">디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DebugTable">
      <summary vsli:raw="The debug table image directory entry.">디버그 테이블 이미지 디렉터리 항목입니다.</summary>
      <returns vsli:raw="A directory entry instance.">디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DelayImportTable">
      <summary vsli:raw="The delay import table image directory entry.">지연 가져오기 테이블 이미지 디렉터리 항목입니다.</summary>
      <returns vsli:raw="A directory entry instance.">디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExceptionTable">
      <summary vsli:raw="The exception table image directory entry.">예외 테이블 이미지 디렉터리 항목입니다.</summary>
      <returns vsli:raw="A directory entry instance.">디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExportTable">
      <summary vsli:raw="The export table image directory entry.">내보내기 테이블 이미지 디렉터리 항목입니다.</summary>
      <returns vsli:raw="A directory entry instance.">디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.GlobalPointerTable">
      <summary vsli:raw="The global pointer table image directory entry.">전역 포인터 테이블 이미지 디렉터리 항목입니다.</summary>
      <returns vsli:raw="A directory entry instance.">디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportAddressTable">
      <summary vsli:raw="The import address table (IAT) image directory entry.">IAT(가져오기 주소 테이블) 이미지 디렉터리 항목입니다.</summary>
      <returns vsli:raw="A directory entry instance.">디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportTable">
      <summary vsli:raw="The import table image directory entry.">가져오기 테이블 이미지 디렉터리 항목입니다.</summary>
      <returns vsli:raw="A directory entry instance.">디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.LoadConfigTable">
      <summary vsli:raw="The load configuration table image directory entry.">로드 구성 테이블 이미지 디렉터리 항목입니다.</summary>
      <returns vsli:raw="A directory entry instance.">디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ResourceTable">
      <summary vsli:raw="The resource table image directory entry.">리소스 테이블 이미지 디렉터리 항목입니다.</summary>
      <returns vsli:raw="A directory entry instance.">디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ThreadLocalStorageTable">
      <summary vsli:raw="The thread local storage (TLS) table image directory entry.">TLS(스레드 로컬 스토리지) 테이블 이미지 디렉터리 항목입니다.</summary>
      <returns vsli:raw="A directory entry instance.">디렉터리 항목 인스턴스입니다.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeader" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.AddressOfEntryPoint">
      <summary vsli:raw="Gets the address of the entry point relative to the image base when the PE file is loaded into memory.">PE 파일이 메모리로 로드될 때 이미지 기준에 따라 진입점의 주소를 가져옵니다.</summary>
      <returns vsli:raw="The address of the entry point relative to the image base.">이미지 밑을 기준으로 하는 진입점의 주소입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfCode">
      <summary vsli:raw="Gets the address of the beginning-of-code section relative to the image base when the image is loaded into memory.">이미지가 메모리에 로드될 때 이미지 기준에 따라 코드 시작 섹션의 주소를 가져옵니다.</summary>
      <returns vsli:raw="The address of the beginning-of-code section relative to the image base.">이미지 베이스를 기준으로 하는 코드의 시작 부분에 대 한 주소입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfData">
      <summary vsli:raw="Gets the address of the beginning-of-data section relative to the image base when the image is loaded into memory.">이미지가 메모리에 로드될 때 이미지 기준에 따라 데이터 시작 섹션의 주소를 가져옵니다.</summary>
      <returns vsli:raw="The address of the beginning-of-data section relative to the image base.">이미지 베이스를 기준으로 하는 데이터 시작 부분의 주소입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseRelocationTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BoundImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CertificateTableDirectory">
      <summary vsli:raw="Gets the Certificate Table entry, which points to a table of attribute certificates.">특성 인증서 테이블을 가리키는 인증서 테이블 항목을 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CheckSum">
      <summary vsli:raw="Gets the image file checksum.">이미지 파일 체크섬을 가져옵니다.</summary>
      <returns vsli:raw="The image file checksum.">이미지 파일 체크섬입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CopyrightTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CorHeaderTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DebugTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DelayImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DllCharacteristics" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExceptionTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment">
      <summary vsli:raw="Gets the alignment factor (in bytes) that is used to align the raw data of sections in the image file.">이미지 파일의 섹션 원시 데이터를 정렬하는 데 사용되는 맞춤 요소(바이트)를 가져옵니다.</summary>
      <returns vsli:raw="A power of 2 between 512 and 64K, inclusive. The default is 512.">512에서 64K 사이의 2 제곱 (포함)입니다. 기본값은 512입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.GlobalPointerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImageBase">
      <summary vsli:raw="Gets the preferred address of the first byte of the image when it is loaded into memory.">이미지를 메모리로 로드할 때 이미지의 첫 번째 바이트의 기본 주소를 가져옵니다.</summary>
      <returns vsli:raw="The preferred address, which is a multiple of 64K.">64K의 배수가 되는 기본 설정 주소입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportAddressTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.LoadConfigTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Magic">
      <summary vsli:raw="Gets a value that identifies the format of the image file.">이미지 파일의 형식을 식별하는 값을 가져옵니다.</summary>
      <returns vsli:raw="The format of the image file.">이미지 파일의 형식입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorImageVersion">
      <summary vsli:raw="Gets the major version number of the image.">이미지의 주 버전 번호를 가져옵니다.</summary>
      <returns vsli:raw="The major version number of the image.">브라우저의 주 버전 번호입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorLinkerVersion">
      <summary vsli:raw="Gets the linker major version number.">링커 주 버전 번호를 가져옵니다.</summary>
      <returns vsli:raw="The linker major version number.">링커 주 버전 번호입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorOperatingSystemVersion">
      <summary vsli:raw="Gets the major version number of the required operating system.">필수 운영 체제의 주 버전 번호를 가져옵니다.</summary>
      <returns vsli:raw="The major version number of the required operating system.">필수 운영 체제의 주 버전 번호입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorSubsystemVersion">
      <summary vsli:raw="Gets the major version number of the subsystem.">하위 시스템의 주 버전 번호를 가져옵니다.</summary>
      <returns vsli:raw="The major version number of the subsystem.">하위 시스템의 주 버전 번호입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorImageVersion">
      <summary vsli:raw="Gets the minor version number of the image.">이미지의 부 버전 번호를 가져옵니다.</summary>
      <returns vsli:raw="The minor version number of the image.">브라우저의 부 버전 번호입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorLinkerVersion">
      <summary vsli:raw="Gets the linker minor version number.">링커 부 버전 번호를 가져옵니다.</summary>
      <returns vsli:raw="The linker minor version number.">링커 부 버전 번호입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorOperatingSystemVersion">
      <summary vsli:raw="Gets the minor version number of the required operating system.">필수 운영 체제의 부 버전 번호를 가져옵니다.</summary>
      <returns vsli:raw="The minor version number of the required operating system.">필수 운영 체제의 부 버전 번호입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorSubsystemVersion">
      <summary vsli:raw="Gets the minor version number of the subsystem.">하위 시스템의 부 버전 번호를 가져옵니다.</summary>
      <returns vsli:raw="The minor version number of the subsystem.">하위 시스템의 부 버전 번호입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.NumberOfRvaAndSizes">
      <summary vsli:raw="Gets the number of data-directory entries in the remainder of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeader&quot; /&gt;. Each describes a location and size.">
        <see cref="T:System.Reflection.PortableExecutable.PEHeader" />의 나머지 부분에 있는 데이터 디렉터리 항목 수를 가져옵니다. 각 항목은 위치와 크기를 설명합니다.</summary>
      <returns vsli:raw="The number of data-directory entries in the remainder of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeader&quot; /&gt;.">
        <see cref="T:System.Reflection.PortableExecutable.PEHeader" />나머지 부분에 있는 데이터 디렉터리 항목 수입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ResourceTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment">
      <summary vsli:raw="Gets the alignment (in bytes) of sections when they are loaded into memory.">메모리에 로드되는 섹션의 맞춤(바이트)을 가져옵니다.</summary>
      <returns vsli:raw="A number greater than or equal to &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeader.FileAlignment&quot; /&gt;. The default is the page size for the architecture.">
        <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment" />보다 크거나 같은 숫자입니다. 기본값은 아키텍처의 페이지 크기입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfCode">
      <summary vsli:raw="Gets the size of the code (text) section, or the sum of all code sections if there are multiple sections.">코드(텍스트) 섹션의 크기 또는 모든 코드 섹션의 합계(여러 섹션이 있는 경우)를 가져옵니다.</summary>
      <returns vsli:raw="the size of the code (text) section, or the sum of all code sections if there are multiple sections.">여러 섹션이 있는 경우 코드 (텍스트) 섹션의 크기 또는 모든 코드 섹션의 합계입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeaders">
      <summary vsli:raw="Gets the combined size of an MS DOS stub, PE header, and section headers rounded up to a multiple of FileAlignment.">FileAlignment의 배수로 반올림된 MS DOS 스텁, PE 헤더 및 섹션 헤더의 결합된 크기를 가져옵니다.</summary>
      <returns vsli:raw="The combined size of an MS DOS stub, PE header, and section headers rounded up to a multiple of FileAlignment.">FileAlignment의 배수로 반올림 된 MS DOS 스텁, PE 헤더 및 섹션 헤더의 결합 된 크기입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit">
      <summary vsli:raw="Gets the size of the local heap space to commit.">커밋할 로컬 힙 공간의 크기를 가져옵니다.</summary>
      <returns vsli:raw="the size of the local heap space to commit.">커밋할 로컬 힙 공간의 크기입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapReserve">
      <summary vsli:raw="Gets the size of the local heap space to reserve. Only &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit&quot; /&gt; is committed; the rest is made available one page at a time until the reserve size is reached.">예약할 로컬 힙 공간의 크기를 가져옵니다. <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit" />만 커밋되고, 나머지는 예약 크기에 도달할 때까지 한 번에 한 페이지씩 사용할 수 있습니다.</summary>
      <returns vsli:raw="The size of the local heap space to reserve.">예약할 로컬 힙 공간의 크기입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfImage">
      <summary vsli:raw="Gets the size (in bytes) of the image, including all headers, as the image is loaded in memory.">이미지가 메모리에 로드될 때 모든 헤더를 포함한 이미지의 크기(바이트)를 가져옵니다.</summary>
      <returns vsli:raw="The size (in bytes) of the image, which is a multiple of &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment&quot; /&gt;.">
        <see cref="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment" />의 배수 이미지 크기 (바이트)입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfInitializedData">
      <summary vsli:raw="Gets the size of the initialized data section, or the sum of all such sections if there are multiple data sections.">초기화된 데이터 섹션의 크기 또는 모든 초기화된 데이터 섹션의 합계(여러 데이터 섹션이 있는 경우)를 가져옵니다.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit">
      <summary vsli:raw="Gets the size of the stack to commit.">커밋할 스택의 크기를 가져옵니다.</summary>
      <returns vsli:raw="The size of the stack to commit.">커밋할 스택의 크기입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackReserve">
      <summary vsli:raw="Gets the size of the stack to reserve. Only &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit&quot; /&gt; is committed; the rest is made available one page at a time until the reserve size is reached.">예약할 스택의 크기를 가져옵니다. <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit" />만 커밋되고, 나머지는 예약 크기에 도달할 때까지 한 번에 한 페이지씩 사용할 수 있습니다.</summary>
      <returns vsli:raw="The size of the stack to reserve.">예약할 스택의 크기입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfUninitializedData">
      <summary vsli:raw="Gets the size of the uninitialized data section (BSS), or the sum of all such sections if there are multiple BSS sections.">초기화되지 않은 데이터 섹션(BSS)의 크기 또는 모든 초기화된 데이터 섹션의 합계(여러 BSS 섹션이 있는 경우)를 가져옵니다.</summary>
      <returns vsli:raw="The size of the uninitialized data section (BSS) or the sum of all such sections.">초기화 되지 않은 데이터 섹션의 크기 (BSS) 또는 이러한 모든 섹션의 합계입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Subsystem">
      <summary vsli:raw="Gets the name of the subsystem that is required to run this image.">이 이미지를 실행하는 데 필요한 하위 시스템의 이름을 가져옵니다.</summary>
      <returns vsli:raw="The name of the subsystem that is required to run this image.">이 이미지를 실행 하는 데 필요한 하위 시스템의 이름입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ThreadLocalStorageTableDirectory" />
    <member name="T:System.Reflection.PortableExecutable.PEHeaderBuilder">
      <summary vsli:raw="Defines the header for a portable executable (PE) file.">PE(이식 가능) 파일에 대한 헤더를 정의합니다.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.#ctor(System.Reflection.PortableExecutable.Machine,System.Int32,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.Subsystem,System.Reflection.PortableExecutable.DllCharacteristics,System.Reflection.PortableExecutable.Characteristics,System.UInt64,System.UInt64,System.UInt64,System.UInt64,System.Int32,System.UInt64,System.Byte,System.Byte,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
      <summary>
        <see cref="T:System.Reflection.PortableExecutable.PEHeader" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="machine">대상 머신의 CPU 아키텍처입니다.</param>
      <param name="sectionAlignment">메모리에 로드되는 섹션의 맞춤(바이트)입니다. <paramref name="fileAlignment" />보다 크거나 같아야 합니다. 기본값은 아키텍처의 페이지 크기입니다.</param>
      <param name="majorSubsystemVersion">하위 시스템의 주 버전 번호입니다.</param>
      <param name="minorSubsystemVersion">하위 시스템의 부 버전 번호입니다.</param>
      <param name="subsystem">이미지를 실행하는 데 필요한 하위 시스템입니다.</param>
      <param name="dllCharacteristics">동적 연결 라이브러리의 특징을 설명하는 개체입니다.</param>
      <param name="imageCharacteristics">이미지의 특징을 설명하는 개체입니다.</param>
      <param name="sizeOfStackReserve">예약할 스택의 크기입니다. <paramref name="sizeOfStackCommit" />만 커밋되고, 나머지는 예약 크기에 도달할 때까지 한 번에 한 페이지씩 사용할 수 있습니다.</param>
      <param name="sizeOfStackCommit">커밋할 스택의 크기입니다.</param>
      <param name="sizeOfHeapReserve">예약할 로컬 힙 공간의 크기입니다. <paramref name="sizeOfHeapCommit" />만 커밋되고, 나머지는 예약 크기에 도달할 때까지 한 번에 한 페이지씩 사용할 수 있습니다.</param>
      <param name="sizeOfHeapCommit">커밋할 로컬 힙 공간의 크기입니다.</param>
      <param name="fileAlignment">이미지 파일의 섹션 원시 데이터를 정렬하는 데 사용되는 맞춤 요소(바이트)입니다. 값은 512~64K(포함) 사이의 2의 거듭제곱입니다. 기본값은 512입니다. <paramref name="sectionAlignment" />가 아키텍처의 페이지 크기보다 작은 경우 <paramref name="fileAlignment" />가 <paramref name="sectionAlignment" />와 일치해야 합니다.</param>
      <param name="imageBase">메모리로 로드되는 이미지의 첫 번째 바이트의 기본 주소이며, 64K의 배수입니다.</param>
      <param name="majorLinkerVersion">링커 주 버전 번호입니다.</param>
      <param name="minorLinkerVersion">링커 부 버전 번호입니다.</param>
      <param name="majorOperatingSystemVersion">필수 운영 체제의 주 버전 번호입니다.</param>
      <param name="minorOperatingSystemVersion">필수 운영 체제의 부 버전 번호입니다.</param>
      <param name="majorImageVersion">브라우저의 주 버전 번호입니다.</param>
      <param name="minorImageVersion">브라우저의 부 버전 번호입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="fileAlignment" />는 512~64K 사이의 2의 거듭제곱이 아닙니다.
또는
<paramref name="sectionAlignment" />는 2의 거듭제곱이 아닙니다.
또는
<paramref name="sectionAlignment" />가 <paramref name="fileAlignment" />보다 작은 경우</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateExecutableHeader">
      <summary vsli:raw="Creates an executable header.">실행 파일 헤더를 만듭니다.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeaderBuilder&quot; /&gt; instance representing the executable header.">실행 파일 헤더를 나타내는 <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" /> 인스턴스입니다.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateLibraryHeader">
      <summary vsli:raw="Creates a library header.">라이브러리 헤더를 만듭니다.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeaderBuilder&quot; /&gt; instance representing the library header.">라이브러리 헤더를 나타내는 <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" /> 인스턴스입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.DllCharacteristics">
      <summary vsli:raw="Returns the dynamic linker library characteristics.">동적 링커 라이브러리 특징을 반환합니다.</summary>
      <returns vsli:raw="An object that describes the dynamic linker library characteristics.">동적 링커 라이브러리 특징을 설명 하는 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.FileAlignment">
      <summary vsli:raw="The alignment factor (in bytes) that is used to align the raw data of sections in the image file. The value should be a power of 2 between 512 and 64K, inclusive. The default is 512. If the section alignment is less than the architecture's page size, then file alignment must match the section alignment.">이미지 파일의 섹션 원시 데이터를 정렬하는 데 사용되는 맞춤 요소(바이트)입니다. 값은 512~64K(포함) 사이의 2의 거듭제곱입니다. 기본값은 512입니다. 섹션 맞춤이 아키텍처의 페이지 크기보다 작은 경우 파일 맞춤은 섹션 맞춤과 일치해야 합니다.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageBase">
      <summary vsli:raw="The preferred address of the first byte of image when loaded into memory; must be a multiple of 64K.">메모리로 로드되는 이미지의 첫 번째 바이트의 기본 주소이며, 64K의 배수입니다.</summary>
      <returns vsli:raw="A number representing the preferred address of the first byte of image when loaded into memory.">메모리로 로드할 때 이미지 첫 번째 바이트의 기본 설정 주소를 나타내는 숫자입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageCharacteristics">
      <summary vsli:raw="Returns the image characteristics.">이미지 특징을 반환합니다.</summary>
      <returns vsli:raw="An object representing the image characteristics.">이미지 특징을 나타내는 개체입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Machine">
      <summary vsli:raw="The target machine's CPU architecture.">대상 머신의 CPU 아키텍처입니다.</summary>
      <returns vsli:raw="One of the enumeration values representing the different CPU architectures.">다른 CPU 아키텍처를 나타내는 열거형 값 중 하나입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorImageVersion">
      <summary vsli:raw="The major version number of the image.">브라우저의 주 버전 번호입니다.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the major version number of the image.">이미지의 주 버전 번호를 나타내는 <see cref="T:System.UInt16" />의 크기를 나타내는 숫자입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorLinkerVersion">
      <summary vsli:raw="The linker major version number.">링커 주 버전 번호입니다.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.Byte&quot; /&gt; representing the linker major version number.">링커 주 버전 번호를 나타내는 <see cref="T:System.Byte" />의 크기를 나타내는 숫자입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorOperatingSystemVersion">
      <summary vsli:raw="The major version number of the required operating system.">필수 운영 체제의 주 버전 번호입니다.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the major version number of the required operating system.">필수 운영 체제의 주 버전 번호를 나타내는 <see cref="T:System.UInt16" /> 크기의 수입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorSubsystemVersion">
      <summary vsli:raw="The major version number of the subsystem.">하위 시스템의 주 버전 번호입니다.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the major version number of the subsystem.">하위 시스템의 주 버전 번호를 나타내는 <see cref="T:System.UInt16" /> 크기의 수입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorImageVersion">
      <summary vsli:raw="The minor version number of the image.">브라우저의 부 버전 번호입니다.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the minor version number of the image.">이미지의 부 버전 번호를 나타내는 <see cref="T:System.UInt16" />의 크기를 나타내는 숫자입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorLinkerVersion">
      <summary vsli:raw="The linker minor version number.">링커 부 버전 번호입니다.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.Byte&quot; /&gt; representing the linker minor version number.">링커 부 버전 번호를 나타내는 <see cref="T:System.Byte" />의 크기를 나타내는 숫자입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorOperatingSystemVersion">
      <summary vsli:raw="The minor version number of the required operating system.">필수 운영 체제의 부 버전 번호입니다.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the minor version number of the required operating system.">필요한 운영 체제의 부 버전 번호를 나타내는 <see cref="T:System.UInt16" /> 크기의 수입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorSubsystemVersion">
      <summary vsli:raw="The minor version number of the subsystem.">하위 시스템의 부 버전 번호입니다.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the minor version number of the subsystem.">하위 시스템의 부 버전 번호를 나타내는 <see cref="T:System.UInt16" /> 크기의 수입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SectionAlignment">
      <summary vsli:raw="The alignment (in bytes) of sections when they are loaded into memory.">메모리에 로드되는 섹션의 맞춤(바이트)입니다.</summary>
      <returns vsli:raw="A number representing the alignment (in bytes) of sections when they are loaded into memory. It must be greater than or equal to the file alignment. The default is the page size for the architecture.">메모리에 로드 되는 섹션의 맞춤 (바이트)을 나타내는 숫자입니다. 파일 맞춤 보다 크거나 같아야 합니다. 기본값은 아키텍처의 페이지 크기입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit">
      <summary vsli:raw="The size of the local heap space to commit.">커밋할 로컬 힙 공간의 크기입니다.</summary>
      <returns vsli:raw="A number representing the size of the local heap space to commit.">커밋할 로컬 힙 공간의 크기를 나타내는 숫자입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapReserve">
      <summary vsli:raw="The size of the local heap space to reserve. Only &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit&quot; /&gt; is committed; the rest is made available one page at a time until the reserve size is reached.">예약할 로컬 힙 공간의 크기입니다. <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit" />만 커밋되고, 나머지는 예약 크기에 도달할 때까지 한 번에 한 페이지씩 사용할 수 있습니다.</summary>
      <returns vsli:raw="A number representing the size of the local heap space to reserve.">예약할 로컬 힙 공간의 크기를 나타내는 숫자입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit">
      <summary vsli:raw="The size of the stack to commit.">커밋할 스택의 크기입니다.</summary>
      <returns vsli:raw="A number representing the size of the stack to commit.">커밋할 스택의 크기를 나타내는 숫자입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackReserve">
      <summary vsli:raw="The size of the stack to reserve. Only &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit&quot; /&gt; is committed; the rest is made available one page at a time until the reserve size is reached.">예약할 스택의 크기입니다. <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit" />만 커밋되고, 나머지는 예약 크기에 도달할 때까지 한 번에 한 페이지씩 사용할 수 있습니다.</summary>
      <returns vsli:raw="A number representing the size of the stack to reserve.">예약할 스택의 크기를 나타내는 숫자입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Subsystem">
      <summary vsli:raw="The subsystem that is required to run this image.">이 이미지를 실행하는 데 필요한 하위 시스템입니다.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.PortableExecutable.Subsystem&quot; /&gt; instance.">
        <see cref="T:System.Reflection.PortableExecutable.Subsystem" /> 인스턴스입니다.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeaders">
      <summary vsli:raw="Defines a type that reads PE (Portable Executable) and COFF (Common Object File Format) headers from a stream.">스트림에서 PE(이식 가능한 실행 파일) 및 COFF(공용 개체 파일 형식) 헤더를 읽는 형식을 정의합니다.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream)">
      <summary vsli:raw="Instantiates a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeaders&quot; /&gt; class that reads the PE headers from the current location in the specified stream.">지정된 스트림의 현재 위치에서 PE 헤더를 읽는 <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> 클래스의 새 인스턴스를 인스턴스화합니다.</summary>
      <param name="peStream" vsli:raw="A stream containing the PE image starting at the stream's current position and ending at the end of the stream.">스트림의 현재 위치에서 시작하여 스트림의 끝에서 끝나는 PE 이미지를 포함하는 스트림입니다.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data read from the stream has an invalid format.">스트림에서 읽은 데이터의 형식이 잘못되었습니다.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream.">스트림에서 읽는 중 오류가 발생했습니다.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The stream does not support seek operations.">스트림이 검색 작업을 지원하지 않습니다.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peStream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peStream" />가 <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32)">
      <summary vsli:raw="Instantiates a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeaders&quot; /&gt; class that reads the PE headers from a stream that represents a PE image of a specified size.">지정된 크기의 PE 이미지를 나타내는 스트림에서 PE 헤더를 읽는 <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> 클래스의 새 인스턴스를 인스턴스화합니다.</summary>
      <param name="peStream" vsli:raw="A stream containing PE image of the given size starting at its current position.">현재 위치에서 시작하여 지정된 크기의 PE 이미지를 포함하는 스트림입니다.</param>
      <param name="size" vsli:raw="The size of the PE image.">PE 이미지의 크기입니다.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data read from the stream has an invalid format.">스트림에서 읽은 데이터의 형식이 잘못되었습니다.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream.">스트림에서 읽는 중 오류가 발생했습니다.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The stream does not support seek operations.">스트림이 검색 작업을 지원하지 않습니다.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peStream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peStream" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative or extends past the end of the stream.">
        <paramref name="size" />가 음수이거나 스트림의 끝을 넘어 확장됩니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
      <summary vsli:raw="Instantiates a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeaders&quot; /&gt; class that reads the PE headers from a stream that represents a PE image of a specified size and indicates whether the PE image has been loaded into memory.">지정된 크기의 PE 이미지를 나타내고 PE 이미지를 메모리로 로드했는지 여부를 표시하는 스트림에서 PE 헤더를 읽는 <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> 클래스의 새 인스턴스를 인스턴스화합니다.</summary>
      <param name="peStream" vsli:raw="The stream containing PE image of the given size starting at its current position.">현재 위치에서 시작하여 지정된 크기의 PE 이미지를 포함하는 스트림입니다.</param>
      <param name="size" vsli:raw="The size of the PE image.">PE 이미지의 크기입니다.</param>
      <param name="isLoadedImage" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the PE image has been loaded into memory by the OS loader; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">OS 로더에서 PE 이미지를 메모리로 로드했으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data read from the stream has invalid format.">스트림에서 읽은 데이터의 형식이 잘못되었습니다.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream.">스트림에서 읽는 중 오류가 발생했습니다.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The stream does not support seek operations.">스트림이 검색 작업을 지원하지 않습니다.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peStream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peStream" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative or extends past the end of the stream.">
        <paramref name="size" />가 음수이거나 스트림의 끝을 넘어 확장됩니다.</exception>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeader">
      <summary vsli:raw="Gets the COFF header of the image.">이미지의 COFF 헤더를 가져옵니다.</summary>
      <returns vsli:raw="The COFF header of the image.">이미지의 COFF 헤더입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeaderStartOffset">
      <summary vsli:raw="Gets the byte offset from the start of the PE image to the start of the COFF header.">PE 이미지 시작 부분에서 COFF 헤더 시작 부분까지 바이트 오프셋을 가져옵니다.</summary>
      <returns vsli:raw="The byte offset from the start of the PE image to the start of the COFF header.">PE 이미지의 시작부터 COFF 헤더 시작 까지의 바이트 오프셋입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeader">
      <summary vsli:raw="Gets the COR header.">COR 헤더를 가져옵니다.</summary>
      <returns vsli:raw="The COR header, or &lt;see langword=&quot;null&quot; /&gt; if the image does not have one.">COR 헤더 이거나, 이미지가 없는 경우 <see langword="null" />입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeaderStartOffset">
      <summary vsli:raw="Gets the byte offset from the start of the image to the COR header.">이미지 시작 위치부터 COR 헤더까지 바이트 오프셋을 가져옵니다.</summary>
      <returns vsli:raw="The byte offset from the start of the image to the COR header, or -1 if the image does not have a COR header.">이미지 시작부터 COR 헤더 까지의 바이트 오프셋 이거나, 이미지에 COR 헤더가 없는 경우-1입니다.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.GetContainingSectionIndex(System.Int32)">
      <summary vsli:raw="Searches sections of the PE image for the section that contains the specified Relative Virtual Address.">PE 이미지 섹션에서 지정된 상대 가상 주소를 포함하는 섹션을 검색합니다.</summary>
      <param name="relativeVirtualAddress" vsli:raw="The relative virtual address to search for.">검색할 상대 가상 주소입니다.</param>
      <returns vsli:raw="The index of the section that contains &lt;paramref name=&quot;relativeVirtualAddress&quot; /&gt;, or -1 if there the search is unsuccessful.">
        <paramref name="relativeVirtualAddress" />를 포함하는 섹션의 인덱스이거나 -1(검색에 실패한 경우)입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsCoffOnly">
      <summary vsli:raw="Gets a value that indicates whether the image is Coff only.">이미지가 COFF 전용인지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the image is Coff only; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">이미지가 Coff 전용 이면 <see langword="true" />이 고, 그렇지 않으면입니다. 그렇지 않으면 <see langword="false" />합니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsConsoleApplication">
      <summary vsli:raw="Gets a value that indicates whether the image represents a Windows console application.">이미지가 Windows 콘솔 애플리케이션을 나타내는지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the image is a Windows console applications; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">이미지가 Windows 콘솔 응용 프로그램 인지 여부를 <see langword="true" /> 합니다. 그렇지 않으면 <see langword="false" />합니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsDll">
      <summary vsli:raw="Gets a value that indicates whether the image represents a dynamic link library.">이미지가 동적 링크 라이브러리를 나타내는지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the image is a DLL; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">이미지가 DLL 인지 여부를 <see langword="true" /> 합니다. 그렇지 않으면 <see langword="false" />합니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsExe">
      <summary vsli:raw="Gets a value that indicates whether the image represents an executable.">이미지가 실행 파일을 나타내는지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the image is an executable; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">이미지가 실행 파일 인지 여부를 <see langword="true" /> 합니다. 그렇지 않으면 <see langword="false" />합니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataSize">
      <summary vsli:raw="Gets the size of the CLI metadata.">CLI 메타데이터의 크기를 가져옵니다.</summary>
      <returns vsli:raw="the size of the CLI metadata, or 0 if the image does not contain metadata.">CLI 메타 데이터의 크기 이거나, 이미지가 메타 데이터를 포함 하지 않는 경우 0입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataStartOffset">
      <summary vsli:raw="Gets the offset (in bytes) from the start of the PE image to the start of the CLI metadata.">PE 이미지 시작 부분에서 CLI 메타데이터 시작 부분까지 오프셋(바이트)을 가져옵니다.</summary>
      <returns vsli:raw="The offset (in bytes) from the start of the PE image to the start of the CLI metadata, or -1 if the image does not contain metadata.">PE 이미지의 시작부터 CLI 메타 데이터 시작 까지의 오프셋 (바이트)입니다. 이미지에 메타 데이터가 포함 되어 있지 않은 경우에는-1입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeader">
      <summary vsli:raw="Gets the image's PE header.">이미지의 PE 헤더를 가져옵니다.</summary>
      <returns vsli:raw="The image's PE header, or &lt;see langword=&quot;null&quot; /&gt; if the image is COFF only.">이미지의 PE 헤더 이거나, 이미지가 COFF 전용 이면 <see langword="null" />입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeaderStartOffset">
      <summary vsli:raw="Gets the byte offset of the header from the start of the image.">이미지의 시작 부분에서 헤더의 바이트 오프셋을 가져옵니다.</summary>
      <returns vsli:raw="The byte offset of the header from the start of the image.">이미지의 시작 부분에 있는 헤더의 바이트 오프셋입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.SectionHeaders">
      <summary vsli:raw="Gets the PE section headers.">PE 섹션 헤더를 가져옵니다.</summary>
      <returns vsli:raw="An array containing the PE section headers.">PE 섹션 헤더를 포함 하는 배열입니다.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.TryGetDirectoryOffset(System.Reflection.PortableExecutable.DirectoryEntry,System.Int32@)">
      <summary vsli:raw="Gets the offset (in bytes) from the start of the image to the given directory data.">이미지 시작 부분에서 지정된 디렉터리 데이터까지 오프셋(바이트)을 가져옵니다.</summary>
      <param name="directory" vsli:raw="The PE directory entry.">PE 디렉터리 항목입니다.</param>
      <param name="offset" vsli:raw="When the method returns, contains the offset from the start of the image to the given directory data.">메서드가 반환될 때 이미지 시작 부분에서 지정된 디렉터리 데이터까지 오프셋을 포함합니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the directory data is found; &lt;see langword=&quot;false&quot; /&gt; otherwise.">디렉터리 데이터가 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEMagic" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32Plus" />
    <member name="T:System.Reflection.PortableExecutable.PEMemoryBlock" />
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent">
      <summary vsli:raw="Reads the contents of the entire block into an array.">전체 블록의 내용을 배열로 읽어 들입니다.</summary>
      <returns vsli:raw="An immutable byte array.">변경할 수 없는 바이트 배열입니다.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent(System.Int32,System.Int32)">
      <summary vsli:raw="Reads the contents of a part of the block into an array.">일부 블록의 내용을 배열로 읽어 들입니다.</summary>
      <param name="start" vsli:raw="The starting position in the block.">블록 내의 시작 위치입니다.</param>
      <param name="length" vsli:raw="The number of bytes to read.">읽을 바이트 수입니다.</param>
      <returns vsli:raw="An immutable array of bytes.">변경할 수 없는 바이트 배열입니다.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The specified range is not contained within the block.">지정된 범위는 블록 내에 포함되지 않습니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Reflection.Metadata.BlobReader&quot; /&gt; for a blob spanning the entire block.">전체 블록에 걸친 blob에 대한 <see cref="T:System.Reflection.Metadata.BlobReader" />를 만듭니다.</summary>
      <returns vsli:raw="A reader for a blob spanning the entire block.">전체 블록에 걸친 blob에 대한 판독기입니다.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader(System.Int32,System.Int32)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Reflection.Metadata.BlobReader&quot; /&gt; for a blob spanning a part of the block.">블록의 일부에 걸친 blob에 대한 <see cref="T:System.Reflection.Metadata.BlobReader" />를 만듭니다.</summary>
      <param name="start" vsli:raw="The starting position in the block.">블록 내의 시작 위치입니다.</param>
      <param name="length" vsli:raw="The number of bytes in the portion of the block.">블록 부분에 있는 바이트 수입니다.</param>
      <returns vsli:raw="A reader for a blob spanning a portion of the block.">블록의 일부에 걸친 blob에 대한 판독기입니다.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The specified range is not contained within the block.">지정된 범위는 블록 내에 포함되지 않습니다.</exception>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Length">
      <summary vsli:raw="Gets the length of the block.">블록의 길이를 가져옵니다.</summary>
      <returns vsli:raw="The length of the block.">블록의 길이입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Pointer">
      <summary vsli:raw="Gets a pointer to the first byte of the block.">블록의 첫 번째 바이트에 대한 포인터를 가져옵니다.</summary>
      <returns vsli:raw="A pointer to the first byte of the block.">블록의 첫 번째 바이트에 대 한 포인터입니다.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEReader">
      <summary vsli:raw="Provides a reader for Portable Executable format (PE) files.">PE(이식 가능) 파일 형식에 대한 판독기를 제공합니다.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32)">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image stored in memory.">메모리에 저장된 PE 이미지를 통해 이식 가능한 실행 파일 판독기를 만듭니다.</summary>
      <param name="peImage" vsli:raw="A pointer to the start of the PE image.">PE 이미지의 시작에 대한 포인터입니다.</param>
      <param name="size" vsli:raw="The size of the PE image.">PE 이미지의 크기입니다.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peImage&quot; /&gt; is &lt;see cref=&quot;F:System.IntPtr.Zero&quot; /&gt;.">
        <paramref name="peImage" />가 <see cref="F:System.IntPtr.Zero" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative.">
        <paramref name="size" />가 음수입니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32,System.Boolean)">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image stored in memory. A flag indicates whether the image has already been loaded into memory.">메모리에 저장된 PE 이미지를 통해 이식 가능한 실행 파일 판독기를 만듭니다. 플래그는 이미지가 메모리에 이미 로드되었는지 여부를 나타냅니다.</summary>
      <param name="peImage" vsli:raw="A pointer to the start of the PE image.">PE 이미지의 시작에 대한 포인터입니다.</param>
      <param name="size" vsli:raw="The size of the PE image.">PE 이미지의 크기입니다.</param>
      <param name="isLoadedImage" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the PE image has been loaded into memory by the OS loader; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">OS 로더에서 PE 이미지를 메모리로 로드했으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peImage&quot; /&gt; is &lt;see cref=&quot;F:System.IntPtr.Zero&quot; /&gt;.">
        <paramref name="peImage" />가 <see cref="F:System.IntPtr.Zero" />입니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative.">
        <paramref name="size" />가 음수입니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image stored in a byte array.">바이트 배열에 저장된 PE 이미지를 통해 이식 가능한 실행 파일 판독기를 만듭니다.</summary>
      <param name="peImage" vsli:raw="An immutable array of bytes representing the PE image.">PE 이미지를 나타내는 변경할 수 없는 바이트 배열입니다.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peImage&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peImage" />가 <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream)">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image stored in a stream.">스트림에 저장된 PE 이미지를 통해 이식 가능한 실행 파일 판독기를 만듭니다.</summary>
      <param name="peStream" vsli:raw="PE image stream.">PE 이미지 스트림입니다.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peStream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peStream" />가 <see langword="null" />입니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image stored in a stream beginning at its current position and ending at the end of the stream.">스트림에 저장된 PE 이미지를 통해 스트림의 현재 위치에서 시작하여 끝에서 끝나는 이식 가능한 실행 파일 판독기를 만듭니다.</summary>
      <param name="peStream" vsli:raw="A PE image stream.">PE 이미지 스트림입니다.</param>
      <param name="options" vsli:raw="Options specifying how sections of the PE image are read from the stream.">스트림에서 PE 이미지의 섹션을 읽는 방법을 지정하는 옵션입니다.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peStream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peStream" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;options&quot; /&gt; has an invalid value.">
        <paramref name="options" />의 값이 잘못된 경우</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream (only when prefetching data).">스트림에서 읽는 중 오류가 발생했습니다(데이터를 프리페치하는 경우에만).</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;see cref=&quot;F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata&quot; /&gt; is specified, and the PE headers of the image are invalid.">
        <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" />가 지정되고 이미지의 PE 헤더가 잘못되었습니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions,System.Int32)">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image of the given size beginning at the stream's current position.">스트림의 현재 위치에서 시작하여 지정된 크기의 PE 이미지를 통해 이식 가능한 실행 파일 판독기를 만듭니다.</summary>
      <param name="peStream" vsli:raw="A PE image stream.">PE 이미지 스트림입니다.</param>
      <param name="options" vsli:raw="Options specifying how sections of the PE image are read from the stream.">스트림에서 PE 이미지의 섹션을 읽는 방법을 지정하는 옵션입니다.</param>
      <param name="size" vsli:raw="The PE image size.">PE 이미지 크기입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative or extends past the end of the stream.">
        <paramref name="size" />가 음수이거나 스트림의 끝을 넘어 확장됩니다.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream (only when prefetching data).">스트림에서 읽는 중 오류가 발생했습니다(데이터를 프리페치하는 경우에만).</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;see cref=&quot;F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata&quot; /&gt; is specified, and the PE headers of the image are invalid.">
        <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" />가 지정되고 이미지의 PE 헤더가 잘못되었습니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.Dispose">
      <summary vsli:raw="Disposes all memory allocated by the reader.">reader에 의해 할당된 모든 메로리를 삭제합니다.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetEntireImage">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEMemoryBlock&quot; /&gt; object containing the entire PE image.">전체 PE 이미지를 포함하는 <see cref="T:System.Reflection.PortableExecutable.PEMemoryBlock" /> 개체를 가져옵니다.</summary>
      <returns vsli:raw="A memory block that contains the entire PE image.">전체 PE 이미지를 포함하는 메모리 블록입니다.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The entire PE image is not available.">전체 PE 이미지를 사용할 수 없습니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetMetadata">
      <summary vsli:raw="Loads a PE section that contains CLI metadata.">CLI 메타데이터를 포함하는 PE 섹션을 로드합니다.</summary>
      <returns vsli:raw="A memory block that contains the CLI metadata.">CLI 메타데이터를 포함하는 메모리 블록입니다.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image doesn't contain metadata (&lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEReader.HasMetadata&quot; /&gt; returns &lt;see langword=&quot;false&quot; /&gt;).">PE 이미지에 메타데이터가 포함되어 있지 않습니다(<see cref="P:System.Reflection.PortableExecutable.PEReader.HasMetadata" />가 <see langword="false" /> 반환).</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The PE headers contain invalid data.">PE 헤더에 잘못된 데이터가 포함되어 있습니다.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">기본 스트림에서 읽는 동안 IO 오류가 발생했습니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.Int32)">
      <summary vsli:raw="Loads the PE section that contains the specified relative virtual address into memory and returns a memory block that starts at that address and ends at the end of the containing section.">지정된 상대 가상 주소를 포함하는 PE 섹션을 메모리로 로드하고 해당 주소에서 시작하여 포함된 섹션의 끝에서 끝나는 메모리 블록을 반환합니다.</summary>
      <param name="relativeVirtualAddress" vsli:raw="The Relative Virtual Address of the data to read.">읽을 데이터의 상대 가상 주소입니다.</param>
      <returns vsli:raw="A memory block that starts at &lt;paramref name=&quot;relativeVirtualAddress&quot; /&gt; and ends at the end of the containing section, or an empty block if &lt;paramref name=&quot;relativeVirtualAddress&quot; /&gt; doesn't represent a location in any of the PE sections of this PE image.">
        <paramref name="relativeVirtualAddress" />에서 시작하여 포함된 섹션의 끝에서 끝나는 메모리 블록이거나, <paramref name="relativeVirtualAddress" />가 이 PE 이미지의 PE 섹션에 포함된 위치를 나타내지 않는 경우 빈 블록입니다.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The PE headers contain invalid data.">PE 헤더에 잘못된 데이터가 포함되어 있습니다.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="An IO error occurred while reading from the underlying stream.">기본 스트림에서 읽는 동안 IO 오류가 발생했습니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image is not available.">PE 이미지를 사용할 수 없습니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;relativeVirtualAddress&quot; /&gt; is negative.">
        <paramref name="relativeVirtualAddress" />가 음수입니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.String)">
      <summary vsli:raw="Loads the PE section with the specified name into memory and returns a memory block that spans the section.">지정된 이름의 PE 섹션을 메모리로 로드하고 섹션을 포괄하는 메모리 블록을 반환합니다.</summary>
      <param name="sectionName" vsli:raw="The name of the section.">섹션의 이름입니다.</param>
      <returns vsli:raw="A memory block that spans the section, or an empty block if no section of the given &lt;paramref name=&quot;sectionName&quot; /&gt; exists in this PE image.">섹션을 포괄하는 메모리 블록이거나, 지정된 <paramref name="sectionName" />의 섹션이 이 PE 이미지에 없으면 빈 블록입니다.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;sectionName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="sectionName" />가 <see langword="null" />입니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image is not available.">PE 이미지를 사용할 수 없습니다.</exception>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.HasMetadata">
      <summary vsli:raw="Gets a value that indicates if the PE image contains CLI metadata.">PE 이미지에 CLI 메타데이터가 포함되어 있는지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the PE image contains CLI metadata; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">PE 이미지가 CLI 메타 데이터를 포함 하는지 여부를 <see langword="true" /> 합니다. 그렇지 않으면 <see langword="false" />합니다.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The PE headers contain invalid data.">PE 헤더에 잘못된 데이터가 포함되어 있습니다.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the underlying stream.">기본 스트림에서 읽는 동안 오류가 발생했습니다.</exception>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsEntireImageAvailable">
      <summary vsli:raw="Gets a value that indicates if the reader can access the entire PE image.">판독기에서 전체 PE 이미지에 액세스할 수 있는지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the reader can access the entire PE image; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">판독기에서 전체 PE 이미지에 액세스할 수 있는지 여부를 <see langword="true" /> 합니다. 그렇지 않으면 <see langword="false" />합니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsLoadedImage">
      <summary vsli:raw="Gets a value that indicates if the PE image has been loaded into memory by the OS loader.">OS 로더에서 PE 이미지를 메모리로 로드했는지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the PE image has been loaded into memory by the OS loader; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">OS 로더에서 PE 이미지를 메모리로 로드했으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.PEHeaders">
      <summary vsli:raw="Gets the PE headers.">PE 헤더를 가져옵니다.</summary>
      <returns vsli:raw="The PE headers for this PE image.">이 PE 이미지의 PE 헤더입니다.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The headers contain invalid data.">헤더에 잘못된 데이터가 포함되어 있습니다.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream.">스트림에서 읽는 중 오류가 발생했습니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadCodeViewDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary vsli:raw="Reads the data pointed to by the specified Debug Directory entry and interprets it as CodeView.">지정된 디버그 디렉터리 항목에서 가리키는 데이터를 읽고 CodeView로 해석합니다.</summary>
      <param name="entry" vsli:raw="A Debug Directory entry instance.">디버그 디렉터리 항목 인스턴스입니다.</param>
      <returns vsli:raw="A code view debug directory data instance.">코드 보기 디버그 디렉터리 데이터 인스턴스입니다.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;entry&quot; /&gt; is not a CodeView entry.">
        <paramref name="entry" />는 CodeView 항목이 아닙니다.</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Bad format of the data.">데이터 형식이 잘못되었습니다.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">기본 스트림에서 읽는 동안 IO 오류가 발생했습니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image is not available.">PE 이미지를 사용할 수 없습니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadDebugDirectory">
      <summary vsli:raw="Reads all Debug Directory table entries.">모든 디버그 디렉터리 테이블 항목을 읽습니다.</summary>
      <returns vsli:raw="An array of Debug Directory table entries.">디버그 디렉터리 테이블 항목의 배열입니다.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Bad format of the entry.">항목의 형식이 잘못되었습니다.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">기본 스트림에서 읽는 동안 IO 오류가 발생했습니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image is not available.">PE 이미지를 사용할 수 없습니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadEmbeddedPortablePdbDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary vsli:raw="Reads the data pointed to by the specified Debug Directory entry and interprets it as an Embedded Portable PDB blob.">지정된 디버그 디렉터리 항목에서 가리키는 데이터를 읽고 Embedded Portable PDB blob으로 해석합니다.</summary>
      <param name="entry" vsli:raw="The Debug Directory entry whose data is to be read.">데이터를 읽을 디버그 디렉터리 항목입니다.</param>
      <returns vsli:raw="The provider of a metadata reader for reading a Portable PDB image.">이식 가능한 PDB 이미지를 읽는 메타데이터 판독기의 공급자입니다.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;entry&quot; /&gt; is not a &lt;see cref=&quot;F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb&quot; /&gt; entry.">
        <paramref name="entry" />가 <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb" /> 항목이 아닌 경우</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Bad format of the data.">데이터 형식이 잘못되었습니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="PE image not available.">PE 이미지를 사용할 수 없습니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadPdbChecksumDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary vsli:raw="Reads the data pointed to by the specified Debug Directory entry and interprets it as a PDB Checksum entry.">지정된 디버그 디렉터리 항목에서 가리키는 데이터를 읽고 PDB 체크섬 항목으로 해석합니다.</summary>
      <param name="entry" vsli:raw="The Debug Directory entry whose data is to be read.">데이터를 읽을 디버그 디렉터리 항목입니다.</param>
      <returns vsli:raw="The PDB Checksum entry.">PDB 체크섬 항목입니다.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;entry&quot; /&gt; is not a PDB Checksum entry.">
        <paramref name="entry" />가 PDB 체크섬 항목이 아닙니다.</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Bad format of the data.">데이터 형식이 잘못되었습니다.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">기본 스트림에서 읽는 동안 IO 오류가 발생했습니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image is not available.">PE 이미지를 사용할 수 없습니다.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.TryOpenAssociatedPortablePdb(System.String,System.Func{System.String,System.IO.Stream},System.Reflection.Metadata.MetadataReaderProvider@,System.String@)">
      <summary vsli:raw="Opens a Portable PDB associated with this PE image.">PE 이미지와 연결된 이식 가능한 PDB를 엽니다.</summary>
      <param name="peImagePath" vsli:raw="The path to the PE image. The path is used to locate the PDB file located in the directory containing the PE file.">PE 이미지의 경로입니다. 경로는 PE 파일을 포함하는 디렉터리에 있는 PDB 파일을 찾는 데 사용됩니다.</param>
      <param name="pdbFileStreamProvider" vsli:raw="If specified, called to open a &lt;see cref=&quot;T:System.IO.Stream&quot; /&gt; for a given file path. The provider is expected to either return a readable and seekable &lt;see cref=&quot;T:System.IO.Stream&quot; /&gt;, or &lt;see langword=&quot;null&quot; /&gt; if the target file doesn't exist or should be ignored for some reason. The provider should throw &lt;see cref=&quot;T:System.IO.IOException&quot; /&gt; if it fails to open the file due to an unexpected IO error.">지정된 경우 지정된 파일 경로에 대한 <see cref="T:System.IO.Stream" />을 열기 위해 호출됩니다. 공급자는 읽을 수 있고 검색 가능한 <see cref="T:System.IO.Stream" /> 또는 <see langword="null" />(대상 파일이 없거나 어떤 이유로 무시되어야 하는 경우)을 반환해야 합니다. 예기치 않은 IO 오류로 인해 파일이 열리지 않는 경우 공급자는 <see cref="T:System.IO.IOException" />을 throw해야 합니다.</param>
      <param name="pdbReaderProvider" vsli:raw="If successful, a new instance of &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; to be used to read the Portable PDB.">성공하면 이식 가능한 PDB를 읽는 데 사용할 <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />의 새 인스턴스입니다.</param>
      <param name="pdbPath" vsli:raw="If successful and the PDB is found in a file, the path to the file, or &lt;see langword=&quot;null&quot; /&gt; if the PDB is embedded in the PE image itself.">성공하고 PDB가 파일에 있으면 파일의 경로이고 PDB가 PE 이미지 자체에 포함되어 있으면 <see langword="null" />입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the PE image has a PDB associated with it and the PDB has been successfully opened; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">PE 이미지에 PDB가 연결되어 있고 PDB가 성공적으로 열린 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peImagePath&quot; /&gt; or &lt;paramref name=&quot;pdbFileStreamProvider&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peImagePath" /> 또는 <paramref name="pdbFileStreamProvider" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The stream returned from &lt;paramref name=&quot;pdbFileStreamProvider&quot; /&gt; doesn't support read and seek operations.">
        <paramref name="pdbFileStreamProvider" />에서 반환되는 스트림은 읽기 및 검색 작업을 지원하지 않습니다.</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="No matching PDB file was found due to an error: The PE image or the PDB is invalid.">오류로 인해 일치하는 PDB 파일을 찾을 수 없습니다. PE 이미지 또는 PDB가 잘못되었습니다.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="No matching PDB file was found due to an error: An IO error occurred while reading the PE image or the PDB.">오류로 인해 일치하는 PDB 파일을 찾을 수 없습니다. PE 이미지 또는 PDB를 읽는 중 IO 오류가 발생했습니다.</exception>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEStreamOptions">
      <summary vsli:raw="Provides options that specify how sections of a PE image are read from a stream.">스트림에서 PE 이미지 섹션을 읽는 방법을 지정하는 옵션을 제공합니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.Default">
      <summary vsli:raw="By default, the stream is disposed when the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; is disposed, and sections of the PE image are read lazily.">기본적으로 스트림은 <see cref="T:System.Reflection.PortableExecutable.PEReader" />가 삭제되고 PE 이미지의 섹션이 느리게 읽혀질 때 삭제됩니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.IsLoadedImage">
      <summary vsli:raw="Indicates that the underlying PE image has been loaded into memory by the OS loader.">OS 로더에서 기본 PE 이미지를 메모리로 로드했는지 여부를 나타냅니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen">
      <summary vsli:raw="Keeps the stream open when the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; is disposed.">
        <see cref="T:System.Reflection.PortableExecutable.PEReader" />가 삭제될 때 스트림을 열린 상태로 유지합니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage">
      <summary vsli:raw="Reads the entire image into memory right away. &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; closes the stream automatically by the time the constructor returns unless &lt;see cref=&quot;F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen&quot; /&gt; is specified.">전체 이미지를 즉시 메모리로 읽습니다. <see cref="T:System.Reflection.PortableExecutable.PEReader" />는 <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" />을 지정하지 않을 경우 생성자가 반환될 때 자동으로 스트림을 닫습니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata">
      <summary vsli:raw="&lt;para&gt;Reads the metadata section into memory right away.&lt;/para&gt;&lt;para&gt;Reading from other sections of the file is not allowed (&lt;see cref=&quot;T:System.InvalidOperationException&quot; /&gt; is thrown by the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt;).&lt;/para&gt;&lt;para&gt;&lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; closes the stream automatically by the time the constructor returns unless &lt;see cref=&quot;F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen&quot; /&gt; is specified. The underlying file may be closed and even deleted after &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; is constructed.&lt;/para&gt;">메타데이터 섹션을 즉시 메모리로 읽습니다.파일의 다른 섹션에서 읽기는 허용되지 않습니다(<see cref="T:System.Reflection.PortableExecutable.PEReader" />에서 <see cref="T:System.InvalidOperationException" />을 throw함).<see cref="T:System.Reflection.PortableExecutable.PEReader" />는 <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" />을 지정하지 않을 경우 생성자가 반환될 때 자동으로 스트림을 닫습니다. 기본 파일은 닫히며 <see cref="T:System.Reflection.PortableExecutable.PEReader" />가 생성된 후에도 삭제될 수 있습니다.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ResourceSectionBuilder">
      <summary vsli:raw="Defines the base class for a PE resource section builder. Derive from &lt;see cref=&quot;T:System.Reflection.PortableExecutable.ResourceSectionBuilder&quot; /&gt; to provide serialization logic for native resources.">PE 리소스 섹션 작성기의 기본 클래스를 정의합니다. <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" />에서 파생하여 네이티브 리소스에 대한 serialization 논리를 제공합니다.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.ResourceSectionBuilder&quot; /&gt; class.">
        <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.SectionLocation)">
      <summary vsli:raw="Serializes the specified resource.">지정된 리소스를 직렬화합니다.</summary>
      <param name="builder" vsli:raw="A blob that contains the data to serialize.">직렬화할 데이터가 들어 있는 Blob입니다.</param>
      <param name="location" vsli:raw="The location to which to serialize &lt;paramref name=&quot;builder&quot; /&gt;.">
        <paramref name="builder" />를 직렬화할 위치입니다.</param>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionCharacteristics" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1024Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align128Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align16Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2048Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align256Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align32Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4096Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align512Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align64Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8192Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.AlignMask" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsCode" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsInitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsUninitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.GPRel" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerComdat" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerInfo" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerNRelocOvfl" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerOther" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerRemove" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Mem16Bit" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemDiscardable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemExecute" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemFardata" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemLocked" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotCached" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotPaged" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPreload" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemProtected" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPurgeable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemRead" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemShared" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemSysheap" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemWrite" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.NoDeferSpecExc" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeCopy" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeDSect" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeGroup" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoLoad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoPad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeOver" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeReg" />
    <member name="T:System.Reflection.PortableExecutable.SectionHeader">
      <summary vsli:raw="Provides information about the section header of a PE/COFF file.">PE/COFF 파일의 섹션 헤더에 대한 정보를 제공합니다.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.Name">
      <summary vsli:raw="Gets the name of the section.">섹션의 이름을 가져옵니다.</summary>
      <returns vsli:raw="The name of the section.">섹션의 이름입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfLineNumbers">
      <summary vsli:raw="Gets the number of line-number entries for the section.">섹션에 대한 줄 번호 항목 수를 가져옵니다.</summary>
      <returns vsli:raw="The number of line-number entries for the section.">섹션에 대 한 줄 번호 항목 수입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfRelocations">
      <summary vsli:raw="Gets the number of relocation entries for the section.">섹션에 대한 재배치 항목 수를 가져옵니다.</summary>
      <returns vsli:raw="The number of relocation entries for the section. Its value is zero for PE images.">섹션에 대 한 재배치 항목 수입니다. PE 이미지의 값은 0입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToLineNumbers">
      <summary vsli:raw="Gets the file pointer to the beginning of line-number entries for the section.">섹션에 대한 줄 번호 항목의 시작 부분을 가리키는 파일 포인터를 가져옵니다.</summary>
      <returns vsli:raw="The file pointer to the beginning of line-number entries for the section, or zero if there are no COFF line numbers.">섹션에 대 한 줄 번호 항목의 시작 부분에 대 한 파일 포인터 이거나, COFF 줄 번호가 없는 경우 0입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRawData">
      <summary vsli:raw="Gets the file pointer to the first page of the section within the COFF file.">COFF 파일 내에 있는 섹션의 첫 페이지를 가리키는 파일 포인터를 가져옵니다.</summary>
      <returns vsli:raw="The file pointer to the first page of the section within the COFF file.">COFF 파일 내에 있는 섹션의 첫 번째 페이지에 대 한 파일 포인터입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRelocations">
      <summary vsli:raw="Gets the file pointer to the beginning of relocation entries for the section.">섹션에 대한 재배치 항목의 시작 부분을 가리키는 파일 포인터를 가져옵니다.</summary>
      <returns vsli:raw="The file pointer to the beginning of relocation entries for the section. It is set to zero for PE images or if there are no relocations.">섹션에 대 한 재배치 항목의 시작 부분에 대 한 파일 포인터입니다. PE 이미지의 경우 0으로 설정 되 고, 재배치가 없으면로 설정 됩니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SectionCharacteristics">
      <summary vsli:raw="Gets the flags that describe the characteristics of the section.">섹션의 특징을 설명하는 플래그를 가져옵니다.</summary>
      <returns vsli:raw="The flags that describe the characteristics of the section.">섹션의 특성을 설명 하는 플래그입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SizeOfRawData">
      <summary vsli:raw="Gets the size of the section (for object files) or the size of the initialized data on disk (for image files).">섹션 크기(개체 파일의 경우) 또는 디스크에 있는 초기화된 데이터의 크기(이미지 파일의 경우)를 가져옵니다.</summary>
      <returns vsli:raw="The size of the section (for object files) or the size of the initialized data on disk (for image files).">디스크에 있는 섹션의 크기 (개체 파일의 경우) 또는 초기화 된 데이터 크기 (이미지 파일의 경우)입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualAddress">
      <summary vsli:raw="Gets the virtual addess of the section.">섹션의 가상 주소를 가져옵니다.</summary>
      <returns vsli:raw="The virtual address of the section.">섹션의 가상 주소입니다.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualSize">
      <summary vsli:raw="Gets the total size of the section when loaded into memory.">메모리에 로드된 섹션의 전체 크기를 가져옵니다.</summary>
      <returns vsli:raw="The total size of the section when loaded into memory.">메모리에 로드 된 경우 섹션의 총 크기입니다.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionLocation" />
    <member name="M:System.Reflection.PortableExecutable.SectionLocation.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" vsli:raw="" />
      <param name="pointerToRawData" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.PointerToRawData" />
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.RelativeVirtualAddress" />
    <member name="T:System.Reflection.PortableExecutable.Subsystem">
      <summary vsli:raw="Describes the subsystem requirement for the image.">이미지의 하위 시스템 요구 사항을 설명합니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiApplication">
      <summary vsli:raw="Extensible Firmware Interface (EFI) application.">EFI(Extensible Firmware Interface) 애플리케이션.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiBootServiceDriver">
      <summary vsli:raw="EFI driver with boot services.">부팅 서비스가 포함된 EFI 드라이버.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRom">
      <summary vsli:raw="EFI ROM image.">EFI ROM 이미지.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRuntimeDriver">
      <summary vsli:raw="EFI driver with run-time services.">런타임 서비스가 포함된 EFI 드라이버.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Native">
      <summary vsli:raw="The image doesn't require a subsystem.">이미지에 하위 시스템이 필요하지 않습니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.NativeWindows">
      <summary vsli:raw="The image is a native Win9x driver.">이미지가 네이티브 Win9x 드라이버입니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.OS2Cui">
      <summary vsli:raw="The image runs in the OS/2 character subsystem.">이미지가 OS/2 문자 하위 시스템에서 실행됩니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.PosixCui">
      <summary vsli:raw="The image runs in the Posix character subsystem.">이미지가 Posix 문자 하위 시스템에서 실행됩니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Unknown">
      <summary vsli:raw="Unknown subsystem.">알 수 없는 하위 시스템.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsBootApplication">
      <summary vsli:raw="Boot application.">부팅 애플리케이션.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCEGui">
      <summary vsli:raw="The image runs in the Windows CE subsystem.">이미지가 Windows CE 하위 시스템에서 실행됩니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCui">
      <summary vsli:raw="The image runs in the Windows character subsystem.">이미지가 Windows 문자 하위 시스템에서 실행됩니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsGui">
      <summary vsli:raw="The image runs in the Windows GUI subsystem.">이미지가 Windows GUI 하위 시스템에서 실행됩니다.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Xbox">
      <summary vsli:raw="Xbox system.">Xbox 시스템.</summary>
    </member>
  </members>
</doc>