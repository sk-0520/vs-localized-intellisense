<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:vsli="https://github.com/sk-0520/vs-localized-intellisense/tree/master/schema/2024">
  <assembly>
    <name>System.Threading</name>
  </assembly>
  <members>
    <member name="T:System.Threading.AbandonedMutexException">
      <summary vsli:raw="The exception that is thrown when one thread acquires a &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that another thread has abandoned by exiting without releasing it.">스레드가 다른 스레드에서 해제하지 않고 종료하여 중단한 <see cref="T:System.Threading.Mutex" /> 개체를 가져오면 throw되는 예외입니다.</summary>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with default values.">기본값을 사용하여 <see cref="T:System.Threading.AbandonedMutexException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.Int32,System.Threading.WaitHandle)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified index for the abandoned mutex, if applicable, and a &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the mutex.">중단된 뮤텍스의 지정된 인덱스 및 뮤텍스를 나타내는 <see cref="T:System.Threading.AbandonedMutexException" /> 개체(해당 사항이 있을 경우)를 사용하여 <see cref="T:System.Threading.Mutex" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="location" vsli:raw="The index of the abandoned mutex in the array of wait handles if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAny&quot; /&gt; method, or -1 if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitOne&quot; /&gt; or &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAll&quot; /&gt; methods.">
        <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> 메서드에 대해 예외가 throw되면 대기 핸들의 배열에서 중단된 뮤텍스의 인덱스이고, <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> 또는 <see cref="Overload:System.Threading.WaitHandle.WaitAll" /> 메서드에 대해 예외가 throw되면 –1입니다.</param>
      <param name="handle" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex.">중단된 뮤텍스를 나타내는 <see cref="T:System.Threading.Mutex" /> 개체입니다.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with serialized data.">serialize된 데이터를 사용하여 <see cref="T:System.Threading.AbandonedMutexException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object that holds the serialized object data about the exception being thrown.">발생되는 예외에 대해 직렬화된 개체 데이터를 보유하는 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체입니다.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; object that contains contextual information about the source or destination.">소스 또는 대상에 대한 컨텍스트 정보를 포함하는 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 개체입니다.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified error message.">지정된 오류 메시지를 사용하여 <see cref="T:System.Threading.AbandonedMutexException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="message" vsli:raw="An error message that explains the reason for the exception.">예외에 대한 이유를 설명하는 오류 메시지입니다.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified error message and inner exception.">지정된 오류 메시지와 내부 예외를 사용하여 <see cref="T:System.Threading.AbandonedMutexException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="message" vsli:raw="An error message that explains the reason for the exception.">예외에 대한 이유를 설명하는 오류 메시지입니다.</param>
      <param name="inner" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;inner&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">현재 예외의 원인인 예외입니다. <paramref name="inner" /> 매개 변수가 <see langword="null" />이 아니면 현재 예외는 내부 예외를 처리하는 <see langword="catch" /> 블록에서 발생합니다.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception,System.Int32,System.Threading.WaitHandle)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified error message, the inner exception, the index for the abandoned mutex, if applicable, and a &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the mutex.">지정된 오류 메시지, 내부 예외, 중단된 뮤텍스의 인덱스 및 뮤텍스를 나타내는 <see cref="T:System.Threading.AbandonedMutexException" /> 개체(해당 사항이 있을 경우)를 사용하여 <see cref="T:System.Threading.Mutex" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="message" vsli:raw="An error message that explains the reason for the exception.">예외에 대한 이유를 설명하는 오류 메시지입니다.</param>
      <param name="inner" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;inner&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">현재 예외의 원인인 예외입니다. <paramref name="inner" /> 매개 변수가 <see langword="null" />이 아니면 현재 예외는 내부 예외를 처리하는 <see langword="catch" /> 블록에서 발생합니다.</param>
      <param name="location" vsli:raw="The index of the abandoned mutex in the array of wait handles if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAny&quot; /&gt; method, or -1 if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitOne&quot; /&gt; or &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAll&quot; /&gt; methods.">
        <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> 메서드에 대해 예외가 throw되면 대기 핸들의 배열에서 중단된 뮤텍스의 인덱스이고, <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> 또는 <see cref="Overload:System.Threading.WaitHandle.WaitAll" /> 메서드에 대해 예외가 throw되면 –1입니다.</param>
      <param name="handle" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex.">중단된 뮤텍스를 나타내는 <see cref="T:System.Threading.Mutex" /> 개체입니다.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Int32,System.Threading.WaitHandle)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified error message, the index of the abandoned mutex, if applicable, and the abandoned mutex.">지정된 오류 메시지, 중단된 뮤텍스의 인덱스 및 중단된 뮤텍스(해당 사항이 있을 경우)를 사용하여 <see cref="T:System.Threading.AbandonedMutexException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="message" vsli:raw="An error message that explains the reason for the exception.">예외에 대한 이유를 설명하는 오류 메시지입니다.</param>
      <param name="location" vsli:raw="The index of the abandoned mutex in the array of wait handles if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAny&quot; /&gt; method, or -1 if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitOne&quot; /&gt; or &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAll&quot; /&gt; methods.">
        <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> 메서드에 대해 예외가 throw되면 대기 핸들의 배열에서 중단된 뮤텍스의 인덱스이고, <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> 또는 <see cref="Overload:System.Threading.WaitHandle.WaitAll" /> 메서드에 대해 예외가 throw되면 –1입니다.</param>
      <param name="handle" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex.">중단된 뮤텍스를 나타내는 <see cref="T:System.Threading.Mutex" /> 개체입니다.</param>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.Mutex">
      <summary vsli:raw="Gets the abandoned mutex that caused the exception, if known.">예외의 발생시킨 중단된 뮤텍스를 가져옵니다.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex, or &lt;see langword=&quot;null&quot; /&gt; if the abandoned mutex could not be identified.">중단된 뮤텍스를 나타내는 <see cref="T:System.Threading.Mutex" /> 개체이며, 중단된 뮤텍스를 식별할 수 없는 경우에는 <see langword="null" />입니다.</returns>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.MutexIndex">
      <summary vsli:raw="Gets the index of the abandoned mutex that caused the exception, if known.">예외의 발생시킨 중단된 뮤텍스를 가져옵니다.</summary>
      <returns vsli:raw="The index, in the array of wait handles passed to the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAny&quot; /&gt; method, of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex, or -1 if the index of the abandoned mutex could not be determined.">
        <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> 메서드에 전달 되는 대기 핸들의 배열에서 중단 된 뮤텍스를 나타내는 <see cref="T:System.Threading.Mutex" /> 개체의 인덱스 이거나, 중단 된 뮤텍스의 인덱스를 확인할 수 없는 경우-1입니다.</returns>
    </member>
    <member name="T:System.Threading.AsyncFlowControl">
      <summary vsli:raw="Provides the functionality to restore the migration, or flow, of the execution context between threads.">마이그레이션 복원 기능 또는 스레드 간 실행 컨텍스트 흐름에 대한 복원 기능을 제공합니다.</summary>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; class.">
        <see cref="T:System.Threading.AsyncFlowControl" /> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure is not used on the thread where it was created.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure has already been used to call &lt;see cref=&quot;M:System.Threading.AsyncFlowControl.Dispose&quot; /&gt; or &lt;see cref=&quot;M:System.Threading.AsyncFlowControl.Undo&quot; /&gt;.">
        <see cref="T:System.Threading.AsyncFlowControl" /> 구조체가 만들어진 스레드에서 사용되지 않은 경우
또는
<see cref="T:System.Threading.AsyncFlowControl" /> 구조체가 <see cref="M:System.Threading.AsyncFlowControl.Dispose" /> 또는 <see cref="M:System.Threading.AsyncFlowControl.Undo" /> 호출에 이미 사용된 경우</exception>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Equals(System.Object)">
      <summary vsli:raw="Determines whether the specified object is equal to the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">지정한 개체가 현재 <see cref="T:System.Threading.AsyncFlowControl" /> 구조체와 같은지 여부를 확인합니다.</summary>
      <param name="obj" vsli:raw="An object to compare with the current structure.">현재 구조체와 비교할 개체입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is an &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure and is equal to the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <paramref name="obj" />가 <see cref="T:System.Threading.AsyncFlowControl" /> 구조체이고 현재 <see cref="T:System.Threading.AsyncFlowControl" /> 구조체와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Equals(System.Threading.AsyncFlowControl)">
      <summary vsli:raw="Determines whether the specified &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure is equal to the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">지정한 <see cref="T:System.Threading.AsyncFlowControl" /> 구조체가 현재 <see cref="T:System.Threading.AsyncFlowControl" /> 구조체와 같은지 여부를 확인합니다.</summary>
      <param name="obj" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure to compare with the current structure.">현재 구조체와 비교할 <see cref="T:System.Threading.AsyncFlowControl" /> 구조체입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is equal to the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <paramref name="obj" />가 현재 <see cref="T:System.Threading.AsyncFlowControl" />과 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.GetHashCode">
      <summary vsli:raw="Gets a hash code for the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">현재 <see cref="T:System.Threading.AsyncFlowControl" /> 구조체의 해시 코드를 가져옵니다.</summary>
      <returns vsli:raw="A hash code for the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">현재 <see cref="T:System.Threading.AsyncFlowControl" /> 구조체의 해시 코드입니다.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.op_Equality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)">
      <summary vsli:raw="Compares two &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structures to determine whether they are equal.">두 <see cref="T:System.Threading.AsyncFlowControl" /> 구조체가 동일한지 비교합니다.</summary>
      <param name="a" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">
        <see cref="T:System.Threading.AsyncFlowControl" /> 구조체입니다.</param>
      <param name="b" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">
        <see cref="T:System.Threading.AsyncFlowControl" /> 구조체입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two structures are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">두 구조체가 동일하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.op_Inequality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)">
      <summary vsli:raw="Compares two &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structures to determine whether they are not equal.">두 <see cref="T:System.Threading.AsyncFlowControl" /> 구조체가 동일하지 않은지 비교합니다.</summary>
      <param name="a" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">
        <see cref="T:System.Threading.AsyncFlowControl" /> 구조체입니다.</param>
      <param name="b" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">
        <see cref="T:System.Threading.AsyncFlowControl" /> 구조체입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the structures are not equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">두 구조체가 개체가 동일하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Undo">
      <summary vsli:raw="Restores the flow of the execution context between threads.">스레드 간 실행 컨텍스트의 흐름을 복원합니다.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure is not used on the thread where it was created.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure has already been used to call &lt;see cref=&quot;M:System.Threading.AsyncFlowControl.Dispose&quot; /&gt; or &lt;see cref=&quot;M:System.Threading.AsyncFlowControl.Undo&quot; /&gt;.">
        <see cref="T:System.Threading.AsyncFlowControl" /> 구조체가 만들어진 스레드에서 사용되지 않은 경우
또는
<see cref="T:System.Threading.AsyncFlowControl" /> 구조체가 <see cref="M:System.Threading.AsyncFlowControl.Dispose" /> 또는 <see cref="M:System.Threading.AsyncFlowControl.Undo" /> 호출에 이미 사용된 경우</exception>
    </member>
    <member name="T:System.Threading.AsyncLocal`1">
      <summary vsli:raw="Represents ambient data that is local to a given asynchronous control flow, such as an asynchronous method.">비동기 메서드와 같은 지정된 비동기 제어 흐름에 로컬인 앰비언트 데이터를 나타냅니다.</summary>
      <typeparam name="T" vsli:raw="The type of the ambient data.">앰비언트 데이터의 형식입니다.</typeparam>
    </member>
    <member name="M:System.Threading.AsyncLocal`1.#ctor">
      <summary vsli:raw="Instantiates an &lt;see cref=&quot;T:System.Threading.AsyncLocal`1&quot; /&gt; instance that does not receive change notifications.">변경 알림을 받지 않는 <see cref="T:System.Threading.AsyncLocal`1" /> 인스턴스를 인스턴스화합니다.</summary>
    </member>
    <member name="M:System.Threading.AsyncLocal`1.#ctor(System.Action{System.Threading.AsyncLocalValueChangedArgs{`0}})">
      <summary vsli:raw="Instantiates an &lt;see cref=&quot;T:System.Threading.AsyncLocal`1&quot; /&gt; local instance that receives change notifications.">변경 알림을 받는 <see cref="T:System.Threading.AsyncLocal`1" /> 로컬 인스턴스를 인스턴스화합니다.</summary>
      <param name="valueChangedHandler" vsli:raw="The delegate that is called whenever the current value changes on any thread.">스레드에서 현재 값이 변경될 때마다 호출되는 대리자입니다.</param>
    </member>
    <member name="P:System.Threading.AsyncLocal`1.Value">
      <summary vsli:raw="Gets or sets the value of the ambient data.">앰비언트 데이터의 값을 가져오거나 설정합니다.</summary>
      <returns vsli:raw="The value of the ambient data. If no value has been set, the returned value is &lt;c&gt;default(T)&lt;/c&gt;.">앰비언트 데이터의 값입니다. 값이 설정 되지 않은 경우 반환 되는 값은 <c>default (T)</c>입니다.</returns>
    </member>
    <member name="T:System.Threading.AsyncLocalValueChangedArgs`1">
      <summary vsli:raw="The class that provides data change information to &lt;see cref=&quot;T:System.Threading.AsyncLocal`1&quot; /&gt; instances that register for change notifications.">변경 알림을 등록하는 <see cref="T:System.Threading.AsyncLocal`1" /> 인스턴스에 데이터 변경 정보를 제공하는 클래스입니다.</summary>
      <typeparam name="T" vsli:raw="The type of the data.">데이터 형식입니다.</typeparam>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.CurrentValue">
      <summary vsli:raw="Gets the data's current value.">데이터의 현재 값을 가져옵니다.</summary>
      <returns vsli:raw="The data's current value.">데이터의 현재 값입니다.</returns>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.PreviousValue">
      <summary vsli:raw="Gets the data's previous value.">데이터의 이전 값을 가져옵니다.</summary>
      <returns vsli:raw="The data's previous value.">데이터의 이전 값입니다.</returns>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.ThreadContextChanged">
      <summary vsli:raw="Returns a value that indicates whether the value changes because of a change of execution context.">실행 컨텍스트가 변경되어 값이 변경되었는지 여부를 나타내는 값을 반환합니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the value changed because of a change of execution context; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">실행 컨텍스트가 변경되어 값이 변경되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="T:System.Threading.AutoResetEvent">
      <summary vsli:raw="Represents a thread synchronization event that, when signaled, resets automatically after releasing a single waiting thread. This class cannot be inherited.">단일 대기 스레드를 해제한 후에 신호를 받으면 자동으로 재설정되는 스레드 동기화 이벤트를 나타냅니다. 이 클래스는 상속될 수 없습니다.</summary>
    </member>
    <member name="M:System.Threading.AutoResetEvent.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AutoResetEvent&quot; /&gt; class with a Boolean value indicating whether to set the initial state to signaled.">초기 상태를 신호 받음으로 설정할지 여부를 나타내는 부울 값을 사용하여 <see cref="T:System.Threading.AutoResetEvent" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state to signaled; &lt;see langword=&quot;false&quot; /&gt; to set the initial state to non-signaled.">초기 상태를 신호 받음으로 설정하려면 <see langword="true" />를 사용하고 초기 상태를 신호 없음으로 설정하려면 <see langword="false" />를 사용합니다.</param>
    </member>
    <member name="T:System.Threading.Barrier">
      <summary vsli:raw="Enables multiple tasks to cooperatively work on an algorithm in parallel through multiple phases.">여러 작업이 여러 단계에 걸쳐 특정 알고리즘에서 병렬로 함께 작동할 수 있도록 합니다.</summary>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; class.">
        <see cref="T:System.Threading.Barrier" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="participantCount" vsli:raw="The number of participating threads.">참여 스레드의 수입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;participantCount&quot; /&gt; is less than 0 or greater than 32,767.">
        <paramref name="participantCount" />가 0보다 작거나 32,767보다 큽니다.</exception>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32,System.Action{System.Threading.Barrier})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; class.">
        <see cref="T:System.Threading.Barrier" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="participantCount" vsli:raw="The number of participating threads.">참여 스레드의 수입니다.</param>
      <param name="postPhaseAction" vsli:raw="The &lt;see cref=&quot;T:System.Action`1&quot; /&gt; to be executed after each phase. null (Nothing in Visual Basic) may be passed to indicate no action is taken.">각 단계 후에 실행할 <see cref="T:System.Action`1" />입니다. 아무 작업도 수행되지 않았음을 나타내기 위해 null(Visual Basic의 경우 Nothing)이 전달될 수 있습니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;participantCount&quot; /&gt; is less than 0 or greater than 32,767.">
        <paramref name="participantCount" />가 0보다 작거나 32,767보다 큽니다.</exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipant">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; that there will be an additional participant.">추가 참가자가 있음을 <see cref="T:System.Threading.Barrier" />에 알립니다.</summary>
      <returns vsli:raw="The phase number of the barrier in which the new participants will first participate.">새 참가자가 처음으로 참여할 장벽의 단계 번호입니다.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Adding a participant would cause the barrier's participant count to exceed 32,767.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method was invoked from within a post-phase action.">참가자를 추가하면 해당 장애물 참가자 수가 32,767을 초과하게 됩니다.
또는
이 메서드는 사후 단계 작업 내에서 호출되었습니다.</exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipants(System.Int32)">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; that there will be additional participants.">추가 참가자가 있음을 <see cref="T:System.Threading.Barrier" />에 알립니다.</summary>
      <param name="participantCount" vsli:raw="The number of additional participants to add to the barrier.">장벽에 추가할 추가 참가자의 수입니다.</param>
      <returns vsli:raw="The phase number of the barrier in which the new participants will first participate.">새 참가자가 처음으로 참여할 장벽의 단계 번호입니다.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;participantCount&quot; /&gt; is less than 0.  &#xA;  &#xA; -or-  &#xA;  &#xA; Adding &lt;paramref name=&quot;participantCount&quot; /&gt; participants would cause the barrier's participant count to exceed 32,767.">
        <paramref name="participantCount" />가 0보다 작은 경우
또는
<paramref name="participantCount" /> 참가자를 추가하면 해당 장애물 참가자 수가 32,767을 초과하게 됩니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action.">이 메서드는 사후 단계 작업 내에서 호출되었습니다.</exception>
    </member>
    <member name="P:System.Threading.Barrier.CurrentPhaseNumber">
      <summary vsli:raw="Gets the number of the barrier's current phase.">장벽의 현재 단계 번호를 가져옵니다.</summary>
      <returns vsli:raw="Returns the number of the barrier's current phase.">장벽의 현재 단계 번호를 반환합니다.</returns>
    </member>
    <member name="M:System.Threading.Barrier.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; class.">
        <see cref="T:System.Threading.Barrier" /> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action.">이 메서드는 사후 단계 작업 내에서 호출되었습니다.</exception>
    </member>
    <member name="M:System.Threading.Barrier.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt;, and optionally releases the managed resources.">
        <see cref="T:System.Threading.Barrier" />에서 사용하는 관리되지 않는 리소스를 해제하고, 관리되는 리소스를 선택적으로 해제할 수 있습니다.</summary>
      <param name="disposing" vsli:raw="true to release both managed and unmanaged resources; false to release only unmanaged resources.">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 true이고, 관리되지 않는 리소스만 해제하려면 false입니다.</param>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantCount">
      <summary vsli:raw="Gets the total number of participants in the barrier.">장벽에 있는 참가자의 총 수를 가져옵니다.</summary>
      <returns vsli:raw="Returns the total number of participants in the barrier.">장벽에 있는 참가자의 총 수를 반환합니다.</returns>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantsRemaining">
      <summary vsli:raw="Gets the number of participants in the barrier that haven't yet signaled in the current phase.">현재 단계에서 아직 신호를 받지 않은 장벽의 참가자 수를 가져옵니다.</summary>
      <returns vsli:raw="Returns the number of participants in the barrier that haven't yet signaled in the current phase.">현재 단계에서 아직 신호를 받지 않은 장벽에 있는 참가자의 수를 반환 합니다.</returns>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipant">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; that there will be one less participant.">참가자가 하나 감소함을 <see cref="T:System.Threading.Barrier" />에 알립니다.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The barrier already has 0 participants.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method was invoked from within a post-phase action.">해당 장애물에 이미 0 참가자가 있습니다.
또는
이 메서드는 사후 단계 작업 내에서 호출되었습니다.</exception>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipants(System.Int32)">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; that there will be fewer participants.">참가자가 감소함을 <see cref="T:System.Threading.Barrier" />에 알립니다.</summary>
      <param name="participantCount" vsli:raw="The number of additional participants to remove from the barrier.">장벽에서 제거할 추가 참가자의 수입니다.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The total participant count is less than the specified &lt;paramref name=&quot;participantCount&quot; /&gt;">총 참가자 수가 지정된 <paramref name="participantCount" />보다 작습니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The barrier already has 0 participants.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method was invoked from within a post-phase action.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current participant count is less than the specified participantCount.">해당 장애물에 이미 0 참가자가 있습니다.
또는
이 메서드는 사후 단계 작업 내에서 호출되었습니다.
또는
현재 참가자 수가 지정된 participantCount보다 작습니다.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well.">참가자가 장벽에 도달했다는 신호를 보내고 다른 모든 참가자도 장벽에 도달할 때까지 기다립니다.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">메서드는 사후 단계 작업 내에서 호출되며 현재 장애물에 0 참가자가 있거나 장애물이 참가자로 등록된 것보다 많은 스레드에서 신호를 받습니다.</exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException" vsli:raw="If an exception is thrown from the post phase action of a Barrier after all participating threads have called SignalAndWait, the exception will be wrapped in a BarrierPostPhaseException and be thrown on all participating threads.">모든 참가 스레드가 SignalAndWait를 호출한 후에 Barrier의 단계 후 작업에서 예외가 throw되는 경우 예외가 BarrierPostPhaseException에서 래핑되고 모든 참가 스레드에서 throw됩니다.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a 32-bit signed integer to measure the timeout.">참가자가 장벽에 도달했다는 신호를 보내고 부호 있는 32비트 정수로 시간 제한을 측정하여 다른 모든 참가자도 장벽에 도달할 때까지 기다립니다.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if all participants reached the barrier within the specified time; otherwise &lt;see langword=&quot;false&quot; /&gt;.">지정된 시간 내에 모든 참가자가 장벽에 도달했으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">메서드는 사후 단계 작업 내에서 호출되며 현재 장애물에 0 참가자가 있거나 장애물이 참가자로 등록된 것보다 많은 스레드에서 신호를 받습니다.</exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException" vsli:raw="If an exception is thrown from the post phase action of a Barrier after all participating threads have called SignalAndWait, the exception will be wrapped in a BarrierPostPhaseException and be thrown on all participating threads.">모든 참가 스레드가 SignalAndWait를 호출한 후에 Barrier의 단계 후 작업에서 예외가 throw되는 경우 예외가 BarrierPostPhaseException에서 래핑되고 모든 참가 스레드에서 throw됩니다.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a 32-bit signed integer to measure the timeout, while observing a cancellation token.">참가자가 장벽에 도달했다는 신호를 보내고 취소 토큰을 확인하면서 부호 있는 32비트 정수로 시간 제한을 측정하여 다른 모든 참가자도 장벽에 도달할 때까지 기다립니다.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">확인할 <see cref="T:System.Threading.CancellationToken" />입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if all participants reached the barrier within the specified time; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">지정된 시간 내에 모든 참가자가 장벽에 도달했으면 true이고, 그렇지 않으면 false입니다.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" />이 취소되었습니다.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">메서드는 사후 단계 작업 내에서 호출되며 현재 장애물에 0 참가자가 있거나 장애물이 참가자로 등록된 것보다 많은 스레드에서 신호를 받습니다.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Threading.CancellationToken)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier, while observing a cancellation token.">참가자가 장벽에 도달했다는 신호를 보내고 취소 토큰을 확인하면서 다른 모든 참가자도 장벽에 도달할 때까지 기다립니다.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">확인할 <see cref="T:System.Threading.CancellationToken" />입니다.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" />이 취소되었습니다.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">메서드는 사후 단계 작업 내에서 호출되며 현재 장애물에 0 참가자가 있거나 장애물이 참가자로 등록된 것보다 많은 스레드에서 신호를 받습니다.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; object to measure the time interval.">참가자가 장벽에 도달했다는 신호를 보내고 <see cref="T:System.TimeSpan" /> 개체를 사용하여 시간 간격을 측정하여 다른 참가자도 장벽에 도달할 때까지 기다립니다.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">대기할 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />이거나, 무한 대기하도록 -1밀리초를 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if all other participants reached the barrier; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">다른 모든 참가자가 장벽에 도달했으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out, or it is greater than 32,767.">
        <paramref name="timeout" />이 무기한 시간 제한을 나타내는 -1밀리초 이외의 음수이거나 시간 제한이 없거나, 32,767보다 큽니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">메서드는 사후 단계 작업 내에서 호출되며 현재 장애물에 0 참가자가 있거나 장애물이 참가자로 등록된 것보다 많은 스레드에서 신호를 받습니다.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; object to measure the time interval, while observing a cancellation token.">참가자가 장벽에 도달했다는 신호를 보내고 취소 토큰을 확인하면서 <see cref="T:System.TimeSpan" /> 개체를 사용하여 시간 제한을 측정하여 다른 모든 참가자도 장벽에 도달할 때까지 기다립니다.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">대기할 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />이거나, 무한 대기하도록 -1밀리초를 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">확인할 <see cref="T:System.Threading.CancellationToken" />입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if all other participants reached the barrier; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">다른 모든 참가자가 장벽에 도달했으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" />이 취소되었습니다.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out.">
        <paramref name="timeout" />은 시간 제한이 없음을 나타내는 -1밀리초 이외의 음수입니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">메서드는 사후 단계 작업 내에서 호출되며 현재 장애물에 0 참가자가 있거나 장애물이 참가자로 등록된 것보다 많은 스레드에서 신호를 받습니다.</exception>
    </member>
    <member name="T:System.Threading.BarrierPostPhaseException">
      <summary vsli:raw="The exception that is thrown when the post-phase action of a &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; fails.">
        <see cref="T:System.Threading.Barrier" />의 사후 단계 작업이 실패할 경우 throw되는 예외입니다.</summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with a system-supplied message that describes the error.">오류를 설명하는 시스템 제공 메시지를 사용하여 <see cref="T:System.Threading.BarrierPostPhaseException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with the specified inner exception.">지정된 내부 예외를 사용하여 <see cref="T:System.Threading.BarrierPostPhaseException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception.">현재 예외의 원인인 예외입니다.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with serialized data.">serialize된 데이터를 사용하여 <see cref="T:System.Threading.BarrierPostPhaseException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="info" vsli:raw="The object that holds the serialized object data.">serialize된 개체 데이터를 보유하는 개체입니다.</param>
      <param name="context" vsli:raw="The contextual information about the source or destination.">원본 또는 대상에 대한 컨텍스트 정보입니다.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with a specified message that describes the error.">
        <see cref="T:System.Threading.BarrierPostPhaseException" /> 클래스의 새 인스턴스를 오류를 설명하는 지정된 메시지로 초기화합니다.</summary>
      <param name="message" vsli:raw="The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.">예외를 설명하는 메시지입니다. 이 생성자의 호출자는 이 문자열이 현재 시스템 문화권에 맞게 지역화되었는지 확인하는 데 필요합니다.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">지정된 오류 메시지와 해당 예외의 원인인 내부 예외에 대한 참조를 사용하여 <see cref="T:System.Threading.BarrierPostPhaseException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="message" vsli:raw="The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.">예외를 설명하는 메시지입니다. 이 생성자의 호출자는 이 문자열이 현재 시스템 문화권에 맞게 지역화되었는지 확인하는 데 필요합니다.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">현재 예외의 원인인 예외입니다. <paramref name="innerException" /> 매개 변수가 <see langword="null" />이 아니면 현재 예외는 내부 예외를 처리하는 <see langword="catch" /> 블록에서 발생합니다.</param>
    </member>
    <member name="T:System.Threading.ContextCallback">
      <summary vsli:raw="Represents a method to be called within a new context.">새 컨텍스트 내에서 호출될 메서드를 나타냅니다.</summary>
      <param name="state" vsli:raw="An object containing information to be used by the callback method each time it executes.">콜백 메서드가 실행될 때마다 사용할 정보가 포함된 개체입니다.</param>
    </member>
    <member name="T:System.Threading.CountdownEvent">
      <summary vsli:raw="Represents a synchronization primitive that is signaled when its count reaches zero.">수가 0에 도달하는 경우 신호를 받는 동기화 기본 형식을 나타냅니다.</summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.#ctor(System.Int32)">
      <summary vsli:raw="Initializes a new instance of &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; class with the specified count.">지정된 수를 사용하여 <see cref="T:System.Threading.CountdownEvent" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="initialCount" vsli:raw="The number of signals initially required to set the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;.">
        <see cref="T:System.Threading.CountdownEvent" />를 설정하는 데 처음 필요한 신호의 수입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="initialCount" />가 0보다 작은 경우</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount">
      <summary vsli:raw="Increments the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;'s current count by one.">
        <see cref="T:System.Threading.CountdownEvent" />의 현재 수를 1씩 늘립니다.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current instance is already set.&#xA;&#xA; -or-&#xA;&#xA; &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is equal to or greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">현재 인스턴스가 이미 설정되어 있습니다.
또는
<see cref="P:System.Threading.CountdownEvent.CurrentCount" />가 <see cref="F:System.Int32.MaxValue" />보다 크거나 같은 경우</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount(System.Int32)">
      <summary vsli:raw="Increments the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;'s current count by a specified value.">
        <see cref="T:System.Threading.CountdownEvent" />의 현재 수를 지정된 값만큼 늘립니다.</summary>
      <param name="signalCount" vsli:raw="The value by which to increase &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt;.">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" />를 늘릴 값입니다.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;signalCount&quot; /&gt; is less than or equal to 0.">
        <paramref name="signalCount" />가 0보다 작거나 같은 경우</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current instance is already set.&#xA;&#xA; -or-&#xA;&#xA; &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is equal to or greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; after count is incremented by &lt;paramref name=&quot;signalCount&quot; /&gt;.">현재 인스턴스가 이미 설정되어 있습니다.
또는
개수가 <paramref name="signalCount." /> 만큼 증가된 후에 <see cref="P:System.Threading.CountdownEvent.CurrentCount" />가 <see cref="F:System.Int32.MaxValue" />보다 크거나 같은 경우</exception>
    </member>
    <member name="P:System.Threading.CountdownEvent.CurrentCount">
      <summary vsli:raw="Gets the number of remaining signals required to set the event.">이벤트를 설정하는 데 필요한 남아 있는 신호의 수를 가져옵니다.</summary>
      <returns vsli:raw="The number of remaining signals required to set the event.">이벤트를 설정하는 데 필요한 남아 있는 신호의 수입니다.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; class.">
        <see cref="T:System.Threading.CountdownEvent" /> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;, and optionally releases the managed resources.">
        <see cref="T:System.Threading.CountdownEvent" />에서 사용하는 관리되지 않는 리소스를 해제하고, 관리되는 리소스를 선택적으로 해제할 수 있습니다.</summary>
      <param name="disposing" vsli:raw="true to release both managed and unmanaged resources; false to release only unmanaged resources.">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 true이고, 관리되지 않는 리소스만 해제하려면 false입니다.</param>
    </member>
    <member name="P:System.Threading.CountdownEvent.InitialCount">
      <summary vsli:raw="Gets the numbers of signals initially required to set the event.">이벤트를 설정하는 데 처음으로 필요한 신호의 수를 가져옵니다.</summary>
      <returns vsli:raw="The number of signals initially required to set the event.">이벤트를 설정하는 데 처음으로 필요한 신호의 수입니다.</returns>
    </member>
    <member name="P:System.Threading.CountdownEvent.IsSet">
      <summary vsli:raw="Indicates whether the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; object's current count has reached zero.">
        <see cref="T:System.Threading.CountdownEvent" /> 개체의 현재 개수가 0에 도달했는지 여부를 나타냅니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current count is zero; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">현재 개수가 0이면<see langword="true" /> 이고, 0이 아니면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset">
      <summary vsli:raw="Resets the &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; to the value of &lt;see cref=&quot;P:System.Threading.CountdownEvent.InitialCount&quot; /&gt;.">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" />를 <see cref="P:System.Threading.CountdownEvent.InitialCount" />의 값으로 다시 설정합니다.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset(System.Int32)">
      <summary vsli:raw="Resets the &lt;see cref=&quot;P:System.Threading.CountdownEvent.InitialCount&quot; /&gt; property to a specified value.">
        <see cref="P:System.Threading.CountdownEvent.InitialCount" /> 속성을 지정된 값으로 재설정합니다.</summary>
      <param name="count" vsli:raw="The number of signals required to set the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;.">
        <see cref="T:System.Threading.CountdownEvent" />를 설정하는 데 필요한 신호의 수입니다.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;count&quot; /&gt; is less than 0.">
        <paramref name="count" />가 0보다 작은 경우</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal">
      <summary vsli:raw="Registers a signal with the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;, decrementing the value of &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt;.">
        <see cref="T:System.Threading.CountdownEvent" />의 값을 줄이면서 신호를 <see cref="P:System.Threading.CountdownEvent.CurrentCount" />에 등록합니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the signal caused the count to reach zero and the event was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">신호로 인해 수가 0에 도달하고 이벤트가 설정되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current instance is already set.">현재 인스턴스가 이미 설정되어 있습니다.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal(System.Int32)">
      <summary vsli:raw="Registers multiple signals with the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;, decrementing the value of &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; by the specified amount.">지정된 양만큼 <see cref="T:System.Threading.CountdownEvent" /> 값을 줄이면서 여러 신호를 <see cref="P:System.Threading.CountdownEvent.CurrentCount" />에 등록합니다.</summary>
      <param name="signalCount" vsli:raw="The number of signals to register.">등록할 신호의 수입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the signals caused the count to reach zero and the event was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">신호로 인해 수가 0에 도달하고 이벤트가 설정되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;signalCount&quot; /&gt; is less than 1.">
        <paramref name="signalCount" />가 1보다 작습니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current instance is already set. -or- Or &lt;paramref name=&quot;signalCount&quot; /&gt; is greater than &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt;.">현재 인스턴스가 이미 설정되어 있습니다. -또는- <paramref name="signalCount" />가 <see cref="P:System.Threading.CountdownEvent.CurrentCount" />보다 큰 경우</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount">
      <summary vsli:raw="Attempts to increment &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; by one.">하나씩 <see cref="P:System.Threading.CountdownEvent.CurrentCount" />를 증가하려고 시도했습니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the increment succeeded; otherwise, false. If &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is already at zero, this method will return &lt;see langword=&quot;false&quot; /&gt;.">늘렸으면 <see langword="true" />이고 그렇지 않으면 false입니다. <see cref="P:System.Threading.CountdownEvent.CurrentCount" />가 이미 0이면 이 메서드에서 <see langword="false" />를 반환합니다.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is equal to &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" />가 <see cref="F:System.Int32.MaxValue" />와 같은 경우</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount(System.Int32)">
      <summary vsli:raw="Attempts to increment &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; by a specified value.">지정된 값만큼 <see cref="P:System.Threading.CountdownEvent.CurrentCount" />를 증가하려고 시도했습니다.</summary>
      <param name="signalCount" vsli:raw="The value by which to increase &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt;.">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" />를 늘릴 값입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the increment succeeded; otherwise, false. If &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is already at zero this will return &lt;see langword=&quot;false&quot; /&gt;.">늘렸으면 <see langword="true" />이고 그렇지 않으면 false입니다. <see cref="P:System.Threading.CountdownEvent.CurrentCount" />가 이미 0이면 <see langword="false" />를 반환합니다.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;signalCount&quot; /&gt; is less than or equal to 0.">
        <paramref name="signalCount" />가 0보다 작거나 같은 경우</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; + &lt;paramref name=&quot;signalCount&quot; /&gt; is equal to or greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> + <paramref name="signalCount" />가 <see cref="F:System.Int32.MaxValue" />보다 크거나 같습니다.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set.">
        <see cref="T:System.Threading.CountdownEvent" />가 설정될 때까지 현재 스레드를 차단합니다.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, using a 32-bit signed integer to measure the timeout.">부호 있는 32비트 정수로 시간 제한을 측정하여 <see cref="T:System.Threading.CountdownEvent" />가 설정될 때까지 현재 스레드를 차단합니다.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see cref="T:System.Threading.CountdownEvent" />가 설정되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, using a 32-bit signed integer to measure the timeout, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">
        <see cref="T:System.Threading.CountdownEvent" />을 확인하면서 부호 있는 32비트 정수로 시간 제한을 측정하여 <see cref="T:System.Threading.CancellationToken" />가 설정될 때까지 현재 스레드를 차단합니다.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">확인할 <see cref="T:System.Threading.CancellationToken" />입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see cref="T:System.Threading.CountdownEvent" />가 설정되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" />이 취소되었습니다.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed. -or- The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">현재 인스턴스가 이미 삭제된 경우 -또는- <paramref name="cancellationToken" />을 만든 <see cref="T:System.Threading.CancellationTokenSource" />가 이미 삭제되었습니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">
        <see cref="T:System.Threading.CountdownEvent" />을 확인하면서 <see cref="T:System.Threading.CancellationToken" />가 설정될 때까지 현재 스레드를 차단합니다.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">확인할 <see cref="T:System.Threading.CancellationToken" />입니다.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" />이 취소되었습니다.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.&#xA;&#xA;-or-&#xA;&#xA;The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">현재 인스턴스가 이미 삭제된 경우 -또는- <paramref name="cancellationToken" />을 만든 <see cref="T:System.Threading.CancellationTokenSource" />가 이미 삭제되었습니다.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the timeout.">
        <see cref="T:System.Threading.CountdownEvent" />으로 시간 제한을 측정하여 <see cref="T:System.TimeSpan" />가 설정될 때까지 현재 스레드를 차단합니다.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">대기할 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />이거나, 무한 대기하도록 -1밀리초를 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see cref="T:System.Threading.CountdownEvent" />가 설정되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" />이 무기한 시간 제한을 나타내는 -1밀리초 이외의 음수이거나 시간 제한이 <see cref="F:System.Int32.MaxValue" />보다 큰 경우.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the timeout, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">
        <see cref="T:System.Threading.CountdownEvent" />을 확인하면서 <see cref="T:System.TimeSpan" />으로 시간 제한을 측정하여 <see cref="T:System.Threading.CancellationToken" />가 설정될 때까지 현재 스레드를 차단합니다.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">대기할 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />이거나, 무한 대기하도록 -1밀리초를 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">확인할 <see cref="T:System.Threading.CancellationToken" />입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see cref="T:System.Threading.CountdownEvent" />가 설정되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" />이 취소되었습니다.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed. -or- The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">현재 인스턴스가 이미 삭제된 경우 -또는- <paramref name="cancellationToken" />을 만든 <see cref="T:System.Threading.CancellationTokenSource" />가 이미 삭제되었습니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" />이 무기한 시간 제한을 나타내는 -1밀리초 이외의 음수이거나 시간 제한이 <see cref="F:System.Int32.MaxValue" />보다 큰 경우.</exception>
    </member>
    <member name="P:System.Threading.CountdownEvent.WaitHandle">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; that is used to wait for the event to be set.">이벤트가 설정될 때까지 대기하는 데 사용되는 <see cref="T:System.Threading.WaitHandle" />을 가져옵니다.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; that is used to wait for the event to be set.">이벤트가 설정될 때까지 대기하는 데 사용되는 <see cref="T:System.Threading.WaitHandle" />입니다.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
    </member>
    <member name="T:System.Threading.EventResetMode">
      <summary vsli:raw="Indicates whether an &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; is reset automatically or manually after receiving a signal.">
        <see cref="T:System.Threading.EventWaitHandle" />이 신호를 받은 후 자동이나 수동으로 다시 설정되는지 여부를 나타냅니다.</summary>
    </member>
    <member name="F:System.Threading.EventResetMode.AutoReset">
      <summary vsli:raw="When signaled, the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; resets automatically after releasing a single thread. If no threads are waiting, the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; remains signaled until a thread blocks, and resets after releasing the thread.">신호를 받으면 <see cref="T:System.Threading.EventWaitHandle" />이 스레드 하나를 해제한 후 자동으로 다시 설정됩니다. 대기 중인 스레드가 없으면 <see cref="T:System.Threading.EventWaitHandle" />은 스레드가 차단될 때까지 신호를 받은 상태로 유지되다가 스레드를 해제한 후 다시 설정됩니다.</summary>
    </member>
    <member name="F:System.Threading.EventResetMode.ManualReset">
      <summary vsli:raw="When signaled, the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; releases all waiting threads and remains signaled until it is manually reset.">신호를 받으면 <see cref="T:System.Threading.EventWaitHandle" />이 대기하는 스레드를 모두 해제하고 수동으로 다시 설정될 때까지 신호를 받은 상태로 유지됩니다.</summary>
    </member>
    <member name="T:System.Threading.EventWaitHandle">
      <summary vsli:raw="Represents a thread synchronization event.">스레드 동기화 이벤트를 나타냅니다.</summary>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.">대기 핸들의 초기 상태를 신호 받음으로 설정할지 여부와 대기 핸들을 자동으로 다시 설정할지 수동으로 다시 설정할지 여부를 지정하여 <see cref="T:System.Threading.EventWaitHandle" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state to signaled; &lt;see langword=&quot;false&quot; /&gt; to set it to nonsignaled.">초기 상태를 신호 받음으로 설정하려면 <see langword="true" />를 사용하고 초기 상태를 신호 없음으로 설정하려면 <see langword="false" />를 사용합니다.</param>
      <param name="mode" vsli:raw="One of the &lt;see cref=&quot;T:System.Threading.EventResetMode&quot; /&gt; values that determines whether the event resets automatically or manually.">이벤트가 자동으로 다시 설정되는지 또는 수동으로 다시 설정되는지를 결정하는 <see cref="T:System.Threading.EventResetMode" /> 값 중 하나입니다.</param>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.">이 호출의 결과로 만들어진 대기 핸들의 초기 상태를 신호 받음으로 설정할지 여부, 대기 핸들을 자동으로 다시 설정할지 수동으로 다시 설정할지 여부 및 시스템 동기화 이벤트의 이름을 지정하여 <see cref="T:System.Threading.EventWaitHandle" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state to signaled if the named event is created as a result of this call; &lt;see langword=&quot;false&quot; /&gt; to set it to nonsignaled.">명명된 이벤트가 이 호출의 결과로 만들어지는 경우 초기 상태를 signaled로 설정하려면 <see langword="true" />이고, nonsignaled로 설정하려면 <see langword="false" />입니다.</param>
      <param name="mode" vsli:raw="One of the &lt;see cref=&quot;T:System.Threading.EventResetMode&quot; /&gt; values that determines whether the event resets automatically or manually.">이벤트가 자동으로 다시 설정되는지 또는 수동으로 다시 설정되는지를 결정하는 <see cref="T:System.Threading.EventResetMode" /> 값 중 하나입니다.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">시스템 차원 동기화 이벤트의 이름입니다.</param>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Win32 오류가 발생한 경우</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named event exists and has access control security, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.EventWaitHandleRights.FullControl&quot; /&gt;.">명명된 이벤트가 존재하고 이 뮤텍스에 액세스 제어 보안이 있지만, 사용자에게 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />이 없는 경우</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 이벤트를 만들 수 없는 경우</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&#xA;          The &lt;paramref name=&quot;mode&quot; /&gt; enum value was out of legal range.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" />이 260자 보다 긴 경우</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.">이 호출의 결과로 대기 핸들이 초기에 신호를 받는지 여부, 자동으로 재설정되는지 또는 수동으로 재설정되는지, 시스템 동기화 이벤트의 이름, 호출 후에 해당 값이 명명된 시스템 이벤트가 생성되었는지 여부를 나타내는 부울 변수를 지정하여 <see cref="T:System.Threading.EventWaitHandle" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state to signaled if the named event is created as a result of this call; &lt;see langword=&quot;false&quot; /&gt; to set it to nonsignaled.">명명된 이벤트가 이 호출의 결과로 만들어지는 경우 초기 상태를 signaled로 설정하려면 <see langword="true" />이고, nonsignaled로 설정하려면 <see langword="false" />입니다.</param>
      <param name="mode" vsli:raw="One of the &lt;see cref=&quot;T:System.Threading.EventResetMode&quot; /&gt; values that determines whether the event resets automatically or manually.">이벤트가 자동으로 다시 설정되는지 또는 수동으로 다시 설정되는지를 결정하는 <see cref="T:System.Threading.EventResetMode" /> 값 중 하나입니다.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">시스템 차원 동기화 이벤트의 이름입니다.</param>
      <param name="createdNew" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if a local event was created (that is, if &lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; or an empty string) or if the specified named system event was created; &lt;see langword=&quot;false&quot; /&gt; if the specified named system event already existed. This parameter is passed uninitialized.">이 메서드가 반환될 때 로컬 이벤트가 만들어지거나(<paramref name="name" />이 <see langword="true" /> 또는 빈 문자열) 명명된 지정 시스템 이벤트가 만들어지면 <see langword="null" />가 포함되고 명명된 지정 시스템 이벤트가 이미 있으면 <see langword="false" />가 포함됩니다. 이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</param>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Win32 오류가 발생한 경우</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named event exists and has access control security, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.EventWaitHandleRights.FullControl&quot; /&gt;.">명명된 이벤트가 존재하고 이 뮤텍스에 액세스 제어 보안이 있지만, 사용자에게 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />이 없는 경우</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 이벤트를 만들 수 없는 경우</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&#xA;          The &lt;paramref name=&quot;mode&quot; /&gt; enum value was out of legal range.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" />이 260자 보다 긴 경우</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
      <summary vsli:raw="Opens the specified named synchronization event, if it already exists.">이미 있는 경우 지정한 명명된 동기화 이벤트를 엽니다.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be opened and shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">열려는 시스템 동기화 이벤트의 이름입니다.</param>
      <returns vsli:raw="An object that represents the named system event.">명명된 시스템 이벤트를 나타내는 개체입니다.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" />이 빈 문자열인 경우
또는
<paramref name="name" />이 260자 보다 긴 경우</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" />가 <see langword="null" />입니다.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be opened. It may not exist, or a synchronization object of a different type might have the same name. In some cases, this exception may be thrown for invalid names.">명명된 시스템 이벤트가 없는 경우</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Win32 오류가 발생한 경우</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named event exists, but the user does not have the security access required to use it.">명명된 이벤트가 있지만 사용자에게 이 이벤트를 사용하는 데 필요한 보안 액세스 권한이 없는 경우</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Reset">
      <summary vsli:raw="Sets the state of the event to nonsignaled, causing threads to block.">스레드가 차단되도록 이벤트 상태를 신호 없음으로 설정합니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation succeeds; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">작업이 성공적으로 수행되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;M:System.Threading.WaitHandle.Close&quot; /&gt; method was previously called on this &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt;.">
        <see cref="M:System.Threading.WaitHandle.Close" /> 메서드가 이 <see cref="T:System.Threading.EventWaitHandle" />에 대해 이전에 호출된 경우</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Set">
      <summary vsli:raw="Sets the state of the event to signaled, allowing one or more waiting threads to proceed.">하나 이상의 대기 중인 스레드가 계속 진행되도록 이벤트 상태를 신호 받음으로 설정합니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation succeeds; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">작업이 성공적으로 수행되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;M:System.Threading.WaitHandle.Close&quot; /&gt; method was previously called on this &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt;.">
        <see cref="M:System.Threading.WaitHandle.Close" /> 메서드가 이 <see cref="T:System.Threading.EventWaitHandle" />에 대해 이전에 호출된 경우</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
      <summary vsli:raw="Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.">지정한 명명된 동기화 이벤트(이미 존재하는 경우)를 열고 작업이 성공했는지를 나타내는 값을 반환합니다.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be opened and shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">열려는 시스템 동기화 이벤트의 이름입니다.</param>
      <param name="result" vsli:raw="When this method returns, contains a &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; object that represents the named synchronization event if the call succeeded, or &lt;see langword=&quot;null&quot; /&gt; if the call failed. This parameter is treated as uninitialized.">이 메서드가 반환될 때 호출에 성공한 경우에는 명명된 동기화 이벤트를 나타내는 <see cref="T:System.Threading.EventWaitHandle" /> 개체를 포함하고 호출에 실패한 경우에는 <see langword="null" />을 포함합니다. 이 매개 변수는 초기화되지 않은 것으로 처리됩니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the named synchronization event was opened successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;. In some cases, &lt;see langword=&quot;false&quot; /&gt; may be returned for invalid names.">명명된 동기화 이벤트를 열었으면 <see langword="true" />이고, 열지 않았으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" />이 빈 문자열인 경우
또는
<paramref name="name" />이 260자 보다 긴 경우</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive. For some invalid names, the method may return &lt;see langword=&quot;false&quot; /&gt; instead.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Win32 오류가 발생한 경우</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named event exists, but the user does not have the desired security access.">명명된 이벤트가 존재하지만 사용자에게 필요한 보안 액세스 권한이 없는 경우</exception>
    </member>
    <member name="T:System.Threading.ExecutionContext">
      <summary vsli:raw="Manages the execution context for the current thread. This class cannot be inherited.">현재 스레드의 실행 컨텍스트를 관리합니다. 이 클래스는 상속될 수 없습니다.</summary>
    </member>
    <member name="M:System.Threading.ExecutionContext.Capture">
      <summary vsli:raw="Captures the execution context from the current thread.">현재 스레드에서 실행 컨텍스트를 캡처합니다.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Threading.ExecutionContext&quot; /&gt; object representing the execution context for the current thread.">현재 스레드의 실행 컨텍스트를 나타내는 <see cref="T:System.Threading.ExecutionContext" /> 개체입니다.</returns>
    </member>
    <member name="M:System.Threading.ExecutionContext.CreateCopy">
      <summary vsli:raw="Creates a copy of the current execution context.">현재 실행 컨텍스트의 복사본을 만듭니다.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Threading.ExecutionContext&quot; /&gt; object representing the current execution context.">현재 실행 컨텍스트를 나타내는 <see cref="T:System.Threading.ExecutionContext" /> 개체입니다.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="This context cannot be copied because it is used. Only newly captured contexts can be copied.">이 컨텍스트가 사용되기 때문에 복사할 수 없는 경우. 새로 캡처한 컨텍스트만 복사할 수 있습니다.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.ExecutionContext&quot; /&gt; class.">
        <see cref="T:System.Threading.ExecutionContext" /> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</summary>
    </member>
    <member name="M:System.Threading.ExecutionContext.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Sets the specified &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object with the logical context information needed to recreate an instance of the current execution context.">현재 실행 컨텍스트의 인스턴스를 다시 만드는 데 필요한 논리 컨텍스트 정보를 사용하여 지정된 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체를 설정합니다.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object to be populated with serialization information.">serialization 정보로 채울 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체입니다.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; structure representing the destination context of the serialization.">serialization의 대상 컨텍스트를 나타내는 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 구조체입니다.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;info&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="info" />가 <see langword="null" />입니다.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.IsFlowSuppressed">
      <summary vsli:raw="Indicates whether the flow of the execution context is currently suppressed.">실행 컨텍스트의 흐름이 현재 억제되는지 여부를 나타냅니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the flow is suppressed; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">해당 흐름이 억제되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Threading.ExecutionContext.RestoreFlow">
      <summary vsli:raw="Restores the flow of the execution context across asynchronous threads.">여러 비동기 스레드 사이의 실행 컨텍스트 흐름을 복원합니다.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The context flow cannot be restored because it is not being suppressed.">현재 억제되어 있지 않아 컨텍스트 흐름을 복원할 수 없는 경우</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)">
      <summary vsli:raw="Runs a method in a specified execution context on the current thread.">현재 스레드의 지정된 실행 컨텍스트에서 메서드를 실행합니다.</summary>
      <param name="executionContext" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ExecutionContext&quot; /&gt; to set.">설정할 <see cref="T:System.Threading.ExecutionContext" />입니다.</param>
      <param name="callback" vsli:raw="A &lt;see cref=&quot;T:System.Threading.ContextCallback&quot; /&gt; delegate that represents the method to be run in the provided execution context.">제공된 실행 컨텍스트에서 실행할 메서드를 나타내는 <see cref="T:System.Threading.ContextCallback" /> 대리자입니다.</param>
      <param name="state" vsli:raw="The object to pass to the callback method.">콜백 메서드로 전달할 개체입니다.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;executionContext&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;executionContext&quot; /&gt; was not acquired through a capture operation.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;executionContext&quot; /&gt; has already been used as the argument to a &lt;see cref=&quot;M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)&quot; /&gt; call.">
        <paramref name="executionContext" />가 <see langword="null" />인 경우
또는
캡처 작업을 통해 <paramref name="executionContext" />를 가져오지 않은 경우
또는
<paramref name="executionContext" />가 이미 <see cref="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)" /> 호출의 인수로 사용된 경우</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.SuppressFlow">
      <summary vsli:raw="Suppresses the flow of the execution context across asynchronous threads.">여러 비동기 스레드 사이의 실행 컨텍스트 흐름을 억제합니다.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure for restoring the flow.">흐름을 복원하기 위한 <see cref="T:System.Threading.AsyncFlowControl" /> 구조체입니다.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The context flow is already suppressed.">컨텍스트 흐름이 이미 억제되어 있는 경우</exception>
    </member>
    <member name="T:System.Threading.HostExecutionContext">
      <summary vsli:raw="Encapsulates and propagates the host execution context across threads.">호스트 실행 컨텍스트를 캡슐화하여 스레드 간에 전파합니다.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; class.">
        <see cref="T:System.Threading.HostExecutionContext" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.#ctor(System.Object)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; class using the specified state.">지정된 상태를 사용하여 <see cref="T:System.Threading.HostExecutionContext" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="state" vsli:raw="An object representing the host execution context state.">호스트 실행 컨텍스트 상태를 나타내는 개체입니다.</param>
    </member>
    <member name="M:System.Threading.HostExecutionContext.CreateCopy">
      <summary vsli:raw="Creates a copy of the current host execution context.">현재 호스트 실행 컨텍스트의 복사본을 만듭니다.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; object representing the host context for the current thread.">현재 스레드의 호스트 컨텍스트를 나타내는 <see cref="T:System.Threading.HostExecutionContext" /> 개체입니다.</returns>
    </member>
    <member name="M:System.Threading.HostExecutionContext.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; class.">
        <see cref="T:System.Threading.HostExecutionContext" /> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.Dispose(System.Boolean)">
      <summary vsli:raw="When overridden in a derived class, releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt;, and optionally releases the managed resources.">파생 클래스에서 재정의된 경우 <see cref="T:System.Threading.WaitHandle" />에서 사용하는 관리되지 않는 리소스를 해제하고 필요에 따라 관리되는 리소스를 해제합니다.</summary>
      <param name="disposing" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to release both managed and unmanaged resources; &lt;see langword=&quot;false&quot; /&gt; to release only unmanaged resources.">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</param>
    </member>
    <member name="P:System.Threading.HostExecutionContext.State">
      <summary vsli:raw="Gets or sets the state of the host execution context.">호스트 실행 컨텍스트의 상태를 가져오거나 설정합니다.</summary>
      <returns vsli:raw="An object representing the host execution context state.">호스트 실행 컨텍스트 상태를 나타내는 개체입니다.</returns>
    </member>
    <member name="T:System.Threading.HostExecutionContextManager">
      <summary vsli:raw="Provides the functionality that allows a common language runtime host to participate in the flow, or migration, of the execution context.">공용 언어 런타임 호스트에서 실행 컨텍스트의 흐름 또는 마이그레이션에 참가할 수 있도록 하는 기능을 제공합니다.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.HostExecutionContextManager&quot; /&gt; class.">
        <see cref="T:System.Threading.HostExecutionContextManager" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.Capture">
      <summary vsli:raw="Captures the host execution context from the current thread.">현재 스레드에서 호스트 실행 컨텍스트를 캡처합니다.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; object representing the host execution context of the current thread.">현재 스레드의 호스트 실행 컨텍스트를 나타내는 <see cref="T:System.Threading.HostExecutionContext" /> 개체입니다.</returns>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.Revert(System.Object)">
      <summary vsli:raw="Restores the host execution context to its prior state.">호스트 실행 컨텍스트를 이전 상태로 복원합니다.</summary>
      <param name="previousState" vsli:raw="The previous context state to revert to.">복원할 이전 컨텍스트 상태입니다.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;previousState&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;previousState&quot; /&gt; was not created on the current thread.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;previousState&quot; /&gt; is not the last state for the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt;.">
        <paramref name="previousState" />가 <see langword="null" />인 경우
또는
현재 스레드에 대해 <paramref name="previousState" />를 만들지 않은 경우
또는
<paramref name="previousState" />가 <see cref="T:System.Threading.HostExecutionContext" />의 마지막 상태가 아닌 경우</exception>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)">
      <summary vsli:raw="Sets the current host execution context to the specified host execution context.">현재 호스트 실행 컨텍스트를 지정한 호스트 실행 컨텍스트로 설정합니다.</summary>
      <param name="hostExecutionContext" vsli:raw="The &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; to be set.">설정할 <see cref="T:System.Threading.HostExecutionContext" />입니다.</param>
      <returns vsli:raw="An object for restoring the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; to its previous state.">
        <see cref="T:System.Threading.HostExecutionContext" />를 이전 상태로 복원하기 위한 개체입니다.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;hostExecutionContext&quot; /&gt; was not acquired through a capture operation.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;hostExecutionContext&quot; /&gt; has been the argument to a previous &lt;see cref=&quot;M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)&quot; /&gt; method call.">캡처 작업을 통해 <paramref name="hostExecutionContext" />를 가져오지 않은 경우
또는
<paramref name="hostExecutionContext" />가 이전 <see cref="M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)" /> 메서드 호출에 대한 인수로 사용되었습니다.</exception>
    </member>
    <member name="T:System.Threading.Interlocked">
      <summary vsli:raw="Provides atomic operations for variables that are shared by multiple threads.">다중 스레드에서 공유하는 변수에 대한 원자 단위 연산을 제공합니다.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
      <summary vsli:raw="Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.">원자 단위 연산으로 두 32비트 정수를 더하고 첫 번째 정수를 합계로 바꿉니다.</summary>
      <param name="location1" vsli:raw="A variable containing the first value to be added. The sum of the two values is stored in &lt;paramref name=&quot;location1&quot; /&gt;.">더할 첫 번째 값이 있는 변수입니다. 두 값의 합계는 <paramref name="location1" />에 저장됩니다.</param>
      <param name="value" vsli:raw="The value to be added to the integer at &lt;paramref name=&quot;location1&quot; /&gt;.">
        <paramref name="location1" />에서 정수에 더할 값입니다.</param>
      <returns vsli:raw="The new value that was stored at &lt;paramref name=&quot;location1&quot; /&gt; by this operation.">
        <paramref name="location1" />에 저장된 새 값입니다.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">
        <paramref name="location1" />의 주소는 null 포인터입니다.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
      <summary vsli:raw="Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.">원자성 연산으로 두 64비트 정수를 더하고 첫 번째 정수를 합계로 바꿉니다.</summary>
      <param name="location1" vsli:raw="A variable containing the first value to be added. The sum of the two values is stored in &lt;paramref name=&quot;location1&quot; /&gt;.">더할 첫 번째 값이 있는 변수입니다. 두 값의 합계는 <paramref name="location1" />에 저장됩니다.</param>
      <param name="value" vsli:raw="The value to be added to the integer at &lt;paramref name=&quot;location1&quot; /&gt;.">
        <paramref name="location1" />에서 정수에 더할 값입니다.</param>
      <returns vsli:raw="The new value that was stored at &lt;paramref name=&quot;location1&quot; /&gt; by this operation.">
        <paramref name="location1" />에 저장된 새 값입니다.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">
        <paramref name="location1" />의 주소는 null 포인터입니다.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
      <summary vsli:raw="Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.">두 배 정밀도 부동 소수점 숫자가 같은지 비교하여 같으면 두 값 중 하나를 바꿉니다.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">
        <paramref name="comparand" />와 비교하여 바뀔 수 있는 값을 가진 대상입니다.</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison results in equality.">비교 결과가 같은 경우 대상 값을 바꿀 값입니다.</param>
      <param name="comparand" vsli:raw="The value that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">
        <paramref name="location1" />의 값과 비교할 값입니다.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">
        <paramref name="location1" />의 원래 값입니다.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">
        <paramref name="location1" />의 주소는 null 포인터입니다.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
      <summary vsli:raw="Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.">두 개의 부호 있는 32비트 정수가 같은지 비교하여 같으면 첫 번째 값을 바꿉니다.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">
        <paramref name="comparand" />와 비교하여 바뀔 수 있는 값을 가진 대상입니다.</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison results in equality.">비교 결과가 같은 경우 대상 값을 바꿀 값입니다.</param>
      <param name="comparand" vsli:raw="The value that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">
        <paramref name="location1" />의 값과 비교할 값입니다.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">
        <paramref name="location1" />의 원래 값입니다.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">
        <paramref name="location1" />의 주소는 null 포인터입니다.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
      <summary vsli:raw="Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.">두 개의 부호 있는 64비트 정수가 같은지 비교하여 같으면 첫 번째 값을 바꿉니다.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">
        <paramref name="comparand" />와 비교하여 바뀔 수 있는 값을 가진 대상입니다.</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison results in equality.">비교 결과가 같은 경우 대상 값을 바꿀 값입니다.</param>
      <param name="comparand" vsli:raw="The value that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">
        <paramref name="location1" />의 값과 비교할 값입니다.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">
        <paramref name="location1" />의 원래 값입니다.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">
        <paramref name="location1" />의 주소는 null 포인터입니다.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
      <summary vsli:raw="Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.">두 플랫폼별 핸들이나 포인터가 같은지 비교하고, 같으면 첫 번째 값을 바꿉니다.</summary>
      <param name="location1" vsli:raw="The destination &lt;see cref=&quot;T:System.IntPtr&quot; /&gt;, whose value is compared with the value of &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced by &lt;paramref name=&quot;value&quot; /&gt;.">
        <paramref name="comparand" /> 값과 비교되어 <paramref name="value" />로 바뀔 수 있는 값을 가진 대상 <see cref="T:System.IntPtr" />입니다.</param>
      <param name="value" vsli:raw="The &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; that replaces the destination value if the comparison results in equality.">비교 결과가 같은 경우 대상 값을 바꿀 <see cref="T:System.IntPtr" />입니다.</param>
      <param name="comparand" vsli:raw="The &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">
        <paramref name="location1" />의 값과 비교할 <see cref="T:System.IntPtr" />입니다.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">
        <paramref name="location1" />의 원래 값입니다.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">
        <paramref name="location1" />의 주소는 null 포인터입니다.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
      <summary vsli:raw="Compares two objects for reference equality and, if they are equal, replaces the first object.">두 개체의 참조가 같은지 비교하고, 같으면 첫 번째 개체를 바꿉니다.</summary>
      <param name="location1" vsli:raw="The destination object that is compared by reference with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">참조에 의해 <paramref name="comparand" />와 비교되어 바뀔 수 있는 대상 개체입니다.</param>
      <param name="value" vsli:raw="The object that replaces the destination object if the reference comparison results in equality.">참조 비교 결과가 같은 경우 대상 개체를 바꾸는 개체입니다.</param>
      <param name="comparand" vsli:raw="The object that is compared by reference to the object at &lt;paramref name=&quot;location1&quot; /&gt;.">참조에 의해 <paramref name="location1" />에서 개체와 비교되는 개체입니다.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">
        <paramref name="location1" />의 원래 값입니다.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="location1" />의 주소는 null 포인터입니다.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
      <summary vsli:raw="Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.">두 단정밀도 부동 소수점 숫자가 같은지 비교하여 같으면 첫 번째 값을 바꿉니다.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">
        <paramref name="comparand" />와 비교하여 바뀔 수 있는 값을 가진 대상입니다.</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison results in equality.">비교 결과가 같은 경우 대상 값을 바꿀 값입니다.</param>
      <param name="comparand" vsli:raw="The value that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">
        <paramref name="location1" />의 값과 비교할 값입니다.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">
        <paramref name="location1" />의 원래 값입니다.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">
        <paramref name="location1" />의 주소는 null 포인터입니다.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
      <summary vsli:raw="Compares two instances of the specified reference type &lt;paramref name=&quot;T&quot; /&gt; for reference equality and, if they are equal, replaces the first one.">지정된 참조 형식 <paramref name="T" />의 두 인스턴스에 대한 참조가 같은지 비교하고, 같으면 첫 번째 값을 바꿉니다.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared by reference with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced. This is a reference parameter (&lt;see langword=&quot;ref&quot; /&gt; in C#, &lt;see langword=&quot;ByRef&quot; /&gt; in Visual Basic).">참조에 의해 <paramref name="comparand" />와 비교되어 바뀔 수 있는 값을 가진 대상입니다. 이것은 참조 매개 변수입니다. C#에서는 <see langword="ref" />이고, Visual Basic에서는 <see langword="ByRef" />입니다.</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison by reference results in equality.">참조에 의한 비교 결과가 같은 경우 대상 값을 바꿀 값입니다.</param>
      <param name="comparand" vsli:raw="The value that is compared by reference to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">참조에 의해 <paramref name="location1" />에서 값과 비교되는 값입니다.</param>
      <typeparam name="T" vsli:raw="The type to be used for &lt;paramref name=&quot;location1&quot; /&gt;, &lt;paramref name=&quot;value&quot; /&gt;, and &lt;paramref name=&quot;comparand&quot; /&gt;. This type must be a reference type.">
        <paramref name="location1" />, <paramref name="value" /> 및 <paramref name="comparand" />에 사용될 형식입니다. 이 형식은 참조 형식이어야 합니다.</typeparam>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">
        <paramref name="location1" />의 원래 값입니다.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">
        <paramref name="location1" />의 주소는 null 포인터입니다.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int32@)">
      <summary vsli:raw="Decrements a specified variable and stores the result, as an atomic operation.">원자 단위 연산으로 지정된 변수를 감소시키고 결과를 저장합니다.</summary>
      <param name="location" vsli:raw="The variable whose value is to be decremented.">값을 감소시킬 변수입니다.</param>
      <returns vsli:raw="The decremented value.">감소한 값입니다.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The address of &lt;paramref name=&quot;location&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">
        <paramref name="location" />의 주소는 null 포인터입니다.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int64@)">
      <summary vsli:raw="Decrements the specified variable and stores the result, as an atomic operation.">원자 단위 연산으로 지정된 변수를 감소시키고 결과를 저장합니다.</summary>
      <param name="location" vsli:raw="The variable whose value is to be decremented.">값을 감소시킬 변수입니다.</param>
      <returns vsli:raw="The decremented value.">감소한 값입니다.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The address of &lt;paramref name=&quot;location&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">
        <paramref name="location" />의 주소는 null 포인터입니다.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
      <summary vsli:raw="Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.">원자 단위 연산으로 배정밀도 부동 소수점 숫자를 지정된 값으로 설정하고 원래 값을 반환합니다.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">지정된 값으로 설정할 변수입니다.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">
        <paramref name="location1" /> 매개 변수의 설정 값입니다.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">
        <paramref name="location1" />의 원래 값입니다.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">
        <paramref name="location1" />의 주소는 null 포인터입니다.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
      <summary vsli:raw="Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.">원자 단위 연산으로 부호 있는 32비트 정수를 지정된 값으로 설정하고 원래 값을 반환합니다.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">지정된 값으로 설정할 변수입니다.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">
        <paramref name="location1" /> 매개 변수의 설정 값입니다.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">
        <paramref name="location1" />의 원래 값입니다.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">
        <paramref name="location1" />의 주소는 null 포인터입니다.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
      <summary vsli:raw="Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.">원자성 연산으로 부호 있는 64비트 정수를 지정된 값으로 설정하고 원래 값을 반환합니다.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">지정된 값으로 설정할 변수입니다.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">
        <paramref name="location1" /> 매개 변수의 설정 값입니다.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">
        <paramref name="location1" />의 원래 값입니다.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">
        <paramref name="location1" />의 주소는 null 포인터입니다.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
      <summary vsli:raw="Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.">원자 단위 연산으로 플랫폼별 핸들 또는 포인터를 지정된 값으로 설정하고 원래 값을 반환합니다.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">지정된 값으로 설정할 변수입니다.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">
        <paramref name="location1" /> 매개 변수의 설정 값입니다.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">
        <paramref name="location1" />의 원래 값입니다.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">
        <paramref name="location1" />의 주소는 null 포인터입니다.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
      <summary vsli:raw="Sets an object to a specified value and returns a reference to the original object, as an atomic operation.">원자 단위 연산으로 개체를 지정된 값으로 설정하고 참조를 원래 개체로 반환합니다.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">지정된 값으로 설정할 변수입니다.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">
        <paramref name="location1" /> 매개 변수의 설정 값입니다.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">
        <paramref name="location1" />의 원래 값입니다.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">
        <paramref name="location1" />의 주소는 null 포인터입니다.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
      <summary vsli:raw="Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.">원자 단위 연산으로 단정밀도 부동 소수점 숫자를 지정된 값으로 설정하고 원래 값을 반환합니다.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">지정된 값으로 설정할 변수입니다.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">
        <paramref name="location1" /> 매개 변수의 설정 값입니다.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">
        <paramref name="location1" />의 원래 값입니다.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">
        <paramref name="location1" />의 주소는 null 포인터입니다.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
      <summary vsli:raw="Sets a variable of the specified type &lt;paramref name=&quot;T&quot; /&gt; to a specified value and returns the original value, as an atomic operation.">원자 단위 연산으로 지정된 형식 <paramref name="T" />의 변수를 지정된 값으로 설정하고 원래 값을 반환합니다.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value. This is a reference parameter (&lt;see langword=&quot;ref&quot; /&gt; in C#, &lt;see langword=&quot;ByRef&quot; /&gt; in Visual Basic).">지정된 값으로 설정할 변수입니다. 이것은 참조 매개 변수입니다. C#에서는 <see langword="ref" />이고, Visual Basic에서는 <see langword="ByRef" />입니다.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">
        <paramref name="location1" /> 매개 변수의 설정 값입니다.</param>
      <typeparam name="T" vsli:raw="The type to be used for &lt;paramref name=&quot;location1&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt;. This type must be a reference type.">
        <paramref name="location1" /> 및 <paramref name="value" />에 사용될 형식입니다. 이 형식은 참조 형식이어야 합니다.</typeparam>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">
        <paramref name="location1" />의 원래 값입니다.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">
        <paramref name="location1" />의 주소는 null 포인터입니다.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.Int32@)">
      <summary vsli:raw="Increments a specified variable and stores the result, as an atomic operation.">원자 단위 연산으로 지정된 변수를 증가시키고 결과를 저장합니다.</summary>
      <param name="location" vsli:raw="The variable whose value is to be incremented.">값을 증가시킬 변수입니다.</param>
      <returns vsli:raw="The incremented value.">증가한 값입니다.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">
        <paramref name="location" />의 주소는 null 포인터입니다.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.Int64@)">
      <summary vsli:raw="Increments a specified variable and stores the result, as an atomic operation.">원자 단위 연산으로 지정된 변수를 증가시키고 결과를 저장합니다.</summary>
      <param name="location" vsli:raw="The variable whose value is to be incremented.">값을 증가시킬 변수입니다.</param>
      <returns vsli:raw="The incremented value.">증가한 값입니다.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">
        <paramref name="location" />의 주소는 null 포인터입니다.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.MemoryBarrier">
      <summary vsli:raw="Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to &lt;see cref=&quot;M:System.Threading.Interlocked.MemoryBarrier&quot; /&gt; execute after memory accesses that follow the call to &lt;see cref=&quot;M:System.Threading.Interlocked.MemoryBarrier&quot; /&gt;.">다음과 같이 메모리 액세스를 동기화합니다. 현재 스레드를 실행하는 프로세서는 <see cref="M:System.Threading.Interlocked.MemoryBarrier" />에 대한 호출 이전의 메모리 액세스가 <see cref="M:System.Threading.Interlocked.MemoryBarrier" />에 대한 호출 이후의 메모리 액세스 뒤에 실행되는 방식으로 명령을 다시 정렬할 수 없습니다.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.MemoryBarrierProcessWide">
      <summary vsli:raw="Provides a process-wide memory barrier that ensures that reads and writes from any CPU cannot move across the barrier.">모든 CPU에서 읽기 및 쓰기가 장벽 간에 이동할 수 없도록 하는 프로세스 전체 메모리 장벽을 제공합니다.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.Read(System.Int64@)">
      <summary vsli:raw="Returns a 64-bit value, loaded as an atomic operation.">원자 단위 연산으로 로드된 64비트 값을 반환합니다.</summary>
      <param name="location" vsli:raw="The 64-bit value to be loaded.">로드될 64비트 값입니다.</param>
      <returns vsli:raw="The loaded value.">로드된 값입니다.</returns>
    </member>
    <member name="T:System.Threading.LazyInitializer">
      <summary vsli:raw="Provides lazy initialization routines.">초기화 지연 루틴을 제공합니다.</summary>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
      <summary vsli:raw="Initializes a target reference type with the type's parameterless constructor if it hasn't already been initialized.">아직 초기화되지 않은 경우 형식의 매개 변수가 없는 생성자를 사용하여 대상 참조 형식을 초기화합니다.</summary>
      <param name="target" vsli:raw="A reference to initialize if it has not already been initialized. If it is &lt;see langword=&quot;null&quot; /&gt;, it is considered not initialized; otherwise, it's considered initialized.">아직 초기화되지 않은 경우 초기화할 참조입니다.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">초기화할 참조의 형식입니다.</typeparam>
      <returns vsli:raw="The initialized object.">초기화된 개체입니다.</returns>
      <exception cref="T:System.MemberAccessException" vsli:raw="Permissions to access the constructor of type &lt;paramref name=&quot;T&quot; /&gt; were missing.">형식의 생성자에 액세스할 수 있는 권한이 <paramref name="T" /> 없습니다.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="Type &lt;paramref name=&quot;T&quot; /&gt; does not have a parameterless constructor.">
        <paramref name="T" /> 형식에는 매개 변수가 없는 생성자가 없습니다.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
      <summary vsli:raw="Initializes a target reference or value type with its parameterless constructor if it hasn't already been initialized.">아직 초기화되지 않은 경우 해당 매개 변수가 없는 생성자를 사용하여 대상 참조 또는 값 형식을 초기화합니다.</summary>
      <param name="target" vsli:raw="A reference or value of type &lt;c&gt;T&lt;/c&gt; to initialize if it hasn't already been initialized.">아직 초기화되지 않은 경우 초기화할 <c>T</c> 형식의 참조 또는 값입니다.</param>
      <param name="initialized" vsli:raw="A reference to a Boolean value that determines whether the target has already been initialized.">대상이 이미 초기화 되었는지 여부를 결정 하는 부울 값에 대 한 참조입니다.</param>
      <param name="syncLock" vsli:raw="A reference to an object used as the mutually exclusive lock for initializing &lt;paramref name=&quot;target&quot; /&gt;. If &lt;paramref name=&quot;syncLock&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, a new object will be instantiated.">초기화에 대 한 배타적인 잠금으로 사용할 개체에 대 한 참조를 <paramref name="target" />입니다. 하는 경우 <paramref name="syncLock" /> 는 <see langword="null" />, 새 개체를 인스턴스화할 수 있습니다.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">초기화할 참조의 형식입니다.</typeparam>
      <returns vsli:raw="The initialized object.">초기화된 개체입니다.</returns>
      <exception cref="T:System.MemberAccessException" vsli:raw="Permissions to access the constructor of type &lt;paramref name=&quot;T&quot; /&gt; were missing.">형식의 생성자에 액세스할 수 있는 권한이 <paramref name="T" /> 없습니다.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="Type &lt;paramref name=&quot;T&quot; /&gt; does not have a parameterless constructor.">
        <paramref name="T" /> 형식에는 매개 변수가 없는 생성자가 없습니다.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
      <summary vsli:raw="Initializes a target reference or value type by using a specified function if it hasn't already been initialized.">아직 초기화 되지 않은 경우에 지정된 된 함수를 사용 하 여 대상 참조 또는 값 형식을 초기화 합니다.</summary>
      <param name="target" vsli:raw="A reference or value of type &lt;c&gt;T&lt;/c&gt; to initialize if it hasn't already been initialized.">아직 초기화되지 않은 경우 초기화할 <c>T</c> 형식의 참조 또는 값입니다.</param>
      <param name="initialized" vsli:raw="A reference to a Boolean value that determines whether the target has already been initialized.">대상이 이미 초기화 되었는지 여부를 결정 하는 부울 값에 대 한 참조입니다.</param>
      <param name="syncLock" vsli:raw="A reference to an object used as the mutually exclusive lock for initializing &lt;paramref name=&quot;target&quot; /&gt;. If &lt;paramref name=&quot;syncLock&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, a new object will be instantiated.">초기화에 대 한 배타적인 잠금으로 사용할 개체에 대 한 참조를 <paramref name="target" />입니다. 하는 경우 <paramref name="syncLock" /> 는 <see langword="null" />, 새 개체를 인스턴스화할 수 있습니다.</param>
      <param name="valueFactory" vsli:raw="The function that is called to initialize the reference or value.">참조 또는 값을 초기화 하기 위해 호출 되는 함수입니다.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">초기화할 참조의 형식입니다.</typeparam>
      <returns vsli:raw="The initialized object.">초기화된 개체입니다.</returns>
      <exception cref="T:System.MemberAccessException" vsli:raw="Permissions to access the constructor of type &lt;paramref name=&quot;T&quot; /&gt; were missing.">형식의 생성자에 액세스할 수 있는 권한이 <paramref name="T" /> 없습니다.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="Type &lt;paramref name=&quot;T&quot; /&gt; does not have a parameterless constructor.">
        <paramref name="T" /> 형식에는 매개 변수가 없는 생성자가 없습니다.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
      <summary vsli:raw="Initializes a target reference type by using a specified function if it hasn't already been initialized.">아직 초기화 되지 않은 경우에 지정된 된 함수를 사용 하 여 대상 참조 형식을 초기화 합니다.</summary>
      <param name="target" vsli:raw="The reference to initialize if it hasn't already been initialized.">아직 초기화되지 않은 경우 초기화할 참조입니다.</param>
      <param name="valueFactory" vsli:raw="The function that is called to initialize the reference.">참조를 초기화 하기 위해 호출 되는 함수입니다.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">초기화할 참조의 형식입니다.</typeparam>
      <returns vsli:raw="The initialized object.">초기화된 개체입니다.</returns>
      <exception cref="T:System.MissingMemberException" vsli:raw="Type &lt;paramref name=&quot;T&quot; /&gt; does not have a parameterless constructor.">
        <paramref name="T" /> 형식에는 매개 변수가 없는 생성자가 없습니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;valueFactory&quot; /&gt; returned null (Nothing in Visual Basic).">
        <paramref name="valueFactory" /> null을 반환 했습니다 (Visual Basic에서는 Nothing)입니다.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Object@,System.Func{``0})">
      <summary vsli:raw="Initializes a target reference type with a specified function if it has not already been initialized.">아직 초기화되지 않은 경우 지정된 함수로 대상 참조 형식을 초기화합니다.</summary>
      <param name="target" vsli:raw="A reference to initialize if it has not already been initialized. If it is &lt;see langword=&quot;null&quot; /&gt;, it is considered not initialized; otherwise, it's considered initialized.">아직 초기화되지 않은 경우 초기화할 참조입니다.</param>
      <param name="syncLock" vsli:raw="A reference to an object used as the mutually exclusive lock for initializing&#xA;            &lt;paramref name=&quot;target&quot; /&gt;. If &lt;paramref name=&quot;syncLock&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, a new object will be instantiated.">초기화에 대 한 배타적인 잠금으로 사용할 개체에 대 한 참조를 <paramref name="target" />입니다. 하는 경우 <paramref name="syncLock" /> 는 <see langword="null" />, 새 개체를 인스턴스화할 수 있습니다.</param>
      <param name="valueFactory" vsli:raw="The method to invoke to initialize &lt;paramref name=&quot;target&quot; /&gt;.">
        <paramref name="target" />을 초기화하기 위해 호출하는 메서드입니다.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">초기화할 참조의 형식입니다.</typeparam>
      <returns vsli:raw="The initialized object.">초기화된 개체입니다.</returns>
    </member>
    <member name="T:System.Threading.LockCookie">
      <summary vsli:raw="Defines the lock that implements single-writer/multiple-reader semantics. This is a value type.">단일 작성기/다중 판독기 기능을 구현하는 잠금을 정의합니다. 이 클래스는 값 형식입니다.</summary>
    </member>
    <member name="M:System.Threading.LockCookie.Equals(System.Object)">
      <summary vsli:raw="Indicates whether a specified object is a &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; and is equal to the current instance.">지정된 개체가 <see cref="T:System.Threading.LockCookie" />이며 현재 인스턴스와 같은지 여부를 나타냅니다.</summary>
      <param name="obj" vsli:raw="The object to compare to the current instance.">현재 인스턴스와 비교할 개체입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the value of &lt;paramref name=&quot;obj&quot; /&gt; is equal to the value of the current instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <paramref name="obj" />의 값이 현재 인스턴스의 값과 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.Equals(System.Threading.LockCookie)">
      <summary vsli:raw="Indicates whether the current instance is equal to the specified &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt;.">현재 인스턴스와 지정된 <see cref="T:System.Threading.LockCookie" />이 같은지 여부를 나타냅니다.</summary>
      <param name="obj" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to the current instance.">현재 인스턴스와 비교할 <see cref="T:System.Threading.LockCookie" />입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is equal to the value of the current instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <paramref name="obj" />가 현재 인스턴스의 값과 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.GetHashCode">
      <summary vsli:raw="Returns the hash code for this instance.">이 인스턴스의 해시 코드를 반환합니다.</summary>
      <returns vsli:raw="A 32-bit signed integer hash code.">부호 있는 32비트 정수 해시 코드입니다.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.op_Equality(System.Threading.LockCookie,System.Threading.LockCookie)">
      <summary vsli:raw="Indicates whether two &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; structures are equal.">두 개의 <see cref="T:System.Threading.LockCookie" /> 구조체가 같은지 여부를 나타냅니다.</summary>
      <param name="a" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to &lt;paramref name=&quot;b&quot; /&gt;.">
        <paramref name="b" />와 비교할 <see cref="T:System.Threading.LockCookie" />입니다.</param>
      <param name="b" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to &lt;paramref name=&quot;a&quot; /&gt;.">
        <paramref name="a" />와 비교할 <see cref="T:System.Threading.LockCookie" />입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;a&quot; /&gt; is equal to &lt;paramref name=&quot;b&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />가 <paramref name="a" />와 같으면 <paramref name="b" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.op_Inequality(System.Threading.LockCookie,System.Threading.LockCookie)">
      <summary vsli:raw="Indicates whether two &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; structures are not equal.">두 개의 <see cref="T:System.Threading.LockCookie" /> 구조체가 같지 않은지 여부를 나타냅니다.</summary>
      <param name="a" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to &lt;paramref name=&quot;b&quot; /&gt;.">
        <paramref name="b" />와 비교할 <see cref="T:System.Threading.LockCookie" />입니다.</param>
      <param name="b" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to &lt;paramref name=&quot;a&quot; /&gt;.">
        <paramref name="a" />와 비교할 <see cref="T:System.Threading.LockCookie" />입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;a&quot; /&gt; is not equal to &lt;paramref name=&quot;b&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />가 <paramref name="a" />와 다르면 <paramref name="b" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="T:System.Threading.LockRecursionException">
      <summary vsli:raw="The exception that is thrown when recursive entry into a lock is not compatible with the recursion policy for the lock.">잠금에 대한 재귀 정책과 맞지 않는 방식으로 잠금을 재귀적으로 시작할 때 throw되는 예외입니다.</summary>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.LockRecursionException&quot; /&gt; class with a system-supplied message that describes the error.">
        <see cref="T:System.Threading.LockRecursionException" /> 클래스의 새 인스턴스를 오류를 설명하는 시스템 제공 메시지로 초기화합니다.</summary>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.LockRecursionException&quot; /&gt; class with serialized data.">serialize된 데이터를 사용하여 <see cref="T:System.Threading.LockRecursionException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="info" vsli:raw="The object that holds the serialized object data.">serialize된 개체 데이터를 보유하는 개체입니다.</param>
      <param name="context" vsli:raw="The contextual information about the source or destination.">원본 또는 대상에 대한 컨텍스트 정보입니다.</param>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.LockRecursionException&quot; /&gt; class with a specified message that describes the error.">
        <see cref="T:System.Threading.LockRecursionException" /> 클래스의 새 인스턴스를 오류를 설명하는 지정된 메시지로 초기화합니다.</summary>
      <param name="message" vsli:raw="The message that describes the exception. The caller of this constructor must make sure that this string has been localized for the current system culture.">예외를 설명하는 메시지입니다. 이 생성자의 호출자는 이 문자열이 현재 시스템 문화권에 따라 지역화되었는지 확인해야 합니다.</param>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.LockRecursionException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">지정된 오류 메시지와 해당 예외의 원인인 내부 예외에 대한 참조를 사용하여 <see cref="T:System.Threading.LockRecursionException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="message" vsli:raw="The message that describes the exception. The caller of this constructor must make sure that this string has been localized for the current system culture.">예외를 설명하는 메시지입니다. 이 생성자의 호출자는 이 문자열이 현재 시스템 문화권에 따라 지역화되었는지 확인해야 합니다.</param>
      <param name="innerException" vsli:raw="The exception that caused the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">현재 예외를 발생시킨 예외입니다. <paramref name="innerException" /> 매개 변수가 <see langword="null" />이 아니면 현재 예외는 내부 예외를 처리하는 <see langword="catch" /> 블록에서 발생합니다.</param>
    </member>
    <member name="T:System.Threading.LockRecursionPolicy">
      <summary vsli:raw="Specifies whether a lock can be entered multiple times by the same thread.">동일한 스레드에서 잠금을 여러 번 시작할 수 있는지 여부를 지정합니다.</summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.NoRecursion">
      <summary vsli:raw="If a thread tries to enter a lock recursively, an exception is thrown. Some classes may allow certain recursions when this setting is in effect.">스레드에서 잠금을 재귀적으로 시작하려고 하면 예외가 throw됩니다. 이 설정을 적용하는 경우 일부 클래스에서 특정 재귀가 허용될 수도 있습니다.</summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.SupportsRecursion">
      <summary vsli:raw="A thread can enter a lock recursively. Some classes may restrict this capability.">스레드에서 잠금을 재귀적으로 시작할 수 있습니다. 일부 클래스에서는 이 기능이 제한될 수 있습니다.</summary>
    </member>
    <member name="T:System.Threading.ManualResetEvent">
      <summary vsli:raw="Represents a thread synchronization event that, when signaled, must be reset manually. This class cannot be inherited.">신호를 받을 때 수동으로 재설정되어야 하는 스레드 동기화 이벤트를 나타냅니다. 이 클래스는 상속될 수 없습니다.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEvent.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEvent&quot; /&gt; class with a Boolean value indicating whether to set the initial state to signaled.">초기 상태를 신호 받음으로 설정할지 여부를 나타내는 부울 값을 사용하여 <see cref="T:System.Threading.ManualResetEvent" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state signaled; &lt;see langword=&quot;false&quot; /&gt; to set the initial state to nonsignaled.">초기 상태를 신호 받음으로 설정하려면 <see langword="true" />를 사용하고 초기 상태를 신호 없음으로 설정하려면 <see langword="false" />를 사용합니다.</param>
    </member>
    <member name="T:System.Threading.ManualResetEventSlim">
      <summary vsli:raw="Represents a thread synchronization event that, when signaled, must be reset manually. This class is a lightweight alternative to &lt;see cref=&quot;T:System.Threading.ManualResetEvent&quot; /&gt;.">신호를 받을 때 수동으로 재설정되어야 하는 스레드 동기화 이벤트를 나타냅니다. 이 클래스는 <see cref="T:System.Threading.ManualResetEvent" />의 간단한 대체 항목입니다.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; class with an initial state of nonsignaled.">새 인스턴스를 초기화 합니다 <see cref="T:System.Threading.ManualResetEventSlim" /> 신호 없음을 초기 상태로 사용 하 여 클래스입니다.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; class with a Boolean value indicating whether to set the initial state to signaled.">새 인스턴스를 초기화 합니다 <see cref="T:System.Threading.ManualResetEventSlim" /> 초기 상태 신호 받음으로 설정할지 여부를 나타내는 부울 값을 사용 하는 클래스입니다.</summary>
      <param name="initialState" vsli:raw="true to set the initial state signaled; false to set the initial state to nonsignaled.">초기 상태를 신호 받음으로 설정하려면 true이고 초기 상태를 신호 없음으로 설정하려면 false입니다.</param>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; class with a Boolean value indicating whether to set the initial state to signaled and a specified spin count.">초기 상태를 신호 받음으로 설정할지 여부를 나타내는 부울 값과 지정된 회전 수를 사용하여 <see cref="T:System.Threading.ManualResetEventSlim" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="initialState" vsli:raw="true to set the initial state to signaled; false to set the initial state to nonsignaled.">초기 상태를 신호 받음으로 설정하려면 true이고 초기 상태를 신호 없음으로 설정하려면 false입니다.</param>
      <param name="spinCount" vsli:raw="The number of spin waits that will occur before falling back to a kernel-based wait operation.">커널 기반의 대기 작업으로 대체하기 전에 수행되는 회전 대기 수입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;spinCount&quot; /&gt; is less than 0 or greater than the maximum allowed value.">
        <paramref name="spinCount" /> 가 0 보다 작거나 최대 허용 값 보다 큽니다.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; class.">
        <see cref="T:System.Threading.ManualResetEventSlim" /> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt;, and optionally releases the managed resources.">
        <see cref="T:System.Threading.ManualResetEventSlim" />에서 사용하는 관리되지 않는 리소스를 해제하고, 관리되는 리소스를 선택적으로 해제할 수 있습니다.</summary>
      <param name="disposing" vsli:raw="true to release both managed and unmanaged resources; false to release only unmanaged resources.">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 true이고, 관리되지 않는 리소스만 해제하려면 false입니다.</param>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.IsSet">
      <summary vsli:raw="Gets whether the event is set.">이벤트가 설정되었는지를 가져옵니다.</summary>
      <returns vsli:raw="true if the event is set; otherwise, false.">이벤트가 설정 되었으면 true이 고, 그렇지 않으면입니다. 그렇지 않으면 false입니다.</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Reset">
      <summary vsli:raw="Sets the state of the event to nonsignaled, which causes threads to block.">스레드가 차단되도록 이벤트 상태를 신호 없음으로 설정합니다.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed.">개체가 이미 삭제되었습니다.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Set">
      <summary vsli:raw="Sets the state of the event to signaled, which allows one or more threads waiting on the event to proceed.">이벤트에서 대기 중인 하나 이상의 스레드가 계속 진행되도록 이벤트 상태를 신호 받음으로 설정합니다.</summary>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.SpinCount">
      <summary vsli:raw="Gets the number of spin waits that will occur before falling back to a kernel-based wait operation.">커널 기반의 대기 작업으로 대체하기 전에 수행되는 회전 대기 수를 가져옵니다.</summary>
      <returns vsli:raw="Returns the number of spin waits that will occur before falling back to a kernel-based wait operation.">커널 기반의 대기 작업으로 대체하기 전에 수행되는 회전 대기 수를 반환합니다.</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set.">현재까지 현재 스레드를 차단 <see cref="T:System.Threading.ManualResetEventSlim" /> 설정 됩니다.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">최대 대기자 수를 초과 합니다.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed.">개체가 이미 삭제되었습니다.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set, using a 32-bit signed integer to measure the time interval.">현재까지 현재 스레드를 차단 <see cref="T:System.Threading.ManualResetEventSlim" /> 시간 간격을 측정 하는 32 비트 부호 있는 정수를 사용 하 여 설정 됩니다.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />가 설정되었으면 <see cref="T:System.Threading.ManualResetEventSlim" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">최대 대기자 수를 초과 합니다.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed.">개체가 이미 삭제되었습니다.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set, using a 32-bit signed integer to measure the time interval, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">현재까지 현재 스레드를 차단 <see cref="T:System.Threading.ManualResetEventSlim" /> 관찰 하는 동안 시간 간격을 측정 하는 32 비트 부호 있는 정수를 사용 하 여 설정 됩니다는 <see cref="T:System.Threading.CancellationToken" />합니다.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">확인할 <see cref="T:System.Threading.CancellationToken" />입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />가 설정되었으면 <see cref="T:System.Threading.ManualResetEventSlim" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> 취소 되었습니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">최대 대기자 수를 초과 합니다.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">이미 삭제 된 개체 또는 <see cref="T:System.Threading.CancellationTokenSource" /> 만든 <paramref name="cancellationToken" /> 삭제 되었습니다.</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 취소 되었습니다.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; receives a signal, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">현재까지 현재 스레드를 차단 <see cref="T:System.Threading.ManualResetEventSlim" /> 관찰 하는 동안 신호를 받을 <see cref="T:System.Threading.CancellationToken" />합니다.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">확인할 <see cref="T:System.Threading.CancellationToken" />입니다.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">최대 대기자 수를 초과 합니다.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> 취소 되었습니다.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">이미 삭제 된 개체 또는 <see cref="T:System.Threading.CancellationTokenSource" /> 만든 <paramref name="cancellationToken" /> 삭제 되었습니다.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was&#xA;            canceled.">
        <paramref name="cancellationToken" /> 취소 되었습니다.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the time interval.">현재까지 현재 스레드를 차단 <see cref="T:System.Threading.ManualResetEventSlim" /> 사용 하 여 설정 됩니다는 <see cref="T:System.TimeSpan" /> 시간 간격을 측정 합니다.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">대기할 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />이거나, 무한 대기하도록 -1밀리초를 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />가 설정되었으면 <see cref="T:System.Threading.ManualResetEventSlim" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out.  &#xA;  &#xA; -or-  &#xA;  &#xA; The number of milliseconds in &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" />은 시간 제한이 없음을 나타내는 -1밀리초 이외의 음수입니다.
-또는-
<paramref name="timeout" />의 밀리초 수가 <see cref="F:System.Int32.MaxValue" />보다 큽니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">최대 대기자 수를 초과 합니다.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed.">개체가 이미 삭제되었습니다.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the time interval, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">현재까지 현재 스레드를 차단 <see cref="T:System.Threading.ManualResetEventSlim" /> 사용 하 여 설정 됩니다는 <see cref="T:System.TimeSpan" /> 관찰 하는 동안 시간 간격을 측정 하는 <see cref="T:System.Threading.CancellationToken" />합니다.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">대기할 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />이거나, 무한 대기하도록 -1밀리초를 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">확인할 <see cref="T:System.Threading.CancellationToken" />입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />가 설정되었으면 <see cref="T:System.Threading.ManualResetEventSlim" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> 취소 되었습니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out.  &#xA;  &#xA; -or-  &#xA;  &#xA; The number of milliseconds in &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" />은 시간 제한이 없음을 나타내는 -1밀리초 이외의 음수입니다.
-또는-
<paramref name="timeout" />의 밀리초 수가 <see cref="F:System.Int32.MaxValue" />보다 큽니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">최대 대기자 수를 초과 합니다.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">이미 삭제 된 개체 또는 <see cref="T:System.Threading.CancellationTokenSource" /> 만든 <paramref name="cancellationToken" /> 삭제 되었습니다.</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 취소 되었습니다.</exception>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.WaitHandle">
      <summary vsli:raw="Gets the underlying &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; object for this &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt;.">기본 가져옵니다 <see cref="T:System.Threading.WaitHandle" /> 이 <see cref="T:System.Threading.ManualResetEventSlim" />합니다.</summary>
      <returns vsli:raw="The underlying &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; event object for this &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt;.">내부 <see cref="T:System.Threading.WaitHandle" /> 이벤트 개체 <see cref="T:System.Threading.ManualResetEventSlim" />합니다.</returns>
    </member>
    <member name="T:System.Threading.Monitor">
      <summary vsli:raw="Provides a mechanism that synchronizes access to objects.">개체에 대한 액세스를 동기화하는 메커니즘을 제공합니다.</summary>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object)">
      <summary vsli:raw="Acquires an exclusive lock on the specified object.">지정된 개체의 단독 잠금을 가져옵니다.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the monitor lock.">모니터 잠금을 가져올 개체입니다.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
      <summary vsli:raw="Acquires an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.">지정된 개체의 단독 잠금을 가져오고 잠금 설정 여부를 나타내는 값을 자동으로 설정합니다.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">대기할 개체입니다.</param>
      <param name="lockTaken" vsli:raw="The result of the attempt to acquire the lock, passed by reference. The input must be &lt;see langword=&quot;false&quot; /&gt;. The output is &lt;see langword=&quot;true&quot; /&gt; if the lock is acquired; otherwise, the output is &lt;see langword=&quot;false&quot; /&gt;. The output is set even if an exception occurs during the attempt to acquire the lock.  &#xA;  &#xA; Note   If no exception occurs, the output of this method is always &lt;see langword=&quot;true&quot; /&gt;.">잠금을 얻기 위한 시도의 결과로서, 참조에 의해 전달됩니다. 입력은 <see langword="false" />여야 합니다. 잠금을 얻으면 출력이 <see langword="true" />이고, 그렇지 않으면 출력이 <see langword="false" />입니다. 잠금을 얻으려는 시도 도중에 예외가 발생해도 출력이 설정됩니다.
예외가 발생하지 않는 경우 이 메서드의 출력은 항상 <see langword="true" />입니다.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The input to &lt;paramref name=&quot;lockTaken&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.">
        <paramref name="lockTaken" />에 대한 입력이 <see langword="true" />인 경우</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Threading.Monitor.Exit(System.Object)">
      <summary vsli:raw="Releases an exclusive lock on the specified object.">지정된 개체의 단독 잠금을 해제합니다.</summary>
      <param name="obj" vsli:raw="The object on which to release the lock.">잠금을 해제할 개체입니다.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The current thread does not own the lock for the specified object.">현재 스레드가 지정된 개체 잠금을 소유하지 않는 경우</exception>
    </member>
    <member name="M:System.Threading.Monitor.IsEntered(System.Object)">
      <summary vsli:raw="Determines whether the current thread holds the lock on the specified object.">현재 스레드가 지정된 개체에 대한 잠금을 보유하는지 여부를 확인합니다.</summary>
      <param name="obj" vsli:raw="The object to test.">테스트할 개체입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread holds the lock on &lt;paramref name=&quot;obj&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">현재 스레드에 <paramref name="obj" /> 잠금이 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;obj&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="obj" />가 <see langword="null" />입니다.</exception>
    </member>
    <member name="P:System.Threading.Monitor.LockContentionCount">
      <summary vsli:raw="Gets the number of times there was contention when trying to take the monitor's lock.">모니터의 잠금을 시도할 때 경합이 발생한 횟수를 가져옵니다.</summary>
      <returns vsli:raw="The number of times there was contention when trying to take the monitor's lock.">모니터의 잠금을 시도 하는 동안 경합이 발생 한 횟수입니다.</returns>
    </member>
    <member name="M:System.Threading.Monitor.Pulse(System.Object)">
      <summary vsli:raw="Notifies a thread in the waiting queue of a change in the locked object's state.">대기 중인 큐에 포함된 스레드에 잠겨 있는 개체의 상태 변경을 알립니다.</summary>
      <param name="obj" vsli:raw="The object a thread is waiting for.">스레드에서 기다리는 개체입니다.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">호출한 스레드가 지정된 개체 잠금을 소유하지 않는 경우</exception>
    </member>
    <member name="M:System.Threading.Monitor.PulseAll(System.Object)">
      <summary vsli:raw="Notifies all waiting threads of a change in the object's state.">대기 중인 모든 스레드에 개체 상태 변경을 알립니다.</summary>
      <param name="obj" vsli:raw="The object that sends the pulse.">펄스를 보내는 개체입니다.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">호출한 스레드가 지정된 개체 잠금을 소유하지 않는 경우</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object)">
      <summary vsli:raw="Attempts to acquire an exclusive lock on the specified object.">지정된 개체의 단독 잠금을 가져오려고 했습니다.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">잠금을 가져올 개체입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread acquires the lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">현재 스레드에서 잠금을 가져오면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
      <summary vsli:raw="Attempts to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.">지정된 개체의 단독 잠금을 가져오고 잠금 설정 여부를 나타내는 값을 자동으로 설정하려고 시도합니다.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">잠금을 가져올 개체입니다.</param>
      <param name="lockTaken" vsli:raw="The result of the attempt to acquire the lock, passed by reference. The input must be &lt;see langword=&quot;false&quot; /&gt;. The output is &lt;see langword=&quot;true&quot; /&gt; if the lock is acquired; otherwise, the output is &lt;see langword=&quot;false&quot; /&gt;. The output is set even if an exception occurs during the attempt to acquire the lock.">잠금을 얻기 위한 시도의 결과로서, 참조에 의해 전달됩니다. 입력은 <see langword="false" />여야 합니다. 잠금을 얻으면 출력이 <see langword="true" />이고, 그렇지 않으면 출력이 <see langword="false" />입니다. 잠금을 얻으려는 시도 도중에 예외가 발생해도 출력이 설정됩니다.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The input to &lt;paramref name=&quot;lockTaken&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.">
        <paramref name="lockTaken" />에 대한 입력이 <see langword="true" />인 경우</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
      <summary vsli:raw="Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.">지정된 시간(밀리초) 동안 지정된 개체의 단독 잠금을 가져오려고 했습니다.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">잠금을 가져올 개체입니다.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait for the lock.">잠금을 기다릴 밀리초 수입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread acquires the lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">현재 스레드에서 잠금을 가져오면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, and not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;.">
        <paramref name="millisecondsTimeout" />가 음수이고 <see cref="F:System.Threading.Timeout.Infinite" />가 아닌 경우</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
      <summary vsli:raw="Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.">지정된 시간(밀리초) 동안 지정된 개체의 단독 잠금을 가져오고 잠금 설정 여부를 나타내는 값을 자동으로 설정하려고 시도합니다.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">잠금을 가져올 개체입니다.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait for the lock.">잠금을 기다릴 밀리초 수입니다.</param>
      <param name="lockTaken" vsli:raw="The result of the attempt to acquire the lock, passed by reference. The input must be &lt;see langword=&quot;false&quot; /&gt;. The output is &lt;see langword=&quot;true&quot; /&gt; if the lock is acquired; otherwise, the output is &lt;see langword=&quot;false&quot; /&gt;. The output is set even if an exception occurs during the attempt to acquire the lock.">잠금을 얻기 위한 시도의 결과로서, 참조에 의해 전달됩니다. 입력은 <see langword="false" />여야 합니다. 잠금을 얻으면 출력이 <see langword="true" />이고, 그렇지 않으면 출력이 <see langword="false" />입니다. 잠금을 얻으려는 시도 도중에 예외가 발생해도 출력이 설정됩니다.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The input to &lt;paramref name=&quot;lockTaken&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.">
        <paramref name="lockTaken" />에 대한 입력이 <see langword="true" />인 경우</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, and not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;.">
        <paramref name="millisecondsTimeout" />가 음수이고 <see cref="F:System.Threading.Timeout.Infinite" />가 아닌 경우</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
      <summary vsli:raw="Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.">지정된 시간 동안 지정된 개체의 단독 잠금을 가져오려고 했습니다.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">잠금을 가져올 개체입니다.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; representing the amount of time to wait for the lock. A value of -1 millisecond specifies an infinite wait.">잠금을 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다. -1밀리초 값은 무한 대기를 지정합니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread acquires the lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">현재 스레드에서 잠금을 가져오면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; in milliseconds is negative and is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1 millisecond), or is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> 값(밀리초)이 음수이고 <see cref="F:System.Threading.Timeout.Infinite" />(-1밀리초)와 같지 않거나 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
      <summary vsli:raw="Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.">지정된 시간 동안 지정된 개체의 단독 잠금을 가져오고 잠금 설정 여부를 나타내는 값을 자동으로 설정하려고 시도합니다.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">잠금을 가져올 개체입니다.</param>
      <param name="timeout" vsli:raw="The amount of time to wait for the lock. A value of -1 millisecond specifies an infinite wait.">잠금을 대기할 시간입니다. -1밀리초 값은 무한 대기를 지정합니다.</param>
      <param name="lockTaken" vsli:raw="The result of the attempt to acquire the lock, passed by reference. The input must be &lt;see langword=&quot;false&quot; /&gt;. The output is &lt;see langword=&quot;true&quot; /&gt; if the lock is acquired; otherwise, the output is &lt;see langword=&quot;false&quot; /&gt;. The output is set even if an exception occurs during the attempt to acquire the lock.">잠금을 얻기 위한 시도의 결과로서, 참조에 의해 전달됩니다. 입력은 <see langword="false" />여야 합니다. 잠금을 얻으면 출력이 <see langword="true" />이고, 그렇지 않으면 출력이 <see langword="false" />입니다. 잠금을 얻으려는 시도 도중에 예외가 발생해도 출력이 설정됩니다.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The input to &lt;paramref name=&quot;lockTaken&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.">
        <paramref name="lockTaken" />에 대한 입력이 <see langword="true" />인 경우</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; in milliseconds is negative and is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1 millisecond), or is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> 값(밀리초)이 음수이고 <see cref="F:System.Threading.Timeout.Infinite" />(-1밀리초)와 같지 않거나 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock.">개체의 잠금을 해제한 다음 잠금을 다시 가져올 때까지 현재 스레드를 차단합니다.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">대기할 개체입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the call returned because the caller reacquired the lock for the specified object. This method does not return if the lock is not reacquired.">지정된 개체 잠금을 호출자가 다시 가져와 호출이 반환되면 <see langword="true" />입니다. 잠금을 다시 가져오지 않으면 이 메서드는 반환하지 않습니다.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">호출한 스레드가 지정된 개체 잠금을 소유하지 않는 경우</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes &lt;see langword=&quot;Wait&quot; /&gt; is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">
        <see langword="Wait" />를 호출하는 스레드가 나중에 대기 상태에서 중단된 경우. 이 예외는 다른 스레드가 이 스레드의 <see cref="M:System.Threading.Thread.Interrupt" /> 메서드를 호출할 때 발생합니다.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.">개체의 잠금을 해제한 다음 잠금을 다시 가져올 때까지 현재 스레드를 차단합니다. 지정된 시간 제한 간격이 지나면 스레드가 준비된 큐에 들어갑니다.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">대기할 개체입니다.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait before the thread enters the ready queue.">스레드가 준비된 큐에 들어가기 전에 대기할 시간(밀리초)입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lock was reacquired before the specified time elapsed; &lt;see langword=&quot;false&quot; /&gt; if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.">지정된 시간이 경과하기 전에 잠금을 다시 가져오면 <see langword="true" />이고, 지정된 시간이 경과한 후에 잠금을 다시 가져오면 <see langword="false" />입니다. 이 메서드는 잠금을 다시 가져올 때까지 반환하지 않습니다.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">호출한 스레드가 지정된 개체 잠금을 소유하지 않는 경우</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes &lt;see langword=&quot;Wait&quot; /&gt; is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">
        <see langword="Wait" />를 호출하는 스레드가 나중에 대기 상태에서 중단된 경우. 이 예외는 다른 스레드가 이 스레드의 <see cref="M:System.Threading.Thread.Interrupt" /> 메서드를 호출할 때 발생합니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of the &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; parameter is negative, and is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;.">
        <paramref name="millisecondsTimeout" /> 매개 변수의 값이 음이고 <see cref="F:System.Threading.Timeout.Infinite" />와 같지 않은 경우</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. This method also specifies whether the synchronization domain for the context (if in a synchronized context) is exited before the wait and reacquired afterward.">개체의 잠금을 해제한 다음 잠금을 다시 가져올 때까지 현재 스레드를 차단합니다. 지정된 시간 제한 간격이 지나면 스레드가 준비된 큐에 들어갑니다. 또한 이 메서드는 컨텍스트의 동기화 도메인(동기화된 컨텍스트에 있는 경우)을 대기 전에 종료하고 나중에 다시 가져오는지 여부도 지정합니다.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">대기할 개체입니다.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait before the thread enters the ready queue.">스레드가 준비된 큐에 들어가기 전에 대기할 시간(밀리초)입니다.</param>
      <param name="exitContext" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">대기 전에 컨텍스트의 동기화 도메인(동기화된 컨텍스트에 있는 경우)을 끝내고 다시 가져오면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lock was reacquired before the specified time elapsed; &lt;see langword=&quot;false&quot; /&gt; if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.">지정된 시간이 경과하기 전에 잠금을 다시 가져오면 <see langword="true" />이고, 지정된 시간이 경과한 후에 잠금을 다시 가져오면 <see langword="false" />입니다. 이 메서드는 잠금을 다시 가져올 때까지 반환하지 않습니다.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="&lt;see langword=&quot;Wait&quot; /&gt; is not invoked from within a synchronized block of code.">
        <see langword="Wait" />가 동기화된 코드 블록 내에서 호출되지 않는 경우</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes &lt;see langword=&quot;Wait&quot; /&gt; is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">
        <see langword="Wait" />를 호출하는 스레드가 나중에 대기 상태에서 중단된 경우. 이 예외는 다른 스레드가 이 스레드의 <see cref="M:System.Threading.Thread.Interrupt" /> 메서드를 호출할 때 발생합니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of the &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; parameter is negative, and is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;.">
        <paramref name="millisecondsTimeout" /> 매개 변수의 값이 음이고 <see cref="F:System.Threading.Timeout.Infinite" />와 같지 않은 경우</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.">개체의 잠금을 해제한 다음 잠금을 다시 가져올 때까지 현재 스레드를 차단합니다. 지정된 시간 제한 간격이 지나면 스레드가 준비된 큐에 들어갑니다.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">대기할 개체입니다.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; representing the amount of time to wait before the thread enters the ready queue.">스레드가 준비된 큐에 들어가기 전에 대기할 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lock was reacquired before the specified time elapsed; &lt;see langword=&quot;false&quot; /&gt; if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.">지정된 시간이 경과하기 전에 잠금을 다시 가져오면 <see langword="true" />이고, 지정된 시간이 경과한 후에 잠금을 다시 가져오면 <see langword="false" />입니다. 이 메서드는 잠금을 다시 가져올 때까지 반환하지 않습니다.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">호출한 스레드가 지정된 개체 잠금을 소유하지 않는 경우</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes &lt;see langword=&quot;Wait&quot; /&gt; is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">
        <see langword="Wait" />를 호출하는 스레드가 나중에 대기 상태에서 중단된 경우. 이 예외는 다른 스레드가 이 스레드의 <see cref="M:System.Threading.Thread.Interrupt" /> 메서드를 호출할 때 발생합니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of the &lt;paramref name=&quot;timeout&quot; /&gt; parameter in milliseconds is negative and does not represent &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1 millisecond), or is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> 매개 변수의 값(밀리초)이 음수이고 <see cref="F:System.Threading.Timeout.Infinite" />(-1밀리초)를 나타내지 않거나 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. Optionally exits the synchronization domain for the synchronized context before the wait and reacquires the domain afterward.">개체의 잠금을 해제한 다음 잠금을 다시 가져올 때까지 현재 스레드를 차단합니다. 지정된 시간 제한 간격이 지나면 스레드가 준비된 큐에 들어갑니다. 필요에 따라 동기화된 컨텍스트의 동기화 도메인을 대기 전에 종료하고 나중에 해당 도메인을 다시 가져옵니다.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">대기할 개체입니다.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; representing the amount of time to wait before the thread enters the ready queue.">스레드가 준비된 큐에 들어가기 전에 대기할 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
      <param name="exitContext" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">대기 전에 컨텍스트의 동기화 도메인(동기화된 컨텍스트에 있는 경우)을 끝내고 다시 가져오면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lock was reacquired before the specified time elapsed; &lt;see langword=&quot;false&quot; /&gt; if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.">지정된 시간이 경과하기 전에 잠금을 다시 가져오면 <see langword="true" />이고, 지정된 시간이 경과한 후에 잠금을 다시 가져오면 <see langword="false" />입니다. 이 메서드는 잠금을 다시 가져올 때까지 반환하지 않습니다.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="&lt;see langword=&quot;Wait&quot; /&gt; is not invoked from within a synchronized block of code.">
        <see langword="Wait" />가 동기화된 코드 블록 내에서 호출되지 않는 경우</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes Wait is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">Wait를 호출하는 스레드가 나중에 대기 상태에서 중단된 경우. 이 예외는 다른 스레드가 이 스레드의 <see cref="M:System.Threading.Thread.Interrupt" /> 메서드를 호출할 때 발생합니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The &lt;paramref name=&quot;timeout&quot; /&gt; parameter is negative and does not represent &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1 millisecond), or is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> 매개 변수가 음수이고 <see cref="F:System.Threading.Timeout.Infinite" />(-1밀리초)를 나타내지 않거나 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
    </member>
    <member name="T:System.Threading.Mutex">
      <summary vsli:raw="A synchronization primitive that can also be used for interprocess synchronization.">프로세스 간 동기화에 사용할 수도 있는 동기화 기본 형식입니다.</summary>
    </member>
    <member name="M:System.Threading.Mutex.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; class with default properties.">기본 속성을 사용하여 <see cref="T:System.Threading.Mutex" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.">호출한 스레드가 뮤텍스의 초기 소유권을 가져야 할지 여부를 나타내는 부울 값을 사용하여 <see cref="T:System.Threading.Mutex" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="initiallyOwned" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to give the calling thread initial ownership of the mutex; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">호출한 스레드에 뮤텍스의 초기 소유권을 부여하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.">호출 스레드가 뮤텍스의 초기 소유권을 가져야 할지 여부를 나타내는 부울 값과 뮤텍스 이름인 문자열을 사용하여 <see cref="T:System.Threading.Mutex" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="initiallyOwned" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">이 호출의 결과로 명명된 시스템 뮤텍스가 만들어지는 경우 호출한 스레드에 명명된 시스템 뮤텍스의 초기 소유권을 부여하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">
        <see cref="T:System.Threading.Mutex" />의 이름입니다. 값이 <see langword="null" />이면 <see cref="T:System.Threading.Mutex" />이(가) 명명되지 않습니다.</param>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named mutex exists and has access control security, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.MutexRights.FullControl&quot; /&gt;.">명명된 뮤텍스가 존재하고 이 뮤텍스에 액세스 제어 보안이 있지만, 사용자에게 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />이 없는 경우</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Win32 오류가 발생한 경우</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 뮤텍스를 만들 수 없는 경우</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&#xA;          .NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" />이 260자 보다 긴 경우</exception>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.">호출한 스레드가 뮤텍스의 초기 소유권을 가져야 할지를 나타내는 부울 값, 뮤텍스의 이름인 문자열 및 메서드에서 반환할 때 호출한 스레드에 뮤텍스의 초기 소유권이 부여되었는지를 나타내는 부울 값을 사용하여 <see cref="T:System.Threading.Mutex" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="initiallyOwned" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">이 호출의 결과로 명명된 시스템 뮤텍스가 만들어지는 경우 호출한 스레드에 명명된 시스템 뮤텍스의 초기 소유권을 부여하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">
        <see cref="T:System.Threading.Mutex" />의 이름입니다. 값이 <see langword="null" />이면 <see cref="T:System.Threading.Mutex" />이(가) 명명되지 않습니다.</param>
      <param name="createdNew" vsli:raw="When this method returns, contains a Boolean that is &lt;see langword=&quot;true&quot; /&gt; if a local mutex was created (that is, if &lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; or an empty string) or if the specified named system mutex was created; &lt;see langword=&quot;false&quot; /&gt; if the specified named system mutex already existed. This parameter is passed uninitialized.">이 메서드가 반환될 때 로컬 뮤텍스가 만들어진 경우(즉, <paramref name="name" />이(가) <see langword="null" />이거나 빈 문자열인 경우)나 지정된 명명된 시스템 뮤텍스가 만들어진 경우에는 <see langword="true" />인 부울이 포함되고, 지정된 명명된 시스템 뮤텍스가 이미 있는 경우에는 <see langword="false" />이(가) 포함됩니다. 이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</param>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named mutex exists and has access control security, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.MutexRights.FullControl&quot; /&gt;.">명명된 뮤텍스가 존재하고 이 뮤텍스에 액세스 제어 보안이 있지만, 사용자에게 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />이 없는 경우</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Win32 오류가 발생한 경우</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 뮤텍스를 만들 수 없는 경우</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&#xA;          .NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" />이 260자 보다 긴 경우</exception>
    </member>
    <member name="M:System.Threading.Mutex.OpenExisting(System.String)">
      <summary vsli:raw="Opens the specified named mutex, if it already exists.">이미 있는 경우 지정한 명명된 뮤텍스를 엽니다.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">열려는 시스템 뮤텍스의 이름입니다.</param>
      <returns vsli:raw="An object that represents the named system mutex.">명명된 시스템 뮤텍스를 나타내는 개체입니다.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" />이 빈 문자열인 경우
또는
<paramref name="name" />이 260자 보다 긴 경우</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name. In some cases, this exception may be thrown for invalid names.">명명된 뮤텍스가 없는 경우</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Win32 오류가 발생한 경우</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named mutex exists, but the user does not have the security access required to use it.">명명된 뮤텍스가 있으나 사용자에게 이를 사용하는 데 필요한 보안 액세스 권한이 없는 경우</exception>
    </member>
    <member name="M:System.Threading.Mutex.ReleaseMutex">
      <summary vsli:raw="Releases the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; once.">
        <see cref="T:System.Threading.Mutex" />을(를) 한 번 해제합니다.</summary>
      <exception cref="T:System.ApplicationException" vsli:raw="The calling thread does not own the mutex.">호출 스레드가 뮤텍스를 소유하지 않습니다.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
    </member>
    <member name="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
      <summary vsli:raw="Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.">지정한 명명된 뮤텍스(이미 존재하는 경우)를 열고 작업이 수행되었는지를 나타내는 값을 반환합니다.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">열려는 시스템 뮤텍스의 이름입니다.</param>
      <param name="result" vsli:raw="When this method returns, contains a &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the named mutex if the call succeeded, or &lt;see langword=&quot;null&quot; /&gt; if the call failed. This parameter is treated as uninitialized.">이 메서드가 반환될 때 호출이 성공적으로 실행된 경우 이름이 지정된 뮤텍스를 나타내는 <see cref="T:System.Threading.Mutex" /> 개체를 포함하고 호출에 실패한 경우는 <see langword="null" />을(를) 포함해야 합니다. 이 매개 변수는 초기화되지 않은 것으로 처리됩니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the named mutex was opened successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;. In some cases, &lt;see langword=&quot;false&quot; /&gt; may be returned for invalid names.">명명된 뮤텍스를 열었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" />이 빈 문자열인 경우
또는
<paramref name="name" />이 260자 보다 긴 경우</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive. For some invalid names, the method may return &lt;see langword=&quot;false&quot; /&gt; instead.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Win32 오류가 발생한 경우</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named mutex exists, but the user does not have the security access required to use it.">명명된 뮤텍스가 있으나 사용자에게 이를 사용하는 데 필요한 보안 액세스 권한이 없는 경우</exception>
    </member>
    <member name="T:System.Threading.ReaderWriterLock">
      <summary vsli:raw="Defines a lock that supports single writers and multiple readers.">단일 작성기 및 다중 판독기를 지원하는 잠금을 정의합니다.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ReaderWriterLock&quot; /&gt; class.">
        <see cref="T:System.Threading.ReaderWriterLock" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
      <summary vsli:raw="Acquires a reader lock, using an &lt;see cref=&quot;T:System.Int32&quot; /&gt; value for the time-out.">제한 시간에 <see cref="T:System.Int32" /> 값을 사용하여 판독기 잠금을 가져옵니다.</summary>
      <param name="millisecondsTimeout" vsli:raw="The time-out in milliseconds.">제한 시간(밀리초)입니다.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; expires before the lock request is granted.">잠금 요청이 부여되기 전에 <paramref name="millisecondsTimeout" />이 만료된 경우</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
      <summary vsli:raw="Acquires a reader lock, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; value for the time-out.">제한 시간에 <see cref="T:System.TimeSpan" /> 값을 사용하여 판독기 잠금을 가져옵니다.</summary>
      <param name="timeout" vsli:raw="A &lt;see langword=&quot;TimeSpan&quot; /&gt; specifying the time-out period.">제한 시간을 지정하는 <see langword="TimeSpan" />입니다.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; expires before the lock request is granted.">잠금 요청이 부여되기 전에 <paramref name="timeout" />이 만료된 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; specifies a negative value other than -1 milliseconds.">
        <paramref name="timeout" />이 -1밀리초 이외의 음수 값을 지정하는 경우</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
      <summary vsli:raw="Acquires the writer lock, using an &lt;see cref=&quot;T:System.Int32&quot; /&gt; value for the time-out.">제한 시간에 <see cref="T:System.Int32" /> 값을 사용하여 작성기 잠금을 가져옵니다.</summary>
      <param name="millisecondsTimeout" vsli:raw="The time-out in milliseconds.">제한 시간(밀리초)입니다.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; expires before the lock request is granted.">잠금 요청이 부여되기 전에 <paramref name="timeout" />이 만료된 경우</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
      <summary vsli:raw="Acquires the writer lock, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; value for the time-out.">제한 시간에 <see cref="T:System.TimeSpan" /> 값을 사용하여 작성기 잠금을 가져옵니다.</summary>
      <param name="timeout" vsli:raw="The &lt;see langword=&quot;TimeSpan&quot; /&gt; specifying the time-out period.">제한 시간을 지정하는 <see langword="TimeSpan" />입니다.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; expires before the lock request is granted.">잠금 요청이 부여되기 전에 <paramref name="timeout" />이 만료된 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; specifies a negative value other than -1 milliseconds.">
        <paramref name="timeout" />이 -1밀리초 이외의 음수 값을 지정하는 경우</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)">
      <summary vsli:raw="Indicates whether the writer lock has been granted to any thread since the sequence number was obtained.">시퀀스 번호를 가져온 다음 임의의 스레드에 작성기 잠금이 부여되었는지 여부를 나타냅니다.</summary>
      <param name="seqNum" vsli:raw="The sequence number.">시퀀스 번호입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the writer lock has been granted to any thread since the sequence number was obtained; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">시퀀스 번호를 가져온 다음 임의의 스레드에 작성기 잠금이 부여된 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)">
      <summary vsli:raw="Restores the lock status of the thread to what it was before &lt;see cref=&quot;M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)&quot; /&gt; was called.">
        <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />을 호출하기 전에 스레드의 잠금 상태를 이전 상태로 복원합니다.</summary>
      <param name="lockCookie" vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; returned by &lt;see cref=&quot;M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)&quot; /&gt;.">
        <see cref="T:System.Threading.LockCookie" />에 의해 반환된 <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />입니다.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="The thread does not have the writer lock.">스레드에 작성기 잠금이 없는 경우</exception>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;lockCookie&quot; /&gt; is a null pointer.">
        <paramref name="lockCookie" />의 주소는 null 포인터입니다.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.IsReaderLockHeld">
      <summary vsli:raw="Gets a value indicating whether the current thread holds a reader lock.">현재 스레드에 판독기 잠금이 있는지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread holds a reader lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">현재 스레드에 판독기 잠금이 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.IsWriterLockHeld">
      <summary vsli:raw="Gets a value indicating whether the current thread holds the writer lock.">현재 스레드에 작성기 잠금이 있는지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread holds the writer lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">현재 스레드에 작성기 잠금이 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseLock">
      <summary vsli:raw="Releases the lock, regardless of the number of times the thread acquired the lock.">스레드에서 잠금을 가져온 횟수에 관계 없이 잠금을 해제합니다.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; value representing the released lock.">해제된 잠금을 나타내는 <see cref="T:System.Threading.LockCookie" /> 값입니다.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseReaderLock">
      <summary vsli:raw="Decrements the lock count.">잠금 횟수를 줄입니다.</summary>
      <exception cref="T:System.ApplicationException" vsli:raw="The thread does not have any reader or writer locks.">스레드에 판독기 또는 작성기 잠금이 없는 경우</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseWriterLock">
      <summary vsli:raw="Decrements the lock count on the writer lock.">작성기 잠금의 잠금 횟수를 줄입니다.</summary>
      <exception cref="T:System.ApplicationException" vsli:raw="The thread does not have the writer lock.">스레드에 작성기 잠금이 없는 경우</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)">
      <summary vsli:raw="Restores the lock status of the thread to what it was before calling &lt;see cref=&quot;M:System.Threading.ReaderWriterLock.ReleaseLock&quot; /&gt;.">
        <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />을 호출하기 전에 스레드의 이전 잠금 상태를 복구합니다.</summary>
      <param name="lockCookie" vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; returned by &lt;see cref=&quot;M:System.Threading.ReaderWriterLock.ReleaseLock&quot; /&gt;.">
        <see cref="T:System.Threading.LockCookie" />에 의해 반환된 <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />입니다.</param>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;lockCookie&quot; /&gt; is a null pointer.">
        <paramref name="lockCookie" />의 주소는 null 포인터입니다.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
      <summary vsli:raw="Upgrades a reader lock to the writer lock, using an &lt;see cref=&quot;T:System.Int32&quot; /&gt; value for the time-out.">제한 시간에 <see langword="Int32" /> 값을 사용하여 판독기 잠금을 작성기 잠금으로 업그레이드합니다.</summary>
      <param name="millisecondsTimeout" vsli:raw="The time-out in milliseconds.">제한 시간(밀리초)입니다.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; value.">
        <see cref="T:System.Threading.LockCookie" /> 값입니다.</returns>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; expires before the lock request is granted.">잠금 요청이 부여되기 전에 <paramref name="millisecondsTimeout" />이 만료된 경우</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
      <summary vsli:raw="Upgrades a reader lock to the writer lock, using a &lt;see langword=&quot;TimeSpan&quot; /&gt; value for the time-out.">제한 시간에 <see langword="TimeSpan" /> 값을 사용하여 판독기 잠금을 작성기 잠금으로 업그레이드합니다.</summary>
      <param name="timeout" vsli:raw="The &lt;see langword=&quot;TimeSpan&quot; /&gt; specifying the time-out period.">제한 시간을 지정하는 <see langword="TimeSpan" />입니다.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; value.">
        <see cref="T:System.Threading.LockCookie" /> 값입니다.</returns>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; expires before the lock request is granted.">잠금 요청이 부여되기 전에 <paramref name="timeout" />이 만료된 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; specifies a negative value other than -1 milliseconds.">
        <paramref name="timeout" />이 -1밀리초 이외의 음수 값을 지정하는 경우</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.WriterSeqNum">
      <summary vsli:raw="Gets the current sequence number.">현재 시퀀스 번호를 가져옵니다.</summary>
      <returns vsli:raw="The current sequence number.">현재 시퀀스 번호입니다.</returns>
    </member>
    <member name="T:System.Threading.ReaderWriterLockSlim">
      <summary vsli:raw="Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.">여러 스레드에서 읽을 수 있도록 허용하거나 쓰기를 위한 단독 액세스를 허용하여 리소스에 대한 액세스를 관리하는 데 사용되는 잠금을 나타냅니다.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; class with default property values.">기본 속성 값으로 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; class, specifying the lock recursion policy.">잠금 재귀 정책을 지정하여 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="recursionPolicy" vsli:raw="One of the enumeration values that specifies the lock recursion policy.">잠금 재귀 정책을 지정하는 열거형 값 중 하나입니다.</param>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
      <summary vsli:raw="Gets the total number of unique threads that have entered the lock in read mode.">읽기 모드로 잠금을 시작한 고유 스레드의 총 개수를 가져옵니다.</summary>
      <returns vsli:raw="The number of unique threads that have entered the lock in read mode.">읽기 모드로 잠금을 시작한 고유 스레드의 총 개수입니다.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; class.">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="&lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.WaitingReadCount&quot; /&gt; is greater than zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount&quot; /&gt; is greater than zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount&quot; /&gt; is greater than zero.">
        <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />가 0보다 큽니다.
또는
<see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />가 0보다 큽니다.
또는
<see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />가 0보다 큽니다.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
      <summary vsli:raw="Tries to enter the lock in read mode.">읽기 모드로 잠금을 시작하려고 합니다.</summary>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt;, and the current thread has attempted to acquire the read lock when it already holds the read lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt;, and the current thread has attempted to acquire the read lock when it already holds the write lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. This limit is so large that applications should never encounter this exception.">
        <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 속성이 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />이고 현재 스레드에서 이미 읽기 잠금을 보유하고 있는 상황에서 읽기 잠금을 가져오려고 시도한 경우
또는
<see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 속성이 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />이고 현재 스레드에서 이미 쓰기 잠금을 보유하고 있는 상황에서 읽기 잠금을 가져오려고 시도한 경우
또는
재귀 횟수가 카운터 용량을 초과하는 경우. 이 제한은 애플리케이션에서 이 예외가 발생하지 않을 정도로 매우 큽니다.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 개체가 삭제되었습니다.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
      <summary vsli:raw="Tries to enter the lock in upgradeable mode.">업그레이드 가능 모드로 잠금을 시작하려고 합니다.</summary>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock in any mode.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">
        <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 속성이 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />이고 현재 스레드에서 이미 모드에 관계없이 잠금을 시작한 경우
또는
현재 스레드에서 읽기 모드를 시작했으므로 업그레이드 가능 모드를 시작하려고 하면 교착 상태가 발생할 수 있는 경우
또는
재귀 횟수가 카운터 용량을 초과하는 경우. 이 제한은 매우 크므로 일반적으로 애플리케이션에서 초과되지 않아야 합니다.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 개체가 삭제되었습니다.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
      <summary vsli:raw="Tries to enter the lock in write mode.">쓰기 모드로 잠금을 시작하려고 합니다.</summary>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock in any mode.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread has entered read mode and doesn't already own a write lock, so trying to enter the lock in write mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">
        <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 속성이 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />이고 현재 스레드에서 이미 모드에 관계없이 잠금을 시작한 경우
또는
현재 스레드에서 읽기 모드를 시작했고 아직 쓰기 잠금을 시작하지 않아 쓰기 모드로 잠금을 시작하려고 하면 교착 상태가 발생할 수 있는 경우
또는
재귀 횟수가 카운터 용량을 초과하는 경우. 이 제한은 매우 크므로 일반적으로 애플리케이션에서 초과되지 않아야 합니다.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 개체가 삭제되었습니다.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
      <summary vsli:raw="Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).">읽기 모드의 재귀 횟수를 줄이고, 결과 횟수가 0이 되면 읽기 모드를 종료합니다.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The current thread has not entered the lock in read mode.">현재 스레드에서 읽기 모드로 잠금을 시작하지 않은 경우</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
      <summary vsli:raw="Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).">업그레이드 가능 모드의 재귀 횟수를 줄이고, 결과 횟수가 0이 되면 업그레이드 가능 모드를 종료합니다.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The current thread has not entered the lock in upgradeable mode.">현재 스레드에서 업그레이드 가능 모드로 잠금을 시작하지 않은 경우</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
      <summary vsli:raw="Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).">쓰기 모드의 재귀 횟수를 줄이고, 결과 횟수가 0이 되면 쓰기 모드를 종료합니다.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The current thread has not entered the lock in write mode.">현재 스레드에서 쓰기 모드로 잠금을 시작하지 않은 경우</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
      <summary vsli:raw="Gets a value that indicates whether the current thread has entered the lock in read mode.">현재 스레드에서 읽기 모드로 잠금을 시작했는지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread has entered read mode; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">현재 스레드에서 읽기 모드가 시작되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
      <summary vsli:raw="Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.">현재 스레드에서 업그레이드 가능 모드로 잠금을 시작했는지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread has entered upgradeable mode; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">현재 스레드에서 업그레이드 가능 모드가 시작되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
      <summary vsli:raw="Gets a value that indicates whether the current thread has entered the lock in write mode.">현재 스레드에서 쓰기 모드로 잠금을 시작했는지 여부를 나타내는 값을 가져옵니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread has entered write mode; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">현재 스레드에서 쓰기 모드가 시작되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
      <summary vsli:raw="Gets a value that indicates the recursion policy for the current &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object.">현재 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 개체에 대한 재귀 정책을 나타내는 값을 가져옵니다.</summary>
      <returns vsli:raw="One of the enumeration values that specifies the lock recursion policy.">잠금 재귀 정책을 지정하는 열거형 값 중 하나입니다.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
      <summary vsli:raw="Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.">재귀를 확인하기 위해 현재 스레드에서 읽기 모드로 잠금을 시작한 횟수를 가져옵니다.</summary>
      <returns vsli:raw="0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or n if the thread has entered the lock recursively n - 1 times.">현재 스레드에서 읽기 모드를 시작하지 않았으면 0이고, 스레드에서 읽기 모드를 시작했지만 재귀적으로 시작하지 않았으면 1이고, 스레드에서 재귀적으로 잠금을 n-1회 시작했으면 n입니다.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
      <summary vsli:raw="Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.">재귀를 확인하기 위해 현재 스레드에서 업그레이드 가능 모드로 잠금을 시작한 횟수를 가져옵니다.</summary>
      <returns vsli:raw="0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or n if the thread has entered upgradeable mode recursively n - 1 times.">현재 스레드에서 업그레이드 가능 모드를 시작하지 않았으면 0이고, 스레드에서 업그레이드 가능 모드를 시작했지만 재귀적으로 시작하지 않았으면 1이고, 스레드에서 재귀적으로 업그레이드 가능 모드를 n-1회 시작했으면 n입니다.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
      <summary vsli:raw="Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.">재귀를 확인하기 위해 현재 스레드에서 쓰기 모드로 잠금을 시작한 횟수를 가져옵니다.</summary>
      <returns vsli:raw="0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or n if the thread has entered write mode recursively n - 1 times.">현재 스레드에서 쓰기 모드를 시작하지 않았으면 0이고, 스레드에서 쓰기 모드를 시작했지만 재귀적으로 시작하지 않았으면 1이고, 스레드에서 재귀적으로 쓰기 모드를 n-1회 시작했으면 n입니다.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
      <summary vsli:raw="Tries to enter the lock in read mode, with an optional integer time-out.">제한 시간(정수)을 선택적으로 적용하여 읽기 모드로 잠금을 시작하려고 합니다.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or -1 (&lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;) to wait indefinitely.">대기할 시간(밀리초)이거나, 무기한 대기하려는 경우 -1(<see cref="F:System.Threading.Timeout.Infinite" />)입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered read mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">호출하는 스레드에서 읽기 모드가 시작되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">
        <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 속성이 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />이고 현재 스레드에서 이미 잠금을 시작한 경우
또는
재귀 횟수가 카운터 용량을 초과하는 경우. 이 제한은 매우 크므로 일반적으로 애플리케이션에서 초과되지 않아야 합니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, but it is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1), which is the only negative value allowed.">
        <paramref name="millisecondsTimeout" />의 값이 음수이지만 유일하게 허용되는 음수 값인 <see cref="F:System.Threading.Timeout.Infinite" />(-1)이 아닌 경우</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 개체가 삭제되었습니다.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
      <summary vsli:raw="Tries to enter the lock in read mode, with an optional time-out.">제한 시간을 선택적으로 적용하여 읽기 모드로 잠금을 시작하려고 합니다.</summary>
      <param name="timeout" vsli:raw="The interval to wait, or -1 milliseconds to wait indefinitely.">대기할 간격이거나, 무기한 대기하려는 경우 -1밀리초입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered read mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">호출하는 스레드에서 읽기 모드가 시작되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">
        <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 속성이 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />이고 현재 스레드에서 이미 잠금을 시작한 경우
또는
재귀 횟수가 카운터 용량을 초과하는 경우. 이 제한은 매우 크므로 일반적으로 애플리케이션에서 초과되지 않아야 합니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.  &#xA;  &#xA; -or-  &#xA;  &#xA; The value of &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; milliseconds.">
        <paramref name="timeout" />의 값이 음수이지만 유일하게 허용되는 음수 값인 -1밀리초가 아닌 경우
또는
<paramref name="timeout" />의 값이 <see cref="F:System.Int32.MaxValue" />밀리초보다 큰 경우</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 개체가 삭제되었습니다.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
      <summary vsli:raw="Tries to enter the lock in upgradeable mode, with an optional time-out.">제한 시간을 선택적으로 적용하여 업그레이드 가능 모드로 잠금을 시작하려고 합니다.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or -1 (&lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;) to wait indefinitely.">대기할 시간(밀리초)이거나, 무기한 대기하려는 경우 -1(<see cref="F:System.Threading.Timeout.Infinite" />)입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered upgradeable mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">호출하는 스레드에서 업그레이드 가능 모드가 시작되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">
        <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 속성이 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />이고 현재 스레드에서 이미 잠금을 시작한 경우
또는
현재 스레드에서 초기에 읽기 모드로 잠금을 시작했으므로 업그레이드 가능 모드를 시작하려고 하면 교착 상태가 발생할 수 있는 경우
또는
재귀 횟수가 카운터 용량을 초과하는 경우. 이 제한은 매우 크므로 일반적으로 애플리케이션에서 초과되지 않아야 합니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, but it is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1), which is the only negative value allowed.">
        <paramref name="millisecondsTimeout" />의 값이 음수이지만 유일하게 허용되는 음수 값인 <see cref="F:System.Threading.Timeout.Infinite" />(-1)이 아닌 경우</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 개체가 삭제되었습니다.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
      <summary vsli:raw="Tries to enter the lock in upgradeable mode, with an optional time-out.">제한 시간을 선택적으로 적용하여 업그레이드 가능 모드로 잠금을 시작하려고 합니다.</summary>
      <param name="timeout" vsli:raw="The interval to wait, or -1 milliseconds to wait indefinitely.">대기할 간격이거나, 무기한 대기하려는 경우 -1밀리초입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered upgradeable mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">호출하는 스레드에서 업그레이드 가능 모드가 시작되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">
        <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 속성이 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />이고 현재 스레드에서 이미 잠금을 시작한 경우
또는
현재 스레드에서 초기에 읽기 모드로 잠금을 시작했으므로 업그레이드 가능 모드를 시작하려고 하면 교착 상태가 발생할 수 있는 경우
또는
재귀 횟수가 카운터 용량을 초과하는 경우. 이 제한은 매우 크므로 일반적으로 애플리케이션에서 초과되지 않아야 합니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.  &#xA;  &#xA; -or-  &#xA;  &#xA; The value of &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; milliseconds.">
        <paramref name="timeout" />의 값이 음수이지만 유일하게 허용되는 음수 값인 -1밀리초가 아닌 경우
또는
<paramref name="timeout" />의 값이 <see cref="F:System.Int32.MaxValue" />밀리초보다 큰 경우</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 개체가 삭제되었습니다.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
      <summary vsli:raw="Tries to enter the lock in write mode, with an optional time-out.">제한 시간을 선택적으로 적용하여 쓰기 모드로 잠금을 시작하려고 합니다.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or -1 (&lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;) to wait indefinitely.">대기할 시간(밀리초)이거나, 무기한 대기하려는 경우 -1(<see cref="F:System.Threading.Timeout.Infinite" />)입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered write mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">호출하는 스레드에서 쓰기 모드가 시작되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">
        <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 속성이 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />이고 현재 스레드에서 이미 잠금을 시작한 경우
또는
현재 스레드에서 초기에 읽기 모드로 잠금을 시작했으므로 쓰기 모드를 시작하려고 하면 교착 상태가 발생할 수 있는 경우
또는
재귀 횟수가 카운터 용량을 초과하는 경우. 이 제한은 매우 크므로 일반적으로 애플리케이션에서 초과되지 않아야 합니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, but it is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1), which is the only negative value allowed.">
        <paramref name="millisecondsTimeout" />의 값이 음수이지만 유일하게 허용되는 음수 값인 <see cref="F:System.Threading.Timeout.Infinite" />(-1)이 아닌 경우</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 개체가 삭제되었습니다.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
      <summary vsli:raw="Tries to enter the lock in write mode, with an optional time-out.">제한 시간을 선택적으로 적용하여 쓰기 모드로 잠금을 시작하려고 합니다.</summary>
      <param name="timeout" vsli:raw="The interval to wait, or -1 milliseconds to wait indefinitely.">대기할 간격이거나, 무기한 대기하려는 경우 -1밀리초입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered write mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">호출하는 스레드에서 쓰기 모드가 시작되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">
        <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 속성이 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />이고 현재 스레드에서 이미 잠금을 시작한 경우
또는
현재 스레드에서 초기에 읽기 모드로 잠금을 시작했으므로 쓰기 모드를 시작하려고 하면 교착 상태가 발생할 수 있는 경우
또는
재귀 횟수가 카운터 용량을 초과하는 경우. 이 제한은 매우 크므로 일반적으로 애플리케이션에서 초과되지 않아야 합니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.  &#xA;  &#xA; -or-  &#xA;  &#xA; The value of &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; milliseconds.">
        <paramref name="timeout" />의 값이 음수이지만 유일하게 허용되는 음수 값인 -1밀리초가 아닌 경우
또는
<paramref name="timeout" />의 값이 <see cref="F:System.Int32.MaxValue" />밀리초보다 큰 경우</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 개체가 삭제되었습니다.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
      <summary vsli:raw="Gets the total number of threads that are waiting to enter the lock in read mode.">읽기 모드로 잠금을 시작하려고 대기 중인 스레드의 총 개수를 가져옵니다.</summary>
      <returns vsli:raw="The total number of threads that are waiting to enter read mode.">읽기 모드를 시작하려고 대기 중인 스레드의 총 개수입니다.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
      <summary vsli:raw="Gets the total number of threads that are waiting to enter the lock in upgradeable mode.">업그레이드 가능 모드로 잠금을 시작하려고 대기 중인 스레드의 총 개수를 가져옵니다.</summary>
      <returns vsli:raw="The total number of threads that are waiting to enter upgradeable mode.">업그레이드 가능 모드를 시작하려고 대기 중인 스레드의 총 개수입니다.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
      <summary vsli:raw="Gets the total number of threads that are waiting to enter the lock in write mode.">쓰기 모드로 잠금을 시작하려고 대기 중인 스레드의 총 개수를 가져옵니다.</summary>
      <returns vsli:raw="The total number of threads that are waiting to enter write mode.">쓰기 모드를 시작하려고 대기 중인 스레드의 총 개수입니다.</returns>
    </member>
    <member name="T:System.Threading.Semaphore">
      <summary vsli:raw="Limits the number of threads that can access a resource or pool of resources concurrently.">리소스 또는 리소스 풀에 동시에 액세스할 수 있는 스레드 수를 제한합니다.</summary>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; class, specifying the initial number of entries and the maximum number of concurrent entries.">초기 항목 수와 최대 동시 항목 수를 지정하여 <see cref="T:System.Threading.Semaphore" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be granted concurrently.">세마포에 동시에 부여할 수 있는 초기 요청 수입니다.</param>
      <param name="maximumCount" vsli:raw="The maximum number of requests for the semaphore that can be granted concurrently.">세마포에 동시에 부여할 수 있는 최대 요청 수입니다.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is greater than &lt;paramref name=&quot;maximumCount&quot; /&gt;.">
        <paramref name="initialCount" />가 <paramref name="maximumCount" />보다 큰 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;maximumCount&quot; /&gt; is less than 1.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="maximumCount" />가 1보다 작습니다.
또는
<paramref name="initialCount" />가 0보다 작은 경우</exception>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.">초기 항목 수와 최대 동시 항목 수를 지정하고, 시스템 세마포 개체 이름을 선택적으로 지정하여 <see cref="T:System.Threading.Semaphore" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be granted concurrently.">세마포에 동시에 부여할 수 있는 초기 요청 수입니다.</param>
      <param name="maximumCount" vsli:raw="The maximum number of requests for the semaphore that can be granted concurrently.">세마포에 동시에 부여할 수 있는 최대 요청 수입니다.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">명명된 시스템 세마포 개체의 이름입니다.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is greater than &lt;paramref name=&quot;maximumCount&quot; /&gt;.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="initialCount" />가 <paramref name="maximumCount" />보다 큰 경우
또는
<paramref name="name" /> 이 260자 보다 긴 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;maximumCount&quot; /&gt; is less than 1.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="maximumCount" />가 1보다 작습니다.
또는
<paramref name="initialCount" />가 0보다 작은 경우</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Win32 오류가 발생한 경우</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named semaphore exists and has access control security, and the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.FullControl&quot; /&gt;.">명명된 세마포가 존재하고 이 세마포에 액세스 제어 보안이 있고 사용자에게 <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />이 없는 경우</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 세마포를 만들 수 없는 경우</exception>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.">초기 항목 수 및 최대 동시 항목 수를 지정하고, 선택적으로 시스템 세마포 개체의 이름을 지정하고, 새 시스템 세마포가 만들어졌는지 여부를 나타내는 값을 받을 변수를 지정하여 <see cref="T:System.Threading.Semaphore" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be satisfied concurrently.">동시에 충족될 수 있는 세마포의 초기 요청 수입니다.</param>
      <param name="maximumCount" vsli:raw="The maximum number of requests for the semaphore that can be satisfied concurrently.">동시에 충족될 수 있는 세마포의 최대 요청 수입니다.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">명명된 시스템 세마포 개체의 이름입니다.</param>
      <param name="createdNew" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if a local semaphore was created (that is, if &lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; or an empty string) or if the specified named system semaphore was created; &lt;see langword=&quot;false&quot; /&gt; if the specified named system semaphore already existed. This parameter is passed uninitialized.">이 메서드가 반환될 때 로컬 세마포가 만들어진 경우(즉, <paramref name="name" />이 <see langword="null" />이거나 빈 문자열인 경우) 또는 지정한 명명된 시스템 세마포가 만들어진 경우에는 <see langword="true" />가 포함되고, 지정한 명명된 시스템 세마포가 이미 있는 경우에는 <see langword="false" />가 포함됩니다. 이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is greater than &lt;paramref name=&quot;maximumCount&quot; /&gt;.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="initialCount" />가 <paramref name="maximumCount" />보다 큰 경우
또는
<paramref name="name" /> 이 260자 보다 긴 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;maximumCount&quot; /&gt; is less than 1.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="maximumCount" />가 1보다 작습니다.
또는
<paramref name="initialCount" />가 0보다 작은 경우</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Win32 오류가 발생한 경우</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named semaphore exists and has access control security, and the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.FullControl&quot; /&gt;.">명명된 세마포가 존재하고 이 세마포에 액세스 제어 보안이 있고 사용자에게 <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />이 없는 경우</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 세마포를 만들 수 없는 경우</exception>
    </member>
    <member name="M:System.Threading.Semaphore.OpenExisting(System.String)">
      <summary vsli:raw="Opens the specified named semaphore, if it already exists.">이미 있는 경우 지정한 명명된 세마포를 엽니다.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">열려는 시스템 세마포의 이름입니다.</param>
      <returns vsli:raw="An object that represents the named system semaphore.">명명된 시스템 세마포를 나타내는 개체입니다.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" />이 빈 문자열인 경우
또는
<paramref name="name" />이 260자 보다 긴 경우</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name. In some cases, this exception may be thrown for invalid names.">명명된 세마포가 없는 경우</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Win32 오류가 발생한 경우</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named semaphore exists, but the user does not have the security access required to use it.">명명된 세마포가 있으나 사용자에게 이를 사용하는 데 필요한 보안 액세스 권한이 없는 경우</exception>
    </member>
    <member name="M:System.Threading.Semaphore.Release">
      <summary vsli:raw="Exits the semaphore and returns the previous count.">세마포를 종료하고 이전 카운트를 반환합니다.</summary>
      <returns vsli:raw="The count on the semaphore before the &lt;see cref=&quot;Overload:System.Threading.Semaphore.Release&quot; /&gt; method was called.">
        <see cref="Overload:System.Threading.Semaphore.Release" /> 메서드가 호출되기 전의 세마포 카운트입니다.</returns>
      <exception cref="T:System.Threading.SemaphoreFullException" vsli:raw="The semaphore count is already at the maximum value.">세마포 카운트가 이미 최대값인 경우</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="A Win32 error occurred with a named semaphore.">명명된 세마포에서 Win32 오류가 발생한 경우</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The current semaphore represents a named system semaphore, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.Modify&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current semaphore represents a named system semaphore, but it was not opened with &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.Modify&quot; /&gt;.">현재 세마포가 명명된 시스템 세마포를 나타내지만 사용자에게 <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />가 없는 경우
또는
현재 세마포가 명명된 시스템 세마포를 나타내지만 세마포가 <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />를 사용하여 열리지 않은 경우</exception>
    </member>
    <member name="M:System.Threading.Semaphore.Release(System.Int32)">
      <summary vsli:raw="Exits the semaphore a specified number of times and returns the previous count.">지정된 횟수만큼 세마포를 종료하고 이전 카운트를 반환합니다.</summary>
      <param name="releaseCount" vsli:raw="The number of times to exit the semaphore.">세마포를 종료할 횟수입니다.</param>
      <returns vsli:raw="The count on the semaphore before the &lt;see cref=&quot;Overload:System.Threading.Semaphore.Release&quot; /&gt; method was called.">
        <see cref="Overload:System.Threading.Semaphore.Release" /> 메서드가 호출되기 전의 세마포 카운트입니다.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;releaseCount&quot; /&gt; is less than 1.">
        <paramref name="releaseCount" />가 1보다 작습니다.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException" vsli:raw="The semaphore count is already at the maximum value.">세마포 카운트가 이미 최대값인 경우</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="A Win32 error occurred with a named semaphore.">명명된 세마포에서 Win32 오류가 발생한 경우</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The current semaphore represents a named system semaphore, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.Modify&quot; /&gt; rights.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current semaphore represents a named system semaphore, but it was not opened with &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.Modify&quot; /&gt; rights.">현재 세마포가 명명된 시스템 세마포를 나타내지만 사용자에게 <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> 권한이 없는 경우
또는
현재 세마포가 명명된 시스템 세마포를 나타내지만 세마포가 <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> 권한을 사용하여 열리지 않은 경우</exception>
    </member>
    <member name="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
      <summary vsli:raw="Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.">지정한 명명된 세마포(이미 존재하는 경우)를 열고 작업이 성공했는지를 나타내는 값을 반환합니다.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">열려는 시스템 세마포의 이름입니다.</param>
      <param name="result" vsli:raw="When this method returns, contains a &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; object that represents the named semaphore if the call succeeded, or &lt;see langword=&quot;null&quot; /&gt; if the call failed. This parameter is treated as uninitialized.">이 메서드가 반환될 때 호출에 성공한 경우에는 명명된 세마포를 나타내는 <see cref="T:System.Threading.Semaphore" /> 개체를 포함하고 호출에 실패한 경우에는 <see langword="null" />을 포함합니다. 이 매개 변수는 초기화되지 않은 것으로 처리됩니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the named semaphore was opened successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;. In some cases, &lt;see langword=&quot;false&quot; /&gt; may be returned for invalid names.">명명된 세마포를 열었으면 <see langword="true" />이고, 그 열지 않았으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" />이 빈 문자열인 경우
또는
<paramref name="name" />이 260자 보다 긴 경우</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" />가 <see langword="null" />인 경우</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive. For some invalid names, the method may return &lt;see langword=&quot;false&quot; /&gt; instead.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Win32 오류가 발생한 경우</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named semaphore exists, but the user does not have the security access required to use it.">명명된 세마포가 있으나 사용자에게 이를 사용하는 데 필요한 보안 액세스 권한이 없는 경우</exception>
    </member>
    <member name="T:System.Threading.SemaphoreFullException">
      <summary vsli:raw="The exception that is thrown when the &lt;see cref=&quot;Overload:System.Threading.Semaphore.Release&quot; /&gt; method is called on a semaphore whose count is already at the maximum.">카운트가 이미 최대값에 도달한 세마포에서 <see cref="Overload:System.Threading.Semaphore.Release" /> 메서드를 호출하면 throw되는 예외입니다.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreFullException&quot; /&gt; class with default values.">기본값을 사용하여 <see cref="T:System.Threading.SemaphoreFullException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreFullException&quot; /&gt; class with serialized data.">serialize된 데이터를 사용하여 <see cref="T:System.Threading.SemaphoreFullException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object that holds the serialized object data about the exception being thrown.">발생되는 예외에 대해 직렬화된 개체 데이터를 보유하는 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체입니다.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; object that contains contextual information about the source or destination.">소스 또는 대상에 대한 컨텍스트 정보를 포함하는 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 개체입니다.</param>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreFullException&quot; /&gt; class with a specified error message.">지정된 오류 메시지를 사용하여 <see cref="T:System.Threading.SemaphoreFullException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">예외에 대한 이유를 설명하는 오류 메시지입니다.</param>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreFullException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">지정된 오류 메시지와 해당 예외의 원인인 내부 예외에 대한 참조를 사용하여 <see cref="T:System.Threading.SemaphoreFullException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">예외에 대한 이유를 설명하는 오류 메시지입니다.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">현재 예외의 원인인 예외입니다. <paramref name="innerException" /> 매개 변수가 <see langword="null" />이 아니면 현재 예외는 내부 예외를 처리하는 <see langword="catch" /> 블록에서 발생합니다.</param>
    </member>
    <member name="T:System.Threading.SemaphoreSlim">
      <summary vsli:raw="Represents a lightweight alternative to &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; that limits the number of threads that can access a resource or pool of resources concurrently.">리소스 또는 리소스 풀에 동시에 액세스할 수 있는 스레드 수를 제한하는 <see cref="T:System.Threading.Semaphore" /> 대신 사용할 수 있는 간단한 클래스를 나타냅니다.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; class, specifying the initial number of requests that can be granted concurrently.">동시에 부여할 수 있는 초기 요청 수를 지정하여 <see cref="T:System.Threading.SemaphoreSlim" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be granted concurrently.">세마포에 동시에 부여할 수 있는 초기 요청 수입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="initialCount" />가 0보다 작은 경우.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; class, specifying the initial and maximum number of requests that can be granted concurrently.">동시에 부여할 수 있는 초기 및 최대 요청 수를 지정하여 <see cref="T:System.Threading.SemaphoreSlim" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be granted concurrently.">세마포에 동시에 부여할 수 있는 초기 요청 수입니다.</param>
      <param name="maxCount" vsli:raw="The maximum number of requests for the semaphore that can be granted concurrently.">세마포에 동시에 부여할 수 있는 최대 요청 수입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0, or &lt;paramref name=&quot;initialCount&quot; /&gt; is greater than &lt;paramref name=&quot;maxCount&quot; /&gt;, or &lt;paramref name=&quot;maxCount&quot; /&gt; is equal to or less than 0.">
        <paramref name="initialCount" />가 0보다 작거나 <paramref name="initialCount" />가 <paramref name="maxCount" />보다 크거나 <paramref name="maxCount" />가 0보다 작거나 같은 경우.</exception>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.AvailableWaitHandle">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; that can be used to wait on the semaphore.">세마포에서 대기하는 데 사용할 수 있는 <see cref="T:System.Threading.WaitHandle" />을(를) 반환합니다.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; that can be used to wait on the semaphore.">세마포에서 대기하는 데 사용할 수 있는 <see cref="T:System.Threading.WaitHandle" />입니다.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has been disposed.">
        <see cref="T:System.Threading.SemaphoreSlim" />가 삭제된 경우</exception>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.CurrentCount">
      <summary vsli:raw="Gets the number of remaining threads that can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; object.">
        <see cref="T:System.Threading.SemaphoreSlim" /> 개체에 들어갈 수 있는 남아 있는 스레드의 수를 가져옵니다.</summary>
      <returns vsli:raw="The number of remaining threads that can enter the semaphore.">세마포에 들어갈 수 있는 남아 있는 스레드의 수입니다.</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; class.">
        <see cref="T:System.Threading.SemaphoreSlim" /> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, and optionally releases the managed resources.">
        <see cref="T:System.Threading.SemaphoreSlim" />에서 사용하는 관리되지 않는 리소스를 해제하고, 관리되는 리소스를 선택적으로 해제할 수 있습니다.</summary>
      <param name="disposing" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to release both managed and unmanaged resources; &lt;see langword=&quot;false&quot; /&gt; to release only unmanaged resources.">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</param>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release">
      <summary vsli:raw="Releases the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; object once.">
        <see cref="T:System.Threading.SemaphoreSlim" /> 개체를 한 번 해제합니다.</summary>
      <returns vsli:raw="The previous count of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;.">
        <see cref="T:System.Threading.SemaphoreSlim" />의 이전 횟수입니다.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
      <exception cref="T:System.Threading.SemaphoreFullException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has already reached its maximum size.">
        <see cref="T:System.Threading.SemaphoreSlim" />이 이미 최대 크기에 도달했습니다.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release(System.Int32)">
      <summary vsli:raw="Releases the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; object a specified number of times.">
        <see cref="T:System.Threading.SemaphoreSlim" /> 개체를 지정된 횟수만큼 해제합니다.</summary>
      <param name="releaseCount" vsli:raw="The number of times to exit the semaphore.">세마포를 종료할 횟수입니다.</param>
      <returns vsli:raw="The previous count of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;.">
        <see cref="T:System.Threading.SemaphoreSlim" />의 이전 횟수입니다.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;releaseCount&quot; /&gt; is less than 1.">
        <paramref name="releaseCount" />가 1보다 작습니다.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has already reached its maximum size.">
        <see cref="T:System.Threading.SemaphoreSlim" />이 이미 최대 크기에 도달했습니다.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;.">현재 스레드가 <see cref="T:System.Threading.SemaphoreSlim" />에 진입할 수 있을 때까지 스레드를 차단합니다.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a 32-bit signed integer that specifies the timeout.">시간 제한을 지정하는 부호 있는 32비트 정수를 사용하여 현재 스레드가 <see cref="T:System.Threading.SemaphoreSlim" />에 진입할 수 있을 때까지 스레드를 차단합니다.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.">대기하는 시간(밀리초), 무기한 대기하는 <see cref="F:System.Threading.Timeout.Infinite" />(-1) 또는 대기 핸들의 상태를 검사하고 즉시 반환하는 0입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">현재 스레드가 <see cref="T:System.Threading.SemaphoreSlim" />에 진입했으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="millisecondsTimeout" />이 무기한 시간 제한을 나타내는 -1 이외의 음수이거나 시간 제한이 <see cref="F:System.Int32.MaxValue" />보다 큽니다.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has been disposed.">
        <see cref="T:System.Threading.SemaphoreSlim" />가 삭제된 경우</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a 32-bit signed integer that specifies the timeout, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">
        <see cref="T:System.Threading.SemaphoreSlim" />을 확인하면서 시간 제한을 지정하는 부호 있는 32비트 정수를 사용하여 현재 스레드가 <see cref="T:System.Threading.CancellationToken" />에 진입할 수 있을 때까지 스레드를 차단합니다.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.">대기하는 시간(밀리초), 무기한 대기하는 <see cref="F:System.Threading.Timeout.Infinite" />(-1) 또는 대기 핸들의 상태를 검사하고 즉시 반환하는 0입니다.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">확인할 <see cref="T:System.Threading.CancellationToken" />입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">현재 스레드가 <see cref="T:System.Threading.SemaphoreSlim" />에 진입했으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" />이 취소되었습니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="millisecondsTimeout" />이 무기한 시간 제한을 나타내는 -1 이외의 음수입니다.
또는
<paramref name="millisecondsTimeout" />가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; instance has been disposed, or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">
        <see cref="T:System.Threading.SemaphoreSlim" /> 인스턴스가 삭제되었거나 <paramref name="cancellationToken" />을 만든 <see cref="T:System.Threading.CancellationTokenSource" />가 삭제되었습니다.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">
        <see cref="T:System.Threading.SemaphoreSlim" />을 확인하면서 현재 스레드가 <see cref="T:System.Threading.CancellationToken" />에 진입할 수 있을 때까지 스레드를 차단합니다.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; token to observe.">확인할 <see cref="T:System.Threading.CancellationToken" /> 토큰입니다.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" />이 취소되었습니다.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.&#xA;&#xA; -or-&#xA;&#xA; The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">현재 인스턴스가 이미 삭제된 경우
또는
<paramref name="cancellationToken" />을 만든 <see cref="T:System.Threading.CancellationTokenSource" />가 이미 삭제되었습니다.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to specify the timeout.">
        <see cref="T:System.Threading.SemaphoreSlim" />으로 시간 제한을 지정하여 현재 스레드가 <see cref="T:System.TimeSpan" />에 진입할 수 있을 때까지 스레드를 차단합니다.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents 0 milliseconds to test the wait handle and return immediately.">대기하는 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />, 무기한 대기하는 -1밀리초를 나타내는 <see cref="T:System.TimeSpan" /> 또는 대기 핸들을 테스트하고 즉시 반환하는 0밀리초를 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">현재 스레드가 <see cref="T:System.Threading.SemaphoreSlim" />에 진입했으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" />이 무기한 시간 제한을 나타내는 -1 이외의 음수입니다.
또는
<paramref name="timeout" />가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The semaphoreSlim instance has been disposed.">semaphoreSlim 인스턴스가 삭제되었습니다.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that specifies the timeout, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">
        <see cref="T:System.Threading.SemaphoreSlim" />을 확인하면서 시간 제한을 지정하는 <see cref="T:System.TimeSpan" />을 사용하여 현재 스레드가 <see cref="T:System.Threading.CancellationToken" />에 진입할 수 있을 때까지 스레드를 차단합니다.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents 0 milliseconds to test the wait handle and return immediately.">대기하는 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />, 무기한 대기하는 -1밀리초를 나타내는 <see cref="T:System.TimeSpan" /> 또는 대기 핸들을 테스트하고 즉시 반환하는 0밀리초를 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">확인할 <see cref="T:System.Threading.CancellationToken" />입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">현재 스레드가 <see cref="T:System.Threading.SemaphoreSlim" />에 진입했으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" />이 취소되었습니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-.&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" />이 무기한 시간 제한을 나타내는 -1 이외의 음수입니다.
또는
<paramref name="timeout" />가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The semaphoreSlim instance has been disposed.&#xA;&#xA;-or-&#xA;&#xA;The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">semaphoreSlim 인스턴스가 삭제되었습니다.
또는
<paramref name="cancellationToken" />을 만든 <see cref="T:System.Threading.CancellationTokenSource" />가 이미 삭제되었습니다.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;.">
        <see cref="T:System.Threading.SemaphoreSlim" />으로 전환될 때까지 비동기적으로 기다립니다.</summary>
      <returns vsli:raw="A task that will complete when the semaphore has been entered.">세마포가 입력되었을 때 완료될 작업입니다.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has been disposed.">
        <see cref="T:System.Threading.SemaphoreSlim" />가 삭제된 경우</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a 32-bit signed integer to measure the time interval.">32비트 부호 있는 정수를 사용하여 시간 간격을 측정하여 <see cref="T:System.Threading.SemaphoreSlim" />으로 전환될 때까지 비동기적으로 기다립니다.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.">대기하는 시간(밀리초), 무기한 대기하는 <see cref="F:System.Threading.Timeout.Infinite" />(-1) 또는 대기 핸들의 상태를 검사하고 즉시 반환하는 0입니다.</param>
      <returns vsli:raw="A task that will complete with a result of &lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, otherwise with a result of &lt;see langword=&quot;false&quot; /&gt;.">현재 스레드가 성공적으로 <see cref="T:System.Threading.SemaphoreSlim" />에 들어온 경우 <see langword="true" />의 결과로 완료되는 작업이고, 그렇지 않으면 <see langword="false" />의 결과로 완료되는 작업입니다.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="millisecondsTimeout" />이 무기한 시간 제한을 나타내는 -1 이외의 음수입니다.
또는
<paramref name="millisecondsTimeout" />가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a 32-bit signed integer to measure the time interval, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">
        <see cref="T:System.Threading.SemaphoreSlim" />을 관찰하는 동안 32비트 부호 있는 정수를 사용하여 시간 간격을 측정하여 <see cref="T:System.Threading.CancellationToken" />으로 전환될 때까지 비동기적으로 기다립니다.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.">대기하는 시간(밀리초), 무기한 대기하는 <see cref="F:System.Threading.Timeout.Infinite" />(-1) 또는 대기 핸들의 상태를 검사하고 즉시 반환하는 0입니다.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">확인할 <see cref="T:System.Threading.CancellationToken" />입니다.</param>
      <returns vsli:raw="A task that will complete with a result of &lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, otherwise with a result of &lt;see langword=&quot;false&quot; /&gt;.">현재 스레드가 성공적으로 <see cref="T:System.Threading.SemaphoreSlim" />에 들어온 경우 <see langword="true" />의 결과로 완료되는 작업이고, 그렇지 않으면 <see langword="false" />의 결과로 완료되는 작업입니다.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="millisecondsTimeout" />이 무기한 시간 제한을 나타내는 -1 이외의 수입니다.
또는
<paramref name="millisecondsTimeout" />가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" />이 취소되었습니다.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">
        <see cref="T:System.Threading.SemaphoreSlim" />을 관찰하는 동안 <see cref="T:System.Threading.CancellationToken" />으로 전환될 때까지 비동기적으로 기다립니다.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; token to observe.">확인할 <see cref="T:System.Threading.CancellationToken" /> 토큰입니다.</param>
      <returns vsli:raw="A task that will complete when the semaphore has been entered.">세마포가 입력되었을 때 완료될 작업입니다.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" />이 취소되었습니다.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the time interval.">
        <see cref="T:System.Threading.SemaphoreSlim" />을 사용하여 시간 간격을 측정하여 <see cref="T:System.TimeSpan" />으로 전환될 때까지 비동기적으로 기다립니다.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents 0 milliseconds to test the wait handle and return immediately.">대기하는 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />, 무기한 대기하는 -1밀리초를 나타내는 <see cref="T:System.TimeSpan" /> 또는 대기 핸들을 테스트하고 즉시 반환하는 0밀리초를 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
      <returns vsli:raw="A task that will complete with a result of &lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, otherwise with a result of &lt;see langword=&quot;false&quot; /&gt;.">현재 스레드가 성공적으로 <see cref="T:System.Threading.SemaphoreSlim" />에 들어온 경우 <see langword="true" />의 결과로 완료되는 작업이고, 그렇지 않으면 <see langword="false" />의 결과로 완료되는 작업입니다.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">현재 인스턴스가 이미 삭제된 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" />이 무기한 시간 제한을 나타내는 -1 이외의 음수입니다.
또는
<paramref name="timeout" />가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the time interval, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">
        <see cref="T:System.Threading.SemaphoreSlim" />을 관찰하는 동안 <see cref="T:System.TimeSpan" />을 사용하여 시간 간격을 측정하여 <see cref="T:System.Threading.CancellationToken" />으로 전환될 때까지 비동기적으로 기다립니다.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents 0 milliseconds to test the wait handle and return immediately.">대기하는 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />, 무기한 대기하는 -1밀리초를 나타내는 <see cref="T:System.TimeSpan" /> 또는 대기 핸들을 테스트하고 즉시 반환하는 0밀리초를 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; token to observe.">확인할 <see cref="T:System.Threading.CancellationToken" /> 토큰입니다.</param>
      <returns vsli:raw="A task that will complete with a result of &lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, otherwise with a result of &lt;see langword=&quot;false&quot; /&gt;.">현재 스레드가 성공적으로 <see cref="T:System.Threading.SemaphoreSlim" />에 들어온 경우 <see langword="true" />의 결과로 완료되는 작업이고, 그렇지 않으면 <see langword="false" />의 결과로 완료되는 작업입니다.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" />이 무기한 시간 제한을 나타내는 -1 이외의 음수입니다.
또는
<paramref name="timeout" />가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" />이 취소되었습니다.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has been disposed.">
        <see cref="T:System.Threading.SemaphoreSlim" />가 삭제된 경우</exception>
    </member>
    <member name="T:System.Threading.SendOrPostCallback">
      <summary vsli:raw="Represents a method to be called when a message is to be dispatched to a synchronization context.">메시지가 동기화 컨텍스트로 디스패치될 때 호출할 메서드를 나타냅니다.</summary>
      <param name="state" vsli:raw="The object passed to the delegate.">대리자에 전달된 개체입니다.</param>
    </member>
    <member name="T:System.Threading.SpinLock">
      <summary vsli:raw="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop repeatedly checking until the lock becomes available.">잠금을 얻으려는 스레드가 잠금을 사용할 수 있을 때까지 루프에서 반복적으로 확인하면서 대기하는 기본적인 상호 배타 잠금을 제공합니다.</summary>
    </member>
    <member name="M:System.Threading.SpinLock.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SpinLock&quot; /&gt; structure with the option to track thread IDs to improve debugging.">디버깅을 향상시키기 위해 스레드 ID를 추적하는 옵션을 사용하여 <see cref="T:System.Threading.SpinLock" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
      <param name="enableThreadOwnerTracking" vsli:raw="Whether to capture and use thread IDs for debugging purposes.">디버깅 용도로 스레드 ID를 캡처하고 사용할지 여부입니다.</param>
    </member>
    <member name="M:System.Threading.SpinLock.Enter(System.Boolean@)">
      <summary vsli:raw="Acquires the lock in a reliable manner, such that even if an exception occurs within the method call, &lt;paramref name=&quot;lockTaken&quot; /&gt; can be examined reliably to determine whether the lock was acquired.">메서드 호출에서 예외가 발생하는 경우에도 안정적인 방식으로 잠금을 얻으며 잠금을 얻었는지 확인하기 위해 <paramref name="lockTaken" />을 안정적으로 검사할 수 있습니다.</summary>
      <param name="lockTaken" vsli:raw="True if the lock is acquired; otherwise, false. &lt;paramref name=&quot;lockTaken&quot; /&gt; must be initialized to false prior to calling this method.">잠금을 얻었으면 true이고, 그렇지 않으면 false입니다. 이 메서드를 호출하기 전에 <paramref name="lockTaken" />을 false로 초기화해야 합니다.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;lockTaken&quot; /&gt; argument must be initialized to false prior to calling Enter.">
        <paramref name="lockTaken" /> 인수는 Enter를 호출하기 전에 false로 초기화해야 합니다.</exception>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="Thread ownership tracking is enabled, and the current thread has already acquired this lock.">스레드 소유권 추적 기능을 사용할 수 있으며 현재 스레드가 이미 이 잠금을 획득했습니다.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit">
      <summary vsli:raw="Releases the lock.">잠금을 해제합니다.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="Thread ownership tracking is enabled, and the current thread is not the owner of this lock.">스레드 소유권 추적 기능을 사용할 수 있으며 현재 스레드가 이 잠금의 소유자가 아닙니다.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit(System.Boolean)">
      <summary vsli:raw="Releases the lock.">잠금을 해제합니다.</summary>
      <param name="useMemoryBarrier" vsli:raw="A Boolean value that indicates whether a memory fence should be issued in order to immediately publish the exit operation to other threads.">종료 작업을 다른 스레드에 즉시 게시하기 위해 메모리 펜스를 실행할지 여부를 나타내는 부울 값입니다.</param>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="Thread ownership tracking is enabled, and the current thread is not the owner of this lock.">스레드 소유권 추적 기능을 사용할 수 있으며 현재 스레드가 이 잠금의 소유자가 아닙니다.</exception>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeld">
      <summary vsli:raw="Gets whether the lock is currently held by any thread.">스레드에서 현재 잠금을 보유하고 있는지 여부를 가져옵니다.</summary>
      <returns vsli:raw="true if the lock is currently held by any thread; otherwise false.">스레드에서 현재 잠금을 보유하고 있으면 true이고, 그렇지 않으면 false입니다.</returns>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeldByCurrentThread">
      <summary vsli:raw="Gets whether the lock is held by the current thread.">현재 스레드에서 잠금을 보유하고 있는지 여부를 가져옵니다.</summary>
      <returns vsli:raw="true if the lock is held by the current thread; otherwise false.">현재 스레드에서 잠금을 보유하고 있으면 true이고, 그렇지 않으면 false입니다.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Thread ownership tracking is disabled.">스레드 소유권 추적을 사용할 수 없습니다.</exception>
    </member>
    <member name="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled">
      <summary vsli:raw="Gets whether thread ownership tracking is enabled for this instance.">이 인스턴스에 대해 스레드 소유권 추적이 사용되는지 여부를 가져옵니다.</summary>
      <returns vsli:raw="true if thread ownership tracking is enabled for this instance; otherwise false.">이 인스턴스에 대해 스레드 소유권 추적이 사용되면 true이고, 그렇지 않으면 false입니다.</returns>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
      <summary vsli:raw="Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, &lt;paramref name=&quot;lockTaken&quot; /&gt; can be examined reliably to determine whether the lock was acquired.">메서드 호출에서 예외가 발생하는 경우에도 안정적인 방식으로 잠금을 얻으려고 시도합니다. 잠금을 얻었는지 확인하기 위해 <paramref name="lockTaken" />을 안정적으로 검사할 수 있습니다.</summary>
      <param name="lockTaken" vsli:raw="True if the lock is acquired; otherwise, false. &lt;paramref name=&quot;lockTaken&quot; /&gt; must be initialized to false prior to calling this method.">잠금을 얻었으면 true이고, 그렇지 않으면 false입니다. 이 메서드를 호출하기 전에 <paramref name="lockTaken" />을 false로 초기화해야 합니다.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;lockTaken&quot; /&gt; argument must be initialized to false prior to calling TryEnter.">
        <paramref name="lockTaken" /> 인수는 TryEnter를 호출하기 전에 false로 초기화해야 합니다.</exception>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="Thread ownership tracking is enabled, and the current thread has already acquired this lock.">스레드 소유권 추적 기능을 사용할 수 있으며 현재 스레드가 이미 이 잠금을 획득했습니다.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
      <summary vsli:raw="Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, &lt;paramref name=&quot;lockTaken&quot; /&gt; can be examined reliably to determine whether the lock was acquired.">메서드 호출에서 예외가 발생하는 경우에도 안정적인 방식으로 잠금을 얻으려고 시도합니다. 잠금을 얻었는지 확인하기 위해 <paramref name="lockTaken" />을 안정적으로 검사할 수 있습니다.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</param>
      <param name="lockTaken" vsli:raw="True if the lock is acquired; otherwise, false. &lt;paramref name=&quot;lockTaken&quot; /&gt; must be initialized to false prior to calling this method.">잠금을 얻었으면 true이고, 그렇지 않으면 false입니다. 이 메서드를 호출하기 전에 <paramref name="lockTaken" />을 false로 초기화해야 합니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;lockTaken&quot; /&gt; argument must be initialized to false prior to calling TryEnter.">
        <paramref name="lockTaken" /> 인수는 TryEnter를 호출하기 전에 false로 초기화해야 합니다.</exception>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="Thread ownership tracking is enabled, and the current thread has already acquired this lock.">스레드 소유권 추적 기능을 사용할 수 있으며 현재 스레드가 이미 이 잠금을 획득했습니다.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
      <summary vsli:raw="Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, &lt;paramref name=&quot;lockTaken&quot; /&gt; can be examined reliably to determine whether the lock was acquired.">메서드 호출에서 예외가 발생하는 경우에도 안정적인 방식으로 잠금을 얻으려고 시도합니다. 잠금을 얻었는지 확인하기 위해 <paramref name="lockTaken" />을 안정적으로 검사할 수 있습니다.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">대기할 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />이거나, 무한 대기하도록 -1밀리초를 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
      <param name="lockTaken" vsli:raw="True if the lock is acquired; otherwise, false. &lt;paramref name=&quot;lockTaken&quot; /&gt; must be initialized to false prior to calling this method.">잠금을 얻었으면 true이고, 그렇지 않으면 false입니다. 이 메서드를 호출하기 전에 <paramref name="lockTaken" />을 false로 초기화해야 합니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; milliseconds.">
        <paramref name="timeout" />이 무기한 시간 제한을 나타내는 -1밀리초 이외의 음수이거나 시간 제한이 <see cref="F:System.Int32.MaxValue" />밀리초보다 큰 경우.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;lockTaken&quot; /&gt; argument must be initialized to false prior to calling TryEnter.">
        <paramref name="lockTaken" /> 인수는 TryEnter를 호출하기 전에 false로 초기화해야 합니다.</exception>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="Thread ownership tracking is enabled, and the current thread has already acquired this lock.">스레드 소유권 추적 기능을 사용할 수 있으며 현재 스레드가 이미 이 잠금을 획득했습니다.</exception>
    </member>
    <member name="T:System.Threading.SpinWait">
      <summary vsli:raw="Provides support for spin-based waiting.">회전 기반 대기를 지원합니다.</summary>
    </member>
    <member name="P:System.Threading.SpinWait.Count">
      <summary vsli:raw="Gets the number of times &lt;see cref=&quot;M:System.Threading.SpinWait.SpinOnce&quot; /&gt; has been called on this instance.">이 인스턴스에서 <see cref="M:System.Threading.SpinWait.SpinOnce" />가 호출된 횟수를 가져옵니다.</summary>
      <returns vsli:raw="Returns an integer that represents the number of times &lt;see cref=&quot;M:System.Threading.SpinWait.SpinOnce&quot; /&gt; has been called on this instance.">이 인스턴스에서 <see cref="M:System.Threading.SpinWait.SpinOnce" />가 호출된 횟수를 나타내는 정수를 반환합니다.</returns>
    </member>
    <member name="P:System.Threading.SpinWait.NextSpinWillYield">
      <summary vsli:raw="Gets whether the next call to &lt;see cref=&quot;M:System.Threading.SpinWait.SpinOnce&quot; /&gt; will yield the processor, triggering a forced context switch.">다음 <see cref="M:System.Threading.SpinWait.SpinOnce" /> 호출이 프로세서를 생성하여 강제 컨텍스트 전환을 트리거할지 여부를 가져옵니다.</summary>
      <returns vsli:raw="Whether the next call to &lt;see cref=&quot;M:System.Threading.SpinWait.SpinOnce&quot; /&gt; will yield the processor, triggering a forced context switch.">다음 <see cref="M:System.Threading.SpinWait.SpinOnce" /> 호출이 프로세서를 생성하여 강제 컨텍스트 전환을 트리거할지 여부입니다.</returns>
    </member>
    <member name="M:System.Threading.SpinWait.Reset">
      <summary vsli:raw="Resets the spin counter.">회전 수를 다시 설정합니다.</summary>
    </member>
    <member name="M:System.Threading.SpinWait.SpinOnce">
      <summary vsli:raw="Performs a single spin.">단일 회전을 수행합니다.</summary>
    </member>
    <member name="M:System.Threading.SpinWait.SpinOnce(System.Int32)">
      <summary vsli:raw="Performs a single spin and calls &lt;see cref=&quot;M:System.Threading.Thread.Sleep(System.Int32)&quot; /&gt; after a minimum spin count.">단일 스핀을 수행하고 최소 스핀 수 이후에 <see cref="M:System.Threading.Thread.Sleep(System.Int32)" />를 호출합니다.</summary>
      <param name="sleep1Threshold" vsli:raw="A minimum spin count after which &lt;see langword=&quot;Thread.Sleep(1)&quot; /&gt; may be used. A value of -1 disables the use of &lt;see langword=&quot;Thread.Sleep(1)&quot; /&gt;.">
        <see langword="Thread.Sleep(1)" />을 사용할 수 있는 최소 스핀 수입니다. -1 값은 <see langword="Thread.Sleep(1)" />의 사용을 비활성화합니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;sleep1Threshold&quot; /&gt; is less than -1.">
        <paramref name="sleep1Threshold" />이 -1보다 작습니다.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean})">
      <summary vsli:raw="Spins until the specified condition is satisfied.">지정된 조건이 충족될 때까지 회전합니다.</summary>
      <param name="condition" vsli:raw="A delegate to be executed over and over until it returns true.">true를 반환할 때까지 계속 실행되는 대리자입니다.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;condition&quot; /&gt; argument is null.">
        <paramref name="condition" /> 인수가 null입니다.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.Int32)">
      <summary vsli:raw="Spins until the specified condition is satisfied or until the specified timeout is expired.">지정된 조건이 충족되거나 지정된 제한 시간이 만료될 때까지 회전합니다.</summary>
      <param name="condition" vsli:raw="A delegate to be executed over and over until it returns true.">true를 반환할 때까지 계속 실행되는 대리자입니다.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the condition is satisfied within the timeout; otherwise, false.">제한 시간 내에 지정된 조건이 충족되면 <see langword="true" />이고, 그렇지 않으면 false입니다.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;condition&quot; /&gt; argument is null.">
        <paramref name="condition" /> 인수가 null입니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.TimeSpan)">
      <summary vsli:raw="Spins until the specified condition is satisfied or until the specified timeout is expired.">지정된 조건이 충족되거나 지정된 제한 시간이 만료될 때까지 회전합니다.</summary>
      <param name="condition" vsli:raw="A delegate to be executed over and over until it returns true.">true를 반환할 때까지 계속 실행되는 대리자입니다.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.">대기할 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />이거나, 무한 대기하도록 -1밀리초를 나타내는 TimeSpan입니다.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the condition is satisfied within the timeout; otherwise, false.">제한 시간 내에 지정된 조건이 충족되면 <see langword="true" />이고, 그렇지 않으면 false입니다.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;condition&quot; /&gt; argument is null.">
        <paramref name="condition" /> 인수가 null입니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" />이 무기한 시간 제한을 나타내는 -1밀리초 이외의 음수이거나 시간 제한이 <see cref="F:System.Int32.MaxValue" />보다 큰 경우.</exception>
    </member>
    <member name="T:System.Threading.SynchronizationContext">
      <summary vsli:raw="Provides the basic functionality for propagating a synchronization context in various synchronization models.">다양한 동기화 모델에서 동기화 컨텍스트를 전파하기 위한 기본 기능을 제공합니다.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.#ctor">
      <summary vsli:raw="Creates a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; class.">
        <see cref="T:System.Threading.SynchronizationContext" /> 클래스의 새 인스턴스를 만듭니다.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.CreateCopy">
      <summary vsli:raw="When overridden in a derived class, creates a copy of the synchronization context.">파생 클래스에서 재정의된 경우 동기화 컨텍스트의 복사본을 만듭니다.</summary>
      <returns vsli:raw="A new &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; object.">새 <see cref="T:System.Threading.SynchronizationContext" /> 개체입니다.</returns>
    </member>
    <member name="P:System.Threading.SynchronizationContext.Current">
      <summary vsli:raw="Gets the synchronization context for the current thread.">현재 스레드의 동기화 컨텍스트를 가져옵니다.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; object representing the current synchronization context.">현재 동기화 컨텍스트를 나타내는 <see cref="T:System.Threading.SynchronizationContext" /> 개체입니다.</returns>
    </member>
    <member name="M:System.Threading.SynchronizationContext.IsWaitNotificationRequired">
      <summary vsli:raw="Determines if wait notification is required.">대기 알림이 필요한지 여부를 결정합니다.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if wait notification is required; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">대기 알림이 필요하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
    </member>
    <member name="M:System.Threading.SynchronizationContext.OperationCompleted">
      <summary vsli:raw="When overridden in a derived class, responds to the notification that an operation has completed.">파생 클래스에서 재정의되면 작업이 완료되었음을 알리는 메시지에 응답합니다.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.OperationStarted">
      <summary vsli:raw="When overridden in a derived class, responds to the notification that an operation has started.">파생 클래스에서 재정의되면 작업이 시작되었음을 알리는 메시지에 응답합니다.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
      <summary vsli:raw="When overridden in a derived class, dispatches an asynchronous message to a synchronization context.">파생 클래스에서 재정의될 때 비동기 메시지를 동기화 컨텍스트로 디스패치합니다.</summary>
      <param name="d" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SendOrPostCallback&quot; /&gt; delegate to call.">호출할 <see cref="T:System.Threading.SendOrPostCallback" /> 대리자입니다.</param>
      <param name="state" vsli:raw="The object passed to the delegate.">대리자에 전달된 개체입니다.</param>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
      <summary vsli:raw="When overridden in a derived class, dispatches a synchronous message to a synchronization context.">파생 클래스에서 재정의될 때 동기 메시지를 동기화 컨텍스트로 디스패치합니다.</summary>
      <param name="d" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SendOrPostCallback&quot; /&gt; delegate to call.">호출할 <see cref="T:System.Threading.SendOrPostCallback" /> 대리자입니다.</param>
      <param name="state" vsli:raw="The object passed to the delegate.">대리자에 전달된 개체입니다.</param>
      <exception cref="T:System.NotSupportedException" vsli:raw="The method was called in a Windows Store app. The implementation of &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; for Windows Store apps does not support the &lt;see cref=&quot;M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)&quot; /&gt; method.">메서드가 Windows 스토어 응용 프로그램에서 호출되었습니다. Windows 스토어 응용 프로그램에 대한 <see cref="T:System.Threading.SynchronizationContext" />의 구현 시 <see cref="M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)" /> 메서드를 지원하지 않습니다.</exception>
    </member>
    <member name="M:System.Threading.SynchronizationContext.SetSynchronizationContext(System.Threading.SynchronizationContext)">
      <summary vsli:raw="Sets the current synchronization context.">현재 동기화 컨텍스트를 설정합니다.</summary>
      <param name="syncContext" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; object to be set.">설정할 <see cref="T:System.Threading.SynchronizationContext" /> 개체입니다.</param>
    </member>
    <member name="M:System.Threading.SynchronizationContext.SetWaitNotificationRequired">
      <summary vsli:raw="Sets notification that wait notification is required and prepares the callback method so it can be called more reliably when a wait occurs.">대기 알림이 필요하다는 알림을 설정하고 대기가 수행될 때 좀 더 안정적으로 호출될 수 있도록 콜백 메서드를 준비합니다.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Wait(System.IntPtr[],System.Boolean,System.Int32)">
      <summary vsli:raw="Waits for any or all the elements in the specified array to receive a signal.">지정된 배열의 임의 또는 모든 요소가 신호를 받기를 기다립니다.</summary>
      <param name="waitHandles" vsli:raw="An array of type &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; that contains the native operating system handles.">네이티브 운영 체제 핸들을 포함하는 <see cref="T:System.IntPtr" /> 유형의 배열입니다.</param>
      <param name="waitAll" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to wait for all handles; &lt;see langword=&quot;false&quot; /&gt; to wait for any handle.">모든 핸들을 대기하려면 <see langword="true" />이고, 임의 핸들을 대기하려면 <see langword="false" />입니다.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</param>
      <returns vsli:raw="The array index of the object that satisfied the wait.">대기를 만족한 개체의 배열 인덱스입니다.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;waitHandles&quot; /&gt; is null.">
        <paramref name="waitHandles" />가 null입니다.</exception>
    </member>
    <member name="M:System.Threading.SynchronizationContext.WaitHelper(System.IntPtr[],System.Boolean,System.Int32)">
      <summary vsli:raw="Helper function that waits for any or all the elements in the specified array to receive a signal.">지정된 배열의 임의 또는 모든 요소가 신호를 받기를 기다리는 도우미 함수입니다.</summary>
      <param name="waitHandles" vsli:raw="An array of type &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; that contains the native operating system handles.">네이티브 운영 체제 핸들을 포함하는 <see cref="T:System.IntPtr" /> 유형의 배열입니다.</param>
      <param name="waitAll" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to wait for all handles;  &lt;see langword=&quot;false&quot; /&gt; to wait for any handle.">모든 핸들을 대기하려면 <see langword="true" />이고, 임의 핸들을 대기하려면 <see langword="false" />입니다.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</param>
      <returns vsli:raw="The array index of the object that satisfied the wait.">대기를 만족한 개체의 배열 인덱스입니다.</returns>
    </member>
    <member name="T:System.Threading.SynchronizationLockException">
      <summary vsli:raw="The exception that is thrown when a method requires the caller to own the lock on a given Monitor, and the method is invoked by a caller that does not own that lock.">메서드가 지정된 Monitor에 대해 잠금을 소유하도록 호출자에게 요구하지만 해당 잠금을 소유하지 않는 호출자가 해당 메서드를 호출할 때 throw되는 예외입니다.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationLockException&quot; /&gt; class with default properties.">기본 속성을 사용하여 <see cref="T:System.Threading.SynchronizationLockException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationLockException&quot; /&gt; class with serialized data.">serialize된 데이터를 사용하여 <see cref="T:System.Threading.SynchronizationLockException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; that holds the serialized object data about the exception being thrown.">throw되는 예외에 대해 serialize된 개체 데이터를 보유하는 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체입니다.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; that contains contextual information about the source or destination.">소스 또는 대상에 대한 컨텍스트 정보를 포함하는 <see cref="T:System.Runtime.Serialization.StreamingContext" />입니다.</param>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationLockException&quot; /&gt; class with a specified error message.">지정된 오류 메시지를 사용하여 <see cref="T:System.Threading.SynchronizationLockException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">예외에 대한 이유를 설명하는 오류 메시지입니다.</param>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationLockException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">지정된 오류 메시지와 해당 예외의 원인인 내부 예외에 대한 참조를 사용하여 <see cref="T:System.Threading.SynchronizationLockException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">예외에 대한 이유를 설명하는 오류 메시지입니다.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">현재 예외의 원인인 예외입니다. <paramref name="innerException" /> 매개 변수가 <see langword="null" />이 아니면 현재 예외는 내부 예외를 처리하는 <see langword="catch" /> 블록에서 발생합니다.</param>
    </member>
    <member name="T:System.Threading.ThreadLocal`1">
      <summary vsli:raw="Provides thread-local storage of data.">데이터의 스레드 로컬 스토리지를 제공합니다.</summary>
      <typeparam name="T" vsli:raw="Specifies the type of data stored per-thread.">스레드별로 저장된 데이터의 형식을 지정합니다.</typeparam>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance.">
        <see cref="T:System.Threading.ThreadLocal`1" /> 인스턴스를 초기화합니다.</summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance and specifies whether all values are accessible from any thread.">
        <see cref="T:System.Threading.ThreadLocal`1" /> 인스턴스를 초기화하고 모든 값을 스레드에서 액세스할 수 있는지 여부를 지정합니다.</summary>
      <param name="trackAllValues" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to track all values set on the instance and expose them through the &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Values&quot; /&gt; property; &lt;see langword=&quot;false&quot; /&gt; otherwise. When set to &lt;see langword=&quot;true&quot; /&gt;, a value stored from a given thread will be available through &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Values&quot; /&gt; even after that thread has exited.">인스턴스에 설정된 모든 값을 추적하고 해당 값을 <see cref="P:System.Threading.ThreadLocal`1.Values" /> 속성을 통해 노출하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0})">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance with the specified &lt;paramref name=&quot;valueFactory&quot; /&gt; function.">지정된 <paramref name="valueFactory" /> 함수를 사용하여 <see cref="T:System.Threading.ThreadLocal`1" />의 인스턴스를 초기화합니다.</summary>
      <param name="valueFactory" vsli:raw="The  &lt;see cref=&quot;T:System.Func`1&quot; /&gt; invoked to produce a lazily-initialized value when an attempt is made to retrieve &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; without it having been previously initialized.">
        <see cref="T:System.Func`1" />를 이전에 초기화하지 않고 검색하려고 하는 경우 lazily-initialized 값을 생성하기 위해 호출되는 <see cref="P:System.Threading.ThreadLocal`1.Value" />입니다.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;valueFactory&quot; /&gt; is a null reference (Nothing in Visual Basic).">
        <paramref name="valueFactory" />가 null 참조(Visual Basic의 경우 Nothing)인 경우</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0},System.Boolean)">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance with the specified &lt;paramref name=&quot;valueFactory&quot; /&gt; function and a flag that indicates whether all values are accessible from any thread.">지정된 <paramref name="valueFactory" /> 함수를 사용하여 <see cref="T:System.Threading.ThreadLocal`1" /> 인스턴스 및 모든 값을 스레드에서 액세스할 수 있는지를 나타내는 플래그를 초기화합니다.</summary>
      <param name="valueFactory" vsli:raw="The &lt;see cref=&quot;T:System.Func`1&quot; /&gt; invoked to produce a lazily-initialized value when an attempt is made to retrieve &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; without it having been previously initialized.">
        <see cref="P:System.Threading.ThreadLocal`1.Value" />를 이전에 초기화하지 않고 검색하려고 하는 경우 지연 초기화 값을 생성하기 위해 호출되는 <see cref="T:System.Func`1" />입니다.</param>
      <param name="trackAllValues" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to track all values set on the instance and expose them through the &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Values&quot; /&gt; property; &lt;see langword=&quot;false&quot; /&gt; otherwise. When set to &lt;see langword=&quot;true&quot; /&gt;, a value stored from a given thread will be available through &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Values&quot; /&gt; even after that thread has exited.">인스턴스에 설정된 모든 값을 추적하고 해당 값을 <see cref="P:System.Threading.ThreadLocal`1.Values" /> 속성을 통해 노출하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;valueFactory&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; reference (&lt;see langword=&quot;Nothing&quot; /&gt; in Visual Basic).">
        <paramref name="valueFactory" />이 <see langword="null" /> 참조(Visual Basic의 경우 <see langword="Nothing" />)인 경우</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; class.">
        <see cref="T:System.Threading.ThreadLocal`1" /> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the resources used by this &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance.">이 <see cref="T:System.Threading.ThreadLocal`1" /> 인스턴스에서 사용하는 리소스를 해제합니다.</summary>
      <param name="disposing" vsli:raw="A Boolean value that indicates whether this method is being called due to a call to &lt;see cref=&quot;M:System.Threading.ThreadLocal`1.Dispose&quot; /&gt;.">
        <see cref="M:System.Threading.ThreadLocal`1.Dispose" /> 호출로 인해 이 메서드가 호출되는지 여부를 나타내는 부울 값입니다.</param>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Finalize">
      <summary vsli:raw="Releases the resources used by this &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance.">이 <see cref="T:System.Threading.ThreadLocal`1" /> 인스턴스에서 사용하는 리소스를 해제합니다.</summary>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.IsValueCreated">
      <summary vsli:raw="Gets whether &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; is initialized on the current thread.">
        <see cref="P:System.Threading.ThreadLocal`1.Value" />가 현재 스레드에서 초기화되었는지 여부를 가져옵니다.</summary>
      <returns vsli:raw="true if &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; is initialized on the current thread; otherwise false.">현재 스레드에서 <see cref="P:System.Threading.ThreadLocal`1.Value" />가 초기화되었으면 true이고, 그렇지 않으면 false입니다.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance has been disposed.">
        <see cref="T:System.Threading.ThreadLocal`1" /> 인스턴스가 삭제되었습니다.</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.ToString">
      <summary vsli:raw="Creates and returns a string representation of this instance for the current thread.">현재 스레드에 대한 이 인스턴스의 문자열 표현을 만들고 반환합니다.</summary>
      <returns vsli:raw="The result of calling &lt;see cref=&quot;M:System.Object.ToString&quot; /&gt; on the &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt;.">
        <see cref="M:System.Object.ToString" />에서 <see cref="P:System.Threading.ThreadLocal`1.Value" />을 호출한 결과입니다.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance has been disposed.">
        <see cref="T:System.Threading.ThreadLocal`1" /> 인스턴스가 삭제되었습니다.</exception>
      <exception cref="T:System.NullReferenceException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; for the current thread is a null reference (Nothing in Visual Basic).">현재 스레드의 <see cref="P:System.Threading.ThreadLocal`1.Value" />는 null 참조입니다(Visual Basic에서는 Nothing).</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The initialization function attempted to reference &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; recursively.">초기화 함수는 <see cref="P:System.Threading.ThreadLocal`1.Value" />를 재귀적으로 참조하려고 했습니다.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="No parameterless constructor is provided and no value factory is supplied.">매개변수가 없는 생성자가 제공되지 않으며 값 팩터리가 제공되지 않습니다.</exception>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Value">
      <summary vsli:raw="Gets or sets the value of this instance for the current thread.">현재 인스턴스에 대한 이 인스턴스의 값을 가져오거나 설정합니다.</summary>
      <returns vsli:raw="Returns an instance of the object that this ThreadLocal is responsible for initializing.">이 ThreadLocal이 초기화를 담당하는 개체의 인스턴스를 반환합니다.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance has been disposed.">
        <see cref="T:System.Threading.ThreadLocal`1" /> 인스턴스가 삭제되었습니다.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The initialization function attempted to reference &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; recursively.">초기화 함수는 <see cref="P:System.Threading.ThreadLocal`1.Value" />를 재귀적으로 참조하려고 했습니다.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="No parameterless constructor is provided and no value factory is supplied.">매개변수가 없는 생성자가 제공되지 않으며 값 팩터리가 제공되지 않습니다.</exception>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Values">
      <summary vsli:raw="Gets a list containing the values stored by all threads that have accessed this instance.">이 인스턴스에 액세스한 모든 스레드가 현재 저장한 모든 값의 목록을 가져옵니다.</summary>
      <returns vsli:raw="A list for all of the values stored by all of the threads that have accessed this instance.">이 인스턴스에 액세스한 모든 스레드가 현재 저장한 모든 값의 목록입니다.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Values stored by all threads are not available because this instance was initialized with the &lt;paramref name=&quot;trackAllValues&quot; /&gt; argument set to &lt;see langword=&quot;false&quot; /&gt; in the call to a class constructor.">클래스 생성자에 대한 호출에서 <see langword="false" />로 설정된 <paramref name="trackAllValues" /> 인수를 사용하여 이 인스턴스를 초기화했기 때문에 모든 스레드에서 저장한 값을 사용할 수 없습니다.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance has been disposed.">
        <see cref="T:System.Threading.ThreadLocal`1" /> 인스턴스가 삭제되었습니다.</exception>
    </member>
    <member name="T:System.Threading.Volatile">
      <summary vsli:raw="Contains methods for performing volatile memory operations.">휘발성 메모리 작업을 수행하기 위한 메서드를 포함합니다.</summary>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Boolean@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">지정된 필드의 값을 읽습니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 뒤에 나타나는 경우 프로세서가 이 메서드 앞으로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field to read.">읽을 필드입니다.</param>
      <returns vsli:raw="The value that was read.">읽은 값입니다. 이 값은 프로세서 수나 프로세서 캐시의 상태에 관계없이 컴퓨터의 어떠한 프로세서에서든 마지막으로 쓴 것입니다.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Byte@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">지정된 필드의 값을 읽습니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 뒤에 나타나는 경우 프로세서가 이 메서드 앞으로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field to read.">읽을 필드입니다.</param>
      <returns vsli:raw="The value that was read.">읽은 값입니다. 이 값은 프로세서 수나 프로세서 캐시의 상태에 관계없이 컴퓨터의 어떠한 프로세서에서든 마지막으로 쓴 것입니다.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Double@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">지정된 필드의 값을 읽습니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 뒤에 나타나는 경우 프로세서가 이 메서드 앞으로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field to read.">읽을 필드입니다.</param>
      <returns vsli:raw="The value that was read.">읽은 값입니다. 이 값은 프로세서 수나 프로세서 캐시의 상태에 관계없이 컴퓨터의 어떠한 프로세서에서든 마지막으로 쓴 것입니다.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int16@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">지정된 필드의 값을 읽습니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 뒤에 나타나는 경우 프로세서가 이 메서드 앞으로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field to read.">읽을 필드입니다.</param>
      <returns vsli:raw="The value that was read.">읽은 값입니다. 이 값은 프로세서 수나 프로세서 캐시의 상태에 관계없이 컴퓨터의 어떠한 프로세서에서든 마지막으로 쓴 것입니다.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int32@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">지정된 필드의 값을 읽습니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 뒤에 나타나는 경우 프로세서가 이 메서드 앞으로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field to read.">읽을 필드입니다.</param>
      <returns vsli:raw="The value that was read.">읽은 값입니다. 이 값은 프로세서 수나 프로세서 캐시의 상태에 관계없이 컴퓨터의 어떠한 프로세서에서든 마지막으로 쓴 것입니다.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int64@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">지정된 필드의 값을 읽습니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 뒤에 나타나는 경우 프로세서가 이 메서드 앞으로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field to read.">읽을 필드입니다.</param>
      <returns vsli:raw="The value that was read.">읽은 값입니다. 이 값은 프로세서 수나 프로세서 캐시의 상태에 관계없이 컴퓨터의 어떠한 프로세서에서든 마지막으로 쓴 것입니다.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.IntPtr@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">지정된 필드의 값을 읽습니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 뒤에 나타나는 경우 프로세서가 이 메서드 앞으로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field to read.">읽을 필드입니다.</param>
      <returns vsli:raw="The value that was read.">읽은 값입니다. 이 값은 프로세서 수나 프로세서 캐시의 상태에 관계없이 컴퓨터의 어떠한 프로세서에서든 마지막으로 쓴 것입니다.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.SByte@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">지정된 필드의 값을 읽습니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 뒤에 나타나는 경우 프로세서가 이 메서드 앞으로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field to read.">읽을 필드입니다.</param>
      <returns vsli:raw="The value that was read.">읽은 값입니다. 이 값은 프로세서 수나 프로세서 캐시의 상태에 관계없이 컴퓨터의 어떠한 프로세서에서든 마지막으로 쓴 것입니다.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Single@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">지정된 필드의 값을 읽습니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 뒤에 나타나는 경우 프로세서가 이 메서드 앞으로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field to read.">읽을 필드입니다.</param>
      <returns vsli:raw="The value that was read.">읽은 값입니다. 이 값은 프로세서 수나 프로세서 캐시의 상태에 관계없이 컴퓨터의 어떠한 프로세서에서든 마지막으로 쓴 것입니다.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt16@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">지정된 필드의 값을 읽습니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 뒤에 나타나는 경우 프로세서가 이 메서드 앞으로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field to read.">읽을 필드입니다.</param>
      <returns vsli:raw="The value that was read.">읽은 값입니다. 이 값은 프로세서 수나 프로세서 캐시의 상태에 관계없이 컴퓨터의 어떠한 프로세서에서든 마지막으로 쓴 것입니다.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt32@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">지정된 필드의 값을 읽습니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 뒤에 나타나는 경우 프로세서가 이 메서드 앞으로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field to read.">읽을 필드입니다.</param>
      <returns vsli:raw="The value that was read.">읽은 값입니다. 이 값은 프로세서 수나 프로세서 캐시의 상태에 관계없이 컴퓨터의 어떠한 프로세서에서든 마지막으로 쓴 것입니다.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt64@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">지정된 필드의 값을 읽습니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 뒤에 나타나는 경우 프로세서가 이 메서드 앞으로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field to read.">읽을 필드입니다.</param>
      <returns vsli:raw="The value that was read.">읽은 값입니다. 이 값은 프로세서 수나 프로세서 캐시의 상태에 관계없이 컴퓨터의 어떠한 프로세서에서든 마지막으로 쓴 것입니다.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UIntPtr@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">지정된 필드의 값을 읽습니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 뒤에 나타나는 경우 프로세서가 이 메서드 앞으로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field to read.">읽을 필드입니다.</param>
      <returns vsli:raw="The value that was read.">읽은 값입니다. 이 값은 프로세서 수나 프로세서 캐시의 상태에 관계없이 컴퓨터의 어떠한 프로세서에서든 마지막으로 쓴 것입니다.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read``1(``0@)">
      <summary vsli:raw="Reads the object reference from the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">지정된 필드에서 개체 참조를 읽습니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 뒤에 나타나는 경우 프로세서가 이 메서드 앞으로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field to read.">읽을 필드입니다.</param>
      <typeparam name="T" vsli:raw="The type of field to read. This must be a reference type, not a value type.">읽을 필드의 형식입니다. 이 형식은 값 형식이 아니라 참조 형식이어야 합니다.</typeparam>
      <returns vsli:raw="The reference to &lt;paramref name=&quot;T&quot; /&gt; that was read. This reference is the latest written by any processor in the computer, regardless of the number of processors or the state of processor cache.">읽은 <paramref name="T" />에 대한 참조입니다. 이 참조는 프로세서 수나 프로세서 캐시의 상태에 관계없이 컴퓨터의 어떠한 프로세서에서든 마지막으로 쓴 것입니다.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Boolean@,System.Boolean)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">지정된 필드에 지정된 값을 씁니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 앞에 나타나는 경우 프로세서가 이 메서드 뒤로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field where the value is written.">값을 쓴 필드입니다.</param>
      <param name="value" vsli:raw="The value to write.">작성할 값입니다. 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 즉시 씁니다.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Byte@,System.Byte)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">지정된 필드에 지정된 값을 씁니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 앞에 나타나는 경우 프로세서가 이 메서드 뒤로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field where the value is written.">값을 쓴 필드입니다.</param>
      <param name="value" vsli:raw="The value to write.">작성할 값입니다. 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 즉시 씁니다.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Double@,System.Double)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">지정된 필드에 지정된 값을 씁니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 앞에 나타나는 경우 프로세서가 이 메서드 뒤로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field where the value is written.">값을 쓴 필드입니다.</param>
      <param name="value" vsli:raw="The value to write.">작성할 값입니다. 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 즉시 씁니다.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int16@,System.Int16)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">지정된 필드에 지정된 값을 씁니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 앞에 나타나는 경우 프로세서가 이 메서드 뒤로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field where the value is written.">값을 쓴 필드입니다.</param>
      <param name="value" vsli:raw="The value to write.">작성할 값입니다. 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 즉시 씁니다.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int32@,System.Int32)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">지정된 필드에 지정된 값을 씁니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 앞에 나타나는 경우 프로세서가 이 메서드 뒤로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field where the value is written.">값을 쓴 필드입니다.</param>
      <param name="value" vsli:raw="The value to write.">작성할 값입니다. 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 즉시 씁니다.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int64@,System.Int64)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">지정된 필드에 지정된 값을 씁니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 앞에 나타나는 경우 프로세서가 이 메서드 뒤로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field where the value is written.">값을 쓴 필드입니다.</param>
      <param name="value" vsli:raw="The value to write.">작성할 값입니다. 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 즉시 씁니다.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.IntPtr@,System.IntPtr)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">지정된 필드에 지정된 값을 씁니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 앞에 나타나는 경우 프로세서가 이 메서드 뒤로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field where the value is written.">값을 쓴 필드입니다.</param>
      <param name="value" vsli:raw="The value to write.">작성할 값입니다. 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 즉시 씁니다.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.SByte@,System.SByte)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">지정된 필드에 지정된 값을 씁니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 앞에 나타나는 경우 프로세서가 이 메서드 뒤로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field where the value is written.">값을 쓴 필드입니다.</param>
      <param name="value" vsli:raw="The value to write.">작성할 값입니다. 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 즉시 씁니다.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Single@,System.Single)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">지정된 필드에 지정된 값을 씁니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 앞에 나타나는 경우 프로세서가 이 메서드 뒤로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field where the value is written.">값을 쓴 필드입니다.</param>
      <param name="value" vsli:raw="The value to write.">작성할 값입니다. 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 즉시 씁니다.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt16@,System.UInt16)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">지정된 필드에 지정된 값을 씁니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 앞에 나타나는 경우 프로세서가 이 메서드 뒤로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field where the value is written.">값을 쓴 필드입니다.</param>
      <param name="value" vsli:raw="The value to write.">작성할 값입니다. 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 즉시 씁니다.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt32@,System.UInt32)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">지정된 필드에 지정된 값을 씁니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 앞에 나타나는 경우 프로세서가 이 메서드 뒤로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field where the value is written.">값을 쓴 필드입니다.</param>
      <param name="value" vsli:raw="The value to write.">작성할 값입니다. 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 즉시 씁니다.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt64@,System.UInt64)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">지정된 필드에 지정된 값을 씁니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 앞에 나타나는 경우 프로세서가 이 메서드 뒤로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field where the value is written.">값을 쓴 필드입니다.</param>
      <param name="value" vsli:raw="The value to write.">작성할 값입니다. 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 즉시 씁니다.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UIntPtr@,System.UIntPtr)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">지정된 필드에 지정된 값을 씁니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 앞에 나타나는 경우 프로세서가 이 메서드 뒤로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field where the value is written.">값을 쓴 필드입니다.</param>
      <param name="value" vsli:raw="The value to write.">작성할 값입니다. 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 즉시 씁니다.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write``1(``0@,``0)">
      <summary vsli:raw="Writes the specified object reference to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">지정된 필드에 지정된 개체 참조를 씁니다. 필요한 시스템에서는 프로세서가 메모리 작업을 다시 정렬하는 것을 막는 메모리 차단을 다음과 같이 삽입합니다. 코드에서 읽기 또는 쓰기가 이 메서드 앞에 나타나는 경우 프로세서가 이 메서드 뒤로 읽기 또는 쓰기를 이동할 수 없습니다.</summary>
      <param name="location" vsli:raw="The field where the object reference is written.">개체 참조를 쓴 필드입니다.</param>
      <param name="value" vsli:raw="The object reference to write.">쓸 개체 참조입니다. 컴퓨터의 모든 프로세서에서 참조를 볼 수 있도록 참조를 즉시 씁니다.</param>
      <typeparam name="T" vsli:raw="The type of field to write. This must be a reference type, not a value type.">쓸 필드의 형식입니다. 이 형식은 값 형식이 아니라 참조 형식이어야 합니다.</typeparam>
    </member>
    <member name="T:System.Threading.WaitHandleCannotBeOpenedException">
      <summary vsli:raw="The exception that is thrown when an attempt is made to open a system mutex, semaphore, or event wait handle that does not exist.">존재하지 않는 시스템 뮤텍스, 세마포 또는 이벤트 대기 핸들을 열려고 할 때 throw되는 예외입니다.</summary>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.WaitHandleCannotBeOpenedException&quot; /&gt; class with default values.">기본값을 사용하여 <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.WaitHandleCannotBeOpenedException&quot; /&gt; class with serialized data.">serialize된 데이터를 사용하여 <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object that holds the serialized object data about the exception being thrown.">발생되는 예외에 대해 직렬화된 개체 데이터를 보유하는 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체입니다.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; object that contains contextual information about the source or destination.">소스 또는 대상에 대한 컨텍스트 정보를 포함하는 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 개체입니다.</param>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.WaitHandleCannotBeOpenedException&quot; /&gt; class with a specified error message.">지정된 오류 메시지를 사용하여 <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">예외에 대한 이유를 설명하는 오류 메시지입니다.</param>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.WaitHandleCannotBeOpenedException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">지정된 오류 메시지와 해당 예외의 원인인 내부 예외에 대한 참조를 사용하여 <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">예외에 대한 이유를 설명하는 오류 메시지입니다.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">현재 예외의 원인인 예외입니다. <paramref name="innerException" /> 매개 변수가 <see langword="null" />이 아니면 현재 예외는 내부 예외를 처리하는 <see langword="catch" /> 블록에서 발생합니다.</param>
    </member>
  </members>
</doc>