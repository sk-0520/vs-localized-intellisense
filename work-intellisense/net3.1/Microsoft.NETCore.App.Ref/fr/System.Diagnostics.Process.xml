<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Diagnostics.Process</name>
  </assembly>
  <members>
    <member name="T:Microsoft.Win32.SafeHandles.SafeProcessHandle">
      <summary>Fournit un wrapper managé pour un handle de processus.</summary>
    </member>
    <member name="M:Microsoft.Win32.SafeHandles.SafeProcessHandle.#ctor(System.IntPtr,System.Boolean)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:Microsoft.Win32.SafeHandles.SafeProcessHandle" /> à partir du handle spécifié, indiquant s’il faut libérer le handle durant la phase de finalisation.</summary>
      <param name="existingHandle">Handle à encapsuler.</param>
      <param name="ownsHandle">
        <see langword="true" /> pour laisser <see cref="T:Microsoft.Win32.SafeHandles.SafeProcessHandle" /> libérer de manière fiable le handle pendant la phase de finalisation ; sinon, <see langword="false" />.</param>
    </member>
    <member name="P:Microsoft.Win32.SafeHandles.SafeProcessHandle.IsInvalid" />
    <member name="T:System.Diagnostics.DataReceivedEventArgs">
      <summary>Fournit des données pour les événements <see cref="E:System.Diagnostics.Process.OutputDataReceived" /> et <see cref="E:System.Diagnostics.Process.ErrorDataReceived" />.</summary>
    </member>
    <member name="P:System.Diagnostics.DataReceivedEventArgs.Data">
      <summary>Obtient la ligne de caractères qui a été écrite dans un flux de sortie <see cref="T:System.Diagnostics.Process" /> redirigé.</summary>
      <returns>Ligne qui a été écrite par un <see cref="T:System.Diagnostics.Process" /> associé à son <see cref="P:System.Diagnostics.Process.StandardOutput" /> redirigé ou à son flux <see cref="P:System.Diagnostics.Process.StandardError" />.</returns>
    </member>
    <member name="T:System.Diagnostics.DataReceivedEventHandler">
      <summary>Représente la méthode qui gérera l'événement <see cref="E:System.Diagnostics.Process.OutputDataReceived" /> ou l'événement <see cref="E:System.Diagnostics.Process.ErrorDataReceived" /> de <see cref="T:System.Diagnostics.Process" />.</summary>
      <param name="sender">Source de l'événement.</param>
      <param name="e">
        <see cref="T:System.Diagnostics.DataReceivedEventArgs" /> qui contient les données d'événement.</param>
    </member>
    <member name="T:System.Diagnostics.MonitoringDescriptionAttribute">
      <summary>Spécifie une description pour une propriété ou un événement.</summary>
    </member>
    <member name="M:System.Diagnostics.MonitoringDescriptionAttribute.#ctor(System.String)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Diagnostics.MonitoringDescriptionAttribute" /> à l'aide de la description spécifiée.</summary>
      <param name="description">Texte de description défini par l'application.</param>
    </member>
    <member name="P:System.Diagnostics.MonitoringDescriptionAttribute.Description">
      <summary>Obtient le texte de description associé à l'élément surveillé.</summary>
      <returns>Description définie par l'application.</returns>
    </member>
    <member name="T:System.Diagnostics.Process">
      <summary>Fournit l'accès à des processus locaux ainsi que distants, et vous permet de démarrer et d'arrêter des processus système locaux.</summary>
    </member>
    <member name="M:System.Diagnostics.Process.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Diagnostics.Process" />.</summary>
    </member>
    <member name="P:System.Diagnostics.Process.BasePriority">
      <summary>Obtient la priorité de base du processus associé.</summary>
      <returns>Priorité de base, calculée à partir du <see cref="P:System.Diagnostics.Process.PriorityClass" /> du processus associé.</returns>
      <exception cref="T:System.InvalidOperationException">Le processus s’est fermé.

ou -

Le processus n’a pas démarré. De ce fait, il n’existe aucun ID de processus.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.BeginErrorReadLine">
      <summary>Commence des opérations de lecture asynchrones sur le flux de données <see cref="P:System.Diagnostics.Process.StandardError" /> redirigé de l'application.</summary>
      <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> a la valeur <see langword="false" />.

ou -
Une opération de lecture asynchrone est déjà en cours sur le flux <see cref="P:System.Diagnostics.Process.StandardError" />.

ou -
Le flux <see cref="P:System.Diagnostics.Process.StandardError" /> a été utilisé par une opération de lecture synchrone.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.BeginOutputReadLine">
      <summary>Commence des opérations de lecture asynchrones sur le flux de données <see cref="P:System.Diagnostics.Process.StandardOutput" /> redirigé de l'application.</summary>
      <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> a la valeur <see langword="false" />.

ou -
Une opération de lecture asynchrone est déjà en cours sur le flux <see cref="P:System.Diagnostics.Process.StandardOutput" />.

ou -
Le flux <see cref="P:System.Diagnostics.Process.StandardOutput" /> a été utilisé par une opération de lecture synchrone.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.CancelErrorRead">
      <summary>Annule l'opération de lecture asynchrone sur le flux <see cref="P:System.Diagnostics.Process.StandardError" /> redirigé d'une application.</summary>
      <exception cref="T:System.InvalidOperationException">Le flux <see cref="P:System.Diagnostics.Process.StandardError" /> n’est pas activé pour des opérations de lecture asynchrones.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.CancelOutputRead">
      <summary>Annule l'opération de lecture asynchrone sur le flux <see cref="P:System.Diagnostics.Process.StandardOutput" /> redirigé d'une application.</summary>
      <exception cref="T:System.InvalidOperationException">Le flux <see cref="P:System.Diagnostics.Process.StandardOutput" /> n’est pas activé pour des opérations de lecture asynchrones.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.Close">
      <summary>Libère toutes les ressources associées à ce composant.</summary>
    </member>
    <member name="M:System.Diagnostics.Process.CloseMainWindow">
      <summary>Ferme un processus possédant une interface utilisateur en envoyant un message de fermeture à sa fenêtre principale.</summary>
      <returns>
        <see langword="true" /> si le message de fermeture a été correctement envoyé ; <see langword="false" /> si le processus associé ne possède pas de fenêtre principale ou si celle-ci est désactivée (par exemple si une boîte de dialogue modale est affichée).</returns>
      <exception cref="T:System.InvalidOperationException">Le processus est déjà terminé.

ou -
Aucun processus n’est associé à cet objet <see cref="T:System.Diagnostics.Process" />.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.Dispose(System.Boolean)">
      <summary>Libère toutes les ressources utilisées par ce processus.</summary>
      <param name="disposing">
        <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="P:System.Diagnostics.Process.EnableRaisingEvents">
      <summary>Obtient ou définit une valeur indiquant si l'événement <see cref="E:System.Diagnostics.Process.Exited" /> est déclenché quand le processus ne s'exécute plus.</summary>
      <returns>
        <see langword="true" /> si l'événement <see cref="E:System.Diagnostics.Process.Exited" /> doit être déclenché une fois que le processus associé n'est plus exécuté (sortie ou appel à <see cref="M:System.Diagnostics.Process.Kill" />) ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />. Notez que l’événement <see cref="E:System.Diagnostics.Process.Exited" /> est déclenché même si la valeur de <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> est <see langword="false" /> lorsque le processus se termine pendant ou avant que l’utilisateur effectue une vérification de <see cref="P:System.Diagnostics.Process.HasExited" />.</returns>
    </member>
    <member name="M:System.Diagnostics.Process.EnterDebugMode">
      <summary>Met un composant <see cref="T:System.Diagnostics.Process" /> en état d'interagir avec des processus du système d'exploitation qui s'exécutent en mode spécial en activant la propriété native <see langword="SeDebugPrivilege" /> sur le thread actuel.</summary>
    </member>
    <member name="E:System.Diagnostics.Process.ErrorDataReceived">
      <summary>Se produit quand une application écrit dans son flux <see cref="P:System.Diagnostics.Process.StandardError" /> redirigé.</summary>
    </member>
    <member name="P:System.Diagnostics.Process.ExitCode">
      <summary>Obtient la valeur spécifiée par le processus associé au moment où il s'est terminé.</summary>
      <returns>Code spécifié par le processus associé une fois celui-ci terminé.</returns>
      <exception cref="T:System.InvalidOperationException">Le processus ne s’est pas fermé.

ou -
Le processus <see cref="P:System.Diagnostics.Process.Handle" /> n’est pas valide.</exception>
      <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.ExitCode" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
    </member>
    <member name="E:System.Diagnostics.Process.Exited">
      <summary>Se produit quand un processus se termine.</summary>
    </member>
    <member name="P:System.Diagnostics.Process.ExitTime">
      <summary>Obtient l'heure à laquelle le processus associé s'est terminé.</summary>
      <returns>
        <see cref="T:System.DateTime" /> qui indique le moment où le processus associé s'est terminé.</returns>
      <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.ExitTime" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.GetCurrentProcess">
      <summary>Obtient un nouveau composant <see cref="T:System.Diagnostics.Process" /> et l'associe au processus actuellement actif.</summary>
      <returns>Nouveau composant <see cref="T:System.Diagnostics.Process" /> associé à la ressource de processus qui exécute l'application appelante.</returns>
    </member>
    <member name="M:System.Diagnostics.Process.GetProcessById(System.Int32)">
      <summary>Retourne un nouveau composant <see cref="T:System.Diagnostics.Process" />, en fonction de l'identificateur d'un processus sur l'ordinateur local.</summary>
      <param name="processId">Identificateur unique au système d'une ressource de processus.</param>
      <returns>Composant <see cref="T:System.Diagnostics.Process" /> associé à la ressource de processus locale identifiée par le paramètre <paramref name="processId" />.</returns>
      <exception cref="T:System.ArgumentException">Le processus spécifié par le paramètre <paramref name="processId" /> n’est pas en cours d’exécution. L’identificateur peut avoir expiré.</exception>
      <exception cref="T:System.InvalidOperationException">Le processus n’a pas été démarré par cet objet.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)">
      <summary>Retourne un nouveau composant <see cref="T:System.Diagnostics.Process" />, en fonction d'un identificateur de processus et du nom d'un ordinateur du réseau.</summary>
      <param name="processId">Identificateur unique au système d'une ressource de processus.</param>
      <param name="machineName">Nom d'un ordinateur du réseau.</param>
      <returns>Composant <see cref="T:System.Diagnostics.Process" /> associé à une ressource de processus distante identifiée par le paramètre <paramref name="processId" />.</returns>
      <exception cref="T:System.ArgumentException">Le processus spécifié par le paramètre <paramref name="processId" /> n’est pas en cours d’exécution. L’identificateur peut avoir expiré.

ou -
La syntaxe du paramètre <paramref name="machineName" /> n’est pas valide. Le nom peut être de longueur zéro (0).</exception>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="machineName" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le processus n’a pas été démarré par cet objet.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.GetProcesses">
      <summary>Crée un composant <see cref="T:System.Diagnostics.Process" /> pour chaque ressource de processus sur l'ordinateur local.</summary>
      <returns>Tableau de type <see cref="T:System.Diagnostics.Process" /> représentant toutes les ressources de processus exécutées sur l'ordinateur local.</returns>
    </member>
    <member name="M:System.Diagnostics.Process.GetProcesses(System.String)">
      <summary>Crée un composant <see cref="T:System.Diagnostics.Process" /> pour chaque ressource de processus sur l'ordinateur spécifié.</summary>
      <param name="machineName">Ordinateur à partir duquel lire la liste de processus.</param>
      <returns>Tableau de type <see cref="T:System.Diagnostics.Process" /> représentant toutes les ressources de processus exécutées sur l'ordinateur spécifié.</returns>
      <exception cref="T:System.ArgumentException">La syntaxe du paramètre <paramref name="machineName" /> n’est pas valide. Sa longueur est peut-être égale à zéro (0).</exception>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="machineName" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">La plateforme du système d’exploitation ne prend pas en charge cette opération sur les ordinateurs distants.</exception>
      <exception cref="T:System.InvalidOperationException">L’accès à l’API du compteur de performance pour obtenir des informations sur les processus présente des problèmes. Cette exception est propre à Windows NT, Windows 2000 et Windows XP.</exception>
      <exception cref="T:System.ComponentModel.Win32Exception">Un problème s’est produit pendant l’accès à l’API système sous-jacente.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.GetProcessesByName(System.String)">
      <summary>Crée un tableau de nouveaux composants <see cref="T:System.Diagnostics.Process" /> et les associe à toutes les ressources de processus de l'ordinateur local qui partagent le nom de processus spécifié.</summary>
      <param name="processName">Nom convivial du processus.</param>
      <returns>Tableau de type <see cref="T:System.Diagnostics.Process" /> représentant les ressources de processus exécutant l'application ou le fichier spécifié.</returns>
      <exception cref="T:System.InvalidOperationException">L’accès à l’API du compteur de performance pour obtenir des informations sur les processus présente des problèmes. Cette exception est propre à Windows NT, Windows 2000 et Windows XP.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)">
      <summary>Crée un tableau de nouveaux composants <see cref="T:System.Diagnostics.Process" /> et les associe à toutes les ressources de processus sur l'ordinateur distant qui partagent le nom de processus spécifié.</summary>
      <param name="processName">Nom convivial du processus.</param>
      <param name="machineName">Nom d'un ordinateur du réseau.</param>
      <returns>Tableau de type <see cref="T:System.Diagnostics.Process" /> représentant les ressources de processus exécutant l'application ou le fichier spécifié.</returns>
      <exception cref="T:System.ArgumentException">La syntaxe du paramètre <paramref name="machineName" /> n’est pas valide. Sa longueur est peut-être égale à zéro (0).</exception>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="machineName" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">La plateforme du système d’exploitation ne prend pas en charge cette opération sur les ordinateurs distants.</exception>
      <exception cref="T:System.InvalidOperationException">La tentative de connexion à <paramref name="machineName" /> a échoué.

ou -
L’accès à l’API du compteur de performance pour obtenir des informations sur les processus présente des problèmes. Cette exception est propre à Windows NT, Windows 2000 et Windows XP.</exception>
      <exception cref="T:System.ComponentModel.Win32Exception">Un problème s’est produit pendant l’accès à l’API système sous-jacente.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.Handle">
      <summary>Obtient le handle natif du processus associé.</summary>
      <returns>Handle que le système d'exploitation a assigné au processus associé au moment du démarrage du processus. Le système utilise ce handle pour assurer le suivi des attributs du processus.</returns>
      <exception cref="T:System.InvalidOperationException">Le processus n’a pas été démarré ou s’est arrêté. La propriété <see cref="P:System.Diagnostics.Process.Handle" /> ne peut pas être lue, car il n’existe aucun processus associé à cette instance <see cref="T:System.Diagnostics.Process" />.

ou -
L’instance <see cref="T:System.Diagnostics.Process" /> a été attachée à un processus en cours d’exécution, mais vous n’avez pas les autorisations nécessaires pour obtenir un handle avec des droits d’accès complets.</exception>
      <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.Handle" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.HandleCount">
      <summary>Obtient le nombre de handles ouverts par le processus.</summary>
      <returns>Nombre de handles du système d'exploitation ouverts par le processus.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.HasExited">
      <summary>Obtient une valeur indiquant si le processus associé s'est terminé.</summary>
      <returns>
        <see langword="true" /> si le processus du système d'exploitation référencé par le composant <see cref="T:System.Diagnostics.Process" /> s'est terminé ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.InvalidOperationException">Aucun processus n’est associé à l’objet.</exception>
      <exception cref="T:System.ComponentModel.Win32Exception">Nous n’avons pas pu récupéré le code de sortie pour le processus.</exception>
      <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.HasExited" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.Id">
      <summary>Obtient l'identificateur unique du processus associé.</summary>
      <returns>Identificateur unique généré par le système du processus référencé par cette instance <see cref="T:System.Diagnostics.Process" />.</returns>
      <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Diagnostics.Process.Id" /> du processus n’a pas été définie.

ou -
Aucun processus n’est associé à cet objet <see cref="T:System.Diagnostics.Process" />.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.Kill">
      <summary>Arrête immédiatement le processus associé.</summary>
      <exception cref="T:System.ComponentModel.Win32Exception">Le processus associé n’a pas pu être arrêté.

ou -

Le processus est en train de se terminer.</exception>
      <exception cref="T:System.NotSupportedException">Vous tentez d’appeler <see cref="M:System.Diagnostics.Process.Kill" /> pour un processus en cours d’exécution sur un ordinateur distant. La méthode est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
      <exception cref="T:System.InvalidOperationException">Le processus est déjà terminé.

ou -
Aucun processus n’est associé à cet objet <see cref="T:System.Diagnostics.Process" />.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.Kill(System.Boolean)">
      <summary>Arrête immédiatement le processus associé et éventuellement ses processus enfants/descendants.</summary>
      <param name="entireProcessTree">
        <see langword="true" /> pour tuer le processus associé et ses descendants ; <see langword="false" /> pour tuer uniquement le processus associé.</param>
      <exception cref="T:System.ComponentModel.Win32Exception">Le processus associé n’a pas pu être arrêté.

ou -

Le processus est en train de se terminer.</exception>
      <exception cref="T:System.NotSupportedException">Vous tentez d’appeler <see cref="M:System.Diagnostics.Process.Kill" /> pour un processus en cours d’exécution sur un ordinateur distant. La méthode est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
      <exception cref="T:System.InvalidOperationException">Le processus est déjà terminé.

ou -
Aucun processus n’est associé à cet objet <see cref="T:System.Diagnostics.Process" /> .

ou -


Le processus appelant est un membre de l’arborescence descendante du processus associé.</exception>
      <exception cref="T:System.AggregateException">Les processus de l’arborescence descendante du processus associé n’ont pas tous pu être arrêtés.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.LeaveDebugMode">
      <summary>Met un composant <see cref="T:System.Diagnostics.Process" /> hors de l'état qui lui permet d'interagir avec des processus du système d'exploitation qui s'exécutent en mode spécial.</summary>
    </member>
    <member name="P:System.Diagnostics.Process.MachineName">
      <summary>Obtient le nom de l'ordinateur sur lequel s'exécute le processus associé.</summary>
      <returns>Nom de l'ordinateur sur lequel s'exécute le processus associé.</returns>
      <exception cref="T:System.InvalidOperationException">Aucun processus n’est associé à cet objet <see cref="T:System.Diagnostics.Process" />.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.MainModule">
      <summary>Obtient le module principal pour le processus associé.</summary>
      <returns>
        <see cref="T:System.Diagnostics.ProcessModule" /> qui a été utilisé pour démarrer le processus.</returns>
      <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.MainModule" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
      <exception cref="T:System.ComponentModel.Win32Exception">Un processus 32 bits tente d’accéder aux modules d’un processus 64 bits.</exception>
      <exception cref="T:System.InvalidOperationException">Le processus <see cref="P:System.Diagnostics.Process.Id" /> n’est pas disponible.

ou -
Le processus s’est fermé.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.MainWindowHandle">
      <summary>Obtient le handle de la fenêtre principale du processus associé.</summary>
      <returns>Handle, généré par le système, de la fenêtre principale du processus associé.</returns>
      <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> n’est pas définie, car le processus s’est fermé.</exception>
      <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.MainWindowTitle">
      <summary>Obtient la légende de la fenêtre principale du processus.</summary>
      <returns>Titre de la fenêtre principale du processus.</returns>
      <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> n’est pas définie, car le processus s’est fermé.</exception>
      <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.MaxWorkingSet">
      <summary>Obtient ou définit la taille maximale autorisée du jeu de travail, en octets, pour le processus associé.</summary>
      <returns>Taille maximale du jeu de travail pouvant être mise en mémoire pour le processus, en octets.</returns>
      <exception cref="T:System.ArgumentException">La taille maximale du jeu de travail n’est pas valide. Elle doit être supérieure ou égale à la taille minimale du jeu de travail.</exception>
      <exception cref="T:System.ComponentModel.Win32Exception">Les informations sur le jeu de travail ne peuvent pas être récupérées de la ressource de processus associée.

ou -

L’identificateur ou le handle du processus est zéro, car le processus n’a pas été démarré.</exception>
      <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
      <exception cref="T:System.InvalidOperationException">Le processus <see cref="P:System.Diagnostics.Process.Id" /> n’est pas disponible.

ou -
Le processus s’est fermé.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.MinWorkingSet">
      <summary>Obtient ou définit la taille minimale autorisée du jeu de travail, en octets, pour le processus associé.</summary>
      <returns>Taille minimale du jeu de travail requise en mémoire pour le processus, en octets.</returns>
      <exception cref="T:System.ArgumentException">La taille minimale du jeu de travail n’est pas valide. Elle doit être inférieure ou égale à la taille maximale du jeu de travail.</exception>
      <exception cref="T:System.ComponentModel.Win32Exception">Les informations sur le jeu de travail ne peuvent pas être récupérées de la ressource de processus associée.

ou -

L’identificateur ou le handle du processus est zéro, car le processus n’a pas été démarré.</exception>
      <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
      <exception cref="T:System.InvalidOperationException">Le processus <see cref="P:System.Diagnostics.Process.Id" /> n’est pas disponible.

ou -
Le processus s’est fermé.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.Modules">
      <summary>Obtient les modules qui ont été chargés par le processus associé.</summary>
      <returns>Tableau de type <see cref="T:System.Diagnostics.ProcessModule" /> représentant les modules qui ont été chargés par le processus associé.</returns>
      <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.Modules" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
      <exception cref="T:System.InvalidOperationException">Le processus <see cref="P:System.Diagnostics.Process.Id" /> n’est pas disponible.</exception>
      <exception cref="T:System.ComponentModel.Win32Exception">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.Modules" /> du processus système ou du processus inactif. Ces processus n’ont pas de modules.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.NonpagedSystemMemorySize">
      <summary>Obtient la quantité de mémoire système non paginée, en octets, allouée pour le processus associé.</summary>
      <returns>Quantité de mémoire, en octets, que le système a allouée au processus associé qui ne peut pas être écrite dans le fichier d'échange de la mémoire virtuelle.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.NonpagedSystemMemorySize64">
      <summary>Obtient la quantité de mémoire système non paginée, en octets, allouée pour le processus associé.</summary>
      <returns>Quantité de mémoire système, en octets, allouée au processus associé qui ne peut pas être écrite dans le fichier d'échange de la mémoire virtuelle.</returns>
    </member>
    <member name="M:System.Diagnostics.Process.OnExited">
      <summary>Déclenche l'événement <see cref="E:System.Diagnostics.Process.Exited" />.</summary>
    </member>
    <member name="E:System.Diagnostics.Process.OutputDataReceived">
      <summary>Se produit quand une application écrit dans son flux <see cref="P:System.Diagnostics.Process.StandardOutput" /> redirigé.</summary>
    </member>
    <member name="P:System.Diagnostics.Process.PagedMemorySize">
      <summary>Obtient la quantité de mémoire paginée, en octets, allouée pour le processus associé.</summary>
      <returns>Quantité de mémoire, en octets, allouée par le processus associé qui peut être écrite dans le fichier d'échange de la mémoire virtuelle.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.PagedMemorySize64">
      <summary>Obtient la quantité de mémoire paginée, en octets, allouée pour le processus associé.</summary>
      <returns>Quantité de mémoire, en octets, allouée dans le fichier d'échange de la mémoire virtuelle pour le processus associé.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.PagedSystemMemorySize">
      <summary>Obtient la quantité de mémoire système paginable, en octets, allouée pour le processus associé.</summary>
      <returns>Quantité de mémoire, en octets, que le système a allouée au processus associé qui peut être écrite dans le fichier d'échange de la mémoire virtuelle.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.PagedSystemMemorySize64">
      <summary>Obtient la quantité de mémoire système paginable, en octets, allouée pour le processus associé.</summary>
      <returns>Quantité de mémoire système, en octets, allouée au processus associé qui peut être écrite dans le fichier d'échange de la mémoire virtuelle.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.PeakPagedMemorySize">
      <summary>Obtient la quantité maximale de mémoire dans le fichier d’échange de la mémoire virtuelle, en octets, utilisé par le processus associé.</summary>
      <returns>Quantité maximale de mémoire, en octets, allouée par le processus associé qui peut être écrite dans le fichier d'échange de la mémoire virtuelle.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.PeakPagedMemorySize64">
      <summary>Obtient la quantité maximale de mémoire dans le fichier d’échange de la mémoire virtuelle, en octets, utilisé par le processus associé.</summary>
      <returns>Quantité de mémoire maximale, en octets, allouée dans le fichier d'échange de la mémoire virtuelle pour le processus associé depuis son démarrage.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.PeakVirtualMemorySize">
      <summary>Obtient la quantité maximale de la mémoire virtuelle, en octets, utilisée par le processus associé.</summary>
      <returns>Quantité maximale de mémoire virtuelle, en octets, demandée par le processus associé.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.PeakVirtualMemorySize64">
      <summary>Obtient la quantité maximale de la mémoire virtuelle, en octets, utilisée par le processus associé.</summary>
      <returns>Quantité maximale de la mémoire virtuelle, en octets, allouée pour le processus associé depuis son démarrage.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.PeakWorkingSet">
      <summary>Obtient la taille maximale du jeu de travail du processus associé, en octets.</summary>
      <returns>Quantité maximale de mémoire physique requise simultanément par le processus associé, en octets.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.PeakWorkingSet64">
      <summary>Obtient la quantité maximale de mémoire physique, en octets, utilisée par le processus associé.</summary>
      <returns>Quantité maximale de la mémoire physique, en octets, allouée pour le processus associé depuis son démarrage.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.PriorityBoostEnabled">
      <summary>Obtient ou définit une valeur indiquant si la priorité du processus associée doit être temporairement renforcée par le système d'exploitation quand la fenêtre principale a le focus.</summary>
      <returns>
        <see langword="true" /> si un renforcement dynamique de la priorité du processus doit être effectué pour un processus quand il quitte l'état d'attente ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</returns>
      <exception cref="T:System.ComponentModel.Win32Exception">Nous n’avons pas pu récupérer les informations de renforcement de priorité à partir de la ressource de processus associée.</exception>
      <exception cref="T:System.PlatformNotSupportedException">L’identificateur ou le handle de processus correspond à zéro. (Le processus n’a pas été démarré.)</exception>
      <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
      <exception cref="T:System.InvalidOperationException">Le processus <see cref="P:System.Diagnostics.Process.Id" /> n’est pas disponible.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.PriorityClass">
      <summary>Obtient ou définit la catégorie de priorité générale pour le processus associé.</summary>
      <returns>Catégorie de priorité pour le processus associé, à partir de laquelle le <see cref="P:System.Diagnostics.Process.BasePriority" /> du processus est calculé.</returns>
      <exception cref="T:System.ComponentModel.Win32Exception">Impossible de définir ou de récupérer les informations de priorité des processus dans la ressource de processus associée.

ou -

L’identificateur ou le handle de processus correspond à zéro. (Le processus n’a pas été démarré.)</exception>
      <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.PriorityClass" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
      <exception cref="T:System.InvalidOperationException">Le processus <see cref="P:System.Diagnostics.Process.Id" /> n’est pas disponible.</exception>
      <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Impossible de définir la classe de priorité, car elle n’utilise pas une valeur valide, telle que définie dans l’énumération <see cref="T:System.Diagnostics.ProcessPriorityClass" />.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.PrivateMemorySize">
      <summary>Obtient la quantité de mémoire privée, en octets, allouée pour le processus associé.</summary>
      <returns>Nombre d'octets alloués par le processus associé qui ne peuvent pas être partagés avec d'autres processus.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.PrivateMemorySize64">
      <summary>Obtient la quantité de mémoire privée, en octets, allouée pour le processus associé.</summary>
      <returns>Quantité de mémoire, en octets, allouée pour le processus associé qui ne peut pas être partagé avec d'autres processus.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.PrivilegedProcessorTime">
      <summary>Obtient le temps processeur privilégié pour ce processus.</summary>
      <returns>
        <see cref="T:System.TimeSpan" /> indiquant la durée d'exécution du code par le processus à l'intérieur du noyau du système d'exploitation.</returns>
      <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.ProcessName">
      <summary>Obtient le nom du processus.</summary>
      <returns>Nom utilisé par le système pour identifier le processus à l'intention de l'utilisateur.</returns>
      <exception cref="T:System.InvalidOperationException">Le processus n’a pas d’identificateur ou aucun processus n’est associé à <see cref="T:System.Diagnostics.Process" />.

ou -
Le processus associé s’est arrêté.</exception>
      <exception cref="T:System.NotSupportedException">Le processus n’est pas sur cet ordinateur.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.ProcessorAffinity">
      <summary>Obtient ou définit les processeurs sur lesquels l'exécution des threads de ce processus peut être planifiée.</summary>
      <returns>Masque de bits représentant les processeurs sur lesquels les threads du processus associé peuvent s'exécuter. La valeur par défaut dépend du nombre de processeurs dont est équipé l'ordinateur. La valeur par défaut est 2 n -1, où n est le nombre de processeurs.</returns>
      <exception cref="T:System.ComponentModel.Win32Exception">Nous n’avons pas pu définir ou récupérer des informations <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> à partir de la ressource de processus associée.

ou -
L’identificateur ou le handle de processus correspond à zéro. (Le processus n’a pas été démarré.)</exception>
      <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
      <exception cref="T:System.InvalidOperationException">Le processus <see cref="P:System.Diagnostics.Process.Id" /> n’était pas disponible.

ou -
Le processus s’est fermé.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.Refresh">
      <summary>Ignore toute information concernant le processus associé qui a été mis en cache dans le composant du processus.</summary>
    </member>
    <member name="P:System.Diagnostics.Process.Responding">
      <summary>Obtient une valeur indiquant si l'interface utilisateur du processus répond.</summary>
      <returns>
        <see langword="true" /> si l'interface utilisateur du processus associé répond au système ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.InvalidOperationException">Aucun processus n’est associé à cet objet <see cref="T:System.Diagnostics.Process" />.</exception>
      <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.Responding" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.SafeHandle">
      <summary>Obtient le handle natif de ce processus.</summary>
      <returns>Handle natif de ce processus.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.SessionId">
      <summary>Obtient l'identificateur de session Terminal Server du processus associé.</summary>
      <returns>Identificateur de session Terminal Server du processus associé.</returns>
      <exception cref="T:System.NullReferenceException">Aucune session n’est associée à ce processus.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun processus n’est associé à cet identificateur de session.

ou -

Le processus associé n’est pas sur cet ordinateur.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.StandardError">
      <summary>Obtient un flux utilisé pour lire la sortie d'erreur de l'application.</summary>
      <returns>
        <see cref="T:System.IO.StreamReader" /> qui peut être utilisé pour lire le flux d'erreurs standard de l'application.</returns>
      <exception cref="T:System.InvalidOperationException">Le flux <see cref="P:System.Diagnostics.Process.StandardError" /> n’a pas été défini pour la redirection ; vérifiez que les propriétés <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> et <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> ont respectivement pour valeur <see langword="true" /> et <see langword="false" />.

ou -
Le flux <see cref="P:System.Diagnostics.Process.StandardError" /> a été ouvert pour des opérations de lecture asynchrones avec <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.StandardInput">
      <summary>Obtient un flux utilisé pour écrire l'entrée de l'application.</summary>
      <returns>
        <see cref="T:System.IO.StreamWriter" /> qui peut être utilisé pour écrire le flux d'entrée standard de l'application.</returns>
      <exception cref="T:System.InvalidOperationException">Le flux <see cref="P:System.Diagnostics.Process.StandardInput" /> n’a pas été défini, car <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> a la valeur <see langword="false" />.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.StandardOutput">
      <summary>Obtient un flux utilisé pour lire la sortie textuelle de l'application.</summary>
      <returns>
        <see cref="T:System.IO.StreamReader" /> qui peut être utilisé pour lire le flux de sortie standard de l'application.</returns>
      <exception cref="T:System.InvalidOperationException">Le flux <see cref="P:System.Diagnostics.Process.StandardOutput" /> n’a pas été défini pour la redirection ; vérifiez que les propriétés <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> et <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> ont respectivement pour valeur <see langword="true" /> et <see langword="false" />.

ou -
Le flux <see cref="P:System.Diagnostics.Process.StandardOutput" /> a été ouvert pour des opérations de lecture asynchrones avec <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.Start">
      <summary>Démarre (ou réutilise) la ressource de processus qui est spécifiée par la propriété <see cref="P:System.Diagnostics.Process.StartInfo" /> de ce composant <see cref="T:System.Diagnostics.Process" /> et l'associe au composant.</summary>
      <returns>
        <see langword="true" /> si une ressource de processus est démarrée ; <see langword="false" /> si aucune ressource de processus n'est démarrée (par exemple, si un processus existant est réutilisé).</returns>
      <exception cref="T:System.InvalidOperationException">Aucun nom de fichier n’a été spécifié dans le <see cref="P:System.Diagnostics.Process.StartInfo" /> du composant <see cref="T:System.Diagnostics.Process" />.

ou -

Le membre <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> de la propriété <see cref="P:System.Diagnostics.Process.StartInfo" /> est <see langword="true" /> alors que <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />ou <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> a la valeur <see langword="true" />.</exception>
      <exception cref="T:System.ComponentModel.Win32Exception">Une erreur s’est produite à l’ouverture du fichier associé.</exception>
      <exception cref="T:System.ObjectDisposedException">L’objet de processus a déjà été supprimé.</exception>
      <exception cref="T:System.PlatformNotSupportedException">Méthode non prise en charge sur les systèmes d’exploitation sans prise en charge de l’interpréteur de commandes comme Nano Server (.NET Core uniquement).</exception>
    </member>
    <member name="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)">
      <summary>Démarre la ressource de processus qui est spécifiée par le paramètre contenant les informations de démarrage du processus (par exemple, le nom de fichier du processus à démarrer) et l'associe à un nouveau composant <see cref="T:System.Diagnostics.Process" />.</summary>
      <param name="startInfo">
        <see cref="T:System.Diagnostics.ProcessStartInfo" /> qui contient les informations utilisées pour démarrer le processus, y compris le nom de fichier et d'éventuels arguments de ligne de commande.</param>
      <returns>Nouvel élément <see cref="T:System.Diagnostics.Process" /> qui est associé à la ressource de processus, ou <see langword="null" /> si aucune ressource de processus n'est démarrée. Notez qu’un nouveau processus démarré en même temps que les instances du même processus déjà en cours d’exécution est indépendant des autres. En outre, le démarrage peut retourner un processus non null avec sa propriété <see cref="P:System.Diagnostics.Process.HasExited" /> déjà définie à <see langword="true" />. Dans ce cas, le processus démarré peut avoir activé une instance existante de lui-même, puis s'être arrêté.</returns>
      <exception cref="T:System.InvalidOperationException">Aucun nom de fichier n’a été spécifié dans la propriété <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> du paramètre <paramref name="startInfo" />.

ou -
La propriété <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> du paramètre <paramref name="startInfo" /> a la valeur <see langword="true" />, et la propriété <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> ou <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> a également la valeur <see langword="true" />.

ou -
La propriété <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> du paramètre <paramref name="startInfo" /> a la valeur <see langword="true" /> et la propriété <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> n’a pas la valeur <see langword="null" /> ou est vide ou la propriété <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> n’a pas la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="startInfo" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ObjectDisposedException">L’objet de processus a déjà été supprimé.</exception>
      <exception cref="T:System.ComponentModel.Win32Exception">Une erreur s’est produite lors de l’ouverture du fichier associé.

ou -
Le fichier spécifié dans la propriété <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> du paramètre <paramref name="startInfo" /> est introuvable.

ou -
La somme de la longueur des arguments et de la longueur du chemin d’accès complet au processus dépasse 2 080. Le message d’erreur associé à cette exception peut être un des suivants : « La zone de données passée à un appel système est insuffisante. » ou « Accès refusé. »</exception>
      <exception cref="T:System.PlatformNotSupportedException">Méthode non prise en charge sur les systèmes d’exploitation sans prise en charge de l’interpréteur de commandes comme Nano Server (.NET Core uniquement).</exception>
    </member>
    <member name="M:System.Diagnostics.Process.Start(System.String)">
      <summary>Démarre une ressource de processus en spécifiant le nom d'un document ou d'un fichier d'application et l'associe à un nouveau composant <see cref="T:System.Diagnostics.Process" />.</summary>
      <param name="fileName">Nom d'un document ou d'un fichier d'application à exécuter dans le processus.</param>
      <returns>Nouvel élément <see cref="T:System.Diagnostics.Process" /> qui est associé à la ressource de processus, ou <see langword="null" /> si aucune ressource de processus n'est démarrée. Notez qu’un nouveau processus démarré en même temps que les instances du même processus déjà en cours d’exécution est indépendant des autres. En outre, le démarrage peut retourner un processus non null avec sa propriété <see cref="P:System.Diagnostics.Process.HasExited" /> déjà définie à <see langword="true" />. Dans ce cas, le processus démarré peut avoir activé une instance existante de lui-même, puis s'être arrêté.</returns>
      <exception cref="T:System.ComponentModel.Win32Exception">Une erreur s’est produite lors de l’ouverture du fichier associé.

ou -

Le fichier spécifié dans <paramref name="fileName" /> est introuvable.</exception>
      <exception cref="T:System.ObjectDisposedException">L’objet de processus a déjà été supprimé.</exception>
      <exception cref="T:System.IO.FileNotFoundException">La variable d’environnement PATH a une chaîne contenant des guillemets.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.Start(System.String,System.String)">
      <summary>Démarre une ressource de processus en spécifiant le nom d’une application et un jeu d’arguments de ligne de commande et l’associe à la ressource avec un nouveau composant <see cref="T:System.Diagnostics.Process" />.</summary>
      <param name="fileName">Nom d'un fichier d'application à exécuter dans le processus.</param>
      <param name="arguments">Arguments de ligne de commande à passer au moment du démarrage du processus.</param>
      <returns>Nouvel élément <see cref="T:System.Diagnostics.Process" /> qui est associé à la ressource de processus, ou <see langword="null" /> si aucune ressource de processus n'est démarrée. Notez qu’un nouveau processus démarré en même temps que les instances du même processus déjà en cours d’exécution est indépendant des autres. En outre, le démarrage peut retourner un processus non null avec sa propriété <see cref="P:System.Diagnostics.Process.HasExited" /> déjà définie à <see langword="true" />. Dans ce cas, le processus démarré peut avoir activé une instance existante de lui-même, puis s'être arrêté.</returns>
      <exception cref="T:System.InvalidOperationException">Le paramètre <paramref name="fileName" /> ou <paramref name="arguments" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ComponentModel.Win32Exception">Une erreur s’est produite lors de l’ouverture du fichier associé.

ou -

Le fichier spécifié dans <paramref name="fileName" /> est introuvable.

ou -
La somme de la longueur des arguments et de la longueur du chemin d’accès complet au processus dépasse 2 080. Le message d’erreur associé à cette exception peut être un des suivants : « La zone de données passée à un appel système est insuffisante. » ou « Accès refusé. »</exception>
      <exception cref="T:System.ObjectDisposedException">L’objet de processus a déjà été supprimé.</exception>
      <exception cref="T:System.IO.FileNotFoundException">La variable d’environnement PATH a une chaîne contenant des guillemets.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)">
      <summary>Démarre une ressource de processus en spécifiant le nom d'une application, un nom d'utilisateur, un mot de passe et un domaine et associe la ressource à un nouveau composant <see cref="T:System.Diagnostics.Process" />.</summary>
      <param name="fileName">Nom d'un fichier d'application à exécuter dans le processus.</param>
      <param name="userName">Nom d'utilisateur à utiliser au moment du démarrage du processus.</param>
      <param name="password">
        <see cref="T:System.Security.SecureString" /> qui contient le mot de passe à utiliser lors du démarrage du processus.</param>
      <param name="domain">Domaine à utiliser au moment du démarrage du processus.</param>
      <returns>Nouvel élément <see cref="T:System.Diagnostics.Process" /> qui est associé à la ressource de processus, ou <see langword="null" /> si aucune ressource de processus n'est démarrée. Notez qu’un nouveau processus démarré en même temps que les instances du même processus déjà en cours d’exécution est indépendant des autres. En outre, le démarrage peut retourner un processus non null avec sa propriété <see cref="P:System.Diagnostics.Process.HasExited" /> déjà définie à <see langword="true" />. Dans ce cas, le processus démarré peut avoir activé une instance existante de lui-même, puis s'être arrêté.</returns>
      <exception cref="T:System.InvalidOperationException">Aucun nom de fichier n’a été spécifié.</exception>
      <exception cref="T:System.ComponentModel.Win32Exception">Une erreur s’est produite à l’ouverture du fichier associé.

ou -

Le fichier spécifié dans <paramref name="fileName" /> est introuvable.</exception>
      <exception cref="T:System.ObjectDisposedException">L’objet de processus a déjà été supprimé.</exception>
      <exception cref="T:System.PlatformNotSupportedException">Ce membre n’est pas pris en charge sur Linux ou macOS (.NET Core uniquement).</exception>
    </member>
    <member name="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)">
      <summary>Démarre une ressource de processus en spécifiant le nom d'une application, un jeu d'arguments de ligne de commande, un nom d'utilisateur, un mot de passe et un domaine, et associe la ressource à un nouveau composant <see cref="T:System.Diagnostics.Process" />.</summary>
      <param name="fileName">Nom d'un fichier d'application à exécuter dans le processus.</param>
      <param name="arguments">Arguments de ligne de commande à passer au moment du démarrage du processus.</param>
      <param name="userName">Nom d'utilisateur à utiliser au moment du démarrage du processus.</param>
      <param name="password">
        <see cref="T:System.Security.SecureString" /> qui contient le mot de passe à utiliser lors du démarrage du processus.</param>
      <param name="domain">Domaine à utiliser au moment du démarrage du processus.</param>
      <returns>Nouvel élément <see cref="T:System.Diagnostics.Process" /> qui est associé à la ressource de processus, ou <see langword="null" /> si aucune ressource de processus n'est démarrée. Notez qu’un nouveau processus démarré en même temps que les instances du même processus déjà en cours d’exécution est indépendant des autres. En outre, le démarrage peut retourner un processus non null avec sa propriété <see cref="P:System.Diagnostics.Process.HasExited" /> déjà définie à <see langword="true" />. Dans ce cas, le processus démarré peut avoir activé une instance existante de lui-même, puis s'être arrêté.</returns>
      <exception cref="T:System.InvalidOperationException">Aucun nom de fichier n’a été spécifié.</exception>
      <exception cref="T:System.ComponentModel.Win32Exception">Une erreur s’est produite lors de l’ouverture du fichier associé.

ou -

Le fichier spécifié dans <paramref name="fileName" /> est introuvable.

ou -
La somme de la longueur des arguments et de la longueur du chemin d’accès complet au fichier associé dépasse 2080. Le message d’erreur associé à cette exception peut être un des suivants : « La zone de données passée à un appel système est insuffisante. » ou « Accès refusé. »</exception>
      <exception cref="T:System.ObjectDisposedException">L’objet de processus a déjà été supprimé.</exception>
      <exception cref="T:System.PlatformNotSupportedException">Ce membre n’est pas pris en charge sur Linux ou macOS (.NET Core uniquement).</exception>
    </member>
    <member name="P:System.Diagnostics.Process.StartInfo">
      <summary>Obtient ou définit les propriétés à passer à la méthode <see cref="M:System.Diagnostics.Process.Start" /> de <see cref="T:System.Diagnostics.Process" />.</summary>
      <returns>
        <see cref="T:System.Diagnostics.ProcessStartInfo" /> qui représente les données avec lesquelles démarrer le processus. Ces arguments comprennent le nom du fichier exécutable ou du document utilisé pour démarrer le processus.</returns>
      <exception cref="T:System.ArgumentNullException">Valeur qui spécifie que <see cref="P:System.Diagnostics.Process.StartInfo" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">La méthode <see cref="M:System.Diagnostics.Process.Start" /> n’a pas été utilisée pour démarrer le processus.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.StartTime">
      <summary>Obtient l'heure à laquelle le processus associé a démarré.</summary>
      <returns>Objet qui indique l'heure de démarrage du processus. Une exception est levée si le processus n'est pas en cours d'exécution.</returns>
      <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.StartTime" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
      <exception cref="T:System.InvalidOperationException">Le processus s’est fermé.

ou -

Le processus n’a pas été démarré.</exception>
      <exception cref="T:System.ComponentModel.Win32Exception">Une erreur s’est produite dans l’appel à la fonction Windows.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.SynchronizingObject">
      <summary>Obtient ou définit l’objet utilisé pour marshaler des appels du gestionnaire d’événements émis à la suite d’un événement de sortie de processus.</summary>
      <returns>
        <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> utilisé pour marshaler les appels du gestionnaire d'événements émis à la suite d'un événement <see cref="E:System.Diagnostics.Process.Exited" /> sur le processus.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.Threads">
      <summary>Obtient le jeu des threads en cours d'exécution dans le processus associé.</summary>
      <returns>Tableau de type <see cref="T:System.Diagnostics.ProcessThread" /> représentant les threads du système d'exploitation en cours d'exécution dans le processus associé.</returns>
      <exception cref="T:System.SystemException">Le processus n’a pas de <see cref="P:System.Diagnostics.Process.Id" />, ou aucun processus n’est associé à l’instance <see cref="T:System.Diagnostics.Process" />.

ou -
Le processus associé s’est arrêté.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.ToString">
      <summary>Met en forme le nom du processus en tant que chaîne, combinée au type de composant parent, le cas échéant.</summary>
      <returns>
        <see cref="P:System.Diagnostics.Process.ProcessName" /> combiné avec la valeur de retour <see cref="M:System.Object.ToString" /> du composant de base.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.TotalProcessorTime">
      <summary>Obtient le temps processeur total pour ce processus.</summary>
      <returns>
        <see cref="T:System.TimeSpan" /> qui indique la durée d'utilisation de l'unité centrale par le processus associé. Cette valeur est la somme de <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> et de <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />.</returns>
      <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.UserProcessorTime">
      <summary>Obtient le temps processeur utilisateur pour ce processus.</summary>
      <returns>
        <see cref="T:System.TimeSpan" /> qui indique la durée d'exécution du code par le processus associé à l'intérieur de la partie application du processus (plutôt qu'à l'intérieur du noyau du système d'exploitation).</returns>
      <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.VirtualMemorySize">
      <summary>Obtient la taille (en octets) de la mémoire virtuelle du processus.</summary>
      <returns>Quantité de mémoire virtuelle, en octets, demandée par le processus associé.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.VirtualMemorySize64">
      <summary>Obtient la quantité de mémoire virtuelle, en octets, allouée au processus associé.</summary>
      <returns>Quantité de la mémoire virtuelle, en octets, allouée pour le processus associé.</returns>
    </member>
    <member name="M:System.Diagnostics.Process.WaitForExit">
      <summary>Indique au composant <see cref="T:System.Diagnostics.Process" /> d'attendre indéfiniment que le processus associé s'arrête.</summary>
      <exception cref="T:System.ComponentModel.Win32Exception">Impossible d’accéder au paramètre wait.</exception>
      <exception cref="T:System.SystemException">Aucun processus <see cref="P:System.Diagnostics.Process.Id" /> n’a été défini, et un <see cref="P:System.Diagnostics.Process.Handle" /> à partir duquel la propriété <see cref="P:System.Diagnostics.Process.Id" /> peut être déterminée n’existe pas.

ou -
Aucun processus n’est associé à cet objet <see cref="T:System.Diagnostics.Process" /> .

ou -
Vous tentez d’appeler <see cref="M:System.Diagnostics.Process.WaitForExit" /> pour un processus en cours d’exécution sur un ordinateur distant. Cette méthode est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.WaitForExit(System.Int32)">
      <summary>Indique au composant <see cref="T:System.Diagnostics.Process" /> d'attendre le nombre de millisecondes spécifié que le processus associé s'arrête.</summary>
      <param name="milliseconds">Délai, en millisecondes, à attendre que le processus associé s'arrête. Le maximum est la plus grande valeur possible d'un entier 32 bits, qui représente l'infini pour le système d'exploitation.</param>
      <returns>
        <see langword="true" /> si le processus associé s'est arrêté ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ComponentModel.Win32Exception">Impossible d’accéder au paramètre wait.</exception>
      <exception cref="T:System.SystemException">Aucun processus <see cref="P:System.Diagnostics.Process.Id" /> n’a été défini, et un <see cref="P:System.Diagnostics.Process.Handle" /> à partir duquel la propriété <see cref="P:System.Diagnostics.Process.Id" /> peut être déterminée n’existe pas.

ou -
Aucun processus n’est associé à cet objet <see cref="T:System.Diagnostics.Process" /> .

ou -
Vous tentez d’appeler <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> pour un processus en cours d’exécution sur un ordinateur distant. Cette méthode est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="milliseconds" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.WaitForInputIdle">
      <summary>Fait en sorte que le composant <see cref="T:System.Diagnostics.Process" /> attende indéfiniment que le processus associé passe à un état inactif. Cette surcharge s'applique uniquement aux processus dotés d'une interface utilisateur et, donc, d'une boucle de message.</summary>
      <returns>
        <see langword="true" /> si le processus associé est devenu inactif.</returns>
      <exception cref="T:System.InvalidOperationException">Le processus ne dispose pas d’une interface graphique.

ou -
Une erreur inconnue s'est produite. Le processus n’est pas parvenu à entrer dans un état inactif.

ou -
Le processus est déjà terminé.

ou -
Aucun processus n’est associé à cet objet <see cref="T:System.Diagnostics.Process" />.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)">
      <summary>Fait en sorte que le composant <see cref="T:System.Diagnostics.Process" /> attende pendant le nombre spécifié de millisecondes que le processus associé passe à un état inactif. Cette surcharge s'applique uniquement aux processus dotés d'une interface utilisateur et, donc, d'une boucle de message.</summary>
      <param name="milliseconds">Une valeur de 1 à <see cref="F:System.Int32.MaxValue" /> qui spécifie la durée, en millisecondes, à attendre que le processus associé devienne inactif. Une valeur de 0 spécifie un retour immédiat et une valeur de -1 spécifie une attente infinie.</param>
      <returns>
        <see langword="true" /> si le processus associé a atteint un état inactif ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.InvalidOperationException">Le processus ne dispose pas d’une interface graphique.

ou -
Une erreur inconnue s'est produite. Le processus n’est pas parvenu à entrer dans un état inactif.

ou -
Le processus est déjà terminé.

ou -
Aucun processus n’est associé à cet objet <see cref="T:System.Diagnostics.Process" />.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.WorkingSet">
      <summary>Obtient l’utilisation de mémoire physique du processus associé, en octets.</summary>
      <returns>Quantité totale de mémoire physique utilisée par le processus associé, en octets.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.WorkingSet64">
      <summary>Obtient la quantité de mémoire physique, en octets, allouée au processus associé.</summary>
      <returns>Quantité de la mémoire physique, en octets, allouée pour le processus associé.</returns>
    </member>
    <member name="T:System.Diagnostics.ProcessModule">
      <summary>Représente un fichier .dll ou .exe chargé dans un processus particulier.</summary>
    </member>
    <member name="P:System.Diagnostics.ProcessModule.BaseAddress">
      <summary>Obtient l'adresse mémoire à laquelle le module a été chargé.</summary>
      <returns>Adresse de chargement du module.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessModule.EntryPointAddress">
      <summary>Obtient l'adresse mémoire de la fonction qui s'exécute lorsque le système charge et exécute le module.</summary>
      <returns>Point d'entrée du module.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessModule.FileName">
      <summary>Obtient le chemin d'accès complet du module.</summary>
      <returns>Chemin d'accès qualifié complet qui définit l'emplacement du module.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessModule.FileVersionInfo">
      <summary>Obtient des informations sur la version relatives au module.</summary>
      <returns>
        <see cref="T:System.Diagnostics.FileVersionInfo" /> qui contient les informations sur la version relatives au module.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessModule.ModuleMemorySize">
      <summary>Obtient la quantité de mémoire nécessaire au chargement du module.</summary>
      <returns>Taille en octets de la mémoire utilisée par le module.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessModule.ModuleName">
      <summary>Obtient le nom du module de processus.</summary>
      <returns>Nom du module.</returns>
    </member>
    <member name="M:System.Diagnostics.ProcessModule.ToString">
      <summary>Convertit le nom du module en chaîne.</summary>
      <returns>La valeur de la propriété <see cref="P:System.Diagnostics.ProcessModule.ModuleName" />.</returns>
    </member>
    <member name="T:System.Diagnostics.ProcessModuleCollection">
      <summary>Fournit une collection fortement typée d’objets <see cref="T:System.Diagnostics.ProcessModule" />.</summary>
    </member>
    <member name="M:System.Diagnostics.ProcessModuleCollection.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Diagnostics.ProcessModuleCollection" /> sans instances <see cref="T:System.Diagnostics.ProcessModule" /> associées.</summary>
    </member>
    <member name="M:System.Diagnostics.ProcessModuleCollection.#ctor(System.Diagnostics.ProcessModule[])">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Diagnostics.ProcessModuleCollection" />, à l’aide du tableau spécifié des instances <see cref="T:System.Diagnostics.ProcessModule" />.</summary>
      <param name="processModules">Tableau d’instances <see cref="T:System.Diagnostics.ProcessModule" /> avec lequel initialiser cette instance <see cref="T:System.Diagnostics.ProcessModuleCollection" />.</param>
    </member>
    <member name="M:System.Diagnostics.ProcessModuleCollection.Contains(System.Diagnostics.ProcessModule)">
      <summary>Détermine si le module de processus spécifié existe dans la collection.</summary>
      <param name="module">Instance <see cref="T:System.Diagnostics.ProcessModule" /> qui indique le module à rechercher dans cette collection.</param>
      <returns>
        <see langword="true" /> si le module existe dans la collection ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Diagnostics.ProcessModuleCollection.CopyTo(System.Diagnostics.ProcessModule[],System.Int32)">
      <summary>Copie un tableau d’instances <see cref="T:System.Diagnostics.ProcessModule" /> dans la collection, à l’index spécifié.</summary>
      <param name="array">Tableau d’instances <see cref="T:System.Diagnostics.ProcessModule" /> à ajouter à la collection.</param>
      <param name="index">Emplacement auquel ajouter les nouvelles instances.</param>
    </member>
    <member name="M:System.Diagnostics.ProcessModuleCollection.IndexOf(System.Diagnostics.ProcessModule)">
      <summary>Fournit l’emplacement d’un module spécifié au sein de la collection.</summary>
      <param name="module">
        <see cref="T:System.Diagnostics.ProcessModule" /> dont l’index est récupéré.</param>
      <returns>Index de base zéro qui définit l’emplacement du module au sein de <see cref="T:System.Diagnostics.ProcessModuleCollection" />.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessModuleCollection.Item(System.Int32)">
      <summary>Obtient un index pour itérer sur le jeu de modules de processus.</summary>
      <param name="index">Valeur d’index de base zéro du module dans la collection.</param>
      <returns>
        <see cref="T:System.Diagnostics.ProcessModule" /> qui indexe les modules dans la collection</returns>
    </member>
    <member name="T:System.Diagnostics.ProcessPriorityClass">
      <summary>Indique la priorité associée par le système à un processus. Cette valeur, ainsi que la valeur de priorité de chaque thread du processus, déterminent le niveau de priorité de base de chaque thread.</summary>
    </member>
    <member name="F:System.Diagnostics.ProcessPriorityClass.AboveNormal">
      <summary>Spécifie que la priorité du processus est supérieure à <see langword="Normal" /> mais inférieure à <see langword="High" />.</summary>
    </member>
    <member name="F:System.Diagnostics.ProcessPriorityClass.BelowNormal">
      <summary>Spécifie que le processus a une priorité supérieure à <see langword="Idle" />, mais inférieure à <see langword="Normal" />.</summary>
    </member>
    <member name="F:System.Diagnostics.ProcessPriorityClass.High">
      <summary>Spécifie que le processus effectue des tâches en temps critique qui doivent être exécutées immédiatement, telles que la boîte de dialogue <see langword="Task List" /> qui doit répondre rapidement lorsqu'elle est appelée par l'utilisateur, peu importe la charge du système d'exploitation. Les threads du processus prévalent sur les threads de processus de classe de priorités normale ou inactive. Soyez extrêmement prudent lorsque vous spécifiez <see langword="High" /> pour la classe de priorité du processus, car une application de classe à priorité élevée peut utiliser presque tout le temps processeur disponible.</summary>
    </member>
    <member name="F:System.Diagnostics.ProcessPriorityClass.Idle">
      <summary>Spécifie que les threads de ce processus ne s'exécutent que si le système est inactif, par exemple un écran de veille. Les threads de tout processus s'exécutant dans une classe de priorités supérieure prévalent sur les threads du processus. Cette classe de priorité est héritée par les processus enfants.</summary>
    </member>
    <member name="F:System.Diagnostics.ProcessPriorityClass.Normal">
      <summary>Spécifie que le processus ne possède aucune exigence de planification spéciale.</summary>
    </member>
    <member name="F:System.Diagnostics.ProcessPriorityClass.RealTime">
      <summary>Spécifie que le processus possède la priorité la plus élevée. Les threads d'un processus à priorité <see langword="RealTime" /> prévalent sur les threads de tous les autres processus, y compris les processus du système d'exploitation exécutant des tâches importantes. Ainsi, un processus à priorité <see langword="RealTime" /> dont l'exécution se prolonge au-delà d'un bref intervalle peut empêcher le cache disque de se vider ou nuire au bon fonctionnement de la souris.</summary>
    </member>
    <member name="T:System.Diagnostics.ProcessStartInfo">
      <summary>Spécifie un jeu de valeurs utilisées lors du démarrage d'un processus.</summary>
    </member>
    <member name="M:System.Diagnostics.ProcessStartInfo.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Diagnostics.ProcessStartInfo" /> sans spécifier le nom de fichier avec lequel démarrer le processus.</summary>
    </member>
    <member name="M:System.Diagnostics.ProcessStartInfo.#ctor(System.String)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Diagnostics.ProcessStartInfo" /> et spécifie un nom de fichier (d'une application ou d'un document, par exemple) avec lequel démarrer le processus.</summary>
      <param name="fileName">Application ou document avec lequel démarrer un processus.</param>
    </member>
    <member name="M:System.Diagnostics.ProcessStartInfo.#ctor(System.String,System.String)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Diagnostics.ProcessStartInfo" /> et spécifie un nom de fichier d’application avec lequel démarrer le processus, ainsi qu’un jeu d’arguments de ligne de commande à passer à l’application.</summary>
      <param name="fileName">Application avec laquelle démarrer un processus.</param>
      <param name="arguments">Arguments de ligne de commande à passer à l’application lors du démarrage du processus.</param>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.ArgumentList">
      <summary>Obtient une collection d'arguments de ligne de commande à utiliser lors du démarrage de l'application.</summary>
      <returns>Collection d’arguments de ligne de commande.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.Arguments">
      <summary>Obtient ou définit le jeu d’arguments de ligne de commande à utiliser lors du démarrage de l’application.</summary>
      <returns>Chaîne unique contenant les arguments à passer à l'application cible spécifiée dans la propriété <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />. La valeur par défaut est une chaîne vide ("").</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.CreateNoWindow">
      <summary>Obtient ou définit une valeur indiquant si le processus doit démarrer dans une nouvelle fenêtre.</summary>
      <returns>
        <see langword="true" /> si le processus doit être démarré sans créer de nouvelle fenêtre pour le contenir ; Sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.Domain">
      <summary>Obtient ou définit une valeur qui identifie le domaine à utiliser lors du démarrage du processus. Si cette valeur est <see langword="null" />, la propriété <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> doit être spécifiée au format UPN.</summary>
      <returns>Domaine Active Directory à utiliser lors du démarrage du processus. Si cette valeur est <see langword="null" />, la propriété <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> doit être spécifiée au format UPN.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.Environment">
      <summary>Obtient les variables d’environnement qui s’appliquent à ce processus et à ses processus enfants.</summary>
      <returns>Dictionnaire générique contenant les variables d’environnement qui s’appliquent à ce processus et à ses processus enfants. La valeur par défaut est <see langword="null" />.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.EnvironmentVariables">
      <summary>Obtient les chemins de recherche de fichiers, les répertoires de fichiers temporaires, les options propres à l'application et d'autres informations similaires.</summary>
      <returns>Dictionnaire de chaînes qui fournit les variables d'environnement qui s'appliquent à ce processus et aux processus enfants. La valeur par défaut est <see langword="null" />.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.ErrorDialog">
      <summary>Obtient ou définit une valeur indiquant si une boîte de dialogue d'erreur est affichée pour l'utilisateur si le processus ne peut pas démarrer.</summary>
      <returns>
        <see langword="true" /> si une boîte de dialogue d’erreur doit s’afficher à l’écran si le processus ne peut pas être démarré ; Sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle">
      <summary>Obtient ou définit le handle de fenêtre à utiliser lorsqu'une boîte de dialogue d'erreur s'affiche pour un processus qui ne peut pas démarrer.</summary>
      <returns>Pointeur vers le handle de la boîte de dialogue d'erreur qui s'affiche à la suite d'un échec de démarrage d'un processus.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.FileName">
      <summary>Obtient ou définit l'application ou le document à démarrer.</summary>
      <returns>Nom de l'application à démarrer, ou nom d'un document d'un type de fichier associé à une application et disposant d'une action d'ouverture par défaut. La valeur par défaut est une chaîne vide ("").</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.LoadUserProfile">
      <summary>Obtient ou définit une valeur qui indique si le profil utilisateur Windows doit être chargé à partir du Registre.</summary>
      <returns>
        <see langword="true" /> si le profil utilisateur Windows doit être chargé ; Sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.Password">
      <summary>Obtient ou définit une chaîne sécurisée contenant le mot de passe de l'utilisateur à utiliser lors du démarrage du processus.</summary>
      <returns>Mot de passe utilisateur à utiliser lors du démarrage du processus.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.PasswordInClearText">
      <summary>Obtient ou définit le mot de passe utilisateur en texte clair à utiliser lors du démarrage du processus.</summary>
      <returns>Mot de passe utilisateur en texte clair.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError">
      <summary>Obtient ou définit une valeur qui indique si la sortie d'erreur d'une application est écrite dans le flux <see cref="P:System.Diagnostics.Process.StandardError" />.</summary>
      <returns>
        <see langword="true" /> si la sortie d’erreur doit être écrite dans <see cref="P:System.Diagnostics.Process.StandardError" />; Sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput">
      <summary>Obtient ou définit une valeur qui indique si l'entrée pour une application est lue à partir du flux <see cref="P:System.Diagnostics.Process.StandardInput" />.</summary>
      <returns>
        <see langword="true" /> si l'entrée est lue depuis <see cref="P:System.Diagnostics.Process.StandardInput" /> ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput">
      <summary>Obtient ou définit une valeur qui indique si la sortie textuelle d’une application est écrite dans le flux <see cref="P:System.Diagnostics.Process.StandardOutput" />.</summary>
      <returns>
        <see langword="true" /> si la sortie doit être écrite dans <see cref="P:System.Diagnostics.Process.StandardOutput" /> ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.StandardErrorEncoding">
      <summary>Obtient ou définit l'encodage recommandé pour la sortie d'erreur.</summary>
      <returns>Objet qui représente l'encodage recommandé pour la sortie d'erreur. La valeur par défaut est <see langword="null" />.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.StandardInputEncoding">
      <summary>Obtient ou définit l'encodage recommandé pour l’entrée standard.</summary>
      <returns>Objet qui représente l’encodage recommandé pour l’entrée standard. La valeur par défaut est <see langword="null" />.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.StandardOutputEncoding">
      <summary>Obtient ou définit l'encodage recommandé pour la sortie standard.</summary>
      <returns>Objet qui représente l'encodage recommandé pour la sortie standard. La valeur par défaut est <see langword="null" />.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.UserName">
      <summary>Obtient ou définit le nom d’utilisateur à utiliser au démarrage du processus. Si vous utilisez le format UPN, <paramref name="user" />@<paramref name="DNS_domain_name" />, la propriété <see cref="P:System.Diagnostics.ProcessStartInfo.Domain" /> doit avoir pour valeur <see langword="null" />.</summary>
      <returns>Nom d'utilisateur à utiliser au moment du démarrage du processus. Si vous utilisez le format UPN, <paramref name="user" />@<paramref name="DNS_domain_name" />, la propriété <see cref="P:System.Diagnostics.ProcessStartInfo.Domain" /> doit avoir pour valeur <see langword="null" />.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.UseShellExecute">
      <summary>Obtient ou définit une valeur indiquant si le shell du système d'exploitation doit être utilisé pour démarrer le processus.</summary>
      <returns>
        <see langword="true" /> si le shell doit être utilisé lors du démarrage du processus ; <see langword="false" /> si le processus doit être créé directement à partir du fichier exécutable. La valeur par défaut est <see langword="true" /> sur les applications .NET Framework et les <see langword="false" /> sur les applications .NET Core.</returns>
      <exception cref="T:System.PlatformNotSupportedException">Une tentative de définir la valeur sur <see langword="true" /> sur les applications UWP (plateforme Windows universelle) se produit.</exception>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.Verb">
      <summary>Obtient ou définit le verbe à utiliser lors de l'ouverture de l'application ou du document spécifié par la propriété <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />.</summary>
      <returns>Action à effectuer avec le fichier ouvert par le processus. La valeur par défaut est une chaîne vide (""), ce qui signifie aucune action.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.Verbs">
      <summary>Obtient l'ensemble de verbes associé au type de fichier spécifié par la propriété <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />.</summary>
      <returns>Actions pouvant être appliquées par le système au fichier indiqué par la propriété <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.WindowStyle">
      <summary>Obtient ou définit l'état de la fenêtre à utiliser lors du démarrage du processus.</summary>
      <returns>Une des valeurs d'énumération indiquant si le processus est démarré dans une fenêtre agrandie, réduite ou normale (ni agrandie, ni réduite), ou encore s'il est invisible. La valeur par défaut est <see langword="Normal" />.</returns>
      <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Le style de fenêtre ne fait pas partie des membres de l’énumération <see cref="T:System.Diagnostics.ProcessWindowStyle" />.</exception>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.WorkingDirectory">
      <summary>Lorsque la propriété <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> est <see langword="false" />, obtient ou définit le répertoire de travail du processus à démarrer. Lorsque <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> est <see langword="true" />, obtient ou définit le répertoire qui contient le processus à démarrer.</summary>
      <returns>Lorsque <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> est <see langword="true" />, nom qualifié complet du répertoire qui contient le processus à démarrer. Lorsque la propriété <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> est <see langword="false" />, répertoire de travail du processus à démarrer. La valeur par défaut est une chaîne vide ("").</returns>
    </member>
    <member name="T:System.Diagnostics.ProcessThread">
      <summary>Représente un thread de processus du système d'exploitation.</summary>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.BasePriority">
      <summary>Obtient la priorité de base du thread.</summary>
      <returns>Priorité de base du thread, calculée par le système d'exploitation en combinant la classe de priorité du processus avec le niveau de priorité du thread associé.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.CurrentPriority">
      <summary>Obtient la priorité actuelle du thread.</summary>
      <returns>Priorité actuelle du thread, qui peut être différente de la priorité de base, selon la manière dont le système d'exploitation planifie le thread. La priorité peut être renforcée temporairement pour un thread actif.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.Id">
      <summary>Obtient l'identificateur unique du thread.</summary>
      <returns>Identificateur unique associé à un thread spécifique.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.IdealProcessor">
      <summary>Définit le processeur par défaut sur lequel exécuter ce thread.</summary>
      <returns>Processeur par défaut pour le thread, utilisé lorsque le système planifie des threads, afin de déterminer le processeur sur lequel exécuter le thread.</returns>
      <exception cref="T:System.ComponentModel.Win32Exception">Le système n'a pas pu définir le thread pour qu'il démarre sur le processeur spécifié.</exception>
      <exception cref="T:System.NotSupportedException">Le processus se trouve sur un ordinateur distant.</exception>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled">
      <summary>Obtient ou définit une valeur indiquant si le système d'exploitation doit renforcer temporairement la priorité du thread qui lui est associé chaque fois que la fenêtre principale du processus du thread reçoit le focus.</summary>
      <returns>
        <see langword="true" /> pour renforcer la priorité du thread en cas d'interaction de l'utilisateur avec l'interface du processus ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</returns>
      <exception cref="T:System.ComponentModel.Win32Exception">Les informations sur le renforcement de la priorité n'ont pas pu être récupérées.

ou -

Les informations sur le renforcement de la priorité n'ont pas pu être définies.</exception>
      <exception cref="T:System.NotSupportedException">Le processus se trouve sur un ordinateur distant.</exception>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.PriorityLevel">
      <summary>Obtient ou définit le niveau de priorité du thread.</summary>
      <returns>Une des valeurs <see cref="T:System.Diagnostics.ThreadPriorityLevel" /> spécifiant une plage qui limite la priorité du thread.</returns>
      <exception cref="T:System.ComponentModel.Win32Exception">Les informations sur le renforcement de la priorité du thread n'ont pas pu être récupérées.

ou -

Le niveau de priorité du thread n'a pas pu être défini.</exception>
      <exception cref="T:System.NotSupportedException">Le processus se trouve sur un ordinateur distant.</exception>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime">
      <summary>Obtient la durée d'exécution du code par le thread à l'intérieur du noyau du système d'exploitation.</summary>
      <returns>
        <see cref="T:System.TimeSpan" /> indiquant la durée d'exécution du code par le thread à l'intérieur du noyau du système d'exploitation.</returns>
      <exception cref="T:System.ComponentModel.Win32Exception">La durée du thread n'a pas pu être récupérée.</exception>
      <exception cref="T:System.NotSupportedException">Le processus se trouve sur un ordinateur distant.</exception>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.ProcessorAffinity">
      <summary>Définit les processeurs sur lesquels le thread associé peut s'exécuter.</summary>
      <returns>
        <see cref="T:System.IntPtr" /> désignant un jeu de bits, chacun d'eux représentant un processeur sur lequel le thread peut s'exécuter.</returns>
      <exception cref="T:System.ComponentModel.Win32Exception">L'affinité du processeur n'a pas pu être définie.</exception>
      <exception cref="T:System.NotSupportedException">Le processus se trouve sur un ordinateur distant.</exception>
    </member>
    <member name="M:System.Diagnostics.ProcessThread.ResetIdealProcessor">
      <summary>Réinitialise le processeur idéal pour ce thread afin d'indiquer qu'il n'existe aucun processeur idéal. En d'autres termes, cela signifie que tous les processeurs sont idéaux.</summary>
      <exception cref="T:System.ComponentModel.Win32Exception">Le processeur idéal n'a pas pu être réinitialisé.</exception>
      <exception cref="T:System.NotSupportedException">Le processus se trouve sur un ordinateur distant.</exception>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.StartAddress">
      <summary>Obtient l'adresse mémoire de la fonction appelée par le système d'exploitation qui a démarré ce thread.</summary>
      <returns>Adresse de départ du thread, qui désigne la fonction définie par l'application exécutée par le thread.</returns>
      <exception cref="T:System.NotSupportedException">Le processus se trouve sur un ordinateur distant.</exception>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.StartTime">
      <summary>Obtient l'heure à laquelle le système d'exploitation a démarré le thread.</summary>
      <returns>
        <see cref="T:System.DateTime" /> représentant l'heure du système au moment où le système d'exploitation a démarré le thread.</returns>
      <exception cref="T:System.ComponentModel.Win32Exception">La durée du thread n'a pas pu être récupérée.</exception>
      <exception cref="T:System.NotSupportedException">Le processus se trouve sur un ordinateur distant.</exception>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.ThreadState">
      <summary>Obtient l'état actuel de ce thread.</summary>
      <returns>
        <see cref="T:System.Diagnostics.ThreadState" /> indiquant l'exécution du thread (par exemple, s'il est en cours d'exécution, en attente ou terminé).</returns>
      <exception cref="T:System.NotSupportedException">Le processus se trouve sur un ordinateur distant.</exception>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.TotalProcessorTime">
      <summary>Obtient la durée totale d'utilisation du processeur par ce thread.</summary>
      <returns>
        <see cref="T:System.TimeSpan" /> indiquant la durée pendant laquelle le thread contrôlait le processeur.</returns>
      <exception cref="T:System.ComponentModel.Win32Exception">La durée du thread n'a pas pu être récupérée.</exception>
      <exception cref="T:System.NotSupportedException">Le processus se trouve sur un ordinateur distant.</exception>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.UserProcessorTime">
      <summary>Obtient la durée d'exécution du code par le thread associé au sein de l'application.</summary>
      <returns>
        <see cref="T:System.TimeSpan" /> indiquant la durée d'exécution du code par le thread à l'intérieur de l'application, et non à l'intérieur du noyau du système d'exploitation.</returns>
      <exception cref="T:System.ComponentModel.Win32Exception">La durée du thread n'a pas pu être récupérée.</exception>
      <exception cref="T:System.NotSupportedException">Le processus se trouve sur un ordinateur distant.</exception>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.WaitReason">
      <summary>Obtient la raison pour laquelle le thread est en attente.</summary>
      <returns>
        <see cref="T:System.Diagnostics.ThreadWaitReason" /> représentant la raison pour laquelle le thread est en état d'attente.</returns>
      <exception cref="T:System.InvalidOperationException">Le thread n'est pas en état d'attente.</exception>
      <exception cref="T:System.NotSupportedException">Le processus se trouve sur un ordinateur distant.</exception>
    </member>
    <member name="T:System.Diagnostics.ProcessThreadCollection">
      <summary>Fournit une collection fortement typée d’objets <see cref="T:System.Diagnostics.ProcessThread" />.</summary>
    </member>
    <member name="M:System.Diagnostics.ProcessThreadCollection.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Diagnostics.ProcessThreadCollection" /> sans instances <see cref="T:System.Diagnostics.ProcessThread" /> associées.</summary>
    </member>
    <member name="M:System.Diagnostics.ProcessThreadCollection.#ctor(System.Diagnostics.ProcessThread[])">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Diagnostics.ProcessThreadCollection" /> à l'aide du tableau spécifié d'instances de <see cref="T:System.Diagnostics.ProcessThread" />.</summary>
      <param name="processThreads">Tableau d'instances de <see cref="T:System.Diagnostics.ProcessThread" /> avec lequel initialiser cette instance de <see cref="T:System.Diagnostics.ProcessThreadCollection" />.</param>
    </member>
    <member name="M:System.Diagnostics.ProcessThreadCollection.Add(System.Diagnostics.ProcessThread)">
      <summary>Ajoute un thread de processus à la collection.</summary>
      <param name="thread">Thread à ajouter à la collection.</param>
      <returns>Index de base zéro du thread dans la collection.</returns>
    </member>
    <member name="M:System.Diagnostics.ProcessThreadCollection.Contains(System.Diagnostics.ProcessThread)">
      <summary>Détermine si le thread de processus spécifié existe dans la collection.</summary>
      <param name="thread">Instance de <see cref="T:System.Diagnostics.ProcessThread" /> qui indique le thread à rechercher dans cette collection.</param>
      <returns>
        <see langword="true" /> si le thread existe dans la collection ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Diagnostics.ProcessThreadCollection.CopyTo(System.Diagnostics.ProcessThread[],System.Int32)">
      <summary>Copie un tableau d'instances de <see cref="T:System.Diagnostics.ProcessThread" /> vers la collection, à l'index spécifié.</summary>
      <param name="array">Tableau d'instances de <see cref="T:System.Diagnostics.ProcessThread" /> à ajouter à la collection.</param>
      <param name="index">Emplacement auquel ajouter les nouvelles instances.</param>
    </member>
    <member name="M:System.Diagnostics.ProcessThreadCollection.IndexOf(System.Diagnostics.ProcessThread)">
      <summary>Fournit l'emplacement d'un thread spécifié dans la collection.</summary>
      <param name="thread">
        <see cref="T:System.Diagnostics.ProcessThread" /> dont l'index est récupéré.</param>
      <returns>Index de base zéro qui définit l'emplacement du thread dans <see cref="T:System.Diagnostics.ProcessThreadCollection" />.</returns>
    </member>
    <member name="M:System.Diagnostics.ProcessThreadCollection.Insert(System.Int32,System.Diagnostics.ProcessThread)">
      <summary>Insère un thread de processus à l'emplacement spécifié dans la collection.</summary>
      <param name="index">Index de base zéro indiquant l'emplacement dans lequel insérer le thread.</param>
      <param name="thread">Thread à insérer dans la collection.</param>
    </member>
    <member name="P:System.Diagnostics.ProcessThreadCollection.Item(System.Int32)">
      <summary>Obtient un index pour itérer au sein du jeu de threads de processus.</summary>
      <param name="index">Valeur d'index de base zéro du thread dans la collection.</param>
      <returns>
        <see cref="T:System.Diagnostics.ProcessThread" /> qui indexe les threads dans la collection.</returns>
    </member>
    <member name="M:System.Diagnostics.ProcessThreadCollection.Remove(System.Diagnostics.ProcessThread)">
      <summary>Supprime de la collection un thread de processus.</summary>
      <param name="thread">Thread à supprimer de la collection.</param>
    </member>
    <member name="T:System.Diagnostics.ProcessWindowStyle">
      <summary>Spécifie la manière dont une nouvelle fenêtre doit s'afficher lorsque le système démarre un processus.</summary>
    </member>
    <member name="F:System.Diagnostics.ProcessWindowStyle.Hidden">
      <summary>Style de fenêtre masquée. Une fenêtre peut être soit visible, soit masquée. Le système affiche une fenêtre masquée, mais pas en la dessinant. Si une fenêtre est masquée, elle est en réalité désactivée. Une fenêtre masquée peut traiter des messages du système ou d'autres fenêtres, mais ne peut pas traiter d'entrée utilisateur ou afficher une sortie. Il arrive fréquemment qu'une application laisse une nouvelle fenêtre masquée pendant qu'elle personnalise son aspect, puis qu'elle lui affecte le style <see cref="F:System.Diagnostics.ProcessWindowStyle.Normal" />. Pour utiliser <see cref="F:System.Diagnostics.ProcessWindowStyle.Hidden" />, la propriété <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> doit être <see langword="true" />.</summary>
    </member>
    <member name="F:System.Diagnostics.ProcessWindowStyle.Maximized">
      <summary>Style de fenêtre agrandie. Par défaut, le système élargit une fenêtre agrandie afin qu'elle remplisse l'écran ou la zone cliente d'une fenêtre parente, s'il s'agit d'une fenêtre enfant. Si la fenêtre possède une barre de titre, le système la déplace automatiquement vers le haut de l'écran ou vers le haut de la zone cliente de la fenêtre parente. En outre, le système désactive la bordure de dimensionnement de la fenêtre et la possibilité de positionnement de la fenêtre à l'aide de la barre de titre de sorte que l'utilisateur ne puisse pas déplacer la fenêtre en faisant glisser la barre de titre.</summary>
    </member>
    <member name="F:System.Diagnostics.ProcessWindowStyle.Minimized">
      <summary>Style de fenêtre réduite. Par défaut, le système diminue une fenêtre réduite jusqu'à la taille de son bouton dans la barre des tâches et la déplace vers la barre des tâches.</summary>
    </member>
    <member name="F:System.Diagnostics.ProcessWindowStyle.Normal">
      <summary>Style de fenêtre normale visible. Le système affiche une fenêtre de style <see cref="F:System.Diagnostics.ProcessWindowStyle.Normal" /> à un emplacement par défaut. Si une fenêtre est visible, l'utilisateur peut lui fournir des entrées dont elle affiche la sortie. Il arrive fréquemment qu'une application affecte à une nouvelle fenêtre le style <see cref="F:System.Diagnostics.ProcessWindowStyle.Hidden" /> pendant qu'elle personnalise son aspect, puis qu'elle lui affecte le style <see cref="F:System.Diagnostics.ProcessWindowStyle.Normal" />.</summary>
    </member>
    <member name="T:System.Diagnostics.ThreadPriorityLevel">
      <summary>Spécifie le niveau de priorité d'un thread.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadPriorityLevel.AboveNormal">
      <summary>Spécifie un niveau au-dessus de la priorité normale pour le <see cref="T:System.Diagnostics.ProcessPriorityClass" /> associé.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadPriorityLevel.BelowNormal">
      <summary>Spécifie un niveau en dessous de la priorité normale pour le <see cref="T:System.Diagnostics.ProcessPriorityClass" /> associé.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadPriorityLevel.Highest">
      <summary>Spécifie la priorité la plus élevée. Elle se situe deux niveaux au-dessus de la priorité normale pour le <see cref="T:System.Diagnostics.ProcessPriorityClass" /> associé.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadPriorityLevel.Idle">
      <summary>Spécifie la priorité du type inactif. Il s'agit de la plus basse priorité possible de tous les threads, indépendante de la valeur du <see cref="T:System.Diagnostics.ProcessPriorityClass" /> associé.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadPriorityLevel.Lowest">
      <summary>Spécifie la priorité la plus basse. Elle se situe deux niveaux en dessous de la priorité normale pour le <see cref="T:System.Diagnostics.ProcessPriorityClass" /> associé.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadPriorityLevel.Normal">
      <summary>Spécifie la priorité normale pour le <see cref="T:System.Diagnostics.ProcessPriorityClass" /> associé.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadPriorityLevel.TimeCritical">
      <summary>Spécifie la priorité critique. Il s'agit de la priorité la plus élevée de tous les threads, indépendante de la valeur du <see cref="T:System.Diagnostics.ProcessPriorityClass" /> associé.</summary>
    </member>
    <member name="T:System.Diagnostics.ThreadState">
      <summary>Spécifie l'état d'exécution actuel du thread.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadState.Initialized">
      <summary>État qui indique que le thread a été initialisé, mais n'a pas encore démarré.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadState.Ready">
      <summary>État qui indique que le thread attend de pouvoir utiliser un processeur, car aucun processeur n'est libre. Le thread est prêt à s'exécuter sur le prochain processeur disponible.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadState.Running">
      <summary>État qui indique que le thread utilise actuellement un processeur.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadState.Standby">
      <summary>État qui indique que le thread est sur le point d'utiliser un processeur. Un seul thread peut être dans cet état à la fois.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadState.Terminated">
      <summary>État qui indique que le thread a terminé de s'exécuter et s'est fermé.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadState.Transition">
      <summary>État qui indique que le thread attend une ressource autre que le processeur avant de pouvoir s'exécuter. Par exemple, il peut attendre que sa pile d'exécution soit paginée à partir du disque.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadState.Unknown">
      <summary>L'état du thread est inconnu.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadState.Wait">
      <summary>État qui indique que le thread n'est pas prêt à utiliser le processeur, car il attend la fin d'une opération de périphérique ou la libération d'une ressource. Lorsque le thread est prêt, il est replanifié.</summary>
    </member>
    <member name="T:System.Diagnostics.ThreadWaitReason">
      <summary>Spécifie la raison pour laquelle un thread attend.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.EventPairHigh">
      <summary>Le thread attend une paire d'événements haute.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.EventPairLow">
      <summary>Le thread attend une paire d'événements basse.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.ExecutionDelay">
      <summary>L'exécution du thread est différée.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.Executive">
      <summary>Le thread attend le planificateur.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.FreePage">
      <summary>Le thread attend une page de mémoire virtuelle libre.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.LpcReceive">
      <summary>Le thread attend l'arrivée d'un appel de procédure local.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.LpcReply">
      <summary>Le thread attend l'arrivée d'une réponse à un appel de procédure local.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.PageIn">
      <summary>Le thread attend l'arrivée d'une page de mémoire virtuelle en mémoire.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.PageOut">
      <summary>Le thread attend l'écriture d'une page de mémoire virtuelle sur le disque.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.Suspended">
      <summary>L'exécution du thread est interrompue.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.SystemAllocation">
      <summary>Le thread attend une allocation système.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.Unknown">
      <summary>Le thread attend pour une raison inconnue.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.UserRequest">
      <summary>Le thread attend une demande utilisateur.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.VirtualMemory">
      <summary>Le thread attend que le système alloue de la mémoire virtuelle.</summary>
    </member>
  </members>
</doc>