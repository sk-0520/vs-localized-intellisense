<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Reflection.Emit</name>
  </assembly>
  <members>
    <member name="T:System.Reflection.Emit.AssemblyBuilder">
      <summary>Définit et représente un assembly dynamique.</summary>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.CodeBase">
      <summary>Obtient l’emplacement de l’assembly, telle que spécifié à l’origine (par exemple dans un objet <see cref="T:System.Reflection.AssemblyName" />).</summary>
      <returns>Emplacement de l’assembly, tel que spécifié à l’origine.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge pour l’instant.</exception>
      <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
      <summary>Définit un assembly dynamique avec le nom et les droits d'accès spécifiés.</summary>
      <param name="name">Nom de l'assembly.</param>
      <param name="access">Droits d’accès de l’assembly.</param>
      <returns>Objet qui représente le nouvel assembly.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
      <summary>Définit un nouvel assembly avec le nom, les droits d'accès et les attributs spécifiés.</summary>
      <param name="name">Nom de l'assembly.</param>
      <param name="access">Droits d'accès de l'assembly.</param>
      <param name="assemblyAttributes">Collection qui contient les attributs de l'assembly.</param>
      <returns>Objet qui représente le nouvel assembly.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
      <summary>Définit un module dynamique transitoire nommé dans cet assembly.</summary>
      <param name="name">Nom du module dynamique.</param>
      <returns>
        <see cref="T:System.Reflection.Emit.ModuleBuilder" /> représentant le module dynamique défini.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> commence par un espace blanc.

ou -
La longueur de <paramref name="name" /> est égale à zéro.

ou -
La longueur de <paramref name="name" /> est supérieure à la longueur maximale définie par le système.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> est <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
      <exception cref="T:System.ExecutionEngineException">L’assembly pour le writer de symbole par défaut ne peut pas être chargé.

ou -

Le type qui implémente l’interface du writer de symbole par défaut est introuvable.</exception>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.EntryPoint">
      <summary>Retourne le point d'entrée de cet assembly.</summary>
      <returns>Point d'entrée de cet assembly.</returns>
      <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.Equals(System.Object)">
      <summary>Retourne une valeur qui indique si cette instance équivaut à l’objet spécifié.</summary>
      <param name="obj">Objet à comparer à cette instance ou <see langword="null" />.</param>
      <returns>
        <see langword="true" /> si <paramref name="obj" /> est égal au type et à la valeur de cette instance ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.FullName">
      <summary>Obtient le nom complet de l'assembly dynamique actuel.</summary>
      <returns>Nom d’affichage de l’assembly dynamique.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Retourne tous les attributs personnalisés qui ont été appliqués au <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> actuel.</summary>
      <param name="inherit">Cet argument est ignoré pour les objets de ce type.</param>
      <returns>Un tableau qui contient les attributs personnalisés ; le tableau est vide s’il n’existe pas d’attributs.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Retourne tous les attributs personnalisés qui ont été appliqués à l’élément <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> actuel et qui dérivent d’un type d’attribut spécifié.</summary>
      <param name="attributeType">Type de base duquel dérivent des attributs.</param>
      <param name="inherit">Cet argument est ignoré pour les objets de ce type.</param>
      <returns>Tableau qui contient les attributs personnalisés dérivés à tous les niveaux de <paramref name="attributeType" /> ; le tableau est vide si de tels attributs n'existent pas.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributeType" /> n’est pas un objet <see cref="T:System.Type" /> fourni par le runtime. Par exemple, <paramref name="attributeType" /> est un objet <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributesData">
      <summary>Retourne des objets <see cref="T:System.Reflection.CustomAttributeData" /> qui contiennent des informations sur les attributs appliqués au <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> actuel.</summary>
      <returns>Liste générique d’objets <see cref="T:System.Reflection.CustomAttributeData" /> représentant des données sur les attributs qui ont été appliqués au module actuel.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule(System.String)">
      <summary>Retourne le module dynamique avec le nom spécifié.</summary>
      <param name="name">Nom du module dynamique demandé.</param>
      <returns>Objet ModuleBuilder représentant le module dynamique demandé.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.</exception>
      <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetExportedTypes">
      <summary>Obtient les types exportés définis dans cet assembly.</summary>
      <returns>Tableau de <see cref="T:System.Type" /> contenant les types exportés définis dans cet assembly.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée.</exception>
      <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetFile(System.String)">
      <summary>Obtient un <see cref="T:System.IO.FileStream" /> pour le fichier spécifié dans la table de fichiers du manifeste de cet assembly.</summary>
      <param name="name">Nom du fichier spécifié.</param>
      <returns>
        <see cref="T:System.IO.FileStream" /> pour le fichier spécifié, ou <see langword="null" />, si le fichier est introuvable.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge pour l’instant.</exception>
      <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetFiles(System.Boolean)">
      <summary>Obtient les fichiers de la table de fichiers d'un manifeste d'assembly, en spécifiant si des modules de ressources doivent être inclus.</summary>
      <param name="getResourceModules">
        <see langword="true" /> pour inclure des modules de ressources ; sinon, <see langword="false" />.</param>
      <returns>Tableau d'objets <see cref="T:System.IO.FileStream" />.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge pour l’instant.</exception>
      <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetHashCode">
      <summary>Retourne le code de hachage de cette instance.</summary>
      <returns>Code de hachage d'un entier signé 32 bits.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetLoadedModules(System.Boolean)">
      <summary>Retourne tous les modules chargés qui font partie de cet assembly et inclut éventuellement des modules de ressources.</summary>
      <param name="getResourceModules">
        <see langword="true" /> pour inclure des modules de ressources ; sinon, <see langword="false" />.</param>
      <returns>Modules chargés qui font partie de cet assembly.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceInfo(System.String)">
      <summary>Retourne des informations sur la manière dont la ressource donnée a été persistante.</summary>
      <param name="resourceName">Nom de la ressource.</param>
      <returns>
        <see cref="T:System.Reflection.ManifestResourceInfo" /> rempli d'informations sur la topologie de la ressource, ou <see langword="null" /> si la ressource est introuvable.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge pour l’instant.</exception>
      <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceNames">
      <summary>Charge la ressource de manifeste spécifiée à partir de cet assembly.</summary>
      <returns>Tableau de type <see langword="String" /> contenant les noms de toutes les ressources.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n'est pas prise en charge sur un assembly dynamique. Pour obtenir les noms des ressources de manifeste, utilisez <see cref="M:System.Reflection.Assembly.GetManifestResourceNames" />.</exception>
      <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.String)">
      <summary>Charge la ressource de manifeste spécifiée à partir de cet assembly.</summary>
      <param name="name">Nom de la ressource de manifeste demandée.</param>
      <returns>
        <see cref="T:System.IO.Stream" /> représentant cette ressource de manifeste.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge pour l’instant.</exception>
      <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.Type,System.String)">
      <summary>Charge la ressource de manifeste spécifiée, dont la portée est définie par l'espace de noms du type déterminé, à partir de cet assembly.</summary>
      <param name="type">Type dont l'espace de noms définit la portée du nom de la ressource de manifeste.</param>
      <param name="name">Nom de la ressource de manifeste demandée.</param>
      <returns>
        <see cref="T:System.IO.Stream" /> représentant cette ressource de manifeste.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge pour l’instant.</exception>
      <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetModule(System.String)">
      <summary>Obtient le module spécifié dans cet assembly.</summary>
      <param name="name">Nom du module demandé.</param>
      <returns>Module demandé, ou <see langword="null" /> si le module est introuvable.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetModules(System.Boolean)">
      <summary>Obtient tous les modules qui font partie de cet assembly et inclut éventuellement des modules de ressources.</summary>
      <param name="getResourceModules">
        <see langword="true" /> pour inclure des modules de ressources ; sinon, <see langword="false" />.</param>
      <returns>Modules qui font partie de cet assembly.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetName(System.Boolean)">
      <summary>Obtient le <see cref="T:System.Reflection.AssemblyName" /> spécifié lorsque l'assembly dynamique actuel a été créé, puis définit la base de code comme spécifié.</summary>
      <param name="copiedName">
        <see langword="true" /> pour définir la base de code en fonction de l'emplacement de l'assembly après la création d'un cliché instantané de ce dernier ; <see langword="false" /> pour définir la base de code en fonction de l'emplacement d'origine.</param>
      <returns>Nom de l'assembly dynamique.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetReferencedAssemblies">
      <summary>Obtient une liste incomplète d'objets <see cref="T:System.Reflection.AssemblyName" /> pour les assemblys référencés par <see cref="T:System.Reflection.Emit.AssemblyBuilder" />.</summary>
      <returns>Tableau de noms d'assemblys pour les assemblys référencés. Ce tableau n’est pas une liste complète.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo)">
      <summary>Obtient l'assembly satellite pour la culture spécifiée.</summary>
      <param name="culture">Culture spécifiée.</param>
      <returns>Assembly satellite spécifié.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="culture" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.IO.FileNotFoundException">L’assembly est introuvable.</exception>
      <exception cref="T:System.IO.FileLoadException">L’assembly satellite avec un nom de fichier correspondant a été trouvé, mais l’élément <see langword="CultureInfo" /> ne correspondait pas à l’élément spécifié.</exception>
      <exception cref="T:System.BadImageFormatException">L’assembly satellite n’est pas un assembly valide.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
      <summary>Obtient la version spécifiée de l'assembly satellite pour la culture donnée.</summary>
      <param name="culture">Culture spécifiée.</param>
      <param name="version">Version de l'assembly satellite.</param>
      <returns>Assembly satellite spécifié.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="culture" /> est <see langword="null" />.</exception>
      <exception cref="T:System.IO.FileLoadException">L’assembly satellite avec un nom de fichier correspondant a été trouvé, mais l’élément <see langword="CultureInfo" /> ou la version ne correspondait pas à l’élément spécifié.</exception>
      <exception cref="T:System.IO.FileNotFoundException">L’assembly est introuvable.</exception>
      <exception cref="T:System.BadImageFormatException">L’assembly satellite n’est pas un assembly valide.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetType(System.String,System.Boolean,System.Boolean)">
      <summary>Obtient le type spécifié à partir des types définis et créés dans le <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> actuel.</summary>
      <param name="name">Nom du type à rechercher.</param>
      <param name="throwOnError">
        <see langword="true" /> pour lever une exception si le type est introuvable ; sinon, <see langword="false" />.</param>
      <param name="ignoreCase">
        <see langword="true" /> pour ignorer la casse du nom de type lors de la recherche ; sinon, <see langword="false" />.</param>
      <returns>Le type spécifié, ou <see langword="null" /> si le type est introuvable ou n’a pas encore été créé.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.GlobalAssemblyCache">
      <summary>Obtient une valeur qui indique si l’assembly a été chargé à partir du Global Assembly Cache.</summary>
      <returns>Toujours <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.HostContext">
      <summary>Obtient le contexte hôte où l’assembly dynamique est créé.</summary>
      <returns>Valeur qui indique le contexte hôte où l’assembly dynamique est créé.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.ImageRuntimeVersion">
      <summary>Obtient la version du Common Language Runtime (CLR) qui sera enregistré dans le fichier contenant le manifeste.</summary>
      <returns>Chaîne représentant la version du Common Language Runtime.</returns>
      <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Retourne une valeur qui indique si une ou plusieurs instances du type d'attribut spécifié sont appliquées à ce membre.</summary>
      <param name="attributeType">Type d'attribut à tester.</param>
      <param name="inherit">Cet argument est ignoré pour les objets de ce type.</param>
      <returns>
        <see langword="true" /> si une ou plusieurs instances de <paramref name="attributeType" /> sont appliquées à cet assembly dynamique ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.IsDynamic">
      <summary>Obtient une valeur qui indique que l'assembly actuel est dynamique.</summary>
      <returns>Toujours <see langword="true" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.Location">
      <summary>Obtient l’emplacement, au format code base, du fichier chargé qui contient le manifeste, s’il n’est pas un cliché instantané.</summary>
      <returns>Emplacement du fichier chargé qui contient le manifeste. Si le fichier chargé est un cliché instantané, le <see langword="Location" /> est celui du fichier avant l'exécution du cliché instantané.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge pour l’instant.</exception>
      <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.ManifestModule">
      <summary>Obtient le module du <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> actuel qui contient le manifeste de l'assembly.</summary>
      <returns>Module de manifeste.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.ReflectionOnly">
      <summary>Obtient une valeur indiquant si l’assembly dynamique est dans le contexte de réflexion uniquement.</summary>
      <returns>
        <see langword="true" /> si l’assembly dynamique est dans le contexte de réflexion uniquement ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Définit un attribut personnalisé sur cet assembly à l’aide d’un objet blob d’attribut personnalisé spécifié.</summary>
      <param name="con">Le constructeur de l’attribut personnalisé.</param>
      <param name="binaryAttribute">Objet blob d’octets représentant les attributs.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> est <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="con" /> n’est pas un objet <see langword="RuntimeConstructorInfo" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Définissez un attribut personnalisé sur cet assembly à l’aide d’un générateur d’attributs personnalisés.</summary>
      <param name="customBuilder">Instance d’une classe d’assistance pour définir l’attribut personnalisé.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> est <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
    </member>
    <member name="T:System.Reflection.Emit.AssemblyBuilderAccess">
      <summary>Définit les modes d'accès d'un assembly dynamique.</summary>
    </member>
    <member name="F:System.Reflection.Emit.AssemblyBuilderAccess.Run">
      <summary>L'assembly dynamique peut être exécuté, mais pas enregistré.</summary>
    </member>
    <member name="F:System.Reflection.Emit.AssemblyBuilderAccess.RunAndCollect">
      <summary>L’assembly dynamique est automatiquement déchargé et sa mémoire libérée, quand il n’est plus accessible.</summary>
    </member>
    <member name="T:System.Reflection.Emit.ConstructorBuilder">
      <summary>Définit et représente un constructeur d’une classe dynamique.</summary>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.Attributes">
      <summary>Obtient les attributs de ce constructeur.</summary>
      <returns>Attributs de ce constructeur.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.CallingConvention">
      <summary>Obtient une valeur <see cref="T:System.Reflection.CallingConventions" /> qui varie selon que le type déclarant est générique ou non.</summary>
      <returns>
        <see cref="F:System.Reflection.CallingConventions.HasThis" /> si le type de déclaration est générique ; sinon, <see cref="F:System.Reflection.CallingConventions.Standard" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.DeclaringType">
      <summary>Obtient une référence à l’objet <see cref="T:System.Type" /> pour le type qui déclare ce membre.</summary>
      <returns>Type qui déclare ce membre.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
      <summary>Définit un paramètre pour ce constructeur.</summary>
      <param name="iSequence">Position du paramètre dans la liste des paramètres. Les paramètres sont indexés en commençant par le numéro 1 pour le premier paramètre.</param>
      <param name="attributes">Attributs du paramètres.</param>
      <param name="strParamName">Nom du paramètre. Le nom peut être la chaîne Null.</param>
      <returns>Objet qui représente le nouveau paramètre de ce constructeur.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="iSequence" /> est inférieur à 0 (zéro) ou est supérieur au nombre de paramètres du constructeur.</exception>
      <exception cref="T:System.InvalidOperationException">Le type conteneur a été créé à l’aide de <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Retourne tous les attributs personnalisés définis pour ce constructeur.</summary>
      <param name="inherit">Contrôle l'héritage des attributs personnalisés des classes de base. Ce paramètre est ignoré.</param>
      <returns>Tableau d’objets représentant tous les attributs personnalisés du constructeur représenté par cette instance <see cref="T:System.Reflection.Emit.ConstructorBuilder" />.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge pour l’instant.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Retourne les attributs personnalisés identifiés par le type donné.</summary>
      <param name="attributeType">Type de l'attribut personnalisé.</param>
      <param name="inherit">Contrôle l’héritage des attributs personnalisés à partir de classes de base. Ce paramètre est ignoré.</param>
      <returns>Tableau d’objets qui représente les attributs de ce constructeur.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge pour l’instant.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator">
      <summary>Obtient un <see cref="T:System.Reflection.Emit.ILGenerator" /> pour ce constructeur.</summary>
      <returns>Objet <see cref="T:System.Reflection.Emit.ILGenerator" /> pour ce constructeur.</returns>
      <exception cref="T:System.InvalidOperationException">Le constructeur est un constructeur sans paramètre.

ou -
Le constructeur possède des indicateurs <see cref="T:System.Reflection.MethodAttributes" /> ou <see cref="T:System.Reflection.MethodImplAttributes" /> signalant qu'il ne doit pas posséder de corps de méthode.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator(System.Int32)">
      <summary>Obtient un objet <see cref="T:System.Reflection.Emit.ILGenerator" />, avec la taille du flux MSIL spécifiée, permettant de construire un corps de méthode pour ce constructeur.</summary>
      <param name="streamSize">Taille du flux MSIL en octets.</param>
      <returns>Un <see cref="T:System.Reflection.Emit.ILGenerator" /> pour ce constructeur.</returns>
      <exception cref="T:System.InvalidOperationException">Le constructeur est un constructeur sans paramètre.

ou -
Le constructeur a <see cref="T:System.Reflection.MethodAttributes" /> ou <see cref="T:System.Reflection.MethodImplAttributes" /> indicateurs indiquant qu’il ne doit pas comporter un corps de méthode.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetMethodImplementationFlags">
      <summary>Retourne les indicateurs d'implémentation de méthodes de ce constructeur.</summary>
      <returns>Indicateurs d’implémentation de méthode de ce constructeur.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetParameters">
      <summary>Retourne les paramètres de ce constructeur.</summary>
      <returns>Tableau qui représente les paramètres de ce constructeur.</returns>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> n’a pas été appelé sur le type de ce constructeur, dans les versions 1.0 et 1.1 du .NET Framework.</exception>
      <exception cref="T:System.NotSupportedException">
        <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> n'a pas été appelé sur le type de ce constructeur, dans la version 2.0 du .NET Framework.</exception>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.InitLocals">
      <summary>Obtient ou détermine une valeur indiquant si les variables locales de ce constructeur doivent être initialisée à zéro.</summary>
      <returns>Lecture/écriture. Obtient ou définit si les variables locales de ce constructeur doivent être initialisées à zéro.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>Appelle de manière dynamique le constructeur réfléchi par cette instance avec les arguments spécifiés et les contraintes du <see langword="Binder" /> spécifié.</summary>
      <param name="obj">Objet devant être réinitialisé.</param>
      <param name="invokeAttr">Une des valeurs <see langword="BindingFlags" /> qui spécifie le type de liaison requis.</param>
      <param name="binder">
        <see langword="Binder" /> qui définit un jeu de propriétés et active la liaison, la contrainte des types d'arguments ainsi que l'appel des membres à l'aide de la réflexion. Si <paramref name="binder" /> est <see langword="null" />, Binder.DefaultBinding est utilisé.</param>
      <param name="parameters">Liste d’arguments. Il s'agit d'un tableau d'arguments ayant les mêmes nombre, ordre et type que les paramètres du constructeur à appeler. En l'absence de paramètres, la valeur doit être une référence null (<see langword="Nothing" /> en Visual Basic).</param>
      <param name="culture">Un <see cref="T:System.Globalization.CultureInfo" /> utilisé pour régir la contrainte de types. Si la valeur est null, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
      <returns>Instance de la classe associée au constructeur.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge pour l’instant. Vous pouvez récupérer le constructeur à l’aide du <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> et appeler <see cref="M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /> sur le <see cref="T:System.Reflection.ConstructorInfo" /> retourné.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>Appelle dynamiquement le constructeur représenté par cette instance sur l’objet donné, en passant les paramètres spécifiés et en tenant compte des contraintes du binder donné.</summary>
      <param name="invokeAttr">Il doit s’agir d’un bit indicateur issu de <see cref="T:System.Reflection.BindingFlags" />, comme InvokeMethod, NonPublic, etc.</param>
      <param name="binder">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <see langword="MemberInfo" /> par le biais de la réflexion. Si binder a la valeur <see langword="null" />, le binder par défaut est utilisé. Consultez <see cref="T:System.Reflection.Binder" />.</param>
      <param name="parameters">Liste d’arguments. Il s’agit d’un tableau d’arguments possédant les mêmes nombres, ordre et type que les paramètres du constructeur à appeler. En l’absence de paramètres, ce paramètre doit être <see langword="null" />.</param>
      <param name="culture">Instance de <see cref="T:System.Globalization.CultureInfo" /> utilisée pour régir la contrainte des types. Si la valeur est null, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé. (Par exemple, cela est nécessaire pour convertir un <see cref="T:System.String" /> représentant 1 000 en valeur <see cref="T:System.Double" />, car 1 000 est représenté de différentes manières, selon la culture.)</param>
      <returns>Valeur retournée par le constructeur appelé.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge pour l’instant. Vous pouvez récupérer le constructeur à l’aide du <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> et appeler <see cref="M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /> sur le <see cref="T:System.Reflection.ConstructorInfo" /> retourné.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Vérifie si le type d’attribut personnalisé spécifié est défini.</summary>
      <param name="attributeType">Type d'attribut personnalisé.</param>
      <param name="inherit">Contrôle l’héritage des attributs personnalisés à partir de classes de base. Ce paramètre est ignoré.</param>
      <returns>
        <see langword="true" /> si le type d’attribut personnalisé spécifié est défini ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge pour l’instant. Vous pouvez récupérer le constructeur à l'aide de <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />, puis appeler <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> sur <see cref="T:System.Reflection.ConstructorInfo" /> retourné.</exception>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.MethodHandle">
      <summary>Obtient le handle interne de la méthode. Utilisez ce handle pour accéder au handle des métadonnées sous-jacentes.</summary>
      <returns>Handle interne de la méthode. Utilisez ce handle pour accéder au handle des métadonnées sous-jacentes.</returns>
      <exception cref="T:System.NotSupportedException">Cette propriété n'est pas prise en charge sur cette classe.</exception>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.Module">
      <summary>Obtient le module dynamique dans lequel ce constructeur est défini.</summary>
      <returns>Objet <see cref="T:System.Reflection.Module" /> qui représente le module dynamique dans lequel ce constructeur est défini.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.Name">
      <summary>Récupère le nom de ce constructeur.</summary>
      <returns>Nom de ce constructeur.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.ReflectedType">
      <summary>Contient une référence à l’objet <see cref="T:System.Type" /> à partir duquel cet objet a été obtenu.</summary>
      <returns>Objet <see langword="Type" /> à partir duquel cet objet a été obtenu.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Définit un attribut personnalisé à l’aide d’un objet blob d’attribut personnalisé spécifié.</summary>
      <param name="con">Le constructeur de l’attribut personnalisé.</param>
      <param name="binaryAttribute">Objet blob d’octets représentant les attributs.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Définit un attribut personnalisé à l’aide d’un générateur d’attributs personnalisés.</summary>
      <param name="customBuilder">Instance d’une classe d’assistance pour définir l’attribut personnalisé.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
      <summary>Définit les indicateurs d’implémentation de méthode de ce constructeur.</summary>
      <param name="attributes">Indicateurs d'implémentation de méthodes.</param>
      <exception cref="T:System.InvalidOperationException">Le type conteneur a été créé à l’aide de <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.ToString">
      <summary>Retourne cette instance de <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> en tant que <see cref="T:System.String" />.</summary>
      <returns>Chaîne contenant le nom, les attributs et les exceptions de ce constructeur, suivis du flux MSIL (Microsoft Intermediate Language) actuel.</returns>
    </member>
    <member name="T:System.Reflection.Emit.EnumBuilder">
      <summary>Décrit et représente un type d’énumération.</summary>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Assembly">
      <summary>Récupère l’assembly dynamique qui contient la définition de cet enum.</summary>
      <returns>Lecture seule. Assembly dynamique qui contient la définition de cet enum.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.AssemblyQualifiedName">
      <summary>Retourne le chemin d’accès complet de cet enum, qualifié par le nom complet de l’assembly parent.</summary>
      <returns>Lecture seule. Chemin d’accès complet de cet enum, qualifié par le nom complet de l’assembly parent.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.BaseType">
      <summary>Retourne le <see cref="T:System.Type" /> parent de ce type qui est toujours <see cref="T:System.Enum" />.</summary>
      <returns>Lecture seule. Parent <see cref="T:System.Type" /> de ce type.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.CreateTypeInfo">
      <summary>Obtient un objet <see cref="T:System.Reflection.TypeInfo" /> qui représente cette énumération.</summary>
      <returns>Objet qui représente cette énumération.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.DeclaringType">
      <summary>Retourne le type qui a déclaré cet <see cref="T:System.Reflection.Emit.EnumBuilder" />.</summary>
      <returns>Lecture seule. Type qui a déclaré cet <see cref="T:System.Reflection.Emit.EnumBuilder" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.DefineLiteral(System.String,System.Object)">
      <summary>Définit le champ statique nommé dans un type d’énumération avec la valeur de constante spécifiée.</summary>
      <param name="literalName">Nom du champ static.</param>
      <param name="literalValue">Valeur de constante du littéral.</param>
      <returns>Champ défini.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.FullName">
      <summary>Retourne le chemin complet de cet enum.</summary>
      <returns>Lecture seule. Chemin complet de cet enum.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetConstructors(System.Reflection.BindingFlags)">
      <summary>Retourne un tableau d’objets <see cref="T:System.Reflection.ConstructorInfo" /> représentant les constructeurs publics et non publics définis pour cette classe, comme spécifié.</summary>
      <param name="bindingAttr">Il doit s’agir d’un bit indicateur issu de <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Retourne un tableau d’objets <see cref="T:System.Reflection.ConstructorInfo" /> représentant les constructeurs spécifiés définis pour cette classe. Si aucun constructeur n’est défini, un tableau vide est retourné.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est actuellement pas prise en charge pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Retourne tous les attributs personnalisés définis pour ce constructeur.</summary>
      <param name="inherit">Spécifie s’il faut rechercher les attributs dans la chaîne d’héritage de ce membre.</param>
      <returns>Retourne un tableau d’objets représentant tous les attributs personnalisés du constructeur représenté par cette instance <see cref="T:System.Reflection.Emit.ConstructorBuilder" />.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est actuellement pas prise en charge pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Retourne les attributs personnalisés identifiés par le type donné.</summary>
      <param name="attributeType">Objet <see langword="Type" /> auquel les attributs personnalisés sont appliqués.</param>
      <param name="inherit">Spécifie s’il faut rechercher les attributs dans la chaîne d’héritage de ce membre.</param>
      <returns>Retourne un tableau d’objets représentant les attributs de ce constructeur qui sont de <see cref="T:System.Type" /><paramref name="attributeType" />.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est actuellement pas prise en charge pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetElementType">
      <summary>L'appel de cette méthode lève toujours <see cref="T:System.NotSupportedException" />.</summary>
      <returns>Cette méthode n'est pas prise en charge. Aucune valeur n'est retournée.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge pour l’instant.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEnumUnderlyingType">
      <summary>Retourne le type d’entier sous-jacent de l’énumération actuelle, qui est défini quand le générateur de l’énumération est défini.</summary>
      <returns>Type sous-jacent.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
      <summary>Retourne l’événement avec le nom spécifié.</summary>
      <param name="name">Nom de l’événement à obtenir.</param>
      <param name="bindingAttr">Attribut de cet appel. Il doit s’agir d’un bit indicateur issu de <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Retourne un objet <see cref="T:System.Reflection.EventInfo" /> représentant l’événement déclaré ou hérité par ce type avec le nom spécifié. Si aucune correspondance n’existe, <see langword="null" /> est retourné.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est actuellement pas prise en charge pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEvents">
      <summary>Retourne les événements publics déclarés ou hérités par ce type.</summary>
      <returns>Retourne un tableau d’objets <see cref="T:System.Reflection.EventInfo" /> représentant les événements publics déclarés ou hérités par ce type. Un tableau vide est retourné s’il n’existe aucun événement public.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est actuellement pas prise en charge pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEvents(System.Reflection.BindingFlags)">
      <summary>Retourne les événements publics et non publics déclarés par ce type.</summary>
      <param name="bindingAttr">Il doit s’agir d’un bit indicateur issu de <see cref="T:System.Reflection.BindingFlags" />, comme <see langword="InvokeMethod" />, <see langword="NonPublic" /> et ainsi de suite.</param>
      <returns>Retourne un tableau d’objets <see cref="T:System.Reflection.EventInfo" /> représentant les événements publics et non publics déclarés ou hérités par ce type. Un tableau vide est retourné s’il n’existe aucun événement, comme il est spécifié.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est actuellement pas prise en charge pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary>Retourne le champ spécifié par le nom donné.</summary>
      <param name="name">Nom du champ à obtenir.</param>
      <param name="bindingAttr">Il doit s’agir d’un bit indicateur issu de <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Retourne l’objet <see cref="T:System.Reflection.FieldInfo" /> représentant le champ déclaré ou hérité par ce type avec le nom spécifié et le modificateur public ou non public. En l’absence de correspondances, la valeur « null » est retournée.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est actuellement pas prise en charge pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary>Retourne les champs publics et non publics déclarés par ce type.</summary>
      <param name="bindingAttr">Il doit s’agir d’un indicateur de bit appartenant à <see cref="T:System.Reflection.BindingFlags" />, tel qu’InvokeMethod, NonPublic, etc.</param>
      <returns>Retourne un tableau d’objets <see cref="T:System.Reflection.FieldInfo" /> représentant les champs publics et non publics déclarés ou hérités par ce type. Un tableau vide est retourné s’il n’existe aucun champ, comme indiqué.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est actuellement pas prise en charge pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetInterface(System.String,System.Boolean)">
      <summary>Retourne l’interface implémentée (directement ou indirectement) par ce type, avec le nom qualifié complet spécifié.</summary>
      <param name="name">Nom de l’interface.</param>
      <param name="ignoreCase">Si <see langword="true" />, la recherche ne respecte pas la casse. Si <see langword="false" />, la recherche respecte la casse.</param>
      <returns>Retourne un objet <see cref="T:System.Type" /> représentant l’interface implémentée. Retourne null si aucun nom d’interface correspondant n’est trouvé.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est actuellement pas prise en charge pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetInterfaceMap(System.Type)">
      <summary>Retourne un mappage d’interface pour l’interface demandée.</summary>
      <param name="interfaceType">Type de l’interface pour laquelle le mappage d’interface doit être récupéré.</param>
      <returns>Mappage d’interface demandé.</returns>
      <exception cref="T:System.ArgumentException">Le type n’implémente pas l’interface.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetInterfaces">
      <summary>Retourne un tableau de toutes les interfaces implémentées sur cette une classe et ses classes de base.</summary>
      <returns>Retourne un tableau d’objets <see cref="T:System.Type" /> représentant les interfaces implémentées. Si aucune interface n’est définie, un tableau vide est retourné.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
      <summary>Retourne tous les membres avec le nom spécifié, le type et la liaison qui sont déclarés ou hérités par ce type.</summary>
      <param name="name">Nom du membre.</param>
      <param name="type">Type du membre qui doit être retourné.</param>
      <param name="bindingAttr">Il doit s’agir d’un bit indicateur issu de <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Retourne un tableau d’objets <see cref="T:System.Reflection.MemberInfo" /> représentant les membres publics et non publics définis sur ce type si <paramref name="nonPublic" /> est utilisé ; sinon, seuls les membres publics sont retournés.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est actuellement pas prise en charge pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetMembers(System.Reflection.BindingFlags)">
      <summary>Retourne les membres spécifiés déclarés ou hérités par ce type.</summary>
      <param name="bindingAttr">Il doit s’agir d’un bit indicateur issu de <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Retourne un tableau d’objets <see cref="T:System.Reflection.MemberInfo" /> représentant les membres publics et non publics déclarés ou hérités par ce type. Un tableau vide est retourné s’il n’existe aucun membre correspondant.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est actuellement pas prise en charge pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary>Retourne toutes les méthodes publiques et non publiques déclarées ou héritées par ce type, comme spécifié.</summary>
      <param name="bindingAttr">Il doit s’agir d’un bit indicateur issu de <see cref="T:System.Reflection.BindingFlags" />, comme <see langword="InvokeMethod" />, <see langword="NonPublic" /> et ainsi de suite.</param>
      <returns>Retourne un tableau d’objets <see cref="T:System.Reflection.MethodInfo" /> représentant les méthodes publiques et non publiques définies sur ce type si <paramref name="nonPublic" /> est utilisé ; sinon, seules les méthodes publiques sont retournées.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est actuellement pas prise en charge pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
      <summary>Retourne le type imbriqué spécifié qui est déclaré par ce type.</summary>
      <param name="name">
        <see cref="T:System.String" /> contenant le nom du type imbriqué à obtenir.</param>
      <param name="bindingAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.

ou -
Zéro, pour rechercher les méthodes publiques en respectant la casse.</param>
      <returns>Objet <see cref="T:System.Type" /> qui représente le type imbriqué correspondant aux critères spécifiés, s’il est trouvé ; sinon, <see langword="null" />.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est actuellement pas prise en charge pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
      <summary>Retourne les types imbriqués publics et non publics déclarés ou hérités par ce type.</summary>
      <param name="bindingAttr">Il doit s’agir d’un bit indicateur issu de <see cref="T:System.Reflection.BindingFlags" />, comme <see langword="InvokeMethod" />, <see langword="NonPublic" /> et ainsi de suite.</param>
      <returns>Tableau d’objets <see cref="T:System.Type" /> représentant tous les types imbriqués dans le <see cref="T:System.Type" /> actuel qui correspondent aux contraintes de liaison spécifiées.
Tableau vide du type <see cref="T:System.Type" /> si aucun type n’est imbriqué dans le <see cref="T:System.Type" /> actuel ou si aucun des types imbriqués ne correspond aux contraintes de liaison.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est actuellement pas prise en charge pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetProperties(System.Reflection.BindingFlags)">
      <summary>Retourne toutes les propriétés publiques et non publiques déclarées ou héritées par ce type, comme spécifié.</summary>
      <param name="bindingAttr">Attribut de cet appel. Il doit s’agir d’un bit indicateur issu de <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Retourne un tableau d’objets <see cref="T:System.Reflection.PropertyInfo" /> représentant les propriétés publiques et non publiques définies sur ce type si <paramref name="nonPublic" /> est utilisé ; sinon, seules les propriétés publiques sont retournées.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est actuellement pas prise en charge pour les types incomplets.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.GUID">
      <summary>Retourne le GUID de cette énumération.</summary>
      <returns>Lecture seule. GUID de cette énumération.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est actuellement pas prise en charge pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
      <summary>Appelle le membre spécifié. La méthode à appeler doit être accessible et fournir la correspondance la plus spécifique avec la liste d’arguments spécifiée, sous les contraintes des attributs de binder et d’appel spécifiés.</summary>
      <param name="name">Nom du membre à appeler. Il peut s’agir d’un constructeur, d’une méthode, d’une propriété ou d’un champ. Un attribut d’appel approprié doit être spécifié. Notez qu’il est possible d’appeler le membre par défaut d’une classe en passant une chaîne vide comme nom du membre.</param>
      <param name="invokeAttr">Attribut d’appel. Il doit s’agir d’un indicateur de bit issu de <see langword="BindingFlags" />.</param>
      <param name="binder">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <see langword="MemberInfo" /> par le biais de la réflexion. Si binder a la valeur <see langword="null" />, le binder par défaut est utilisé. Consultez <see cref="T:System.Reflection.Binder" />.</param>
      <param name="target">Objet sur lequel appeler le membre spécifié. Si le membre est statique, ce paramètre est ignoré.</param>
      <param name="args">Liste d’arguments. Il s’agit d’un tableau d’objets contenant le nombre, l’ordre et le type des paramètres du membre à appeler. En l’absence de paramètres, il doit avoir la valeur null.</param>
      <param name="modifiers">Tableau de même longueur que <paramref name="args" /> avec des éléments qui représentent les attributs associés aux arguments du membre à appeler. Un paramètre est associé à des attributs dans les métadonnées. Elles sont utilisées par divers services d’interopérabilité. Pour plus d’informations de ce type, consultez les spécifications des métadonnées.</param>
      <param name="culture">Instance de <see langword="CultureInfo" /> utilisée pour régir la contrainte des types. Si la valeur est null, le <see langword="CultureInfo" /> du thread actuel est utilisé. (Notez que cela est nécessaire pour, par exemple, convertir une chaîne représentant 1000 en valeur double, car 1000 est représenté de différentes manières selon la culture.)</param>
      <param name="namedParameters">Chaque paramètre dans le tableau <paramref name="namedParameters" /> obtient la valeur de l’élément correspondant dans le tableau <paramref name="args" />. Si la longueur de <paramref name="args" /> est supérieure à la longueur de <paramref name="namedParameters" />, les valeurs d’argument restantes sont passées dans l’ordre.</param>
      <returns>Retourne la valeur de retour du membre appelé.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est actuellement pas prise en charge pour les types incomplets.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.IsByRefLike" />
    <member name="P:System.Reflection.Emit.EnumBuilder.IsConstructedGenericType">
      <summary>Obtient une valeur qui indique si cet objet représente un type générique construit.</summary>
      <returns>
        <see langword="true" /> si cet objet représente un type générique construit ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Vérifie si le type d’attribut personnalisé spécifié est défini.</summary>
      <param name="attributeType">Objet <see langword="Type" /> auquel les attributs personnalisés sont appliqués.</param>
      <param name="inherit">Spécifie s’il faut rechercher les attributs dans la chaîne d’héritage de ce membre.</param>
      <returns>
        <see langword="true" /> si une ou plusieurs instances de <paramref name="attributeType" /> sont définies sur ce membre ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est actuellement pas prise en charge pour les types incomplets.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.IsSZArray" />
    <member name="P:System.Reflection.Emit.EnumBuilder.IsTypeDefinition" />
    <member name="P:System.Reflection.Emit.EnumBuilder.IsVariableBoundArray" />
    <member name="M:System.Reflection.Emit.EnumBuilder.MakeArrayType">
      <summary>Retourne un objet <see cref="T:System.Type" /> qui représente un tableau unidimensionnel du type actuel, avec une limite inférieure de zéro.</summary>
      <returns>Objet <see cref="T:System.Type" /> qui représente un tableau unidimensionnel du type actuel, avec une limite inférieure de zéro.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.MakeArrayType(System.Int32)">
      <summary>Retourne un objet <see cref="T:System.Type" /> qui représente un tableau du type actuel, avec le nombre spécifié de dimensions.</summary>
      <param name="rank">Nombre de dimensions pour le tableau. Ce nombre doit être inférieur ou égal à 32.</param>
      <returns>Objet qui représente un tableau du type actuel, avec le nombre spécifié de dimensions.</returns>
      <exception cref="T:System.IndexOutOfRangeException">
        <paramref name="rank" /> est inférieur à 1.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.MakeByRefType">
      <summary>Retourne un objet <see cref="T:System.Type" /> qui représente le type actif quand il est passé en tant que paramètre ref (paramètre ByRef en Visual Basic).</summary>
      <returns>Objet <see cref="T:System.Type" /> qui représente le type actif quand il est passé en tant que paramètre ref (paramètre ByRef en Visual Basic).</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.MakePointerType">
      <summary>Retourne un objet <see cref="T:System.Type" /> qui représente un pointeur vers le type actuel.</summary>
      <returns>Objet <see cref="T:System.Type" /> qui représente un pointeur vers le type actuel.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Module">
      <summary>Récupère le module dynamique qui contient la définition de cet <see cref="T:System.Reflection.Emit.EnumBuilder" />.</summary>
      <returns>Lecture seule. Module dynamique qui contient la définition de cet <see cref="T:System.Reflection.Emit.EnumBuilder" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Name">
      <summary>Retourne le nom de cette énumération.</summary>
      <returns>Lecture seule. Nom de cette énumération.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Namespace">
      <summary>Retourne l’espace de noms de cet enum.</summary>
      <returns>Lecture seule. Espace de noms de cet enum.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.ReflectedType">
      <summary>Retourne le type qui a été utilisé pour obtenir ce <see cref="T:System.Reflection.Emit.EnumBuilder" />.</summary>
      <returns>Lecture seule. Le type qui a été utilisé pour obtenir ce <see cref="T:System.Reflection.Emit.EnumBuilder" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Définit un attribut personnalisé à l’aide d’un objet blob d’attribut personnalisé spécifié.</summary>
      <param name="con">Le constructeur de l’attribut personnalisé.</param>
      <param name="binaryAttribute">Objet blob d’octets représentant les attributs.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Définit un attribut personnalisé à l’aide d’un générateur d’attributs personnalisés.</summary>
      <param name="customBuilder">Instance d’une classe d’assistance pour définir l’attribut personnalisé.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.TypeHandle">
      <summary>Récupère le handle interne de cette énumération.</summary>
      <returns>Lecture seule. Handle interne de cette énumération.</returns>
      <exception cref="T:System.NotSupportedException">Cette propriété n'est pas prise en charge actuellement.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.UnderlyingField">
      <summary>Retourne le champ sous-jacent de cet enum.</summary>
      <returns>Lecture seule. Champ sous-jacent de cet enum.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.UnderlyingSystemType">
      <summary>Retourne le type de système sous-jacent pour cette enum.</summary>
      <returns>Lecture seule. Retourne le type de système sous-jacent.</returns>
    </member>
    <member name="T:System.Reflection.Emit.EventBuilder">
      <summary>Définit les événements d'une classe.</summary>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.AddOtherMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Ajoute une des « autres » méthodes associées à cet événement. Les « autres » méthodes sont des méthodes autres que les méthodes « on » et « raise » associées à un événement. Vous pouvez appeler cette fonction plusieurs fois pour ajouter d'« autres » méthodes.</summary>
      <param name="mdBuilder">Objet <see langword="MethodBuilder" /> qui représente l'autre méthode.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">La méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> a été appelée sur le type englobant.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetAddOnMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Définit la méthode utilisée pour s'abonner à cet événement.</summary>
      <param name="mdBuilder">Objet <see langword="MethodBuilder" /> qui représente la méthode utilisée pour s'abonner à cet événement.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">La méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> a été appelée sur le type englobant.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Définit un attribut personnalisé à l’aide d’un objet blob d’attribut personnalisé spécifié.</summary>
      <param name="con">Le constructeur de l’attribut personnalisé.</param>
      <param name="binaryAttribute">Objet blob d’octets représentant les attributs.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">La méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> a été appelée sur le type englobant.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Définit un attribut personnalisé à l’aide d’un générateur d’attributs personnalisés.</summary>
      <param name="customBuilder">Instance d’une classe d’assistance pour décrire l’attribut personnalisé.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">La méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> a été appelée sur le type englobant.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetRaiseMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Définit la méthode utilisée pour déclencher cet événement.</summary>
      <param name="mdBuilder">Objet <see langword="MethodBuilder" /> qui représente la méthode utilisée pour déclencher cet événement.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">La méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> a été appelée sur le type englobant.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetRemoveOnMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Définit la méthode utilisée pour annuler l'abonnement à cet événement.</summary>
      <param name="mdBuilder">Objet <see langword="MethodBuilder" /> qui représente la méthode utilisée pour annuler l'abonnement à cet événement.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">La méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> a été appelée sur le type englobant.</exception>
    </member>
    <member name="T:System.Reflection.Emit.FieldBuilder">
      <summary>Définit et représente un champ. Cette classe ne peut pas être héritée.</summary>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.Attributes">
      <summary>Indique les attributs de ce champ. Cette propriété est en lecture seule.</summary>
      <returns>Attributs de ce champ.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.DeclaringType">
      <summary>Indique une référence à l'objet <see cref="T:System.Type" /> pour le type qui déclare ce champ. Cette propriété est en lecture seule.</summary>
      <returns>Référence à l'objet <see cref="T:System.Type" /> pour le type qui déclare ce champ.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.FieldHandle">
      <summary>Indique le handle de métadonnées interne de ce champ. Cette propriété est en lecture seule.</summary>
      <returns>Handle de métadonnées interne de ce champ.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n'est pas prise en charge.</exception>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.FieldType">
      <summary>Indique l'objet <see cref="T:System.Type" /> qui représente le type de ce champ. Cette propriété est en lecture seule.</summary>
      <returns>Objet <see cref="T:System.Type" /> qui représente le type de ce champ.</returns>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Retourne tous les attributs personnalisés définis pour ce champ.</summary>
      <param name="inherit">Contrôle l’héritage des attributs personnalisés à partir de classes de base.</param>
      <returns>Tableau de type <see cref="T:System.Object" /> représentant tous les attributs personnalisés du constructeur représenté par cette instance <see cref="T:System.Reflection.Emit.FieldBuilder" />.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n'est pas prise en charge.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Retourne tous les attributs personnalisés définis pour ce champ et identifiés par le type donné.</summary>
      <param name="attributeType">Type d’attribut personnalisé.</param>
      <param name="inherit">Contrôle l’héritage des attributs personnalisés à partir de classes de base.</param>
      <returns>Tableau de type <see cref="T:System.Object" /> représentant tous les attributs personnalisés du constructeur représenté par cette instance <see cref="T:System.Reflection.Emit.FieldBuilder" />.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n'est pas prise en charge.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.GetValue(System.Object)">
      <summary>Récupère la valeur du champ pris en charge par l'objet donné.</summary>
      <param name="obj">Objet sur lequel accéder au champ.</param>
      <returns>
        <see cref="T:System.Object" /> qui contient la valeur du champ réfléchi par cette instance.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n'est pas prise en charge.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Indique si un attribut doté du type spécifié est défini sur un champ.</summary>
      <param name="attributeType">Type de l'attribut.</param>
      <param name="inherit">Contrôle l’héritage des attributs personnalisés à partir de classes de base.</param>
      <returns>
        <see langword="true" /> si une ou plusieurs instances de <paramref name="attributeType" /> sont définies sur ce champ ; sinon <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge pour l’instant. Vous pouvez récupérer le champ à l'aide de <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" /> et appeler <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> sur le <see cref="T:System.Reflection.FieldInfo" /> retourné.</exception>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.Module">
      <summary>Obtient le module dans lequel le type qui contient ce champ est défini.</summary>
      <returns>
        <see cref="T:System.Reflection.Module" /> représentant le module dynamique dans lequel ce champ est défini.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.Name">
      <summary>Indique le nom de ce champ. Cette propriété est en lecture seule.</summary>
      <returns>
        <see cref="T:System.String" /> qui contient le nom de ce champ.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.ReflectedType">
      <summary>Indique la référence à l'objet <see cref="T:System.Type" /> à partir duquel cet objet a été obtenu. Cette propriété est en lecture seule.</summary>
      <returns>Référence à l'objet <see cref="T:System.Type" /> à partir duquel cette instance a été obtenue.</returns>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetConstant(System.Object)">
      <summary>Définit la valeur par défaut de ce champ.</summary>
      <param name="defaultValue">Nouvelle valeur par défaut de ce champ.</param>
      <exception cref="T:System.InvalidOperationException">Le type conteneur a été créé à l’aide de <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      <exception cref="T:System.ArgumentException">Le champ ne correspond pas à un type pris en charge.

ou -
Le type de <paramref name="defaultValue" /> ne correspond pas au type du champ.

ou -
Le champ est de type <see cref="T:System.Object" /> ou d'un autre type référence, <paramref name="defaultValue" /> n'est pas <see langword="null" />, et la valeur ne peut pas être assignée au type référence.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Définit un attribut personnalisé à l’aide d’un objet blob d’attribut personnalisé spécifié.</summary>
      <param name="con">Le constructeur de l’attribut personnalisé.</param>
      <param name="binaryAttribute">Objet blob d’octets représentant les attributs.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le type parent de ce champ est complet.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Définit un attribut personnalisé à l’aide d’un générateur d’attributs personnalisés.</summary>
      <param name="customBuilder">Instance d’une classe d’assistance pour définir l’attribut personnalisé.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le type parent de ce champ est complet.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetOffset(System.Int32)">
      <summary>Spécifie la disposition du champ.</summary>
      <param name="iOffset">Offset du champ dans le type contenant ce champ.</param>
      <exception cref="T:System.InvalidOperationException">Le type conteneur a été créé à l’aide de <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="iOffset" /> est inférieur à zéro.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
      <summary>Définit la valeur du champ pris en charge par l’objet donné.</summary>
      <param name="obj">Objet sur lequel accéder au champ.</param>
      <param name="val">La valeur à affecter au champ.</param>
      <param name="invokeAttr">Membre de <see langword="IBinder" /> qui spécifie le type de liaison requis (par exemple, IBinder.CreateInstance, IBinder.ExactBinding).</param>
      <param name="binder">Ensemble de propriétés et d'activations de la liaison, de la contrainte des types d'arguments et d'appel des membres à l'aide de la réflexion. Si binder est null, Binder.DefaultBinding est utilisé.</param>
      <param name="culture">Préférences logicielles d'une culture spécifique.</param>
      <exception cref="T:System.NotSupportedException">Cette méthode n'est pas prise en charge.</exception>
    </member>
    <member name="T:System.Reflection.Emit.GenericTypeParameterBuilder">
      <summary>Définit et crée des paramètres de type générique pour les types et les méthodes génériques définis dynamiquement. Cette classe ne peut pas être héritée.</summary>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Assembly">
      <summary>Obtient un objet <see cref="T:System.Reflection.Assembly" /> représentant l'assembly dynamique qui contient la définition de type générique à laquelle appartient le paramètre de type actuel.</summary>
      <returns>Objet <see cref="T:System.Reflection.Assembly" /> représentant l'assembly dynamique qui contient la définition de type générique à laquelle appartient le paramètre de type actuel.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.AssemblyQualifiedName">
      <summary>Obtient <see langword="null" /> dans tous les cas.</summary>
      <returns>Référence Null (<see langword="Nothing" /> en Visual Basic) dans tous les cas.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.BaseType">
      <summary>Obtient la contrainte de type de base du paramètre de type générique actuel.</summary>
      <returns>Objet <see cref="T:System.Type" /> qui représente la contrainte de type de base du paramètre de type générique, ou <see langword="null" /> si le paramètre de type ne possède aucune contrainte de type de base.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.ContainsGenericParameters">
      <summary>Obtient <see langword="true" /> dans tous les cas.</summary>
      <returns>
        <see langword="true" /> dans tous les cas.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.DeclaringMethod">
      <summary>Obtient un <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode de déclaration, si le <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> actuel représente un paramètre de type d’une méthode générique.</summary>
      <returns>Obtient un <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode de déclaration, si le <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> actuel représente un paramètre de type d’une méthode générique ; sinon, <see langword="null" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.DeclaringType">
      <summary>Obtient la définition de type générique ou la définition de méthode générique à laquelle appartient le paramètre de type générique.</summary>
      <returns>Si le paramètre de type appartient à un type générique, un objet <see cref="T:System.Type" /> représentant ce type générique ; si le paramètre de type appartient à une méthode générique, un objet <see cref="T:System.Type" /> représentant le type qui a déclaré cette méthode générique.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.Equals(System.Object)">
      <summary>Tests si l'objet donné est une instance de <see langword="EventToken" /> et est égal à l'instance actuelle.</summary>
      <param name="o">Objet à comparer à l'instance actuelle.</param>
      <returns>
        <see langword="true" /> si <paramref name="o" /> est une instance de <see langword="EventToken" /> et s'il est égal à l'instance en cours ; sinon <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.FullName">
      <summary>Obtient <see langword="null" /> dans tous les cas.</summary>
      <returns>Référence Null (<see langword="Nothing" /> en Visual Basic) dans tous les cas.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.GenericParameterAttributes">
      <summary>Obtient une combinaison d'indicateurs <see cref="T:System.Reflection.GenericParameterAttributes" /> qui décrivent la covariance et des contraintes spéciales du paramètre de type générique actuel.</summary>
      <returns>Combinaison d'opérations de bits de valeurs qui décrit la covariance et les contraintes spéciales du paramètre de type générique actuel.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.GenericParameterPosition">
      <summary>Obtient la position du paramètre de type dans la liste des paramètres de type du type générique ou de la méthode qui a déclaré le paramètre.</summary>
      <returns>Position du paramètre de type dans la liste des paramètres de type du type générique ou de la méthode qui a déclaré le paramètre.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetConstructors(System.Reflection.BindingFlags)">
      <summary>Non pris en charge pour les paramètres de type générique incomplets.</summary>
      <param name="bindingAttr">Non pris en charge.</param>
      <returns>Non pris en charge pour les paramètres de type générique incomplets.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Non pris en charge pour les paramètres de type générique incomplets.</summary>
      <param name="inherit">Spécifie s’il faut rechercher les attributs dans la chaîne d’héritage de ce membre.</param>
      <returns>Non pris en charge pour les paramètres de type générique incomplets.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Non pris en charge pour les paramètres de type générique incomplets.</summary>
      <param name="attributeType">Type d’attribut à rechercher. Seuls les attributs qui peuvent être assignés à ce type sont retournés.</param>
      <param name="inherit">Spécifie s’il faut rechercher les attributs dans la chaîne d’héritage de ce membre.</param>
      <returns>Non pris en charge pour les paramètres de type générique incomplets.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetElementType">
      <summary>Lève une exception <see cref="T:System.NotSupportedException" /> dans tous les cas.</summary>
      <returns>Type référencé par le type tableau, type pointeur ou type <see langword="ByRef" /> actuel ; ou <see langword="null" /> si le type actuel n’est pas un type tableau, n’est pas un type pointeur et n’est pas passé par référence.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
      <summary>Non pris en charge pour les paramètres de type générique incomplets.</summary>
      <param name="name">Non pris en charge.</param>
      <param name="bindingAttr">Non pris en charge.</param>
      <returns>Non pris en charge pour les paramètres de type générique incomplets.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetEvents">
      <summary>Non pris en charge pour les paramètres de type générique incomplets.</summary>
      <returns>Non pris en charge pour les paramètres de type générique incomplets.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetEvents(System.Reflection.BindingFlags)">
      <summary>Non pris en charge pour les paramètres de type générique incomplets.</summary>
      <param name="bindingAttr">Non pris en charge.</param>
      <returns>Non pris en charge pour les paramètres de type générique incomplets.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary>Non pris en charge pour les paramètres de type générique incomplets.</summary>
      <param name="name">Non pris en charge.</param>
      <param name="bindingAttr">Non pris en charge.</param>
      <returns>Non pris en charge pour les paramètres de type générique incomplets.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary>Non pris en charge pour les paramètres de type générique incomplets.</summary>
      <param name="bindingAttr">Non pris en charge.</param>
      <returns>Non pris en charge pour les paramètres de type générique incomplets.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetGenericArguments">
      <summary>Non valide pour les paramètres de type générique.</summary>
      <returns>Non valide pour les paramètres de type générique.</returns>
      <exception cref="T:System.InvalidOperationException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetGenericTypeDefinition">
      <summary>Non valide pour les paramètres de type générique.</summary>
      <returns>Non valide pour les paramètres de type générique.</returns>
      <exception cref="T:System.InvalidOperationException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetHashCode">
      <summary>Retourne un code de hachage entier 32 bits pour l'instance actuelle.</summary>
      <returns>Code de hachage entier 32 bits.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetInterface(System.String,System.Boolean)">
      <summary>Non pris en charge pour les paramètres de type générique incomplets.</summary>
      <param name="name">Nom de l’interface.</param>
      <param name="ignoreCase">
        <see langword="true" /> pour effectuer une recherche sans respecter la casse ; <see langword="false" /> pour effectuer une recherche en respectant la casse.</param>
      <returns>Non pris en charge pour les paramètres de type générique incomplets.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetInterfaceMap(System.Type)">
      <summary>Non pris en charge pour les paramètres de type générique incomplets.</summary>
      <param name="interfaceType">Objet <see cref="T:System.Type" /> qui représente le type d'interface dont le mappage doit être récupéré.</param>
      <returns>Non pris en charge pour les paramètres de type générique incomplets.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetInterfaces">
      <summary>Non pris en charge pour les paramètres de type générique incomplets.</summary>
      <returns>Non pris en charge pour les paramètres de type générique incomplets.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
      <summary>Non pris en charge pour les paramètres de type générique incomplets.</summary>
      <param name="name">Non pris en charge.</param>
      <param name="type">Non pris en charge.</param>
      <param name="bindingAttr">Non pris en charge.</param>
      <returns>Non pris en charge pour les paramètres de type générique incomplets.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetMembers(System.Reflection.BindingFlags)">
      <summary>Non pris en charge pour les paramètres de type générique incomplets.</summary>
      <param name="bindingAttr">Non pris en charge.</param>
      <returns>Non pris en charge pour les paramètres de type générique incomplets.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary>Non pris en charge pour les paramètres de type générique incomplets.</summary>
      <param name="bindingAttr">Non pris en charge.</param>
      <returns>Non pris en charge pour les paramètres de type générique incomplets.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
      <summary>Non pris en charge pour les paramètres de type générique incomplets.</summary>
      <param name="name">Non pris en charge.</param>
      <param name="bindingAttr">Non pris en charge.</param>
      <returns>Non pris en charge pour les paramètres de type générique incomplets.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
      <summary>Non pris en charge pour les paramètres de type générique incomplets.</summary>
      <param name="bindingAttr">Non pris en charge.</param>
      <returns>Non pris en charge pour les paramètres de type générique incomplets.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetProperties(System.Reflection.BindingFlags)">
      <summary>Non pris en charge pour les paramètres de type générique incomplets.</summary>
      <param name="bindingAttr">Non pris en charge.</param>
      <returns>Non pris en charge pour les paramètres de type générique incomplets.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.GUID">
      <summary>Non pris en charge pour les paramètres de type générique incomplets.</summary>
      <returns>Non pris en charge pour les paramètres de type générique incomplets.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
      <summary>Non pris en charge pour les paramètres de type générique incomplets.</summary>
      <param name="name">Non pris en charge.</param>
      <param name="invokeAttr">Non pris en charge.</param>
      <param name="binder">Non pris en charge.</param>
      <param name="target">Non pris en charge.</param>
      <param name="args">Non pris en charge.</param>
      <param name="modifiers">Non pris en charge.</param>
      <param name="culture">Non pris en charge.</param>
      <param name="namedParameters">Non pris en charge.</param>
      <returns>Non pris en charge pour les paramètres de type générique incomplets.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.IsAssignableFrom(System.Type)">
      <summary>Lève une exception <see cref="T:System.NotSupportedException" /> dans tous les cas.</summary>
      <param name="c">Objet à tester.</param>
      <returns>Lève une exception <see cref="T:System.NotSupportedException" /> dans tous les cas.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsByRefLike" />
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsConstructedGenericType">
      <summary>Obtient une valeur qui indique si cet objet représente un type générique construit.</summary>
      <returns>
        <see langword="true" /> si cet objet représente un type générique construit ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Non pris en charge pour les paramètres de type générique incomplets.</summary>
      <param name="attributeType">Non pris en charge.</param>
      <param name="inherit">Non pris en charge.</param>
      <returns>Non pris en charge pour les paramètres de type générique incomplets.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsGenericParameter">
      <summary>Obtient <see langword="true" /> dans tous les cas.</summary>
      <returns>
        <see langword="true" /> dans tous les cas.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsGenericType">
      <summary>Retourne <see langword="false" /> dans tous les cas.</summary>
      <returns>
        <see langword="false" /> dans tous les cas.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsGenericTypeDefinition">
      <summary>Obtient <see langword="false" /> dans tous les cas.</summary>
      <returns>
        <see langword="false" /> dans tous les cas.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.IsSubclassOf(System.Type)">
      <summary>Non pris en charge pour les paramètres de type générique incomplets.</summary>
      <param name="c">Non pris en charge.</param>
      <returns>Non pris en charge pour les paramètres de type générique incomplets.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsSZArray" />
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsTypeDefinition" />
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsVariableBoundArray" />
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeArrayType">
      <summary>Retourne le type d'un tableau unidimensionnel dont le type d'élément est le paramètre de type générique.</summary>
      <returns>Objet <see cref="T:System.Type" /> qui représente le type d’un tableau unidimensionnel dont le type d’élément est le paramètre de type générique.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeArrayType(System.Int32)">
      <summary>Retourne le type d'un tableau dont le type d'élément est le paramètre de type générique, avec le nombre spécifié de dimensions.</summary>
      <param name="rank">Nombre de dimensions pour le tableau.</param>
      <returns>Objet <see cref="T:System.Type" /> qui représente le type d’un tableau dont le type des éléments correspond au paramètre de type générique, avec le nombre spécifié de dimensions.</returns>
      <exception cref="T:System.IndexOutOfRangeException">
        <paramref name="rank" /> n’est pas un nombre de dimensions valide. Par exemple, sa valeur est inférieure à 1.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeByRefType">
      <summary>Retourne un objet <see cref="T:System.Type" /> représentant le paramètre de type générique actuel lorsqu'il est passé en tant que paramètre de référence.</summary>
      <returns>Objet <see cref="T:System.Type" /> qui représente le paramètre de type générique actuel quand il est passé comme paramètre de référence.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeGenericType(System.Type[])">
      <summary>Non valide pour les paramètres de type générique incomplets.</summary>
      <param name="typeArguments">Tableau d’arguments de type.</param>
      <returns>Cette méthode n'est pas valide pour les paramètres de type générique incomplets.</returns>
      <exception cref="T:System.InvalidOperationException">Dans tous les cas.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakePointerType">
      <summary>Retourne un objet <see cref="T:System.Type" /> représentant un pointeur vers le paramètre de type générique actuel.</summary>
      <returns>Objet <see cref="T:System.Type" /> qui représente un pointeur vers le paramètre de type générique actuel.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Module">
      <summary>Obtient le module dynamique qui contient le paramètre de type générique.</summary>
      <returns>Objet <see cref="T:System.Reflection.Module" /> qui représente le module dynamique contenant le paramètre de type générique.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Name">
      <summary>Obtient le nom du paramètre de type générique.</summary>
      <returns>Nom du paramètre de type générique.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Namespace">
      <summary>Obtient <see langword="null" /> dans tous les cas.</summary>
      <returns>Référence Null (<see langword="Nothing" /> en Visual Basic) dans tous les cas.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.ReflectedType">
      <summary>Obtient l'objet <see cref="T:System.Type" /> qui a été utilisé pour obtenir <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</summary>
      <returns>Objet <see cref="T:System.Type" /> qui a été utilisé pour obtenir <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetBaseTypeConstraint(System.Type)">
      <summary>Définit le type de base un type doit hériter afin d’être substitué au paramètre de type.</summary>
      <param name="baseTypeConstraint">
        <see cref="T:System.Type" /> devant être hérité par tout type qui sera substitué au paramètre de type.</param>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Définit un attribut personnalisé à l’aide d’un objet blob d’attribut personnalisé spécifié.</summary>
      <param name="con">Le constructeur de l’attribut personnalisé.</param>
      <param name="binaryAttribute">Objet blob d'octets représentant l'attribut.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> est <see langword="null" />.

ou -
<paramref name="binaryAttribute" /> est une référence null.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Définit un attribut personnalisé à l’aide d’un générateur d’attributs personnalisés.</summary>
      <param name="customBuilder">Instance de classe d'assistance qui définit l'attribut personnalisé.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes(System.Reflection.GenericParameterAttributes)">
      <summary>Définit les caractéristiques de variance et les contraintes spéciales du paramètre générique, telles que la contrainte de constructeur sans paramètre.</summary>
      <param name="genericParameterAttributes">Combinaison d'opérations de bits de valeurs <see cref="T:System.Reflection.GenericParameterAttributes" /> représentant les caractéristiques de variance et les contraintes spéciales du paramètre de type générique.</param>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetInterfaceConstraints(System.Type[])">
      <summary>Définit les interfaces qu’un type doit implémenter pour être substitué au paramètre de type.</summary>
      <param name="interfaceConstraints">Tableau d'objets <see cref="T:System.Type" /> représentant les interfaces qu'un type doit implémenter pour être substitué au paramètre de type.</param>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.ToString">
      <summary>Renvoie une représentation sous forme de chaîne du paramètre de type générique actuel.</summary>
      <returns>Chaîne contenant le nom du paramètre de type générique.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.TypeHandle">
      <summary>Non pris en charge pour les paramètres de type générique incomplets.</summary>
      <returns>Non pris en charge pour les paramètres de type générique incomplets.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.UnderlyingSystemType">
      <summary>Obtient le paramètre de type générique actuel.</summary>
      <returns>Objet <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> actuel.</returns>
    </member>
    <member name="T:System.Reflection.Emit.MethodBuilder">
      <summary>Définit et représente une méthode (ou un constructeur) sur une classe dynamique.</summary>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.Attributes">
      <summary>Récupère les attributs de cette méthode.</summary>
      <returns>Lecture seule. Récupère le <see langword="MethodAttributes" /> de cette méthode.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.CallingConvention">
      <summary>Retourne la convention d’appel de la méthode.</summary>
      <returns>Lecture seule. Convention d’appel de la méthode.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
      <summary>Non pris en charge pour ce type.</summary>
      <returns>Non pris en charge.</returns>
      <exception cref="T:System.NotSupportedException">La méthode appelée n’est pas prise en charge dans la classe de base.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.DeclaringType">
      <summary>Retourne le type qui déclare cette méthode.</summary>
      <returns>Lecture seule. Type qui déclare cette méthode.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
      <summary>Définit le nombre de paramètres de type générique pour la méthode actuelle, indique leur nom et retourne un tableau d’objets <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> pouvant être utilisés pour définir leurs contraintes.</summary>
      <param name="names">Tableau de chaînes qui représentent les noms des paramètres de type générique.</param>
      <returns>Tableau d’objets <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> représentant les paramètres de type de la méthode générique.</returns>
      <exception cref="T:System.InvalidOperationException">Des paramètres de type générique ont déjà été définis pour cette méthode.

ou -
La méthode a déjà été exécutée.

ou -
La méthode <see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" /> a été appelée pour la méthode actuelle.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="names" /> a la valeur <see langword="null" />.

ou -
Un élément de <paramref name="names" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="names" /> est un tableau vide.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
      <summary>Définit les attributs de paramètre et le nom d’un paramètre de cette méthode, ou de la valeur de retour de cette méthode. Retourne un ParameterBuilder qui peut être utilisé pour appliquer des attributs personnalisés.</summary>
      <param name="position">Position du paramètre dans la liste des paramètres. Les paramètres sont indexés en commençant par le numéro 1 pour le premier paramètre ; le numéro 0 représente la valeur de retour de la méthode.</param>
      <param name="attributes">Attributs du paramètre.</param>
      <param name="strParamName">Nom du paramètre. Le nom peut être la chaîne Null.</param>
      <returns>Retourne un objet <see langword="ParameterBuilder" /> qui représente un paramètre de cette méthode ou la valeur de retour de cette méthode.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">La méthode n'a pas de paramètre.

ou -
<paramref name="position" /> est inférieur à zéro.

ou -
<paramref name="position" /> est supérieur au nombre de paramètres de la méthode.</exception>
      <exception cref="T:System.InvalidOperationException">Le type conteneur a déjà été créé à l’aide de <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.

ou -
Pour la méthode actuelle, la propriété <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> est <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> est <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)">
      <summary>Détermine si l’objet spécifié est égal à cette instance.</summary>
      <param name="obj">Objet à comparer avec cette instance <see langword="MethodBuilder" />.</param>
      <returns>
        <see langword="true" /> si <paramref name="obj" /> est une instance de <see langword="MethodBuilder" /> et s’il est égal à cet objet ; sinon <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition">
      <summary>Retourne l’implémentation de base pour une méthode.</summary>
      <returns>Implémentation de base de cette méthode.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Retourne tous les attributs personnalisés définis pour cette méthode.</summary>
      <param name="inherit">Spécifie s’il faut rechercher les attributs personnalisés dans la chaîne d’héritage de ce membre.</param>
      <returns>Retourne un tableau d’objets représentant tous les attributs personnalisés de cette méthode.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge pour l’instant. Récupérez la méthode à l’aide de <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> et appelez <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> sur le <see cref="T:System.Reflection.MethodInfo" /> retourné.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Retourne les attributs personnalisés identifiés par le type donné.</summary>
      <param name="attributeType">Type d’attribut personnalisé.</param>
      <param name="inherit">Spécifie s’il faut rechercher les attributs personnalisés dans la chaîne d’héritage de ce membre.</param>
      <returns>Retourne un tableau d’objets représentant les attributs de cette méthode qui sont de type <paramref name="attributeType" />.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge pour l’instant. Récupérez la méthode à l’aide de <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> et appelez <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> sur le <see cref="T:System.Reflection.MethodInfo" /> retourné.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
      <summary>Retourne un tableau d’objets <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> qui représentent les paramètres de type de la méthode, si elle est générique.</summary>
      <returns>Tableau d’objets <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> représentant les paramètres de type, si la méthode est générique, ou <see langword="null" /> si la méthode n’est pas générique.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
      <summary>Retourne cette méthode.</summary>
      <returns>Instance actuelle de <see cref="T:System.Reflection.Emit.MethodBuilder" />.</returns>
      <exception cref="T:System.InvalidOperationException">La méthode actuelle n’est pas générique. Autrement dit, la propriété <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> retourne <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetHashCode">
      <summary>Obtient le code de hachage de cette méthode.</summary>
      <returns>Code de hachage de cette méthode.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
      <summary>Retourne un <see langword="ILGenerator" /> pour cette méthode avec une taille de flux MSIL (Microsoft Intermediate Language) par défaut de 64 octets.</summary>
      <returns>Retourne un objet <see langword="ILGenerator" /> pour cette méthode.</returns>
      <exception cref="T:System.InvalidOperationException">La méthode ne doit pas avoir de corps en raison de ses indicateurs <see cref="T:System.Reflection.MethodAttributes" /> ou <see cref="T:System.Reflection.MethodImplAttributes" /> (par exemple, l’indicateur <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" />).

ou -
La méthode est une méthode générique, mais pas une définition de méthode générique. Autrement dit, la propriété <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> a la valeur <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
      <summary>Retourne un <see langword="ILGenerator" /> pour cette méthode avec la taille du flux MSIL (Microsoft Intermediate Language) spécifiée.</summary>
      <param name="size">Taille du flux MSIL, en octets.</param>
      <returns>Retourne un objet <see langword="ILGenerator" /> pour cette méthode.</returns>
      <exception cref="T:System.InvalidOperationException">La méthode ne doit pas avoir de corps en raison de ses indicateurs <see cref="T:System.Reflection.MethodAttributes" /> ou <see cref="T:System.Reflection.MethodImplAttributes" /> (par exemple, l’indicateur <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" />).

ou -
La méthode est une méthode générique, mais pas une définition de méthode générique. Autrement dit, la propriété <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> a la valeur <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags">
      <summary>Retourne les indicateurs d’implémentation pour la méthode.</summary>
      <returns>Retourne les indicateurs d’implémentation pour la méthode.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetParameters">
      <summary>Retourne les paramètres de cette méthode.</summary>
      <returns>Tableau d’objets <see langword="ParameterInfo" /> qui représentent les paramètres de la méthode.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge pour l’instant. Récupérez la méthode à l’aide de <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> et appelez <see langword="GetParameters" /> sur le <see cref="T:System.Reflection.MethodInfo" /> retourné.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.InitLocals">
      <summary>Obtient ou définit une valeur booléenne qui indique si les variables locales de la méthode sont initialisées à zéro. La valeur par défaut de cette propriété est <see langword="true" />.</summary>
      <returns>
        <see langword="true" /> si les variables locales dans la méthode doivent être initialisées à zéro ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.InvalidOperationException">Pour la méthode actuelle, la propriété <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> est <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> est <see langword="false" />. (Get ou set).</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>Appelle de manière dynamique la méthode réfléchie par cette instance sur l’objet donné, en passant les paramètres spécifiés et en tenant compte des contraintes du binder donné.</summary>
      <param name="obj">Objet sur lequel appeler la méthode spécifiée. Si la méthode est statique, ce paramètre est ignoré.</param>
      <param name="invokeAttr">Il doit s’agir d’un bit indicateur issu de <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <param name="binder">Objet qui active la liaison, la contrainte de types d’arguments, l’appel des membres et la récupération des objets MemberInfo par le biais de la réflexion. Si binder a la valeur <see langword="null" />, le binder par défaut est utilisé. Pour plus d'informations, consultez <see cref="T:System.Reflection.Binder" />.</param>
      <param name="parameters">Liste d’arguments. Il s’agit d’un tableau d’arguments possédant les mêmes nombre, ordre et type que les paramètres de la méthode à appeler. En l’absence de paramètres, ce paramètre doit être <see langword="null" />.</param>
      <param name="culture">Instance de <see cref="T:System.Globalization.CultureInfo" /> utilisée pour régir la contrainte des types. Si la valeur est null, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé. (Cela est nécessaire, par exemple, pour convertir un <see cref="T:System.String" /> représentant 1000 en valeur <see cref="T:System.Double" />, car 1000 est représenté de différentes manières selon la culture.)</param>
      <returns>Retourne un objet contenant la valeur de retour de la méthode appelée.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge pour l’instant. Récupérez la méthode à l’aide de <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> et appelez <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> sur le <see cref="T:System.Reflection.MethodInfo" /> retourné.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsConstructedGenericMethod" />
    <member name="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Vérifie si le type d’attribut personnalisé spécifié est défini.</summary>
      <param name="attributeType">Type d’attribut personnalisé.</param>
      <param name="inherit">Spécifie s’il faut rechercher les attributs personnalisés dans la chaîne d’héritage de ce membre.</param>
      <returns>
        <see langword="true" /> si le type d’attribut personnalisé spécifié est défini ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge pour l’instant. Récupérez la méthode à l’aide de <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> et appelez <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> sur le <see cref="T:System.Reflection.MethodInfo" /> retourné.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
      <summary>Obtient une valeur indiquant si la méthode est une méthode générique.</summary>
      <returns>
        <see langword="true" /> si la méthode est générique ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
      <summary>Obtient une valeur indiquant si l’objet <see cref="T:System.Reflection.Emit.MethodBuilder" /> actuel représente la définition d’une méthode générique.</summary>
      <returns>
        <see langword="true" /> si l’objet <see cref="T:System.Reflection.Emit.MethodBuilder" /> actuel représente la définition d’une méthode générique ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
      <summary>Lève une exception <see cref="T:System.NotSupportedException" /> dans tous les cas.</summary>
      <returns>Lève une exception <see cref="T:System.NotSupportedException" /> dans tous les cas.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas. Cette propriété n’est pas pris en charge dans les assemblys dynamiques.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
      <summary>Lève une exception <see cref="T:System.NotSupportedException" /> dans tous les cas.</summary>
      <returns>Lève une exception <see cref="T:System.NotSupportedException" /> dans tous les cas.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas. Cette propriété n’est pas pris en charge dans les assemblys dynamiques.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
      <summary>Lève une exception <see cref="T:System.NotSupportedException" /> dans tous les cas.</summary>
      <returns>Lève une exception <see cref="T:System.NotSupportedException" /> dans tous les cas.</returns>
      <exception cref="T:System.NotSupportedException">Dans tous les cas. Cette propriété n’est pas pris en charge dans les assemblys dynamiques.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
      <summary>Retourne une méthode générique construite à partir de la définition de méthode générique actuelle avec les arguments de type générique spécifiés.</summary>
      <param name="typeArguments">Tableau d’objets <see cref="T:System.Type" /> qui représentent les arguments de type de la méthode générique.</param>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode générique construite à partir de la définition de méthode générique actuelle avec les arguments de type générique spécifiés.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
      <summary>Récupère le handle interne de la méthode. Utilisez ce handle pour accéder au handle des métadonnées sous-jacentes.</summary>
      <returns>Lecture seule. Handle interne de la méthode. Utilisez ce handle pour accéder au handle des métadonnées sous-jacentes.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge pour l’instant. Récupérez la méthode à l’aide de <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> et appelez <see cref="P:System.Reflection.MethodBase.MethodHandle" /> sur le <see cref="T:System.Reflection.MethodInfo" /> retourné.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.Module">
      <summary>Obtient le module dans lequel la méthode actuelle est définie.</summary>
      <returns>
        <see cref="T:System.Reflection.Module" /> dans lequel le membre représenté par les <see cref="T:System.Reflection.MemberInfo" /> actuelles est défini.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.Name">
      <summary>Récupère le nom de cette méthode.</summary>
      <returns>Lecture seule. Récupère une chaîne contenant le nom simple de cette méthode.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReflectedType">
      <summary>Récupère la classe qui a été utilisée dans la réflexion pour obtenir cet objet.</summary>
      <returns>Lecture seule. Le type qui a été utilisé pour obtenir cette méthode.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReturnParameter">
      <summary>Obtient un objet <see cref="T:System.Reflection.ParameterInfo" /> qui contient des informations relatives au type de retour de la méthode, telles que la présence de modificateurs personnalisés.</summary>
      <returns>Objet <see cref="T:System.Reflection.ParameterInfo" /> qui contient des informations sur le type de retour.</returns>
      <exception cref="T:System.InvalidOperationException">Le type déclarant n’a pas été créé.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReturnType">
      <summary>Obtient le type de retour de la méthode représentée par ce <see cref="T:System.Reflection.Emit.MethodBuilder" />.</summary>
      <returns>Type de retour de la méthode.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
      <summary>Retourne les attributs personnalisés du type de retour de la méthode.</summary>
      <returns>Lecture seule. Attributs personnalisés du type de retour de la méthode.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Définit un attribut personnalisé à l’aide d’un objet blob d’attribut personnalisé spécifié.</summary>
      <param name="con">Le constructeur de l’attribut personnalisé.</param>
      <param name="binaryAttribute">Objet blob d’octets représentant les attributs.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Pour la méthode actuelle, la propriété <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> est <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> est <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Définit un attribut personnalisé à l’aide d’un générateur d’attributs personnalisés.</summary>
      <param name="customBuilder">Instance d’une classe d’assistance pour décrire l’attribut personnalisé.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Pour la méthode actuelle, la propriété <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> est <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> est <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
      <summary>Définit les indicateurs d’implémentation de cette méthode.</summary>
      <param name="attributes">Indicateurs d’implémentation à définir.</param>
      <exception cref="T:System.InvalidOperationException">Le type conteneur a déjà été créé à l’aide de <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.

ou -
Pour la méthode actuelle, la propriété <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> est <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> est <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
      <summary>Définit le nombre et les types des paramètres d’une méthode.</summary>
      <param name="parameterTypes">Tableau d’objets <see cref="T:System.Type" /> représentant les types des paramètres.</param>
      <exception cref="T:System.InvalidOperationException">La méthode actuelle est générique, mais n’est pas une définition de méthode générique. Autrement dit, la propriété <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> a la valeur <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
      <summary>Définit le type de retour de la méthode.</summary>
      <param name="returnType">Objet <see cref="T:System.Type" /> qui représente le type de retour de la méthode.</param>
      <exception cref="T:System.InvalidOperationException">La méthode actuelle est générique, mais n’est pas une définition de méthode générique. Autrement dit, la propriété <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> a la valeur <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>Définit la signature de la méthode, y compris le type de retour, les types de paramètres, ainsi que les modificateurs personnalisés requis et facultatifs du type de retour et des types de paramètres.</summary>
      <param name="returnType">Type de retour de la méthode.</param>
      <param name="returnTypeRequiredCustomModifiers">Tableau de types représentant les modificateurs personnalisés requis, tels qu’<see cref="T:System.Runtime.CompilerServices.IsConst" />, pour le type de retour de la méthode. Si le type de retour ne possède pas de modificateur personnalisé requis, spécifiez <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers">Tableau de types représentant les modificateurs personnalisés facultatifs, tels qu’<see cref="T:System.Runtime.CompilerServices.IsConst" />, pour le type de retour de la méthode. Si le type de retour ne possède pas de modificateur personnalisé facultatif, spécifiez <see langword="null" />.</param>
      <param name="parameterTypes">Types des paramètres de la méthode.</param>
      <param name="parameterTypeRequiredCustomModifiers">Tableau de tableaux de types. Chaque tableau de types représente les modificateurs personnalisés obligatoires pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un paramètre particulier ne possède pas de modificateurs personnalisés obligatoires, spécifiez <see langword="null" /> plutôt qu’un tableau de types. Si aucun paramètre ne possède de modificateur personnalisé requis, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</param>
      <param name="parameterTypeOptionalCustomModifiers">Tableau de tableaux de types. Chaque tableau de types représente les modificateurs personnalisés facultatifs pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un paramètre particulier ne possède pas de modificateurs personnalisés facultatifs, spécifiez <see langword="null" /> plutôt qu’un tableau de types. Si aucun paramètre ne possède de modificateur personnalisé facultatif, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</param>
      <exception cref="T:System.InvalidOperationException">La méthode actuelle est générique, mais n’est pas une définition de méthode générique. Autrement dit, la propriété <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> a la valeur <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.ToString">
      <summary>Retourne cette instance <see langword="MethodBuilder" /> sous forme de chaîne.</summary>
      <returns>Retourne une chaîne contenant le nom, les attributs, la signature de méthode, les exceptions et la signature locale de cette méthode, suivis du flux MSIL (Microsoft Intermediate Language) actuel.</returns>
    </member>
    <member name="T:System.Reflection.Emit.ModuleBuilder">
      <summary>Définit et représente un module dans un assembly dynamique.</summary>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.Assembly">
      <summary>Obtient l'assembly dynamique qui a défini cette instance de <see cref="T:System.Reflection.Emit.ModuleBuilder" />.</summary>
      <returns>Assembly dynamique qui a défini le module dynamique actuel.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
      <summary>Complète les définitions de fonction globale et les définitions de données globales pour ce module dynamique.</summary>
      <exception cref="T:System.InvalidOperationException">Cette méthode a été appelée au préalable.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
      <summary>Définit un type d'énumération qui est un type valeur avec un champ non statique unique appelé <paramref name="value__" /> du type spécifié.</summary>
      <param name="name">Chemin d'accès complet du type d'énumération. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="visibility">Attributs de type pour l'énumération. Un attribut correspond à n'importe quel octet défini par <see cref="F:System.Reflection.TypeAttributes.VisibilityMask" />.</param>
      <param name="underlyingType">Type sous-jacent pour l'énumération. Ce doit être un type entier intégré.</param>
      <returns>Énumération définie.</returns>
      <exception cref="T:System.ArgumentException">Des attributs autres que des attributs de visibilité sont fournis.

ou -
Une énumération portant le nom donné existe dans l'assembly parent de ce module.

ou -
Les attributs de visibilité ne correspondent pas à la portée de l'énumération. Par exemple, si <see cref="F:System.Reflection.TypeAttributes.NestedPublic" /> est spécifié pour <paramref name="visibility" /> alors que l'énumération n'est pas de type imbriqué.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary>Définit une méthode globale à l'aide du nom, des attributs, de la convention d'appel, du type de retour et des types de paramètres spécifiés.</summary>
      <param name="name">Nom de la méthode. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="attributes">Attributs de la méthode. <paramref name="attributes" /> doit inclure <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
      <param name="callingConvention">Convention d’appel de la méthode.</param>
      <param name="returnType">Type de retour de la méthode.</param>
      <param name="parameterTypes">Types des paramètres de la méthode.</param>
      <returns>Méthode globale définie.</returns>
      <exception cref="T:System.ArgumentException">La méthode n’est pas statique. C'est-à-dire que <paramref name="attributes" /> n'inclut pas <see cref="F:System.Reflection.MethodAttributes.Static" />.

ou -
Un élément du tableau <see cref="T:System.Type" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> a été appelé précédemment.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>Définit une méthode globale à l'aide du nom, des attributs, de la convention d'appel, du type de retour, des modificateurs personnalisés pour le type de retour, des types de paramètres et des modificateurs personnalisés pour les types de paramètres spécifiés.</summary>
      <param name="name">Nom de la méthode. <paramref name="name" /> ne peut pas contenir de caractères Null incorporés.</param>
      <param name="attributes">Attributs de la méthode. <paramref name="attributes" /> doit inclure <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
      <param name="callingConvention">Convention d’appel de la méthode.</param>
      <param name="returnType">Type de retour de la méthode.</param>
      <param name="requiredReturnTypeCustomModifiers">Tableau des types représentant les modificateurs personnalisés requis pour le type de retour, tels que <see cref="T:System.Runtime.CompilerServices.IsConst" /> ou <see cref="T:System.Runtime.CompilerServices.IsBoxed" />. Si le type de retour ne possède pas de modificateur personnalisé requis, spécifiez <see langword="null" />.</param>
      <param name="optionalReturnTypeCustomModifiers">Tableau des types représentant les modificateurs personnalisés facultatifs pour le type de retour, tels que <see cref="T:System.Runtime.CompilerServices.IsConst" /> ou <see cref="T:System.Runtime.CompilerServices.IsBoxed" />. Si le type de retour ne possède pas de modificateur personnalisé facultatif, spécifiez <see langword="null" />.</param>
      <param name="parameterTypes">Types des paramètres de la méthode.</param>
      <param name="requiredParameterTypeCustomModifiers">Tableau de tableaux de types. Chaque tableau de types représente les modificateurs personnalisés requis pour le paramètre correspondant de la méthode globale. Si un argument particulier ne possède pas de modificateur personnalisé requis, spécifiez <see langword="null" /> plutôt qu'un tableau de types. Si la méthode globale ne possède pas d'argument, ou si aucun des arguments ne possède de modificateur personnalisé requis, spécifiez <see langword="null" /> plutôt qu'un tableau de tableaux.</param>
      <param name="optionalParameterTypeCustomModifiers">Tableau de tableaux de types. Chaque tableau de types représente les modificateurs personnalisés facultatifs pour le paramètre correspondant. Si un argument particulier ne possède pas de modificateur personnalisé facultatif, spécifiez <see langword="null" /> plutôt qu'un tableau de types. Si la méthode globale ne possède pas d'argument, ou si aucun des arguments ne possède de modificateur personnalisé facultatif, spécifiez <see langword="null" /> plutôt qu'un tableau de tableaux.</param>
      <returns>Méthode globale définie.</returns>
      <exception cref="T:System.ArgumentException">La méthode n’est pas statique. C'est-à-dire que <paramref name="attributes" /> n'inclut pas <see cref="F:System.Reflection.MethodAttributes.Static" />.

ou -
Un élément du tableau <see cref="T:System.Type" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">La méthode <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> a été appelée au préalable.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
      <summary>Définit une méthode globale à l'aide du nom, des attributs, du type de retour et des types de paramètres spécifiés.</summary>
      <param name="name">Nom de la méthode. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="attributes">Attributs de la méthode. <paramref name="attributes" /> doit inclure <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
      <param name="returnType">Type de retour de la méthode.</param>
      <param name="parameterTypes">Types des paramètres de la méthode.</param>
      <returns>Méthode globale définie.</returns>
      <exception cref="T:System.ArgumentException">La méthode n’est pas statique. C'est-à-dire que <paramref name="attributes" /> n'inclut pas <see cref="F:System.Reflection.MethodAttributes.Static" />.

ou -
La longueur de <paramref name="name" /> est égale à zéro.
ou -
Un élément du tableau <see cref="T:System.Type" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> a été appelé précédemment.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
      <summary>Définit un champ de données initialisé dans la section .sdata du fichier exécutable portable.</summary>
      <param name="name">Nom utilisé pour faire référence aux données. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="data">Objet BLOB de données.</param>
      <param name="attributes">Attributs du champ. La valeur par défaut est <see langword="Static" />.</param>
      <returns>Champ pour référencer les données.</returns>
      <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.

ou -
La taille de <paramref name="data" /> est inférieure ou égale à zéro, ou supérieure ou égale à 0x3f0000.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ou <paramref name="data" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> a été appelé précédemment.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary>Définit une méthode <see langword="PInvoke" /> à l'aide du nom, du nom de la DLL dans laquelle la méthode a été définie, des attributs de la méthode, de la convention d'appel, du type de retour, des types de paramètres et des indicateurs <see langword="PInvoke" /> spécifiés.</summary>
      <param name="name">Nom de la méthode <see langword="PInvoke" />. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="dllName">Nom de la DLL dans laquelle la méthode <see langword="PInvoke" /> est définie.</param>
      <param name="attributes">Attributs de la méthode.</param>
      <param name="callingConvention">Convention d’appel de la méthode.</param>
      <param name="returnType">Type de retour de la méthode.</param>
      <param name="parameterTypes">Types des paramètres de la méthode.</param>
      <param name="nativeCallConv">Convention d’appel native.</param>
      <param name="nativeCharSet">Jeu de caractères natif de la méthode.</param>
      <returns>Méthode <see langword="PInvoke" /> définie.</returns>
      <exception cref="T:System.ArgumentException">La méthode n'est pas statique ou le type conteneur est une interface.

ou -

La méthode est de type abstract.

ou -

La méthode a déjà été définie.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ou <paramref name="dllName" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le type conteneur a été créé au préalable à l'aide de la méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary>Définit une méthode <see langword="PInvoke" /> à l'aide du nom, du nom de la DLL dans laquelle la méthode a été définie, des attributs de la méthode, de la convention d'appel, du type de retour, des types de paramètres et des indicateurs <see langword="PInvoke" /> spécifiés.</summary>
      <param name="name">Nom de la méthode <see langword="PInvoke" />. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="dllName">Nom de la DLL dans laquelle la méthode <see langword="PInvoke" /> est définie.</param>
      <param name="entryName">Nom du point d’entrée dans la DLL.</param>
      <param name="attributes">Attributs de la méthode.</param>
      <param name="callingConvention">Convention d’appel de la méthode.</param>
      <param name="returnType">Type de retour de la méthode.</param>
      <param name="parameterTypes">Types des paramètres de la méthode.</param>
      <param name="nativeCallConv">Convention d’appel native.</param>
      <param name="nativeCharSet">Jeu de caractères natif de la méthode.</param>
      <returns>Méthode <see langword="PInvoke" /> définie.</returns>
      <exception cref="T:System.ArgumentException">La méthode n'est pas statique, le type conteneur est une interface, la méthode est abstraite ou elle a été définie au préalable.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ou <paramref name="dllName" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le type conteneur a été créé au préalable à l'aide de la méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
      <summary>Construit un <see langword="TypeBuilder" /> pour un type privé portant le nom spécifié dans ce module.</summary>
      <param name="name">Chemin d'accès complet du type, espace de noms compris. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <returns>Type privé portant le nom spécifié.</returns>
      <exception cref="T:System.ArgumentException">Un type portant le nom donné existe dans l'assembly parent de ce module.

ou -

Des attributs de type imbriqué sont définis sur un type non imbriqué.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
      <summary>Construit un <see langword="TypeBuilder" /> en fonction du nom et des attributs du type.</summary>
      <param name="name">Chemin d'accès complet du type. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="attr">Attributs du type défini.</param>
      <returns>
        <see langword="TypeBuilder" /> créé avec tous les attributs demandés.</returns>
      <exception cref="T:System.ArgumentException">Un type portant le nom donné existe dans l'assembly parent de ce module.

ou -

Des attributs de type imbriqué sont définis sur un type non imbriqué.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
      <summary>Construit un <see langword="TypeBuilder" /> en fonction du nom et des attributs du type, ainsi que du type que le type défini étend.</summary>
      <param name="name">Chemin d'accès complet du type. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="attr">Attribut à associer au type.</param>
      <param name="parent">Type étendu par le type défini.</param>
      <returns>
        <see langword="TypeBuilder" /> créé avec tous les attributs demandés.</returns>
      <exception cref="T:System.ArgumentException">Un type portant le nom donné existe dans l'assembly parent de ce module.

ou -

Des attributs de type imbriqué sont définis sur un type non imbriqué.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
      <summary>Construit un <see langword="TypeBuilder" /> en fonction du nom et des attributs du type, du type étendu par le type défini et de la taille totale du type.</summary>
      <param name="name">Chemin d'accès complet du type. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="attr">Attributs du type défini.</param>
      <param name="parent">Type étendu par le type défini.</param>
      <param name="typesize">Taille totale du type.</param>
      <returns>Objet <see langword="TypeBuilder" />.</returns>
      <exception cref="T:System.ArgumentException">Un type portant le nom donné existe dans l'assembly parent de ce module.

ou -

Des attributs de type imbriqué sont définis sur un type non imbriqué.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
      <summary>Construit un <see langword="TypeBuilder" /> en fonction du nom et des attributs du type, du type étendu par le type défini et de la taille de compactage du type.</summary>
      <param name="name">Chemin d'accès complet du type. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="attr">Attributs du type défini.</param>
      <param name="parent">Type étendu par le type défini.</param>
      <param name="packsize">Taille de compression du type.</param>
      <returns>Objet <see langword="TypeBuilder" />.</returns>
      <exception cref="T:System.ArgumentException">Un type portant le nom donné existe dans l'assembly parent de ce module.

ou -

Des attributs de type imbriqué sont définis sur un type non imbriqué.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
      <summary>Construit un <see langword="TypeBuilder" /> en fonction du nom et des attributs du type, du type étendu par le type défini, de la taille de compactage et de la taille totale du type défini.</summary>
      <param name="name">Chemin d'accès complet du type. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="attr">Attributs du type défini.</param>
      <param name="parent">Type étendu par le type défini.</param>
      <param name="packingSize">Taille de compression du type.</param>
      <param name="typesize">Taille totale du type.</param>
      <returns>
        <see langword="TypeBuilder" /> créé avec tous les attributs demandés.</returns>
      <exception cref="T:System.ArgumentException">Un type portant le nom donné existe dans l'assembly parent de ce module.

ou -

Des attributs de type imbriqué sont définis sur un type non imbriqué.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
      <summary>Construit un <see langword="TypeBuilder" /> en fonction du nom et des attributs du type, du type étendu par le type défini et de l'interface implémentée par le type défini.</summary>
      <param name="name">Chemin d'accès complet du type. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="attr">Attributs à associer au type.</param>
      <param name="parent">Type étendu par le type défini.</param>
      <param name="interfaces">Liste des interfaces implémentées par le type.</param>
      <returns>
        <see langword="TypeBuilder" /> créé avec tous les attributs demandés.</returns>
      <exception cref="T:System.ArgumentException">Un type portant le nom donné existe dans l'assembly parent de ce module.

ou -

Des attributs de type imbriqué sont définis sur un type non imbriqué.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
      <summary>Définit un champ de données non initialisé dans la section .sdata du fichier exécutable portable (PE, Portable Executable).</summary>
      <param name="name">Nom utilisé pour faire référence aux données. <paramref name="name" /> ne peut pas contenir des valeurs Null imbriquées.</param>
      <param name="size">Taille du champ de données.</param>
      <param name="attributes">Attributs du champ.</param>
      <returns>Champ pour référencer les données.</returns>
      <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.

ou -
<paramref name="size" /> est inférieur ou égal à zéro, ou supérieur ou égal à 0x003f0000.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> a été appelé précédemment.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.Equals(System.Object)">
      <summary>Retourne une valeur qui indique si cette instance équivaut à l’objet spécifié.</summary>
      <param name="obj">Objet à comparer à cette instance ou <see langword="null" />.</param>
      <returns>
        <see langword="true" /> si <paramref name="obj" /> est égal au type et à la valeur de cette instance ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName">
      <summary>Obtient un <see langword="String" /> représentant le nom et le chemin d'accès complets de ce module.</summary>
      <returns>Nom qualifié complet du module.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary>Retourne la méthode nommée sur une classe Array.</summary>
      <param name="arrayClass">Classe Array.</param>
      <param name="methodName">Nom d'une méthode sur la classe Array.</param>
      <param name="callingConvention">Convention d’appel de la méthode.</param>
      <param name="returnType">Type de retour de la méthode.</param>
      <param name="parameterTypes">Types des paramètres de la méthode.</param>
      <returns>Méthode nommée sur une classe Array.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="arrayClass" /> n'est pas un tableau.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="arrayClass" /> ou <paramref name="methodName" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Retourne tous les attributs personnalisés qui ont été appliqués au <see cref="T:System.Reflection.Emit.ModuleBuilder" /> actuel.</summary>
      <param name="inherit">Cet argument est ignoré pour les objets de ce type.</param>
      <returns>Un tableau qui contient les attributs personnalisés ; le tableau est vide s’il n’existe pas d’attributs.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Retourne tous les attributs personnalisés qui ont été appliqués à l’élément <see cref="T:System.Reflection.Emit.ModuleBuilder" /> actuel et qui dérivent d’un type d’attribut spécifié.</summary>
      <param name="attributeType">Type de base duquel dérivent des attributs.</param>
      <param name="inherit">Cet argument est ignoré pour les objets de ce type.</param>
      <returns>Tableau qui contient les attributs personnalisés dérivés (à tous les niveaux) de <paramref name="attributeType" /> ; le tableau est vide si de tels attributs n'existent pas.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributeType" /> n’est pas un objet <see cref="T:System.Type" /> fourni par le runtime. Par exemple, <paramref name="attributeType" /> est un objet <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData">
      <summary>Retourne des informations sur les attributs appliqués au <see cref="T:System.Reflection.Emit.ModuleBuilder" /> actuel, en tant qu'objets <see cref="T:System.Reflection.CustomAttributeData" />.</summary>
      <returns>Liste générique d’objets <see cref="T:System.Reflection.CustomAttributeData" /> représentant des données sur les attributs qui ont été appliqués au module actuel.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary>Retourne un champ au niveau du module, défini dans la région .sdata du fichier exécutable portable (PE, Portable Executable) ayant le nom et les attributs de liaison spécifiés.</summary>
      <param name="name">Nom du champ.</param>
      <param name="bindingAttr">Combinaison des bits indicateurs <see langword="BindingFlags" /> utilisés pour contrôler la recherche.</param>
      <returns>Champ ayant le nom et les attributs de liaison spécifiés, ou <see langword="null" /> si le champ n'existe pas.</returns>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary>Retourne tous les champs définis dans la région .sdata du fichier exécutable portable (PE) qui correspondent aux indicateurs de liaisons spécifiés.</summary>
      <param name="bindingFlags">Combinaison des bits indicateurs <see langword="BindingFlags" /> utilisés pour contrôler la recherche.</param>
      <returns>Tableau des champs qui correspondent aux indicateurs spécifiés ; le tableau est vide si de tels champs n'existent pas.</returns>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetHashCode">
      <summary>Retourne le code de hachage de cette instance.</summary>
      <returns>Code de hachage d'un entier signé 32 bits.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary>Retourne toutes les méthodes définies au niveau du module pour le <see cref="T:System.Reflection.Emit.ModuleBuilder" /> actuel et qui correspondent aux indicateurs de liaisons spécifiés.</summary>
      <param name="bindingFlags">Combinaison des bits indicateurs <see langword="BindingFlags" /> utilisés pour contrôler la recherche.</param>
      <returns>Tableau qui contient toutes les méthodes au niveau du module correspondant à <paramref name="bindingFlags" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
      <summary>Obtient une paire de valeurs indiquant la nature du code dans un module et la plateforme ciblée par le module.</summary>
      <param name="peKind">Cette méthode retourne une combinaison des valeurs <see cref="T:System.Reflection.PortableExecutableKinds" /> indiquant la nature du code dans le module.</param>
      <param name="machine">Cette méthode retourne une des valeurs <see cref="T:System.Reflection.ImageFileMachine" /> indiquant la plateforme ciblée par le module.</param>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
      <summary>Obtient le type nommé défini dans le module.</summary>
      <param name="className">Nom du <see cref="T:System.Type" /> à obtenir.</param>
      <returns>Type demandé, si le type est défini dans ce module ; sinon, <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentException">La longueur de <paramref name="className" /> est égale à zéro ou supérieure à 1 023.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="className" /> est <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">Le <see cref="T:System.Type" /> demandé est non public et l'appelant n'a pas <see cref="T:System.Security.Permissions.ReflectionPermission" /> pour réfléchir les objets non publics en dehors de l'assembly en cours.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Un initialiseur de classe est appelé et lève une exception.</exception>
      <exception cref="T:System.TypeLoadException">Une erreur s'est produite pendant le chargement de <see cref="T:System.Type" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
      <summary>Obtient le type nommé défini dans le module en ignorant éventuellement la casse du nom de type.</summary>
      <param name="className">Nom du <see cref="T:System.Type" /> à obtenir.</param>
      <param name="ignoreCase">Si <see langword="true" />, la recherche ne respecte pas la casse. Si <see langword="false" />, la recherche respecte la casse.</param>
      <returns>Type demandé, si le type est défini dans ce module ; sinon, <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentException">La longueur de <paramref name="className" /> est égale à zéro ou supérieure à 1 023.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="className" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">Le <see cref="T:System.Type" /> demandé est non public et l'appelant n'a pas <see cref="T:System.Security.Permissions.ReflectionPermission" /> pour réfléchir les objets non publics en dehors de l'assembly en cours.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Un initialiseur de classe est appelé et lève une exception.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
      <summary>Obtient le type nommé défini dans le module en ignorant éventuellement la casse du nom de type. Peut lever une exception, si le type est introuvable.</summary>
      <param name="className">Nom du <see cref="T:System.Type" /> à obtenir.</param>
      <param name="throwOnError">
        <see langword="true" /> pour lever une exception si le type est introuvable ; <see langword="false" /> pour retourner <see langword="null" />.</param>
      <param name="ignoreCase">Si <see langword="true" />, la recherche ne respecte pas la casse. Si <see langword="false" />, la recherche respecte la casse.</param>
      <returns>Type spécifié, si le type est déclaré dans ce module ; sinon, <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentException">La longueur de <paramref name="className" /> est égale à zéro ou supérieure à 1 023.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="className" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">Le <see cref="T:System.Type" /> demandé est non public et l'appelant n'a pas <see cref="T:System.Security.Permissions.ReflectionPermission" /> pour réfléchir les objets non publics en dehors de l'assembly en cours.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Un initialiseur de classe est appelé et lève une exception.</exception>
      <exception cref="T:System.TypeLoadException">
        <paramref name="throwOnError" /> a la valeur <see langword="true" /> et le type spécifié est introuvable.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
      <summary>Retourne toutes les classes définies dans ce module.</summary>
      <returns>Tableau qui contient les types définis dans le module réfléchi par cette instance.</returns>
      <exception cref="T:System.Reflection.ReflectionTypeLoadException">Au moins une des classes d’un module n’a pas pu être chargée.</exception>
      <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Retourne une valeur qui indique si le type d'attribut spécifié a été appliqué à ce module.</summary>
      <param name="attributeType">Type de l'attribut personnalisé à tester.</param>
      <param name="inherit">Cet argument est ignoré pour les objets de ce type.</param>
      <returns>
        <see langword="true" /> si une ou plusieurs instances de <paramref name="attributeType" /> ont été appliquées à ce module ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributeType" /> n’est pas un objet <see cref="T:System.Type" /> fourni par le runtime. Par exemple, <paramref name="attributeType" /> est un objet <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.IsResource">
      <summary>Obtient une valeur indiquant si l'objet est une ressource.</summary>
      <returns>
        <see langword="true" /> si l'objet est une ressource ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion">
      <summary>Obtient la version de flux des métadonnées.</summary>
      <returns>Entier 32 bits représentant la version de flux des métadonnées. Les deux octets de poids fort représentent le numéro de la version principale, et les deux octets de poids faible représentent le numéro de la version secondaire.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.MetadataToken">
      <summary>Obtient un jeton qui identifie le module dynamique actuel dans les métadonnées.</summary>
      <returns>Jeton d'entier qui identifie le module actuel dans les métadonnées.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId">
      <summary>Obtient un identificateur unique universel (UUID) qui peut être utilisé pour faire la distinction entre deux versions d’un module.</summary>
      <returns>
        <see cref="T:System.Guid" /> qui peut être utilisé pour faire la distinction entre deux versions d’un module.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.Name">
      <summary>Chaîne qui indique qu'il s'agit d'un module en mémoire.</summary>
      <returns>Texte qui indique qu'il s'agit d'un module en mémoire.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
      <summary>Retourne le champ identifié par le jeton de métadonnées spécifié dans le contexte défini par les paramètres de type générique spécifiés.</summary>
      <param name="metadataToken">Jeton de métadonnées qui identifie un champ dans le module.</param>
      <param name="genericTypeArguments">Tableau d'objets <see cref="T:System.Type" /> représentant les arguments de type générique du type pour lequel le jeton est dans la portée, ou <see langword="null" /> si ce type n'est pas générique.</param>
      <param name="genericMethodArguments">Tableau d'objets <see cref="T:System.Type" /> représentant les arguments de type générique de la méthode pour laquelle le jeton est dans la portée, ou <see langword="null" /> si cette méthode n'est pas générique.</param>
      <returns>Objet <see cref="T:System.Reflection.FieldInfo" /> qui représente le champ identifié par le jeton de métadonnées spécifié.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> n'est pas un jeton de champ dans la portée du module actuel.

ou -
<paramref name="metadataToken" /> identifie un champ dont le <see langword="TypeSpec" /> parent a une signature contenant le type d'élément <see langword="var" /> (un paramètre de type d'un type générique) ou <see langword="mvar" /> (un paramètre de type d'une méthode générique), et les arguments de type générique nécessaires n'ont pas été fournis pour <paramref name="genericTypeArguments" /> ou <paramref name="genericMethodArguments" /> (ou pour les deux).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> n'est pas un jeton valide dans la portée du module actuel.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
      <summary>Retourne le type ou le membre identifié par le jeton de métadonnées spécifié dans le contexte défini par les paramètres de type générique spécifiés.</summary>
      <param name="metadataToken">Jeton de métadonnées qui identifie un type ou un membre dans le module.</param>
      <param name="genericTypeArguments">Tableau d'objets <see cref="T:System.Type" /> représentant les arguments de type générique du type pour lequel le jeton est dans la portée, ou <see langword="null" /> si ce type n'est pas générique.</param>
      <param name="genericMethodArguments">Tableau d'objets <see cref="T:System.Type" /> représentant les arguments de type générique de la méthode pour laquelle le jeton est dans la portée, ou <see langword="null" /> si cette méthode n'est pas générique.</param>
      <returns>Objet <see cref="T:System.Reflection.MemberInfo" /> représentant le type ou le membre identifié par le jeton de métadonnées spécifié.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> n'est pas un jeton pour un type ou un membre dans la portée du module actuel.

ou -
<paramref name="metadataToken" /> est un <see langword="MethodSpec" /> ou <see langword="TypeSpec" /> dont la signature contient un type d'élément <see langword="var" /> (un paramètre de type d'un type générique) ou <see langword="mvar" /> (un paramètre de type d'une méthode générique), et les arguments de type générique nécessaires n'ont pas été fournis pour <paramref name="genericTypeArguments" /> ou <paramref name="genericMethodArguments" /> (ou pour les deux).

ou -
<paramref name="metadataToken" /> identifie une propriété ou un événement.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> n'est pas un jeton valide dans la portée du module actuel.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
      <summary>Retourne la méthode ou le constructeur identifié par le jeton de métadonnées spécifié dans le contexte défini par les paramètres de type générique spécifiés.</summary>
      <param name="metadataToken">Jeton de métadonnées qui identifie une méthode ou un constructeur dans le module.</param>
      <param name="genericTypeArguments">Tableau d'objets <see cref="T:System.Type" /> représentant les arguments de type générique du type pour lequel le jeton est dans la portée, ou <see langword="null" /> si ce type n'est pas générique.</param>
      <param name="genericMethodArguments">Tableau d'objets <see cref="T:System.Type" /> représentant les arguments de type générique de la méthode pour laquelle le jeton est dans la portée, ou <see langword="null" /> si cette méthode n'est pas générique.</param>
      <returns>Objet <see cref="T:System.Reflection.MethodBase" /> qui représente la méthode identifiée par le jeton de métadonnées spécifié.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> n'est pas un jeton pour une méthode ou un constructeur dans la portée du module en cours.

ou -
<paramref name="metadataToken" /> est un <see langword="MethodSpec" /> dont la signature contient un type d'élément <see langword="var" /> (un paramètre de type d'un type générique) ou <see langword="mvar" /> (un paramètre de type d'une méthode générique), et les arguments de type générique nécessaires n'ont pas été fournis pour <paramref name="genericTypeArguments" /> ou <paramref name="genericMethodArguments" /> (ou pour les deux).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> n'est pas un jeton valide dans la portée du module actuel.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
      <summary>Retourne le blob de signature identifié par un jeton de métadonnées.</summary>
      <param name="metadataToken">Jeton de métadonnées qui identifie une signature dans le module.</param>
      <returns>Tableau d'octets représentant le blob de signature.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" />n'est pas un <see langword="MemberRef" />, un <see langword="MethodDef" />, un <see langword="TypeSpec" />, une signature ou un jeton <see langword="FieldDef" /> valide dans la portée du module en cours.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> n'est pas un jeton valide dans la portée du module actuel.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
      <summary>Retourne la chaîne identifiée par le jeton de métadonnées spécifié.</summary>
      <param name="metadataToken">Jeton de métadonnées qui identifie une chaîne dans le tas de chaînes du module.</param>
      <returns>
        <see cref="T:System.String" /> contenant une valeur de chaîne du tas de chaînes des métadonnées.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> n'est pas un jeton pour une chaîne dans la portée du module actuel.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> n'est pas un jeton valide dans la portée du module actuel.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
      <summary>Retourne le type identifié par le jeton de métadonnées spécifié dans le contexte défini par les paramètres de type générique spécifiés.</summary>
      <param name="metadataToken">Jeton de métadonnées qui identifie un type dans le module.</param>
      <param name="genericTypeArguments">Tableau d'objets <see cref="T:System.Type" /> représentant les arguments de type générique du type pour lequel le jeton est dans la portée, ou <see langword="null" /> si ce type n'est pas générique.</param>
      <param name="genericMethodArguments">Tableau d'objets <see cref="T:System.Type" /> représentant les arguments de type générique de la méthode pour laquelle le jeton est dans la portée, ou <see langword="null" /> si cette méthode n'est pas générique.</param>
      <returns>Objet <see cref="T:System.Type" /> qui représente le type identifié par le jeton de métadonnées spécifié.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> n'est pas le jeton d'un type dans la portée du module en cours.

ou -
<paramref name="metadataToken" /> est un <see langword="TypeSpec" /> dont la signature contient un type d'élément <see langword="var" /> (un paramètre de type d'un type générique) ou <see langword="mvar" /> (un paramètre de type d'une méthode générique), et les arguments de type générique nécessaires n'ont pas été fournis pour <paramref name="genericTypeArguments" /> ou <paramref name="genericMethodArguments" /> (ou pour les deux).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> n'est pas un jeton valide dans la portée du module actuel.</exception>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.ScopeName">
      <summary>Obtient une chaîne qui représente le nom du module dynamique.</summary>
      <returns>Nom du module dynamique.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Applique un attribut personnalisé à ce module à l'aide d'un objet BLOB spécifié qui représente l'attribut.</summary>
      <param name="con">Le constructeur de l’attribut personnalisé.</param>
      <param name="binaryAttribute">Objet BLOB d'octets représentant l'attribut.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Applique un attribut personnalisé à ce module à l'aide d'un générateur d'attributs personnalisés.</summary>
      <param name="customBuilder">Instance de classe d'assistance qui spécifie l'attribut personnalisé à appliquer.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="T:System.Reflection.Emit.PropertyBuilder">
      <summary>Définit les propriétés d'un type.</summary>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.AddOtherMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Ajoute une des autres méthodes associées à cette propriété.</summary>
      <param name="mdBuilder">Objet <see langword="MethodBuilder" /> qui représente l'autre méthode.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">La méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> a été appelée sur le type englobant.</exception>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.Attributes">
      <summary>Obtient les attributs de cette propriété.</summary>
      <returns>Attributs de cette propriété.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.CanRead">
      <summary>Obtient une valeur indiquant si la propriété peut être lue.</summary>
      <returns>
        <see langword="true" /> si la propriété peut être lue ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.CanWrite">
      <summary>Obtient une valeur indiquant s'il est possible d'écrire dans la propriété.</summary>
      <returns>
        <see langword="true" /> s'il est possible d'écrire dans la propriété ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.DeclaringType">
      <summary>Obtient la classe qui déclare ce membre.</summary>
      <returns>Objet <see langword="Type" /> de la classe qui déclare ce membre.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetAccessors(System.Boolean)">
      <summary>Retourne un tableau d'accesseurs <see langword="get" /> et <see langword="set" /> publics et non publics sur cette propriété.</summary>
      <param name="nonPublic">Indique si des méthodes non publiques doivent être retournées dans le tableau <see langword="MethodInfo" />. <see langword="true" /> si les méthodes non publiques doivent être incluses ; sinon, <see langword="false" />.</param>
      <returns>Tableau de type <see langword="MethodInfo" /> contenant les accesseurs publics ou non publics correspondants ou un tableau vide s'il n'existe aucun accesseur correspondant sur cette propriété.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n'est pas prise en charge.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Retourne un tableau de tous les attributs personnalisés de cette propriété.</summary>
      <param name="inherit">Si <see langword="true" />, recherche les attributs personnalisés dans la chaîne d'héritage de cette propriété.</param>
      <returns>Tableau de tous les attributs personnalisés.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n'est pas prise en charge.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Retourne un tableau des attributs personnalisés identifiés par <see cref="T:System.Type" />.</summary>
      <param name="attributeType">Tableau d'attributs personnalisés identifiés par type.</param>
      <param name="inherit">Si <see langword="true" />, recherche les attributs personnalisés dans la chaîne d'héritage de cette propriété.</param>
      <returns>Un tableau d'attributs personnalisés définis sur ce membre réfléchi, ou <see langword="null" /> si aucun attribut n'est défini sur le membre.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n'est pas prise en charge.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetGetMethod(System.Boolean)">
      <summary>Retourne l'accesseur GET public et non public de cette propriété.</summary>
      <param name="nonPublic">Indique si des accesseurs GET non publics doivent être retournés. <see langword="true" /> si les méthodes non publiques doivent être incluses ; sinon, <see langword="false" />.</param>
      <returns>Objet <see langword="MethodInfo" /> représentant l'accesseur GET de cette propriété si <paramref name="nonPublic" /> est <see langword="true" />. Retourne <see langword="null" /> si <paramref name="nonPublic" /> est <see langword="false" /> et si l'accesseur GET est non public ou si <paramref name="nonPublic" /> est <see langword="true" /> mais qu'il n'existe pas d'accesseur GET.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetIndexParameters">
      <summary>Retourne un tableau de tous les paramètres d'index de la propriété.</summary>
      <returns>Tableau de type <see langword="ParameterInfo" /> contenant les paramètres des index.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n'est pas prise en charge.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetSetMethod(System.Boolean)">
      <summary>Retourne l'accesseur set public de cette propriété.</summary>
      <param name="nonPublic">Indique si l’accesseur doit être retourné s’il est non public. <see langword="true" /> si les méthodes non publiques doivent être incluses ; sinon, <see langword="false" />.</param>
      <returns>La méthode <see langword="Set" /> de la propriété, ou <see langword="null" />, tel qu'indiqué dans le tableau suivant.
  Value 
  Condition 
  Objet <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode Set de cette propriété.  
  
  L’accesseur set est public.  
  
 <paramref name="nonPublic" /> est true et les méthodes non publiques peuvent être retournées.  
  
  null 
 <paramref name="nonPublic" /> est true, mais la propriété est en lecture seule.  
  
 <paramref name="nonPublic" /> a la valeur false et l'accesseur set est non public.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetValue(System.Object,System.Object[])">
      <summary>Obtient la valeur de la propriété indexée en appelant la méthode de l'accesseur GET de la propriété.</summary>
      <param name="obj">Objet dont la valeur de propriété sera retournée.</param>
      <param name="index">Valeurs d'index facultatives pour les propriétés indexées. Cette valeur doit être <see langword="null" /> pour les propriétés non indexées.</param>
      <returns>Valeur de la propriété indexée spécifiée.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n'est pas prise en charge.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetValue(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>Obtient la valeur d'une propriété ayant la liaison, l'index et le <see langword="CultureInfo" /> spécifiés.</summary>
      <param name="obj">Objet dont la valeur de propriété sera retournée.</param>
      <param name="invokeAttr">Attribut d’appel. Il doit s'agir d'un bit indicateur de <see langword="BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="Static" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />. Un attribut d’appel approprié doit être spécifié. Si le membre à appeler est statique, l'indicateur <see langword="Static" /> de <see langword="BindingFlags" /> doit être défini.</param>
      <param name="binder">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <see langword="MemberInfo" /> par le biais de la réflexion. Si <paramref name="binder" /> est <see langword="null" />, le binder par défaut est utilisé.</param>
      <param name="index">Valeurs d'index facultatives pour les propriétés indexées. Cette valeur doit être <see langword="null" /> pour les propriétés non indexées.</param>
      <param name="culture">Objet <see langword="CultureInfo" /> qui représente la culture pour laquelle la ressource doit être localisée. Notez que si la ressource n'est pas localisée pour cette culture, la méthode <see langword="CultureInfo.Parent" /> sera appelée pour rechercher une correspondance. Si cette valeur est <see langword="null" />, <see langword="CultureInfo" /> est obtenu à partir de la propriété <see langword="CultureInfo.CurrentUICulture" />.</param>
      <returns>Valeur de propriété pour <paramref name="obj" />.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n'est pas prise en charge.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Indique si une ou plusieurs instances de <paramref name="attributeType" /> sont définies sur cette propriété.</summary>
      <param name="attributeType">Objet <see langword="Type" /> auquel les attributs personnalisés sont appliqués.</param>
      <param name="inherit">Spécifie s'il faut rechercher les attributs personnalisés dans la chaîne d'héritage de cette propriété.</param>
      <returns>
        <see langword="true" /> si une ou plusieurs instances de <paramref name="attributeType" /> sont définies sur cette propriété ; sinon <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n'est pas prise en charge.</exception>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.Module">
      <summary>Obtient le module dans lequel le type qui déclare la propriété actuelle est défini.</summary>
      <returns>
        <see cref="T:System.Reflection.Module" /> dans lequel le type qui déclare la propriété actuelle est défini.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.Name">
      <summary>Obtient le nom de ce membre.</summary>
      <returns>
        <see cref="T:System.String" /> contenant le nom de ce membre.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.PropertyType">
      <summary>Obtient le type du champ de cette propriété.</summary>
      <returns>Type de cette propriété.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.ReflectedType">
      <summary>Obtient l'objet classe utilisé pour obtenir cette instance de <see langword="MemberInfo" />.</summary>
      <returns>Objet <see langword="Type" /> via lequel cet objet <see langword="MemberInfo" /> a été obtenu.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetConstant(System.Object)">
      <summary>Définit la valeur par défaut de cette propriété.</summary>
      <param name="defaultValue">Valeur par défaut de cette propriété.</param>
      <exception cref="T:System.InvalidOperationException">La méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> a été appelée sur le type englobant.</exception>
      <exception cref="T:System.ArgumentException">La propriété ne correspond pas à un type pris en charge.

ou -
Le type de <paramref name="defaultValue" /> ne correspond pas au type de la propriété.

ou -
La propriété est de type <see cref="T:System.Object" /> ou d'un autre type référence, <paramref name="defaultValue" /> n'est pas <see langword="null" /> et la valeur ne peut pas être assignée au type référence.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Définit un attribut personnalisé à l’aide d’un objet blob d’attribut personnalisé spécifié.</summary>
      <param name="con">Le constructeur de l’attribut personnalisé.</param>
      <param name="binaryAttribute">Objet blob d’octets représentant les attributs.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">La méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> a été appelée sur le type englobant.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Définit un attribut personnalisé à l’aide d’un générateur d’attributs personnalisés.</summary>
      <param name="customBuilder">Instance d’une classe d’assistance pour définir l’attribut personnalisé.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">si <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> a été appelé sur le type englobant.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetGetMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Définit la méthode qui obtient la valeur de la propriété.</summary>
      <param name="mdBuilder">Objet <see langword="MethodBuilder" /> qui représente la méthode qui obtient la valeur de la propriété.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">La méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> a été appelée sur le type englobant.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetSetMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Définit la méthode qui définit la valeur de la propriété.</summary>
      <param name="mdBuilder">Objet <see langword="MethodBuilder" /> qui représente la méthode qui définit la valeur de la propriété.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">La méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> a été appelée sur le type englobant.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetValue(System.Object,System.Object,System.Object[])">
      <summary>Définit la valeur de la propriété avec des valeurs d'index facultatives pour les propriétés d'index.</summary>
      <param name="obj">Objet dont la valeur de propriété sera définie.</param>
      <param name="value">Nouvelle valeur de cette propriété.</param>
      <param name="index">Valeurs d'index facultatives pour les propriétés indexées. Cette valeur doit être <see langword="null" /> pour les propriétés non indexées.</param>
      <exception cref="T:System.NotSupportedException">Cette méthode n'est pas prise en charge.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>Assigne la valeur donnée à la propriété de l'objet désigné.</summary>
      <param name="obj">Objet dont la valeur de propriété sera retournée.</param>
      <param name="value">Nouvelle valeur de cette propriété.</param>
      <param name="invokeAttr">Attribut d’appel. Il doit s'agir d'un bit indicateur de <see langword="BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="Static" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />. Un attribut d’appel approprié doit être spécifié. Si le membre à appeler est statique, l'indicateur <see langword="Static" /> de <see langword="BindingFlags" /> doit être défini.</param>
      <param name="binder">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <see langword="MemberInfo" /> par le biais de la réflexion. Si <paramref name="binder" /> est <see langword="null" />, le binder par défaut est utilisé.</param>
      <param name="index">Valeurs d'index facultatives pour les propriétés indexées. Cette valeur doit être <see langword="null" /> pour les propriétés non indexées.</param>
      <param name="culture">Objet <see langword="CultureInfo" /> qui représente la culture pour laquelle la ressource doit être localisée. Notez que si la ressource n'est pas localisée pour cette culture, la méthode <see langword="CultureInfo.Parent" /> sera appelée pour rechercher une correspondance. Si cette valeur est <see langword="null" />, <see langword="CultureInfo" /> est obtenu à partir de la propriété <see langword="CultureInfo.CurrentUICulture" />.</param>
      <exception cref="T:System.NotSupportedException">Cette méthode n'est pas prise en charge.</exception>
    </member>
    <member name="T:System.Reflection.Emit.TypeBuilder">
      <summary>Définit et crée des instances de classes pendant l’exécution.</summary>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
      <summary>Ajoute une interface implémentée par ce type.</summary>
      <param name="interfaceType">Interface implémentée par ce type.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="interfaceType" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Assembly">
      <summary>Récupère l’assembly dynamique qui contient la définition de ce type.</summary>
      <returns>Lecture seule. Récupère l’assembly dynamique qui contient la définition de ce type.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
      <summary>Retourne le nom complet de ce type, qualifié par le nom complet de l'assembly.</summary>
      <returns>Lecture seule. Nom complet de ce type qualifié par le nom complet de l'assembly.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.BaseType">
      <summary>Récupère le type de base de ce type.</summary>
      <returns>Lecture seule. Récupère le type de base de ce type.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.CreateType">
      <summary>Crée un objet <see cref="T:System.Type" /> pour la classe. Après avoir défini les champs et les méthodes sur la classe, <see langword="CreateType" /> est appelé pour charger son objet <see langword="Type" />.</summary>
      <returns>Retourne le nouvel objet <see cref="T:System.Type" /> pour cette classe.</returns>
      <exception cref="T:System.InvalidOperationException">Le type englobant n’a pas été créé.

ou -

Ce type est non abstrait et contient une méthode abstraite.

ou -

Ce type n’est pas une classe abstraite ni une interface et contient une méthode sans corps de méthode.</exception>
      <exception cref="T:System.ArgumentException">Contenu d’étiquette incorrect dans <see cref="T:System.Reflection.Emit.ILGenerator" /> : Vous avez défini une étiquette sans appeler <see cref="M:System.Reflection.Emit.ILGenerator.MarkLabel(System.Reflection.Emit.Label)" />.</exception>
      <exception cref="T:System.NotSupportedException">Le type contient un code MSIL (Microsoft Intermediate Language) non valide.

ou -

La cible de branche est spécifiée à l’aide d’un offset de 1 octet, mais la cible est à une distance supérieure à 127 octets de la branche.</exception>
      <exception cref="T:System.TypeLoadException">Impossible de charger le type. Par exemple, il contient une méthode <see langword="static" /> avec la convention d’appel <see cref="F:System.Reflection.CallingConventions.HasThis" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo">
      <summary>Obtient un objet <see cref="T:System.Reflection.TypeInfo" /> qui représente ce type.</summary>
      <returns>Objet qui représente ce type.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod">
      <summary>Obtient la méthode qui a déclaré le paramètre de type générique actuel.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodBase" /> qui représente la méthode qui a déclaré le type actuel, si celui-ci est un paramètre de type générique ; sinon, <see langword="null" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.DeclaringType">
      <summary>Retourne le type qui a déclaré ce type.</summary>
      <returns>Lecture seule. Type qui a déclaré ce type.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
      <summary>Ajoute un nouveau constructeur au type avec les attributs donnés et la signature.</summary>
      <param name="attributes">Attributs du constructeur.</param>
      <param name="callingConvention">Convention d’appel du constructeur.</param>
      <param name="parameterTypes">Types de paramètre du constructeur.</param>
      <returns>Constructeur défini.</returns>
      <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
      <summary>Ajoute un nouveau constructeur au type, avec les attributs, la signature et les modificateurs personnalisés donnés.</summary>
      <param name="attributes">Attributs du constructeur.</param>
      <param name="callingConvention">Convention d’appel du constructeur.</param>
      <param name="parameterTypes">Types de paramètre du constructeur.</param>
      <param name="requiredCustomModifiers">Tableau de tableaux de types. Chaque tableau de types représente les modificateurs personnalisés obligatoires pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un paramètre particulier ne possède pas de modificateurs personnalisés obligatoires, spécifiez <see langword="null" /> plutôt qu’un tableau de types. Si aucun paramètre ne possède de modificateur personnalisé requis, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</param>
      <param name="optionalCustomModifiers">Tableau de tableaux de types. Chaque tableau de types représente les modificateurs personnalisés facultatifs pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un paramètre particulier ne possède pas de modificateurs personnalisés facultatifs, spécifiez <see langword="null" /> plutôt qu’un tableau de types. Si aucun paramètre ne possède de modificateur personnalisé facultatif, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</param>
      <returns>Constructeur défini.</returns>
      <exception cref="T:System.ArgumentException">La taille de <paramref name="requiredCustomModifiers" /> ou <paramref name="optionalCustomModifiers" /> n’est pas égale à la taille de <paramref name="parameterTypes" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.

ou -
Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
      <summary>Définit le constructeur sans paramètre. Le constructeur défini ici appelle simplement le constructeur sans paramètre du parent.</summary>
      <param name="attributes">Objet <see langword="MethodAttributes" /> représentant les attributs à appliquer au constructeur.</param>
      <returns>Retourne le constructeur.</returns>
      <exception cref="T:System.NotSupportedException">Le type parent (type de base) n’a pas de constructeur sans paramètre.</exception>
      <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.

ou -
Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
      <summary>Ajoute un nouvel événement au type avec le nom, les attributs et le type d’événement donnés.</summary>
      <param name="name">Nom de l’événement. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="attributes">Attributs de l’événement.</param>
      <param name="eventtype">Type de l’événement.</param>
      <returns>Événement défini.</returns>
      <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.

ou -
<paramref name="eventtype" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
      <summary>Ajoute un nouveau champ au type avec les nom, attributs et type de champ donnés.</summary>
      <param name="fieldName">Nom du champ. <paramref name="fieldName" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="type">Type du champ</param>
      <param name="attributes">Attributs du champ.</param>
      <returns>Champ défini.</returns>
      <exception cref="T:System.ArgumentException">La longueur de <paramref name="fieldName" /> est égale à zéro.

ou -
<paramref name="type" /> est System.Void.

ou -
Une taille totale a été spécifiée pour la classe parente de ce champ.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="fieldName" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
      <summary>Ajoute un nouveau champ au type avec le nom, les attributs, le type de champ et les modificateurs personnalisés donnés.</summary>
      <param name="fieldName">Nom du champ. <paramref name="fieldName" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="type">Type du champ</param>
      <param name="requiredCustomModifiers">Tableau de types représentant les modificateurs personnalisés pour le champ, tels que <see cref="T:Microsoft.VisualC.IsConstModifier" />.</param>
      <param name="optionalCustomModifiers">Tableau de types représentant les modificateurs personnalisés facultatifs pour le champ, tels que <see cref="T:Microsoft.VisualC.IsConstModifier" />.</param>
      <param name="attributes">Attributs du champ.</param>
      <returns>Champ défini.</returns>
      <exception cref="T:System.ArgumentException">La longueur de <paramref name="fieldName" /> est égale à zéro.

ou -
<paramref name="type" /> est System.Void.

ou -
Une taille totale a été spécifiée pour la classe parente de ce champ.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="fieldName" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
      <summary>Définit les paramètres de type générique pour le type actuel, en spécifiant leur nombre et leurs noms, et retourne un tableau d’objets <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> pouvant être utilisés pour définir leurs contraintes.</summary>
      <param name="names">Tableau de noms de paramètres de type générique.</param>
      <returns>Tableau d’objets <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> pouvant être utilisés pour définir les contraintes des paramètres de type générique pour le type actuel.</returns>
      <exception cref="T:System.InvalidOperationException">Des paramètres de type générique ont déjà été définis pour ce type.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="names" /> a la valeur <see langword="null" />.

ou -
Un élément de <paramref name="names" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="names" /> est un tableau vide.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
      <summary>Définit un champ de données non initialisées dans la section .sdata du fichier exécutable portable (PE).</summary>
      <param name="name">Nom utilisé pour faire référence aux données. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="data">Objet blob de données.</param>
      <param name="attributes">Attributs du champ.</param>
      <returns>Champ pour référencer les données.</returns>
      <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.

ou -
La taille des données est inférieure ou égale à zéro, ou supérieure ou égale à 0x3f0000.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ou <paramref name="data" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> a été appelé précédemment.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
      <summary>Ajoute une nouvelle méthode au type, avec le nom et les attributs de méthode spécifiés.</summary>
      <param name="name">Nom de la méthode. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="attributes">Attributs de la méthode.</param>
      <returns>
        <see cref="T:System.Reflection.Emit.MethodBuilder" /> représentant la méthode récemment définie.</returns>
      <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.

ou -
Le type du parent de cette méthode est une interface, et cette méthode n’est pas virtuelle (<see langword="Overridable" /> en Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.

ou -
Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
      <summary>Ajoute une nouvelle méthode au type, avec le nom, les attributs de méthode et la convention d’appel spécifiés.</summary>
      <param name="name">Nom de la méthode. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="attributes">Attributs de la méthode.</param>
      <param name="callingConvention">Convention d’appel de la méthode.</param>
      <returns>
        <see cref="T:System.Reflection.Emit.MethodBuilder" /> représentant la méthode récemment définie.</returns>
      <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.

ou -
Le type du parent de cette méthode est une interface, et cette méthode n’est pas virtuelle (<see langword="Overridable" /> en Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.

ou -
Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary>Ajoute une nouvelle méthode au type, avec le nom, les attributs de méthode, la convention d’appel et la signature de méthode spécifiés.</summary>
      <param name="name">Nom de la méthode. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="attributes">Attributs de la méthode.</param>
      <param name="callingConvention">Convention d’appel de la méthode.</param>
      <param name="returnType">Type de retour de la méthode.</param>
      <param name="parameterTypes">Types des paramètres de la méthode.</param>
      <returns>
        <see cref="T:System.Reflection.Emit.MethodBuilder" /> représentant la méthode récemment définie.</returns>
      <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.

ou -
Le type du parent de cette méthode est une interface, et cette méthode n’est pas virtuelle (<see langword="Overridable" /> en Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.

ou -
Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>Ajoute une nouvelle méthode au type avec les nom, attributs de méthode, convention d’appel, signature de méthode et modificateurs personnalisés spécifiés.</summary>
      <param name="name">Nom de la méthode. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="attributes">Attributs de la méthode.</param>
      <param name="callingConvention">Convention d’appel de la méthode.</param>
      <param name="returnType">Type de retour de la méthode.</param>
      <param name="returnTypeRequiredCustomModifiers">Tableau de types représentant les modificateurs personnalisés requis, tels qu’<see cref="T:System.Runtime.CompilerServices.IsConst" />, pour le type de retour de la méthode. Si le type de retour ne possède pas de modificateur personnalisé requis, spécifiez <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers">Tableau de types représentant les modificateurs personnalisés facultatifs, tels qu’<see cref="T:System.Runtime.CompilerServices.IsConst" />, pour le type de retour de la méthode. Si le type de retour ne possède pas de modificateur personnalisé facultatif, spécifiez <see langword="null" />.</param>
      <param name="parameterTypes">Types des paramètres de la méthode.</param>
      <param name="parameterTypeRequiredCustomModifiers">Tableau de tableaux de types. Chaque tableau de types représente les modificateurs personnalisés obligatoires pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un paramètre particulier ne possède pas de modificateurs personnalisés obligatoires, spécifiez <see langword="null" /> plutôt qu’un tableau de types. Si aucun paramètre ne possède de modificateur personnalisé requis, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</param>
      <param name="parameterTypeOptionalCustomModifiers">Tableau de tableaux de types. Chaque tableau de types représente les modificateurs personnalisés facultatifs pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un paramètre particulier ne possède pas de modificateurs personnalisés facultatifs, spécifiez <see langword="null" /> plutôt qu’un tableau de types. Si aucun paramètre ne possède de modificateur personnalisé facultatif, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</param>
      <returns>Objet <see cref="T:System.Reflection.Emit.MethodBuilder" /> représentant la nouvelle méthode ajoutée.</returns>
      <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.

ou -
Le type du parent de cette méthode est une interface, et cette méthode n’est pas virtuelle (<see langword="Overridable" /> en Visual Basic).

ou -
La taille de <paramref name="parameterTypeRequiredCustomModifiers" /> ou <paramref name="parameterTypeOptionalCustomModifiers" /> n’est pas égale à la taille de <paramref name="parameterTypes" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.

ou -
Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
      <summary>Ajoute une nouvelle méthode au type, avec le nom, les attributs de méthode et la signature de méthode spécifiés.</summary>
      <param name="name">Nom de la méthode. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="attributes">Attributs de la méthode.</param>
      <param name="returnType">Type de retour de la méthode.</param>
      <param name="parameterTypes">Types des paramètres de la méthode.</param>
      <returns>Méthode définie.</returns>
      <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.

ou -
Le type du parent de cette méthode est une interface, et cette méthode n’est pas virtuelle (<see langword="Overridable" /> en Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.

ou -
Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
      <summary>Spécifie un corps de méthode donné qui implémente une déclaration de méthode donnée, éventuellement avec un nom différent.</summary>
      <param name="methodInfoBody">Corps de méthode à utiliser. Il doit s’agir d’un objet <see langword="MethodBuilder" /> .</param>
      <param name="methodInfoDeclaration">Méthode dont la déclaration doit être utilisée.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="methodInfoBody" /> n’appartient pas à cette classe.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="methodInfoBody" /> ou <paramref name="methodInfoDeclaration" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.

ou -
Le type déclarant de <paramref name="methodInfoBody" /> n’est pas le type représenté par ce <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
      <summary>Définit un type imbriqué, en fonction de son nom.</summary>
      <param name="name">Nom court du type. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <returns>Type imbriqué défini.</returns>
      <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro ou supérieure à 1023.

ou -
Cette opération permet de créer un type avec un <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> en double dans l’assembly actuel.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
      <summary>Définit un type imbriqué, en fonction de son nom et de ses attributs.</summary>
      <param name="name">Nom court du type. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="attr">Attributs du type.</param>
      <returns>Type imbriqué défini.</returns>
      <exception cref="T:System.ArgumentException">L’attribut imbriqué n’est pas spécifié.

ou -
Ce type est scellé.

ou -
Ce type est un tableau.

ou -
Ce type est une interface, mais le type imbriqué n’est pas une interface.

ou -
La longueur de <paramref name="name" /> est égale à zéro ou supérieure à 1 023.

ou -
Cette opération permet de créer un type avec un <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> en double dans l’assembly actuel.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
      <summary>Définit un type imbriqué, en fonction de son nom, de ses attributs et du type qu’il étend.</summary>
      <param name="name">Nom court du type. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="attr">Attributs du type.</param>
      <param name="parent">Type étendu par le type imbriqué.</param>
      <returns>Type imbriqué défini.</returns>
      <exception cref="T:System.ArgumentException">L’attribut imbriqué n’est pas spécifié.

ou -
Ce type est scellé.

ou -
Ce type est un tableau.

ou -
Ce type est une interface, mais le type imbriqué n’est pas une interface.

ou -
La longueur de <paramref name="name" /> est égale à zéro ou supérieure à 1 023.

ou -
Cette opération permet de créer un type avec un <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> en double dans l’assembly actuel.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
      <summary>Définit un type imbriqué, en fonction de son nom, de ses attributs, de la taille totale du type et du type qu’il étend.</summary>
      <param name="name">Nom court du type. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="attr">Attributs du type.</param>
      <param name="parent">Type étendu par le type imbriqué.</param>
      <param name="typeSize">Taille totale du type.</param>
      <returns>Type imbriqué défini.</returns>
      <exception cref="T:System.ArgumentException">L’attribut imbriqué n’est pas spécifié.

ou -
Ce type est scellé.

ou -
Ce type est un tableau.

ou -
Ce type est une interface, mais le type imbriqué n’est pas une interface.

ou -
La longueur de <paramref name="name" /> est égale à zéro ou supérieure à 1 023.

ou -
Cette opération permet de créer un type avec un <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> en double dans l’assembly actuel.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
      <summary>Définit un type imbriqué, en fonction de son nom, de ses attributs, du type qu’il étend et de la taille de compression.</summary>
      <param name="name">Nom court du type. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="attr">Attributs du type.</param>
      <param name="parent">Type étendu par le type imbriqué.</param>
      <param name="packSize">Taille de compression du type.</param>
      <returns>Type imbriqué défini.</returns>
      <exception cref="T:System.ArgumentException">L’attribut imbriqué n’est pas spécifié.

ou -
Ce type est scellé.

ou -
Ce type est un tableau.

ou -
Ce type est une interface, mais le type imbriqué n’est pas une interface.

ou -
La longueur de <paramref name="name" /> est égale à zéro ou supérieure à 1 023.

ou -
Cette opération permet de créer un type avec un <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> en double dans l’assembly actuel.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
      <summary>Définit un type imbriqué, en fonction de ses nom, attributs, taille et du type qu’il étend.</summary>
      <param name="name">Nom court du type. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="attr">Attributs du type.</param>
      <param name="parent">Type étendu par le type imbriqué.</param>
      <param name="packSize">Taille de compression du type.</param>
      <param name="typeSize">Taille totale du type.</param>
      <returns>Type imbriqué défini.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
      <summary>Définit un type imbriqué, en fonction de son nom, de ses attributs, du type qu’il étend et des interfaces qu’il implémente.</summary>
      <param name="name">Nom court du type. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="attr">Attributs du type.</param>
      <param name="parent">Type étendu par le type imbriqué.</param>
      <param name="interfaces">Interfaces implémentées par le type imbriqué.</param>
      <returns>Type imbriqué défini.</returns>
      <exception cref="T:System.ArgumentException">L’attribut imbriqué n’est pas spécifié.

ou -
Ce type est scellé.

ou -
Ce type est un tableau.

ou -
Ce type est une interface, mais le type imbriqué n’est pas une interface.

ou -
La longueur de <paramref name="name" /> est égale à zéro ou supérieure à 1 023.

ou -
Cette opération permet de créer un type avec un <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> en double dans l’assembly actuel.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.

ou -
Un élément du tableau <paramref name="interfaces" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary>Définit une méthode <see langword="PInvoke" /> en fonction de son nom, du nom de la DLL dans laquelle elle est définie, des attributs de la méthode, de sa convention d’appel, de son type de retour, des types de ses paramètres et des indicateurs <see langword="PInvoke" />.</summary>
      <param name="name">Nom de la méthode <see langword="PInvoke" />. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="dllName">Nom de la DLL dans laquelle la méthode <see langword="PInvoke" /> est définie.</param>
      <param name="attributes">Attributs de la méthode.</param>
      <param name="callingConvention">Convention d’appel de la méthode.</param>
      <param name="returnType">Type de retour de la méthode.</param>
      <param name="parameterTypes">Types des paramètres de la méthode.</param>
      <param name="nativeCallConv">Convention d’appel native.</param>
      <param name="nativeCharSet">Jeu de caractères natif de la méthode.</param>
      <returns>Méthode <see langword="PInvoke" /> définie.</returns>
      <exception cref="T:System.ArgumentException">La méthode n’est pas statique.

ou -
Le type parent est une interface.

ou -
La méthode est de type abstract.

ou -
La méthode a déjà été définie.

ou -
La longueur de <paramref name="name" /> ou <paramref name="dllName" /> est de zéro.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ou <paramref name="dllName" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le type conteneur a déjà été créé à l’aide de <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary>Définit une méthode <see langword="PInvoke" /> en fonction de son nom, du nom de la DLL dans laquelle elle est définie, du nom du point d’entrée, des attributs de la méthode, de sa convention d’appel, de son type de retour, des types de ses paramètres et des indicateurs <see langword="PInvoke" />.</summary>
      <param name="name">Nom de la méthode <see langword="PInvoke" />. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="dllName">Nom de la DLL dans laquelle la méthode <see langword="PInvoke" /> est définie.</param>
      <param name="entryName">Nom du point d’entrée dans la DLL.</param>
      <param name="attributes">Attributs de la méthode.</param>
      <param name="callingConvention">Convention d’appel de la méthode.</param>
      <param name="returnType">Type de retour de la méthode.</param>
      <param name="parameterTypes">Types des paramètres de la méthode.</param>
      <param name="nativeCallConv">Convention d’appel native.</param>
      <param name="nativeCharSet">Jeu de caractères natif de la méthode.</param>
      <returns>Méthode <see langword="PInvoke" /> définie.</returns>
      <exception cref="T:System.ArgumentException">La méthode n’est pas statique.

ou -
Le type parent est une interface.

ou -
La méthode est de type abstract.

ou -
La méthode a déjà été définie.

ou -
La longueur de <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> est égale à zéro.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le type conteneur a déjà été créé à l’aide de <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][])">
      <summary>Définit une méthode <see langword="PInvoke" /> en fonction de son nom, du nom de la DLL dans laquelle elle est définie, du nom du point d’entrée, des attributs de la méthode, de sa convention d’appel, de son type de retour, des types de ses paramètres, des indicateurs <see langword="PInvoke" /> et des modificateurs personnalisés des paramètres et du type de retour.</summary>
      <param name="name">Nom de la méthode <see langword="PInvoke" />. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="dllName">Nom de la DLL dans laquelle la méthode <see langword="PInvoke" /> est définie.</param>
      <param name="parameterTypeOptionalCustomModifiers">Tableau de tableaux de types. Chaque tableau de types représente les modificateurs personnalisés facultatifs pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un paramètre particulier ne possède pas de modificateurs personnalisés facultatifs, spécifiez <see langword="null" /> plutôt qu’un tableau de types. Si aucun paramètre ne possède de modificateur personnalisé facultatif, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</param>
      <param name="nativeCallConv">Convention d’appel native.</param>
      <param name="nativeCharSet">Jeu de caractères natif de la méthode.</param>
      <param name="entryName">Nom du point d’entrée dans la DLL.</param>
      <param name="attributes">Attributs de la méthode.</param>
      <param name="callingConvention">Convention d’appel de la méthode.</param>
      <param name="returnType">Type de retour de la méthode.</param>
      <param name="returnTypeRequiredCustomModifiers">Tableau de types représentant les modificateurs personnalisés requis, tels qu’<see cref="T:System.Runtime.CompilerServices.IsConst" />, pour le type de retour de la méthode. Si le type de retour ne possède pas de modificateur personnalisé requis, spécifiez <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers">Tableau de types représentant les modificateurs personnalisés facultatifs, tels qu’<see cref="T:System.Runtime.CompilerServices.IsConst" />, pour le type de retour de la méthode. Si le type de retour ne possède pas de modificateur personnalisé facultatif, spécifiez <see langword="null" />.</param>
      <param name="parameterTypes">Types des paramètres de la méthode.</param>
      <param name="parameterTypeRequiredCustomModifiers">Tableau de tableaux de types. Chaque tableau de types représente les modificateurs personnalisés obligatoires pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un paramètre particulier ne possède pas de modificateurs personnalisés obligatoires, spécifiez <see langword="null" /> plutôt qu’un tableau de types. Si aucun paramètre ne possède de modificateur personnalisé requis, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</param>
      <returns>
        <see cref="T:System.Reflection.Emit.MethodBuilder" /> représentant la méthode <see langword="PInvoke" /> définie.</returns>
      <exception cref="T:System.ArgumentException">La méthode n’est pas statique.

ou -
Le type parent est une interface.

ou -
La méthode est de type abstract.

ou -
La méthode a déjà été définie.

ou -
La longueur de <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> est égale à zéro.

ou -
La taille de <paramref name="parameterTypeRequiredCustomModifiers" /> ou <paramref name="parameterTypeOptionalCustomModifiers" /> n’est pas égale à la taille de <paramref name="parameterTypes" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.

ou -
Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary>Ajoute une nouvelle propriété au type avec le nom, les attributs, la convention d’appel et la signature de propriété spécifiés.</summary>
      <param name="name">Nom de la propriété. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="attributes">Attributs de la propriété.</param>
      <param name="callingConvention">Convention d’appel des accesseurs de propriété.</param>
      <param name="returnType">Type de retour de la propriété.</param>
      <param name="parameterTypes">Types des paramètres de la propriété.</param>
      <returns>Propriété définie.</returns>
      <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.

ou -
Un des éléments du tableau <paramref name="parameterTypes" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>Ajoute une nouvelle propriété au type avec le nom, la convention d’appel, la signature de propriété et les modificateurs personnalisés spécifiés.</summary>
      <param name="name">Nom de la propriété. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="attributes">Attributs de la propriété.</param>
      <param name="callingConvention">Convention d’appel des accesseurs de propriété.</param>
      <param name="returnType">Type de retour de la propriété.</param>
      <param name="returnTypeRequiredCustomModifiers">Tableau de types représentant les modificateurs personnalisés obligatoires, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />, pour le type de retour de la propriété. Si le type de retour ne possède pas de modificateur personnalisé requis, spécifiez <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers">Tableau de types représentant les modificateurs personnalisés facultatifs, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />, pour le type de retour de la propriété. Si le type de retour ne possède pas de modificateur personnalisé facultatif, spécifiez <see langword="null" />.</param>
      <param name="parameterTypes">Types des paramètres de la propriété.</param>
      <param name="parameterTypeRequiredCustomModifiers">Tableau de tableaux de types. Chaque tableau de types représente les modificateurs personnalisés obligatoires pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un paramètre particulier ne possède pas de modificateurs personnalisés obligatoires, spécifiez <see langword="null" /> plutôt qu’un tableau de types. Si aucun paramètre ne possède de modificateur personnalisé requis, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</param>
      <param name="parameterTypeOptionalCustomModifiers">Tableau de tableaux de types. Chaque tableau de types représente les modificateurs personnalisés facultatifs pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un paramètre particulier ne possède pas de modificateurs personnalisés facultatifs, spécifiez <see langword="null" /> plutôt qu’un tableau de types. Si aucun paramètre ne possède de modificateur personnalisé facultatif, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</param>
      <returns>Propriété définie.</returns>
      <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.

ou -
Un des éléments du tableau <paramref name="parameterTypes" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
      <summary>Ajoute une nouvelle propriété au type avec le nom et la signature de propriété donnés.</summary>
      <param name="name">Nom de la propriété. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="attributes">Attributs de la propriété.</param>
      <param name="returnType">Type de retour de la propriété.</param>
      <param name="parameterTypes">Types des paramètres de la propriété.</param>
      <returns>Propriété définie.</returns>
      <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.

ou -
Un des éléments du tableau <paramref name="parameterTypes" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>Ajoute une nouvelle propriété au type, avec le nom, la signature de propriété et les modificateurs personnalisés donnés.</summary>
      <param name="name">Nom de la propriété. <paramref name="name" /> ne peut pas contenir de valeurs null imbriquées.</param>
      <param name="attributes">Attributs de la propriété.</param>
      <param name="returnType">Type de retour de la propriété.</param>
      <param name="returnTypeRequiredCustomModifiers">Tableau de types représentant les modificateurs personnalisés obligatoires, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />, pour le type de retour de la propriété. Si le type de retour ne possède pas de modificateur personnalisé requis, spécifiez <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers">Tableau de types représentant les modificateurs personnalisés facultatifs, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />, pour le type de retour de la propriété. Si le type de retour ne possède pas de modificateur personnalisé facultatif, spécifiez <see langword="null" />.</param>
      <param name="parameterTypes">Types des paramètres de la propriété.</param>
      <param name="parameterTypeRequiredCustomModifiers">Tableau de tableaux de types. Chaque tableau de types représente les modificateurs personnalisés obligatoires pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un paramètre particulier ne possède pas de modificateurs personnalisés obligatoires, spécifiez <see langword="null" /> plutôt qu’un tableau de types. Si aucun paramètre ne possède de modificateur personnalisé requis, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</param>
      <param name="parameterTypeOptionalCustomModifiers">Tableau de tableaux de types. Chaque tableau de types représente les modificateurs personnalisés facultatifs pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un paramètre particulier ne possède pas de modificateurs personnalisés facultatifs, spécifiez <see langword="null" /> plutôt qu’un tableau de types. Si aucun paramètre ne possède de modificateur personnalisé facultatif, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</param>
      <returns>Propriété définie.</returns>
      <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.

ou -
Un des éléments du tableau <paramref name="parameterTypes" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
      <summary>Définit l’initialiseur de ce type.</summary>
      <returns>Retourne un initialiseur de type.</returns>
      <exception cref="T:System.InvalidOperationException">Le type conteneur a déjà été créé à l’aide de <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
      <summary>Définit un champ de données non initialisé dans la section <see langword=".sdata" /> du fichier exécutable portable (PE).</summary>
      <param name="name">Nom utilisé pour faire référence aux données. <paramref name="name" /> ne peut pas contenir des valeurs Null imbriquées.</param>
      <param name="size">Taille du champ de données.</param>
      <param name="attributes">Attributs du champ.</param>
      <returns>Champ pour référencer les données.</returns>
      <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.

ou -
<paramref name="size" /> est inférieur ou égal à zéro, ou supérieur ou égal à 0x003f0000.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.FullName">
      <summary>Récupère le chemin complet de ce type.</summary>
      <returns>Lecture seule. Récupère le chemin complet de ce type.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes">
      <summary>Obtient une valeur qui indique la covariance et les contraintes spéciales du paramètre de type générique actuel.</summary>
      <returns>Combinaison d'opérations de bits de valeurs <see cref="T:System.Reflection.GenericParameterAttributes" /> qui décrit la covariance et les contraintes spéciales du paramètre de type générique actuel.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
      <summary>Obtient la position d’un paramètre de type dans la liste des paramètres de type du type générique qui a déclaré le paramètre.</summary>
      <returns>Si l’objet courant <see cref="T:System.Reflection.Emit.TypeBuilder" /> représente un paramètre de type générique, la position du paramètre de type dans la liste des paramètres de type du type générique qui a déclaré le paramètre ; sinon, non défini.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
      <summary>Retourne le constructeur du type générique construit spécifié qui correspond au constructeur spécifié de la définition de type générique.</summary>
      <param name="type">Type générique construit dont le constructeur est retourné.</param>
      <param name="constructor">Constructeur sur la définition de type générique de <paramref name="type" />, qui spécifie le constructeur de <paramref name="type" /> à retourner.</param>
      <returns>Objet <see cref="T:System.Reflection.ConstructorInfo" /> qui représente le constructeur de <paramref name="type" /> correspondant à <paramref name="constructor" />, qui spécifie un constructeur appartenant à la définition de type générique de <paramref name="type" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> ne représente pas un type générique.

ou -
<paramref name="type" /> n'est pas de type <see cref="T:System.Reflection.Emit.TypeBuilder" />.

ou -
Le type déclarant de <paramref name="constructor" /> n’est pas une définition de type générique.

ou -
Le type déclarant de <paramref name="constructor" /> n’est pas la définition de type générique de <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
      <summary>Retourne un tableau d’objets <see cref="T:System.Reflection.ConstructorInfo" /> représentant les constructeurs publics et non publics définis pour cette classe, comme spécifié.</summary>
      <param name="bindingAttr">Il doit s’agir d’un indicateur de bit issu de <see cref="T:System.Reflection.BindingFlags" />, comme dans <see langword="InvokeMethod" />, <see langword="NonPublic" /> et ainsi de suite.</param>
      <returns>Retourne un tableau d’objets <see cref="T:System.Reflection.ConstructorInfo" /> représentant les constructeurs spécifiés définis pour cette classe. Si aucun constructeur n’est défini, un tableau vide est retourné.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Retourne tous les attributs personnalisés définis pour ce type.</summary>
      <param name="inherit">Spécifie s’il faut rechercher les attributs dans la chaîne d’héritage de ce membre.</param>
      <returns>Retourne un tableau d’objets représentant tous les attributs personnalisés de ce type.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge pour l’instant pour les types incomplets. Récupérez le type à l’aide de <see cref="M:System.Type.GetType" /> et appelez <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> sur le <see cref="T:System.Type" /> retourné.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Retourne tous les attributs personnalisés du type actuel qui peuvent être assignés à un type spécifié.</summary>
      <param name="attributeType">Type d’attribut à rechercher. Seuls les attributs qui peuvent être assignés à ce type sont retournés.</param>
      <param name="inherit">Spécifie s’il faut rechercher les attributs dans la chaîne d’héritage de ce membre.</param>
      <returns>Tableau d’attributs personnalisés définis sur le type actuel.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge pour l’instant pour les types incomplets. Récupérez la méthode à l’aide de <see cref="M:System.Type.GetType" /> et appelez <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> sur le <see cref="T:System.Type" />retourné.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Le type doit être un type fourni par le système runtime sous-jacent.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetElementType">
      <summary>L'appel de cette méthode lève toujours <see cref="T:System.NotSupportedException" />.</summary>
      <returns>Cette méthode n'est pas prise en charge. Aucune valeur n'est retournée.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n'est pas prise en charge.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
      <summary>Retourne l’événement avec le nom spécifié.</summary>
      <param name="name">Nom de l’événement à rechercher.</param>
      <param name="bindingAttr">Combinaison de bits de valeurs <see cref="T:System.Reflection.BindingFlags" /> qui limite la recherche.</param>
      <returns>Objet <see cref="T:System.Reflection.EventInfo" /> représentant l’événement déclaré ou hérité par ce type avec le nom spécifié, ou <see langword="null" /> s’il n’existe aucune correspondance.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetEvents">
      <summary>Retourne les événements publics déclarés ou hérités par ce type.</summary>
      <returns>Retourne un tableau d’objets <see cref="T:System.Reflection.EventInfo" /> représentant les événements publics déclarés ou hérités par ce type. Un tableau vide est retourné s’il n’existe aucun événement public.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
      <summary>Retourne les événements publics et non publics déclarés par ce type.</summary>
      <param name="bindingAttr">Combinaison de bits de valeurs <see cref="T:System.Reflection.BindingFlags" /> qui limite la recherche.</param>
      <returns>Retourne un tableau d’objets <see cref="T:System.Reflection.EventInfo" /> représentant les événements déclarés ou hérités par ce type et correspondant aux indicateurs de liaison spécifiés. Un tableau vide est retourné s’il n’existe aucun événement correspondant.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary>Retourne le champ spécifié par le nom donné.</summary>
      <param name="name">Nom du champ à obtenir.</param>
      <param name="bindingAttr">Il doit s’agir d’un indicateur de bit issu de <see cref="T:System.Reflection.BindingFlags" />, comme dans <see langword="InvokeMethod" />, <see langword="NonPublic" /> et ainsi de suite.</param>
      <returns>Retourne l’objet <see cref="T:System.Reflection.FieldInfo" /> représentant le champ déclaré ou hérité par ce type avec le nom spécifié et le modificateur public ou non public. En l’absence de modèles de correspondance, <see langword="null" /> est retourné.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
      <summary>Retourne le champ du type générique construit spécifié qui correspond au champ spécifié de la définition de type générique.</summary>
      <param name="type">Type générique construit dont la méthode est retournée.</param>
      <param name="field">Champ sur la définition de type générique de <paramref name="type" />, qui spécifie le champ de <paramref name="type" /> à retourner.</param>
      <returns>Objet <see cref="T:System.Reflection.FieldInfo" /> qui représente le champ de <paramref name="type" /> correspondant à <paramref name="field" />, qui spécifie un champ appartenant à la définition de type générique de <paramref name="type" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> ne représente pas un type générique.

ou -
<paramref name="type" /> n'est pas de type <see cref="T:System.Reflection.Emit.TypeBuilder" />.

ou -
Le type déclarant de <paramref name="field" /> n’est pas une définition de type générique.

ou -
Le type déclarant de <paramref name="field" /> n’est pas la définition de type générique de <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary>Retourne les champs publics et non publics déclarés par ce type.</summary>
      <param name="bindingAttr">Il doit s’agir d’un bit indicateur issu de <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Retourne un tableau d’objets <see cref="T:System.Reflection.FieldInfo" /> représentant les champs publics et non publics déclarés ou hérités par ce type. Un tableau vide est retourné s’il n’existe aucun champ, comme indiqué.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
      <summary>Retourne un tableau d’objets <see cref="T:System.Type" /> qui représentent les arguments de type d’un type générique ou les paramètres de type d’une définition de type générique.</summary>
      <returns>Tableau d'objets <see cref="T:System.Type" />. Les éléments du tableau représentent les arguments de type d’un type générique ou les paramètres de type d’une définition de type générique.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
      <summary>Retourne un objet <see cref="T:System.Type" /> qui représente une définition de type générique à partir de laquelle le type actuel peut être obtenu.</summary>
      <returns>Objet <see cref="T:System.Type" /> qui représente une définition de type générique à partir de laquelle le type actuel peut être obtenu.</returns>
      <exception cref="T:System.InvalidOperationException">Le type actuel n’est pas générique. Autrement dit, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> retourne <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
      <summary>Retourne l’interface implémentée (directement ou indirectement) par cette classe avec le nom qualifié complet correspondant au nom de l’interface donnée.</summary>
      <param name="name">Nom de l’interface.</param>
      <param name="ignoreCase">Si <see langword="true" />, la recherche ne respecte pas la casse. Si <see langword="false" />, la recherche respecte la casse.</param>
      <returns>Retourne un objet <see cref="T:System.Type" /> représentant l’interface implémentée. Retourne null si aucun nom d’interface correspondant n’est trouvé.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
      <summary>Retourne un mappage d’interface pour l’interface demandée.</summary>
      <param name="interfaceType">
        <see cref="T:System.Type" /> de l’interface pour laquelle le mappage doit être récupéré.</param>
      <returns>Retourne le mappage d’interface demandé.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetInterfaces">
      <summary>Retourne un tableau de toutes les interfaces implémentées sur ce type et ses types de base.</summary>
      <returns>Retourne un tableau d’objets <see cref="T:System.Type" /> représentant les interfaces implémentées. Si aucune interface n’est définie, un tableau vide est retourné.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
      <summary>Retourne tous les membres publics et non publics déclarés ou hérités par ce type, comme indiqué.</summary>
      <param name="name">Nom du membre.</param>
      <param name="type">Type du membre à retourner.</param>
      <param name="bindingAttr">Il doit s’agir d’un bit indicateur issu de <see cref="T:System.Reflection.BindingFlags" />, comme dans <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Retourne un tableau d’objets <see cref="T:System.Reflection.MemberInfo" /> représentant les membres publics et non publics définis sur ce type si <paramref name="nonPublic" /> est utilisé ; sinon, seuls les membres publics sont retournés.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
      <summary>Retourne les membres publics et non publics déclarés ou hérités par ce type.</summary>
      <param name="bindingAttr">Il doit s’agir d’un bit indicateur issu de <see cref="T:System.Reflection.BindingFlags" />, comme <see langword="InvokeMethod" />, <see langword="NonPublic" /> et ainsi de suite.</param>
      <returns>Retourne un tableau d’objets <see cref="T:System.Reflection.MemberInfo" /> représentant les membres publics et non publics déclarés ou hérités par ce type. Un tableau vide est retourné s’il n’existe aucun membre correspondant.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
      <summary>Retourne la méthode du type générique construit spécifié qui correspond à la méthode spécifiée de la définition de type générique.</summary>
      <param name="type">Type générique construit dont la méthode est retournée.</param>
      <param name="method">Méthode sur la définition de type générique de <paramref name="type" />, qui spécifie la méthode de <paramref name="type" /> à retourner.</param>
      <returns>Objet <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode de <paramref name="type" /> correspondant à <paramref name="method" />, qui spécifie une méthode appartenant à la définition de type générique de <paramref name="type" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> est une méthode générique qui n’est pas une définition de méthode générique.

ou -
<paramref name="type" /> ne représente pas un type générique.

ou -
<paramref name="type" /> n'est pas de type <see cref="T:System.Reflection.Emit.TypeBuilder" />.

ou -
Le type déclarant de <paramref name="method" /> n’est pas une définition de type générique.

ou -
Le type déclarant de <paramref name="method" /> n’est pas la définition de type générique de <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary>Retourne toutes les méthodes publiques et non publiques déclarées ou héritées par ce type, comme spécifié.</summary>
      <param name="bindingAttr">Il doit s’agir d’un indicateur de bit issu de <see cref="T:System.Reflection.BindingFlags" />, comme dans <see langword="InvokeMethod" />, <see langword="NonPublic" /> et ainsi de suite.</param>
      <returns>Retourne un tableau d’objets <see cref="T:System.Reflection.MethodInfo" /> représentant les méthodes publiques et non publiques définies sur ce type si <paramref name="nonPublic" /> est utilisé ; sinon, seules les méthodes publiques sont retournées.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
      <summary>Retourne les types imbriqués publics et non publics déclarés par ce type.</summary>
      <param name="name">
        <see cref="T:System.String" /> contenant le nom du type imbriqué à obtenir.</param>
      <param name="bindingAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.

ou -
Zéro, pour rechercher les méthodes publiques en respectant la casse.</param>
      <returns>Objet <see cref="T:System.Type" /> qui représente le type imbriqué correspondant aux critères spécifiés, s’il est trouvé ; sinon, <see langword="null" />.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
      <summary>Retourne les types imbriqués publics et non publics déclarés ou hérités par ce type.</summary>
      <param name="bindingAttr">Il doit s’agir d’un bit indicateur issu de <see cref="T:System.Reflection.BindingFlags" />, comme dans <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Tableau d’objets <see cref="T:System.Type" /> représentant tous les types imbriqués dans le <see cref="T:System.Type" /> actuel qui correspondent aux contraintes de liaison spécifiées.
Tableau vide du type <see cref="T:System.Type" /> si aucun type n’est imbriqué dans le <see cref="T:System.Type" /> actuel ou si aucun des types imbriqués ne correspond aux contraintes de liaison.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
      <summary>Retourne toutes les propriétés publiques et non publiques déclarées ou héritées par ce type, comme spécifié.</summary>
      <param name="bindingAttr">Attribut de cet appel. Il doit s’agir d’un bit indicateur issu de <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Retourne un tableau d’objets <see langword="PropertyInfo" /> représentant les propriétés publiques et non publiques définies sur ce type si <paramref name="nonPublic" /> est utilisé ; sinon, seules les propriétés publiques sont retournées.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.GUID">
      <summary>Récupère le GUID de ce type.</summary>
      <returns>Lecture seule. Récupère le GUID de ce type.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge pour l’instant pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
      <summary>Appelle le membre spécifié. La méthode à appeler doit être accessible et fournir la correspondance la plus spécifique avec la liste d’arguments spécifiée, sous les contraintes des attributs de binder et d’appel spécifiés.</summary>
      <param name="name">Nom du membre à appeler. Il peut s’agir d’un constructeur, d’une méthode, d’une propriété ou d’un champ. Un attribut d’appel approprié doit être spécifié. Notez qu’il est possible d’appeler le membre par défaut d’une classe en passant une chaîne vide comme nom du membre.</param>
      <param name="invokeAttr">Attribut d’appel. Il doit s’agir d’un indicateur de bit issu de <see langword="BindingFlags" />.</param>
      <param name="binder">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <see langword="MemberInfo" /> par le biais de la réflexion. Si binder a la valeur <see langword="null" />, le binder par défaut est utilisé. Consultez <see cref="T:System.Reflection.Binder" />.</param>
      <param name="target">Objet sur lequel appeler le membre spécifié. Si le membre est statique, ce paramètre est ignoré.</param>
      <param name="args">Liste d’arguments. Il s’agit d’un tableau d’objets contenant le nombre, l’ordre et le type des paramètres du membre à appeler. En l’absence de paramètres, il doit avoir la valeur null.</param>
      <param name="modifiers">Tableau de même longueur que <paramref name="args" /> avec des éléments qui représentent les attributs associés aux arguments du membre à appeler. Un paramètre est associé à des attributs dans les métadonnées. Elles sont utilisées par divers services d’interopérabilité. Pour plus d’informations, consultez les spécifications des métadonnées.</param>
      <param name="culture">Instance de <see langword="CultureInfo" /> utilisée pour régir la contrainte des types. Si la valeur est null, le <see langword="CultureInfo" /> du thread actuel est utilisé. (Notez que cela est nécessaire pour, par exemple, convertir une chaîne représentant 1000 en valeur double, car 1000 est représenté de différentes manières selon la culture.)</param>
      <param name="namedParameters">Chaque paramètre dans le tableau <paramref name="namedParameters" /> obtient la valeur de l’élément correspondant dans le tableau <paramref name="args" />. Si la longueur de <paramref name="args" /> est supérieure à la longueur de <paramref name="namedParameters" />, les valeurs d’argument restantes sont passées dans l’ordre.</param>
      <returns>Retourne la valeur de retour du membre appelé.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge pour l’instant pour les types incomplets.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
      <summary>Obtient une valeur qui indique si un objet <see cref="T:System.Type" /> spécifié peut être affecté à cet objet.</summary>
      <param name="c">Objet à tester.</param>
      <returns>
        <see langword="true" /> si le paramètre <paramref name="c" /> et le type actuel représentent le même type, ou si le type actuel est dans la hiérarchie d’héritage de <paramref name="c" />, ou si le type actuel est une interface prise en charge par <paramref name="c" />. <see langword="false" /> si aucune de ces conditions n’est valide, ou si <paramref name="c" /> est <see langword="null" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsByRefLike" />
    <member name="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType">
      <summary>Obtient une valeur qui indique si cet objet représente un type générique construit.</summary>
      <returns>
        <see langword="true" /> si cet objet représente un type générique construit ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsCreated">
      <summary>Retourne une valeur qui indique si le type dynamique actuel a été créé.</summary>
      <returns>
        <see langword="true" /> si la méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> a été appelée ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Détermine si un attribut personnalisé est appliqué au type actuel.</summary>
      <param name="attributeType">Type d’attribut à rechercher. Seuls les attributs qui peuvent être assignés à ce type sont retournés.</param>
      <param name="inherit">Spécifie s’il faut rechercher les attributs dans la chaîne d’héritage de ce membre.</param>
      <returns>
        <see langword="true" /> si une ou plusieurs instances de <paramref name="attributeType" />, ou un attribut dérivé de <paramref name="attributeType" />, sont définis sur ce type ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge pour l’instant pour les types incomplets. Récupérez le type à l’aide de <see cref="M:System.Type.GetType" /> et appelez <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> sur le <see cref="T:System.Type" /> retourné.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributeType" /> n’est pas défini.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter">
      <summary>Obtient une valeur indiquant si le type actuel est un paramètre de type générique.</summary>
      <returns>
        <see langword="true" /> si l’objet <see cref="T:System.Reflection.Emit.TypeBuilder" /> actuel représente un paramètre de type générique ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
      <summary>Obtient une valeur indiquant si le type actuel est un type générique.</summary>
      <returns>
        <see langword="true" /> si le type représenté par l’objet <see cref="T:System.Reflection.Emit.TypeBuilder" /> actuel est générique ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
      <summary>Obtient une valeur qui indique si le <see cref="T:System.Reflection.Emit.TypeBuilder" /> actuel représente une définition de type générique, à partir de laquelle d’autres types génériques peuvent être construits.</summary>
      <returns>
        <see langword="true" /> si cet objet <see cref="T:System.Reflection.Emit.TypeBuilder" /> représente une définition de type générique ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
      <summary>Obtient une valeur qui indique si le type actuel est critique de sécurité (security-critical) ou critique sécurisé (security-safe-critical), et peut donc effectuer des opérations critiques.</summary>
      <returns>
        <see langword="true" /> si le type actuel est critique de sécurité ou critique sécurisé ; <see langword="false" /> s’il est transparent.</returns>
      <exception cref="T:System.NotSupportedException">Le type dynamique actuel n’a pas été créé en appelant la méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
      <summary>Obtient une valeur qui indique si le type actuel est critique sécurisé, autrement dit s’il peut effectuer des opérations critiques et s’il est accessible par du code transparent.</summary>
      <returns>
        <see langword="true" /> si le type actuel est critique sécurisé ; <see langword="false" /> s’il est critique de sécurité ou transparent.</returns>
      <exception cref="T:System.NotSupportedException">Le type dynamique actuel n’a pas été créé en appelant la méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
      <summary>Obtient une valeur qui indique si le type actuel est transparent et s’il ne peut donc pas effectuer d’opérations critiques.</summary>
      <returns>
        <see langword="true" /> si le type est transparent de sécurité ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">Le type dynamique actuel n’a pas été créé en appelant la méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
      <summary>Détermine si ce type est dérivé d’un type spécifié.</summary>
      <param name="c">
        <see cref="T:System.Type" /> à vérifier.</param>
      <returns>Lecture seule. Retourne <see langword="true" /> si ce type est identique au type <paramref name="c" /> ou est un sous-type du type <paramref name="c" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSZArray" />
    <member name="P:System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
    <member name="P:System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
      <summary>Retourne un objet <see cref="T:System.Type" /> qui représente un tableau unidimensionnel du type actuel, avec une limite inférieure de zéro.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant un type de tableau unidimensionnel dont le type d’élément est le type actuel, avec une limite inférieure de zéro.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
      <summary>Retourne un objet <see cref="T:System.Type" /> qui représente un tableau du type actuel, avec le nombre spécifié de dimensions.</summary>
      <param name="rank">Nombre de dimensions pour le tableau.</param>
      <returns>Objet <see cref="T:System.Type" /> qui représente un tableau unidimensionnel du type actuel.</returns>
      <exception cref="T:System.IndexOutOfRangeException">
        <paramref name="rank" /> n’est pas une dimension de tableau valide.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
      <summary>Retourne un objet <see cref="T:System.Type" /> qui représente le type actuel quand il est passé en tant que paramètre <see langword="ref" /> (<see langword="ByRef" /> en Visual Basic).</summary>
      <returns>Objet <see cref="T:System.Type" /> qui représente le type actuel quand il est passé en tant que paramètre <see langword="ref" /> (<see langword="ByRef" /> en Visual Basic).</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
      <summary>Substitue les éléments d’un tableau de types aux paramètres de type de la définition du type générique actuel et retourne le type construit résultant.</summary>
      <param name="typeArguments">Tableau de types à substituer aux paramètres de type de la définition du type générique actuel.</param>
      <returns>
        <see cref="T:System.Type" /> représentant le type construit formé en substituant les éléments de <paramref name="typeArguments" /> pour les paramètres de type du type générique actuel.</returns>
      <exception cref="T:System.InvalidOperationException">Le type actuel ne représente pas la définition d’un type générique. Autrement dit, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> retourne <see langword="false" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArguments" /> a la valeur <see langword="null" />.

ou -
Tout élément de <paramref name="typeArguments" /> est <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Type.Module" /> de n’importe quel élément de <paramref name="typeArguments" /> est <see langword="null" />.

ou -
La propriété <see cref="P:System.Reflection.Module.Assembly" /> du module de n’importe quel élément de <paramref name="typeArguments" /> est <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
      <summary>Retourne un objet <see cref="T:System.Type" /> qui représente le type d’un pointeur non managé vers le type actuel.</summary>
      <returns>Objet <see cref="T:System.Type" /> qui représente le type d’un pointeur non managé vers le type actuel.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Module">
      <summary>Récupère le module dynamique qui contient la définition de ce type.</summary>
      <returns>Lecture seule. Récupère le module dynamique qui contient la définition de ce type.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Name">
      <summary>Récupère le nom de ce type.</summary>
      <returns>Lecture seule. Récupère le nom <see cref="T:System.String" /> de ce type.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Namespace">
      <summary>Récupère l’espace de noms dans lequel ce <see langword="TypeBuilder" /> est défini.</summary>
      <returns>Lecture seule. Récupère l’espace de noms dans lequel ce <see langword="TypeBuilder" /> est défini.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.PackingSize">
      <summary>Récupère la taille de compactage de ce type.</summary>
      <returns>Lecture seule. Récupère la taille de compactage de ce type.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.ReflectedType">
      <summary>Retourne le type qui a été utilisé pour obtenir ce type.</summary>
      <returns>Lecture seule. Type qui a été utilisé pour obtenir ce type.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Définit un attribut personnalisé à l’aide d’un objet blob d’attribut personnalisé spécifié.</summary>
      <param name="con">Le constructeur de l’attribut personnalisé.</param>
      <param name="binaryAttribute">Objet blob d’octets représentant les attributs.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> ou <paramref name="binaryAttribute" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Définit un attribut personnalisé à l’aide d’un générateur d’attributs personnalisés.</summary>
      <param name="customBuilder">Instance d’une classe d’assistance pour définir l’attribut personnalisé.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> est <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
      <summary>Définit le type de base du type actuellement en cours d’élaboration.</summary>
      <param name="parent">Nouveau type de base.</param>
      <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.

ou -
<paramref name="parent" /> a la valeur <see langword="null" />, et l’instance actuelle représente une interface dont les attributs n’incluent pas <see cref="F:System.Reflection.TypeAttributes.Abstract" />.

ou -
Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> est une interface. Cette condition d’exception est une nouveauté de .NET Framework version 2.0.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Size">
      <summary>Récupère la taille totale d’un type.</summary>
      <returns>Lecture seule. Récupère la taille totale de ce type.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.ToString">
      <summary>Retourne le nom du type sans l’espace de noms.</summary>
      <returns>Lecture seule. Nom du type sans l’espace de noms.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
      <summary>Non pris en charge dans les modules dynamiques.</summary>
      <returns>Lecture seule.</returns>
      <exception cref="T:System.NotSupportedException">Non pris en charge dans les modules dynamiques.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
      <summary>Retourne le type de système sous-jacent pour ce <see langword="TypeBuilder" />.</summary>
      <returns>Lecture seule. Retourne le type de système sous-jacent.</returns>
      <exception cref="T:System.InvalidOperationException">Ce type est une énumération, mais il n’y a pas de type de système sous-jacent.</exception>
    </member>
    <member name="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize">
      <summary>Signifie que la taille totale du type n’est pas spécifiée.</summary>
    </member>
  </members>
</doc>